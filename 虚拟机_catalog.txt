>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Java虚拟机（第2版）
前言
第一部分走近Java
第1章走近Java2
1.1概述2
1.2Java技术体系3
1.3Java发展史5
1.4Java虚拟机发展史9
1.4.1SunClassicExactVM9
1.4.2SunHotSpotVM11
1.4.3SunMobile—EmbeddedVMMeta—CircularVM12
1.4.4BEAJRockitIBMJ9VM13
1.4.5AzulVMBEALiquidVM14
1.4.6ApacheHarmonyGoogleAndroidDalvikVM14
1.4.7MicrosoftJVM及其他15
1.5展望Java技术的未来16
1.5.1模块化17
1.5.2混合语言17
1.5.3多核并行19
1.5.4进一步丰富语法20
1.5.564位虚拟机21
1.6实战：自己编译JDK22
1.6.1获取JDK源码22
1.6.2系统需求24
1.6.3构建编译环境25
1.6.4进行编译26
1.6.5在IDE工具中进行源码调试31
1.7本章小结35
第二部分自动内存管理机制
第2章Java内存区域与内存溢出异常38
2.1概述38
2.2运行时数据区域38
2.2.1程序计数器39
2.2.2Java虚拟机栈39
2.2.3本地方法栈40
2.2.4Java堆41
2.2.5方法区41
2.2.6运行时常量池42
2.2.7直接内存43
2.3HotSpot虚拟机对象探秘43
2.3.1对象的创建44
2.3.2对象的内存布局47
2.3.3对象的访问定位48
2.4实战：OutOfMemoryError异常50
2.4.1Java堆溢出51
2.4.2虚拟机栈和本地方法栈溢出53
2.4.3方法区和运行时常量池溢出56
2.4.4本机直接内存溢出59
2.5本章小结60
第3章垃圾收集器与内存分配策略61
3.1概述61
3.2对象已死吗62
3.2.1引用计数算法62
3.2.2可达性分析算法64
3.2.3再谈引用65
3.2.4生存还是死亡66
3.2.5回收方法区68
3.3垃圾收集算法69
3.3.1标记—清除算法69
3.3.2复制算法70
3.3.3标记—整理算法71
3.3.4分代收集算法72
3.4HotSpot的算法实现72
3.4.1枚举根节点72
3.4.2安全点73
3.4.3安全区域74
3.5垃圾收集器75
3.5.1Serial收集器76
3.5.2ParNew收集器77
3.5.3ParallelScavenge收集器79
3.5.4SerialOld收集器80
3.5.5ParallelOld收集器80
3.5.6CMS收集器81
3.5.7G1收集器84
3.5.8理解GC日志89
3.5.9垃圾收集器参数总结90
3.6内存分配与回收策略91
3.6.1对象优先在Eden分配91
3.6.2大对象直接进入老年代93
3.6.3长期存活的对象将进入老年代95
3.6.4动态对象年龄判定97
3.6.5空间分配担保98
3.7本章小结100
第4章虚拟机性能监控与故障处理工具101
4.1概述101
4.2JDK的命令行工具101
4.2.1jps：虚拟机进程状况工具104
4.2.2jstat：虚拟机统计信息监视工具105
4.2.3jinfo：Java配置信息工具106
4.2.4jmap：Java内存映像工具107
4.2.5jhat：虚拟机堆转储快照分析工具108
4.2.6jstack：Java堆栈跟踪工具109
4.2.7HSDIS：JIT生成代码反汇编111
4.3JDK的可视化工具114
4.3.1JConsole：Java监视与管理控制台115
4.3.2VisualVM：多合一故障处理工具122
4.4本章小结131
第5章调优案例分析与实战132
5.1概述132
5.2案例分析132
5.2.1高性能硬件上的程序部署策略132
5.2.2集群间同步导致的内存溢出135
5.2.3堆外内存导致的溢出错误136
5.2.4外部命令导致系统缓慢137
5.2.5服务器JVM进程崩溃138
5.2.6不恰当数据结构导致内存占用过大139
5.2.7由Windows虚拟内存导致的长时间停顿141
5.3实战：Eclipse运行速度调优142
5.3.1调优前的程序运行状态142
5.3.2升级JDK1.6的性能变化及兼容问题145
5.3.3编译时间和类加载时间的优化150
5.3.4调整内存设置控制垃圾收集频率153
5.3.5选择收集器降低延迟157
5.4本章小结160
第三部分虚拟机执行子系统
第6章类文件结构162
6.1概述162
6.2无关性的基石162
6.3Class类文件的结构164
6.3.1魔数与Class文件的版本166
6.3.2常量池167
6.3.3访问标志173
6.3.4类索引、父类索引与接口索引集合174
6.3.5字段表集合175
6.3.6方法表集合178
6.3.7属性表集合180
6.4字节码指令简介196
6.4.1字节码与数据类型197
6.4.2加载和存储指令199
6.4.3运算指令200
6.4.4类型转换指令202
6.4.5对象创建与访问指令203
6.4.6操作数栈管理指令203
6.4.7控制转移指令204
6.4.8方法调用和返回指令204
6.4.9异常处理指令205
6.4.10同步指令205
6.5公有设计和私有实现206
6.6Class文件结构的发展207
6.7本章小结208
第7章虚拟机类加载机制209
7.1概述209
7.2类加载的时机210
7.3类加载的过程214
7.3.1加载214
7.3.2验证216
7.3.3准备219
7.3.4解析220
7.3.5初始化225
7.4类加载器227
7.4.1类与类加载器228
7.4.2双亲委派模型229
7.4.3破坏双亲委派模型233
7.5本章小结235
第8章虚拟机字节码执行引擎236
8.1概述236
8.2运行时栈帧结构236
8.2.1局部变量表238
8.2.2操作数栈242
8.2.3动态连接243
8.2.4方法返回地址243
8.2.5附加信息244
8.3方法调用244
8.3.1解析244
8.3.2分派246
8.3.3动态类型语言支持258
8.4基于栈的字节码解释执行引擎269
8.4.1解释执行269
8.4.2基于栈的指令集与基于寄存器的指令集270
8.4.3基于栈的解释器执行过程272
8.5本章小结275
第9章类加载及执行子系统的案例与实战276
9.1概述276
9.2案例分析276
9.2.1Tomcat：正统的类加载器架构276
9.2.2OSGi：灵活的类加载器架构279
9.2.3字节码生成技术与动态代理的实现282
9.2.4Retrotranslator：跨越JDK版本286
9.3实战：自己动手实现远程执行功能289
9.3.1目标290
9.3.2思路290
9.3.3实现291
9.3.4验证298
9.4本章小结299
第四部分程序编译与代码优化
第10章早期（编译期）优化302
10.1概述302
10.2Javac编译器303
10.2.1Javac的源码与调试303
10.2.2解析与填充符号表305
10.2.3注解处理器307
10.2.4语义分析与字节码生成307
10.3Java语法糖的味道311
10.3.1泛型与类型擦除311
10.3.2自动装箱、拆箱与遍历循环315
10.3.3条件编译317
10.4实战：插入式注解处理器318
10.4.1实战目标318
10.4.2代码实现319
10.4.3运行与测试326
10.4.4其他应用案例327
10.5本章小结328
第11章晚期（运行期）优化329
11.1概述329
11.2HotSpot虚拟机内的即时编译器329
11.2.1解释器与编译器330
11.2.2编译对象与触发条件332
11.2.3编译过程337
11.2.4查看及分析即时编译结果339
11.3编译优化技术345
11.3.1优化技术概览346
11.3.2公共子表达式消除350
11.3.3数组边界检查消除351
11.3.4方法内联352
11.3.5逃逸分析354
11.4Java与C/C++的编译器对比356
11.5本章小结358
第五部分高效并发
第12章Java内存模型与线程360
12.1概述360
12.2硬件的效率与一致性361
12.3Java内存模型362
12.3.1主内存与工作内存363
12.3.2内存间交互操作364
12.3.3对于volatile型变量的特殊规则366
12.3.4对于long和double型变量的特殊规则372
12.3.5原子性、可见性与有序性373
12.3.6先行发生原则375
12.4Java与线程378
12.4.1线程的实现378
12.4.2Java线程调度381
12.4.3状态转换383
12.5本章小结384
第13章线程安全与锁优化385
13.1概述385
13.2线程安全385
13.2.1Java语言中的线程安全386
13.2.2线程安全的实现方法390
13.3锁优化397
13.3.1自旋锁与自适应自旋398
13.3.2锁消除398
13.3.3锁粗化400
13.3.4轻量级锁400
13.3.5偏向锁402
13.4本章小结403
附录
附录A编译Windows版的OpenJDK406
附录B虚拟机字节码指令表414
附录CHotSpot虚拟机主要参数表420
附录D对象查询语言（OQL）简介424
附录EJDK历史版本轨迹430
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Java虚拟机（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Java虚拟机
前　言
致　谢
第一部分　走近Java
第1章　走近Java / 2
1.1　概述 / 2
1.2　Java技术体系 / 3
1.3　Java发展史 / 5
1.4　展望Java技术的未来 / 9
1.4.1　模块化 / 9
1.4.2　混合语言 / 9
1.4.3　多核并行 / 11
1.4.4　进一步丰富语法 / 12
1.4.5　64位虚拟机 / 13
1.5　实战：自己编译JDK / 13
1.5.1　获取JDK源码 / 13
1.5.2　系统需求 / 14
1.5.3　构建编译环境 / 15
1.5.4　准备依赖项 / 17
1.5.5　进行编译 / 18
1.6　本章小结 / 21
第二部分　自动内存管理机制
第2章　Java内存区域与内存溢出异常 / 24
2.1　概述 / 24
2.2　运行时数据区域 / 25
2.2.1　程序计数器 / 25
2.2.2　Java虚拟机栈 / 26
2.2.3　本地方法栈 / 27
2.2.4　Java堆 / 27
2.2.5　方法区 / 28
2.2.6　运行时常量池 / 29
2.2.7　直接内存 / 29
2.3　对象访问 / 30
2.4　实战：OutOfMemoryError异常 / 32
2.4.1　Java堆溢出 / 32
2.4.2　虚拟机栈和本地方法栈溢出 / 35
2.4.3　运行时常量池溢出 / 38
2.4.4　方法区溢出 / 39
2.4.5　本机直接内存溢出 / 41
2.5　本章小结 / 42
第3章　垃圾收集器与内存分配策略 / 43
3.1　概述 / 43
3.2　对象已死？ / 44
3.2.1　引用计数算法 / 44
3.2.2　根搜索算法 / 46
3.2.3　再谈引用 / 47
3.2.4　生存还是死亡？ / 48
3.2.5　回收方法区 / 50
3.3　垃圾收集算法 / 51
3.3.1　标记 -清除算法 / 51
3.3.2　复制算法 / 52
3.3.3　标记-整理算法 / 54
3.3.4　分代收集算法 / 54
3.4　垃圾收集器 / 55
3.4.1　Serial收集器 / 56
3.4.2　ParNew收集器 / 57
3.4.3　Parallel Scavenge收集器 / 59
3.4.4　Serial Old收集器 / 60
3.4.5　Parallel Old收集器 / 61
3.4.6　CMS收集器 / 61
3.4.7　G1收集器 / 64
3.4.8　垃圾收集器参数总结 / 64
3.5　内存分配与回收策略 / 65
3.5.1　对象优先在Eden分配 / 66
3.5.2　大对象直接进入老年代 / 68
3.5.3　长期存活的对象将进入老年代 / 69
3.5.4　动态对象年龄判定 / 71
3.5.5　空间分配担保 / 73
3.6　本章小结 / 75
第4章　虚拟机性能监控与故障处理工具 / 76
4.1　概述 / 76
4.2　JDK的命令行工具 / 76
4.2.1　jps：虚拟机进程状况工具 / 79
4.2.2　jstat：虚拟机统计信息监视工具 / 80
4.2.3　jinfo：Java配置信息工具 / 82
4.2.4　jmap：Java内存映像工具 / 82
4.2.5　jhat：虚拟机堆转储快照分析工具 / 84
4.2.6　jstack：Java堆栈跟踪工具 / 85
4.3　JDK的可视化工具 / 87
4.3.1　JConsole：Java监视与管理控制台 / 88
4.3.2　VisualVM：多合一故障处理工具 / 96
4.4　本章小结 / 105
第5章　调优案例分析与实战 / 106
5.1　概述 / 106
5.2　案例分析 / 106
5.2.1　高性能硬件上的程序部署策略 / 106
5.2.2　集群间同步导致的内存溢出 / 109
5.2.3　堆外内存导致的溢出错误 / 110
5.2.4　外部命令导致系统缓慢 / 112
5.2.5　服务器JVM进程崩溃 / 113
5.3　实战：Eclipse运行速度调优 / 114
5.3.1　调优前的程序运行状态 / 114
5.3.2　升级JDK 1.6的性能变化及兼容问题 / 117
5.3.3　编译时间和类加载时间的优化 / 122
5.3.4　调整内存设置控制垃圾收集频率 / 126
5.3.5　选择收集器降低延迟 / 130
5.4　本章小结 / 133
第三部分　虚拟机执行子系统
第6章　类文件结构 / 136
6.1　概述 / 136
6.2　无关性的基石 / 136
6.3　Class类文件的结构 / 138
6.3.1　魔数与Class文件的版本 / 139
6.3.2　常量池 / 141
6.3.3　访问标志 / 147
6.3.4　类索引、父类索引与接口索引集合 / 148
6.3.5　字段表集合 / 149
6.3.6　方法表集合 / 153
6.3.7　属性表集合 / 155
6.4　Class文件结构的发展 / 168
6.5　本章小结 / 170
第7章　虚拟机类加载机制 / 171
7.1　概述 / 171
7.2　类加载的时机 / 172
7.3　类加载的过程 / 176
7.3.1　加载 / 176
7.3.2　验证 / 178
7.3.3　准备 / 181
7.3.4　解析 / 182
7.3.5　初始化 / 186
7.4　类加载器 / 189
7.4.1　类与类加载器 / 189
7.4.2　双亲委派模型 / 191
7.4.3　破坏双亲委派模型 / 194
7.5　本章小结 / 197
第8章　虚拟机字节码执行引擎 / 198
8.1　概述 / 198
8.2　运行时栈帧结构 / 199
8.2.1　局部变量表 / 199
8.2.2　操作数栈 / 204
8.2.3　动态连接 / 206
8.2.4　方法返回地址 / 206
8.2.5　附加信息 / 207
8.3　方法调用 / 207
8.3.1　解析 / 207
8.3.2　分派 / 209
8.4　基于栈的字节码解释执行引擎 / 221
8.4.1　解释执行 / 221
8.4.2　基于栈的指令集与基于寄存器的指令集 / 223
8.4.3　基于栈的解释器执行过程 / 224
8.5　本章小结 / 230
第9章　类加载及执行子系统的案例与实战 / 231
9.1　概述 / 231
9.2　案例分析 / 231
9.2.1　Tomcat：正统的类加载器架构 / 232
9.2.2　OSGi：灵活的类加载器架构 / 235
9.2.3　字节码生成技术与动态代理的实现 / 238
9.2.4　Retrotranslator：跨越JDK版本 / 242
9.3　实战：自己动手实现远程执行功能 / 246
9.3.1　目标 / 246
9.3.2　思路 / 247
9.3.3　实现 / 248
9.3.4　验证 / 255
9.4　本章小结 / 256
第四部分　程序编译与代码优化
第10章　早期（编译期）优化 / 258
10.1　概述 / 258
10.2　Javac编译器 / 259
10.2.1　Javac的源码与调试 / 259
10.2.2　解析与填充符号表 / 262
10.2.3　注解处理器 / 264
10.2.4　语义分析与字节码生成 / 264
10.3　Java语法糖的味道 / 268
10.3.1　泛型与类型擦除 / 268
10.3.2　自动装箱、拆箱与遍历循环 / 273
10.3.3　条件编译 / 275
10.4　实战：插入式注解处理器 / 276
10.4.1　实战目标 / 276
10.4.2　代码实现 / 277
10.4.3　运行与测试 / 284
10.4.4　其他应用案例 / 286
10.5　本章小结 / 286
第11章　晚期（运行期）优化 / 287
11.1　概述 / 287
11.2　HotSpot虚拟机内的即时编译器 / 288
11.2.1　解释器与编译器 / 288
11.2.2　编译对象与触发条件 / 291
11.2.3　编译过程 / 294
11.2.4　查看与分析即时编译结果 / 297
11.3　编译优化技术 / 301
11.3.1　优化技术概览 / 301
11.3.2　公共子表达式消除 / 305
11.3.3　数组边界检查消除 / 307
11.3.4　方法内联 / 307
11.3.5　逃逸分析 / 309
11.4　Java与C/C++的编译器对比 / 311
11.5　本章小结 / 313
第五部分　高效并发
第12章　Java内存模型与线程 / 316
12.1　概述 / 316
12.2　硬件的效率与一致性 / 317
12.3　Java内存模型 / 318
12.3.1　主内存与工作内存 / 319
12.3.2　内存间交互操作 / 320
12.3.3　对于volatile型变量的特殊规则 / 322
12.3.4　对于long和double型变量的特殊规则 / 327
12.3.5　原子性、可见性与有序性 / 328
12.3.6　先行发生原则 / 330
12.4　Java与线程 / 333
12.4.1　线程的实现 / 333
12.4.2　Java线程调度 / 337
12.4.3　状态转换 / 339
12.5　本章小结 / 341
第13章　线程安全与锁优化 / 342
13.1　概述 / 342
13.2　线程安全 / 343
13.2.1　Java语言中的线程安全 / 343
13.2.2　线程安全的实现方法 / 348
13.3　锁优化 / 356
13.3.1　自旋锁与自适应自旋 / 356
13.3.2　锁消除 / 357
13.3.3　锁粗化 / 358
13.3.4　轻量级锁 / 358
13.3.5　偏向锁 / 361
13.4　本章小结 / 362
附录A　Java虚拟机家族 / 363
附录B　虚拟机字节码指令表 / 366
附录C　HotSpot虚拟机主要参数表 / 372
附录D　对象查询语言（OQL）简介 / 376
附录E　JDK历史版本轨迹 / 383
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Java虚拟机
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入Java虚拟机(原书第2版)
译者序
前言
第1章 Java体系结构介绍
第2章 平台无关
第3章 安全
第4章 网络移动性
第5章 Java虚拟机
第6章 Java class文件
第7章 类型的生命周期
第8章 连接模型
第9章 垃圾收集
第10章 栈和局部变量操作
第11章 类型转换
第12章 整数运算
第13章 逻辑运算
第14章 浮点运算
第15章 对象和数组
第16章 控制流
第17章 异常
第18章 finally子句
第19章 方法的调用与返回
第20章 指令invokespecial
第21章 线程同步
附录A 按操作码助记符排列的指令集
附录B 按功能排列的操作码助记符
附录C 按操作码字节值排列的操作码助记符
附录D Java虚拟机的一个模拟：“Slices of Pi”
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入Java虚拟机(原书第2版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>虚拟机
第1章 虚拟机导论
1.1 计算机体系结构
1.2 虚拟机基础
1.3 进程虚拟机
1.3.1 多道程序设计
1.3.2 仿真器和动态二进制翻译器
1.3.3 相同ISA下的二进制优化器
1.3.4 高级语言虚拟机：平台独立性
1.4 系统虚拟机
1.4.1 系统虚拟机的实现
1.4.2 全系统虚拟机：仿真
1.4.3 协同设计虚拟机：硬件优化
1.5 一种分类方法
1.6 总结：虚拟机功能的多样性
1.7 本书的其他部分
第2章 仿真：解释和二进制翻译
2.1 基本的解释
2.2 线索解释
2.3 预译码和直接线程解释
2.3.1 基本的预译码
2.3.2 直接线索解释
2.4 解释一个复杂的指令集
2.4.1 IA-32 ISA的解释
2.4.2 线索解释
2.4.3 一个高性能IA-32解释器
2.5 二进制翻译
2.6 代码发现和动态翻译
2.6.1 代码发现的问题
2.6.2 代码定位问题
2.6.3 增量式预译码和翻译
2.6.4 相同ISA仿真
2.7 控制转移优化
2.7.1 翻译链接
2.7.2 软件间接跳转预测
2.7.3 影子栈
2.8 指令集问题
2.8.1 寄存器结构
2.8.2 条件码
2.8.3 数据格式和运算
2.8.4 内存地址解析
2.8.5 内存数据对齐
2.8.6 字节序
2.8.7 寻址结构
2.9 案例研究：SHADE和模拟过程中的仿真角色
2.10 总结：性能折衷
第3章 进程虚拟机
3.1 虚拟机实现
3.2 兼容性
3.2.1 兼容性的级别
3.2.2 一个兼容性框架
3.2.3 实现依赖
3.3 状态映射
3.3.1 寄存器映射
3.3.2 内存地址空间映射
3.4 内存结构仿真
3.4.1 内存保护
3.4.2 自引用和自修改代码
3.5 指令仿真
3.5.1 性能权衡
3.5.2 分阶段的仿真
3.6 异常仿真
3.6.1 异常检测
3.6.2 中断处理
3.6.3 确定精确的客户机状态
3.7 操作系统仿真
3.7.1 相同操作系统仿真
3.7.2 不同操作系统仿真
3.8 代码cache管理
3.8.1 代码cache实现
3.8.2 替换算法
3.9 系统环境
3.10 案例研究：FX 1 32
3.11 总结
第4章 动态二进制优化
4.1 动态程序的行为
4.2 剖析
4.2.1 剖析的作用
4.2.2 剖析的类型
4.2.3 收集剖析
4.2.4 解释期间的剖析
4.2.5 剖析翻译后的代码
4.2.6 剖析开销
4.3 优化翻译块
4.3.1 提高局部性
4.3.2 踪迹
4.3.3 超块
4.3.4 动态超块的形成
4.3.5 树簇
4.4 优化框架
4.4.1 方法
4.4.2 优化和兼容性
4.4.3 一致的寄存器映射
4.5 代码重排
4.5.1 基元指令重排
4.5.2 实现一个调度算法
4.5.3 超块与踪迹
4.6 代码优化
4.6.1 基本的优化
4.6.2 兼容性问题
4.6.3 超块间的优化
4.6.4 特定指令集的优化
4.7 相同ISA优化系统：特殊的进程虚拟机
4.7.1 代码修补
4.7.2 案例：HPDynamo
4.7.3 讨论
4.8 总结
第5章 高级语言虚拟机结构
5.1Pascal P-code虚拟机
5.1.1 内存结构
5.1.2 指令集
5.1.3P-code总结
5.2 面向对象高级语言虚拟机
5.2.1 安全和保护
5.2.2 健壮性——面向对象编程
5.2.3 网络
5.2.4 性能
5.3 Java虚拟机结构
5.3.1 数据类型
5.3.2 数据存储
5.3.3Java指令集
5.3.4 异常和错误
5.3.5 二进制类
5.3.6Java本地接口
5.4 完善平台：APIs
5.4.1Java平台
5.4.2Java API
5.4.3 序列化和反射
5.4.4Java线程
5.5 微软公共语言基础：一个灵活的高级语言虚拟机
5.5.1 公共语言接口
5.5.2 属性
5.5.3 微软中间语言
5.5.4 隔离和应用域
5.6 总结：虚拟ISA的特点
5.6.1 元数据
5.6.2 内存结构
5.6.3 内存地址格式
5.6.4 精确的异常
5.6.5 指令集特点
5.6.6 指令发现
5.6.7 自修改和自引用代码
5.6.8 操作系统依赖
第6章 高级语言虚拟机实现
6.1 动态类加载
第7章 协同设计虚拟机
第8章 系统虚拟机
第9章 多处理器虚拟化
第10章 新兴应用
附录A 实际机器
参考文献
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>虚拟机
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Java虚拟机（第3版）
前言
致谢
第一部分　走近Java
第1章　走近Java 2
1.1　概述 2
1.2　Java技术体系 3
1.3　Java发展史 4
1.4　Java虚拟机家族 12
1.4.1　虚拟机始祖：Sun Classic/Exact VM 12
1.4.2　武林盟主：HotSpot VM 13
1.4.3　小家碧玉：Mobile/Embedded VM 14
1.4.4　天下第二：BEA JRockit/IBM J9 VM 15
1.4.5　软硬合璧：BEA Liquid VM/Azul VM 16
1.4.6　挑战者：Apache Harmony/Google Android Dalvik VM 17
1.4.7　没有成功，但并非失败：Microsoft JVM及其他 18
1.4.8　百家争鸣 19
1.5　展望Java技术的未来 21
1.5.1　无语言倾向 21
1.5.2　新一代即时编译器 23
1.5.3　向Native迈进 24
1.5.4　灵活的胖子 26
1.5.5　语言语法持续增强 27
1.6　实战：自己编译JDK 29
1.6.1　获取源码 29
1.6.2　系统需求 31
1.6.3　构建编译环境 33
1.6.4　进行编译 34
1.6.5　在IDE工具中进行源码调试 36
1.7　本章小结 39
第二部分　自动内存管理
第2章　Java内存区域与内存溢出异常 42
2.1　概述 42
2.2　运行时数据区域 42
2.2.1　程序计数器 43
2.2.2　Java虚拟机栈 43
2.2.3　本地方法栈 44
2.2.4　Java堆 44
2.2.5　方法区 46
2.2.6　运行时常量池 47
2.2.7　直接内存 47
2.3　HotSpot虚拟机对象探秘 48
2.3.1　对象的创建 48
2.3.2　对象的内存布局 51
2.3.3　对象的访问定位 52
2.4　实战：OutOfMemoryError异常 53
2.4.1　Java堆溢出 54
2.4.2　虚拟机栈和本地方法栈溢出 56
2.4.3　方法区和运行时常量池溢出 61
2.4.4　本机直接内存溢出 65
2.5　本章小结 66
第3章　垃圾收集器与内存分配策略 67
3.1　概述 67
3.2　对象已死？ 68
3.2.1　引用计数算法 68
3.2.2　可达性分析算法 70
3.2.3　再谈引用 71
3.2.4　生存还是死亡？ 72
3.2.5　回收方法区 74
3.3　垃圾收集算法 75
3.3.1　分代收集理论 75
3.3.2　标记-清除算法 77
3.3.3　标记-复制算法 78
3.3.4　标记-整理算法 79
3.4　HotSpot的算法细节实现 81
3.4.1　根节点枚举 81
3.4.2　安全点 82
3.4.3　安全区域 83
3.4.4　记忆集与卡表 84
3.4.5　写屏障 85
3.4.6　并发的可达性分析 87
3.5　经典垃圾收集器 89
3.5.1　Serial收集器 90
3.5.2　ParNew收集器 92
3.5.3　Parallel Scavenge收集器 93
3.5.4　Serial Old收集器 94
3.5.5　Parallel Old收集器 95
3.5.6　CMS收集器 96
3.5.7　Garbage First收集器 98
3.6　低延迟垃圾收集器 104
3.6.1　Shenandoah收集器 105
3.6.2　ZGC收集器 112
3.7　选择合适的垃圾收集器 121
3.7.1　Epsilon收集器 121
3.7.2　收集器的权衡 121
3.7.3　虚拟机及垃圾收集器日志 122
3.7.4　垃圾收集器参数总结 127
3.8　实战：内存分配与回收策略 129
3.8.1　对象优先在Eden分配 130
3.8.2　大对象直接进入老年代 131
3.8.3　长期存活的对象将进入老年代 132
3.8.4　动态对象年龄判定 134
3.8.5　空间分配担保 135
3.9　本章小结 137
第4章　虚拟机性能监控、故障处理工具 138
4.1　概述 138
4.2　基础故障处理工具 138
4.2.1　jps：虚拟机进程状况工具 141
4.2.2　jstat：虚拟机统计信息监视工具 142
4.2.3　jinfo：Java配置信息工具 143
4.2.4　jmap：Java内存映像工具 144
4.2.5　jhat：虚拟机堆转储快照分析工具 145
4.2.6　jstack：Java堆栈跟踪工具 146
4.2.7　基础工具总结 148
4.3　可视化故障处理工具 151
4.3.1　JHSDB：基于服务性代理的调试工具 152
4.3.2　JConsole：Java监视与管理控制台 157
4.3.3　VisualVM：多合-故障处理工具 164
4.3.4　Java Mission Control：可持续在线的监控工具 171
4.4　HotSpot虚拟机插件及工具 175
4.5　本章小结 180
第5章　调优案例分析与实战 181
5.1　概述 181
5.2　案例分析 181
5.2.1　大内存硬件上的程序部署策略 182
5.2.2　集群间同步导致的内存溢出 184
5.2.3　堆外内存导致的溢出错误 185
5.2.4　外部命令导致系统缓慢 187
5.2.5　服务器虚拟机进程崩溃 187
5.2.6　不恰当数据结构导致内存占用过大 188
5.2.7　由Windows虚拟内存导致的长时间停顿 189
5.2.8　由安全点导致长时间停顿 190
5.3　实战：Eclipse运行速度调优 192
5.3.1　调优前的程序运行状态 193
5.3.2　升级JDK版本的性能变化及兼容问题 196
5.3.3　编译时间和类加载时间的优化 200
5.3.4　调整内存设置控制垃圾收集频率 203
5.3.5　选择收集器降低延迟 206
5.4　本章小结 209
第三部分　虚拟机执行子系统
第6章　类文件结构 212
6.1　概述 212
6.2　无关性的基石 212
6.3　Class类文件的结构 214
6.3.1　魔数与Class文件的版本 215
6.3.2　常量池 218
6.3.3　访问标志 224
6.3.4　类索引、父类索引与接口索引集合 225
6.3.5　字段表集合 226
6.3.6　方法表集合 229
6.3.7　属性表集合 230
6.4　字节码指令简介 251
6.4.1　字节码与数据类型 251
6.4.2　加载和存储指令 253
6.4.3　运算指令 254
6.4.4　类型转换指令 255
6.4.5　对象创建与访问指令 256
6.4.6　操作数栈管理指令 256
6.4.7　控制转移指令 257
6.4.8　方法调用和返回指令 257
6.4.9　异常处理指令 258
6.4.10　同步指令 258
6.5　公有设计，私有实现 259
6.6　Class文件结构的发展 260
6.7　本章小结 261
第7章　虚拟机类加载机制 262
7.1　概述 262
7.2　类加载的时机 263
7.3　类加载的过程 267
7.3.1　加载 267
7.3.2　验证 268
7.3.3　准备 271
7.3.4　解析 272
7.3.5　初始化 277
7.4　类加载器 279
7.4.1　类与类加载器 280
7.4.2　双亲委派模型 281
7.4.3　破坏双亲委派模型 285
7.5　Java模块化系统 287
7.5.1　模块的兼容性 288
7.5.2　模块化下的类加载器 290
7.6　本章小结 292
第8章　虚拟机字节码执行引擎 293
8.1　概述 293
8.2　运行时栈帧结构 294
8.2.1　局部变量表 294
8.2.2　操作数栈 299
8.2.3　动态连接 300
8.2.4　方法返回地址 300
8.2.5　附加信息 301
8.3　方法调用 301
8.3.1　解析 301
8.3.2　分派 303
8.4　动态类型语言支持 315
8.4.1　动态类型语言 316
8.4.2　Java与动态类型 317
8.4.3　java.lang.invoke包 318
8.4.4　invokedynamic指令 321
8.4.5　实战：掌控方法分派规则 324
8.5　基于栈的字节码解释执行引擎 326
8.5.1　解释执行 327
8.5.2　基于栈的指令集与基于寄存器的指令集 328
8.5.3　基于栈的解释器执行过程 329
8.6　本章小结 334
第9章　类加载及执行子系统的案例与实战 335
9.1　概述 335
9.2　案例分析 335
9.2.1　Tomcat：正统的类加载器架构 335
9.2.2　OSGi：灵活的类加载器架构 338
9.2.3　字节码生成技术与动态代理的实现 341
9.2.4　Backport工具：Java的时光机器 345
9.3　实战：自己动手实现远程执行功能 348
9.3.1　目标 348
9.3.2　思路 349
9.3.3　实现 350
9.3.4　验证 355
9.4　本章小结 356
第四部分　程序编译与代码优化
第10章　前端编译与优化 358
10.1　概述 358
10.2　Javac编译器 359
10.2.1　Javac的源码与调试 359
10.2.2　解析与填充符号表 362
10.2.3　注解处理器 363
10.2.4　语义分析与字节码生成 364
10.3　Java语法糖的味道 367
10.3.1　泛型 367
10.3.2　自动装箱、拆箱与遍历循环 375
10.3.3　条件编译 377
10.4　实战：插入式注解处理器 378
10.4.1　实战目标 379
10.4.2　代码实现 379
10.4.3　运行与测试 385
10.4.4　其他应用案例 386
10.5　本章小结 386
第11章　后端编译与优化 388
11.1　概述 388
11.2　即时编译器 389
11.2.1　解释器与编译器 389
11.2.2　编译对象与触发条件 392
11.2.3　编译过程 397
11.2.4　实战：查看及分析即时编译结果 398
11.3　提前编译器 404
11.3.1　提前编译的优劣得失 405
11.3.2　实战：Jaotc的提前编译 408
11.4　编译器优化技术 411
11.4.1　优化技术概览 411
11.4.2　方法内联 415
11.4.3　逃逸分析 417
11.4.4　公共子表达式消除 420
11.4.5　数组边界检查消除 421
11.5　实战：深入理解Graal编译器 423
11.5.1　历史背景 423
11.5.2　构建编译调试环境 424
11.5.3　JVMCI编译器接口 426
11.5.4　代码中间表示 429
11.5.5　代码优化与生成 432
11.6　本章小结 436
第五部分　高效并发
第12章　Java内存模型与线程 438
12.1　概述 438
12.2　硬件的效率与一致性 439
12.3　Java内存模型 440
12.3.1　主内存与工作内存 441
12.3.2　内存间交互操作 442
12.3.3　对于volatile型变量的特殊规则 444
12.3.4　针对long和double型变量的特殊规则 450
12.3.5　原子性、可见性与有序性 450
12.3.6　先行发生原则 452
12.4　Java与线程 455
12.4.1　线程的实现 455
12.4.2　Java线程调度 458
12.4.3　状态转换 460
12.5　Java与协程 461
12.5.1　内核线程的局限 461
12.5.2　协程的复苏 462
12.5.3　Java的解决方案 464
12.6　本章小结 465
第13章　线程安全与锁优化 466
13.1　概述 466
13.2　线程安全 466
13.2.1　Java语言中的线程安全 467
13.2.2　线程安全的实现方法 471
13.3　锁优化 479
13.3.1　自旋锁与自适应自旋 479
13.3.2　锁消除 480
13.3.3　锁粗化 481
13.3.4　轻量级锁 481
13.3.5　偏向锁 483
13.4　本章小结 485
附录A　在Windows系统下编译OpenJDK 6 486
附录B　展望Java技术的未来（2013年版） 493
附录C　虚拟机字节码指令表 499
附录D　对象查询语言（OQL）简介 506
附录E　JDK历史版本轨迹 512
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Java虚拟机（第3版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>自己动手写Java虚拟机
前言
第1章　命令行工具 1
1.1　准备工作 1
1.2　java命令 4
1.3　编写命令行工具 5
1.4　测试本章代码 7
1.5　本章小结 8
第2章　搜索class文件 9
2.1　类路径 9
2.2　准备工作 10
2.3　实现类路径 11
2.4　测试本章代码 20
2.5　本章小结 21
第3章　解析class文件 23
3.1　class文件 24
3.2　解析class文件 25
3.3　解析常量池 35
3.4　解析属性表 50
3.5　测试本章代码 61
3.6　本章小结 63
第4章　运行时数据区 65
4.1　运行时数据区概述 66
4.2　数据类型 67
4.3　实现运行时数据区 68
4.4　测试本章代码 81
4.5　本章小结 83
第5章　指令集和解释器 85
5.1　字节码和指令集 86
5.2　指令和指令解码 88
5.2.1　Instruction接口 89
5.2.2　BytecodeReader 91
5.3　常量指令 92
5.3.1　nop指令 92
5.3.2　const系列指令 93
5.3.3　bipush和sipush指令 94
5.4　加载指令 94
5.5　存储指令 95
5.6　栈指令 96
5.6.1　pop和pop2指令 96
5.6.2　dup指令 97
5.6.3　swap指令 98
5.7　数学指令 98
5.7.1　算术指令 98
5.7.2　位移指令 99
5.7.3　布尔运算指令 101
5.7.4　iinc指令 102
5.8　类型转换指令 102
5.9　比较指令 103
5.10　控制指令 108
5.11　扩展指令 111
5.12　解释器 114
5.13　测试本章代码 118
5.14　本章小结 120
第6章　类和对象 121
6.1　方法区 122
6.2　运行时常量池 127
6.3　类加载器 133
6.4　对象、实例变量和类变量 136
6.5　类和字段符号引用解析 141
6.6　类和对象相关指令 144
6.7　测试本章代码 156
6.8　本章小结 160
第7章　方法调用和返回 161
7.1　方法调用概述 161
7.2　解析方法符号引用 163
7.3　方法调用和参数传递 166
7.4　返回指令 169
7.5　方法调用指令 170
7.6　改进解释器 176
7.7　测试方法调用 178
7.8　类初始化 181
7.9　本章小结 185
第8章　数组和字符串 187
8.1　数组概述 187
8.2　数组实现 188
8.3　数组相关指令 191
8.4　测试数组 203
8.5　字符串 204
8.6　测试字符串 207
8.7　本章小结 210
第9章　本地方法调用 211
9.1　注册和查找本地方法 212
9.2　调用本地方法 213
9.3　反射 215
9.4　字符串拼接和String.intern()方法 225
9.5　Object.hashCode()、equals()和toString() 231
9.6　Object.clone() 233
9.7　自动装箱和拆箱 235
9.8　本章小结 238
第10章　异常处理 239
10.1　异常处理概述 239
10.2　异常抛出 240
10.3　异常处理表 241
10.4　实现athrow指令 245
10.5　Java虚拟机栈信息 248
10.6　测试本章代码 251
10.7　本章小结 252
第11章　结束 253
11.1　System类是如何被初始化的 253
11.2　初始化System类 255
11.3　System.out.println()是如何工作的 258
11.4　测试本章代码 260
11.5　总结 260
附录　指令表 263
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>自己动手写Java虚拟机
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实战Java虚拟机
第1章　初探Java虚拟机	1
1.1  知根知底：追溯Java的发展历程	2
1.1.1  那些依托Java虚拟机的语言大咖们	2
1.1.2  Java发展史上的里程碑	2
1.2  跨平台的真相：Java虚拟机来做中介	4
1.2.1  理解Java虚拟机的原理	4
1.2.2  看清Java虚拟机的种类	5
1.3  一切看我的：Java语言规范	6
1.3.1  词法的定义	6
1.3.2  语法的定义	7
1.3.3  数据类型的定义	8
1.3.4  Java语言规范总结	9
1.4  一切听我的：Java虚拟机规范	9
1.5  数字编码就是计算机世界的水和电	10
1.5.1  整数在Java虚拟机中的表示	10
1.5.2  浮点数在Java虚拟机中的表示	12
1.6  抛砖引玉：编译和调试虚拟机	14
1.7  小结	19
第2章　认识Java虚拟机的基本结构	20
2.1  谋全局者才能成大器：看穿Java虚拟机的架构	20
2.2  小参数能解决大问题：学会设置Java虚拟机的参数	22
2.3  对象去哪儿：辨清Java堆	23
2.4  函数如何调用：出入Java栈	25
2.4.1  局部变量表	27
2.4.2  操作数栈	32
2.4.3  帧数据区	32
2.4.4  栈上分配	33
2.5  类去哪儿了：识别方法区	35
2.6  小结	37
第3章　常用Java虚拟机参数	38
3.1  一切运行都有迹可循：掌握跟踪调试参数	38
3.1.1  跟踪垃圾回收——读懂虚拟机日志	39
3.1.2  类加载/卸载的跟踪	42
3.1.3  系统参数查看	44
3.2  让性能飞起来：学习堆的配置参数	45
3.2.1  最大堆和初始堆的设置	45
3.2.2  新生代的配置	49
3.2.3  堆溢出处理	52
3.3  别让性能有缺口：了解非堆内存的参数配置	54
3.3.1  方法区配置	55
3.3.2  栈配置	55
3.3.3  直接内存配置	55
3.4  Client和Server二选一：虚拟机的工作模式	58
3.5  小结	59
第4章　垃圾回收概念与算法	60
4.1  内存管理清洁工：认识垃圾回收	60
4.2  清洁工具大PK：讨论常用的垃圾回收算法	61
4.2.1  引用计数法（Reference Counting）	62
4.2.2  标记清除法（Mark-Sweep）	63
4.2.3  复制算法（Copying）	64
4.2.4  标记压缩法（Mark-Compact）	66
4.2.5  分代算法（Generational Collecting）	67
4.2.6  分区算法（Region）	68
4.3  谁才是真正的垃圾：判断可触及性	69
4.3.1  对象的复活	69
4.3.2  引用和可触及性的强度	71
4.3.3  软引用——可被回收的引用	72
4.3.4  弱引用——发现即回收	76
4.3.5  虚引用——对象回收跟踪	77
4.4  垃圾回收时的停顿现象：Stop-The-World案例实战	79
4.5  小结	83
第5章　垃圾收集器和内存分配	84
5.1  一心一意一件事：串行回收器	85
5.1.1  新生代串行回收器	85
5.1.2  老年代串行回收器	86
5.2  人多力量大：并行回收器	86
5.2.1  新生代ParNew回收器	87
5.2.2  新生代ParallelGC回收器	88
5.2.3老年代ParallelOldGC回收器	89
5.3  一心多用都不落下：CMS回收器	90
5.3.1  CMS主要工作步骤	90
5.3.2  CMS主要的设置参数	91
5.3.3  CMS的日志分析	92
5.3.4  有关Class的回收	94
5.4  未来我做主：G1回收器	95
5.4.1  G1的内存划分和主要收集过程	95
5.4.2  G1的新生代GC	96
5.4.3  G1的并发标记周期	97
5.4.4  混合回收	100
5.4.5  必要时的Full GC	102
5.4.6  G1日志	102
5.4.7  G1相关的参数	106
5.5  回眸：有关对象内存分配和回收的一些细节问题	107
5.5.1  禁用System.gc()	107
5.5.2  System.gc()使用并发回收	107
5.5.3  并行GC前额外触发的新生代GC	109
5.5.4  对象何时进入老年代	110
5.5.5  在TLAB上分配对象	117
5.5.6  方法finalize()对垃圾回收的影响	120
5.6  温故又知新：常用的GC参数	125
5.7  动手才是真英雄：垃圾回收器对Tomcat性能影响的实验	127
5.7.1  配置实验环境	127
5.7.2  配置进行性能测试的工具JMeter	128
5.7.3  配置Web应用服务器Tomcat	131
5.7.4  实战案例1——初试串行回收器	133
5.7.5  实战案例2——扩大堆以提升系统性能	133
5.7.6  实战案例3——调整初始堆大小	134
5.7.7  实战案例4——使用ParrellOldGC回收器	135
5.7.8  实战案例5——使用较小堆提高GC压力	135
5.7.9  实战案例6——测试ParallelOldGC的表现	135
5.7.10 实战案例7——测试ParNew回收器的表现	136
5.7.11 实战案例8——测试JDK 1.6的表现	136
5.7.12 实战案例9——使用高版本虚拟机提升性能	137
5.8  小结	137
第6章　性能监控工具	138
6.1  有我更高效：Linux下的性能监控工具	139
6.1.1  显示系统整体资源使用情况——top命令	139
6.1.2  监控内存和CPU——vmstat命令	140
6.1.3  监控IO使用——iostat命令	142
6.1.4  多功能诊断器——pidstat工具	143
6.2  用我更高效：Windows下的性能监控工具	148
6.2.1  任务管理器	148
6.2.2  perfmon性能监控工具	150
6.2.3  Process Explorer进程管理工具	153
6.2.4  pslist命令——Windows下也有命令行工具	155
6.3  外科手术刀：JDK性能监控工具	157
6.3.1  查看Java进程——jps命令	158
6.3.2  查看虚拟机运行时信息——jstat命令	159
6.3.3  查看虚拟机参数——jinfo命令	162
6.3.4  导出堆到文件——jmap命令	163
6.3.5  JDK自带的堆分析工具——jhat命令	165
6.3.6  查看线程堆栈——jstack命令	167
6.3.7  远程主机信息收集——jstatd命令	170
6.3.8  多功能命令行——jcmd命令	172
6.3.9  性能统计工具——hprof	175
6.3.10 扩展jps命令	177
6.4  我是你的眼：图形化虚拟机监控工具JConsole	178
6.4.1  JConsole连接Java程序	178
6.4.2  Java程序概况	179
6.4.3  内存监控	180
6.4.4  线程监控	180
6.4.5  类加载情况	182
6.4.6  虚拟机信息	182
6.5  一目了然：可视化性能监控工具Visual VM	183
6.5.1  Visual VM连接应用程序	184
6.5.2  监控应用程序概况	185
6.5.3  Thread Dump和分析	186
6.5.4  性能分析	187
6.5.5  内存快照分析	189
6.5.6  BTrace介绍	190
6.6  来自JRockit的礼物：虚拟机诊断工具Mission Control	198
6.6.1  MBean服务器	198
6.6.2  飞机记录器（Flight Recorder）	200
6.7  小结	203
第7章　分析Java堆	204
7.1  对症才能下药：找到内存溢出的原因	205
7.1.1  堆溢出	205
7.1.2  直接内存溢出	205
7.1.3  过多线程导致OOM	207
7.1.4  永久区溢出	209
7.1.5  GC效率低下引起的OOM	210
7.2  无处不在的字符串：String在虚拟机中的实现	210
7.2.1  String对象的特点	210
7.2.2  有关String的内存泄漏	212
7.2.3  有关String常量池的位置	215
7.3  虚拟机也有内窥镜：使用MAT分析Java堆	217
7.3.1  初识MAT	217
7.3.2  浅堆和深堆	220
7.3.3例解MAT堆分析	221
7.3.4支配树（Dominator Tree）	225
7.3.5  Tomcat堆溢出分析	226
7.4  筛选堆对象：MAT对OQL的支持	230
7.4.1  Select子句	230
7.4.2  From子句	232
7.4.3  Where子句	234
7.4.4  内置对象与方法	234
7.5  更精彩的查找：Visual VM对OQL的支持	239
7.5.1  Visual VM的OQL基本语法	239
7.5.2  内置heap对象	240
7.5.3  对象函数	242
7.5.4  集合/统计函数	247
7.5.5  程序化OQL分析Tomcat堆	252
7.6  小结	255
第8章　锁与并发	256
8.1  安全就是锁存在的理由：锁的基本概念和实现	257
8.1.1  理解线程安全	257
8.1.2  对象头和锁	259
8.2  避免残酷的竞争：锁在Java虚拟机中的实现和优化	260
8.2.1  偏向锁	260
8.2.2  轻量级锁	262
8.2.3  锁膨胀	263
8.2.4  自旋锁	264
8.2.5  锁消除	264
8.3  应对残酷的竞争：锁在应用层的优化思路	266
8.3.1  减少锁持有时间	266
8.3.2  减小锁粒度	267
8.3.3  锁分离	269
8.3.4  锁粗化	271
8.4  无招胜有招：无锁	273
8.4.1  理解CAS	273
8.4.2  原子操作	274
8.4.3  新宠儿LongAddr	277
8.5  将随机变为可控：理解Java内存模型	280
8.5.1  原子性	280
8.5.2  有序性	282
8.5.3  可见性	284
8.5.4  Happens-Before原则	286
8.6  小结	286
第9章　Class文件结构	287
9.1  不仅跨平台，还能跨语言：语言无关性	287
9.2  虚拟机的基石：Class文件	289
9.2.1  Class文件的标志——魔数	290
9.2.2  Class文件的版本	292
9.2.3  存放所有常数——常量池	293
9.2.4  Class的访问标记（Access Flag）	300
9.2.5  当前类、父类和接口	301
9.2.6  Class文件的字段	302
9.2.7  Class文件的方法基本结构	304
9.2.8  方法的执行主体——Code属性	306
9.2.9  记录行号——LineNumberTable属性	307
9.2.10 保存局部变量和参数——LocalVariableTable属性	308
9.2.11 加快字节码校验——StackMapTable属性	308
9.2.12Code属性总结	313
9.2.13 抛出异常——Exceptions属性	314
9.2.14 用实例分析Class的方法结构	315
9.2.15 我来自哪里——SourceFile属性	318
9.2.16 强大的动态调用——BootstrapMethods属性	319
9.2.17内部类——InnerClasses属性	320
9.2.18 将要废弃的通知——Deprecated属性	321
9.2.19Class文件总结	322
9.3  操作字节码：走进ASM	322
9.3.1  ASM体系结构	322
9.3.2  ASM之Hello World	324
9.4  小结	325
第10章　Class装载系统	326
10.1  来去都有序：看懂Class文件的装载流程	326
10.1.1  类装载的条件	327
10.1.2  加载类	330
10.1.3  验证类	332
10.1.4  准备	333
10.1.5  解析类	334
10.1.6  初始化	336
10.2  一切Class从这里开始：掌握ClassLoader	340
10.2.1  认识ClassLoader，看懂类加载	341
10.2.2  ClassLoader的分类	341
10.2.3  ClassLoader的双亲委托模式	343
10.2.4  双亲委托模式的弊端	347
10.2.5  双亲委托模式的补充	348
10.2.6  突破双亲模式	350
10.2.7  热替换的实现	353
10.3  小结	357
第11章　字节码执行	358
11.1  代码如何执行：字节码执行案例	359
11.2  执行的基础：Java虚拟机常用指令介绍	369
11.2.1  常量入栈指令	369
11.2.2  局部变量压栈指令	370
11.2.3  出栈装入局部变量表指令	371
11.2.4  通用型操作	372
11.2.5  类型转换指令	373
11.2.6  运算指令	375
11.2.7  对象/数组操作指令	377
11.2.8  比较控制指令	379
11.2.9  函数调用与返回指令	386
11.2.10 同步控制	389
11.2.11 再看Class的方法结构	391
11.3  更上一层楼：再看ASM	393
11.3.1  为类增加安全控制	393
11.3.2  统计函数执行时间	396
11.4  谁说Java太刻板：Java Agent运行时修改类	399
11.4.1  使用-javaagent参数启动Java虚拟机	400
11.4.2  使用Java Agent为函数增加计时功能	402
11.4.3  动态重转换类	404
11.4.4  有关Java Agent的总结	407
11.5  与时俱进：动态函数调用	407
11.5.1  方法句柄使用实例	407
11.5.2  调用点使用实例	411
11.5.3  反射和方法句柄	412
11.5.4  指令invokedynamic使用实例	414
11.6  跑得再快点：静态编译优化	418
11.6.1  编译时计算	419
11.6.2  变量字符串的连接	421
11.6.3  基于常量的条件语句裁剪	422
11.6.4  switch语句的优化	423
11.7  提高虚拟机的执行效率：JIT及其相关参数	424
11.7.1  开启JIT编译	425
11.7.2  JIT编译阈值	426
11.7.3  多级编译器	427
11.7.4  OSR栈上替换	430
11.7.5  方法内联	431
11.7.6  设置代码缓存大小	432
11.8  小结	436
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实战Java虚拟机
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机规范（Java SE 8版）
译者序
前　言
第1章　引言1
1.1　简史1
1.2　Java虚拟机2
1.3　各章节摘要2
1.4　说明3
1.5　反馈3
第2章　Java虚拟机结构4
2.1　class文件格式4
2.2　数据类型5
2.3　原始类型与值5
2.3.1　整数类型与整型值6
2.3.2　浮点类型、取值集合及浮点值6
2.3.3　returnAddress类型和值8
2.3.4　boolean类型8
2.4　引用类型与值9
2.5　运行时数据区9
2.5.1　pc寄存器9
2.5.2　Java虚拟机栈10
2.5.3　Java堆10
2.5.4　方法区11
2.5.5　运行时常量池11
2.5.6　本地方法栈12
2.6　栈帧12
2.6.1　局部变量表13
2.6.2　操作数栈14
2.6.3　动态链接14
2.6.4　方法调用正常完成15
2.6.5　方法调用异常完成15
2.7　对象的表示15
2.8　浮点算法15
2.8.1　Java虚拟机和IEEE 754中的浮点算法15
2.8.2　浮点模式16
2.8.3　数值集合转换17
2.9　特殊方法18
2.10　异常19
2.11　字节码指令集简介20
2.11.1　数据类型与Java虚拟机21
2.11.2　加载和存储指令23
2.11.3　算术指令24
2.11.4　类型转换指令25
2.11.5　对象的创建与操作27
2.11.6　操作数栈管理指令27
2.11.7　控制转移指令27
2.11.8　方法调用和返回指令28
2.11.9　抛出异常28
2.11.10　同步28
2.12　类库29
2.13　公有设计、私有实现30
第3章　Java虚拟机编译器31
3.1　示例的格式说明31
3.2　常量、局部变量和控制结构的使用32
3.3　算术运算36
3.4　访问运行时常量池36
3.5　与控制结构有关的更多示例37
3.6　接收参数40
3.7　方法调用41
3.8　使用类实例43
3.9　数组44
3.10　编译switch语句46
3.11　使用操作数栈48
3.12　抛出异常和处理异常48
3.13　编译finally语句块51
3.14　同步54
3.15　注解55
第4章　class文件格式56
4.1　ClassFile结构57
4.2　各种名称的内部表示形式61
4.2.1　类和接口的二进制名称61
4.2.2　非限定名61
4.3　描述符62
4.3.1　语法符号62
4.3.2　字段描述符62
4.3.3　方法描述符63
4.4　常量池64
4.4.1　CONSTANT_Class_info结构65
4.4.2　CONSTANT_Fieldref_info、CONSTANT_Methodref_info和CONSTANT_InterfaceMethodref_info结构66
4.4.3　CONSTANT_String_info结构67
4.4.4　CONSTANT_Integer_info和CONSTANT_Float_info结构67
4.4.5　CONSTANT_Long_info和CONSTANT_Double_info结构68
4.4.6　CONSTANT_NameAnd-Type_info结构69
4.4.7　CONSTANT_Utf8_info结构70
4.4.8　CONSTANT_MethodHandle_info结构72
4.4.9　CONSTANT_MethodType_info结构73
4.4.10　CONSTANT_Invoke-Dynamic_info结构74
4.5　字段74
4.6　方法76
4.7　属性78
4.7.1　自定义和命名新的属性82
4.7.2　ConstantValue属性82
4.7.3　Code属性83
4.7.4　StackMapTable属性86
4.7.5　Exceptions属性92
4.7.6　InnerClasses属性93
4.7.7　EnclosingMethod属性95
4.7.8　Synthetic属性96
4.7.9　Signature属性96
4.7.10　SourceFile属性100
4.7.11　SourceDebugExtension属性101
4.7.12　LineNumberTable属性102
4.7.13　LocalVariableTable属性103
4.7.14　LocalVariableTypeTable属性104
4.7.15　Deprecated属性106
4.7.16　RuntimeVisibleAnnota-tions属性106
4.7.17　RuntimeInvisible-Annotations属性110
4.7.18　RuntimeVisibleParameterAnnotations属性111
4.7.19　RuntimeInvisiblePara-meterAnnotations属性112
4.7.20　RuntimeVisibleTypeAnnotations属性114
4.7.21　RuntimeInvisibleType-Annotations属性124
4.7.22　AnnotationDefault属性125
4.7.23　BootstrapMethods属性126
4.7.24　MethodParameters属性127
4.8　格式检查129
4.9　Java虚拟机代码约束129
4.9.1　静态约束130
4.9.2　结构化约束132
4.10　class文件校验135
4.10.1　类型检查验证136
4.10.2　类型推导验证200
4.11　Java虚拟机限制206
第5章　加载、链接与初始化208
5.1　运行时常量池208
5.2　虚拟机启动210
5.3　创建和加载211
5.3.1　使用引导类加载器来加载类型212
5.3.2　使用用户自定义类加载器来加载类型212
5.3.3　创建数组类213
5.3.4　加载限制214
5.3.5　从class文件表示得到类214
5.4　链接215
5.4.1　验证216
5.4.2　准备216
5.4.3　解析217
5.4.4　访问控制225
5.4.5　方法覆盖225
5.5　初始化226
5.6　绑定本地方法实现228
5.7　Java虚拟机退出228
第6章　Java虚拟机指令集229
6.1　设定：“必须”的含义229
6.2　保留操作码229
6.3　虚拟机错误230
6.4　指令描述格式230
6.5　指令集描述232
第7章　操作码助记符320
附录A　Limited License Grant327
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机规范（Java SE 8版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>虚拟机设计与实现
第一部分 虚拟机基础
第1章 虚拟机简介　2
1.1 虚拟机类型　2
1.2 为什么需要虚拟机　3
1.3 虚拟机示例　4
1.3.1 JavaScript引擎　4
1.3.2 Perl引擎　5
1.3.3 Android Java VM　5
1.3.4 Apache Harmony　6
第2章 虚拟机内部组成　7
2.1 虚拟机核心组件　7
2.1.1 加载器与动态链接器　7
2.1.2 执行引擎　8
2.1.3 内存管理器　8
2.1.4 线程调度器　9
2.1.5 语言扩展　9
2.1.6 传统模型与虚拟机模型　10
2.2 虚拟ISA　11
2.2.1 JVM　12
2.2.2 JVM与CLR　15
第3章 虚拟机中的数据结构　17
3.1 对象与类　17
3.2 对象表示　18
3.3 方法描述　18
第二部分 虚拟机设计
第4章 执行引擎设计　22
4.1 解释器　22
4.1.1 超级指令　23
4.1.2 选择性内联　23
4.2 JIT编译　23
4.2.1 基于方法的JIT　24
4.2.2 基于踪迹的JIT　26
4.2.3 基于区域的JIT　29
4.3 解释器与JIT编译器的关系　30
4.4 AOT编译　31
4.5 编译时与运行时　33
第5章 垃圾回收设计　37
5.1 对象生存期　37
5.2 引用计数　38
5.3 对象追踪　40
5.4 RC与对象追踪　42
5.5 GC安全点　43
5.6 常用追踪GC算法　45
5.6.1 标记清除　46
5.6.2 追踪复制　46
5.7 常用追踪GC变体　48
5.7.1 标记压缩　48
5.7.2 滑动压缩　48
5.7.3 追踪转发　49
5.7.4 标记复制　50
5.7.5 分代式GC　50
5.8 移动式GC与非移动式GC　53
5.8.1 数据局部性　53
5.8.2 跳增指针分配　53
5.8.3 空闲列表与分配位图　53
5.8.4 离散大小列表　54
5.8.5 标记位与分配位　54
5.8.6 线程局部分配　55
5.8.7 移动式GC与非移动式GC的混合　56
第6章 线程设计　58
6.1 什么是线程　58
6.2 内核线程与用户线程　59
6.3 VM线程到OS线程的映射　61
6.4 同步构件　63
6.5 monitor　65
6.5.1 互斥　65
6.5.2 条件变量　66
6.5.3 monitorenter　66
6.5.4 monitorexit　69
6.5.5 Object.wait()　71
6.5.6 Object.notify()　71
6.6 原子　73
6.7 monitor与原子　75
6.7.1 阻塞与非阻塞　75
6.7.2 中央控制点　75
6.7.3 锁与非锁　75
6.7.4 非阻塞之上的阻塞　76
6.8 回收器与修改器　77
6.9 线程局部数据　78
6.10 GC的线程暂停支持　81
6.10.1 GC安全点　81
6.10.2 GC安全区域　83
6.10.3 基于锁的安全点　86
6.10.4 回收中的线程交互　87
第三部分 虚拟机内部支持
第7章 本地接口　92
7.1 为何需要本地接口　92
7.2 从托管代码到本地代码的转换　93
7.2.1 本地方法封装　94
7.2.2 封装代码的GC支持　96
7.2.3 封装代码的同步支持　98
7.3 本地方法实现的绑定　99
7.4 本地代码到托管代码的转换　99
7.5 本地代码到本地代码的转换　102
7.5.1 通过JNI API的本地到本地转换　102
7.5.2 为什么在本地到本地转换中使用JNI API　105
第8章 栈展开　107
8.1 为何需要栈展开　107
8.2 Java方法帧的栈展开　108
8.2.1 栈展开设计　108
8.2.2 栈展开实现　110
8.3 本地方法帧的栈展开　112
8.3.1 栈展开设计　112
8.3.2 Java到本地封装设计　114
8.3.3 栈展开实现　116
8.3.4 本地帧与C帧　117
第9章 垃圾回收支持　119
9.1 为何需要垃圾回收支持　119
9.2 在Java代码中支持垃圾回收　121
9.2.1 GC-map　121
9.2.2 带寄存器的栈展开　124
9.3 在本地代码中支持垃圾回收　126
9.3.1 对象引用访问　127
9.3.2 对象句柄实现　129
9.3.3 GC安全性维护　132
9.3.4 对象体访问　133
9.3.5 对象分配　135
9.4 在同步方法中支持垃圾回收　136
9.4.1 同步Java方法　136
9.4.2 同步本地方法　138
9.5 Java与本地代码转换中的GC支持　140
9.5.1 本地到Java　140
9.5.2 Java到本地　142
9.5.3 本地到本地　142
9.6 全局根集　144
第10章 运行时辅助　145
10.1 为何需要运行时辅助　145
10.2 带运行时辅助的VM服务设计　147
10.2.1 运行时辅助操作　147
10.2.2 运行时辅助实现　148
10.2.3 JNI API作为运行时辅助　150
10.3 没有运行时辅助的VM服务设计　151
10.3.1 运行时辅助的快速路径　153
10.3.2 快速路径VM服务编程　154
10.4 主要VM服务　154
第11章 异常抛出　157
11.1 保存异常抛出上下文　157
11.1.1 VM保存的上下文　158
11.1.2 Linux中OS保存的上下文　158
11.1.3 Windows中OS保存的上下文　159
11.1.4 同步与异步异常　160
11.2 本地代码内与跨本地代码异常处理　161
11.2.1 本地代码内的异常处理　161
11.2.2 带异常Java代码返回到本地代码　162
11.2.3 带异常的本地代码返回到Java代码　166
11.3 保存栈轨迹　167
11.4 找到异常处理器　169
11.5 控制转移　172
11.5.1 控制转移操作　172
11.5.2 用于控制转移的寄存器　173
11.5.3 数据寄存器恢复　174
11.5.4 控制寄存器修正　176
11.5.5 执行恢复　176
11.5.6 未捕获异常　179
第12章 终结与弱引用　180
12.1 终结　180
12.2 为何需要弱引用　182
12.3 对象生存期状态　184
12.3.1 对象状态转换　185
12.3.2 引用队列　187
12.3.3 引用对象状态转换　187
12.4 引用对象实现　189
12.5 引用对象处理顺序　191
第13章 虚拟机模块化设计　194
13.1 VM组件　194
13.2 对象信息暴露　197
13.3 垃圾回收器接口　199
13.4 执行引擎接口　202
13.5 跨组件优化　203
第四部分 垃圾回收优化
第14章 针对吞吐量的GC优化　208
14.1 部分堆回收与全堆回收之间的适应性调整　208
14.2 分代式与非分代式算法之间的适应性调整　213
14.3 堆的空间大小的适应性调整　217
14.3.1 空间大小扩展　218
14.3.2 NOS大小　219
14.3.3 部分转发NOS设计　221
14.3.4 半空间NOS设计　221
14.3.5 aged-mature NOS设计　223
14.3.6 回退回收　225
14.4 分配空间之间的适应性调整　225
14.5 大OS页与预取　230
第15章 针对可扩展性的GC优化　232
15.1 回收阶段　232
15.2 并行对象图遍历　233
15.2.1 任务共享　234
15.2.2 工作偷取　234
15.2.3 任务推送　235
15.3 并行对象标记　238
15.4 并行压缩　239
15.4.1 并行LISP2压缩器　239
15.4.2 对象依赖树　241
15.4.3 带用于转发指针的目标表的压缩器　244
15.4.4 基于对象节的压缩器　246
15.4.5 单趟就地压缩器　247
第16章 针对响应性的GC优化　249
16.1 区域式GC　249
16.2 并发追踪　252
16.2.1 起始快照　252
16.2.2 增量更新　256
16.2.3 用三色术语表示并发追踪　259
16.2.4 使用读屏障的并发追踪　260
16.3 并发根集枚举　261
16.3.1 并发根集枚举设计　262
16.3.2 在根集枚举过程中追踪堆　265
16.3.3 并发栈扫描　266
16.4 并发回收调度　267
16.4.1 调度并发根集枚举　267
16.4.2 调度并发堆追踪　269
16.4.3 并发回收调度　271
16.4.4 并发回收阶段转换　272
第17章 并发移动式回收　277
17.1 并发复制：“目标空间不变”　277
17.1.1 基于槽位的“目标空间不变”算法　277
17.1.2 “目标空间不变”性　280
17.1.3 对象转发　282
17.1.4 基于对象的“目标空间不变”算法　283
17.1.5 基于虚拟内存的“目标空间不变”算法　285
17.2 并发复制：“当前副本不变”　286
17.2.1 对象移动风暴　286
17.2.2 “当前副本不变”设计　287
17.2.3 并发复制与并发堆追踪的关系　289
17.3 并发复制：“源空间不变”　292
17.3.1 “源空间不变”设计　292
17.3.2 部分转发“源空间不变”设计　294
17.4 无STW的完整并发移动　295
17.5 并发压缩回收　296
17.5.1 并发区域复制式回收　296
17.5.2 基于虚拟内存的并发压缩　299
第五部分 线程交互优化
第18章 monitor性能优化　308
18.1 惰性锁　308
18.2 瘦锁　310
18.2.1 瘦锁锁定路径　310
18.2.2 瘦锁解锁路径　313
18.2.3 竞争标志重置支持　316
18.3 胖锁　318
18.3.1 整合monitor数据结构　318
18.3.2 交由OS来支持　319
18.3.3 瘦锁膨胀为胖锁　321
18.3.4 休眠等待被竞争瘦锁　324
18.4 Tasuki锁　327
18.4.1 将同一个胖锁monitor用于竞争控制　327
18.4.2 胖锁收缩为瘦锁　331
18.5 线程局部锁 334
18.5.1 锁保留　335
18.5.2 线程亲密锁　339
第19章 基于硬件事务内存的设计　346
19.1 硬件事务内存　346
19.1.1 从事务数据库到事务内存　346
19.1.2 Intel的HTM实现　347
19.2 使用HTM的monitor实现　348
19.2.1 基于HTM的monitor的正确性问题　349
19.2.2 基于HTM的monitor的性能问题　352
19.3 使用HTM的并发垃圾回收　355
19.3.1 GC中HTM的机会　355
19.3.2 复制式回收　357
19.3.3 压缩式回收　360
参考文献　364
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>虚拟机设计与实现
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机精讲
第1 章  Java体系结构 / 1
1.1   认识 Java / 1
1.1.1   与生俱来的优点 / 2
1.1.2   语法结构和对象模型 / 4
1.1.3   历史版本追溯 / 5
1.2  Java重要概念 / 7
1.2.1  Java 编程语言 / 7
1.2.2   字节码 / 7
1.2.3  Java API / 8
1.2.4  Java 虚拟机 / 8
1.3   安装与配置 Java 运行环境 / 10
1.3.1  Windows 环境下的安装与 配置 / 10
1.3.2  Linux 环境下的安装与配置 / 11
1.3.3   编写Java 程序 / 12
1.3.4   编译与运行 / 13
1.3.5   关键字与标示符 / 13
1.4  Java技术的新特性 / 14
1.4.1  Java 模块化与 OSGi技术 / 14
1.4.2   语言无关性 / 15
1.4.3   使用Fork/Join 框架实现多核并行 / 16
1.4.4   丰富的语法特性 / 17
1.4.5   过渡到64 位虚拟机 / 18
1.5   实战：玩转 OpenJDK / 19
1.5.1  JDK 与OpenJDK 的关系 / 19
1.5.2   基于OpenJDK 深度定制的 淘宝JVM（TaobaoVM ） / 20
1.5.3   下载OpenJDK 源代码 / 22
1.5.4   构建编译环境 / 22
1.5.5   执行整个 OpenJDK的编译 / 23
1.5.6   执行单独 HotSpot的编译 / 26
1.5.7   导致编译失败的一些疑难 杂症 / 29
1.5.8   使用GDB工具Debug  HotSpot. / 30
1.6   本章小结 / 36
第2 章   字节码的编译原理 / 37
2.1  javac 编译器简介 / 37
2.1.1  javac与Eclipse Compiler for   Java 编译器 / 38
2.1.2  javac的使用与标准选项配置 / 39
2.1.3   编译原理 / 40
2.1.4   下载javac 编译器源码 / 41
2.1.5   调用compile() 方法执行编译 / 41
2.2   词法解析步骤 / 43
2.2.1  Token 序列 / 45
2.2.2   源码字符集合与 Token 之间 的对应关系 / 47
2.2.3   调用key()方法获取指定Token / 48
2.2.4   调用nextToken() 方法计算Token 的获取规则 / 48
2.2.5   调用parseCompilationUnit() 方法执行词法解 / 49
2.3   语法解析步骤 / 51
2.3.1   调用qualident()方法解析 package 语法节点 / 52
2.3.2   调用importDeclaration()
方法解析import 语法树 / 54
2.3.3   调用classDeclaration() 方法解析class 语法树 / 56
2.4   语义解析步骤 / 59
2.5   生成字节码 / 61
2.6   实战：使用 javap 工具分析字节码 / 62
2.7   实战：使用 GCJ 编译器将Java源码直接编译为本地机器指令 / 64
2.8   本章小结 / 66
第3 章   字节码文件 / 67
3.1   字节码文件的内部组成结构 / 67
3.2   符号引用 / 73
3.2.1   类或者接口的全限定名 / 74
3.2.2   简单名称 / 74
3.2.3   描述符 / 74
3.3   常量池 / 76
3.3.1  CONSTANT_Utf8_info 常量项 / 77
3.3.2  CONSTANT_Integer_info 常量项 / 77
3.3.3  CONSTANT_Float_info 常量项 / 78
3.3.4  CONSTANT_Long_info 常量项 / 78
3.3.5  CONSTANT_Double_info 常量项 / 79
3.3.6  CONSTANT_Class_info 常量项 / 79
3.3.7  CONSTANT_String_info 常量项 / 80
3.3.8  CONSTANT_Fieldref_info 常量项 / 81
3.3.9  CONSTANT_Methodref_info 常量项 / 81
3.3.10  CONSTANT_I nterfaceMethodref _info常量项 / 82
3.3.11  CONSTANT_NameAndType _info常量项 / 82
3.3.12  CONSTANT_MethodHandle _info常量项 / 83
3.3.13  CONSTANT_MethodType _info常量项 / 84
3.3.14  CONSTANT_InvokeDynamic _info常量项 / 84
3.4   字段表 / 85
3.5   方法表 / 86
3.6   属性表 / 88
3.6.1  Code属性 / 89
3.6.2  ConstantValue 属性 / 90
3.6.3  Exceptions 属性 / 91
3.6.4  LineNumberTable 属性 / 92
3.6.5  SourceFile 属性 / 93
3.6.6  LocalVariableTable属性 / 93
3.6.7  InnerClasses属性 / 94
3.6.8  BootstrapMethods 属性 / 95
3.7   本章小结 / 96

第4 章   剖析HotSpot 的Launcher / 97
4.1  HotSpot 的源码目录结构 / 97
4.2  Launcher简介 / 99
4.3   跟踪 Launcher 的执行过程 / 101
4.3.1   使用Launcher 启动JVM / 101
4.3.2   启动函数 main() / 102
4.3.3   在主线程中执行 JavaMain() 函数 / 106
4.3.4   调用JNI_CreateJavaVM() 函数初始化HotSpot / 114
4.3.5   调用LoadClass() 函数获取 Java 启动类 / 115
4.3.6   调用GetStaticMethodId() 函数获取Java 启动方法 / 116
4.3.7   调用CallStaticVoidMethod() 函数执行Java 启动方法 / 116
4.3.8   调用jni_DestroyJavaVM 函数销毁HotSpot / 119
4.4   实战：在 Launcher 中添加 自定义函数模块 / 120
4.5   本章小结 / 121
第5 章   剖析HotSpot 的初始化过程 / 122
5.1  HotSpot 的构成模块 / 122
5.2  Prims 模块 / 124
5.2.1  JNI 子模块 / 124
5.2.2  JVM子模块 / 125
5.2.3  JVMTI 子模块 / 128
5.2.4  Perf 子模块 / 129
5.3  Runtime 模块 / 129
5.3.1  Thread 子模块 / 131
5.3.2   调用create_vm() 函数完成 HotSpot的最终初始化 / 131
5.4   跟踪 HotSpot的初始化过程 / 140
5.4.1   调用init() 和init_2()函数 初始化os 模块 / 141
5.4.2   调用vm_init_globals()函数 初始化全局数据结构 / 144
5.4.3   调用init_globals() 函数 初始化全局模块 / 144
5.5   本章小结 / 146
第6 章   内存分配与垃圾回收 / 147
6.1  JVM的运行时内存区结构 / 147
6.2   线程共享内存区 / 148
6.2.1  Java 堆区 / 148
6.2.2   方法区 / 150
6.2.3   运行时常量池 / 150
6.3   线程私有内存区 / 150
6.3.1  PC寄存器 / 151
6.3.2  Java 栈 / 151
6.3.3   本地方法栈 / 152
6.4   性能监控区 / 152
6.5   自动内存管理 / 152
6.5.1   内存分配原理 / 153
6.5.2   逃逸分析与栈上分配 / 157
6.5.3   对象内存布局与 OOP-Klass 模型 / 158
6.5.4  GC 的作用 / 159
6.5.5   垃圾标记：根搜索算法 / 160
6.5.6   垃圾回收：分代收集算法 / 161
6.6   垃圾收集器 / 164
6.6.1   串行回收：Serial 收集器 / 165
6.6.2   并行回收：ParNew收集器 / 166
6.6.3   程序吞吐量优先：Parallel 收集器 / 166
6.6.4   低延迟：CMS（Concurrent- Mark-Sweep）收集器 / 167
6.6.5   区域化分代式：G1（Garbage- First ）收集器 / 170
6.6.6   垃圾收集的相关选项配置 / 172
6.7   实战：GC日志分析 / 175
6.7.1   不同GC日志的展示形式 / 175
6.7.2   使用GCHisto 工具分析离线 日志 / 179
6.8   实战：分析 dump 文件 / 181
6.8.1   使用jmap 工具生成dump 文件 / 181
6.8.2   使用MAT（Memory Analyzer Tool ）工具分析 dump 文件 / 182
6.9   本章小结 / 184
第7 章   类加载机制 / 185
7.1   类加载器 / 185
7.1.1   抽象类ClassLoader / 187
7.1.2   双亲委派模型 / 188
7.1.3   自定义类加载器 / 191
7.1.4   定位ClassNotFoundException 异常 / 193
7.1.5   定位NoClassDefFoundError 异常 / 194
7.2   类的加载过程 / 195
7.2.1   加载字节码 / 198
7.2.2   验证阶段 / 199
7.2.3   准备阶段 / 200
7.2.4   解析阶段 / 201
7.2.5   初始化阶段 / 201
7.3   实战：字节码文件的加密与 解密 / 204
7.4   本章小结 / 208
第8 章   剖析HotSpot 的架构模型与 执行引擎 / 209
8.1   栈帧的组成结构 / 209
8.1.1   局部变量表 / 211
8.1.2   操作数栈 / 212
8.1.3   动态链接 / 214
8.1.4   方法返回值 / 216
8.2  HotSpot 中执行引擎的架构 模型 / 216
8.2.1   本地机器指令 / 217
8.2.2   寄存器架构与栈式架构之间 的区别 / 218
8.2.3   基于栈式架构的设计 / 221
8.2.4   调用call_stub()函数执行Java 方法 / 222
8.2.5   栈顶缓存（Top-of-Stack Cashing ） 技术 / 225
8.2.6   实战：跟踪字节码解释器的 执行步骤 / 227
8.3   解释器与 JIT 编译器 / 230
8.3.1   查阅HotSpot的运行时执 行模式 / 231
8.3.2   解释器的工作机制与构成模块 / 232
8.3.3  JIT 编译器的工作机制与构成模块 / 234
8.3.4   分层编译策略 / 235
8.3.5   热点探测功能 / 236
8.4   本章小结 / 239
附录A  Java7新增语法特性 / 241
A.1  try-with-resources 语句 / 241
A.2  泛型的“<>”类型推断运算符 / 245
A.3  声明二进制字面值 / 247
A.4  字面值下画线支持 / 248
A.5  switch表达式支持 String 类型 / 250
A.6  mutil-catch特性 / 251
A.7  NIO2.0 文件系统的改变 / 255
附录B  指令助记符 / 262
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机精讲
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>自己动手实现Lua
前言
第一部分　准备
第1章　准备工作
1.1　准备开发环境
1.2　准备目录结构
1.3　本章小结
第二部分　Lua虚拟机和Lua API
第2章　二进制chunk
2.1　什么是二进制chunk
2.2　luac命令介绍
2.3　二进制chunk格式
2.4　解析二进制chunk
2.5　测试本章代码
2.6　本章小结
第3章　指令集
3.1　指令集介绍
3.2　指令编码格式
3.3　指令解码
3.4　测试本章代码
3.5　本章小结
第4章　Lua API
4.1　Lua API介绍
4.2　Lua栈
4.3　Lua State
4.4　测试本章代码
4.5　本章小结
第5章　Lua运算符
5.1　Lua运算符介绍
5.2　自动类型转换
5.3　扩展LuaState接口
5.4　测试本章代码
5.5　本章小结
第6章　虚拟机雏形
6.1　添加LuaVM接口
6.2　实现Lua虚拟机指令
6.3　指令分派
6.4　测试本章代码
6.5　本章小结
第7章　表
7.1　表介绍
7.2　表内部实现
7.3　表相关API
7.4　表相关指令
7.5　测试本章代码
7.6　本章小结
第8章　函数调用
8.1　函数调用介绍
8.2　函数调用栈
8.3　函数调用API
8.4　函数调用指令
8.5　测试本章代码
8.6　本章小结
第9章　Go函数调用
9.1　Go函数登场
9.2　Lua注册表
9.3　全局环境
9.4　测试本章代码
9.5　本章小结
第10章　闭包和Upvalue
10.1　闭包和Upvalue介绍
10.2　Upvalue底层支持
10.3　Upvalue相关指令
10.4　测试本章代码
10.5　本章小结
第11章　元编程
11.1　元表和元方法介绍
11.2　支持元表
11.3　调用元方法
11.4　扩展Lua API
11.5　测试本章代码
11.6　本章小结
第12章　迭代器
12.1　迭代器介绍
12.2　next（）函数
12.3　通用for循环指令
12.4　测试本章代码
12.5　本章小结
第13章　异常和错误处理
13.1　异常和错误处理介绍
13.2　异常和错误处理API
13.3　error（）和pcall（）函数
13.4　测试本章代码
13.5　本章小结
第三部分　Lua语法和编译器
第14章　词法分析
14.1　编译器介绍
14.2　Lua词法介绍
14.3　实现词法分析器
14.4　LookAhead（）和其他方法
14.5　测试本章代码
14.6　本章小结
第15章　抽象语法树
15.1　抽象语法树介绍
15.2　Chunk和块
15.3　语句
15.4　表达式
15.5　本章小结
第16章　语法分析
16.1　语法分析介绍
16.2　解析块
16.3　解析语句
16.4　解析表达式
16.5　测试本章代码
16.6　本章小结
第17章　代码生成
17.1　定义funcInfo结构体
17.2　编译块
17.3　编译语句
17.4　编译表达式
17.5　生成函数原型
17.6　使用编译器
17.7　测试本章代码
17.8　本章小结
第四部分　Lua标准库
第18章　辅助API和基础库
18.1　Lua标准库介绍
18.2　辅助API
18.3　基础库
18.4　测试本章代码
18.5　本章小结
第19章　工具库
19.1　数学库
19.2　表库
19.3　字符串库
19.4　UTF-8库
19.5　OS库
19.6　本章小结
第20章　包和模块
20.1　包和模块介绍
20.2　实现包库
20.3　测试本章代码
20.4　本章小结
第21章　协程
21.1　协程介绍
21.2　协程API
21.3　实现协程库
21.4　测试本章代码
21.5　本章小结
附录A　Lua虚拟机指令集
附录B　Lua语法EBNF描述
后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>自己动手实现Lua
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>揭秘Java虚拟机
第1章 Java虚拟机概述	1
1.1 从机器语言到Java——詹爷，你好	1
1.2 兼容的选择：一场生产力的革命	6
1.3 中间语言翻译	10
1.3.1 从中间语言翻译到机器码	11
1.3.2 通过C程序翻译	11
1.3.3 直接翻译为机器码	13
1.3.4 本地编译	16
1.4 神奇的指令	18
1.4.1 常见汇编指令	20
1.4.2 JVM指令	21
1.5 本章总结	24
第2章 Java执行引擎工作原理：方法调用	25
2.1 方法调用	26
2.1.1 真实的机器调用	26
2.1.2 C语言函数调用	41
2.2 JVM的函数调用机制	47
2.3 函数指针	53
2.4 CallStub函数指针定义	60
2.5 _call_stub_entry例程	72
2.6 本章总结	115
第3章 Java数据结构与面向对象	117
3.1 从Java算法到数据结构	118
3.2 数据类型简史	122
3.3 Java数据结构之偶然性	129
3.4 Java类型识别	132
3.4.1 class字节码概述	133
3.4.2 魔数与JVM内部的int类型	136
3.4.3 常量池与JVM内部对象模型	137
3.5 大端与小端	143
3.5.1 大端和小端的概念	146
3.5.2 大小端产生的本质原因	148
3.5.3 大小端验证	149
3.5.4 大端和小端产生的场景	151
3.5.5 如何解决字节序反转	154
3.5.6 大小端问题的避免	156
3.5.7 JVM对字节码文件的大小端处理	156
3.6 本章总结	159
第4章 Java字节码实战	161
4.1 字节码格式初探	161
4.1.1 准备测试用例	162
4.1.2 使用javap命令分析字节码文件	162
4.1.3 查看字节码二进制	165
4.2 魔数与版本	166
4.2.1 魔数	168
4.2.2 版本号	168
4.3 常量池	169
4.3.1 常量池的基本结构	169
4.3.2 JVM所定义的11种常量	170
4.3.3 常量池元素的复合结构	170
4.3.4 常量池的结束位置	172
4.3.5 常量池元素总数量	172
4.3.6 第一个常量池元素	173
4.3.7 第二个常量池元素	174
4.3.8 父类常量	174
4.3.9 变量型常量池元素	175
4.4 访问标识与继承信息	177
4.4.1 access_flags	177
4.4.2 this_class	178
4.4.3 super_class	179
4.4.4 interface	179
4.5 字段信息	180
4.5.1 fields_count	180
4.5.2 field_info fields[fields_count]	181
4.6 方法信息	185
4.6.1 methods_count	185
4.6.2 method_info methods[methods_count]	185
4.7 本章回顾	205
第5章 常量池解析	206
5.1 常量池内存分配	208
5.1.1 常量池内存分配总体链路	209
5.1.2 内存分配	215
5.1.3 初始化内存	223
5.2 oop-klass模型	224
5.2.1 两模型三维度	225
5.2.2 体系总览	227
5.2.3 oop体系	229
5.2.4 klass体系	231
5.2.5 handle体系	234
5.2.6 oop、klass、handle的相互转换	239
5.3 常量池klass模型（1）	244
5.3.1 klassKlass实例构建总链路	246
5.3.2 为klassOop申请内存	249
5.3.3 klassOop内存清零	253
5.3.4 初始化mark	253
5.3.5 初始化klassOop._metadata	258
5.3.6 初始化klass	259
5.3.7 自指	260
5.4 常量池klass模型（2）	261
5.4.1 constantPoolKlass模型构建	261
5.4.2 constantPoolOop与klass	264
5.4.3 klassKlass终结符	267
5.5 常量池解析	267
5.5.1 constantPoolOop域初始化	268
5.5.2 初始化tag	269
5.5.3 解析常量池元素	271
5.6 本章总结	279
第6章 类变量解析	280
6.1 类变量解析	281
6.2 偏移量	285
6.2.1 静态变量偏移量	285
6.2.2 非静态变量偏移量	287
6.2.3 Java字段内存分配总结	312
6.3 从源码看字段继承	319
6.3.1 字段重排与补白	319
6.3.2 private字段可被继承吗	325
6.3.3 使用HSDB验证字段分配与继承	329
6.3.4 引用类型变量内存分配	338
6.4 本章总结	342
第7章 Java栈帧	344
7.1 entry_point例程生成	345
7.2 局部变量表创建	352
7.2.1 constMethod的内存布局	352
7.2.2 局部变量表空间计算	356
7.2.3 初始化局部变量区	359
7.3 堆栈与栈帧	368
7.3.1 栈帧是什么	368
7.3.2 硬件对堆栈的支持	387
7.3.3 栈帧开辟与回收	390
7.3.4 堆栈大小与多线程	391
7.4 JVM的栈帧	396
7.4.1 JVM栈帧与大小确定	396
7.4.2 栈帧创建	399
7.4.3 局部变量表	421
7.5 栈帧深度与slot复用	433
7.6 最大操作数栈与操作数栈复用	436
7.7 本章总结	439
第8章 类方法解析	440
8.1 方法签名解析与校验	445
8.2 方法属性解析	447
8.2.1 code属性解析	447
8.2.2 LVT&LVTT	449
8.3 创建methodOop	455
8.4 Java方法属性复制	459
8.5 与	461
8.6 查看运行时字节码指令	482
8.7 vtable	489
8.7.1 多态	489
8.7.2 C++中的多态与vtable	491
8.7.3 Java中的多态实现机制	493
8.7.4 vtable与invokevirtual指令	500
8.7.5 HSDB查看运行时vtable	502
8.7.6 miranda方法	505
8.7.7 vtable特点总结	508
8.7.8 vtable机制逻辑验证	509
8.8 本章总结	511
第9章 执行引擎	513
9.1 执行引擎概述	514
9.2 取指	516
9.2.1 指令长度	519
9.2.2 JVM的两级取指机制	527
9.2.3 取指指令放在哪	532
9.2.4 程序计数器在哪里	534
9.3 译码	535
9.3.1 模板表	535
9.3.2 汇编器	540
9.3.3 汇编	549
9.4 栈顶缓存	558
9.5 栈式指令集	565
9.6 操作数栈在哪里	576
9.7 栈帧重叠	581
9.8 entry_point例程机器指令	586
9.9 执行引擎实战	588
9.9.1 一个简单的例子	588
9.9.2 字节码运行过程分析	590
9.10 字节码指令实现	597
9.10.1 iconst_3	598
9.10.2 istore_0	599
9.10.3 iadd	600
9.11 本章总结	601
第10章 类的生命周期	602
10.1 类的生命周期概述	602
10.2 类加载	605
10.2.1 类加载——镜像类与静态字段	611
10.2.2 Java主类加载机制	617
10.2.3 类加载器的加载机制	622
10.2.4 反射加载机制	623
10.2.5 import与new指令	624
10.3 类的初始化	625
10.4 类加载器	628
10.4.1 类加载器的定义	628
10.4.2 系统类加载器与扩展类加载器创建	634
10.4.3 双亲委派机制与破坏	636
10.4.4 预加载	638
10.4.5 引导类加载	640
10.4.6 加载、链接与延迟加载	641
10.4.7 父加载器	645
10.4.8 加载器与类型转换	648
10.5 类实例分配	649
10.5.1 栈上分配与逃逸分析	652
10.5.2 TLAB	655
10.5.3 指针碰撞与eden区分配	657
10.5.4 清零	658
10.5.5 偏向锁	658
10.5.6 压栈与取指	659
10.6 本章总结	661
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>揭秘Java虚拟机
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>自己动手写Python虚拟机
第1章编程语言虚拟机1
1.1编程语言的发展1
1.2编程语言虚拟机2
1.3开发环境5
第2章编译流程6
2.1Python字节码6
2.2词法分析7
2.3文法分析10
2.4抽象语法树13
2.4.1构建AST14
2.4.2递归程序的本质16
2.4.3访问者模式21
2.4.4用Visitor重写AST29
第3章二进制文件结构32
3.1pyc文件格式32
3.2加载CodeObject34
3.2.1准备工具36
3.2.2创建CodeObject41
3.3整理工程结构47
3.4执行字节码49
第4章实现控制流55
4.1分支结构55
4.1.1条件判断56
4.1.2跳转59
4.1.3True、False和None60
4.2循环结构62
4.2.1变量62
4.2.2循环内的跳转67
第5章基本的数据类型75
5.1KlassOop二元结构75
5.2整数78
5.3字符串82
第6章函数和方法85
6.1函数85
6.1.1栈帧86
6.1.2创建FunctionObject89
6.1.3调用方法92
6.2变量和参数96
6.2.1LEGB规则96
6.2.2函数的参数104
6.2.3参数默认值107
6.3Native函数111
6.4方法115
第7章列表和字典122
7.1列表122
7.1.1列表的定义122
7.1.2操作列表126
7.2字典154
7.2.1字典的定义154
7.2.2操作字典157
7.3增强函数功能165
7.3.1灵活多变的函数参数165
7.3.2闭包和函数修饰器172
7.4总结179
第8章类和对象180
8.1类型对象180
8.1.1TypeObject180
8.1.2object185
8.1.3通过类型创建对象189
8.2自定义类型191
8.3创建对象196
8.4操作符重载206
8.5继承215
第9章垃圾回收223
9.1自动内存管理223
9.1.1概念定义223
9.1.2引用计数224
9.1.3图的知识226
9.1.4Tracing GC231
9.2复制回收234
9.2.1算法描述234
9.2.2算法实现235
9.2.3建堆237
9.2.4在堆中创建对象243
9.2.5垃圾回收247
第10章模块和库261
10.1import语句261
10.1.1ModuleObject262
10.1.2加载模块264
10.1.3from子句266
10.2builtin模块268
10.3加载动态库271
10.3.1定义接口27
10.3.2实现math module277
第11章迭代281
11.1异常281
11.1.1finally子句281
11.1.2break和continue287
11.1.3Exception291
11.2自定义迭代器类306
11.3Generator309
11.3.1yield语句309
11.3.2Generator对象311
11.4总结317
附录APython2字节码表318
附录B高级算法321
B.1字符串查找321
B.2排序算法325
B.2.1快速排序325
B.2.2选择排序328
B.2.3堆排序329
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>自己动手写Python虚拟机
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机规范(Java SE 7版)
《java虚拟机规范(java se 7版)》
译者序
前言
第2版前言
第1版前言
第1章　引言1
1.1　简史1
1.2　java虚拟机2
1.3　各章节摘要2
1.4　说明3
第2章　java虚拟机结构4
2.1　class文件格式4
2.2　数据类型5
2.3　原始类型与值5
2.3.1　整数类型与整型值6
2.3.2　浮点类型、取值集合及浮点值6
2.3.3　returnaddress类型和值8
2.3.4　boolean类型8
2.4　引用类型与值9
2.5　运行时数据区9
.2.5.1　pc寄存器9
2.5.2　java虚拟机栈9
2.5.3　java堆10
2.5.4　方法区11
2.5.5　运行时常量池11
2.5.6　本地方法栈11
2.6　栈帧12
2.6.1　局部变量表13
2.6.2　操作数栈13
2.6.3　动态链接14
2.6.4　方法正常调用完成14
2.6.5　方法异常调用完成15
2.7　对象的表示15
2.8　浮点算法15
2.8.1　java虚拟机和ieee 754中的浮点算法15
2.8.2　浮点模式16
2.8.3　数值集合转换16
2.9　特殊方法17
2.10　异常18
2.11　字节码指令集简介20
2.11.1　数据类型与java虚拟机21
2.11.2　加载和存储指令23
2.11.3　算术指令23
2.11.4　类型转换指令24
2.11.5　对象创建与操作26
2.11.6　操作数栈管理指令26
2.11.7　控制转移指令27
2.11.8　方法调用和返回指令27
2.11.9　抛出异常28
2.11.10　同步28
2.12　类库28
2.13　公有设计，私有实现29
第3章　java虚拟机编译器30
3.1　示例的格式说明30
3.2　常量、局部变量和控制结构的使用31
3.3　算术运算35
3.4　访问运行时常量池35
3.5　更多控制结构示例36
3.6　接收参数39
3.7　方法调用39
3.8　使用类实例42
3.9　数组43
3.10　编译switch语句45
3.11　使用操作数栈46
3.12　抛出异常和处理异常47
3.13　编译finally语句块50
3.14　同步53
3.15　注解54
第4章　class文件格式55
4.1　classfile结构56
4.2　各种内部表示名称60
4.2.1　类和接口的二进制名称60
4.2.2　非全限定名60
4.3　描述符和签名61
4.3.1　语法符号61
4.3.2　字段描述符61
4.3.3　方法描述符63
4.3.4　签名63
4.4　常量池66
4.4.1　constant_class_info结构67
4.4.2　constant_fieldref_info、constant_methodref_info和constant_interface methodref_info结构67
4.4.3　constant_string_info结构69
4.4.4　constant_integer_info和constant_float_info结构69
4.4.5　constant_long_info和constant_double_info结构70
4.4.6　constant_nameandtype_info结构71
4.4.7　constant_utf8_info结构72
4.4.8　constant_methodhandle_info结构74
4.4.9　constant_methodtype_info结构74
4.4.10　constant_invokedynamic_info结构75
4.5　字段75
4.6　方法77
4.7　属性80
4.7.1　自定义和命名新的属性81
4.7.2　constantvalue属性81
4.7.3　code属性82
4.7.4　stackmaptable属性85
4.7.5　exceptions属性91
4.7.6　innerclasses属性92
4.7.7　enclosingmethod属性94
4.7.8　synthetic属性94
4.7.9　signature属性95
4.7.10　sourcefile属性96
4.7.11　sourcedebugextension属性96
4.7.12　linenumbertable属性97
4.7.13　localvariabletable属性98
4.7.14　localvariabletypetable属性99
4.7.15　deprecated属性101
4.7.16　runtimevisibleannotations属性101
4.7.17　runtimeinvisible annotations属性105
4.7.18　runtimevisibleparameter annotations属性106
4.7.19　runtimeinvisibleparameter annotations属性107
4.7.20　annotationdefault属性108
4.7.21　bootstrapmethods属性108
4.8　格式检查110
4.9　java虚拟机代码约束110
4.9.1　静态约束110
4.9.2　结构化约束113
4.10　class文件校验115
4.10.1　类型检查验证116
4.10.2　类型推导验证178
4.11　java虚拟机限制184
第5章　加载、链接与初始化186
5.1　运行时常量池186
5.2　虚拟机启动188
5.3　创建和加载188
5.3.1　使用引导类加载器来加载类型190
5.3.2　使用用户自定义类加载器来加载类型190
5.3.3　创建数组类191
5.3.4　加载限制191
5.3.5　从class文件表示得到类192
5.4　链接193
5.4.1　验证194
5.4.2　准备194
5.4.3　解析195
5.4.4　访问控制201
5.4.5　方法覆盖201
5.5　初始化202
5.6　绑定本地方法实现203
5.7　java虚拟机退出203
第6章　java虚拟机指令集204
6.1　设定：“必须”的含义204
6.2　保留操作码204
6.3　虚拟机错误205
6.4　指令描述格式205
6.5　指令集描述207
第7章　操作码助记符293
附录a　limited license grant300
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机规范(Java SE 7版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala程序设计
第1章 简介	1
1.1 为何选择Scala	1
1.2 何为Scala	3
1.3 函数式编程	7
1.4 本书的内容	9
1.5 本书面向的读者	11
1.6 致谢	11
第2章 起步	13
2.1 下载Scala	13
2.2 安装Scala	13
2.2.1 在Windows上安装Scala	14
2.2.2 在类UNIX系统上安装Scala	14
2.3 让Scala跑起来	15
2.4 命令行上的Scala	16
2.5 把Scala代码当作脚本运行	17
2.5.1 在类UNIX系统上作为脚本运行	17
2.5.2 在Windows上作为脚本运行	18
2.6 在IDE里面运行Scala	18
2.7 编译Scala	19
第3章 Scala步入正轨	20
3.1 把Scala当作简洁的Java	20
3.2 Java基本类型对应的Scala类	23
3.3 元组与多重赋值	23
3.4 字符串与多行原始字符串	25
3.5 自适应的默认做法	26
3.6 运算符重载	27
3.7 Scala带给Java程序员的惊奇	29
3.7.1 赋值的结果	29
3.7.2 Scala的==	30
3.7.3 分号是半可选的	31
3.7.4 默认的访问修饰符	32
3.7.5 默认的访问修饰符以及如何修改	32
3.7.6 Scala的Protected	33
3.7.7 细粒度访问控制	34
3.7.8 避免显式return	35
第4章 Scala的类	37
4.1 创建类	37
4.2 定义字段、方法和构造函数	38
4.3 类继承	41
4.4 单例对象	42
4.5 独立对象和伴生对象	43
4.6 Scala中的static	44
第5章 自适应类型	46
5.1 容器和类型推演	47
5.2 Any类型	49
5.3 关于Nothing的更多情况	50
5.4 Option类型	50
5.5 方法返回类型推演	51
5.6 传递变参	52
5.7 参数化类型的可变性	53
第6章 函数值和闭包	57
6.1 从普通函数迈向高阶函数	57
6.2 函数值	58
6.3 具有多参数的函数值	59
6.4 Curry化	61
6.5 重用函数值	62
6.6 参数的位置记法	64
6.7 Execute Around Method模式	65
6.8 偏应用函数	67
6.9 闭包	68
第7章 Trait和类型转换	70
7.1 Trait	70
7.2 选择性混入	72
7.3 以trait进行装饰	74
7.4 Trait方法的延迟绑定	75
7.5 隐式类型转换	77
第8章 使用容器	81
8.1 常见的Scala容器	81
8.2 使用Set	82
8.3 使用Map	83
8.4 使用List	85
8.5 for表达式	90
第9章 模式匹配和正则表达式	93
9.1 匹配字面量和常量	93
9.2 匹配通配符	94
9.3 匹配元组和列表	94
9.4 类型和卫述句的匹配	96
9.5 case表达式里的模式变量和常量	96
9.6 对XML片段进行模式匹配	98
9.7 使用case类进行模式匹配	98
9.8 使用提取器进行匹配	100
9.9 正则表达式	103
9.10 把正则表达式当做提取器	104
第10章 并发编程	106
10.1 促进不变性	106
10.2 使用Actor的并发	107
10.3 消息传递	110
10.4 Actor类	113
10.5 actor方法	115
10.6 receive和receiveWithin方法	117
10.7 react和reactWithin方法	120
10.8 loop和loopWhile	124
10.9 控制线程执行	125
10.10 在各种接收方法中选择	127
第11章 与Java互操作	128
11.1 在Scala里使用Scala类	128
11.2 在Scala里使用Java类	130
11.3 在Java里使用Scala类	132
11.3.1 有普通函数和高阶函数的Scala类	132
11.3.2 同trait一起工作	134
11.3.3 单例对象和伴生对象	134
11.4 继承类	136
第12章 用Scala做单元测试	138
12.1 使用JUnit	138
12.2 使用ScalaTest	139
12.3 以Canary测试开始	140
12.4 使用Runner	140
12.5 Asserts	142
12.6 异常测试	144
12.7 在测试间共享代码	146
12.7.1 用BeforeAndAfter共享代码	146
12.7.2 用闭包共享代码	147
12.8 FunSuite的函数式风格	148
12.9 用JUnit运行ScalaTest	149
第13章 异常处理	152
13.1 异常处理	152
13.2 注意catch顺序	154
第14章 使用Scala	156
14.1 净资产应用实例	156
14.2 获取用户输入	156
14.3 读写文件	157
14.4 XML，作为一等公民	159
14.5 读写XML	161
14.6 从Web获取股票价格	164
14.7 让净资产应用并发	167
14.8 为净资产应用增加GUI	168
附录A Web资源	178
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Android
推荐序
前言
第1章　本书必读1
1.1　概述1
1.2　准备环境和工具2
1.2.1　准备源代码2
1.2.2　准备Source Insight2
1.2.3　准备模拟器和自制系统镜像5
1.2.4　小结8
1.3　本书的内容9
1.4　本书资源下载说明12
第2章　深入理解Class文件格式13
2.1　Class文件格式总览13
2.2　常量池及相关内容14
2.2.1　常量项的类型和关系14
2.2.2　信息描述规则18
2.2.3　常量池实例剖析19
2.3　field_info和method_info19
2.4　access_flags介绍21
2.5　属性介绍22
2.5.1　属性概貌22
2.5.2　Code属性23
2.5.3　LineNumberTable属性25
2.5.4　LocalVariableTable属性26
2.6　Java指令码介绍27
2.6.1　指令码和助记符27
2.6.2　如何阅读规范28
2.7　学习路线推荐30
2.8　参考资料30
第3章　深入理解Dex文件格式31
3.1　Dex文件格式总览31
3.1.1　Dex和Class文件格式的区别31
3.1.2　Dex文件格式的概貌35
3.2　认识Dex文件36
3.2.1　header_item36
3.2.2　string_id_item等37
3.2.3　class_def38
3.2.4　code_item40
3.3　Dex指令码介绍41
3.3.1　insns的组织形式41
3.3.2　指令码描述规则42
3.4　学习路线推荐44
3.5　参考资料45
第4章　深入理解ELF文件格式46
4.1　概述46
4.2　ELF文件格式介绍46
4.2.1　ELF文件头结构介绍47
4.2.2　Linking View下的ELF52
4.2.3　Execution View下的ELF61
4.2.4　实例分析：调用动态库中的函数65
4.2.5　ELF总结72
4.3　学习路线推荐73
4.4　参考资料73
第5章　认识C++1174
5.1　数据类型76
5.1.1　基本内置数据类型介绍76
5.1.2　指针、引用和void类型77
5.1.3　字符和字符串81
5.1.4　数组82
5.2　C++源码构成及编译83
5.2.1　头文件示例83
5.2.2　源文件示例85
5.2.3　编译86
5.3　Class介绍88
5.3.1　构造、赋值和析构函数89
5.3.2　类的派生和继承97
5.3.3　友元和类的前向声明103
5.3.4　explicit构造函数105
5.3.5　C++中的struct106
5.4　操作符重载106
5.4.1　操作符重载的实现方式107
5.4.2　输出和输入操作符重载108
5.4.3　->和*操作符重载110
5.4.4　new和delete操作符重载111
5.4.5　函数调用运算符重载117
5.5　函数模板与类模板118
5.5.1　函数模板119
5.5.2　类模板122
5.6　lambda表达式125
5.7　STL介绍127
5.7.1　string类128
5.7.2　容器类129
5.7.3　算法和函数对象介绍134
5.7.4　智能指针类138
5.7.5　探讨STL的学习140
5.8　其他常用知识141
5.8.1　initializer_list141
5.8.2　带作用域的enum141
5.8.3　constexpr142
5.8.4　static_assert143
5.9　参考资料143
第6章　编译dex字节码为机器码145
6.1　编译器全貌介绍147
6.2　编译器前端介绍150
6.2.1　词法分析和lex151
6.2.2　语法分析和yacc160
6.2.3　语义分析和IR生成介绍171
6.3　优化器介绍175
6.3.1　构造CFG176
6.3.2　分析和处理CFG181
6.3.3　数据流分析与SSA191
6.3.4　IR优化204
6.4　ART中的IR—HInstruction222
6.4.1　ART中的IR222
6.4.2　IR之间的关系225
6.4.3　ART IR对象的初始化231
6.5　寄存器分配233
6.5.1　LSRA介绍235
6.5.2　LSRA相关代码介绍247
6.6　机器码生成相关代码介绍271
6.6.1　GenerateFrameEntry272
6.6.2　VisitAdd和VisitInstance-FieldGet273
6.6.3　GenerateSlowPaths275
6.7　总结277
6.8　参考资料280
第7章　虚拟机的创建283
7.1　概述284
7.1.1　JniInvocation Init函数介绍286
7.1.2　AndroidRuntime startVm函数介绍287
7.2　Runtime Create介绍288
7.2.1　Create函数介绍288
7.2.2　Init函数介绍290
7.3　MemMap与OatFileManager293
7.3.1　MemMap介绍293
7.3.2　OatFileManager介绍298
7.4　FaultManager介绍302
7.4.1　信号处理和SignalAction介绍302
7.4.2　FaultManager介绍307
7.5　Thread介绍311
7.5.1　Startup函数介绍311
7.5.2　Attach函数介绍312
7.6　Heap学习之一325
7.6.1　初识Heap中的关键类326
7.6.2　Heap构造函数第一部分337
7.7　JavaVMExt和JNIEnvExt340
7.7.1　JavaVMExt341
7.7.2　JNIEnvExt343
7.7.3　总结344
7.8　ClassLinker345
7.8.1　关键类介绍345
7.8.2　ClassLinker构造函数352
7.8.3　InitFromBootImage353
7.8.4　ClassLinker总结360
7.9　总结和阅读指导362
第8章　虚拟机的启动363
8.1　Runtime Start364
8.2　初识JNI365
8.2.1　JNI中的数据类型365
8.2.2　ScopedObjectAccess等辅助类367
8.2.3　常用JNI函数介绍369
8.3　Jit LoadCompilerLibrary373
8.4　Runtime InitNativeMethods374
8.4.1　JniConstants Init374
8.4.2　RegisterRuntimeNative Methods375
8.4.3　WellKnownClasses Init和LastInit376
8.5　Thread相关376
8.5.1　Runtime InitThreadGroups377
8.5.2　Thread FinishSetup377
8.5.3　Runtime StartDaemonThreads380
8.6　Runtime CreateSystemClassLoader381
8.7　类的加载、链接和初始化383
8.7.1　关键类介绍383
8.7.2　SetupClass392
8.7.3　LoadClass相关函数393
8.7.4　LinkClass相关函数398
8.7.5　DefineClass414
8.7.6　Verify相关函数416
8.7.7　Initialize相关函数424
8.7.8　ClassLinker中其他常用函数426
8.7.9　ClassLoader介绍437
8.8　虚拟机创建和启动关键内容梳理445
第9章　深入理解dex2oat447
9.1　概述448
9.2　ParseArgs介绍452
9.2.1　CompilerOptions类介绍453
9.2.2　ProcessOptions函数介绍454
9.2.3　InsertCompileOptions函数介绍455
9.3　OpenFile介绍456
9.4　Setup介绍458
9.4.1　Setup代码分析之一458
9.4.2　Setup代码分析之二464
9.4.3　Setup代码分析之三474
9.4.4　Setup代码分析之四484
9.5　CompileImage484
9.5.1　Compile485
9.5.2　ArtCompileDEX496
9.5.3　OptimizingCompiler JniCompile499
9.5.4　OptimizingCompiler Compile527
9.6　OAT和ART文件格式介绍544
9.6.1　OAT文件格式544
9.6.2　ART文件格式550
9.6.3　oatdump介绍554
9.7　总结561
第10章　解释执行和JIT562
10.1　基础知识564
10.1.1　LinkCode564
10.1.2　Runtime ArtMethod566
10.1.3　栈和参数传递572
10.2　解释执行580
10.2.1　art_quick_to_interpreter_bridge580
10.2.2　artQuickToInterpreter-Bridge582
10.2.3　EnterInterpreterFromEntry-Point584
10.2.4　调用栈的管理和遍历593
10.3　ART中的JIT599
10.3.1　Jit、JitCodeCache等600
10.3.2　JIT阈值控制与处理609
10.3.3　OSR的处理612
10.4　HDeoptimize的处理615
10.4.1　VisitDeoptimize相关616
10.4.2　QuickExceptionHandler相关618
10.4.3　解释执行中关于Deoptimize的处理621
10.5　Instrumentation介绍623
10.5.1　MethodEnterEvent和MethodExitEvent624
10.5.2　DexPcMovedEvent625
10.6　异常投递和处理625
10.6.1　抛异常626
10.6.2　异常处理629
10.7　总结635
第11章　ART中的JNI636
11.1　JavaVM和JNIEnv637
11.1.1　JavaVMExt相关介绍638
11.1.2　JNIEnvExt介绍642
11.2　Java native方法的调用644
11.2.1　art_jni_dlsym_lookup_stub644
11.2.2　art_quick_generic_jni_trampoline646
11.3　CallStaticVoidMethod651
11.4　JNI中引用型对象的管理653
11.4.1　关键类介绍653
11.4.2　JniMethodStart和JniMethod-End657
11.4.3　IndirectReferenceTable相关函数658
11.4.4　NewObject和jobject的含义660
11.4.5　JNI中引用对象相关662
11.4.6　PushLocalFrame和PopLocalFrame663
11.4.7　回收引用对象664
11.5　总结666
第12章　CheckPoints、线程同步及信号处理668
12.1　CheckPoints介绍669
12.1.1　设置Check Point标志位670
12.1.2　Check Points的设置672
12.1.3　执行检查点处的任务676
12.2　ThreadList和ThreadState681
12.2.1　线程ID683
12.2.2　RunCheckpoint和Dump684
12.2.3　SuspendAll和ResumeAll687
12.2.4　Thread状态切换690
12.3　线程同步相关知识691
12.3.1　关键类介绍692
12.3.2　synchronized的处理697
12.3.3　Object wait、notifyAll等705
12.4　volatile成员的读写707
12.4.1　基础知识707
12.4.2　解释执行模式下的处理711
12.4.3　机器码执行模式的处理712
12.5　信号处理714
12.5.1　zygote进程的处理714
12.5.2　非zygote进程的处理716
12.6　总结719
第13章　内存分配与释放720
13.1　Space等关键类介绍722
13.2　ZygoteSpace723
13.3　BumpPointerSpace和RegionSpace725
13.3.1　BumpPointerSpace726
13.3.2　RegionSpace733
13.4　DlMallocSpace和RosAlloc-Space740
13.4.1　DlMallocSpace741
13.4.2　RosAllocSpace745
13.4.3　rosalloc介绍748
13.5　LargeObjectMapSpace760
13.6　new-instance/array指令的处理762
13.6.1　设置内存分配器762
13.6.2　解释执行模式下的处理767
13.6.3　机器码执行模式下的处理770
13.6.4　Heap AllocObjectWith-Allocator773
13.7　细观Space779
13.7.1　Space类779
13.7.2　ContinuousSpace和Discon-tinuousSpace类781
13.7.3　MemMapSpace和Continuous MemMapAllocSpace类782
13.7.4　MallocSpace类783
13.8　Heap学习之二784
13.8.1　Heap构造函数784
13.8.2　关键类介绍792
13.8.3　ObjectVisitReferences806
13.9　总结812
第14章　ART中的GC813
14.1　GC基础知识814
14.1.1　Mark-Sweep Collection原理介绍815
14.1.2　Copying Collection原理介绍817
14.1.3　Mark-Compact Collection原理介绍818
14.1.4　其他概念819
14.2　Runtime VisitRoots819
14.2.1　关键数据结构821
14.2.2　Thread VisitRoots824
14.3　ART GC概览827
14.3.1　关键数据结构827
14.3.2　ART GC选项830
14.3.3　创建回收器和设置回收策略832
14.4　MarkSweep835
14.4.1　Heap相关成员变量取值情况835
14.4.2　MarkSweep概貌837
14.4.3　MarkingPhase840
14.4.4　PausePhase848
14.4.5　ReclaimPhase851
14.4.6　FinishPhase857
14.4.7　PartialMarkSweep857
14.4.8　StickyMarkSweep858
14.4.9　Concurrent MarkSweep864
14.4.10　Parallel GC868
14.4.11　MarkSweep小结869
14.5　ConcurrentCopying870
14.5.1　InitalizePhase871
14.5.2　FlipThreadRoots873
14.5.3　MarkingPhase881
14.5.4　ReclaimPhase883
14.5.5ConcurrentCopying小结885
14.6　MarkCompact885
14.6.1　MarkingPhase886
14.6.2　ReclaimPhase889
14.6.3　MarkCompact小结891
14.7　SemiSpace892
14.7.1　InitializePhase893
14.7.2　MarkingPhase894
14.7.3　SemiSpace小结898
14.8　Java Reference对象的处理899
14.8.1　基础知识899
14.8.2　MarkSweep中Reference对象的处理903
14.8.3ReferenceProcessor904
14.8.4　PhantomReference的处理912
14.8.5　finalize函数的调用913
14.8.6　Reference处理小结917
14.9　Heap学习之三917
14.9.1　Heap Trim917
14.9.2　CollectGarbageInternal919
14.9.3　PreZygoteFork924
14.9.4　内存碎片的解决926
14.10　总结927
14.11　参考资料928
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Android
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入嵌入式Java虚拟机
第一章 Java与KVM的关系
第二章 Java类文件格式
第三章 KVM执行时所用的class与instance结构
第四章 KVM执行时所用的数据结构
第五章 KVM内部的Interpreter
第六章 Methods invokation
第七章 Exceptions
第八章 Garbage Collection
第九章 编写KVM的native methods
第十章 The Technology Compatibility Kit(TCK)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入嵌入式Java虚拟机
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>解析Java虚拟机开发
第1章一起走进Java世界
1.1 Java的优势
1.1.1 排名第一的编程语言
1.1.2 提供给我们美好的就业前景
1.2 学习Java需要了解的那些事
1.2.1 品Java语言的发展历史
1.2.2 Java的特点
1.3 剖析Java的运行机制
1.3.1 高级语言的运行机制
1.3.2 Java的运行机制
1.3.3 Java虚拟机ⅧIVM
1.3.4 独特的垃圾回收机制
1.4 剖析Java语言体系
1.4.1 Java程序员的6个级别
1.4.2 分析Java体系的构成
1.5 Java虚拟机家族
1.5.1 虚拟机的用途
1.5.2 理解Iava虚拟机
1.5.3 Java虚拟机的数据类型
1.5.4 Java虚拟机体系结构
1.5.5 探索Java虚拟机家族成员的发展史
1.6 Java的最大优势——平台无关性
1.6.1 平台无关性的好处
1.6.2 Java对平台无关性的支持
1.6.3 分析影响Java平台无关性的因素
1.6.4 实现平台无关性的策略
第2章 JDK编译测试
第3章 安全性的考虑
第4章 通过网络实现移动性
第5章 浅谈Java虚拟机的内部机制
第6章 详解Class文件
第7章 栈和局部变量操作
第8章 内存异常和垃圾处理
第9章 高效手段之性能监控工具和优化部署
第10章 JVM参数分析和调优实战
第11章 虚拟机类的加载机制
第12章 研究高效之魂
第13章 类加载器和执行子系统
第14章 编译优化
第15章 运行期优化
第16章 内存模型和线程
第17章 安全和优化合二为一
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>解析Java虚拟机开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机并发编程
译者序
前言
第1章 并发的威力与风险 1
1.1 线程：程序的执行流程 1
1.2 并发的威力 1
1.3 并发的风险 4
1.4 小结 9
第一部分 并发策略
第2章 分工原则 11
2.1 从顺序到并发 11
2.2 在IO密集型应用程序中使用并发技术 13
2.3 并发方法对IO密集型应用程序的加速效果 19
2.4 在计算密集型应用程序中使用并发技术 20
2.5 并发方法对于计算密集型应用程序的加速效果 25
2.6 有效的并发策略 26
2.7 小结 27
第3章 设计方法 28
3.1 处理状态 28
3.2 探寻设计选项 29
3.3 共享可变性设计 29
3.4 隔离可变性设计 30
3.5 纯粹不可变性设计 30
3.6 持久的/不可变的数据结构 31
3.7 选择一种设计方法 34
3.8 小结 34
第二部分 现代Java/JDK并发模型
第4章 可扩展性和线程安全 37
4.1 用ExecutorService管理线程 37
4.2 使线程协作 38
4.3 数据交换 47
4.4 Java 7 Fork-Join API 49
4.5 可扩展集合类 51
4.6 Lock和Synchronized 54
4.7 小结 58
第5章 驯服共享可变性 59
5.1 共享可变性 != Public 59
5.2 定位并发问题 59
5.3 保持不变式 61
5.4 管理好资源 62
5.5 保证可见性 64
5.6 增强并发性 65
5.7 保证原子性 67
5.8 小结 70
第三部分 软件事务内存
第6章 软件事务内存导论 71
6.1 同步与并发水火不容 71
6.2 对象模型的缺陷 72
6.3 将实体与状态分离 73
6.4 软件事务内存 74
6.5 STM中的事务 77
6.6 用STM实现并发 77
6.7 用Akka/Multiverse STM实现并发 82
6.8 创建事务 84
6.9 创建嵌套事务 90
6.10 配置Akka事务 97
6.11 阻塞事务—有意识地等待 100
6.12 提交和回滚事件 103
6.13 集合与事务 106
6.14 处理写偏斜异常 110
6.15 STM的局限性 112
6.16 小结 116
第7章 在Clojure、Groovy、Java、JRuby和Scala中使用STM 117
7.1 Clojure STM 117
7.2 Groovy集成 118
7.3 Java集成 122
7.4 JRuby集成 124
7.5 Scala中的可选方案 130
7.6 小结 133
第四部分 基于角色的并发模型
第8章 讨喜的隔离可变性 135
8.1 用角色实现隔离可变性 136
8.2 角色的特性 137
8.3 创建角色 138
8.4 收发消息 144
8.5 同时使用多个角色 148
8.6 多角色协作 152
8.7 使用类型化角色 159
8.8 类型化角色和murmurs 163
8.9 混合使用角色和STM 169
8.10 使用transactor 169
8.11 调和类型化角色 176
8.12 远程角色 182
8.13 基于角色模型的局限性 184
8.14 小结 184
第9章 在Groovy、Java、JRuby和Scala中使用角色 186
9.1 在Groovy中使用GPars提供的角色实现 186
9.2 在Java中使用Akka提供的角色实现 199
9.3 在JRuby中使用Akka提供的Actor实现 199
9.4 在Scala中使用角色 202
9.5 小结 202
第五部分 后记
第10章 并发编程之禅 205
10.1 慎重选择 205
10.2 并发：程序员指南 206
10.3 并发：架构师指南 207
10.4 明智地进行选择 208
附录1 Clojure agent 210
附录2 一些网络资源 214
参考文献 216
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机并发编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala与Clojure函数式编程模式
第1章　模式和函数式编程　　1
1.1　什么是函数式编程　　2
1.2　模式词汇表　　4
第2章　TinyWeb：让模式协同工作　　7
2.1　TinyWeb简介　　7
2.2　采用Java来编写TinyWeb　　7
2.3　采用Scala来编写TinyWeb 　　17
2.4　采用Clojure来编写TinyWeb　　25
第3章　替代面向对象模式　　35
简介　　35
模式1　替代函数式接口　　35
模式2　替代承载状态的函数式接口　　42
模式3　替代命令模式　　48
模式4　替代生成器模式来获得不可变对象　　55
模式5　替代迭代器模式　　64
模式6　替代模板方法模式　　73
模式7　替代策略模式　　81
模式8　替代空对象　　87
模式9　替代装饰器模式　　95
模式10　替代访问者模式　　99
模式11　替代依赖注入　　113
第4章　函数式模式　　121
简介　　121
模式12　尾递归模式　　121
模式13　相互递归模式　　128
模式14　Filter-Map-Reduce模式　　136
模式15　操作链模式　　139
模式16　函数生成器模式　　146
模式17　记忆模式　　159
模式18　惰性序列模式　　163
模式19　集中的可变性　　172
模式20　自定义控制流　　180
模式21　领域特定语言　　191
第5章　结束语　　201
参考文献　　202
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala与Clojure函数式编程模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机规范
目录
前言
1 Introduction
1.1 A Bit of History
1.2 The Java Virtual Machine
1.3 Organization of the Specification
1.4 Notation
1.5 Feedback
2 The Structure of the Java Virtual Machine
2.1 The  class File Format
2.2 Data Types
2.3 Primitive Types and Values
2.3.1 Integral Types and Values
2.3.2 Floating-Point Types, Value Sets, and Values
2.3.3 The  returnAddress Type and Values
2.3.4 The  boolean Type
2.4 Reference Types and Values
2.5 Run-Time Data Areas
2.5.1 The  pc Register
2.5.2 Java Virtual Machine Stacks
2.5.3 Heap
2.5.4 Method Area
2.5.5 Run-Time Constant Pool
2.5.6 Native Method Stacks
2.6 Frames
2.6.1 Local Variables
2.6.2 Operand Stacks
2.6.3 Dynamic Linking
2.6.4 Normal Method Invocation Completion
2.6.5 Abrupt Method Invocation Completion
2.7 Representation of Objects
2.8 Floating-Point Arithmetic
2.8.1 Java Virtual Machine Floating-Point Arithmetic and IEEE 754
2.8.2 Floating-Point Modes
2.8.3 Value Set Conversion
2.9 Special Methods
2.10 Exceptions
2.11 Instruction Set Summary
2.11.1 Types and the Java Virtual Machine
2.11.2 Load and Store Instructions
2.11.3 Arithmetic Instructions
2.11.4 Type Conversion Instructions
2.11.5 Object Creation and Manipulation
2.11.6 Operand Stack Management Instructions
2.11.7 Control Transfer Instructions
2.11.8 Method Invocation and Return Instructions
2.11.9 Throwing Exceptions
2.11.10 Synchronization
2.12 Class Libraries
2.13 Public Design, Private Implementation
3 Compiling for the Java Virtual Machine
3.1 Format of Examples
3.2 Use of Constants, Local Variables, and Control Constructs
3.3 Arithmetic
3.4 Accessing the Run-Time Constant Pool
3.5 More Control Examples
3.6 Receiving Arguments
3.7 Invoking Methods
3.8 Working with Class Instances
3.9 Arrays
3.10 Compiling Switches
3.11 Operations on the Operand Stack
3.12 Throwing and Handling Exceptions
3.13 Compiling finally
3.14 Synchronization
3.15 Annotations
4 The class File Format
4.1 The ClassFile Structure
4.2 The Internal Form of Names
4.2.1 Binary Class and Interface Names
4.2.2 Unqualified Names
4.3 Descriptors
4.3.1 Grammar Notation
4.3.2 Field Descriptors
4.3.3 Method Descriptors
4.4 The Constant Pool
4.4.1 The CONSTANT_Class_info Structure
4.4.2 The CONSTANT_Fieldref_info, CONSTANT_Methodref_info, and CONSTANT_InterfaceMethodref_info Structures
4.4.3 The CONSTANT_String_info Structure
4.4.4 The CONSTANT_Integer_info and CONSTANT_Float_info Structures
4.4.5 The CONSTANT_Long_info and CONSTANT_Double_info Structures
4.4.6 The CONSTANT_NameAndType_info Structure
4.4.7 The CONSTANT_Utf8_info Structure
4.4.8 The CONSTANT_MethodHandle_info Structure
4.4.9 The CONSTANT_MethodType_info Structure
4.4.10 The CONSTANT_InvokeDynamic_info Structure
4.5 Fields
4.6 Methods
4.7 Attributes
4.7.1 Defining and Naming New Attributes
4.7.2 The ConstantValue Attribute
4.7.3 The Code Attribute
4.7.4 The StackMapTable Attribute
4.7.5 The Exceptions Attribute
4.7.6 The InnerClasses Attribute
4.7.7 The EnclosingMethod Attribute
4.7.8 The Synthetic Attribute
4.7.9 The Signature Attribute
4.7.9.1 Signatures
4.7.10 The SourceFile Attribute
4.7.11 The SourceDebugExtension Attribute
4.7.12 The LineNumberTable Attribute
4.7.13 The LocalVariableTable Attribute
4.7.14 The LocalVariableTypeTable Attribute
4.7.15 The Deprecated Attribute
4.7.16 The RuntimeVisibleAnnotations Attribute
4.7.16.1 The element_value structure
4.7.17 The RuntimeInvisibleAnnotations Attribute
4.7.18 The RuntimeVisibleParameterAnnotations Attribute
4.7.19 The RuntimeInvisibleParameterAnnotations Attribute
4.7.20 The RuntimeVisibleTypeAnnotations Attribute
4.7.20.1 The target_info union
4.7.20.2 The type_path structure
4.7.21 The RuntimeInvisibleTypeAnnotations Attribute
4.7.22 The AnnotationDefault Attribute
4.7.23 The BootstrapMethods Attribute
4.7.24 The MethodParameters Attribute
4.8 Format Checking
4.9 Constraints on Java Virtual Machine Code
4.9.1 Static Constraints
4.9.2 Structural Constraints
4.10 Verification of class Files
4.10.1 Verification by Type Checking
4.10.1.1 Accessors for Java Virtual Machine Artifacts
4.10.1.2 Verification Type System
4.10.1.3 Instruction Representation
4.10.1.4 Stack Map Frame Representation
4.10.1.5 Type Checking Abstract and Native Methods
4.10.1.6 Type Checking Methods with Code
4.10.1.7 Type Checking Load and Store Instructions
4.10.1.8 Type Checking for protected Members
4.10.1.9 Type Checking Instructions
4.10.2 Verification by Type Inference
4.10.2.1 The Process of Verification by Type Inference
4.10.2.2 The Bytecode Verifier
4.10.2.3 Values of Types long and double
4.10.2.4 Instance Initialization Methods and Newly Created Objects
4.10.2.5 Exceptions and finally
4.11 Limitations of the Java Virtual Machine
5 Loading, Linking, and Initializing
5.1 The Run-Time Constant Pool
5.2 Java Virtual Machine Startup
5.3 Creation and Loading
5.3.1 Loading Using the Bootstrap Class Loader
5.3.2 Loading Using a User-defined Class Loader
5.3.3 Creating Array Classes
5.3.4 Loading Constraints
5.3.5 Deriving a Class from a class File Representation
5.4 Linking
5.4.1 Verification
5.4.2 Preparation
5.4.3 Resolution
5.4.3.1 Class and Interface Resolution
5.4.3.2 Field Resolution
5.4.3.3 Method Resolution
5.4.3.4 Interface Method Resolution
5.4.3.5 Method Type and Method Handle Resolution
5.4.3.6 Call Site Specifier Resolution
5.4.4 Access Control
5.4.5 Overriding
5.5 Initialization
5.6 Binding Native Method Implementations
5.7 Java Virtual Machine Exit
6 The Java Virtual Machine Instruction Set
6.1 Assumptions: The Meaning of "Must"
6.2 Reserved Opcodes
6.3 Virtual Machine Errors
6.4 Format of Instruction Descriptions
mnemonic
6.5 Instructions
aaload
aastore
aconst_null
aload
aload_<n>
anewarray
areturn
arraylength
astore
astore_<n>
athrow
baload
bastore
bipush
caload
castore
checkcast
d2f
d2i
d2l
dadd
daload
dastore
dcmp<op>
dconst_<d>
ddiv
dload
dload_<n>
dmul
dneg
drem
dreturn
dstore
dstore_<n>
dsub
dup
dup_x1
dup_x2
dup2
dup2_x1
dup2_x2
f2d
f2i
f2l
fadd
faload
fastore
fcmp<op>
fconst_<f>
fdiv
fload
fload_<n>
fmul
fneg
frem
freturn
fstore
fstore_<n>
fsub
getfield
getstatic
goto
goto_w
i2b
i2c
i2d
i2f
i2l
i2s
iadd
iaload
iand
iastore
iconst_<i>
idiv
if_acmp<cond>
if_icmp<cond>
if<cond>
ifnonnull
ifnull
iinc
iload
iload_<n>
imul
ineg
instanceof
invokedynamic
invokeinterface
invokespecial
invokestatic
invokevirtual
ior
irem
ireturn
ishl
ishr
istore
istore_<n>
isub
iushr
ixor
jsr
jsr_w
l2d
l2f
l2i
ladd
laload
land
lastore
lcmp
lconst_<l>
ldc
ldc_w
ldc2_w
ldiv
lload
lload_<n>
lmul
lneg
lookupswitch
lor
lrem
lreturn
lshl
lshr
lstore
lstore_<n>
lsub
lushr
lxor
monitorenter
monitorexit
multianewarray
new
newarray
nop
pop
pop2
putfield
putstatic
ret
return
saload
sastore
sipush
swap
tableswitch
wide
7 Opcode Mnemonics by Opcode
Index
A Limited License Grant
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机规范
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>直達Java虛擬機器
第1章 走近 Java
1.1 概述
1.2 Java 技術體系
1.3 Java 發展史
1.4 展望 Java 技術的未來
1.4.1 模組化
1.4.2 混合語言
1.4.3 多核心平行
1.4.4 進一步豐富語法
1.4.5 64 位元虛擬機器
1.5  實戰 ：自己編譯 JDK
1.5.1 獲取 JDK 原始碼
1.5.2 系統需求
1.5.3 構建編譯環境
1.5.4 準備依賴項
1.5.5 進行編譯
1.6  本章小結
第2章 Java 記憶體區域與記憶體溢出異常
2.1 概述
2.2 執行時資料區域
2.2.1 程式計數器
2.2.2 Java 虛擬機器堆疊
2.2.3 本地方法堆疊
2.2.4 Java堆
2.2.5 方法區
2.2.6 執行時常數池
2.2.7 直接記憶體
2.3 對象訪問
2.4  實戰：OutOfMemoryError異常
2.4.1 Java 堆溢出
2.4.2 虛擬機器堆疊和本地方法堆疊溢出 .
2.4.3 執行時常數池溢出
2.4.4 方法區溢出
2.4.5 本機直接記憶體溢出
2.5  本章小結
第3章垃圾收集器與記憶體分配策略
3.1  概述
3.2  物件已死？
3.2.1 參考計數演算法
3.2.2 根搜尋演算法
3.2.3 再談參考
3.2.4 生存還是死亡？
3.2.5 回收方法區
3.3  垃圾收集演算法
3.3.1 標記 — 清除演算法
3.3.2 複製演算法
3.3.3 標記 — 整理演算法
3.3.4 分代收集演算法
3.4  垃圾收集器
3.4.1 Serial 收集器
3.4.2 ParNew 收集器
3.4.3 Parallel Scavenge 收集器
3.4.4 Serial Old 收集器
3.4.5 Parallel Old 收集器
3.4.6 CMS 收集器
3.4.7 G1 收集器
3.4.8 垃圾收集器參數總結
3.5 記憶體分配與回收策略
3.5.1 對象優先在 Eden 分配
3.5.2 大物件直接進入老年代
3.5.3 長期存活的物件將進入老年代
3.5.4 動態物件年齡判定
3.5.5 空間分配擔保
3.6  本章小結
第4章 虛擬機器性能監控與故障處理工具
4.1  概述
4.2 JDK 的命令列工具
4.2.1 jps ：虛擬機器進程狀況工具
4.2.2 jstat ：虛擬機器統計資訊監視工具
4.2.3 jinfo ：Java 設定資訊工具
4.2.4 jmap ：Java 記憶體對應工具
4.2.5 jhat ：虛擬機器堆轉儲存快照分析工具
4.2.6 jstack ：Java 堆疊跟蹤工具
4.3  JDK 的視覺化工具
4.3.1 JConsole ：Java 監視與管理主控台
4.3.2 VisualVM ：多合一故障處理工具
4.4  本章小結
第5章 調教優化案例分析與實戰
5.1 概述
5.2 案例分析
5.2.1 高性能硬體上的程式部署策略
5.2.2 叢集間同步導致的記憶體溢出
5.2.3 堆外記憶體導致的溢出錯誤
5.2.4 外部命令導致系統緩慢
5.2.5 伺服器JVM進程崩潰
5.3 實戰：Eclipse執行速度調教優化
5.3.1 調教優化前的程式執行狀態
5.3.2 升級JDK 1.6的性能變化及相容問題
5.3.3 編譯時間和類別載入時間的優化
5.3.4 調整記憶體設置控制垃圾收集頻率
5.3.5 選擇收集器降低延遲
5.4 本章小結
第6章 類別檔結構
6.1 概述
6.2 無關性的基石
6.3 Class類別檔的結構
6.3.1魔數與Class檔的版本
6.3.2 常數池
6.3.3 訪問標誌
6.3.4 類別索引、父類別索引與介面索引集合
6.3.5 欄位表集合
6.3.6 方法表集合
6.3.7 屬性工作表集合
6.4 Class檔結構的發展
6.5 本章小結
第7章 虛擬機器類別載入機制
7.1 概述
7.2 類別載入的時機
7.3 類別載入的過程
7.3.1 載入
7.3.2 驗證
7.3.3 準備
7.3.4 解析
7.3.5 初始化
7.4 類別載入器
7.4.1 類別與類別載入器
7.4.2 雙親委派模型
7.4.3 破壞雙親委派模型
7.5 本章小結
第8章虛擬機器位元組編碼執行引擎
8.1 概述
8.2 執行時堆疊結構結構
8.2.1 區域變數表
8.2.2 運算元堆疊
8.2.3 動態連接
8.2.4 方法返回位址
8.2.5 附加資訊
8.3 方法呼叫
8.3.1 解析
8.3.2 分派
8.4 基於堆疊的位元組編碼解譯執行引擎
8.4.1 解譯執行
8.4.2 基於堆疊的指令集與基於暫存器的指令集
8.4.3 基於堆疊的解譯器執行過程
8.5 本章小結
第9章 類別載入及執行子系統的案例與實戰
9.1 概述
9.2 案例分析
9.2.1 Tomcat：正統的類別載入器架構
9.2.2 OSGi：靈活的類別載入器架構
9.2.3 位元組編碼產生技術與動態代理的實現
9.2.4 Retrotranslator：跨越JDK版本
9.3 實戰：自己動手實現遠端執行功能
9.3.1 目標
9.3.2 思路
9.3.3 實現
9.3.4 驗證
9.4 本章小結
第10章 早期（編譯期）優化
10.1 概述
10.2 Javac編譯器.
10.2.1 Javac的原始碼與偵錯
10.2.2 解析與填充符號表
10.2.3 注解處理器
10.2.4 語義分析與位元組編碼產生
10.3 Java 語法糖的味道
10.3.1 泛用型與類型刪除
10.3.2 自動打包、拆箱與遍歷迴圈
10.3.3 條件編譯
10.4 實戰：插入式注解處理器
10.4.1 實戰目標
10.4.2 程式碼實現
10.4.3 執行與測試
10.4.4 其他應用案例
10.5 本章小結.
第11章 晚期（執行期）優化
11.1 概述
11.2 HotSpot虛擬機器內的即時編譯器
11.2.1 解譯器與編譯器
11.2.2 編譯物件與觸發條件
11.2.3 編譯過程 .
11.2.4 查看與分析即時編譯結果
11.3 編譯優化技術
11.3.1 優化技術概覽
11.3.2 公共子運算式消除
11.3.3 陣列邊界檢查消除
11.3.4 方法內聯
11.3.5 逃逸分析
11.4 Java與C/C++的編譯器對比
11.5 本章小結
第12章 Java記憶體模型與執行緒
12.1 概述
12.2 硬體的效率與一致性
12.3 Java記憶體模型
12.3.1 主記憶體與工作記憶體
12.3.2 記憶體間互動操作
12.3.3 對於volatile型變數的特殊規則.
12.3.4 對於long和double型變數的特殊規則
12.3.5 原子性、可見性與有序性
12.3.6 先行發生原則
12.4 Java與執行緒
12.4.1 執行緒的實現
12.4.2 Java執行緒調度
12.4.3 狀態轉換
12.5 本章小結
第13章 執行緒安全與鎖優化
13.1 概述
13.2 執行緒安全
13.2.1 Java語言中的執行緒安全
13.2.2 執行緒安全的實現方法
13.3 鎖優化
13.3.1 自旋鎖與自我調整自旋
13.3.2 鎖消除
13.3.3 鎖粗化
13.3.4 輕量化鎖
13.3.5 偏向鎖
13.4 本章小結
附錄A Java虛擬機器家族
A.1 商用高性能虛擬機器
A.2 其他影響較大的虛擬機器
A.3 嵌入式虛擬機器
A.4 其他虛擬機器實現
附錄B 虛擬機器位元組編碼指令表
附錄C HotSpot虛擬機器主要參數表
C.1 記憶體管理參數
C.2 即時編譯參數
C.3 類型載入參數
C.4 多執行緒相關參數
C.5 性能參數
C.6 偵錯參數
附錄D 物件查詢語言（OQL）簡介
D.1 SELECT子句
D.1.1 選擇特定的顯示列
D.1.2 使用列別名
D.1.3 合併成為一個物件清單選擇專案
D.1.4 排除重複物件
D.2 FROM子句
D.2.1 FROM子句指定需要查詢的類別
D.2.2 包含子類別
D.2.3 禁止查詢類別實例
D.3 WHERE子句
D.3.1 >=、<=、>、<、[NOT] LIKE、[NOT] IN（關係操作）
D.3.2 =、!=（等於操作）
D.3.3 AND（條件與操作）
D.3.4 OR（條件或操作）
D.3.5 文字運算式
D.4 屬性訪問器
D.4.1 訪問堆轉儲快照中對象的欄位
D.4.2 訪問Java Bean屬性
D.4.3 呼叫OQL Java方法
D.4.4 OQL 的內建函數
D.5 OQL 語言的 BNF 範式
附錄E JDK 歷史版本軌
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>直達Java虛擬機器
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>虚拟机配置与应用完全手册(附光盘)
第一章 VMware Workstation for Windows应用基础
第二章 VMware中多种操作系统的安装实战――初学者提高的必经之路
第三章 在虚拟机中模拟网络环境――网络组建者与管理员的成长之路
第四章 在虚拟机中进行无盘工作站和终端网络的组建与配置实验――无盘和终端爱好者的福音
第五章 虚拟机中群集的实现――高级网络管理员修炼场
第六章 Virtual PC的应用基础
第七章 Virtual PC的高级应用――高手修炼场
第八章 VMware GSX Server应用指南
第九章 虚拟机的特殊应用
附录A  在只有一个分区的计算机上安装多个操作系统
附录B  不同虚拟机的性能测试
附录C  有关虚拟机相关软件的下载站点
附录D  VMware Workstation 4.0使用说明
后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>虚拟机配置与应用完全手册(附光盘)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>虚拟机排困解难DIY
第一章 虚拟机的用途
第二章 CONNECTIX VIRTUAL PC篇
第三章 VMWARE WORKSTATION篇
第四章 游戏模拟器篇
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>虚拟机排困解难DIY
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>RHCSARHCE Red Hat Linux认证模拟考试解析与虚拟机(Exams EX200 &amp; EX300)
第1章  准备Red Hat实际操作认证考试	1
1.1  RHCSA和RHCE考试	3
1.1.1  考试经验	3
1.1.2  RHCSA考试	4
1.1.3  RHCE考试	4
1.1.4  不断演进的要求	5
1.2  基本硬件要求	5
1.2.1  硬件兼容性	5
1.2.2  内存要求	6
1.2.3  硬盘驱动器选项	6
1.3  获取Red Hat企业版Linux	7
1.3.1  点发行版并不重要	7
1.3.2  可选方案	7
1.3.3  购买RHEL 6订阅版	8
1.3.4  获取评估版副本	8
1.3.5  让RHEL 6运转起来	8
1.3.6  第三方重新构建版	9
1.4  安装要求	10
1.4.1  Red Hat和虚拟机	11
1.4.2  虚拟和物理系统	11
1.5  安装选项	12
1.5.1  引导媒介	12
1.5.2  开始安装RHEL 6	12
1.5.3  基本安装步骤	13
1.5.4  默认的安全设置	20
1.6  从DVD安装虚拟机	23
1.6.1  实验所需的预安装环境	27
1.6.2  系统角色	27
1.7  配置物理机承载虚拟客户机	28
1.8  默认配置的FTP服务器	29
1.9  默认配置的HTTP服务器	29
1.10  认证小结	30
1.11  自测题	31
1.12  实验题	32
1.13  自测题答案	33
1.14  实验题答案	35
第2章  虚拟机和自动安装	37
2.1  启动和停止虚拟机	38
2.1.1  从命令行启动和停止VM	38
2.1.2  从GUI启动和停止VM	38
2.2  配置系统在开机时启动虚拟机	39
2.3  访问虚拟机控制台	40
2.4  使用SSH访问远程系统	40
2.5  将Red Hat企业版Linux系统安装为虚拟客户机	41
2.6  使用Kickstart自动安装Red Hat企业版Linux	42
2.7  认证小结	43
2.8  自测题	43
2.9  实验题	44
2.10  自测题答案	44
2.11  实验题答案	45
第3章  基础命令行技能	49
3.1  访问shell提示符并使用正确的语法给出命令	50
3.2  使用输入/输出重定向	50
3.3  创建、删除、复制及移动文件和目录	51
3.4  创建硬链接和软链接	51
3.5  使用grep和正则表达式分析文本	52
3.6  定位、阅读和使用系统文档	53
3.7  创建和编辑文本文件	53
3.8  启动、停止及检查网络服务状态	54
3.9  配置网络和主机名解析	54
3.10  认证小结	55
3.11  自测题	56
3.12  实验题	57
3.13  自测题答案	57
3.14  实验题答案	58
第4章  RHCSA级的安全选项	63
4.1  列出、设置及修改标准的ugo/rwx权限	64
4.2  诊断并修改文件权限问题	64
4.3  创建和管理访问控制列表(ACL)	65
4.4  使用system-config-firewall或者iptables配置防火墙设置	66
4.5  为SELinux设置强制模式和宽容模式	66
4.6  列出并识别SELinux文件和进程的上下文	67
4.7  恢复默认文件上下文	68
4.8  使用布尔值设置修改系统SELinux设置	68
4.9  判断和处理违反常规SELinux策略的行为	69
4.10  认证小结	70
4.11  自测题	71
4.12  实验题	72
4.13  自测题答案	72
4.14  实验题答案	73
第?5章  引导过程	79
5.1  正常地启动、重启和关闭系统	80
5.2  手动将系统引导到不同的运行级别	81
5.3  使用单用户模式获取对系统的访问	82
5.4  配置系统自动引导到特定的运行级别	82
5.5  配置网络服务在开机时自动启动	83
5.6  修改系统bootloader	84
5.7  认证小结	84
5.8  自测题	85
5.9  实验题	86
5.10  自测题答案	86
5.11  实验题答案	87
第6章  Linux文件系统管理	91
6.1  非破坏性地为系统添加新分区、逻辑卷和交换分区	92
6.2  列出、创建、删除主分区、扩展分区和逻辑分区，以及设置分区类型	93
6.3  创建和删除物理卷、将物理卷分配到卷组、创建和删除逻辑卷	93
6.4  扩展已有的未加密ext4格式的逻辑卷	94
6.5  创建、挂载和使用ext2、ext3、ext4文件系统	95
6.6  挂载和取消挂载CIFS和NFS网络文件系统	95
6.7  配置系统在开机时通过通用唯一ID(UUID)或标签来挂载文件系统	96
6.8  创建和配置LUKS加密的分区和逻辑卷，在开机时提示输入密码并挂载
加密文件系统	97
6.9  挂载、取消挂载和使用LUKS加密的文件系统	98
6.10  配置系统自动挂载ext4、LUKS加密和网络文件系统	98
6.11  认证小结	99
6.12  自测题	100
6.13  实验题	101
6.14  自测题答案	102
6.15  实验题答案	103
第7章  包管理	107
7.1  从Red Hat Network、远程代码库或者本地文件系统安装和更新软件包	108
7.2  在保证系统可启动的前提下妥善更新内核包	109
7.3  认证小结	109
7.4  自测题	109
7.5  实验题	110
7.6  自测题答案	111
7.7  实验题答案	111
第8章  用户管理	113
8.1  在多用户运行级别登录和切换用户	114
8.2  创建、删除、修改本地用户账号	114
8.3  为本地用户账号修改密码及调整密码时效	115
8.4  创建、删除、修改本地组和组成员	116
8.5  创建和配置用于协作的set-GID目录	116
8.6  配置系统使用已有的LDAP目录服务提供关于用户和组的信息	117
8.7  认证小结	118
8.8  自测题	118
8.9  实验题	119
8.10  自测题答案	119
8.11  实验题答案	120
第9章  RHCSA级的系统管理任务	125
9.1  使用VNC访问远程系统	126
9.2  使用tar、star、gzip、bzip2归档、压缩、拆包以及解压文件	126
9.3  识别CPU/内存密集进程、使用renice调整进程优先级、kill进程	127
9.4  使用cron调度任务	127
9.5  定位和解析系统日志文件	128
9.6  认证小结	129
9.7  自测题	130
9.8  实验题	131
9.9  自测题答案	131
9.10  实验题答案	132
第10章  安全入门	135
10.1  使用iptables实现包过滤并配置网络地址转换(NAT)	136
10.2  为服务配置基于主机和基于用户的安全	137
10.3  认证小结	138
10.4  自测题	138
10.5  实验题	140
10.6  自测题答案	140
10.7  实验题答案	141
第11章  系统服务和SELinux	145
11.1  安装提供服务所需的软件包	146
11.2  配置服务在系统引导时启动	147
11.3  配置SELinux以支持服务	147
11.4  配置基于密钥的身份验证	148
11.5  配置文档中描述的附加选项	149
11.6  认证小结	150
11.7  自测题	150
11.8  实验题	151
11.9  自测题答案	152
11.10  实验题答案	153
第12章  RHCE管理任务	157
12.1  使用shell脚本自动完成系统维护任务	158
12.2  使用/proc/sys和sysctl修改内核运行时参数	159
12.3  创建仅包含一个单独文件的简单RPM	160
12.4  配置系统成为始终挂载某个iSCSI目标的iSCSI启动器	162
12.5  配置系统使用Kerberos认证	163
12.6  路由IP流量并创建静态路由	163
12.7  认证小结	165
12.8  自测题	165
12.9  实验题	166
12.10  自测题答案	166
12.11  实验题答案	167
第13章  电子邮件服务器	171
13.1  安装提供服务所需的软件包	172
13.2  配置SELinux以支持服务	173
13.3  配置服务在系统引导时启动	173
13.4  配置服务完成基本操作	173
13.5  为服务配置基于主机和基于用户的安全	174
13.6  配置邮件传输代理(MTA)接收从其他系统发来的入站邮件	175
13.7  配置MTA通过智能主机转发邮件	176
13.8  认证小结	176
13.9  自测题	177
13.10  实验题	178
13.11  自测题答案	178
13.12  实验题答案	179
第14章  Apache Web服务器	183
14.1  安装提供服务所需的软件包	184
14.2  配置SELinux以支持服务	185
14.3  配置服务在系统引导时启动	187
14.4  配置服务完成基本操作	187
14.5  为服务配置基于主机和基于用户的安全	187
14.6  配置虚拟主机	188
14.7  配置私有目录	189
14.8  部署基本的CGI应用	190
14.9  配置组管理内容	191
14.10  认证小结	191
14.11  自测题	192
14.12  实验题	193
14.13  自测题答案	193
14.14  实验题答案	194
第15章  Samba文件服务器	201
15.1  安装提供服务所需的软件包	202
15.2  配置SELinux以支持服务	202
15.3  配置服务在系统引导时启动	203
15.4  配置服务完成基本操作	204
15.5  为服务配置基于主机和基于用户的安全	205
15.6  为特定的客户端提供网络共享	206
15.7  提供适用于组协作的网络共享	206
15.8  认证小结	207
15.9  自测题	207
15.10  实验题	209
15.11  自测题答案	209
15.12  实验题答案	210
第16章  更多文件共享服务	213
16.1  安装提供服务所需的软件包	214
16.2  配置SELinux以支持服务	214
16.3  配置服务在系统引导时启动	215
16.4  配置服务完成基本操作	215
16.5  为服务配置基于主机和基于用户的安全	216
16.6  为FTP服务器配置仅匿名下载	217
16.7  为特定的客户端提供NFS网络共享	217
16.8  提供适用于组协作的NFS网络共享	218
16.9  认证小结	218
16.10  自测题	219
16.11  实验题	220
16.12  自测题答案	220
16.13  实验题答案	221
第17章  管理服务：DNS、NTP和日志	225
17.1  产生和传送系统使用情况报告(处理器、内存、磁盘和网络)	226
17.2  配置系统将日志记录到远程系统	227
17.3  配置系统接收来自远程系统的日志	227
17.4  安装提供服务所需的软件包	228
17.5  配置SELinux以支持服务	229
17.6  配置服务在系统引导时启动	229
17.7  配置服务完成基本操作	229
17.8  为服务配置基于主机和基于用户的安全	230
17.9  配置仅缓存名称服务器	230
17.10  配置仅缓存名称服务器转发DNS请求	231
17.11  使用其他NTP对端同步时间	232
17.12  认证小结	233
17.13  自测题	233
17.14  实验题	235
17.15  自测题答案	235
17.16  实验题答案	236
附录??A  为模拟考试准备一个系统	241
附录??B  RHCSA：模拟考试1	245
附录??C  RHCSA：模拟考试2	249
附录??D  RHCE：模拟考试1	253
附录??E  RHCE：模拟考试2	257
附录??F  关于DVD	261

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>RHCSARHCE Red Hat Linux认证模拟考试解析与虚拟机(Exams EX200 &amp; EX300)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>玩通VMware
【作者序】
【推薦序】
【快速索引】
【Chapter 1 基礎篇－虛擬機常見十大問題】
【Chapter 2 搞定篇－馴服那最不安份的虛擬機靈魂】
【Chapter 3 出發篇－讓虛擬機應用更貼近你的生活】
【Chapter 4 網路篇－揭發神秘的虛擬機網路設定】
【Chapter 5 進化篇－徹底玩弄VM 中的作業系統】
【Chapter 6 硬碟篇－操弄VMware的VMDK及WVP的VHD硬碟】
【Chapter 7 還原篇－搭乘虛擬機回到過去拯救你的電腦系統】
【Chapter 8 轉換篇－實體機轉換到虛擬機平台上】
【Chapter 9 系統篇－在VMware Workstation 上安裝各種作業系統】
【Chapter 10 從高手昇華成達人的養成班】
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>玩通VMware
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入解析Android虚拟机
第1章　获取并编译Android源码　1
1.1　获取Android源码　1
1.1.1　在Linux系统获取Android
源码　1
1.1.2　在Windows平台获取Android
源码　2
1.1.3　Windows获取Android L源码　4
1.2　分析Android源码结构　6
1.3　编译Android源码　8
1.3.1　搭建编译环境　8
1.3.2　开始编译　9
1.3.3　在模拟器中运行　10
1.3.4　常见的错误分析　10
1.3.5　实践演练—演示两种编译Android程序的方法　11
1.4　编译Android Kernel　14
1.4.1　获取Goldfish内核代码　14
1.4.2　获取MSM内核代码　17
1.4.3　获取OMAP内核代码　17
1.4.4　编译Android的Linux内核　17
第2章　Java虚拟机基础　19
2.1　虚拟机的作用　19
2.2　Java虚拟机概述　20
2.2.1　JVM的数据类型　20
2.2.2　Java虚拟机体系结构　21
2.2.3　JVM的生命周期　25
2.3　JVM的安全性　26
2.3.1　JVM的安全模型　26
2.3.2　沙箱模型的4种组件　27
2.3.3　分析Java的策略机制　28
2.4　网络移动性　29
2.4.1　现实需要网络移动性　29
2.4.2　网络移动性　30
2.5　内存异常和垃圾处理　31
2.5.1　内存分配中的栈和堆　31
2.5.2　运行时的数据区域　33
2.5.3　对象访问　34
2.5.4　内存泄露　35
2.5.5　JVM的垃圾收集策略　36
2.5.6　垃圾收集器　37
2.6　Java内存模型　37
2.6.1　Java内存模型概述　38
2.6.2　主内存与工作内存　38
2.6.3　内存间交互操作　39
第3章　Dalvik和ART基础　40
3.1　Dalvik VM和JVM的差异　40
3.2　Dalvik虚拟机的主要特征　41
3.3　Dalvik VM架构　42
3.3.1　Dalvik虚拟机的代码结构　42
3.3.2　dx工具　44
3.3.3　Dalvik VM的进程管理　44
3.3.4　Android的初始化流程　44
3.4　Dalvik VM控制VM命令详解　45
3.4.1　基本命令　45
3.4.2　扩展的JNI检测　45
3.4.3　断言　46
3.4.4　字节码校验和优化　46
3.4.5　Dalvik VM的运行模式　47
3.4.6　死锁预测　47
3.4.7　dump堆栈追踪　48
3.4.8　dex文件和校验　48
3.4.9　产生标志位　48
3.5　ART机制基础　48
3.5.1　什么是ART模式　48
3.5.2　ART优化机制基础　50
第4章　分析JNI　52
4.1　JNI的本质　52
4.2　分析Java层　54
4.2.1　加载JNI库　54
4.2.2　实现扫描工作　55
4.2.3　读取并保存信息　56
4.2.4　删除SD卡外的信息　58
4.2.5　直接转向JNI　58
4.2.6　扫描函数scanFile　59
4.2.7　JNI中的异常处理　59
4.3　分析JNI层　60
4.3.1　将Native对象的指针保存到
Java对象　60
4.3.2　创建Native层的MediaScanner
对象　60
4.4　Native（本地）层　61
4.4.1　注册JNI函数　61
4.4.2　完成注册工作　63
4.4.3　动态注册　64
4.4.4　处理路径参数　65
4.4.5　扫描文件　66
4.4.6　添加TAG信息　66
4.4.7　总结函数JNI_OnLoad()与函数JNI_OnUnload()的用途　67
4.4.8　Java与JNI基本数据类型
转换　67
4.4.9　JNIEnv接口　69
4.4.10　JNI中的环境变量　70
第5章　分析内存系统　71
5.1　分析Android的进程通信机制　71
5.1.1　Android的进程间通信（IPC）
机制Binder　71
5.1.2　Service Manager是Binder
机制的上下文管理者　72
5.1.3　Service Manager服务　86
5.2　匿名共享内存子系统详解　89
5.2.1　基础数据结构　89
5.2.2　初始化处理　90
5.2.3　打开匿名共享内存设备文件　91
5.2.4　内存映射　93
5.2.5　读写操作　94
5.2.6　锁定和解锁　95
5.2.7　回收内存块　100
5.3　C++访问接口层详解　101
5.3.1　接口MemoryBase　101
5.3.2　接口MemoryBase　108
5.4　Java访问接口层详解　111
第6章　Android程序的生命周期管理　115
6.1　Android程序的生命周期　115
6.1.1　进程和线程　115
6.1.2　进程的类型　116
6.2　Activity的生命周期　116
6.2.1　Activity的几种状态　117
6.2.2　分解剖析Activity　117
6.2.3　几个典型的场景　119
6.2.4　管理Activity的生命周期　119
6.2.5　Activity的实例化与启动　120
6.2.6　Activity的暂停与继续　120
6.2.7　Activity的关闭/销毁与
重新运行　121
6.2.8　Activity的启动模式　121
6.3　进程与线程　122
6.3.1　进程　122
6.3.2　线程　123
6.3.3　线程安全的方法　123
6.3.4　Android的线程模型　123
6.4　测试生命周期　125
6.5　Service的生命周期　129
6.5.1　Service的基本概念和用途　129
6.5.2　Service的生命周期详解　129
6.5.3　Service与Activity通信　129
6.6　Android广播的生命周期　133
6.6.1　Android 的广播机制　133
6.6.2　编写广播程序　133
6.7　ART进程管理　135
第7章　IPC进程通信机制　147
7.1　Binder机制概述　147
7.2　Service Manager是Binder机制的
上下文管理者　148
7.2.1　入口函数　148
7.2.2　打开Binder设备文件　149
7.2.3　创建设备文件　149
7.2.4　管理内存映射地址空间　154
7.2.5　发生通知　156
7.2.6　循环等待　161
7.3　内存映射　162
7.3.1　实现内存分配功能　162
7.3.2　分配物理内存　164
7.3.3　释放物理页面　166
7.3.4　分配内核缓冲区　167
7.3.5　释放内核缓冲区　168
7.3.6　查询内核缓冲区　170
第8章　init进程详解　171
8.1　init基础　171
8.2　分析入口函数　172
8.3　配置文件详解　174
8.3.1　init.rc简介　174
8.3.2　分析init.rc的过程　176
8.4　解析service　179
8.4.1　Zygote对应的service action　179
8.4.2　init组织service　180
8.4.3　函数parse_service和parse_line_service　181
8.5　字段on　184
8.5.1　Zygote对应的on action　184
8.5.2　init组织on　185
8.5.3　解析on用到的函数　186
8.6　在init控制service　186
8.6.1　启动Zygote　186
8.6.2　启动service　187
8.6.3　4种启动service的方式　191
8.7　控制属性服务　194
8.7.1　引入属性　194
8.7.2　初始化属性服务　197
8.7.3　启动属性服务　197
8.7.4　处理设置属性的请求　200
第9章　Dalvik VM的进程系统　202
9.1　Zygote（孕育）进程详解　202
9.1.1　Zygote基础　202
9.1.2　分析Zygote的启动过程　203
9.2　System进程详解　216
9.2.1　启动System进程前的准备
工作　216
9.2.2　分析SystemServer　217
9.2.3　分析EntropyService　220
9.2.4　分析DropBoxManagerService　222
9.2.5　分析DiskStatsService　227
9.2.6　分析DeviceStorageManager Service　231
9.2.7　分析SamplingProfilerService　233
9.2.8　分析ClipboardService　241
9.3　应用程序进程详解　247
9.3.1　创建应用程序　247
9.3.2　启动线程池　256
9.3.3　创建信息循环　257
第10章　Dalvik VM运作流程详解　259
10.1　Dalvik VM相关的可执行程序　259
10.1.1　dalvikvm、dvz和app_process
简介　259
10.1.2　对比app_process和dalvikvm的
执行过程　260
10.2　初始化Dalvik虚拟机　262
10.2.1　开始虚拟机的准备工作　262
10.2.2　初始化跟踪显示系统　262
10.2.3　初始化垃圾回收器　263
10.2.4　初始化线程列表和主线程
环境参数　263
10.2.5　分配内部操作方法的表格
内存　264
10.2.6　初始化虚拟机的指令码相关
的内容　264
10.2.7　分配指令寄存器状态的
内存　264
10.2.8　分配指令寄存器状态的内存
和最基本用的Java库　265
10.2.9　初始化使用的Java类库
线程类　266
10.2.10　初始化虚拟机使用的异常
Java类库　267
10.2.11　初始化其他对象　268
10.3　启动Zygote　276
10.3.1　在init.rc中配置Zygote启动
参数　276
10.3.2　启动Socket服务端口　276
10.3.3　加载preload-classes　277
10.3.4　加载preload-resources　277
10.3.5　使用folk启动新进程　278
10.4　启动SystemServer进程　278
10.4.1　启动各种系统服务线程　279
10.4.2　启动第一个Activity　280
10.5　加载class类文件　281
10.5.1　DexFile在内存中的映射　281
10.5.2　ClassObject—Class在
加载后的表现形式　283
10.5.3　加载Class并生成相应
ClassObject的函数　283
10.5.4　加载基本类库文件　284
10.5.5　加载用户类文件　284
第11章　DEX文件详解　285
11.1　DEX文件介绍　285
11.2　DEX文件的格式　285
11.2.1　map_list　286
11.2.2　string_id_item　288
11.2.3　type_id_item　291
11.2.4　proto_id_item　292
11.2.5　ield_id_item　293
11.2.6　method_id_item　293
11.2.7　class_def_item　294
11.3　DEX文件结构　297
11.3.1　文件头（File Header）　297
11.3.2　魔数字段　298
11.3.3　检验码字段　298
11.3.4　SHA-1签名字段　300
11.3.5　map_off字段　300
11.3.6　string_ids_size和off字段　301
11.4　DEXFile接口详解　303
11.4.1　构造函数　303
11.4.2　公共方法　304
11.5　DEX和动态加载类机制　306
11.5.1　类加载机制　306
11.5.2　具体加载　306
11.5.3　代码加密　308
11.6　动态加载jar和DEX　309
第12章　Dvlik VM内存系统详解　310
12.1　如何分配内存　310
12.2　内存管理机制详解　312
12.3　优化Dalvik虚拟机的堆内存分配　326
第13章　Dalvik VM垃圾收集机制　328
13.1　引用计数算法　328
13.2　Mark Sweep算法　328
13.3　和垃圾收集算法有关的函数　330
13.4　垃圾回收的时机　346
13.5　调试信息　347
13.6　Dalvik VM和JVM垃圾收集机制的
区别　348
第14章　Dalvik VM内存优化机制详解　350
14.1　sp和wp简介　350
14.1.1　sp基础　350
14.1.2　wp基础　351
14.2　智能指针详解　351
14.2.1　智能指针基础　352
14.2.2　轻量级指针　353
14.2.3　强指针　355
14.2.4　弱指针　365
第15章　分析Dalvik VM的启动过程　369
15.1　Dalvik VM启动流程概览　369
15.2　Dalvik VM启动过程详解　370
15.2.1　创建Dalvik VM实例　370
15.2.2　指定一系列控制选项　371
15.2.3　创建并初始化Dalvik VM
实例　376
15.2.4　创建JNIEnvExt对象　378
15.2.5　设置当前进程和进程组ID　382
15.2.6　注册Android核心类的JNI
方法　382
15.2.7　创建javaCreateThreadEtc
钩子　385
第16章　注册Dalvik VM并创建线程　387
16.1　注册Dalvik VM的JNI方法　387
16.1.1　设置加载程序　387
16.1.2　加载so文件并验证　387
16.1.3　获取描述类　392
16.1.4　注册JNI方法　392
16.1.5　实现JNI操作　394
16.2　创建Dalvik VM进程　395
16.2.1　分析底层启动过程　395
16.2.2　创建Dalvik VM进程　395
16.2.3　初始化运行的Dalvik VM　398
16.3　创建Dalvik VM线程　399
16.3.1　检查状态值　399
16.3.2　创建线程　399
16.3.3　分析启动过程　402
16.3.4　清理线程　404
第17章　Dalvik VM异常处理详解　407
17.1　Java异常处理机制　407
17.1.1　方法调用栈　407
17.1.2　Java提供的异常处理类　409
17.2　Java VM异常处理机制详解　409
17.2.1　Java语言及虚拟机的异常
处理机制　410
17.2.2　COSIX虚拟机异常处理的
设计与实现　410
17.3　分析Dalvik虚拟机异常处理的
源码　414
17.3.1　初始化虚拟机使用的异常
Java类库　414
17.3.2　抛出一个线程异常　415
17.3.3　持续抛出进程　415
17.3.4　找出异常原因　416
17.3.5　找出异常原因　417
17.3.6　清除挂起的异常和等待
初始化的异常　420
17.3.7　包装“现在等待”异常的
不同例外　420
17.3.8　输出跟踪当前异常的错误
信息　421
17.3.9　搜索和当前异常相匹配的
方法　421
17.3.10　获取匹配的捕获块　423
17.3.11　进行堆栈跟踪　424
17.3.12　生成堆栈跟踪元素　425
17.3.13　将内容添加到堆栈跟踪
日志中　426
17.3.14　将内容添加到堆栈跟踪
日志中　427
17.4　常见异常的类型与原因　428
17.4.1　SQLException：操作数据库
异常类　428
17.4.2　ClassCastException：数据
类型转换异常　428
17.4.3　NumberFormatException：
字符串转换为数字类型时
抛出的异常　428
17.5　调用堆栈跟踪分析异常　429
17.5.1　解决段错误　429
17.5.2　跟踪Android Callback调用
堆栈　431
第18章　JIT编译　434
18.1　JIT简介　434
18.1.1　JIT概述　434
18.1.2　Java虚拟机主要的优化
技术　436
18.1.3　Dalvik中JIT的实现　436
18.2　Dalvik VM对JIT的支持　436
18.3　汇编代码和改动　438
18.3.1　汇编部分代码　438
18.3.2　对C文件的改动　438
18.4　Dalvik VM中的JIT源码　439
18.4.1　入口文件　439
18.4.2　核心函数　447
18.4.3　编译文件　450
18.4.4　BasicBlock处理　458
18.4.5　内存初始化　459
18.4.6　对JIT源码的总结　462
第19章　Dalvik VM内存优化　463
19.1　Android内存优化的作用　463
19.2　查看Android内存和CPU使用情况　464
19.2.1　利用Android API函数查看　464
19.2.2　直接对Android文件进行
解析查询　464
19.2.3　通过Runtime类实现　465
19.2.4　使用DDMS工具获取　465
19.2.5　其他方法　469
19.3　Android的内存泄露　472
19.3.1　什么是内存泄漏　472
19.3.2　为什么会发生内存泄露　473
19.3.3　shallow size、retained size　474
19.3.4　查看Android内存泄露的
工具——MAT　475
19.3.5　查看Android内存泄露的
方法　478
19.3.6　Android（Java）中常见的容易
引起内存泄漏的不良代码　480
19.4　常见的引起内存泄露的坏习惯　480
19.4.1　查询数据库时忘记
关闭游标　481
19.4.2　构造Adapter时不习惯使用
缓存的convertView　481
19.4.3　没有及时释放对象的引用　482
19.4.4　不在使用Bitmap对象时调用
recycle()释放内存　482
19.5　解决内存泄露实践　483
19.5.1　使用MAT根据heap dump分析Java代码内存泄漏的根源　483
19.5.2　演练Android中内存泄露
代码优化及检测　489
第20章　Dalvik VM性能优化　491
20.1　加载APK/DEX文件优化　491
20.1.1　APK文件介绍　492
20.1.2　DEX文件优化　493
20.1.3　使用类动态加载技术实现
加密优化　493
20.2　SD卡优化　496
20.3　虚拟机优化详解　497
20.3.1　平台优化—ARM的流水线
技术　497
20.3.2　Android对C库优化　501
20.3.3　优化创建的进程　504
20.3.4　渲染优化　504
第21章　分析ART的启动过程　508
21.1　运行环境的转换　508
21.2　运行 app_process 进程　509
21.3　准备启动　512
21.4　创建运行实例　518
21.5　注册本地JNI函数　519
21.6　启动守护进程　520
21.7　解析参数　521
21.8　初始化类、方法和域　528
第22章　执行ART主程序　534
22.1　进入main主函数　534
22.2　查找目标类　535
22.2.1　函数LookupClass()　535
22.2.2　函数DefineClass()　537
22.2.3　函数InsertClass()　540
22.2.4　函数LinkClass()　541
22.3　类操作　543
22.4　实现托管操作　544
第23章　安装APK应用程序　549
23.1　PackageManagerService概述　549
23.2　主函数main　549
23.3　调用初始化函数　550
23.4　创建PackageManagerService服务　553
23.5　扫描并解析　554
23.6　保存解析信息　570
第24章　ART环境安装APK应用程序　572
24.1　Android安装APK概述　572
24.2　启动时安装　572
24.3　ART安装　581
24.4　实现dex2oat转换　586
24.4.1　参数解析　586
24.4.2　创建 OAT文件指针　588
24.4.3　dex2oat准备工作　588
24.4.4　提取classes.dex文件　589
24.4.5　创建OAT文件　594
24.5　APK文件的转换　595
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入解析Android虚拟机
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机基础教程
第1章　Java虚拟机	1
1.1　JVM实现	1
1.2　为何要在JVM上开发	2
1.2.1　JVM适应市场的变化	2
1.2.2　Java类库	3
1.2.3　生态系统	3
1.3　常见的用途	5
1.3.1　Web应用程序	5
1.3.2　大数据	5
1.3.3　IoT	6
1.4　JVM概念	6
1.4.1　虚拟机	6
1.4.2　JIT编译器	7
1.4.3　基本数据类型	7
1.4.4　类	8
1.4.5　引用类型	8
1.4.6　垃圾收集器	9
1.4.7　向后兼容	11
1.4.8　构建工具	11
1.5　Java版本	12
1.5.1　Java SE	12
1.5.2　Java EE	13
1.5.3　Java ME	13
1.6　其他JVM语言	14
1.6.1　为何选择其他语言	14
1.6.2　在同一个项目中使用多种JVM语言	15
1.6.3　使用另一种语言编写单元测试	17
1.7　小结	17
第2章　Java虚拟机开发	18
2.1　JDK	18
2.1.1　安装JDK	19
2.1.2　探索JDK	23
2.1.3　JRE	27
2.2　使用包组织类	28
2.2.1　包是什么	28
2.2.2　选择包名	29
2.2.3　包名举例	30
2.2.4　全限定类名	30
2.3　Java类库	30
2.3.1　Java类库的组织结构	31
2.3.2　包概述	31
2.3.3　java.lang包中的重要类	32
2.3.4	集合API——java.util.ArrayList和java.util.HashMap	35
2.4　从命令行运行JVM应用程序	40
2.4.1　至少有一个类包含静态方法main()	41
2.4.2　存储类文件的目录结构	41
2.4.3　为JVM实例设置ClassPath	42
2.4.4　将类文件放在JAR归档文件中	43
2.4.5　使用命令java运行程序	44
2.4.6　在JVM中运行的示例项目	46
2.5　Eclipse IDE	49
2.5.1　下载Eclipse IDE	50
2.5.2　安装Eclipse IDE	51
2.6　小结	52

第3章　Java	53
3.1　Java 中的面向对象编程功能	53
3.1.1　定义类	54
3.1.2　类访问限定符	54
3.1.3　类限定符final——锁定类	54
3.1.4　定义包	55
3.1.5　导入类	55
3.1.6　添加类成员——变量和方法	56
3.1.7　限定符	57
3.1.8　构造函数和终结方法	62
3.1.9　向上转换和向下转换	69
3.2　编写Java代码	70
3.2.1　运算符	70
3.2.2　条件检查	71
3.2.3　POJO	73
3.2.4　数组	74
3.2.5　泛型和集合	75
3.2.6　循环	77
3.2.7　异常	79
3.2.8　线程	81
3.2.9　lambda	83
3.3　编程风格指南	84
3.4　小测验	85
3.5　小结	86
第4章　Java编程	87
4.1　配置Eclipse IDE	87
4.2　使用Java创建Web服务	88
4.2.1　在Eclipse IDE中新建Gradle项目	89
4.2.2　修改Gradle构建文件	90
4.2.3　构建项目	91
4.2.4　编写后端类	92
4.3　小结	103
第5章　Scala	104
5.1　安装Scala	104
5.2　Scala的REPL shell	106
5.3　函数式编程和命令式编程	106
5.4　Scala语法和规则	108
5.4.1　静态类型语言	108
5.4.2　可修改的变量和不可修改的变量	108
5.4.3　常用的Scala类型	109
5.5　Scala的OOP功能	110
5.5.1　定义包和子包	111
5.5.2　导入成员	112
5.5.3　定义类	112
5.5.4　实例变量和实例方法	113
5.5.5　构造函数	114
5.5.6　扩展类	115
5.5.7　重载方法	116
5.5.8　抽象类	116
5.5.9　特质	117
5.5.10　单例对象	118
5.5.11　运算符重载	118
5.5.12		Case类	119
5.6　Scala标准库	120
5.6.1　泛型	120
5.6.2　集合	121
5.6.3　XML处理	123
5.7　Scala的函数式编程功能	124
5.7.1　使用函数遍历集合	125
5.7.2　映射?过滤?归约设计模式	125
5.7.3　柯里化	126
5.8　小测验	127
5.9　小结	128
第6章　Scala编程	129
6.1　Scala IDE for Eclipse插件	129
6.1.1　安装Scala IDE for Eclipse	129
6.1.2　切换到Scala IDE透视图	131
6.2　SBT	131
6.2.1　安装SBT	132
6.2.2　创建基于SBT的Eclipse IDE项目	132
6.2.3　Scala编译器（scalac）	135
6.3　创建Akka项目	136
6.3.1　在SBT构建文件中添加Akka依赖项	137
6.3.2　更新Scala IDE项目	138
6.3.3　Akka概念	138
6.3.4　创建第一个Akka Actor——QuotesHandlerActor	140
6.3.5　创建消息	142
6.3.6　编写基于ScalaTest的单元测试	144
6.3.7　实现消息处理程序	146
6.3.8　创建QuotePrinterActor	147
6.3.9　主应用程序	149
6.4　小结	151
第7章　Clojure	152
7.1　安装Clojure	152
7.2　Clojure的交互式shell（REPL）	154
7.3　Clojure语言	155
7.3.1　语法	155
7.3.2　表达式	156
7.3.3　定义变量	157
7.3.4　定义函数	157
7.3.5　数据结构	158
7.4　使用Java类	167
7.5　使用代理管理状态	169
7.6　风格指南	172
7.7　小测验	173
7.8　小结	174
第8章　Clojure编程	175
8.1　Eclipse IDE插件Counterclockwise	175
8.1.1　安装插件Counterclockwise	176
8.1.2　切换到Java透视图	177
8.2　构建工具Leiningen	177
8.3　创建可执行的Clojure程序	179
8.3.1　在不使用Leiningen的情况下将代码编译成类文件	179
8.3.2　使用Leiningen编译项目	180
8.4　新建Counterclockwise项目	181
8.4.1　Eclipse IDE中的Clojure REPL	183
8.4.2　更新项目的Clojure版本	183
8.4.3　添加依赖	184
8.5　以测试驱动开发的方式探索monad	185
8.6　Web框架Luminus	189
8.6.1　创建Luminus项目	190
8.6.2　将项目导入Counterclockwise	191
8.6.3　探索Luminus项目	191
8.6.4　在Web应用程序中添加页面	192
8.7　小结	194
第9章　Kotlin	196
9.1　安装Kotlin	196
9.2　Kotlin的REPL交互式shell	198
9.3　Kotlin语言基础	200
9.3.1　定义局部变量	200
9.3.2　定义函数	201
9.3.3　Kotlin类型	202
9.3.4　循环	207
9.4　Kotlin的OOP功能	208
9.4.1　定义包	208
9.4.2　导入成员	208
9.4.3　定义类和构造函数	209
9.4.4　给类添加成员	210
9.4.5　继承	212
9.4.6　接口	213
9.4.7　可见性限定符	214
9.4.8　单例对象和伴生对象	214
9.4.9　数据类	216
9.4.10　lambda和内联函数	217
9.5　Kotlin过程性编程	218
9.6　风格指南	219
9.7　小测验	220
9.8　小结	220
第10章　Kotlin编程	222
10.1　Eclipse IDE Kotlin插件	222
10.1.1　安装Eclipse IDE Kotlin插件	222
10.1.2　切换到Kotlin透视图	223
10.2　Apache Maven	224
10.2.1　安装Apache Maven	224
10.2.2　下载预制的Kotlin基本套件	225
10.2.3　在Eclipse IDE中导入项目	226
10.2.4　探索构建文件pom.xml	227
10.2.5　在Eclipse中更新构建文件	228
10.3　创建JavaFX桌面GUI应用程序	229
10.3.1　定制项目	230
10.3.2　创建可运行的应用程序	230
10.3.3　编写扩展函数	233
10.3.4　布局窗格	235
10.3.5　实现基于BorderPane的布局	236
10.3.6　实现动画	238
10.3.7　调试程序	241
10.4　小结	243
第11章　Groovy	244
11.1　安装Groovy	244
11.2　Groovy语言	247
11.3　Groovy开发包（GDK）	255
11.3.1　Groovy字符串（GString）	256
11.3.2　集合	257
11.4　动态和静态编程	260
11.4.1　元编程	261
11.4.2　Groovy静态编程	262
11.5　小测验	264
11.6　小结	265
第12章　Groovy编程	266
12.1　安装Groovy Eclipse插件	266
12.2　Apache Ivy和IvyDE	268
12.3　创建并配置项目	269
12.3.1　新建Groovy Eclipse项目	269
12.3.2　创建供Ivy使用的ivy.xml文件	270
12.4　Java Database Connectivity（JDBC）	272
12.4.1　H2数据库	274
12.4.2　创建内存数据库	274
12.5　使用MarkupBuilder生成XML	278
12.6　微服务平台Vert.x	281
12.6.1　在文件ivy.xml中添加Vert.x依赖	282
12.6.2　创建Web服务	283
12.7　小结	286
附录A　其他JVM语言	287
附录B　小测验答案	296
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机基础教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实战Java虚拟机：JVM故障诊断与性能优化（第2版）
第1章　初探Java虚拟机	1
1.1  知根知底：追溯Java的发展历程	2
1.1.1  那些依托Java虚拟机的语言大咖们	2
1.1.2  Java发展史上的里程碑	2
1.2  跨平台的真相：Java虚拟机做中介	4
1.2.1  理解Java虚拟机的原理	4
1.2.2  看清Java虚拟机的种类	5
1.3  一切看我的：Java语言规范	6
1.3.1  词法的定义	6
1.3.2  语法的定义	7
1.3.3  数据类型的定义	8
1.3.4  Java语言规范总结	9
1.4  一切听我的：Java虚拟机规范	9
1.5  数字编码就是计算机世界的水和电	10
1.5.1  整数在Java虚拟机中的表示	10
1.5.2  浮点数在Java虚拟机中的表示	12
1.6  抛砖引玉：编译和调试虚拟机	14
1.7  小结	18
第2章　认识Java虚拟机的基本结构	19
2.1  谋全局者才能成大器：看穿Java虚拟机的架构	19
2.2  小参数能解决大问题：学会设置Java虚拟机的参数	21
2.3  对象去哪儿：辨清Java堆	22
2.4  函数如何调用：出入Java栈	24
2.4.1  局部变量表	26
2.4.2  操作数栈	31
2.4.3  帧数据区	31
2.4.4  栈上分配	32
2.5  类去哪儿了：识别方法区	34
2.6  小结	36
第3章　常用Java虚拟机参数	37
3.1  一切运行都有迹可循：掌握跟踪调试参数	37
3.1.1  跟踪垃圾回收—读懂虚拟机日志	38
3.1.2  类加载/卸载的跟踪	42
3.1.3  查看系统参数	45
3.2  让性能飞起来：学习堆的配置参数	45
3.2.1  最大堆和初始堆的设置	46
3.2.2  新生代的配置	49
3.2.3  堆溢出处理	53
3.3  别让性能有缺口：了解非堆内存的参数配置	54
3.3.1  方法区配置	55
3.3.2  栈配置	55
3.3.3  直接内存配置	55
3.4  Client和Server二选一：虚拟机的工作模式	58
3.5  小结	59
第4章　垃圾回收的概念与算法	60
4.1  内存管理清洁工：认识垃圾回收	60
4.2  清洁工具大PK：讨论常用的垃圾回收算法	61
4.2.1  引用计数法（Reference Counting）	62
4.2.2  标记清除法（Mark-Sweep）	63
4.2.3  复制算法（Copying）	64
4.2.4  标记压缩法（Mark-Compact）	66
4.2.5  分代算法（Generational Collecting）	67
4.2.6  分区算法（Region）	68
4.3  谁才是真正的垃圾：判断可触及性	69
4.3.1  对象的复活	69
4.3.2  引用和可触及性的强度	71
4.3.3  软引用—可被回收的引用	72
4.3.4  弱引用—发现即回收	76
4.3.5  虚引用—对象回收跟踪	77
4.4  垃圾回收时的停顿现象：Stop-The-World案例实战	79
4.5  小结	83
第5章　垃圾收集器和内存分配	84
5.1  一心一意一件事：串行回收器	85
5.1.1  新生代串行回收器	85
5.1.2  老年代串行回收器	86
5.2  人多力量大：并行回收器	86
5.2.1  新生代ParNew回收器	87
5.2.2  新生代ParallelGC回收器	88
5.2.3  老年代ParallelOldGC回收器	89
5.3  一心多用都不落下：CMS回收器（JDK 8及之前的版本）	90
5.3.1  CMS主要工作步骤	90
5.3.2  CMS主要的参数	91
5.3.3  CMS的日志分析	93
5.3.4  有关Class的回收	94
5.4  未来我做主：G1回收器（JDK 9及之后版本的默认回收器）	95
5.4.1  G1的内存划分和主要收集过程	95
5.4.2  G1的新生代GC	96
5.4.3  G1的并发标记周期	97
5.4.4  混合回收	100
5.4.5  必要时的Full GC	102
5.4.6  G1的日志	102
5.4.7  G1相关的参数	106
5.5  回眸：有关对象内存分配和回收的一些细节问题	106
5.5.1  禁用System.gc()	107
5.5.2  System.gc()使用并发回收	107
5.5.3  并行GC前额外触发的新生代GC	109
5.5.4  对象何时进入老年代	109
5.5.5  在TLAB上分配对象	117
5.5.6  finalize()函数对垃圾回收的影响	120
5.6  温故又知新：常用的GC参数	125
5.7  动手才是真英雄：垃圾回收器对Tomcat性能影响的实验	127
5.7.1  配置实验环境	127
5.7.2  配置性能测试工具JMeter	128
5.7.3  配置Web应用服务器Tomcat	131
5.7.4  实战案例1—初试串行回收器	133
5.7.5  实战案例2—扩大堆以提升系统性能	133
5.7.6  实战案例3—调整初始堆大小	134
5.7.7  实战案例4—使用ParrellOldGC回收器	135
5.7.8  实战案例5—使用较小堆提高GC压力	135
5.7.9  实战案例6—测试ParallelOldGC的表现	135
5.7.10  实战案例7—测试ParNew回收器的表现	136
5.7.11  实战案例8—测试JDK 1.8的表现	136
5.7.12  实战案例9—使用高版本虚拟机提升性能	137
5.8  小结	137
第6章　性能监控工具	138
6.1  有我更高效：Linux下的性能监控工具	139
6.1.1  显示系统整体资源使用情况—top命令	139
6.1.2  监控内存和CPU—vmstat命令	140
6.1.3  监控I/O—iostat命令	142
6.1.4  多功能诊断器—pidstat工具	143
6.2  用我更高效：Windows下的性能监控工具	148
6.2.1  任务管理器	148
6.2.2  perfmon性能监控工具	150
6.2.3  Process Explorer进程管理工具	153
6.2.4  pslist命令—Windows下也有命令行工具	155
6.3  外科手术刀：JDK性能监控工具	157
6.3.1  查看Java进程—jps命令	158
6.3.2  查看虚拟机运行时信息—jstat命令	159
6.3.3  查看虚拟机参数—jinfo命令	162
6.3.4  导出堆到文件—jmap命令	163
6.3.5  JDK自带的堆分析工具—jhat命令	165
6.3.6  查看线程堆栈—jstack命令	168
6.3.7  远程主机信息收集—jstatd命令	171
6.3.8  多功能命令行—jcmd命令	173
6.3.9  性能统计工具—hprof	175
6.3.10  扩展jps命令	178
6.4  我是你的眼：图形化虚拟机监控工具JConsole	178
6.4.1  JConsole连接Java程序	179
6.4.2  Java程序概况	180
6.4.3  内存监控	180
6.4.4  线程监控	181
6.4.5  类加载情况	183
6.4.6  虚拟机信息	183
6.5  一目了然：可视化性能监控工具Visual VM	184
6.5.1  Visual VM连接应用程序	185
6.5.2  监控应用程序概况	186
6.5.3  Thread Dump和分析	187
6.5.4  性能分析	188
6.5.5  内存快照分析	190
6.5.6  BTrace介绍	191
6.6  来自JRockit的礼物：虚拟机诊断工具Mission Control	199
6.6.1  MBean服务器	199
6.6.2  飞行记录器（Flight Recorder）	201
6.7  小结	204
第7章　分析Java堆	205
7.1  对症才能下药：找到内存溢出的原因	206
7.1.1  堆溢出	206
7.1.2  直接内存溢出	206
7.1.3  过多线程导致OOM	208
7.1.4  永久区溢出	210
7.1.5  GC效率低下引起的OOM	211
7.2  无处不在的字符串：String在虚拟机中的实现	211
7.2.1  String对象的特点	211
7.2.2  有关String的内存泄漏	213
7.2.3  有关String常量池的位置	216
7.3  虚拟机也有内窥镜：使用MAT分析Java堆	218
7.3.1  初识MAT	218
7.3.2  浅堆和深堆	221
7.3.3  MAT堆分析案例解析	222
7.3.4  支配树（Dominator Tree）	226
7.3.5  Tomcat堆溢出分析	227
7.4  筛选堆对象：MAT对OQL的支持	231
7.4.1  Select子句	231
7.4.2  From子句	233
7.4.3  Where子句	235
7.4.4  内置对象与方法	235
7.5  更精彩的查找：Visual VM对OQL的支持	240
7.5.1  Visual VM的OQL基本语法	240
7.5.2  内置heap对象	241
7.5.3  对象函数	243
7.5.4  集合/统计函数	247
7.5.5  程序化OQL分析Tomcat堆	253
7.6  小结	256
第8章　锁与并发	257
8.1  安全就是锁存在的理由：锁的基本概念和实现	258
8.1.1  理解线程安全	258
8.1.2  对象头和锁	260
8.2  避免残酷的竞争：锁在Java虚拟机中的实现和优化	261
8.2.1  偏向锁	261
8.2.2  轻量级锁	263
8.2.3  锁膨胀	264
8.2.4  自旋锁	265
8.2.5  锁消除	265
8.3  应对残酷的竞争：锁在应用层的优化思路	267
8.3.1  减少锁持有时间	267
8.3.2  减小锁粒度	268
8.3.3  锁分离	270
8.3.4  锁粗化	272
8.4  无招胜有招：无锁	274
8.4.1  理解CAS	274
8.4.2  原子操作	275
8.4.3  新宠儿LongAdder	278
8.5  将随机变为可控：理解Java内存模型	281
8.5.1  原子性	281
8.5.2  有序性	283
8.5.3  可见性	285
8.5.4  Happens-Before原则	287
8.6  小结	287
第9章　Class文件结构	288
9.1  不仅跨平台，还能跨语言：语言无关性	288
9.2  虚拟机的基石：Class文件	290
9.2.1  Class文件的标志—魔数	291
9.2.2  Class文件的版本	293
9.2.3  存放所有常数—常量池	294
9.2.4  Class的访问标记（Access Flag）	301
9.2.5  当前类、父类和接口	302
9.2.6  Class文件的字段	303
9.2.7  Class文件的方法基本结构	305
9.2.8  方法的执行主体—Code属性	307
9.2.9  记录行号—LineNumberTable属性	308
9.2.10  保存局部变量和参数—LocalVariableTable属性	309
9.2.11  加快字节码校验—StackMapTable属性	309
9.2.12  Code属性总结	314
9.2.13  抛出异常—Exceptions属性	315
9.2.14  用实例分析Class的方法结构	316
9.2.15  我来自哪里—SourceFile属性	319
9.2.16  强大的动态调用—BootstrapMethods属性	320
9.2.17  内部类—InnerClasses属性	321
9.2.18  将要废弃的通知—Deprecated属性	322
9.2.19  Class文件总结	323
9.3  操作字节码：走进ASM	323
9.3.1  ASM体系结构	323
9.3.2  ASM之Hello World	325
9.4  小结	326
第10章　Class装载系统	327
10.1  来去都有序：看懂Class文件的装载流程	327
10.1.1  类装载的条件	328
10.1.2  加载类	331
10.1.3  验证类	333
10.1.4  准备	334
10.1.5  解析类	335
10.1.6  初始化	337
10.2  一切Class从这里开始：掌握ClassLoader	341
10.2.1  认识ClassLoader，看懂类加载	342
10.2.2  ClassLoader的分类	342
10.2.3  ClassLoader的双亲委托模式	344
10.2.4  双亲委托模式的弊端	348
10.2.5  双亲委托模式的补充	349
10.2.6  突破双亲模式	351
10.2.7  热替换的实现	354
10.3  小结	358
第11章　字节码执行	359
11.1  代码如何执行：字节码执行案例	360
11.2  执行的基础：Java虚拟机常用指令介绍	370
11.2.1  常量入栈指令	370
11.2.2  局部变量压栈指令	370
11.2.3  出栈装入局部变量表指令	372
11.2.4  通用型操作	373
11.2.5  类型转换指令	374
11.2.6  运算指令	376
11.2.7  对象操作指令	378
11.2.8  比较控制指令	380
11.2.9  函数调用与返回指令	386
11.2.10  同步控制	389
11.2.11  再看Class的方法结构	392
11.3  更上一层楼：再看ASM	393
11.3.1  为类增加安全控制	394
11.3.2  统计函数执行时间	397
11.4  谁说Java太刻板：Java Agent运行时修改类	400
11.4.1  使用-javaagent参数启动Java虚拟机	400
11.4.2  使用Java Agent为函数增加计时功能	403
11.4.3  动态重转换类	404
11.4.4  有关Java Agent的总结	407
11.5  与时俱进：动态方法调用	407
11.5.1  方法句柄使用实例	408
11.5.2  调用点使用实例	411
11.5.3  反射和方法句柄	413
11.5.4  指令invokedynamic使用实例	414
11.6  跑得再快点：静态编译优化	419
11.6.1  编译时计算	419
11.6.2  变量字符串的连接	421
11.6.3  基于常量的条件语句裁剪	422
11.6.4  switch语句的优化	424
11.7  提高虚拟机的执行效率：JIT及其相关参数	425
11.7.1  开启JIT编译	425
11.7.2  JIT编译阈值	426
11.7.3  多级编译器	427
11.7.4  OSR栈上替换	430
11.7.5  方法内联	432
11.7.6  设置代码缓存大小	433
11.8  小结	436
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实战Java虚拟机：JVM故障诊断与性能优化（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>自制编程语言
目　录
第1章 　引子　　001
1.1 为什么要制作编程语言　　002
1.2 自制编程语言并不是很难　　003
1.3 本书的构成与面向读者　　004
1.4 用什么语言来制作　　006
1.5 要制作怎样的语言　　007
1.5.1 要设计怎样的语法　　007
1.5.2 要设计怎样的运行方式　　009
补充知识 　“用户”指的是谁？　　012
补充知识 　解释器并不会进行翻译　　012
1.6 环境搭建　　012
1.6.1 搭建开发环境　　012
补充知识 关于bison与flex的安装　　014
1.6.2 本书涉及的源代码以及编译器　　015
第2章 　试做一个计算器　　017
2.1 yacc/lex是什么　　018
补充知识 　词法分析器与解析器是各自独立的　　019
2.2 试做一个计算器　　020
2.2.1 lex　　021
2.2.2 简单正则表达式讲座　　024
2.2.3 yacc　　026
2.2.4 生成执行文件　　033
2.2.5 理解冲突所代表的含义　　034
2.2.6 错误处理　　040
2.3 不借助工具编写计算器　　041
2.3.1 自制词法分析器　　041
补充知识 　保留字（关键字）　　046
补充知识 避免重复包含　　047
2.3.2 自制语法分析器　　048
补充知识 预读记号的处理　　053
2.4 少许理论知识——LL(1)与LALR(1)　　054
补充知识 Pascal/C 中的语法处理诀窍　　056
2.5 习题：扩展计算器　　056
2.5.1 让计算器支持括号　　056
2.5.2 让计算器支持负数　　058
第3章 　制作无类型语言crowbar　　061
3.1　制作crowbar ver.0.1语言的基础部分　　062
3.1.1 crowbar是什么　　062
3.1.2 程序的结构　　063
3.1.3 数据类型　　064
3.1.4 变量　　064
补充知识 初次赋值兼做变量声明的理由　　066
补充说明 各种语言的全局变量处理　　067
3.1.5 语句与结构控制　　067
补充知识 elif、elsif、elseif的选择　　068
3.1.6 语句与运算符　　069
3.1.7 内置函数　　069
3.1.8 让crowbar支持C 语言调用　　070
3.1.9 从crowbar中调用C 语言（内置函数的编写）　　071
3.2 预先准备　　071
3.2.1 模块与命名规则　　072
3.2.2 内存管理模块MEM　　073
补充知识 valgrind　　075
补充知识 富翁式编程　　075
补充知识 符号表与扣留操作　　076
3.2.3 调试模块DBG　　076
3.3 crowbar ver.0.1的实现　　077
3.3.1 crowbar的解释器——CRB_Interpreter　　077
补充知识 不完全类型　　080
3.3.2 词法分析——crowbar.l　　081
补充知识 静态变量的许可范围　　084
3.3.3 分析树的构建——crowbar.y 与create.c　　085
3.3.4 常量折叠　　089
3.3.5 错误信息　　089
补充知识 关于crowbar中使用的枚举型定义　　091
3.3.6 运行——execute.c　　092
3.3.7 表达式评估——eval.c　　096
3.3.8 值——CRB_Value　　104
3.3.9 原生指针型　　105
3.3.10 变量　　106
3.3.11 字符串与垃圾回收机制——string_pool.c　　108
3.3.12 编译与运行　　110
第4章 　数组和mark-sweep垃圾回收器　　113
4.1 crowbar ver.0.2　　114
4.1.1 crowbar的数组　　114
4.1.2 访问数组元素　　115
4.1.3 数组是一种引用类型　　116
补充知识 　“数组的数组”和多维数组　　116
4.1.4 为数组添加元素　　118
4.1.5 增加( 模拟) 函数调用功能　　118
4.1.6 其他细节　　118
4.2 制作mark-sweep GC　　119
4.2.1 引用数据类型的结构　　119
4.2.2　mark-sweep GC　　121
补充知识 引用和immutable　　123
4.2.3 crowbar栈　　124
4.2.4 其他根　　127
4.2.5 原生函数的形式参数　　128
4.3 实现GC 本身　　129
4.3.1 对象的管理方法　　129
4.3.2 GC 何时启动　　129
4.3.3 sweep阶段　　132
补充知识 GC 现存的问题　　133
补充知识 Coping GC　　134
4.4 其他修改　　136
4.4.1 修改语法　　136
4.4.2 函数的模拟　　137
4.4.3 左值的处理　　139
4.4.4 创建数组和原生函数的书写方法　　142
4.4.5 原生指针类型的修改　　144
第5章 　中文支持和Unicode　　147
5.1 中文支持策略和基础知识　　148
5.1.1 现存问题　　148
5.1.2 宽字符（双字节）串和多字节字符串　　149
补充知识 wchar_t 肯定能表示1 个字符吗？　　150
5.1.3 多字节字符/ 宽字符之间的转换函数群　　150
5.2 Unicode　　153
5.2.1 Unicode的历史　　153
5.2.2 Unicode的编码方式　　154
补充知识 Unicode可以固定（字节）长度吗？　　156
5.3 crowbar book_ver.0.3的实现　　156
5.3.1 要实现到什么程度？　　156
5.3.2 发起转换的时机　　157
5.3.3 关于区域设置　　158
5.3.4 解决0x5C问题　　158
补充知识 失败的 #ifdef　　160
5.3.5 应该是什么样子　　160
补充知识 还可以是别的样子——Code Set Independent　　161
第6章 　制作静态类型的语言Diksam　　163
6.1 制作Diksam Ver 0.1语言的基本部分　　164
6.1.1 Diksam的运行状态　　164
6.1.2 什么是Diksam　　165
6.1.3 程序结构　　165
6.1.4 数据类型　　166
6.1.5 变量　　166
6.1.6 语句和流程控制　　167
6.1.7 表达式　　167
6.1.8 内建函数　　168
6.1.9 其他　　168
6.2 什么是静态的/ 执行字节码的语言　　169
6.2.1 静态类型的语言　　169
6.2.2 什么是字节码　　169
6.2.3 将表达式转换为字节码　　170
6.2.4 将控制结构转换为字节码　　173
6.2.5 函数的实现　　173
6.3 Diksam ver.0.1的实现——编译篇　　175
6.3.1 目录结构　　175
6.3.2 编译的概要　　176
6.3.3 构建分析树（create.c）　　176
6.3.4 修正分析树（fix_tree.c）　　179
6.3.5 Diksam的运行形式——DVM_Executable　　185
6.3.6 常量池　　186
补充知识 YARV 的情况　　187
6.3.7 全局变量　　188
6.3.8 函数　　189
6.3.9 顶层结构的字节码　　189
6.3.10 行号对应表　　190
6.3.11 栈的需要量　　190
6.3.12 生成字节码（generate.c）　　191
6.3.13 生成实际的编码　　193
6.4 Diksam虚拟机　　197
6.4.1 加载/ 链接DVM_Executable到DVM　　200
6.4.2 执行——巨大的switch case　　202
6.4.3 函数调用　　204
第7章 　为Diksam引入数组　　207
7.1 Diksam中数组的设计　　208
7.1.1 声明数组类型的变量　　208
7.1.2 数组常量　　209
补充知识 D 语言的数组　　210
7.2 修改编译器　　210
7.2.1 数组的语法规则　　210
7.2.2 TypeSpecifier结构体　　212
7.3 修改DVM　　213
7.3.1 增加指令　　213
补充知识 创建Java 的数组常量　　215
补充知识 C 语言中数组的初始化　　217
7.3.2 对象　　217
补充知识 ArrayStoreException　　218
7.3.3 增加null　　219
7.3.4 哎! 还缺点什么吧？　　219
第8章 　将类引入Diksam　　221
8.1 分割源文件　　222
8.1.1 包和分割源代码　　222
补充知识 #include、文件名、行号　　225
8.1.2 DVM_ExecutableList　　225
8.1.3 ExecutableEntry　　226
8.1.4 分开编译源代码　　227
8.1.5 加载和再链接　　230
补充知识 动态加载时的编译器　　233
8.2 设计Diksam中的类　　233
8.2.1 超简单的面向对象入门　　233
8.2.2 类的定义和实例创建　　237
8.2.3 继承　　239
8.2.4 关于接口　　241
8.2.5 编译与接口　　242
8.2.6 Diksam怎么会设计成这样？　　243
8.2.7 数组和字符串的方法　　245
8.2.8 检查类的类型　　246
8.2.9 向下转型　　246
8.3 关于类的实现——继承和多态　　247
8.3.1 字段的内存布局　　247
8.3.2 多态——以单继承为前提　　249
8.3.3 多继承——C++　　250
8.3.4 Diksam的多继承　　252
补充知识 无类型语言中的继承　　254
8.3.5 重写的条件　　254
8.4 关于类的实现　　256
8.4.1 语法规则　　256
8.4.2 编译时的数据结构　　258
8.4.3 DVM_Executable中的数据结构　　260
8.4.4 与类有关的指令　　262
补充知识 方法调用、括号和方法指针　　263
8.4.5 方法调用　　264
8.4.6 super　　266
8.4.7 类的链接　　266
8.4.8 实现数组和字符串的方法　　267
8.4.9 类型检查和向下转型　　267
补充知识 对象终结器（finalizer）和析构函数（destructor）　　268
第9章 　应用篇　　271
9.1 为crowbar引入对象和闭包　　272
9.1.1 crowbar的对象　　272
9.1.2 对象实现　　273
9.1.3 闭包　　274
9.1.4 方法　　276
9.1.5 闭包的实现　　278
9.1.6 试着跟踪程序实际执行时的轨迹　　281
9.1.7 闭包的语法规则　　284
9.1.8 普通函数　　284
9.1.9 模拟方法（修改版）　　285
9.1.10 基于原型的面向对象　　286
9.2 异常处理机制　　286
9.2.1 为crowbar引入异常　　286
9.2.2 setjmp()/longjmp()　　289
补充知识 Java 和C# 异常处理的不同　　293
9.2.3 为Diksam引入异常　　295
补充知识 catch 的编写方法　　296
9.2.4 异常的数据结构　　297
9.2.5 异常处理时生成的字节码299
9.2.6 受查异常　　301
补充知识 受查异常的是与非 303
补充知识 异常处理本身的是与非　　304
9.3 构建脚本　　305
9.3.1 基本思路　　306
9.3.2 YY_INPUT　　307
9.3.3 Diksam的构建脚本　　308
9.3.4 三次加载/ 链接　　308
9.4 为crowbar引入鬼车　　309
9.4.1 关于“鬼车”　　309
9.4.2 正则表达式常量　　310
9.4.3 正则表达式的相关函数　　311
9.5 其他　　312
9.5.1 foreach 和迭代器（crowbar）　　312
9.5.2 switch case（Diksam)　　314
9.5.3 enum（Diksam）　　315
9.5.4 delegate（Diksam）　　316
9.5.5 final、const（Diksam）　　319
附录A 　crowbar语言的设计　　322
附录B 　Diksam语言的设计　　336
附录C 　Diksam Virtual Machine 指令集　　359
编程语言实用化指南——写在最后　　369
参考文献　　375
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>自制编程语言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java性能权威指南
推荐序　　xi
前言　　xii
第1章　导论　　1
1.1　概述　　2
1.2　平台版本约定　　2
1.3　全面的性能调优　　4
1.3.1　编写更好的算法　　4
1.3.2　编写更少的代码　　4
1.3.3　老调重弹的过早优化　　5
1.3.4　其他：数据库很可能就是瓶颈　　6
1.3.5　常见的优化　　7
1.4　小结　　8
第2章　性能测试方法　　9
2.1　原则1：测试真实应用　　9
2.1.1　微基准测试　　9
2.1.2　宏基准测试　　13
2.1.3　介基准测试　　15
2.1.4　代码示例　　16
2.2　原则2：理解批处理流逝时间、吞吐量和响应时间　　19
2.2.1　批处理流逝时间　　19
2.2.2　吞吐量测试　　20
2.2.3　响应时间测试　　20
2.3　原则3：用统计方法应对性能的变化　　23
2.4　原则4：尽早频繁测试　　26
2.5　小结　　28
第3章　Java性能调优工具箱　　29
3.1　操作系统的工具和分析　　29
3.1.1　CPU使用率　　29
3.1.2　CPU运行队列　　32
3.1.3　磁盘使用率　　33
3.1.4　网络使用率　　34
3.2　Java监控工具　　35
3.2.1　基本的VM信息　　36
3.2.2　线程信息　　39
3.2.3　类信息　　39
3.2.4　实时GC分析　　39
3.2.5　事后堆转储　　39
3.3　性能分析工具　　39
3.3.1　采样分析器　　40
3.3.2　探查分析器　　41
3.3.3　阻塞方法和线程时间线　　42
3.3.4　本地分析器　　44
3.4　Java任务控制　　45
3.4.1　Java飞行记录器　　46
3.4.2　开启JFR　　52
3.4.3　选择JFR 事件　　54
3.5　小结　　56
第4章　JIT编译器　　58
4.1　JIT编译器：概览　　58
4.2　调优入门：选择编译器类型（Client、Server或二者同用）　　61
4.2.1　优化启动　　62
4.2.2　优化批处理　　63
4.2.3　优化长时间运行的应用　　64
4.3　Java和JIT编译器版本　　64
4.4　编译器中级调优　　67
4.4.1　调优代码缓存　　67
4.4.2　编译阈值　　68
4.4.3　检测编译过程　　70
4.5　高级编译器调优　　73
4.5.1　编译线程　　73
4.5.2　内联　　74
4.5.3　逃逸分析　　75
4.6　逆优化　　76
4.6.1　代码被丢弃　　77
4.6.2　逆优化僵尸代码　　78
4.7　分层编译级别　　79
4.8　小结　　80
第5章　垃圾收集入门　　81
5.1　垃圾收集概述　　81
5.1.1　分代垃圾收集器　　83
5.1.2　GC算法　　84
5.1.3　选择GC算法　　87
5.2　GC调优基础　　92
5.2.1　调整堆的大小　　92
5.2.2　代空间的调整　　95
5.2.3　永久代和元空间的调整　　96
5.2.4　控制并发　　97
5.2.5　自适应调整　　98
5.3　垃圾回收工具　　99
5.4　小结　　102
第6章　垃圾收集算法　　103
6.1　理解Throughput收集器　　103
6.2　理解CMS收集器　　109
6.2.1　针对并发模式失效的调优　　113
6.2.2　CMS收集器的永久代调优　　116
6.2.3　增量式CMS垃圾收集　　117
6.3　理解G1垃圾收集器　　118
6.4　高级调优　　126
6.4.1　晋升及Survivor空间　　126
6.4.2　分配大对象　　129
6.4.3　AggressiveHeap标志　　136
6.4.4　全盘掌控堆空间的大小　　137
6.5　小结　　138
第7章　堆内存最佳实践　　140
7.1　堆分析　　140
7.1.1　堆直方图　　141
7.1.2　堆转储　　142
7.1.3　内存溢出错误　　146
7.2　减少内存使用　　149
7.2.1　减少对象大小　　149
7.2.2　延迟初始化　　152
7.2.3　不可变对象和标准化对象　　156
7.2.4　字符串的保留　　157
7.3　对象生命周期管理　　160
7.3.1　对象重用　　160
7.3.2　弱引用、软引用与其他引用　　165
7.4　小结　　175
第8章　原生内存最佳实践　　176
8.1　内存占用　　176
8.1.1　测量内存占用　　177
8.1.2　内存占用最小化　　178
8.1.3　原生NIO缓冲区　　178
8.1.4　原生内存跟踪　　179
8.2　针对不同操作系统优化JVM　　182
8.2.1　大页　　182
8.2.2　压缩的oop　　185
8.3　小结　　187
第9章　线程与同步的性能　　188
9.1　线程池与ThreadPoolExecutor　　188
9.1.1　设置最大线程数　　189
9.1.2　设置最小线程数　　192
9.1.3　线程池任务大小　　193
9.1.4　设置ThreadPoolExecutor的大小　　193
9.2　ForkJoinPool　　195
9.3　线程同步　　201
9.3.1　同步的代价　　202
9.3.2　避免同步　　205
9.3.3　伪共享　　208
9.4　JVM线程调优　　211
9.4.1　调节线程栈大小　　211
9.4.2　偏向锁　　212
9.4.3　自旋锁　　212
9.4.4　线程优先级　　213
9.5　监控线程与锁　　213
9.5.1　查看线程　　214
9.5.2　查看阻塞线程　　214
9.6　小结　　217
第10章　Java EE 性能调优　　218
10.1　Web容器的基本性能　　218
10.2　线程池　　222
10.3　EJB会话Bean　　223
10.3.1　调优EJB对象池　　223
10.3.2　调优EJB缓存　　225
10.3.3　本地和远程实例　　226
10.4　XML和JSON处理　　227
10.4.1　数据大小　　227
10.4.2　解析和编组概述　　229
10.4.3　选择解析器　　230
10.4.4　XML验证　　235
10.4.5　文档模型　　237
10.4.6　Java对象模型　　240
10.5　对象序列化　　241
10.5.1　transient字段　　241
10.5.2　覆盖默认的序列化　　241
10.5.3　压缩序列化数据　　244
10.5.4　追踪对象复制　　246
10.6　Java EE网络API　　248
10.7　小结　　250
第11章　数据库性能的最佳实践　　251
11.1　JDBC　　251
11.1.1　JDBC驱动程序　　252
11.1.2　预处理语句和语句池　　253
11.1.3　JDBC连接池　　255
11.1.4　事务　　256
11.1.5　结果集的处理　　262
11.2　JPA　　264
11.2.1　事务处理　　264
11.2.2　对JPA的写性能进行优化　　267
11.2.3　对JPA的读性能进行优化　　268
11.2.4　JPA缓存　　271
11.2.5　JPA的只读实体　　276
11.3　小结　　277
第12章　Java SE API技巧　　278
12.1　缓冲式I/O　　278
12.2　类加载　　280
12.3　随机数　　284
12.4　Java原生接口　　285
12.5　异常　　287
12.6　字符串的性能　　290
12.7　日志　　291
12.8　Java集合类API　　292
12.8.1　同步还是非同步　　293
12.8.2　设定集合的大小　　294
12.8.3　集合与内存使用效率　　295
12.9　AggressiveOpts标志　　296
12.9.1　替代实现　　296
12.9.2　其他标志　　297
12.10　Lambda表达式和匿名类　　297
12.11　流和过滤器的性能　　300
12.12　小结　　302
附录A　性能调优标志摘要　　303
作者简介　　312
关于封面　　312
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java性能权威指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>HotSpot实战
第1章　初识HotSpot　1
1.1　JDK概述　2
1.1.1　JCP与JSR　3
1.1.2　JDK的发展历程　4
1.1.3　Java 7的语法变化　7
1.2　动手编译虚拟机　13
1.2.1　源代码下载　13
1.2.2　HotSpot源代码结构　13
1.2.3　搭建编译环境　15
1.2.4　编译目标　16
1.2.5　编译过程　17
1.2.6　编译常见问题　19
1.3　实战：在HotSpot内调试HelloWorld　20
1.3.1　认识GDB　21
1.3.2　准备调试脚本　22
1.4　小结　26
第2章　启动　28
2.1　HotSpot内核　28
2.1.1　如何阅读源代码　28
2.1.2　HotSpot内核框架　36
2.1.3　Prims　37
2.1.4　Services　39
2.1.5　Runtime　43
2.2　启动　46
2.2.1　Launcher　46
2.2.2　虚拟机生命周期　48
2.2.3　入口：main函数　50
2.2.4　主线程　51
2.2.5　InitializeJVM函数　53
2.2.6　JNI_CreateJavaVM函数　55
2.2.7　调用Java主方法　56
2.2.8　JVM退出路径 56
2.3　系统初始化　57
2.3.1　配置OS模块　58
2.3.2　配置系统属性　60
2.3.3　加载系统库　61
2.3.4　启动线程　62
2.3.5　vm_init_globals函数：初始化全局数据结构　65
2.3.6　init_globals函数：初始化全局模块　65
2.4　小结　69
第3章　类与对象　70
3.1　对象表示机制　71
3.1.1　OOP-Klass二分模型　71
3.1.2　Oops模块　71
3.1.3　OOP框架与对象访问机制　73
3.1.4　Klass与instanceKlass　79
3.1.5　实战：用HSDB调试HotSpot　82
3.2　类的状态转换　87
3.2.1　入口：Class文件　87
3.2.2　类的状态　92
3.2.3　加载　96
3.2.4　链接　101
3.2.5　初始化　104
3.2.6　实战：类的“族谱”　107
3.2.7　实战：系统字典　111
3.3　创建对象　113
3.3.1　实例对象的创建流程　114
3.3.2　实战：探测JVM内部对象　116
3.4　小结　119
第4章　运行时数据区　120
4.1　堆　121
4.1.1　Java的自动内存管理　121
4.1.2　堆的管理　122
4.2　线程私有区域　125
4.2.1　PC　125
4.2.2　JVM栈　126
4.3　方法区　126
4.3.1　纽带作用　127
4.3.2　常量池　130
4.3.3　常量池缓存：ConstantPoolCache　133
4.3.4　方法的表示：methodOop　134
4.3.5　方法的解析：将符号引用转换成直接引用　138
4.3.6　代码放在哪里：ConstMethodOop　141
4.3.7　实战：探测运行时常量池　142
4.4　性能监控数据区：Perf Data　147
4.4.1　描述这段空间：PerfMemory　147
4.4.2　查看　148
4.4.3　生产　150
4.5　转储　151
4.5.1　用VisualVM进行转储分析　151
4.5.2　JVM Crash　153
4.6　小结　158
第5章　垃圾收集　159
5.1　堆与GC　160
5.1.1　垃圾收集　160
5.1.2　分代收集　162
5.1.3　快速分配　165
5.1.4　栈上分配和逸出分析　167
5.1.5　GC公共模块　167
5.2　垃圾收集器　170
5.2.1　设计演进　170
5.2.2　CMS收集器　175
5.2.3　G1收集器　180
5.3　实战：性能分析方法　184
5.3.1　获取GC日志　184
5.3.2　GC监控信息　187
5.3.3　内存分析工具　189
5.3.4　选择合适的收集器与GC性能评估　190
5.3.5　不要忽略JVM Crash日志　195
5.4　小结　196
第6章　栈　197
6.1　硬件背景：了解真实机器　198
6.1.1　程序是如何运行的　198
6.1.2　x86与栈帧　199
6.1.3　ARM对Java硬件级加速：Jazelle技术　202
6.2　Java栈　203
6.2.1　寄存器式指令集与栈式指令集　203
6.2.2　HotSpot中的栈　204
6.2.3　栈帧　207
6.2.4　充分利用寄存器资源　210
6.2.5　虚拟机如何调用Java函数　212
6.2.6　优化：栈顶缓存　221
6.2.7　实战：操作数栈　223
6.3　小结　228
第7章　解释器和即时编译器　229
7.1　概述　230
7.2　解释器如何工作　231
7.2.1　Interpreter模块　232
7.2.2　Code模块　234
7.2.3　字节码表　235
7.2.4　Code Cache　236
7.2.5　InterpreterCodelet与Stub队列　239
7.2.6　Code生成器　241
7.2.7　模板表与转发表　244
7.2.8　实战：InterpreterCodelet　247
7.3　即时编译器　250
7.3.1　概述　250
7.3.2　编译器模块　251
7.3.3　编译器的基本结构　252
7.3.4　实战：编译原理实践，了解编译中间环节　255
7.4　小结　267
第8章　指令集　268
8.1　再说栈式指令集　268
8.2　数据传送　270
8.2.1　局部变量、常量池和操作数栈之间的数据传送　270
8.2.2　数据传送指令　272
8.2.3　实战：数组的越界检查　277
8.3　类型转换　279
8.4　对象的创建和操作　281
8.5　程序流程控制　282
8.5.1　控制转移指令　282
8.5.2　条件转移　283
8.5.3　无条件转移　284
8.5.4　复合条件转移　285
8.5.5　实战：switch语句如何使用String　287
8.6　运算　290
8.6.1　加法：iadd　290
8.6.2　取负：ineg　291
8.7　函数的调用和返回　292
8.7.1　Java函数分发机制：VTABLE与ITABLE　293
8.7.2　invoke系列指令　297
8.7.3　动态分发：覆盖　299
8.7.4　静态分发：重载　302
8.8　异常　305
8.8.1　异常表　305
8.8.2　创建异常　306
8.8.3　try-catch　309
8.8.4　finally　311
8.9　小结　312
第9章　虚拟机监控工具　313
9.1　Attach机制　314
9.1.1　AttachProvider与VirtualMachine　314
9.1.2　命令的下发：execute()　317
9.1.3　命令的执行：Attach Listener守护线程　319
9.2　查看JVM进程　320
9.2.1　用jps查看Java进程　320
9.2.2　实战：定制jps，允许查看库路径　323
9.3　查看和配置JVM　326
9.3.1　用jinfo查看JVM参数配置　326
9.3.2　实战：扩展flags选项，允许查看命令行参数　330
9.4　堆内存转储工具　332
9.4.1　Heap Dump　332
9.4.2　原理　333
9.5　堆转储分析　337
9.5.1　Heap Dump分析工具：jhat　337
9.5.2　实战：MAT分析过程　340
9.6　线程转储分析　343
9.6.1　jstack　343
9.6.2　实战：如何分析资源等待　344
9.7　小结　347
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>HotSpot实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>虚拟化与云计算
第1章  数据中心的构建与管理  1.1  数据中心概述  1.2  数据中心的设计和构建    1.2.1  总体设计    1.2.2  建筑的设计与构建    1.2.3  基础设施的设计与构建    1.2.4  数据中心上线  1.3  数据中心的管理和维护    1.3.1  硬件的管理和维护    1.3.2  软件的管理和维护    1.3.3  数据的管理和维护    1.3.4  资源管理    1.3.5  安全管理  1.4  新一代数据中心的需求    1.4.1  合理规划    1.4.2  流程化    1.4.3  可管理性    1.4.4  可伸缩性    1.4.5  可靠性    1.4.6  降低成本    1.4.7  节能环保  1.5  小结第2章  虚拟化概论第3章  虚拟化的关键技术第4章  虚拟化的业界动态第5章  云计算概论第6章  云架构第7章  云计算的关键技术与挑战第8章  云计算的业界动态附录A  超级计算机排名参考资料索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>虚拟化与云计算
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java深度历险
第一章 深入Java2 SDK
第二章 深入类装载器
第三章 Java与Microsoft Office 
第四章 用Visual Studio.net来操纵Java虚拟机
第五章 package与import机制
第六章 Ant
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java深度历险
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Xen虚拟化技术
第1部分 Xen和虚拟化技术
第1章 概述
1.1 虚拟化技术
1.1.1 虚拟化技术的发展历史
1.1.2 虚拟化技术的实现层次及分类
1.1.3 虚拟机与虚拟机监视器
1.1.4 x86的虚拟化技术
1.2 Xen 虚拟机系统
1.2.1 x86架构的虚拟化
1.2.2 Xen的设计理念
1.2.3 Xen的发展历史
1.3 本章小结
第2章 Xen体系结构
2.1 Xen Hypervisor
2.1.1 基本概念
2.1.2 虚拟域（Domain）
2.1.3 控制面板
2.2 CPU虚拟化
2.2.1 半虚拟化
2.2.2 硬件虚拟化
2.3 内存虚拟化
2.4 I/O虚拟化
2.5 本章小结
第2部分 Xen基本机制和策略
第3章 Xen信息页
3.1 启动信息页
3.1.1 启动信息页的数据结构
3.1.2 结构体start-info成员字段说明
3.2 共享信息页
3.2.1 共享信息页的数据结构
3.2.2 结构体shared_info成员字段说明
3.3 本章小结
第4章 超级调用和事件通道
4.1 系统调用
4.1.1 系统调用的过程
4.1.2 系统调用的实现
4.2 超级调用
4.2.1 超级调用的实现方式
4.2.2 超级调用页
4.2.3 申请超级调用
4.3 事件通道
4.3.1 基本概念
4.3.2 事件通道的初始化
4.3.3 事件通道的操作
4.3.4 事件通道的使用
4.4 本章小结
第5章 授权表
5.1 共享内存
5.1.1 Linux中的共享内存
5.1.2 Xen中的共享内存
5.2 授权表
5.2.1 授权项
5.2.2 授权表的操作
5.3 页面映射
5.3.1 页面映射操作
5.3.2 撤销映射操作
5.4 页面传递
5.4.1 页面传递操作
5.4.2 内存拷贝操作
5.5 授权表的使用
5.5.1 授权引用操作
5.5.2 设备驱动gntdev
5.6 本章小结
第3部分 Xen子系统
第6章 CPU虚拟化
6.1 中断和异常的处理
6.1.1 基本知识
6.1.2 物理中断处理
6.1.3 虚拟中断处理
6.1.4 异常处理
6.2 时间和计时器
6.2.1 时间
6.2.2 计时器
6.2.3 时间和计时器操作
6.3 VCPU设置
6.3.1 VCPU数据结构
6.3.2 VCPU初始化
6.3.3 VCPU操作
6.4 VCPU调度
6.4.1 调度器
6.4.2 调度处理
6.5 本章小结
第7章 内存虚拟化
7.1 内存寻址
7.1.1 80386的分段机制
7.1.2 Xen的分段机制
7.1.3 80386的分页机制
7.1.4 Xen的分页机制
7.2 内存分配
7.2.1 Xen的内存分配
7.2.2 Guest OS的物理内存
7.2.3 物理内存管理
7.3 虚拟地址转换
7.3.1 直接模式
7.3.2 页表更新
7.3.3 可写页表
7.4 本章小结
第8章 I/O设备虚拟化
8.1 设备虚拟化的三种模型
8.1.1 仿真设备模型
8.1.2 直接分配设备模型
8.1.3 虚拟设备模型
8.2 虚拟设备模型及其相关机制
8.3 隔离驱动域
8.4 设备I/O环
8.4.1 设备I/O环的基本原理
8.4.2 设备I/O环的实现方式
8.4.3 设备I/O环的实例——块设备的I/O环
8.5 Xenstore和Xenbus
8.5.1 Xenstore简介
8.5.2 Xenstore的实现原理
8.5.3 Xenbus简介
8.5.4 Xenbus的实现原理
8.6 虚拟块设备
8.6.1 虚拟块设备I/O环
8.6.2 虚拟块设备的初始化
8.7 虚拟网络设备
8.7.1 虚拟网络设备简介
8.7.2 虚拟网络设备的实现原理
8.7.3 虚拟网络设备的数据传输流程
8.8 本章小结
第4部分 Xen安全机制
第9章 Xen访问控制模块
9.1 ACM模块总体介绍
9.1.1 ACM模块架构
9.1.2 ACM模块的常用功能
9.1.3 ACM模块的编译
9.2 策略文档的编译与装载
9.2.1 策略文档的格式
9.2.2 策略文档的编译
9.2.3 策略文档的装载
9.3 ACM模块分析
9.3.1 ACM模块的Hooks函数及其接口函数
9.3.2 中国墙策略实现分析
9.3.3 STE策略实现分析
9.4 ACM模块实际操作示例
9.5 本章小结
第10章 可信平台模块虚拟化
10.1 可信计算
10.1.1 可信的定义
10.1.2 可信平台
10.1.3 可信平台模块
10.2 虚拟化可信平台模块（vTPM）
10.2.1 vTPM的设计
10.2.2 vTPM的实现
10.2.3 vTPM的使用
10.3 本章小结
第5部分 Xen展望
第11章 硬件虚拟化
11.1 特权级环
11.2 VMX和VMCS
11.2.1 VMX
11.2.2 VMCS
11.3 HVM中的其他机制
11.4 本章小结
附录 名词解释
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Xen虚拟化技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker开发实践
第一篇　基础篇：Docker基础
第1章　Docker简介　　2
1.1　Docker简介　　2
1.1.1　Docker的概念　　5
1.1.2　Docker的背景　　5
1.1.3　容器与虚拟机　　7
1.1.4　Docker与容器　　8
1.1.5　Docker的应用场景　　9
1.2　Docker的组件　　10
1.3　Docker的相关技术　　11
1.4　Docker的安装　　12
1.4.1　Ubuntu下的安装　　12
1.4.2　Red Hat下的安装　　13
1.4.3　OS X下的安装　　14
1.4.4　Windows下的安装　　15
第2章　容器　　17
2.1　容器的管理操作　　17
2.1.1　创建容器　　17
2.1.2　查看容器　　20
2.1.3　启动容器　　21
2.1.4　终止容器　　22
2.1.5　删除容器　　22
2.2　容器内信息获取和命令执行　　23
2.2.1　依附容器　　23
2.2.2　查看容器日志　　24
2.2.3　查看容器进程　　25
2.2.4　查看容器信息　　25
2.2.5　容器内执行命令　　26
2.3　容器的导入和导出　　26
第3章　镜像　　28
3.1　镜像的概念　　28
3.1.1　镜像与容器　　28
3.1.2　镜像的系统结构　　29
3.1.3 镜像的写时复制机制　　30
3.2　本地镜像的管理　　30
3.2.1 查看　　30
3.2.2　下载　　31
3.2.3　删除　　33
3.3　创建本地镜像　　33
3.3.1　使用commit命令创建本地镜像　　33
3.3.2　使用Dockerfile创建镜像　　34
3.4　Docker Hub　　40
3.4.1　Docker Hub简介　　41
3.4.2　镜像的分发　　41
3.4.3　自动化构建　　43
3.4.4　创建注册服务器　　47
第4章　数据卷及容器连接　　49
4.1　容器网络基础　　49
4.1.1　暴露网络端口　　50
4.1.2　查看网络配置　　53
4.2　数据卷　　54
4.2.1　创建数据卷　　54
4.2.2　挂载主机目录作为数据卷　　55
4.2.3　挂载主机文件作为数据卷　　57
4.2.4　数据卷容器　　57
4.2.5　数据的备份与恢复　　59
4.3　容器连接　　60
4.3.1　容器命名　　60
4.3.2　容器连接　　60
4.3.3　代理连接　　62
第二篇　案例篇：综合案例
第5章　创建SSH服务镜像　　66
5.1　基于commit命令的方式　　66
5.2　基于Dockerfile的方式　　70
第6章　综合案例1：Apache+PHP+MySQL　　72
6.1　构建mysql 镜像　　72
6.1.1　编写镜像Dockerfile　　73
6.1.2　构建和上传镜像　　75
6.2　构建apache+php镜像　　76
6.2.1　编写镜像Dockerfile　　77
6.2.2　构建和上传镜像　　79
6.3　启动容器　　80
第7章　综合案例2：DLNNM　　82
7.1　构建mongodb镜像　　83
7.1.1　编写镜像Dockerfile　　84
7.1.2　构建和上传镜像　　84
7.2　构建Node.js镜像　　86
7.2.1　项目源文件　　86
7.2.2　编写镜像Dockerfile　　88
7.2.3　构建和上传镜像　　89
7.3　连接Node.js服务和MongoDB服务　　89
7.3.1　制作代理镜像mongoabassador　　89
7.3.2　启动MongoDB服务　　91
7.3.3　启动Node-Web-API服务　　92
7.4　搭建前端Nginx　　93
7.4.1　构建镜像并运行　　93
7.4.2　验证Web应用　　95
第8章　阿里云Docker开发实践　　97
8.1　阿里云Docker介绍　　99
8.2　部署镜像注册服务器　　102
8.3　开发　　103
8.3.1　项目开发　　103
8.3.2　制作和上传镜像　　104
8.4　测试　　105
8.5　部署　　105
第9章　在阿里云上部署WordPress　　107
9.1　初始化阿里云Docker环境　　107
9.2　部署MySQL容器　　109
9.3　部署WordPress容器　　109
第10章　使用私有仓库　　112
10.1　使用docker-registry　　112
10.2　用户认证　　115
第11章　使用Docker部署Hadoop集群　　118
11.1　Hadoop简介　　118
11.2　构建Hadoop镜像　　119
11.3　构建Hadoop集群　　122
11.3.1　Ambari简介　　123
11.3.2　部署Hadoop集群　　123
第三篇　高级篇：高级话题、API、工具及集群管理
第12章　容器网络　　128
12.1　容器网络的原理　　128
12.1.1　基础网络工具　　128
12.1.2　网络空间虚拟化　　131
12.1.3　网络设备虚拟化　　132
12.1.4　容器运行的4 种网络模式　　 135
12.1.5　手动配置容器的网络环境　　 137
12.2　配置及原理　　138
12.2.1　基本配置　　138
12.2.2　容器互联配置及原理　　140
12.2.3　容器内访配置及原理　　142
12.2.4　容器外访配置及原理　　143
12.2.5　创建点对点连接　　144
12.3　网桥　　146
12.3.1　配置网桥　　146
12.3.2　构建自己的网桥　　146
第13章　安全　　148
13.1　命名空间　　148
13.2　cgroups　　151
13.3　Linux能力机制　　152
第14章　DockerAPI　　154
14.1　API 概述　　154
14.2　绑定Docker后台监听接口　　155
14.3　远程API　　158
14.3.1　容器相关的API　　158
14.3.2　镜像相关的API　　164
14.4　平台API　　167
14.4.1　注册服务器架构及流程　　167
14.4.2　操作Hub API　　169
14.5　API 实战：docker-py库编程　　173
14.5.1　docker-py开发环境的搭建　　173
14.5.2　docker-py库编程　　174
第15章　Fig　　177
15.1　Fig简介　　177
15.2　Fig安装　　177
15.3　Rails开发环境配置　　178
15.4　Django开发环境配置　　180
15.5　WordPress开发环境配置　　182
15.6　Flocker：跨主机的Fig应用　　184
第16章　Kubernetes　　189
16.1　Kubernetes简介　　189
16.2　核心概念　　190
16.2.1　节点　　190
16.2.2　Pod　　190
16.2.3　服务　　191
16.2.4　标签　　194
16.3　架构和组件　　195
16.3.1　主控节点　　195
16.3.2　从属节点　　198
16.3.3　组件交互流程　　198
16.4　Kubernetes实战　　200
16.4.1　环境部署　　201
16.4.2　应用操作　　207
第17章　shipyard　　214
17.1　简介　　214
17.2　shipyard操作　　217
17.2.1　鉴权　　217
17.2.2　引擎　　217
17.2.3　容器　　220
17.2.4　服务密钥　　222
17.2.5　Web钩子密钥　　223
17.2.6　事件　　223
17.2.7　集群信息　　224
第18章　Machine+Swarm+Compose225
18.1　Machine　　225
18.2　Swarm　　227
18.2.1　架构和组件　　228
18.2.2　实操　　230
18.2.3　发现服务和调度　　233
18.3　Compose　　239
第四篇　附录
附录A　常见镜像　　242
附录B　Docker API列表　　262
附录C　参考资料　　278
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker开发实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算与OpenStack
PartⅠ  概念篇
第1章  云计算概述	2
1.1  云计算是什么	2
1.2  云计算发展现状	4
1.3  云计算体系架构	7
1.3.1  云计算参与者	8
1.3.2  云计算部署方式	11
1.4  云计算的影响	13
1.4.1  云计算引发了整个IT行业变革	13
1.4.2  云计算对经济社会各领域带来深刻影响	14
1.5  云计算商用解决方案	15
1.5.1  亚马逊云计算解决方案	15
1.5.2  VMware vSphere解决方案	19
1.6  云计算开源解决方案OpenStack	21
1.6.1  OpenStack发展历史	22
1.6.2  OpenStack概述	23
第2章  OpenStack安装体验及入门	26
2.1  快速体验安装	26
2.2  脚本安装	28
2.3  手动安装	29
2.4  体验	35
2.4.1  创建虚拟机	36
2.4.2  添加磁盘	38
2.4.3  安全和访问设置	41
2.5  Q&A	43
2.5.1  虚拟机上是否可以安装OpenStack	43
2.5.2  找不到安装源	43
2.5.3  设置上网代理	44
2.6  如何入门提升	44
2.6.1  源码阅读	45
2.6.2  日志分析	48
2.6.3  安装问题	49
PartⅡ  架构篇
第3章  系统架构	52
3.1  整体架构剖析	52
3.2  逻辑架构	57
3.2.1  逻辑概念模型	59
3.2.2  逻辑模块划分	60
3.3  运行架构	63
3.4  开发架构	66
3.5  物理架构	67
第4章  功能剖析	70
4.1  消息队列协议AMQP	70
4.2  调度器nova-scheduler	74
4.2.1  过滤（Filtering）	76
4.2.2  权衡（Weighting）	78
4.3  计算资源管理	80
4.3.1  KVM适配	83
4.3.2  VMware适配	84
4.4  存储资源管理	85
4.4.1  Cinder功能分析	88
4.4.2  iSCSI适配	90
4.4.3  NFS适配	93
4.5  网络资源管理	94
4.5.1  IP资源管理	95
4.5.2  DHCP自动分派IP	95
4.5.3  网络连接管理	98
4.5.4  虚拟交换机管理	99
4.5.5  NAT网络映射	102
4.5.6  网络安全管理	104
4.5.7  Quantum项目介绍	106
Part Ⅲ  实现篇
第5章  计算资源池实现剖析	114
5.1  代码结构分析	114
5.1.1  常用命令	114
5.1.2  代码结构	115
5.2  业务逻辑模型分析	116
5.2.1  整体业务逻辑模型	116
5.2.2  Libvirt虚拟化实现模型	118
5.2.3  Xen API虚拟化实现模型	119
5.3  数据模型分析	120
5.3.1  整体数据模型	120
5.3.2  虚拟机模型instances	121
5.3.3  虚拟机状态	122
5.4  虚拟机开通	123
5.4.1  操作实现	123
5.4.2  实现剖析	126
5.4.3  开通虚拟机外部接口nova-api.create( )	127
5.4.4  开通虚拟机内部接口compute-api.create( )	128
5.4.5  计算节点部署虚拟机 compute-manager.run_instance()	131
5.4.6  虚拟化适配	134
5.5  虚拟机启停	138
5.5.1  虚拟机关闭	138
5.5.2  虚拟机启动	140
5.6  在线热迁移	140
5.6.1  构建NFS共享存储	142
5.6.2  修改计算节点配置	145
5.6.3  迁移虚拟机	146
5.7  VNC控制台	147
5.7.1  VNC和noVNC	147
5.7.2  实现剖析	147
5.7.3  noVNC代理的配置和部署	148
5.8  安全组管理	149
5.8.1  安全组数据模型	150
5.8.2  安全组创建和删除	151
5.9  Q&A	152
5.9.1  虚拟机部署异常	152
5.9.2  计算节点服务不能正常启动	153
5.9.3  热迁移失败	154
参考文献	154
第6章   存储资源池实现剖析	155
6.1  代码结构分析	155
6.1.1  nova-volume代码结构	155
6.1.2  Cinder代码结构	157
6.2  业务逻辑模型分析	158
6.2.1  整体模型分析	158
6.2.2  卷管理类（VolumeManager）	159
6.2.3  iSCSI实现ISCSIDriver	160
6.3  数据库模型分析	160
6.3.1  整体模型分析	160
6.3.2  卷（volumes）	161
6.4  创建和挂载弹性云硬盘操作实现	162
6.4.1  创建云硬盘操作实现	162
6.4.2  挂载云硬盘操作实现	164
6.5  机架式服务器iSCSI存储实现剖析	165
6.5.1  LVM基本概念	165
6.5.2  存储节点预处理	166
6.5.3  创建云硬盘	167
6.5.4  挂载云硬盘	168
6.6  快照管理	169
6.6.1  创建快照	170
6.6.2  快照恢复	171
第7章   网络资源池实现剖析	173
7.1  代码结构分析	173
7.1.1  Nova-network代码	173
7.1.2  Quantum代码	174
7.2  nova-network业务逻辑模型分析	176
7.2.1  业务逻辑模型	176
7.2.2  私网资源池管理NetworkManager	177
7.2.3  公网资源池管理FloatingIP	179
7.3  nova-network数据模型分析	180
7.3.1  整体模型	180
7.3.2  私有网络Networks	181
7.3.3  私网IP地址池	182
7.3.4  弹性IP地址池	183
7.4  nova-network中FlatDHCP模式	184
7.4.1  网络部署	184
7.4.2  网络连接机制剖析	185
7.4.3  高可用性	187
7.5  nova-network中VLAN模式	189
7.5.1  网络部署	189
7.5.2  网络连接机制剖析	190
7.5.3  高可用性	191
7.6  nova-network分配私网IP地址	192
7.6.1  创建私有网络	192
7.6.2  分配私网fixed IP	193
7.6.3  DHCP自动分配IP地址	197
7.7  nova-network分配弹性IP地址	199
7.7.1  操作实现	200
7.7.2  实现剖析	201
7.8  Quantum业务逻辑模型分析	203
7.8.1  Quantum-Server业务逻辑模型	203
7.8.2  Agent业务逻辑模型	204
7.9  Quantum数据模型分析	204
7.9.1  整体数据模型	204
7.9.2  Quantum模型映射关系	206
7.9.3  端口ports	207
7.10  Quantum网络模式分析	208
7.10.1  扁平共享模式（Flat）	208
7.10.2  租户私有网络	209
7.11  Quantum操作实现	211
第8章  Glance镜像管理	212
8.1  镜像功能架构	213
8.1.1  逻辑架构	213
8.1.2  开发架构	213
8.2  业务逻辑模型分析	215
8.3  数据模型分析	215
8.3.1  整体模型	215
8.3.2  镜像（images）	216
8.3.3  镜像状态	217
8.4  制作镜像	218
8.4.1  制作Windows 7镜像	218
8.4.2  制作Linux镜像	222
8.4.3  上传镜像	222
8.5  创建镜像实现分析	224
第9章  Horizon前端界面实现剖析	227
9.1  什么是Django	227
9.2  Horizon的功能和实现	228
9.2.1  Horizon介绍	228
9.2.2  功能架构	229
9.2.3  部署架构	230
9.2.4  开发架构	232
9.2.5  Horizon和Django	233
9.2.6  Horizon和其他模块的关系	234
9.3  定制Horizon	235
9.3.1  修改Web应用的标题	235
9.3.2  修改Horizon的Logo	235
9.3.3  修改Dashboard和Panel	236
9.4  国际化	236
第10章  Keystone认证管理	238
10.1  Keystone架构	238
10.1.1  逻辑架构	238
10.1.2  开发架构	239
10.2  数据模型分析	241
10.2.1  整体模型	241
10.2.2  用户（user）	242
10.2.3  项目Tenant	242
10.2.4  用户项目角色关联表metadata	243
10.2.5  服务service	243
10.2.6  服务端endpoint	243
10.3  Keystone操作体验	244
10.3.1  创建项目Project	244
10.3.2  创建用户	245
10.3.3  为项目Project增加新用户	246
10.4  认证机制剖析	247
10.4.1  curl方式创建虚拟机	247
10.4.2  认证过程剖析	252
10.4.3  认证获取Token剖析	254
10.4.4  权限判断	256
10.5  Q&A	258
Part Ⅳ  应用篇
第11章  私有云平台建设	262
11.1  概述	262
11.2  适用场景分析	263
11.2.1  选择私有云	264
11.2.2  适用场景示例——服务器应用	266
11.2.3  适用场景示例——桌面云应用	270
11.3  建设思路	274
11.3.1  建设思路转变	274
11.3.2  统筹规划、分阶段建设	277
11.4  建设过程	277
11.4.1  网络规划及部署	278
11.4.2  CPU兼容性	282
11.5  案例分析	283
11.6  私有云平台待完善	287
11.6.1  OpenStack持续优化	288
11.6.2  系统监控管理	289
11.6.3  高可用性管理	294
第12章  公有云平台建设	297
12.1  谁适用公有云	297
12.2  运营商建设	298
12.2.1  小规模应用	299
12.2.2  大规模建设	300
12.3  单数据中心建设方案	301
12.3.1  网络部署方案	301
12.3.2  共享存储提升高可用性	303
12.4  多数据中心建设方案	304
12.4.1  区域Zone解决方案	305
12.4.2  单元Cell解决方案	307
后记	309
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算与OpenStack
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>计算机组成及汇编语言原理
出版者的话
译者序
前言
第一部分  假想计算机
第1章 计算和表示 1
1.1 计算 1
1.1.1 电子设备 1
1.1.2 算法机 1
1.1.3 功能部件 2
1.2 数字和数值表示 6
1.2.1 数字表示和位 6
1.2.2 布尔逻辑 8
1.2.3 字节和字 9
1.2.4 表示 10
1.3 虚拟机 19
1.3.1 什么是虚拟机 19
1.3.2 可移植性问题 21
1.3.3 超越限制 21
1.3.4 易于升级 21
1.3.5 安全问题 22
1.3.6 劣势 22
1.4 JVM编程 23
1.4.1 Java：JVM不是什么 23
1.4.2 样例程序的转换 24
1.4.3 高级语言和低级语言 25
1.4.4 JVM所看到的样例程序 26
1.5 本章回顾 28
1.6 习题 28
1.7 编程习题 29
第2章 算术表达式 30
2.1 符号表示 30
2.1.1 指令集 30
2.1.2 操作、操作数及顺序 30
2.1.3 基于堆栈的计算器 31
2.2 存储程序计算机 32
2.2.1 取指－执行周期 32
2.2.2 CISC计算机与RISC计算机 34
2.3 JVM上的算术运算 35
2.3.1 一般评述 35
2.3.2 一个算术指令集示例 36
2.3.3 堆栈操作 39
2.3.4 汇编语言和机器码 40
2.3.5 非法操作 41
2.4 一个样例程序 41
2.4.1 一个有注解的例子 41
2.4.2 最终的JVM代码 43
2.5 JVM计算指令总结 44
2.6 本章回顾 44
2.7 习题 45
2.8 编程习题 45
第3章 用jasmin进行汇编语言编程 46
3.1 Java编程系统 46
3.2 使用汇编器 47
3.2.1 汇编器 47
3.2.2 运行一个程序 47
3.2.3 显示到控制台还是显示到窗口 48
3.2.4 使用System.out和System.in 49
3.3 汇编语言语句类型 51
3.3.1 指令和注释 51
3.3.2 汇编指令 52
3.3.3 资源汇编指令 52
3.4 例子：随机数生成 53
3.4.1 生成伪随机数 53
3.4.2 在JVM上实现 53
3.4.3 另一种实现 55
3.4.4 与Java类交互 56
3.5 本章回顾 57
3.6 习题 57
3.7 编程习题 58
第4章 控制结构 60
4.1 他们教给你的都是错误的 60
4.1.1 再谈取指－执行 60
4.1.2 转移指令和标号 60
4.1.3 结构化编程：转移一下注意力 61
4.1.4 高级控制结构及其等效结构 62
4.2 goto的类型 63
4.2.1 无条件转移 63
4.2.2 条件转移 63
4.2.3 比较操作 64
4.2.4 组合操作 65
4.3 建立控制结构 65
4.3.1 if语句 65
4.3.2 循环 66
4.3.3 转移指令的细节 67
4.4 示例：Syracuse数 68
4.4.1 问题定义 68
4.4.2 设计 69
4.4.3 解答与实现 70
4.5 表跳转 71
4.6 子例程 74
4.6.1 基本指令 74
4.6.2 子例程示例 75
4.7 例子：p的蒙特卡洛估计 78
4.7.1 问题定义 78
4.7.2 设计 79
4.7.3 解答与实现 80
4.8 本章回顾 82
4.9 习题 82
4.10 编程习题 83
第二部分 真实计算机
第5章 通用体系结构问题：实际计算机 85
5.1 虚拟机的限制 85
5.2 CPU优化 85
5.2.1 建造一个更好的捕鼠夹 85
5.2.2 多处理 86
5.2.3 指令集优化 86
5.2.4 流水化 86
5.2.5 超标量体系结构 88
5.3 存储器优化 89
5.3.1 cache存储器 89
5.3.2 存储管理 90
5.3.3 直接地址转换 90
5.3.4 页式地址转换 90
5.4 外设优化 92
5.4.1 忙-等待问题 92
5.4.2 中断处理 92
5.4.3 与外设的通信：利用总线 93
5.5 本章回顾 93
5.6 习题 93
第6章 Intel 8088 93
6.1 背景 95
6.2 组织和体系结构 95
6.2.1 中央处理单元 95
6.2.2 取指-执行周期 97
6.2.3 存储器 97
6.2.4 设备和外设 98
6.3 汇编语言 98
6.3.1 操作和寻址 98
6.3.2 算术指令集 100
6.3.3 浮点运算 101
6.3.4 判定和控制结构 102
6.3.5 高级操作 104
6.4 存储器组织和使用 105
6.4.1 地址和变量 105
6.4.2 字节交换 106
6.4.3 数组和串 106
6.4.4 串原语 108
6.4.5 局部变量和信息隐藏 110
6.4.6 系统栈 110
6.4.7 栈帧 111
6.5 再论锥形山 113
6.6 接口问题 114
6.7 本章回顾 115
6.8 习题 116
第7章 Power体系结构 117
7.1 背景 117
7.2 组织和体系结构 118
7.2.1 中央处理单元 118
7.2.2 存储器 119
7.2.3 设备和外设 119
7.3 汇编语言 120
7.3.1 算术运算 120
7.3.2 浮点操作 121
7.3.3 比较和条件标志 121
7.3.4 数据移动 122
7.3.5 转移 123
7.4 再论锥形山 123
7.5 存储器组织和使用 124
7.6 性能问题 125
7.7 本章回顾 126
7.8 习题 127
第8章 Intel Pentium 128
8.1 背景 128
8.2 组织和体系结构 128
8.2.1 中央处理单元 128
8.2.2 存储器 129
8.2.3 设备和外设 129
8.3 汇编语言 130
8.3.1 操作和寻址 130
8.3.2 高级操作 130
8.3.3 指令格式 131
8.4 存储器组织和使用 131
8.5 性能问题 132
8.5.1 流水化 132
8.5.2 并行操作 133
8.5.3 超标量体系结构 133
8.6 再论RISC与CISC 134
8.7 本章回顾 134
8.8 习题 135
第9章 微控制器：Atmel AVR 136
9.1 背景 136
9.2 组织和体系结构 136
9.2.1 中央处理单元 136
9.2.2 存储器 137
9.2.3 设备和外设 140
9.3 汇编语言 141
9.4 存储器组织和使用 142
9.5 接口问题 143
9.5.1 与外部设备的接口 143
9.5.2 与定时器的接口 144
9.6 设计一个AVR程序 145
9.7 本章回顾 146
9.8 习题 146
第10章 JVM高级编程问题 147
10.1 复杂和派生类型 147
10.1.1 对派生类型的需求 147
10.1.2 派生类型的一个例子：数组 147
10.1.3 记录：没有方法的类 153
10.2 类和继承 154
10.2.1 定义类 154
10.2.2 一个简单的类：String 155
10.2.3 实现String 156
10.3 类的操作和方法 157
10.3.1 类操作介绍 157
10.3.2 域操作 157
10.3.3 方法 159
10.3.4 类的分类 162
10.4 对象 163
10.4.1 作为类的实例创建对象 163
10.4.2 销毁对象 164
10.4.3 类型对象 166
10.5 类文件和.class文件结构 166
10.5.1 类文件 166
10.5.2 启动类 167
10.6 类层次汇编指令 168
10.7 注释示例：再讨论Hello,World 169
10.8 输入和输出：一个解释 170
10.8.1 问题描述 170
10.8.2 两个系统比较 170
10.8.3 示例：在JVM中从键盘读入 173
10.8.4 解答 173
10.9 示例：通过递归求阶乘 174
10.9.1 问题描述 174
10.9.2 设计 174
10.9.3 解答 175
10.10 本章回顾 176
10.11 习题 176
10.12 编程习题 177
附录A 数字逻辑 178
附录B JVM指令集 185
附录C 按序号排列的操作代码 220
附录D 类文件格式 224
附录E ASCII表 228
词汇表 229
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>计算机组成及汇编语言原理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>编译器构造
第1章 概述
1.1 编译的历史
1.2 编译器可以做什么
1.2.1 编译器生成的机器代码
1.2.2 目标代码格式
1.3 解释器
1.4 语法和语义
1.4.1 静态语义
1.4.2 运行时语义
1.5 编译器的组织结构
1.5.1 扫描器
1.5.2 分析器
1.5.3 类型检查器（语义分析）
1.5.4 翻译器（程序综合）
1.5.5 符号表
1.5.6 优化器
1.5.7 代码生成器
1.5.8 编译器开发工具
1.6 程序设计语言和编译器设计
1.7 计算机体系结构和编译器设计
1.8 编译器设计的考虑事项
1.8.1 调试（开发）编译器
1.8.2 优化编译器
1.8.3 可重定向编译器
1.9 集成开发环境
练习
第2章 一个简单的编译器
2.1 ac语言的非形式化定义
2.2 ac语言的形式化定义
2.2.1 语法规范
2.2.2 词法单元规范
2.3 一个简单编译器中的阶段
2.4 扫描
2.5 分析
2.5.1 分析过程的预测
2.5.2 产生式的实现
2.6 抽象语法树
2.7 语义分析
2.7.1 符号表
2.7.2 类型检查
2.8 代码生成
练习
第3章 扫描--理论和实践
3.1 扫描器概述
3.2 正则表达式
3.3 示例
3.4 有限自动机和扫描器
3.4.1 确定性的有限自动机
3.5 扫描器生成工具Lex
3.5.1 定义Lex中的词法单元
3.5.2 字符类
3.5.3 使用正则表达式来定义词法单元
3.5.4 使用Lex进行字符处理
3.6 其他扫描器生成工具
3.7 构造扫描器的实际注意事项
3.7.1 处理标识符和字面常量
3.7.2 使用编译命令和列出源码行
3.7.3 扫描器的终止
3.7.4 向前看多个字符
3.7.5 性能上的考虑
3.7.6 词法错误恢复
3.8 正则表达式和有限自动机
3.8.1 把正则表达式转换为NFA
3.8.2 创建DFA
3.8.3 有限状态机的化简
3.8.4 把有限自动机转换为正则表达式
3.9 本章小结
练习
第4章 文法和分析
4.1 上下文无关文法
4.1.1 最左推导
4.1.2 最右推导
4.1.3 分析树
4.1.4 其他类型的文法
4.2 上下文无关文法的属性
4.2.1 简化的文法
4.2.2 二义性
4.2.3 语言定义中的错误
4.3 扩展文法的转换
4.4 分析器和识别器
4.5 文法分析的算法
4.5.1 文法表示
4.5.2 推导空字符串
4.5.3 First集合
4.5.4 Follow集合
练习
第5章 自顶向下分析
5.1 概述
5.2 LL(k)文法
5.3 递归下降的LL(1)分析器
5.4 表格驱动的LL(1)分析器
5.5 如何获得LL(1)文法
5.5.1 公共前缀
5.5.2 左递归
5.6 非LL(1)的语言
5.7 LL(1)分析器的属性
5.8 分析表的表示方法
5.8.1 精简方法
5.8.2 压缩方法
5.9 语法错误的恢复和修复
5.9.1 错误恢复
5.9.2 错误修复
5.9.3 LL(1)分析器中的错误检查
5.9.4 LL(1)分析器中的错误恢复
练习
第6章 自底向上分析
6.1 概述
6.2 移进-规约分析器
6.2.1 LR分析器和最右推导
6.2.2 把LR分析看做是编织过程（knitting）
6.2.3 LR分析引擎
6.2.4 LR分析表
6.2.5 LR(k)分析
6.3 LR(0)分析表的构造
6.4 冲突诊断
6.4.1 二义性文法
6.4.2 非LR(k)的文法
6.5 冲突解决方法和分析表的构造
6.5.1 SLR(k)分析表的构造
6.5.2 LALR(k)分析表的构造
6.5.3 LALR传播图
6.5.4 LR(k)分析表的构造
本章小结
练习
第7章 语法制导翻译
7.1 概述
7.1.1 语义动作和语义值
7.1.2 综合和继承属性
7.2 自底向上的语法制导翻译
7.2.1 示例
7.2.2 规则克隆
7.2.3 强加语义动作
7.2.4 进一步的文法重组
7.3 自顶向下的语法制导翻译
7.4 抽象语法树
7.4.1 具体和抽象语法树
7.4.2 高效的抽象语法树数据结构
7.4.3 创建抽象语法树的基础结构
7.5 抽象语法树的设计和构造
7.5.1 设计
7.5.2 构造
7.6 左值和右值的抽象语法树结构
7.7 抽象语法树的设计模式
7.7.1 结点的类层次结构
7.7.2 访问者模式
7.7.3 反射的访问者模式
本章小结
练习
第8章 符号表和声明处理
8.1 构造符号表
8.1.1 静态作用域
8.1.2 符号表的接口
8.2 块结构的语言和作用域
8.2.1 处理作用域
8.2.2 使用一个还是多个符号表
8.3 基本的实现技术
8.3.1 添加和查找名称
8.3.2 名字空间
8.3.3 一种高效的符号表实现方法
8.4 高级特性
8.4.1 记录和类型名
8.4.2 重载和类型层次结构
8.4.3 隐式声明
8.4.4 导出和导入命令
8.4.5 查找规则的修改
8.5 声明处理的基础
8.5.1 符号表中的属性
8.5.2 类型描述符的结构
8.5.3 使用抽象语法树进行类型检查
8.6 变量和类型声明
8.6.1 简单变量声明
8.6.2 类型名称的处理
8.6.3 类型声明
8.6.4 复杂的变量声明
8.6.5 静态数组类型
8.6.6 结构和记录类型
8.6.7 枚举类型
8.7 类和方法的声明
8.7.1 类声明的处理
8.7.2 方法声明的处理
8.8 类型检查简介
8.8.1 简单标识符和字面常量
8.8.2 赋值语句
8.8.3 表达式检查
8.8.4 复杂名称的检查
本章小结
练习
第9章 语义分析
9.1 控制结构的语义分析
9.1.1 可达和终止分析
9.1.2 if语句
9.1.3 While、Do和Repeat循环
9.1.4 for循环
9.1.5 break、continue、return和goto语句
9.1.6 switch和case语句
9.1.7 异常处理
9.2 方法调用的语义分析
9.3 本章小结
练习
第10章 中间表示形式
10.1 概述
10.1.1 示例
10.1.2 中端
10.2 Java虚拟机
10.2.1 概述和设计原则
10.2.2 类文件的内容
10.2.3 JVM指令
10.3 静态单赋值形式
10.3.1 重命名和φ-函数
练习
第11章 面向虚拟机的代码生成
11.1 代码生成的Visitor
11.2 类和方法声明
11.2.1 类声明
11.2.2 方法声明
11.3 MethodBodyVisitor
11.3.1 常量
11.3.2 局部存储的引用
11.3.3 静态引用
11.3.4 表达式
11.3.5 赋值
11.3.6 方法调用
11.3.7 域引用
11.3.8 数组引用
11.3.9 条件执行
11.3.10 循环
11.4 LHSVisitor
11.4.1 局部引用
11.4.2 静态引用
11.4.3 域引用
11.4.4 数组引用
练习
第12章 运行时支持
12.1 静态分配
12.2 栈分配
12.2.1 类和struct中的域访问
12.2.2 在运行时访问活动记录
12.2.3 处理类和对象
12.2.4 处理多个作用域
12.2.5 程序块级的分配
12.2.6 关于活动记录的其他内容
12.3 数组
12.3.1 静态的一维数组
12.3.2 多维数组
12.4 堆管理
12.4.1 分配机制
12.4.2 释放机制
12.4.3 自动垃圾回收
12.5 基于区域的内存管理
练习
第13章 目标代码生成
13.1 字节码的翻译
13.1.1 内存地址的分配
13.1.2 数组和对象的分配
13.1.3 方法调用
13.1.4 字节码翻译的例子
13.2 表达式树的翻译
13.3 寄存器分配
13.3.1 On-the-Fly寄存器分配
13.3.2 使用图着色法的寄存器分配
13.3.3 基于优先级的寄存器分配
13.3.4 过程间寄存器分配
13.4 代码调度
13.4.1 代码调度的改进
13.4.2 全局和动态的代码调度
13.5 自动的指令选择
13.5.1 使用BURS进行指令选择
13.5.2 使用Twig进行指令选择
13.5.3 其他方法
13.6 窥孔优化
13.6.1 窥孔优化的层次
13.6.2 窥孔优化的自动生成
练习
第14章 程序优化
14.1 概述
14.1.1 为什么要进行优化
14.2 控制流分析
14.2.1 控制流图
14.2.2 程序和控制流结构
14.2.3 直接过程调用图
14.2.4 深度优先生成树
14.2.5 支配关系
14.2.6 简单的支配算法
14.2.7 快速的支配算法
14.2.8 支配边界
14.2.9 区间
14.3 数据流分析简介
14.3.1 可用表达式
14.3.2 活跃变量
14.4 数据流框架
14.4.1 数据流求值图
14.4.2 交格
14.4.3 转换函数
14.5 求值
14.5.1 迭代
14.5.2 初始化
14.5.3 终止问题和快速框架
14.5.4 分配式框架
14.6 常量传播
14.7 SSA形式
14.7.1 添加? -函数
14.7.2 重命名
练习
参考文献
缩略语
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>编译器构造
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual C++冒险游戏程序设计
Chapter 1 来做冒险游戏吧
Chapter 2 设计一个游戏
Chapter 3 建立类库
Chapter 4 制作游戏系统
Chapter 5 扩充游戏系统
Chapter 6 设计自己的游戏
Chapter 7 制作游戏的技巧
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual C++冒险游戏程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JVM G1源码分析和调优
前言
第1章　垃圾回收概述
1.1　Java发展概述
1.2　本书常见术语
1.3　回收算法概述
1.4　JVM垃圾回收器概述
第2章　G1的基本概念
2.1　分区
2.2　G1停顿预测模型
2.3　卡表和位图
2.4　对象头
2.5　内存分配和管理
2.6　线程
2.7　日志解读
2.8　参数介绍和调优
第3章　G1的对象分配
3.1　对象分配概述
3.2　快速分配
3.3　慢速分配
3.4　G1垃圾回收的时机
3.5　参数介绍和调优
第4章　G1的Refine线程
4.1　记忆集
4.2　Refine线程的功能及原理
4.3　Refinement Zone
4.4　RSet涉及的写屏障
4.5　日志解读
4.6　参数介绍和调优
第5章　新生代回收
5.1　YGC算法概述
5.2　YGC代码分析
5.3　YGC算法演示
5.4　日志解读
5.5　参数介绍和调优
第6章　混合回收
6.1　并发标记算法详解
6.2　并发标记算法的难点
6.3　G1中混合回收的步骤
6.4　混合回收中并发标记处理的线程
6.5　并发标记算法演示
6.6　GC活动图
6.7　日志解读
6.8　参数优化
第7章　Full GC
7.1　Evac失败
7.2　串行FGC
7.3　并行FGC
7.4　日志解读
7.5　参数介绍和调优
第8章　G1中的引用处理
8.1　引用概述
8.2　可回收对象发现
8.3　在GC时的处理发现列表
8.4　重新激活可达的引用
8.5　日志解读
8.6　参数介绍和调优
第9章　G1的新特性：字符串去重
9.1　字符串去重概述
9.2　日志解读
9.3　参数介绍和调优
9.4　字符串去重和String.intern的区别
9.5　String.intern中的实现
第10章　线程中的安全点
10.1　安全点的基本概念
10.2　G1并发线程进入安全点
10.3　解释线程进入安全点
10.4　编译线程进入安全点
10.5　正在执行本地代码的线程进入安全点
10.6　安全点小结
10.7　日志分析
10.8　参数介绍和调优
第11章　垃圾回收器的选择
11.1　如何衡量垃圾回收器
11.2　G1调优的方向
第12章　新一代垃圾回收器
12.1　Shenandoah
12.2　ZGC
附录A　编译调试JVM
附录B　本地内存跟踪
附录C　阅读JVM需要了解的C++知识
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JVM G1源码分析和调优
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>编译原理（第3版）
第1章 引论 1
1.1 什么是编译程序 1
1.2 编译过程和编译程序的结构 2
1.2.1 编译过程概述 2
1.2.2 编译程序的结构 5
1.2.3 编译阶段的组合 6
1.3 解释程序和一些软件工具 7
1.3.1 解释程序 7
1.3.2 处理源程序的软件工具 8
1.4 PL/0语言编译系统 10
1.4.1 PL/0语言编译系统构成 11
1.4.2 PL/0语言 11
1.4.3 类P-code语言 14
1.4.4 PL/0编译程序 15
1.4.5 PL/0语言编译系统的驱动代码 16
练习 18
第2章 文法和语言 19
2.1 文法的直观概念 19
2.2 符号和符号串 20
2.3 文法和语言的形式定义 21
2.4 文法的类型 25
2.5 上下文无关文法及其语法树 26
2.6 句型的分析 29
2.6.1 自上而下的分析方法 30
2.6.2 自下而上的分析方法 30
2.6.3 句型分析的有关问题 31
2.7 有关文法实际应用的一些说明 32
2.7.1 有关文法的实用限制 32
2.7.2 上下文无关文法中的ε规则 33
练习 33
第3章 词法分析 37
3.1 词法分析程序的设计 37
3.1.1 词法分析程序和语法分析程序的接口方式 37
3.1.2 词法分析程序的输出 37
3.1.3 将词法分析工作分离的考虑 38
3.1.4 词法分析程序中如何识别单词 39
3.2 PL/0编译程序中词法分析程序的设计和实现 39
3.3 单词的形式化描述工具 44
3.3.1 正规文法 44
3.3.2 正规式 45
3.3.3 正规文法和正规式的等价性 46
3.4 有穷自动机 47
3.4.1 确定的有穷自动机(DFA) 47
3.4.2 不确定的有穷自动机(NFA) 49
3.4.3 NFA转换为等价的DFA 50
3.4.4 确定有穷自动机的化简 52
3.5 正规式和有穷自动机的等价性 54
3.6 正规文法和有穷自动机的等价性 57
3.7 词法分析程序的自动构造工具 58
3.7.1 lex描述文件中使用的正规表达式 59
3.7.2 lex描述文件的格式 60
3.7.3 lex的使用 63
3.7.4 与yacc的接口约定 63
练习 64
第4章 自顶向下语法分析方法 68
4.1 确定的自顶向下分析思想 68
4.2 LL(1)文法的判别 72
4.3 某些非LL(1)文法到LL(1)文法的等价变换 77
4.3.1 提取左公共因子 77
4.3.2 消除左递归 80
4.4 不确定的自顶向下分析思想 84
4.5 LL(1)分析的实现 86
4.5.1 递归下降LL(1)分析程序 86
4.5.2 表驱动LL(1)分析程序 92
4.6 LL(1)分析中的出错处理 95
4.6.1 应急恢复 95
4.6.2 短语层恢复 96
4.6.3 PL/0语法分析程序的错误处理 98
练习 99
第5章 自底向上优先分析 103
5.1 自底向上优先分析概述 104
5.2 简单优先分析法 104
5.2.1 优先关系定义 105
5.2.2 简单优先文法的定义 106
5.2.3 简单优先分析法的操作步骤 106
5.3 算符优先分析法 107
5.3.1 直观算符优先分析法 107
5.3.2 算符优先文法的定义 108
5.3.3 算符优先关系表的构造 110
5.3.4 算符优先分析算法 115
5.3.5 优先函数 117
5.3.6 算符优先分析法的局限性 121
练习 121
第6章 LR分析 123
6.1 LR分析概述 123
6.2 LR(0)分析 124
6.2.1 可归前缀和子前缀 125
6.2.2 识别活前缀的有限自动机 127
6.2.3 活前缀及可归前缀的一般计算方法 128
6.2.4 LR(0)项目集规范族的构造 130
6.3 SLR(1)分析 137
6.4 LR(1)分析 144
6.4.1 LR(1)项目集族的构造 145
6.4.2 LR(1)分析表的构造 146
6.5 LALR(1)分析 148
6.6 二义性文法在LR分析中的应用 153
练习 156
第7章 语法制导的语义计算 160
7.1 基于属性文法的语义计算 160
7.1.1 属性文法 160
7.1.2 遍历分析树进行语义计算 164
7.1.3 S-属性文法和L-属性文法 166
7.1.4 基于S-属性文法的语义计算 166
7.1.5 基于L-属性文法的语义计算 168
7.2 基于翻译模式的语义计算 172
7.2.1 翻译模式 172
7.2.2 基于S-翻译模式的语义计算 173
7.2.3 基于L-翻译模式的自顶向下语义计算 174
7.2.4 基于L-翻译模式的自底向上语义计算 178
7.3 分析和翻译程序的自动生成工具yacc 183
7.3.1 yacc描述文件 184
7.3.2 使用yacc的一个简单例子 187
练习 189
第8章 静态语义分析和中间代码生成 195
8.1 符号表 195
8.1.1 符号表的作用 195
8.1.2 符号的常见属性 196
8.1.3 符号表的实现 197
8.1.4 符号表体现作用域与可见性 197
8.1.5 实例: PL/0编译程序中符号表的设计与实现 199
8.2 静态语义分析 203
8.2.1 静态语义分析的主要任务 203
8.2.2 类型检查 204
8.3 中间代码生成 208
8.3.1 常见的中间表示形式 208
8.3.2 生成抽象语法树 210
8.3.3 生成三地址码 211
8.4 多遍的方法 220
练习 223
第9章 运行时存储组织 229
9.1 运行时存储组织概述 229
9.1.1 运行时存储组织的作用与任务 229
9.1.2 程序运行时存储空间的布局 230
9.1.3 存储分配策略 231
9.2 活动记录 234
9.2.1 过程活动记录 234
9.2.2 嵌套过程定义中非局部量的访问 236
9.2.3 嵌套程序块的非局部量访问 239
9.2.4 动态作用域规则和静态作用域规则 240
9.3 过程调用 241
9.4 PL/0编译程序的运行时存储组织 243
9.4.1 PL/0程序运行栈中的过程活动记录 244
9.4.2 实现过程调用和返回的类P-code指令 245
9.5 面向对象语言存储分配策略 247
9.5.1 类和对象的角色 247
9.5.2 面向对象程序运行时的特征 247
9.5.3 对象的存储组织 248
9.5.4 例程的动态绑定 249
9.5.5 其他话题 251
练习 251
第10章 代码优化和目标代码生成 255
10.1 基本块、流图和循环 255
10.1.1 基本块 255
10.1.2 流图 256
10.1.3 循环 257
10.2 数据流分析基础 258
10.2.1 数据流方程的概念 259
10.2.2 到达-定值数据流分析 259
10.2.3 活跃变量数据流分析 262
10.2.4 几种重要的变量使用数据流信息 263
10.3 代码优化技术 268
10.3.1 窥孔优化 270
10.3.2 局部优化 271
10.3.3 循环优化 275
10.3.4 全局优化 278
10.4 目标代码生成技术 279
10.4.1 目标代码生成的主要环节 280
10.4.2 一个简单的代码生成过程 282
10.4.3 高效使用寄存器 285
10.4.4 图着色寄存器分配 288
10.4.5 PL/0编译器的目标代码生成程序 289
练习 292
第11章 课程设计 296
11.1 基于PL/0编译器的课程设计 296
11.2 基于Decaf编译器的课程设计 297
11.2.1 Decaf编译器实验的总体结构 298
11.2.2 词法和语法分析（阶段一） 300
11.2.3 语义分析（阶段二） 303
11.2.4 中间代码生成（阶段三） 309
11.2.5 代码优化（阶段四） 317
11.2.6 目标代码生成（阶段五） 320
11.2.7 基于Decaf编译器的课程设计 333
11.3 软件包相关信息说明 335
第12章 编译器和相关工具实例——GCC/Binutils 336
12.1 开源编译器GCC 336
12.1.1 GCC介绍 337
12.1.2 GCC总体结构 338
12.1.3 GCC编译流程 339
12.1.4 GCC代码组织 341
12.1.5 小结 341
12.2 开源工具Binutils 341
12.2.1 目标文件 341
12.2.2 汇编器和链接器 342
12.2.3 其他工具 343
12.2.4 小结 343
12.3 编译器和工具使用实例 343
12.3.1 编译特定版本的编译器 343
12.3.2 查看目标文件 347
12.3.3 程序代码优化 349
12.3.4 小结 353
练习 353
附录A PL/0编译程序文本 354
参考文献  398
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>编译原理（第3版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>疯狂VirtualBox实战讲学录
第1章 虚拟化和云
1．1 虚拟化相关内容介绍
1．2 云计算相关内容介绍
1．3 参考资料与扩展阅读
第2章 以gui和gli方式管理virtualbox
2．1 virmalbox总体介绍
2．2 virtualbox开源版和闭源版的区别
2．3 virtualbox虚拟机的功能特点和特色
2．4 virtualbox虚拟机安装(gui方式)
2．5 virtualbox安装(cli方式)
2．6 virtualbox安装过程排错
2．7 使vboxmanage更好用
2．8 参考资料与扩展阅读
第3章 virtualbox术语及基本操作总览
3．1 virtualbox中的常用术语
3．2 virtualbox的基本操作
第4章配置虚拟机
4．1 virtualbox支持的操作系统
4．2 general settings(通用设置)
.4．3 system settings(系统设置)
4．4 display settings(显示设置)
4．5 存储设置(storage settings)
4．6 音频设置(audio settings)
4．7 网络设置(network settings)
4．8 串口(serial pons)
4．9 参考资料与扩展阅读
露5章 guost additiorts和extension pack
5．1 guest additions功能总览
5．2 实验
5．3 oracle vm virtualbox extension pack
5．4 参考资料与扩展阅读
第6章 快照技术和ova/ovf格式
6．1 什么是快照
6．2 快照的具体使用
6．3 快照技术细节分析
6．4 使用命令行管理snapshot
6．5 clone
6．6 通过cli的方式管理clone
6．7 ovf＼ova格式的好处
6．8 使用cli接口管理ovf＼ova
6．9 参考资料与扩展阅读
第7章 virtualbox的各种网络类型
7．1 virtualbox中常见的五种网络类型(gui方式配置)
7．2 使用cli的方式配置虚拟网络
7．3 参考资料与扩展阅读
第8章 udp tunnel networking@virtio
8．1 virtualbox支持的网卡芯片类型
8．2 virtio
8．3 使用命令行配置vlnio
8．4 udp tunnel networking
8．5 udp tunnel networking(cli方式进行)
8．6 使用一台计算机测试udp tunnel networking
8．7 参考资料与扩展阅读
第9章 vrdp配置大全
9．1 什么是rdp
9．2 vrdp
9．3 null模式配置
9．4 深入理解vrdp
9．5 通过external(第一种)验证vrdp(windows系统)
9．6 通过external(第一种)认证vrdp(linux发行版)
9．7 通过external(第二种)认证vrdp
9．8 使用cli配置null模式
9．9 使用cli配置external模式(第一种情况)
9．10 使用cl[配置external模式(第二种情况)
9．11 rdp encryption
9．12 vrdp video redirection
9．13 multiple connections to the vrdp server
9．14 multiple remote monitors
9．15 vrdp customization
9．16 remote usb
9．17 vrdp与rdp的对比
9．18 参考资料与扩展阅读
第10章 虚拟磁盘类型
10．1 virlualbox支持的虚拟磁盘格式
10．2 不同类型的硬盘接口
10．3 virtualbox中不同硬盘控制器的特点
10．4 virtualbox中不同性质的虚拟磁盘(重点)
10．5 7种虚拟磁盘类型总结(串讲)
10．6 方法总结
10．7 克隆磁盘(clonedisk)
10．8 host i／o caching
10．9 limitingbandwidthfordisklmages
10．10 参考资料与扩展阅读
第11章 virtualbox内置iscsi功能讨论
11．1 virtualbox内置iscsi功能介绍
11．2 存储技术介绍
11．3 实验
11．4 参考资料与扩展阅读
第12章 teleporting在线迁移
12．1 teleporting功能简介
12．2 配置teleporting
12．3 配置teleporting经验分享
12．4 参考资料与扩展阅读
露13章 virtualbox高级功能
13．1 sata硬盘ncq指令支持
13．2 模拟物理机bios dmi信息激活oem版系统
13．3 硬盘vendor product data(vpd)的妙用
13．4 vboxsdl，thesimplified vm displayer
13．5 automated guest logons
13．6 cpuhot-plugging
13．7 pci passthrough
13．8 自定义vesa
13．9 自定义vm的最大分辨率
13．10 在virtualbox中玩转rdm
13．11 调优virtualbox的nat引擎
13．12 调整time stamp counter(tsc)
13．13 accelerate or slow down the guest clock
13．14 调优guest additions的对时服务
13．15 自定义virtualbox manager的gui界面
13．16 自定义vm的电源行为
13．17 memory ballooning
13．18 memory balloonlng service
13．19 page fusion
13．20 phpvirtualbox配置详解
13．21 离线挂载vdi虚拟硬盘容器文件
13．22 参考资料与扩展阅读
第14章 vboxmanage相关内容补充
14．1 introduetion
14．2 vboxmanage list
14．3 vboxmanage showvminfo
14．4 vboxmanage registervm
14．5 vboxmanage unregistervm
14．6 vboxmanage createvm
14．7 vboxmanage modifyvm
14．8 vboxmanage controlvm
14．9 vboxmanage storagectl
14．10 vboxmanage modifyhd
14．1l vboxmanage convertfromraw
14．12 vboxmanage setproperty
14．13 vboxmanage deugvm
14．14 vboxmanage metrics
14．15 vboxmanage 子命令总览
14．16 参考资料与扩展阅读
第15章 virtualbox排错相关
15．1 virtualbox 4.0版本后的改变
15．2 virtualbox executables
15．3 installation failed! error报错解决办法
15．4 virtualbox内置的vmdebugger
15．5 virtualbox逻辑组件架构
15．6 解决vm显示ide／sata errors错误信息的方法
15．7 由于cie节能开关引起的物理机性能下降解决办法
15．8 使用vboxtestogl检测2d／3d视频加速
15．9 windows 2000安装失败解决办法
15．10 如何记录vm的蓝屏信息
15．11 windows vista／7不支持amd网卡驱动的解决办法
15．12 访问shared folders过慢的解决办法
15．13 windows98使用usb设备出现问题的解决办法
15．14 恢复d3d8.dll and d3d9.dll文件解决3d加速问题
15．15 由于linux发行版引起的系统负载较高的解决办法
15．16 已知linux核心bug解决办法
15．17 参考资料与扩展阅读
第16章 虚拟化和云必不可少的部分——p2v与v2v
16．1 虚拟化对企业的意义
16．2 p2v、v2v转换工具总览
16．3 使用disk2vhd进行p2v、v2v转换实例介绍
16．4 使用acronis true image进行p2v、v2v转换
16．5 使用vmware vcenter converter进行p2v、v2v转换
16．6 使用parallels transporter agent进行p2v、v2v转换
16．7 使用winlmage进行p2v、v2v转换
16．8 使用citrix xenconvert进行p2v、v2v转换
16．9 使用vboxmanage clonehd进行v2v转换
16．10 使用vmdk2vhd进行v2v转换
16．11 总结
16．12 参考资料与扩展阅读
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>疯狂VirtualBox实战讲学录
