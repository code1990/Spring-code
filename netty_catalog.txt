>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Netty实战
第一部分 Netty的概念及体系结构
第1 章 Netty——异步和事件驱动 3
1.1 Java 网络编程 4
1.1.1 Java NIO 5
1.1.2 选择器 6
1.2 Netty 简介 6
1.2.1 谁在使用Netty 7
1.2.2 异步和事件驱动 8
1.3 Netty 的核心组件 9
1.3.1 Channel 9
1.3.2 回调 9
1.3.3 Future 10
1.3.4 事件和ChannelHandler 11
1.3.5 把它们放在一起 12
1.4 小结 13
第2 章 你的第一款Netty应用程序 14
2.1 设置开发环境 14
2.1.1 获取并安装Java 开发工具包 14
2.1.2 下载并安装IDE 15
2.1.3 下载和安装Apache Maven 15
2.1.4 配置工具集 16
2.2 Netty 客户端/服务器概览 16
2.3 编写Echo 服务器 17
2.3.1 ChannelHandler 和业务逻辑 17
2.3.2 引导服务器 18
2.4 编写Echo 客户端 21
2.4.1 通过ChannelHandler 实现客户端逻辑 21
2.4.2 引导客户端 22
2.5 构建和运行Echo 服务器和客户端 24
2.5.1 运行构建 24
2.5.2 运行Echo 服务器和客户端 27
2.6 小结 29
第3 章 Netty 的组件和设计 30
3.1 Channel、EventLoop 和ChannelFuture 30
3.1.1 Channel 接口 31
3.1.2 EventLoop 接口 31
3.1.3 ChannelFuture 接口 32
3.2 ChannelHandler 和ChannelPipeline 32
3.2.1 ChannelHandler 接口 32
3.2.2 ChannelPipeline 接口 33
3.2.3 更加深入地了解ChannelHandler 34
3.2.4 编码器和解码器 35
3.2.5 抽象类SimpleChannelInboundHandler 35
3.3 引导 36
3.4 小结 37
第4 章 传输 38
4.1 案例研究：传输迁移 38
4.1.1 不通过Netty 使用OIO和NIO 39
4.1.2 通过Netty 使用OIO和NIO 41
4.1.3 非阻塞的Netty 版本 42
4.2 传输API 43
4.3 内置的传输 45
4.3.1 NIO——非阻塞I/O 46
4.3.2 Epoll——用于Linux的本地非阻塞传输 47
4.3.3 OIO——旧的阻塞I/O 48
4.3.4 用于JVM 内部通信的Local 传输 48
4.3.5 Embedded 传输 49
4.4 传输的用例 49
4.5 小结 51
第5 章 ByteBuf 52
5.1 ByteBuf 的API 52
5.2 ByteBuf 类——Netty的数据容器 53
5.2.1 它是如何工作的 53
5.2.2 ByteBuf 的使用模式 53
5.3 字节级操作 57
5.3.1 随机访问索引 57
5.3.2 顺序访问索引 57
5.3.3 可丢弃字节 58
5.3.4 可读字节 58
5.3.5 可写字节 59
5.3.6 索引管理 59
5.3.7 查找操作 60
5.3.8 派生缓冲区 60
5.3.9 读/写操作 62
5.3.10 更多的操作 64
5.4 ByteBufHolder 接口 65
5.5 ByteBuf 分配 65
5.5.1 按需分配：ByteBufAllocator 接口 65
5.5.2 Unpooled 缓冲区 67
5.5.3 ByteBufUtil 类 67
5.6 引用计数 67
5.7 小结 68
第6 章 ChannelHandler 和ChannelPipeline 70
6.1 ChannelHandler 家族 70
6.1.1 Channel 的生命周期 70
6.1.2 ChannelHandler的生命周期 71
6.1.3 ChannelInboundHandler接口 71
6.1.4 ChannelOutboundHandler接口 73
6.1.5 ChannelHandler 适配器 74
6.1.6 资源管理 74
6.2 ChannelPipeline 接口 76
6.2.1 修改ChannelPipeline 78
6.2.2 触发事件 79
6.3 ChannelHandlerContext接口 80
6.3.1 使用ChannelHandlerContext 82
6.3.2 ChannelHandler 和ChannelHandlerContext 的高级用法 84
6.4 异常处理 86
6.4.1 处理入站异常 86
6.4.2 处理出站异常 87
6.5 小结 88
第7 章 EventLoop 和线程模型 89
7.1 线程模型概述 89
7.2 EventLoop 接口 90
7.2.1 Netty 4 中的I/O 和事件处理 92
7.2.2 Netty 3 中的I/O 操作 92
7.3 任务调度 93
7.3.1 JDK 的任务调度API 93
7.3.2 使用EventLoop调度任务 94
7.4 实现细节 95
7.4.1 线程管理 95
7.4.2 EventLoop/线程的分配 96
7.5 小结 98
第8 章 引导 99
8.1 Bootstrap 类 99
8.2 引导客户端和无连接协议 101
8.2.1 引导客户端 102
8.2.2 Channel 和EventLoopGroup 的兼容性 103
8.3 引导服务器 104
8.3.1 ServerBootstrap 类 104
8.3.2 引导服务器 105
8.4 从Channel引导客户端 107
8.5 在引导过程中添加多个ChannelHandler 108
8.6 使用Netty 的ChannelOption 和属性 110
8.7 引导DatagramChannel 111
8.8 关闭 112
8.9 小结 112
第9 章 单元测试 113
9.1 EmbeddedChannel概述 113
9.2 使用EmbeddedChannel测试ChannelHandler 115
9.2.1 测试入站消息 115
9.2.2 测试出站消息 118
9.3 测试异常处理 119
9.4 小结 121
第二部分 编解码器
第10 章 编解码器框架 125
10.1 什么是编解码器 125
10.2 解码器 125
10.2.1 抽象类ByteToMessageDecoder 126
10.2.2 抽象类ReplayingDecoder 127
10.2.3 抽象类MessageToMessageDecoder 128
10.2.4 TooLongFrameException 类 130
10.3 编码器 131
10.3.1 抽象类MessageToByteEncoder 131
10.3.2 抽象类MessageToMessageEncoder 132
10.4 抽象的编解码器类 133
10.4.1 抽象类ByteToMessageCodec 133
10.4.2 抽象类MessageToMessageCodec 134
10.4.3 CombinedChannelDuplexHandler 类 137
10.5 小结 138
第11 章 预置的ChannelHandler和编解码器 139
11.1 通过SSL/TLS 保护Netty 应用程序 139
11.2 构建基于Netty 的HTTP/HTTPS 应用程序 141
11.2.1 HTTP 解码器、编码器和编解码器 141
11.2.2 聚合HTTP 消息 143
11.2.3 HTTP 压缩 144
11.2.4 使用HTTPS 145
11.2.5 WebSocket 146
11.3 空闲的连接和超时 148
11.4 解码基于分隔符的协议和基于长度的协议 150
11.4.1 基于分隔符的协议 150
11.4.2 基于长度的协议 153
11.5 写大型数据 155
11.6 序列化数据 1 57
11.6.1 JDK 序列化 157
11.6.2 使用JBoss Marshalling进行序列化 157
11.6.3 通过Protocol Buffers序列化 159
11.7 小结 160
第三部分 网络协议
第12 章 WebSocket 163
12.1 WebSocket 简介 163
12.2 我们的WebSocket 示例应用程序 164
12.3 添加WebSocket支持 165
12.3.1 处理HTTP 请求 165
12.3.2 处理WebSocket 帧 168
12.3.3 初始化ChannelPipeline 169
12.3.4 引导 171
12.4 测试该应用程序 173
12.5 小结 176
第13章 使用UDP 广播事件 177
13.1 UDP 的基础知识 177
13.2 UDP 广播 178
13.3 UDP 示例应用程序 178
13.4 消息 POJO:LogEvent 179
13.5 编写广播者 180
13.6 编写监视器 185
13.7 运行LogEventBroadcaster 和LogEventMonitor 187
13.8 小结 189
第四部分 案例研究
第14 章 案例研究，第一部分 193
14.1 Droplr—构建移动服务 193
14.1.1 这一切的起因 193
14.1.2 Droplr 是怎样工作的 194
14.1.3 创造一个更加快速的上传体验 194
14.1.4 技术栈 196
14.1.5 性能 199
14.1.6 小结——站在巨人的肩膀上 200
14.2 Firebase—实时的数据同步服务 200
14.2.1 Firebase 的架构 201
14.2.2 长轮询 201
14.2.3 HTTP 1.1 keep-alive和流水线化 204
14.2.4 控制SslHandler 205
14.2.5 Firebase 小结 207
14.3 Urban Airship—构建移动服务 207
14.3.1 移动消息的基础知识 207
14.3.2 第三方递交 208
14.3.3 使用二进制协议的例子 209
14.3.4 直接面向设备的递交 211
14.3.5 Netty 擅长管理大量的并发连接 212
14.3.6 Urban Airship 小结——跨越防火墙边界 213
14.4 小结 214
第15 章 案例研究，第二部分 215
15.1 Netty 在Facebook 的使用：Nifty 和Swift 215
15.1.1 什么是Thrift 215
15.1.2 使用Netty 改善Java Thrift 的现状 216
15.1.3 Nifty 服务器的设计 217
15.1.4 Nifty 异步客户端的设计 220
15.1.5 Swift：一种更快的构建Java Thrift 服务的方式 221
15.1.6 结果 221
15.1.7 Facebook 小结 224
15.2 Netty 在Twitter的使用：Finagle 224
15.2.1 Twitter 成长的烦恼 224
15.2.2 Finagle 的诞生 224
15.2.3 Finagle 是如何工作的 225
15.2.4 Finagle 的抽象 230
15.2.5 故障管理 231
15.2.6 组合服务 232
15.2.7 未来：Netty 232
15.2.8 Twitter 小结 233
15.3 小结 233
附录 Maven 介绍 234
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Netty实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Netty权威指南（第2版）
基础篇走进Java NIO
第1 章Java 的I/O 演进之路.2
1.1 I/O 基础入门...............3
1.1.1 Linux 网络I/O 模型简介.......3
1.1.2 I/O 多路复用技术.................6
1.2 Java 的I/O 演进..........8
1.3 总结............................ 10
第2 章NIO 入门.................... 11
2.1 传统的BIO 编程....... 11
2.1.1 BIO 通信模型图.................. 12
2.1.2 同步阻塞式I/O 创建的TimeServer 源码分析............. 13
2.1.3 同步阻塞式I/O 创建的TimeClient 源码分析.......... 16
2.2 伪异步I/O 编程........ 18
2.2.1 伪异步I/O 模型图.............. 19
2.2.2 伪异步I/O 创建的TimeServer 源码分析..... 19
2.2.3 伪异步I/O 弊端分析........... 21
2.3 NIO 编程.................... 24
2.3.1 NIO 类库简介.. 24
2.3.2 NIO 服务端序列图.............. 28
2.3.3 NIO 创建的TimeServer 源码分析................ 30
2.3.4 NIO 客户端序列图.............. 36
2.3.5 NIO 创建的TimeClient 源码分析................ 39
2.4 AIO 编程.................... 45
2.4.1 AIO 创建的TimeServer 源码分析................ 46
2.4.2 AIO 创建的TimeClient 源码分析................ 51
2.4.3 AIO 版本时间服务器运行结果.................... 56
2.5 4 种I/O 的对比......... 58
2.5.1 概念澄清.......... 58
2.5.2 不同I/O 模型对比.............. 59
2.6 选择Netty 的理由..... 60
2.6.1 不选择Java 原生NIO 编程的原因............... 61
2.6.2 为什么选择Netty ................ 62
2.7 总结............................ 63
入门篇 Netty NIO 开发指南
第3 章Netty 入门应用.......... 66
3.1 Netty 开发环境的搭建................ 66
3.1.1 下载Netty 的软件包........... 67
3.1.2 搭建Netty 应用工程........... 67
3.2 Netty 服务端开发...... 68
3.3 Netty 客户端开发...... 73
3.4 运行和调试................ 76
3.4.1 服务端和客户端的运行...... 76
3.4.2 打包和部署...... 77
3.5 总结............................ 77
第4 章TCP 粘包/拆包问题的解决之道...... 79
4.1 TCP 粘包/拆包.......... 79
4.1.1 TCP 粘包/拆包问题说明..... 80
4.1.2 TCP 粘包/拆包发生的原因....... 80
4.1.3 粘包问题的解决策略.......... 81
4.2 未考虑TCP 粘包导致功能异常案例................. 82
4.2.1 TimeServer 的改造.............. 82
4.2.2 TimeClient 的改造............... 83
4.2.3 运行结果.......... 84
4.3 利用LineBasedFrameDecoder 解决TCP 粘包问题................ 85
4.3.1 支持TCP 粘包的TimeServer ....................... 86
4.3.2 支持TCP 粘包的TimeClient........................ 88
4.3.3 运行支持TCP 粘包的时间服务器程序........ 90
4.3.4 LineBasedFrameDecoder 和StringDecoder 的原理分析........... 91
4.4 总结............................ 92
第5 章分隔符和定长解码器的应用...... 93
5.1 DelimiterBasedFrameDecoder 应用开发............. 94
5.1.1 DelimiterBasedFrameDecoder 服务端开发.... 94
5.1.2 DelimiterBasedFrameDecoder 客户端开发.... 97
5.1.3 运行DelimiterBasedFrameDecoder 服务端和客户端............... 99
5.2 FixedLengthFrameDecoder 应用开发............... 101
5.2.1 FixedLengthFrameDecoder 服务端开发...... 101
5.2.2 利用telnet 命令行测试EchoServer 服务端......103
5.3 总结.......................... 104
中级篇 Netty 编解码开发指南
第6 章编解码技术.............. 106
6.1 Java 序列化的缺点 ...... 107
6.1.1 无法跨语言.... 107
6.1.2 序列化后的码流太大........ 107
6.1.3 序列化性能太低................ 110
6.2 业界主流的编解码框架............ 113
6.2.1 Google 的Protobuf 介绍.... 113
6.2.2 Facebook 的Thrift 介绍.... 115
6.2.3 JBoss Marshalling 介绍..... 116
6.3 总结.......................... 117
第7 章MessagePack 编解码............... 118
7.1 MessagePack 介绍... 118
7.1.1 MessagePack 多语言支持.. 119
7.1.2 MessagePack Java API 介绍........................ 119
7.1.3 MessagePack 开发包下载. 120
7.2 MessagePack 编码器和解码器开发................. 120
7.2.1 MessagePack 编码器开发....... 120
7.2.2 MessagePack 解码器开发 ...... 121
7.2.3 功能测试........ 121
7.3 粘包/半包支持......... 124
7.4 总结.......................... 127
第8 章Google Protobuf 编解码.......... 128
8.1 Protobuf 的入门....... 129
8.1.1 Protobuf 开发环境搭建..... 129
8.1.2 Protobuf 编解码开发......... 131
8.1.3 运行Protobuf 例程............ 133
8.2 Netty 的Protobuf 服务端开发.. 133
8.2.1 Protobuf 版本的图书订购服务端开发........ 134
8.2.2 Protobuf 版本的图书订购客户端开发........ 136
8.2.3 Protobuf 版本的图书订购程序功能测试.... 139
8.3 Protobuf 的使用注意事项......... 140
8.4 总结.......................... 142
第9 章JBoss Marshalling 编解码....... 143
9.1 Marshalling 开发环境准备........ 143
9.2 Netty 的Marshalling 服务端开发..................... 144
9.3 Netty 的Marshalling 客户端开发..................... 147
9.4 运行Marshalling 客户端和服务端例程........... 149
9.5 总结.......................... 150
高级篇 Netty 多协议开发和应用
第10 章HTTP 协议开发应用............... 154
10.1 HTTP 协议介绍..... 155
10.1.1 HTTP 协议的URL .......... 155
10.1.2 HTTP 请求消息（HttpRequest）.............. 155
10.1.3 HTTP 响应消息（HttpResponse）........... 158
10.2 Netty HTTP 服务端入门开发....... 159
10.2.1 HTTP 服务端例程场景描述..................... 160
10.2.2 HTTP 服务端开发........... 160
10.2.3 Netty HTTP 文件服务器例程运行结果.... 166
10.3 Netty HTTP+XML 协议栈开发....................... 170
10.3.1 开发场景介绍................. 171
10.3.2 HTTP+XML 协议栈设计.......174
10.3.3 高效的XML 绑定框架JiBx ..................... 175
10.3.4 HTTP+XML 编解码框架开发.................. 183
10.3.5 HTTP+XML 协议栈测试....... 199
10.3.6 小结............. 201
10.4 总结........................ 202
第11 章WebSocket 协议开发............. 203
11.1 HTTP 协议的弊端....... 204
11.2 WebSocket 入门..... 204
11.2.1 WebSocket 背景............... 205
11.2.2 WebSocket 连接建立....... 206
11.2.3 WebSocket 生命周期....... 207
11.2.4 WebSocket 连接关闭....... 208
11.3 Netty WebSocket 协议开发..... 209
11.3.1 WebSocket 服务端功能介绍..................... 209
11.3.2 WebSocket 服务端开发.... 210
11.3.3 运行WebSocket 服务端... 218
11.4 总结........................ 219
第12 章私有协议栈开发.... 221
12.1 私有协议介绍........ 221
12.2 Netty 协议栈功能设计............ 223
12.2.1 网络拓扑图.. 223
12.2.2 协议栈功能描述.............. 224
12.2.3 通信模型...... 224
12.2.4 消息定义...... 225
12.2.5 Netty 协议支持的字段类型...................... 226
12.2.6 Netty 协议的编解码规范. 227
12.2.7 链路的建立.. 229
12.2.8 链路的关闭.. 230
12.2.9 可靠性设计.. 230
12.2.10 安全性设计 232
12.2.11 可扩展性设计................ 232
12.3 Netty 协议栈开发.. 233
12.3.1 数据结构定义................. 233
12.3.2 消息编解码.. 237
12.3.3 握手和安全认证.............. 241
12.3.4 心跳检测机制................. 245
12.3.5 断连重连...... 248
12.3.6 客户端代码.. 249
12.3.7 服务端代码.. 251
12.4 运行协议栈............ 252
12.4.1 正常场景...... 252
12.4.2 异常场景：服务端宕机重启.................... 253
12.4.3 异常场景：客户端宕机重启.................... 256
12.5 总结........................ 256
第13 章服务端创建............ 258
13.1 原生NIO 类库的复杂性......... 259
13.2 Netty 服务端创建源码分析.... 259
13.2.1 Netty 服务端创建时序图. 260
13.2.2 Netty 服务端创建源码分析...................... 263
13.3 客户端接入源码分析.............. 272
13.4 总结........................ 275
第14 章客户端创建............ 276
14.1 Netty 客户端创建流程分析.... 276
14.2.1 Netty 客户端创建时序图. 276
14.2.2 Netty 客户端创建流程分析...................... 277
14.2 Netty 客户端创建源码分析.... 278
14.2.1 客户端连接辅助类Bootstrap.................... 278
14.2.2 客户端连接操作.............. 281
14.2.3 异步连接结果通知.......... 283
14.2.4 客户端连接超时机制...... 284
14.3 总结........................ 286
源码分析篇 Netty 功能介绍和源码分析
第15 章ByteBuf 和相关辅助类........... 288
15.1 ByteBuf 功能说明. 288
15.1.1 ByteBuf 的工作原理........ 289
15.1.2 ByteBuf 的功能介绍........ 294
15.2 ByteBuf 源码分析. 308
15.2.1 ByteBuf 的主要类继承关系..................... 309
15.2.2 AbstractByteBuf 源码分析........................ 310
15.2.3 AbstractReferenceCountedByteBuf 源码分析.................. 319
15.2.4 UnpooledHeapByteBuf 源码分析.............. 321
15.2.5 PooledByteBuf 内存池原理分析............... 326
15.2.6 PooledDirectByteBuf 源码分析................. 329
15.3 ByteBuf 相关的辅助类功能介绍.................... 332
15.3.1 ByteBufHolder................. 332
15.3.2 ByteBufAllocator ............. 333
15.3.3 CompositeByteBuf ........... 334
15.3.4 ByteBufUtil .. 336
15.4 总结........................ 337
第16 章Channel 和Unsafe ................. 338
16.1 Channel 功能说明. 338
16.1.1 Channel 的工作原理........ 339
16.1.2 Channel 的功能介绍........ 340
16.2 Channel 源码分析. 343
16.2.1 Channel 的主要继承关系类图.................. 343
16.2.2 AbstractChannel 源码分析........................ 344
16.2.3 AbstractNioChannel 源码分析.................. 347
16.2.4 AbstractNioByteChannel 源码分析........... 350
16.2.5 AbstractNioMessageChannel 源码分析..... 353
16.2.6 AbstractNioMessageServerChannel 源码分析.............. 354
16.2.7 NioServerSocketChannel 源码分析........... 355
16.2.8 NioSocketChannel 源码分析..................... 358
16.3 Unsafe 功能说明... 364
16.4 Unsafe 源码分析... 365
16.4.1 Unsafe 继承关系类图...... 365
16.4.2 AbstractUnsafe 源码分析. 366
16.4.3 AbstractNioUnsafe 源码分析.................... 375
16.4.4 NioByteUnsafe 源码分析. 379
16.5 总结........................ 387
第17 章ChannelPipeline 和ChannelHandler........... 388
17.1 ChannelPipeline 功能说明....... 389
17.1.1 ChannelPipeline 的事件处理.................... 389
17.1.2 自定义拦截器................. 391
17.1.3 构建pipeline 392
17.1.4 ChannelPipeline 的主要特性.................... 393
17.2 ChannelPipeline 源码分析....... 393
17.2.1 ChannelPipeline 的类继承关系图............. 393
17.2.2 ChannelPipeline 对ChannelHandler 的管理........... 393
17.2.3 ChannelPipeline 的inbound 事件.............. 396
17.2.4 ChannelPipeline 的outbound 事件............ 397
17.3 ChannelHandler 功能说明....... 398
17.3.1 ChannelHandlerAdapter 功能说明............ 399
17.3.2 ByteToMessageDecoder 功能说明............ 399
17.3.3 MessageToMessageDecoder 功能说明...... 400
17.3.4 LengthFieldBasedFrameDecoder 功能说明............... 400
17.3.5 MessageToByteEncoder 功能说明............. 404
17.3.6 MessageToMessageEncoder 功能说明....... 404
17.3.7 LengthFieldPrepender 功能说明............... 405
17.4 ChannelHandler 源码分析....... 406
17.4.1 ChannelHandler 的类继承关系图............. 406
17.4.2 ByteToMessageDecoder 源码分析............ 407
17.4.3 MessageToMessageDecoder 源码分析...... 410
17.4.4 LengthFieldBasedFrameDecoder 源码分析............ 411
17.4.5 MessageToByteEncoder 源码分析............. 415
17.4.6 MessageToMessageEncoder 源码分析....... 416
17.4.7 LengthFieldPrepender 源码分析............... 417
17.5 总结........................ 418
第18 章EventLoop 和EventLoopGroup.................... 419
18.1 Netty 的线程模型.. 419
18.1.1 Reactor 单线程模型......... 420
18.1.2 Reactor 多线程模型......... 421
18.1.3 主从Reactor 多线程模型 422
18.1.4 Netty 的线程模型............ 423
18.1.5 最佳实践...... 424
18.2 NioEventLoop 源码分析......... 425
18.2.1 NioEventLoop 设计原理.. 425
18.2.2 NioEventLoop 继承关系类图................... 426
18.2.3 NioEventLoop.................. 427
18.3 总结........................ 436
第19 章Future 和Promise .................. 438
19.1 Future 功能............ 438
19.2 ChannelFuture 源码分析......... 443
19.3 Promise 功能介绍. 445
19.4 Promise 源码分析. 447
19.4.1 Promise 继承关系图........ 447
19.4.2 DefaultPromise ................ 447
19.5 总结........................ 449
架构和行业应用篇 Netty 高级特性
第20 章Netty 架构剖析..... 452
20.1 Netty 逻辑架构...... 452
20.1.1 Reactor 通信调度层......... 453
20.1.2 职责链ChannelPipeline ... 453
20.1.3 业务逻辑编排层（Service ChannelHandler）........... 454
20.2 关键架构质量属性.................. 454
20.2.1 高性能.......... 454
20.2.2 可靠性.......... 457
20.2.3 可定制性...... 460
20.2.4 可扩展性...... 460
20.3 总结........................ 460
第21 章Java 多线程编程在Netty 中的应用............. 461
21.1 Java 内存模型与多线程编程.. 461
21.1.1 硬件的发展和多任务处理........................ 461
21.1.2 Java 内存模型................. 462
21.2 Netty 的并发编程实践............ 464
21.2.1 对共享的可变数据进行正确的同步......... 464
21.2.2 正确使用锁.. 465
21.2.3 volatile 的正确使用......... 467
21.2.4 CAS 指令和原子类......... 470
21.2.5 线程安全类的应用.......... 472
21.2.6 读写锁的应用................. 476
21.2.7 线程安全性文档说明...... 477
21.2.8 不要依赖线程优先级...... 478
21.3 总结........................ 479
第22 章高性能之道............ 480
22.1 RPC 调用性能模型分析.......... 480
22.1.1 传统RPC 调用性能差的三宗罪............... 480
22.1.2 I/O 通信性能三原则........ 481
22.2 Netty 高性能之道.. 482
22.2.1 异步非阻塞通信.............. 482
22.2.2 高效的Reactor 线程模型 482
22.2.3 无锁化的串行设计.......... 485
22.2.4 高效的并发编程.............. 486
22.2.5 高性能的序列化框架...... 486
22.2.6 零拷贝.......... 487
22.2.7 内存池.......... 491
22.2.8 灵活的TCP 参数配置能力....................... 494
22.3 主流NIO 框架性能对比......... 495
22.4 总结........................ 497
第23 章可靠性.................... 498
23.1 可靠性需求............ 498
23.1.1 宕机的代价.. 498
23.1.2 Netty 可靠性需求............ 499
23.2 Netty 高可靠性设计................ 500
23.2.1 网络通信类故障.............. 500
23.2.2 链路的有效性检测.......... 507
23.2.3 Reactor 线程的保护......... 510
23.2.4 内存保护...... 513
23.2.5 流量整形...... 516
23.2.6 优雅停机接口................. 519
23.3 优化建议................ 520
23.3.1 发送队列容量上限控制... 520
23.3.2 回推发送失败的消息...... 521
23.4 总结........................ 521
第24 章安全性.................... 522
24.1 严峻的安全形势.... 522
24.1.1 OpenSSL Heart bleed 漏洞.......... 522
24.1.2 安全漏洞的代价.............. 523
24.1.3 Netty 面临的安全风险..... 523
24.2 Netty SSL 安全特性................. 525
24.2.1 SSL 单向认证.................. 525
24.2.2 SSL 双向认证.................. 532
24.2.3 第三方CA 认证.............. 536
24.3 Netty SSL 源码分析................. 538
24.3.1 客户端.......... 538
24.3.2 服务端.......... 541
24.3.3 消息读取...... 544
24.3.4 消息发送...... 545
24.4 Netty 扩展的安全特性............ 546
24.4.1 IP 地址黑名单机制.......... 547
24.4.2 接入认证...... 548
24.4 总结........................ 550
第25 章Netty 未来展望..... 551
25.1 应用范围................ 551
25.2 技术演进................ 552
25.3 社区活跃度............ 552
25.4 Road Map ............... 552
25.5 总结........................ 553
附录A Netty 参数配置表.... 554
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Netty权威指南（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Netty权威指南
基础篇  走进Java NIO
第1章  Java的I/O演进之路	2
1.1  I/O基础入门	3
1.1.1  Linux网络I/O模型简介	3
1.1.2  I/O多路复用技术	6
1.2  Java的I/O演进	8
1.3  总结	10
第2章  NIO入门	11
2.1  传统的BIO编程	11
2.1.1  BIO通信模型图	12
2.1.2  同步阻塞式I/O创建的TimeServer源码分析	13
2.1.3  同步阻塞式I/O创建的TimeClient源码分析	16
2.2  伪异步I/O编程	18
2.2.1  伪异步I/O模型图	19
2.2.2  伪异步式I/O创建的TimeServer源码分析	19
2.2.3  伪异步I/O弊端分析	21
2.3  NIO编程	24
2.3.1  NIO类库简介	24
2.3.2  NIO服务端序列图	28
2.3.3  NIO创建的TimeServer源码分析	31
2.3.4  NIO客户端序列图	36
2.3.5  NIO创建的TimeClient源码分析	39
2.4  AIO编程	45
2.4.1  AIO创建的TimeServer源码分析	46
2.4.2  AIO创建的TimeClient源码分析	52
2.4.3  AIO版本时间服务器运行结果	56
2.5  4种I/O的对比	58
2.5.1  概念澄清	58
2.5.2  不同I/O模型对比	60
2.6  选择Netty的理由	60
2.6.1  不选择Java原生NIO编程的原因	61
2.6.2  为什么选择Netty	62
2.7  总结	63
入门篇  Netty NIO开发指南
第3章  Netty入门应用	66
3.1  Netty开发环境的搭建	66
3.1.1  下载Netty的软件包	67
3.1.2  搭建Netty应用工程	67
3.2  Netty服务端开发	68
3.3  Netty客户端开发	73
3.4  运行和调试	76
3.4.1  服务端和客户端的运行	76
3.4.2  打包和部署	77
3.5  总结	78
第4章  TCP粘包/拆包问题的解决之道	79
4.1  TCP粘包/拆包	79
4.1.1  TCP粘包/拆包问题说明	80
4.1.2  TCP粘包/拆包发生的原因	80
4.1.3  粘包问题的解决策略	81
4.2  未考虑TCP粘包导致功能异常案例	82
4.2.1  TimeServer的改造	82
4.2.2  TimeClient的改造	83
4.2.3  运行结果	84
4.3  利用LineBasedFrameDecoder解决TCP粘包问题	88
4.3.1  支持TCP粘包的TimeServer	88
4.3.2  支持TCP粘包的TimeClient	90
4.3.3  运行支持TCP粘包的时间服务器程序	93
4.3.4  LineBasedFrameDecoder和StringDecoder的原理分析	98
4.4  总结	99
第5章  分隔符和定长解码器的应用	100
5.1  DelimiterBasedFrameDecoder应用开发	101
5.1.1  DelimiterBasedFrameDecoder服务端开发	101
5.1.2  DelimiterBasedFrameDecoder客户端开发	104
5.1.3  运行DelimiterBasedFrameDecoder服务端和客户端	106
5.2  FixedLengthFrameDecoder应用开发	108
5.2.1  FixedLengthFrameDecoder服务端开发	108
5.2.2  利用telnet命令行测试EchoServer服务端	110
5.3  总结	111
中级篇  Netty编解码开发指南
第6章  编解码技术	114
6.1  Java序列化的缺点	115
6.1.1  无法跨语言	115
6.1.2  序列化后的码流太大	115
6.1.3  序列化性能太低	118
6.2  业界主流的编解码框架	121
6.2.1  Google的Protobuf介绍	121
6.2.2  Facebook的Thrift介绍	123
6.2.3  JBoss Marshalling介绍	124
6.3  总结	125
第7章  Java序列化	126
7.1  Netty Java序列化服务端开发	126
7.2  Java序列化Netty客户端开发	132
7.3  运行结果	135
7.4  总结	137
第8章  Google Protobuf编解码	138
8.1  Protobuf的入门	139
8.1.1  Protobuf开发环境搭建	139
8.1.2  Protobuf编解码开发	141
8.1.3  运行Protobuf例程	143
8.2  Netty的Protobuf服务端开发	143
8.2.1  Protobuf版本的图书订购服务端开发	144
8.2.2  Protobuf版本的图书订购客户端开发	146
8.2.3  Protobuf版本的图书订购程序功能测试	149
8.3  Protobuf的使用注意事项	152
8.4  总结	153
第9章  JBoss Marshalling编解码	154
9.1  Marshalling开发环境准备	154
9.2  Netty的Marshalling服务端开发	155
9.3  Netty的Marshalling客户端开发	158
9.4  运行Marshalling客户端和服务端例程	160
9.5  总结	162
高级篇  Netty多协议开发和应用
第10章  HTTP协议开发应用	164
10.1  HTTP协议介绍	165
10.1.1  HTTP协议的URL	165
10.1.2  HTTP请求消息（HttpRequest）	165
10.1.3  HTTP响应消息（HttpResponse）	168
10.2  Netty HTTP服务端入门开发	169
10.2.1  HTTP服务端例程场景描述	170
10.2.2  HTTP服务端开发	170
10.2.3  Netty HTTP文件服务器例程运行结果	178
10.3  Netty HTTP+XML协议栈开发	182
10.3.1  开发场景介绍	183
10.3.2  HTTP+XML协议栈设计	186
10.3.3  高效的XML绑定框架JiBx	187
10.3.4  HTTP+XML编解码框架开发	195
10.3.5  HTTP+XML协议栈测试	211
10.3.6  小结	213
10.4  总结	214
第11章  WebSocket协议开发	215
11.1  HTTP协议的弊端	216
11.2  WebSocket入门	216
11.2.1  WebSocket背景	217
11.2.2  WebSocket连接建立	218
11.2.3  WebSocket生命周期	219
11.2.4  WebSocket连接关闭	220
11.3  Netty WebSocket协议开发	221
11.3.1  WebSocket服务端功能介绍	221
11.3.2  WebSocket服务端开发	222
11.3.3  运行WebSocket服务端	230
11.4  总结	231
第12章  UDP协议开发	233
12.1  UDP协议简介	234
12.2  UDP服务端开发	235
12.3  UDP客户端开发	238
12.4  运行UDP例程	240
12.5  总结	241
第13章  文件传输	242
13.1  文件的基础知识	243
13.1.1  文件的概念	243
13.1.2  文件路径	243
13.1.3  文件名称	244
13.1.4  FileChannel简介	244
13.2  Netty文件传输开发	245
13.3  运行Netty文件传输服务例程	248
13.4  总结	250
第14章  私有协议栈开发	251
14.1  私有协议介绍	251
14.2  Netty协议栈功能设计	253
14.2.1  网络拓扑图	253
14.2.2  协议栈功能描述	254
14.2.3  通信模型	254
14.2.4  消息定义	255
14.2.5  Netty协议支持的字段类型	256
14.2.6  Netty协议的编解码规范	257
14.2.7  链路的建立	259
14.2.8  链路的关闭	260
14.2.9  可靠性设计	260
14.2.10  安全性设计	262
14.2.11  可扩展性设计	262
14.3  Netty协议栈开发	263
14.3.1  数据结构定义	263
14.3.2  消息编解码	267
14.3.3  握手和安全认证	271
14.3.4  心跳检测机制	275
14.3.5  断连重连	278
14.3.6  客户端代码	279
14.3.7  服务端代码	281
14.4  运行协议栈	282
14.4.1  正常场景	282
14.4.2  异常场景：服务端宕机重启	283
14.4.3  异常场景：客户端宕机重启	286
14.5  总结	286
源码分析篇  Netty功能介绍和源码分析
第15章  ByteBuf和相关辅助类	290
15.1  ByteBuf功能说明	290
15.1.1  ByteBuf的工作原理	291
15.1.2  ByteBuf的功能介绍	296
15.2  ByteBuf源码分析	310
15.2.1  ByteBuf的主要类继承关系	311
15.2.2  AbstractByteBuf源码分析	312
15.2.3  AbstractReferenceCountedByteBuf源码分析	321
15.2.4  UnpooledHeapByteBuf源码分析	323
15.2.5  PooledByteBuf内存池原理分析	328
15.2.6  PooledDirectByteBuf源码分析	331
15.3  ByteBuf相关的辅助类功能介绍	334
15.3.1  ByteBufHolder	334
15.3.2  ByteBufAllocator	335
15.3.3  CompositeByteBuf	336
15.3.4  ByteBufUtil	338
15.4  总结	339
第16章  Channel和Unsafe	340
16.1  Channel 功能说明	340
16.1.1  Channel的工作原理	341
16.1.2  Channel的功能介绍	342
16.2  Channel源码分析	345
16.2.1  Channel的主要继承关系类图	345
16.2.2  AbstractChannel源码分析	346
16.2.3  AbstractNioChannel源码分析	349
16.2.4  AbstractNioByteChannel源码分析	352
16.2.5  AbstractNioMessageChannel源码分析	356
16.2.6  AbstractNioMessageServerChannel源码分析	357
16.2.7  NioServerSocketChannel源码分析	358
16.2.8  NioSocketChannel源码分析	360
16.3  Unsafe功能说明	366
16.4  Unsafe源码分析	367
16.4.1  Unsafe继承关系类图	367
16.4.2  AbstractUnsafe源码分析	367
16.4.3  AbstractNioUnsafe源码分析	377
16.4.4  NioByteUnsafe源码分析	380
16.5  总结	387
第17章  ChannelPipeline和ChannelHandler	389
17.1  ChannelPipeline功能说明	390
17.1.1  ChannelPipeline的事件处理	390
17.1.2  自定义拦截器	392
17.1.3  构建pipeline	393
17.1.4  ChannelPipeline的主要特性	394
17.2  ChannelPipeline源码分析	394
17.2.1  ChannelPipeline的类继承关系图	394
17.2.2  ChannelPipeline对ChannelHandler的管理	394
17.2.3  ChannelPipeline的inbound事件	397
17.2.4  ChannelPipeline的outbound事件	398
17.3  ChannelHandler功能说明	399
17.3.1  ChannelHandlerAdapter功能说明	400
17.3.2  ByteToMessageDecoder功能说明	400
17.3.3  MessageToMessageDecoder功能说明	401
17.3.4  LengthFieldBasedFrameDecoder功能说明	402
17.3.5  MessageToByteEncoder功能说明	405
17.3.6  MessageToMessageEncoder功能说明	406
17.3.7  LengthFieldPrepender功能说明	406
17.4  ChannelHandler源码分析	407
17.4.1  ChannelHandler的类继承关系图	407
17.4.2  ByteToMessageDecoder源码分析	408
17.4.3  MessageToMessageDecoder源码分析	411
17.4.4  LengthFieldBasedFrameDecoder源码分析	413
17.4.5  MessageToByteEncoder源码分析	417
17.4.6  MessageToMessageEncoder源码分析	418
17.4.7  LengthFieldPrepender源码分析	419
17.5  总结	420
第18章  EventLoop和EventLoopGroup	421
18.1  Netty的线程模型	421
18.1.1  Reactor单线程模型	422
18.1.2  Reactor多线程模型	423
18.1.3  主从Reactor多线程模型	424
18.1.4  Netty的线程模型	425
18.1.5  最佳实践	427
18.2  NioEventLoop源码分析	427
18.2.1  NioEventLoop设计原理	427
18.2.2  NioEventLoop继承关系类图	428
18.2.3  NioEventLoop	429
18.3  总结	440
第19章  Future和Promise	441
19.1  Future功能	441
19.2  ChannelFuture源码分析	446
19.3  Promise功能介绍	448
19.4  Promise源码分析	450
19.4.1  Promise继承关系图	450
19.4.2  DefaultPromise	450
19.5  总结	453
架构和行业应用篇  Netty高级特性
第20章  Java多线程编程在Netty中的应用	456
20.1  Java内存模型与多线程编程	456
20.1.1  硬件的发展和多任务处理	456
20.1.2  Java内存模型	457
20.2  Netty的并发编程实践	459
20.2.1  对共享的可变数据进行正确的同步	459
20.2.2  正确的使用锁	460
20.2.3  volatile的正确使用	462
20.2.4  CAS指令和原子类	465
20.2.5  线程安全类的应用	467
20.2.6  读写锁的应用	470
20.2.7  线程安全性文档说明	472
20.2.8  不要依赖线程优先级	473
20.3  总结	474
第21章  Netty架构剖析	475
21.1  Netty逻辑架构	475
21.1.1  Reactor通信调度层	476
21.1.2  职责链ChannelPipeline	476
21.1.3  业务逻辑编排层（Service ChannelHandler）	477
21.2  关键架构质量属性	477
21.2.1  高性能	477
21.2.2  可靠性	480
21.2.3  可定制性	483
21.2.4  可扩展性	483
21.3  总结	483
第22章  Netty行业应用	484
22.1  Netty在互联网行业的应用	485
22.1.1  传统垂直架构面临的问题	485
22.1.2  阿里分布式服务框架Dubbo	485
22.1.3  Dubbo的架构介绍	487
22.1.4  Netty在Dubbo中的应用	489
22.1.5  Dubbo框架集成Netty源码分析	491
22.2  Netty在大数据领域的应用	496
22.3  Netty在游戏行业的应用	497
22.3.1  游戏服务端架构介绍	498
22.3.2  Netty在游戏服务端的应用	501
22.4  总结	502
第23章  Netty未来展望	503
23.1  应用范围	503
23.2  技术演进	504
23.3  社区活跃度	504
23.4  Road Map	504
23.5  总结	505
附录A  Netty参数配置表	506
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Netty权威指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Netty进阶之路：跟着案例学Netty
第1章  Netty服务端意外退出案例  1
1.1  Netty服务端意外退出问题  1
1.1.1  Java Daemon线程简介  2
1.1.2  Netty服务端启动原理  4
1.1.3  如何防止Netty服务端意外退出  6
1.1.4  实际项目中的优化策略  8
1.2  Netty优雅退出机制  9
1.2.1  Java优雅退出机制  10
1.2.2  Java优雅退出的注意点  12
1.2.3  Netty优雅退出机制  14
1.2.4  Netty优雅退出原理和源码分析  15
1.2.5  Netty优雅退出的一些误区  20
1.3  总结  21
第2章  Netty客户端连接池资源泄漏案例  22
2.1  Netty连接池资源泄漏问题  22
2.1.1  连接池创建代码  23
2.1.2  内存溢出和线程膨胀  23
2.1.3  错用NIO编程模式  25
2.1.4  正确的连接池创建方式  26
2.1.5  并发安全和资源释放  28
2.2  Netty客户端创建机制  29
2.2.1  Java NIO客户端创建原理分析  29
2.2.2  Netty客户端创建原理分析  32
2.2.3  Bootstrap工具类源码分析  34
2.3  总结  36
第3章  Netty内存池泄漏疑云案例  37
3.1  Netty内存池泄漏问题  37
3.1.1  路由转发服务代码  38
3.1.2  响应消息内存释放玄机  39
3.1.3  采集堆内存快照分析  42
3.1.4  ByteBuf申请和释放的理解误区  45
3.2  Netty内存池工作机制  48
3.2.1  内存池的性能优势  48
3.2.2  内存池工作原理分析  51
3.2.3  内存池核心代码分析  54
3.3  总结  58
第４章  ByteBuf故障排查案例  59
4.1  HTTP协议栈ByteBuf使用问题  59
4.1.1  HTTP响应Body获取异常  59
4.1.2  ByteBuf非法引用问题  63
4.1.3  ByteBuf使用注意事项  66
4.2  Netty ByteBuf实现机制  67
4.2.1  Java原生ByteBuffer的局限性  67
4.2.2  Netty ByteBuf工作原理分析  67
4.2.3  ByteBuf引用计数器工作原理和源码分析  70
4.3  总结  73
第5章  Netty发送队列积压导致内存泄漏案例  74
5.1  Netty发送队列积压案例  74
5.1.1  高并发故障场景  74
5.1.2  内存泄漏原因分析  76
5.1.3  如何防止发送队列积压  78
5.1.4  其他可能导致发送队列积压的因素  80
5.2  Netty消息发送工作机制  82
5.2.1  WriteAndFlushTask原理和源码分析  83
5.2.2  ChannelOutboundBuffer原理和源码分析  86
5.2.3  消息发送源码分析  88
5.2.4  消息发送高低水位控制  94
5.3  总结  95
第6章  API网关高并发压测性能波动案例  96
6.1  高并发压测性能波动问题  96
6.1.1  故障场景模拟  96
6.1.2  性能波动原因定位  98
6.1.3  主动内存泄漏定位法  101
6.1.4  网关类产品的优化建议  102
6.2  Netty消息接入内存申请机制  102
6.2.1  消息接入的内存分配原理和源码分析  102
6.2.2  Netty ByteBuf的动态扩容原理和源码分析  107
6.3  总结  108
第7章  Netty ChannelHandler并发安全案例  109
7.1  Netty ChannelHandler并发安全问题  109
7.1.1  串行执行的ChannelHandler  110
7.1.2  跨链路共享的ChannelHandler  114
7.1.3  ChannelHandler的并发陷阱  116
7.2  Netty ChannelHandler工作机制  118
7.2.1  职责链ChannelPipeline原理和源码分析  118
7.2.2  用户自定义Event原理和源码分析  122
7.3  总结  123
第8章  车联网服务端接收不到车载终端消息案例  124
8.1  车联网服务端接收不到车载终端消息问题  124
8.1.1  故障现象  125
8.1.2  故障期线程堆栈快照分析  126
8.1.3  NioEventLoop线程防挂死策略  128
8.2  NioEventLoop线程工作机制  129
8.2.1  I/O读写操作原理和源码分析  130
8.2.2  异步任务执行原理和源码分析  133
8.2.3  定时任务执行原理和源码分析  135
8.2.4  Netty多线程最佳实践  137
8.3  总结  137
第９章  Netty 3.X版本升级案例  139
9.1  Netty 3.X的版本升级背景  139
9.1.1  被迫升级场景  140
9.1.2  升级不当遭遇各种问题  140
9.2  版本升级后数据被篡改问题  141
9.2.1  数据篡改原因分析  142
9.2.2  问题总结  143
9.3  升级后上下文丢失问题  143
9.3.1  上下文丢失原因分析  144
9.3.2  依赖第三方线程模型的思考  144
9.4  升级后应用遭遇性能下降问题  145
9.4.1  性能下降原因分析  145
9.4.2  性能优化建议  146
9.5  Netty线程模型变更分析  147
9.5.1  Netty 3.X版本线程模型  147
9.5.2  Netty 4.X版本线程模型  149
9.5.3  线程模型变化点源码分析  150
9.5.4  线程模型变化总结  152
9.6  总结  154
第10章  Netty并发失效导致性能下降案例  155
10.1  业务ChannelHandler无法并发执行问题  155
10.1.1  服务端并发设计相关代码分析  155
10.1.2  无法并行执行的EventExecutorGroup  159
10.1.3  并行执行优化策略和结果  161
10.2  Netty DefaultEventExecutor工作机制  163
10.2.1  DefaultEventExecutor原理和源码分析  164
10.2.2  业务线程池优化策略  165
10.2.3  Netty线程绑定机制原理和源码分析  168
10.3  总结  170
第11章  IoT百万长连接性能调优案例  171
11.1  海量长连接接入面临的挑战  171
11.1.1  IoT设备接入特点  172
11.1.2  IoT服务端性能优化场景  172
11.1.3  服务端面临的性能挑战  172
11.2  智能家居内存泄漏问题  173
11.2.1  服务端内存泄漏原因定位  173
11.2.2  问题背后的一些思考  174
11.3  操作系统参数调优  174
11.3.1  文件描述符  175
11.3.2  TCP/IP相关参数  175
11.3.3  多网卡队列和软中断  177
11.4  Netty性能调优  177
11.4.1  设置合理的线程数  177
11.4.2  心跳优化  180
11.4.3  接收和发送缓冲区调优  183
11.4.4  合理使用内存池  184
11.4.5  防止I/O线程被意外阻塞  185
11.4.6  I/O线程和业务线程分离  187
11.4.7  针对端侧并发连接数的流控  187
11.5  JVM相关性能优化  189
11.5.1  GC调优  189
11.5.2  其他优化手段  193
11.6  总结  193
第12章  静态检查修改不当引起性能下降案例  195
12.1  Edge Service性能严重下降问题  195
12.1.1  Edge Service热点代码分析  195
12.1.2  静态检查问题不是简单的一改了之  197
12.1.3  问题反思和改进  200
12.2  克隆和浅拷贝  201
12.2.1  浅拷贝存在的问题  201
12.2.2  Netty的对象拷贝实现策略  203
12.3  总结  204
第13章  Netty性能统计误区案例  205
13.1  时延毛刺排查相关问题  205
13.1.1  时延毛刺问题初步分析  205
13.1.2  服务调用链改进  207
13.1.3  都是同步思维惹的祸  208
13.1.4  正确的消息发送速度性能统计策略  209
13.1.5  常见的消息发送性能统计误区  212
13.2  Netty关键性能指标采集策略  212
13.2.1  Netty I/O线程池性能指标  213
13.2.2  Netty发送队列积压消息数  214
13.2.3  Netty消息读取速度性能统计  215
13.3  总结  215
第14章  gRPC的Netty HTTP/2实践案例  216
14.1  gRPC基础入门  216
14.1.1  RPC框架简介  216
14.1.2  当前主流的RPC框架  218
14.1.3  gRPC框架特点  218
14.1.4  为什么选择HTTP/2  219
14.2  gRPC Netty HTTP/2服务端工作机制  220
14.2.1  Netty HTTP/2服务端创建原理和源码分析  220
14.2.2  服务端接收HTTP/2请求消息原理和源码分析  224
14.2.3  服务端发送HTTP/2响应消息原理和源码分析  231
14.3  gRPC Netty HTTP/2客户端工作机制  234
14.3.1  Netty HTTP/2客户端创建原理和源码分析  235
14.3.2  客户端发送HTTP/2请求消息原理和源码分析  238
14.3.3  客户端接收HTTP/2响应消息原理和源码分析  242
14.4  gRPC消息序列化机制  243
14.4.1  Google Protobuf简介  243
14.4.2  消息的序列化原理和源码分析  244
14.4.3  消息的反序列化原理和源码分析  245
14.5  gRPC线程模型  246
14.5.1  服务端线程模型  246
14.5.2  客户端线程模型  247
14.5.3  线程模型总结  248
14.6  总结  249
第15章  Netty事件触发策略使用不当案例  250
15.1  channelReadComplete方法被调用多次问题  250
15.1.1  ChannelHandler调用问题  250
15.1.2  生产环境问题模拟重现  252
15.2  ChannelHandler使用的一些误区总结  255
15.2.1  channelReadComplete方法调用  255
15.2.2  ChannelHandler职责链调用  257
15.3  总结  258
第16章  Netty流量整形应用案例  259
16.1  Netty流量整形功能  259
16.1.1  通用的流量整形功能简介  260
16.1.2  Netty流量整形功能简介  260
16.2  Netty流量整形应用  261
16.2.1  流量整形示例代码  261
16.2.2  流量整形功能测试  263
16.3  Netty流量整形工作机制  264
16.3.1  流量整形工作原理和源码分析  264
16.3.2  并发编程在流量整形中的应用  271
16.3.3  使用流量整形的一些注意事项总结  274
16.4  总结  278
第17章  Netty SSL应用案例  279
17.1  Netty SSL功能简介  279
17.1.1  SSL安全特性  280
17.1.2  Netty SSL实现机制  281
17.2  Netty客户端SSL握手超时问题  282
17.2.1  握手超时原因定位  282
17.2.2  Netty SSL握手问题定位技巧  283
17.3  SSL握手性能问题  284
17.3.1  SSL握手性能热点分析  284
17.3.2  缓存和对象池  285
17.4  SSL事件监听机制  286
17.4.1  握手成功事件  286
17.4.2  SSL连接关闭事件  286
17.5  总结  287
第18章  Netty HTTPS服务端高并发宕机案例  288
18.1  Netty HTTPS服务端宕机问题  288
18.1.1  客户端大量超时  288
18.1.2  服务端内存泄漏原因分析  289
18.1.3  NioSocketChannel泄漏原因探究  290
18.1.4  高并发场景下缺失的可靠性保护  292
18.2  功能层面的可靠性优化  294
18.2.1  Netty HTTPS服务端可靠性优化  295
18.2.2  HTTPS客户端优化  296
18.3  架构层面的可靠性优化  297
18.3.1  端到端架构问题剖析  297
18.3.2  HTTP Client切换到NIO  298
18.3.3  同步RPC调用切换到异步调用  299
18.3.4  协议升级到HTTP/2  303
18.4  总结  307
第19章  MQTT服务接入超时案例  308
19.1  MQTT服务接入超时问题  308
19.1.1  生产环境问题现象  308
19.1.2  连接数膨胀原因分析  309
19.1.3  无效连接的关闭策略  309
19.1.4  问题总结  310
19.2  基于Netty的可靠性设计  311
19.2.1  业务定制I/O异常  311
19.2.2  链路的有效性检测  312
19.2.3  内存保护  313
19.3  总结  315
第20章  Netty实践总结  316
20.1  Netty学习策略  316
20.1.1  入门知识准备  316
20.1.2  Netty入门学习  319
20.1.3  项目实践  319
20.1.4  Netty源码阅读策略  319
20.2  Netty故障定位技巧  320
20.2.1  接收不到消息  320
20.2.2  内存泄漏  321
20.2.3  性能问题  322
20.3  总结  322
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Netty进阶之路：跟着案例学Netty
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Netty、Redis、Zookeeper高并发实战
前言
第1章 高并发时代的必备技能 1
1.1 Netty为何这么火 1
1.1.1 Netty火热的程度 1
1.1.2 Netty是面试的必杀器 2
1.2 高并发利器Redis 2
1.2.1 什么是Redis 2
1.2.2 Redis成为缓存事实标准的原因 3
1.3 分布式利器ZooKeeper 3
1.3.1 什么是ZooKeeper 3
1.3.2 ZooKeeper的优势 4
1.4 高并发IM的综合实践 4
1.4.1 高并发IM的学习价值 4
1.4.2 庞大的应用场景 5
1.5 Netty、Redis、ZooKeeper实践计划 5
1.5.1 第1天：Java NIO实践 5
1.5.2 第2天：Reactor反应器模式实践 6
1.5.3 第3天：异步回调模式实践 7
1.5.4 第4天：Netty基础实践 8
1.5.5 第5天：解码器（Decoder）与编码器（Encoder）实践 9
1.5.6 第6天：JSON和ProtoBuf序列化实践 11
1.5.7 第7~10天：基于Netty的单聊实战 12
1.5.8 第11天：ZooKeeper实践计划 14
1.5.9 第12天：Redis实践计划 14
1.6 本章小结 16
第2章 高并发IO的底层原理 17
2.1 IO读写的基础原理 17
2.1.1 内核缓冲区与进程缓冲区 18
2.1.2 详解典型的系统调用流程 18
2.2 四种主要的IO模型 19
2.2.1 同步阻塞IO（Blocking IO） 20
2.2.2 同步非阻塞NIO（None Blocking IO） 21
2.2.3 IO多路复用模型（IO Multiplexing） 22
2.2.4 异步IO模型（Asynchronous IO） 23
2.3 通过合理配置来支持百万级并发连接 24
2.4 本章小结 26
第3章 Java NIO通信基础详解 27
3.1 Java NIO简介 27
3.1.1 NIO和OIO的对比 28
3.1.2 通道（Channel） 28
3.1.3 Selector 选择器 28
3.1.4 缓冲区（Buffer） 29
3.2 详解NIO Buffer类及其属性 29
3.2.1 Buffer类 29
3.2.2 Buffer类的重要属性 29
3.2.3 4个属性的小结 31
3.3 详解NIO Buffer类的重要方法 31
3.3.1 allocate()创建缓冲区 31
3.3.2 put()写入到缓冲区 32
3.3.3 flip()翻转 33
3.3.4 get()从缓冲区读取 34
3.3.5 rewind()倒带 35
3.3.6 mark( )和reset( ) 37
3.3.7 clear( )清空缓冲区 38
3.3.8 使用Buffer类的基本步骤 38
3.4 详解NIO Channel（通道）类 38
3.4.1 Channel（通道）的主要类型 39
3.4.2 FileChannel文件通道 39
3.4.3 使用FileChannel完成文件复制的实践案例 41
3.4.4 SocketChannel套接字通道 42
3.4.5 使用SocketChannel发送文件的实践案例 44
3.4.6 DatagramChannel数据报通道 46
3.4.7 使用DatagramChannel数据包通道发送数据的实践案例 47
3.5 详解NIO Selector选择器 49
3.5.1 选择器以及注册 49
3.5.2 SelectableChannel可选择通道 50
3.5.3 SelectionKey选择键 50
3.5.4 选择器使用流程 50
3.5.5 使用NIO实现Discard服务器的实践案例 52
3.5.6 使用SocketChannel在服务器端接收文件的实践案例 54
3.6 本章小结 57
第4章 鼎鼎大名的Reactor反应器模式 59
4.1 Reactor反应器模式为何如此重要 59
4.1.1 为什么首先学习Reactor反应器模式 59
4.1.2 Reactor反应器模式简介 60
4.1.3 多线程OIO的致命缺陷 60
4.2 单线程Reactor反应器模式 62
4.2.1 什么是单线程Reactor反应器 62
4.2.2 单线程Reactor反应器的参考代码 63
4.2.3 一个Reactor反应器版本的EchoServer实践案例 65
4.2.4 单线程Reactor反应器模式的缺点 67
4.3 多线程的Reactor反应器模式 68
4.3.1 多线程池Reactor反应器演进 68
4.3.2 多线程Reactor 反应器的实践案例 68
4.3.3 多线程Handler处理器的实践案例 70
4.4 Reactor反应器模式小结 72
4.5 本章小结 73
第5章 并发基础中的Future异步回调模式 74
5.1 从泡茶的案例说起 74
5.2 join异步阻塞 75
5.2.1 线程的join合并流程 75
5.2.2 使用join实现异步泡茶喝的实践案例 75
5.2.3 详解join合并方法 77
5.3 FutureTask异步回调之重武器 77
5.3.1 Callable接口 77
5.3.2 初探FutureTask类 78
5.3.3 Future接口 79
5.3.4 再探FutureTask类 79
5.3.5 使用FutureTask类实现异步泡茶喝的实践案例 80
5.4 Guava的异步回调 82
5.4.1 详解FutureCallback 82
5.4.2 详解ListenableFuture 83
5.4.3 ListenableFuture异步任务 84
5.4.4 使用Guava实现泡茶喝的实践案例 84
5.5 Netty的异步回调模式 87
5.5.1 详解GenericFutureListener接口 87
5.5.2 详解Netty的Future接口 88
5.5.3 ChannelFuture的使用 88
5.5.4 Netty的出站和入站异步回调 89
5.6 本章小结 90
第6章 Netty原理与基础 91
6.1 第一个Netty的实践案例DiscardServer 91
6.1.1 创建第一个Netty项目 91
6.1.2 第一个Netty服务器端程序 92
6.1.3 业务处理器NettyDiscardHandler 93
6.1.4 运行NettyDiscardServer 94
6.2 解密Netty中的Reactor反应器模式 95
6.2.1 回顾Reactor反应器模式中IO事件的处理流程 95
6.2.2 Netty中的Channel通道组件 96
6.2.3 Netty中的Reactor 反应器 96
6.2.4 Netty中的Handler处理器 97
6.2.5 Netty的流水线（Pipeline） 98
6.3 详解Bootstrap启动器类 100
6.3.1 父子通道 100
6.3.2 EventLoopGroup线程组 101
6.3.3 Bootstrap的启动流程 101
6.3.4 ChannelOption通道选项 104
6.4 详解Channel通道 105
6.4.1 Channel通道的主要成员和方法 105
6.4.2 EmbeddedChannel嵌入式通道 107
6.5 详解Handler业务处理器 108
6.5.1 ChannelInboundHandler通道入站处理器 109
6.5.2 ChannelOutboundHandler通道出站处理器 110
6.5.3 ChannelInitializer通道初始化处理器 111
6.5.4 ChannelInboundHandler的生命周期的实践案例 112
6.6 详解Pipeline流水线 115
6.6.1 Pipeline入站处理流程 115
6.6.2 Pipeline出站处理流程 116
6.6.3 ChannelHandlerContext上下文 118
6.6.4 截断流水线的处理 118
6.6.5 Handler业务处理器的热拔插 120
6.7 详解ByteBuf缓冲区 122
6.7.1 ByteBuf的优势 122
6.7.2 ByteBuf的逻辑部分 123
6.7.3 ByteBuf的重要属性 123
6.7.4 ByteBuf的三组方法 124
6.7.5 ByteBuf基本使用的实践案例 125
6.7.6 ByteBuf的引用计数 127
6.7.7 ByteBuf的Allocator分配器 128
6.7.8 ByteBuf缓冲区的类型 130
6.7.9 三类ByteBuf使用的实践案例 131
6.7.10 ByteBuf的自动释放 133
6.8 ByteBuf浅层复制的高级使用方式 136
6.8.1 slice切片浅层复制 136
6.8.2 duplicate整体浅层复制 137
6.8.3 浅层复制的问题 138
6.9 EchoServer回显服务器的实践案例 138
6.9.1 NettyEchoServer回显服务器的服务器端 138
6.9.2 共享NettyEchoServerHandler处理器 139
6.9.3 NettyEchoClient客户端代码 140
6.9.4 NettyEchoClientHandler处理器 142
6.10 本章小结 143
第7章 Decoder与Encoder重要组件 144
7.1 Decoder原理与实践 144
7.1.1 ByteToMessageDecoder解码器 145
7.1.2 自定义Byte2IntegerDecoder整数解码器的实践案例 146
7.1.3 ReplayingDecoder解码器 148
7.1.4 整数的分包解码器的实践案例 149
7.1.5 字符串的分包解码器的实践案例 152
7.1.6 MessageToMessageDecoder解码器 156
7.2 开箱即用的Netty内置Decoder 157
7.2.1 LineBasedFrameDecoder解码器 157
7.2.2 DelimiterBasedFrameDecoder解码器 158
7.2.3 LengthFieldBasedFrameDecoder解码器 159
7.2.4 多字段Head-Content协议数据帧解析的实践案例 162
7.3 Encoder原理与实践 164
7.3.1 MessageToByteEncoder编码器 165
7.3.2 MessageToMessageEncoder编码器 166
7.4 解码器和编码器的结合 167
7.4.1 ByteToMessageCodec编解码器 168
7.4.2 CombinedChannelDuplexHandler组合器 169
7.5 本章小结 169
第8章 JSON和ProtoBuf序列化 171
8.1 详解粘包和拆包 172
8.1.1 半包问题的实践案例 172
8.1.2 什么是半包问题 174
8.1.3 半包现象的原理 174
8.2 JSON协议通信 175
8.2.1 JSON序列化的通用类 175
8.2.2 JSON序列化与反序列化的实践案例 176
8.2.3 JSON传输的编码器和解码器之原理 178
8.2.4 JSON传输之服务器端的实践案例 179
8.2.5 JSON传输之客户端的实践案例 180
8.3 Protobuf协议通信 182
8.3.1 一个简单的proto文件的实践案例 182
8.3.2 控制台命令生成POJO和Builder 183
8.3.3 Maven插件生成POJO和Builder 183
8.3.4 消息POJO和Builder的使用之实践案例 184
8.4 Protobuf编解码的实践案例 187
8.4.1 Protobuf编码器和解码器的原理 187
8.4.2 Protobuf传输之服务器端的实践案例 188
8.4.3 Protobuf传输之客户端的实践案例 189
8.5 详解Protobuf协议语法 191
8.5.1 proto的头部声明 191
8.5.2 消息结构体与消息字段 192
8.5.3 字段的数据类型 193
8.5.4 其他的语法规范 194
8.6 本章小结 195
第9章 基于Netty的单体IM系统的开发实践 196
9.1 自定义ProtoBuf编解码器 196
9.1.1 自定义Protobuf编码器 197
9.1.2 自定义Protobuf解码器 198
9.1.3 IM系统中Protobuf消息格式的设计 199
9.2 概述IM的登录流程 202
9.2.1 图解登录/响应流程的9个环节 203
9.2.2 客户端涉及的主要模块 203
9.2.3 服务器端涉及的主要模块 204
9.3 客户端的登录处理的实践案例 204
9.3.1 LoginConsoleCommand和User POJO 205
9.3.2 LoginSender发送器 207
9.3.3 ClientSession客户端会话 209
9.3.4 LoginResponceHandler登录响应处理器 211
9.3.5 客户端流水线的装配 212
9.4 服务器端的登录响应的实践案例 213
9.4.1 服务器流水线的装配 214
9.4.2 LoginRequestHandler登录请求处理器 215
9.4.3 LoginProcesser用户验证逻辑 216
9.4.4 EventLoop线程和业务线程相互隔离 217
9.5 详解ServerSession服务器会话 218
9.5.1 通道的容器属性 219
9.5.2 ServerSession服务器端会话类 220
9.5.3 SessionMap会话管理器 222
9.6 点对点单聊的实践案例 223
9.6.1 简述单聊的端到端流程 223
9.6.2 客户端的ChatConsoleCommand收集聊天内容 224
9.6.3 客户端的CommandController发送POJO 224
9.6.4 服务器端的ChatRedirectHandler消息转发 225
9.6.5 服务器端的ChatRedirectProcesser异步处理 226
9.6.6 客户端的ChatMsgHandler接收POJO 227
9.7 详解心跳检测 228
9.7.1 网络连接的假死现象 228
9.7.2 服务器端的空闲检测 229
9.7.3 客户端的心跳报文 230
9.8 本章小结 232
第10章 ZooKeeper分布式协调 233
10.1 ZooKeeper伪集群安装和配置 233
10.1.1 创建数据目录和日志目录： 234
10.1.2 创建myid文件 234
10.1.3 创建和修改配置文件 235
10.1.4 配置文件示例 237
10.1.5 启动ZooKeeper伪集群 238
10.2 使用ZooKeeper进行分布式存储 239
10.2.1 详解ZooKeeper存储模型 239
10.2.2 zkCli客户端命令清单 240
10.3 ZooKeeper应用开发的实践 241
10.3.1 ZkClient开源客户端介绍 242
10.3.2 Curator开源客户端介绍 242
10.3.3 Curator开发的环境准备 243
10.3.4 Curator客户端实例的创建 244
10.3.5 通过Curator创建ZNode节点 245
10.3.6 在Curator中读取节点 247
10.3.7 在Curator中更新节点 248
10.3.8 在Curator中删除节点 249
10.4 分布式命名服务的实践 251
10.4.1 ID生成器 252
10.4.2 ZooKeeper分布式ID生成器的实践案例 253
10.4.3 集群节点的命名服务之实践案例 254
10.4.4 使用ZK实现SnowFlakeID算法的实践案例 256
10.5 分布式事件监听的重点 261
10.5.1 Watcher标准的事件处理器 261
10.5.2 NodeCache节点缓存的监听 265
10.5.3 PathChildrenCache子节点监听 267
10.5.4 Tree Cache节点树缓存 272
10.6 分布式锁的原理与实践 276
10.6.1 公平锁和可重入锁的原理 276
10.6.2 ZooKeeper分布式锁的原理 277
10.6.3 分布式锁的基本流程 279
10.6.4 加锁的实现 280
10.6.5 释放锁的实现 285
10.6.6 分布式锁的使用 287
10.6.7 Curator的InterProcessMutex可重入锁 288
10.7 本章小结 289
第11章 分布式缓存Redis 290
11.1 Redis入门 290
11.1.1 Redis安装和配置 290
11.1.2 Redis客户端命令 292
11.1.3 Redis Key的命名规范 294
11.2 Redis数据类型 295
11.2.1 String字符串 295
11.2.2 List列表 296
11.2.3 Hash哈希表 297
11.2.4 Set集合 298
11.2.5 Zset有序集合 299
11.3 Jedis基础编程的实践案例 300
11.3.1 Jedis操作String字符串 301
11.3.2 Jedis操作List列表 303
11.3.3 Jedis操作Hash哈希表 304
11.3.4 Jedis操作Set集合 305
11.3.5 Jedis操作Zset有序集合 306
11.4 JedisPool连接池的实践案例 308
11.4.1 JedisPool的配置 308
11.4.2 JedisPool创建和预热 310
11.4.3 JedisPool的使用 312
11.5 使用spring-data-redis完成 CRUD的实践案例 313
11.5.1 CRUD中应用缓存的场景 313
11.5.2 配置spring-redis.xml 315
11.5.3 使用RedisTemplate模板API 316
11.5.4 使用RedisTemplate模板API完成CRUD的实践案例 321
11.5.5 使用RedisCallback回调完成CRUD的实践案例 323
11.6 Spring的Redis缓存注解 325
11.6.1 使用Spring缓存注解完成CRUD的实践案例 325
11.6.2 spring-redis.xml中配置的调整 327
11.6.3 详解@CachePut和 @Cacheable注解 328
11.6.4 详解@CacheEvict注解 329
11.6.5 详解@Caching组合注解 330
11.7 详解SpringEL（SpEL） 331
11.7.1 SpEL运算符 332
11.7.2 缓存注解中的SpringEL表达式 334
11.8 本章小结 336
第12章 亿级高并发IM架构的开发实践 337
12.1 如何支撑亿级流量的高并发IM架构的理论基础 337
12.1.1 亿级流量的系统架构的开发实践 338
12.1.2 高并发架构的技术选型 338
12.1.3 详解IM消息的序列化协议选型 339
12.1.4 详解长连接和短连接 339
12.2 分布式IM的命名服务的实践案例 340
12.2.1 IM节点的POJO类 341
12.2.2 IM节点的ImWorker类 342
12.3 Worker集群的负载均衡之实践案例 345
12.3.1 ImLoadBalance负载均衡器 346
12.3.2 与WebGate的整合 348
12.4 即时通信消息的路由和转发的实践案例 349
12.4.1 IM路由器WorkerRouter 349
12.4.2 IM转发器WorkerReSender 352
12.5 Feign短连接RESTful调用 354
12.5.1 短连接API的接口准备 355
12.5.2 声明远程接口的本地代理 355
12.5.3 远程API的本地调用 356
12.6 分布式的在线用户统计的实践案例 358
12.6.1 Curator的分布式计数器 358
12.6.2 用户上线和下线的统计 360
12.7 本章小结 361
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Netty、Redis、Zookeeper高并发实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Netty 4核心原理与手写RPC框架实战
第1篇 I/O 基础篇
第1章 网络通信原理   2
1.1 网络基础架构    2
1.1.1 C/S 架构    2
1.1.2 C/S 信息传输流程    2
1.2 TCP/IP 五层模型详解    3
1.2.1 物理层    3
1.2.2 数据链路层    4
1.2.3 网络层    5
1.2.4 传输层    10
1.2.5 应用层    15
1.2.6 小结    16
1.3 网络通信实现原理    18
1.4 向浏览器输入 URL 后发生了什么    19
1.5 网络通信之“魂”——Socket   21
第2章 Java I/O 演进之路   23
2.1 I/O 的问世    23
2.1.1 什么是 I/O    23
2.1.2 I/O 交互流程    24
2.2 五种 I/O 通信模型    25
2.2.1 阻塞 I/O 模型    25
2.2.2 非阻塞 I/O 模型    26
2.2.3 多路复用 I/O 模型    27
2.2.4 信号驱动 I/O 模型    28
2.2.5 异步 I/O 模型    28
2.2.6 易混淆的概念澄清    29
2.2.7 各 I/O 模型的对比与总结    32
2.3 从 BIO 到 NIO 的演进    33
2.3.1 面向流与面向缓冲    33
2.3.2 阻塞与非阻塞    33
2.3.3 选择器在 I/O 中的应用    34
2.3.4 NIO 和 BIO 如何影响应用程序的设计    34
2.4 Java AIO 详解    37
2.4.1 AIO 基本原理    37
2.4.2 AIO 初体验    38
第2篇 Netty 初体验
第3章 Netty 与 NIO 之前世今生    44
3.1 Java NIO 三件套    44
3.1.1 缓冲区    44
3.1.2 选择器    54
3.1.3 通道    58
3.2 NIO 源码初探    63
3.3 反应堆    69
3.4 Netty 与 NIO    70
3.4.1 Netty 支持的功能与特性    70
3.4.2 Netty 采用 NIO 而非 AIO 的理由    71
第4章 基于 Netty 手写 Tomcat   72
4.1 环境准备    72
4.1.1 定义 GPServlet 抽象类    72
4.1.2 创建用户业务代码    73
4.1.3 完成 web.properties 配置    74
4.2 基于传统 I/O 手写 Tomcat    74
4.2.1 创建 GPRequest 对象    74
4.2.2 创建 GPResponse 对象    76
4.2.3 创建 GPTomcat 启动类    77
4.3 基于 Netty 重构 Tomcat 实现    80
4.3.1 重构 GPTomcat 逻辑    80
4.3.2 重构 GPRequest 逻辑    83
4.3.3 重构 GPResponse 逻辑    84
4.3.4 运行效果演示    85
第5章 基于 Netty 重构 RPC 框架    87
5.1 RPC 概述    87
5.2 环境预设    88
5.3 代码实战    91
5.3.1 创建 API 模块    91
5.3.2 创建自定义协议    91
5.3.3 实现 Provider 业务逻辑    92
5.3.4 完成 Registry 服务注册    93
5.3.5 实现 Consumer 远程调用    97
5.3.6 Monitor 监控    101
5.4 运行效果演示    102
第3篇 Netty 核心篇
第6章 Netty 高性能之道    104
6.1 背景介绍    104
6.1.1 Netty 惊人的性能数据    104
6.1.2 传统 RPC 调用性能差的“三宗罪”   104
6.1.3 Netty 高性能的三个主题    105
6.2 Netty 高性能之核心法宝    106
6.2.1 异步非阻塞通信    106
6.2.2 零拷贝    108
6.2.3 内存池    112
6.2.4 高效的 Reactor 线程模型    116
6.2.5 无锁化的串行设计理念    118
6.2.6 高效的并发编程    119
6.2.7 对高性能的序列化框架的支持    119
6.2.8 灵活的 TCP 参数配置能力    120
第7章 揭开 Bootstrap 的神秘面纱   124
7.1 客户端 Bootstrap    124
7.1.1 Channel 简介    124
7.1.2 NioSocketChannel 的创建    125
7.1.3 客户端 Channel 的初始化    127
7.1.4 Unsafe 属性的初始化    130
7.1.5 ChannelPipeline 的初始化    131
7.1.6 EventLoop 的初始化    132
7.1.7 将 Channel 注册到 Selector    137
7.1.8 Handler 的添加过程    139
7.1.9 客户端发起连接请求    141
7.2 服务端 ServerBootstrap    144
7.2.1 NioServerSocketChannel 的创建    146
7.2.2 服务端 Channel 的初始化    146
7.2.3 服务端 ChannelPipeline 的初始化    149
7.2.4 将服务端 Channel 注册到 Selector    149
7.2.5 bossGroup 与 workerGroup   149
7.2.6 服务端 Selector 事件轮询    152
7.2.7 Netty 解决 JDK 空轮询 Bug   154
7.2.8 Netty 对 Selector 中 KeySet 的优化    157
7.2.9 Handler 的添加过程    160
第8章 大名鼎鼎的 EventLoop    164
8.1 EventLoopGroup 与 Reactor    164
8.1.1 再谈 Reactor 线程模型    164
8.1.2 EventLoopGroup 与 Reactor 关联    166
8.1.3 EventLoopGroup 的实例化    167
8.2 任务执行者 EventLoop    169
8.2.1 NioEventLoop 的实例化过程    170
8.2.2 EventLoop 与 Channel 的关联    171
8.2.3 EventLoop 的启动    172
第9章 Netty 大动脉 Pipeline    176
9.1 Pipeline 设计原理    176
9.1.1 Channel 与 ChannelPipeline    176
9.1.2 再谈 ChannelPipeline 的初始化    177
9.1.3 ChannelInitializer 的添加   178
9.1.4 自定义 ChannelHandler 的添加过程    181
9.1.5 给 ChannelHandler 命名    184
9.1.6 ChannelHandler 的默认命名规则    185
9.2 Pipeline 的事件传播机制    186
9.2.1 Outbound 事件传播方式    194
9.2.2 Inbound 事件传播方式    196
9.2.3 小结    199
9.3 Handler 的各种“姿势”    200
9.3.1 ChannelHandlerContext    200
9.3.2 Channel 的生命周期    201
9.3.3 ChannelHandler 常用的 API    201
9.3.4 ChannelInboundHandler    202
第10章 异步处理双子星 Future 与 Promise    204
10.1 异步结果 Future    204
10.2 异步执行 Promise    205
第11章 Netty 内存分配 ByteBuf    209
11.1 初识 ByteBuf    209
11.1.1 ByteBuf 的基本结构    209
11.1.2 ByteBuf 的重要 API    210
11.1.3 ByteBuf 的基本分类    213
11.2 ByteBufAllocator 内存管理器    214
11.3 非池化内存分配    218
11.3.1 堆内内存的分配    218
11.3.2 堆外内存的分配    221
11.4 池化内存分配    224
11.4.1 PooledByteBufAllocator 简述    224
11.4.2 DirectArena 内存分配流程    229
11.4.3 内存池的内存规格    231
11.4.4 命中缓存的分配    231
11.4.5 Page 级别的内存分配    241
11.4.6 SubPage 级别的内存分配    254
11.4.7 内存池 ByteBuf 的内存回收    268
11.4.8 SocketChannel 读取 ByteBuf 的过程    273
第12章 Netty 编解码的艺术    281
12.1 什么是拆包、粘包    281
12.1.1 TCP 拆包、粘包    281
12.1.2 粘包问题的解决策略    282
12.2 什么是编解码    282
12.2.1 编解码技术    282
12.2.2 Netty 为什么要提供编解码框架    283
12.3 Netty 中常用的解码器    284
12.3.1 ByteToMessageDecoder 抽象解码器    284
12.3.2 LineBasedFrameDecoder 行解码器    289
12.3.3 DelimiterBasedFrameDecoder 分隔符解码器    296
12.3.4 FixedLengthFrameDecoder 固定长度解码器    302
12.3.5 LengthFieldBasedFrameDecoder 通用解码器    303
12.4 Netty 编码器原理和数据输出    307
12.4.1 WriteAndFlush 事件传播    307
12.4.2 MessageToByteEncoder 抽象编码器    311
12.4.3 写入 Buffer 队列    312
12.4.4 刷新 Buffer 队列    316
12.4.5 数据输出回调    322
12.5 自定义编解码    335
12.5.1 MessageToMessageDecoder 抽象解码器    335
12.5.2 MessageToMessageEncoder 抽象编码器    336
12.5.3 ObjectEncoder 序列化编码器    337
12.5.4 LengthFieldPrepender 通用编码器    338
第4篇 Netty 实战篇
第13章 基于 Netty 手写消息推送系统    342
13.1 环境搭建    342
13.2 多协议通信设计    343
13.2.1 自定义协议规则    343
13.2.2 自定义编解码器    346
13.2.3 对 HTTP 的支持    349
13.2.4 对自定义协议的支持    351
13.2.5 对 WebSocket 协议的支持    351
13.3 服务端逻辑处理    352
13.3.1 多协议串行处理    352
13.3.2 服务端用户中心    354
13.4 客户端控制台处理    359
13.4.1 控制台接入代码    359
13.4.2 控制台消息处理    360
13.5 客户端 Web 页面交互实现    363
13.5.1 Web 页面设计    363
13.5.2 WebSocket 接入    365
13.5.3 登录和退出    366
13.5.4 发送文字信息    367
13.5.5 发送图片表情    368
13.5.6 发送鲜花雨特效    369
第14章 Netty 高性能调优工具类解析    371
14.1 多线程共享 FastThreadLocal    371
14.1.1 FastThreadLocal 的使用和创建    371
14.1.2 FastThreadLocal 的设值    379
14.2 Recycler 对象回收站    381
14.2.1 Recycler 的使用和创建    381
14.2.2 从 Recycler 中获取对象    386
14.2.3 相同线程内的对象回收    389
14.2.4 不同线程间的对象回收    391
14.2.5 获取不同线程间释放的对象    397
第15章 单机百万连接性能调优    405
15.1 模拟 Netty 单机连接瓶颈    405
15.2 单机百万连接调优解决思路    410
15.2.1 突破局部文件句柄限制    410
15.2.2 突破全局文件句柄限制    412
15.3 Netty 应用级别的性能调优    413
15.3.1 Netty 应用级别的性能瓶颈复现    413
15.3.2 Netty 应用级别的性能调优方案    420
第16章 设计模式在 Netty 中的应用    422
16.1 单例模式源码举例    422
16.2 策略模式源码举例    423
16.3 装饰者模式源码举例    424
16.4 观察者模式源码举例    426
16.5 迭代器模式源码举例    427
16.6 责任链模式源码举例    428
16.7 工厂模式源码举例    430
第17章 Netty 经典面试题集锦   432
17.1 基础知识部分    432
17.1.1 TCP 和 UDP 的根本区别    432
17.1.2 TCP 如何保证可靠传输    433
17.1.3 Netty 能解决什么问题    433
17.1.4 选用 Netty 作为通信组件框架的举例    433
17.1.5 Netty 有哪些主要组件，它们之间有什么关联    433
17.2 高级特性部分    434
17.2.1 相较同类框架，Netty 有哪些优势    434
17.2.2 Netty 的高性能体现在哪些方面    434
17.2.3 默认情况下 Netty 起多少线程，何时启动    434
17.2.4 Netty 有几种发送消息的方式    434
17.2.5 Netty 支持哪些心跳类型设置    435
17.2.6 Netty 和 Tomcat 的区别    435
17.2.7 在实际应用中，如何确定要使用哪些编解码器    435
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Netty 4核心原理与手写RPC框架实战
