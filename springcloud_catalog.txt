>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务实战
第1章　基础知识	1
什么是微服务架构	1
-- 与单体系统的区别	1
-- 如何实施微服务	2
为什么选择Spring Cloud	6
Spring Cloud简介	7
版本说明	8
第2章　微服务构建：Spring Boot	11
框架简介	12
快速入门	13
-- 项目构建与解析	13
-- 实现RESTful API	17
配置详解	20
-- 配置文件	20
-- 自定义参数	22
-- 参数引用	22
-- 使用随机数	23
-- 命令行参数	23
-- 多环境配置	24
-- 加载顺序	25
监控与管理	26
-- 初识actuator	27
-- 原生端点	28
小结	38
第3章　服务治理：Spring Cloud Eureka	39
服务治理	39
-- Netflix Eureka	40
--搭建服务注册中心	41
--注册服务提供者	43
--高可用注册中心	46
--服务发现与消费	48
Eureka详解	51
--基础架构	52
--服务治理机制	52
--源码分析	56
配置详解	65
--服务注册类配置	65
--服务实例类配置	67
跨平台支持	71
第4章　客户端负载均衡：Spring Cloud Ribbon	73
客户端负载均衡	73
RestTemplate详解	75
-- GET请求	75
-- POST请求	77
-- PUT请求	79
-- DELETE请求	79
源码分析	80
-- 负载均衡器	91
-- 负载均衡策略	109
配置详解	123
--自动化配置	124
-- Camden版本对RibbonClient配置的优化	125
-- 参数配置	127
-- 与Eureka结合	127
重试机制	128
第5章　服务容错保护：Spring Cloud Hystrix	130
快速入门	131
原理分析	135
-- 工作流程	135
-- 断路器原理	144
-- 依赖隔离	148
使用详解	151
-- 创建请求命令	151
-- 定义服务降级	154
-- 异常处理	157
-- 命令名称、分组以及线程池划分	158
-- 请求缓存	159
-- 请求合并	166
属性详解	172
-- Command属性	174
-- collapser属性	184
-- threadPool属性	185
Hystrix仪表盘	187
Turbine集群监控	192
-- 构建监控聚合服务	192
-- 与消息代理结合	196
第6章　声明式服务调用：Spring Cloud Feign	199
快速入门	200
参数绑定	202
继承特性	205
Ribbon配置	209
全局配置	209
指定服务配置	209
重试机制	210
Hystrix配置	211
全局配置	211
禁用Hystrix	211
指定命令配置	212
服务降级配置	212
其他配置	214
第7章　API网关服务：Spring Cloud Zuul	217
快速入门	219
-- 构建网关	220
-- 请求路由	221
-- 请求过滤	223
路由详解	226
-- 传统路由配置	226
-- 服务路由配置	228
-- 服务路由的默认规则	229
-- 自定义路由映射规则	229
-- 路径匹配	230
-- 路由前缀	233
-- 本地跳转	234
--  Cookie与头信息	235
-- Hystrix和Ribbon支持	236
过滤器详解	238
-- 过滤器	238
-- 请求生命周期	239
-- 核心过滤器	240
-- 异常处理	244
-- 禁用过滤器	256
动态加载	257
-- 动态路由	257
-- 动态过滤器	261
第8章　分布式配置中心：Spring Cloud Config	267
快速入门	267
-- 构建配置中心	268
-- 配置规则详解	269
-- 客户端配置映射	272
服务端详解	274
-- 基础架构	274
-- Git配置仓库	276
-- SVN配置仓库	279
-- 本地仓库	279
-- 本地文件系统	279
-- 健康监测	280
-- 属性覆盖	281
-- 安全保护	281
-- 加密解密	282
-- 高可用配置	286
客户端详解	286
--  URI指定配置中心	287
-- 服务化配置中心	287
-- 失败快速响应与重试	290
-- 获取远程配置	292
-- 动态刷新配置	293
第9章　消息总线：Spring Cloud Bus	295
消息代理	295
RabbitMQ实现消息总线	296
-- 基本概念	297
-- 安装与使用	298
-- 快速入门	302
-- 整合Spring Cloud Bus	306
-- 原理分析	307
-- 指定刷新范围	308
-- 架构优化	309
-- RabbitMQ配置	310
Kafka实现消息总线	312
-- Kafka简介	312
-- 快速入门	313
--整合Spring Cloud Bus	315
-- Kafka配置	318
深入理解	318
-- 源码分析	320
-- 其他消息代理的支持	342
第10章　消息驱动的微服务：Spring Cloud Stream	344
快速入门	344
核心概念	349
-- 绑定器	350
-- 发布-订阅模式	351
-- 消费组	353
-- 消息分区	354
使用详解	355
-- 开启绑定功能	355
-- 绑定消息通道	356
-- 消息生产与消费	360
-- 响应式编程	366
-- 消费组与消息分区	368
-- 消息类型	370
绑定器详解	373
-- 绑定器SPI	373
-- 自动化配置	374
-- 多绑定器配置	374
--  RabbitMQ与Kafka绑定器	376
配置详解	376
-- 基础配置	377
-- 绑定通道配置	377
-- 绑定器配置	379
第11章　分布式服务跟踪：Spring Cloud Sleuth	386
快速入门	386
-- 准备工作	386
-- 实现跟踪	389
跟踪原理	390
抽样收集	392
与Logstash整合	394
与Zipkin整合	397
--  HTTP收集	398
-- 消息中间件收集	402
-- 收集原理	404
-- 数据存储	414
--  API接口	417
附录A　Starter POMs	419
后记	421
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker微服务架构实战
1 微服务架构概述. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.1 单体应用架构存在的问题1
1.2 如何解决单体应用架构存在的问题3
1.3 什么是微服务3
1.4 微服务架构的优点与挑战5
1.4.1 微服务架构的优点5
1.4.2 微服务架构面临的挑战5
1.5 微服务设计原则6
1.6 如何实现微服务架构7
1.6.1 技术选型7
1.6.2 架构图及常用组件8
2 微服务开发框架——Spring Cloud . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2.1 Spring Cloud 简介10
2.2 Spring Cloud 特点10
2.3 Spring Cloud 版本11
2.3.1 版本简介11
2.3.2 子项目一览12
2.3.3 Spring Cloud/Spring Boot 版本兼容性13
3 开始使用Spring Cloud 实战微服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
3.1 Spring Cloud 实战前提14
3.1.1 技术储备14
3.1.2 工具及软件版本15
3.2 服务提供者与服务消费者16
3.3 编写服务提供者16
3.3.1 手动编写项目17
3.3.2 使用Spring Initializr 快速创建Spring Boot 项目21
3.4 编写服务消费者23
3.5 为项目整合Spring Boot Actuator 25
3.6 硬编码有哪些问题27
4 微服务注册与发现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
4.1 服务发现简介29
4.2 Eureka 简介31
4.3 Eureka 原理31
4.4 编写Eureka Server 33
4.5 将微服务注册到Eureka Server 上35
4.6 Eureka Server 的高可用36
4.6.1 将应用注册到Eureka Server 集群上38
4.7 为Eureka Server 添加用户认证39
4.7.1 将微服务注册到需认证的Eureka Server 40
4.8 理解Eureka 的元数据41
4.8.1 改造用户微服务41
4.8.2 改造电影微服务41
4.9 Eureka Server 的REST 端点43
4.9.1 示例45
4.9.2 注销微服务实例49
4.10 Eureka 的自我保护模式51
4.11 多网卡环境下的IP 选择52
4.11.1 忽略指定名称的网卡52
4.11.2 使用正则表达式，指定使用的网络地址52
4.11.3 只使用站点本地地址53
4.11.4 手动指定IP 地址53
4.12 Eureka 的健康检查53
5 使用Ribbon 实现客户端侧负载均衡. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
5.1 Ribbon 简介56
5.2 为服务消费者整合Ribbon 57
5.3 使用Java 代码自定义Ribbon 配置60
5.4 使用属性自定义Ribbon 配置63
5.5 脱离Eureka 使用Ribbon 64
6 使用Feign 实现声明式REST 调用. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
6.1 Feign 简介67
6.2 为服务消费者整合Feign 67
6.3 自定义Feign 配置69
6.4 手动创建Feign 72
6.4.1 修改用户微服务72
6.4.2 修改电影微服务76
6.5 Feign 对继承的支持78
6.6 Feign 对压缩的支持79
6.7 Feign 的日志80
6.8 使用Feign 构造多参数请求82
6.8.1 GET 请求多参数的URL 82
6.8.2 POST 请求包含多个参数83
7 使用Hystrix 实现微服务的容错处理. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
7.1 实现容错的手段85
7.1.1 雪崩效应85
7.1.2 如何容错86
7.2 使用Hystrix 实现容错88
7.2.1 Hystrix 简介88
7.2.2 通用方式整合Hystrix 89
7.2.3 Hystrix 断路器的状态监控与深入理解91
7.2.4 Hystrix 线程隔离策略与传播上下文93
7.2.5 Feign 使用Hystrix 96
7.3 Hystrix 的监控101
7.3.1 Feign 项目的Hystrix 监控102
7.4 使用Hystrix Dashboard 可视化监控数据103
7.5 使用Turbine 聚合监控数据105
7.5.1 Turbine 简介105
7.5.2 使用Turbine 监控多个微服务105
7.5.3 使用消息中间件收集数据108
8 使用Zuul 构建微服务网关. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
8.1 为什么要使用微服务网关113
8.2 Zuul 简介115
8.3 编写Zuul 微服务网关115
8.4 Zuul 的路由端点118
8.5 Zuul 的路由配置详解119
8.6 Zuul 的安全与Header 122
8.6.1 敏感Header 的设置122
8.6.2 忽略Header 123
8.7 使用Zuul 上传文件124
8.7.1 编写文件上传微服务124
8.8 Zuul 的过滤器127
8.8.1 过滤器类型与请求生命周期127
8.8.2 编写Zuul 过滤器128
8.8.3 禁用Zuul 过滤器130
8.9 Zuul 的容错与回退130
8.9.1 为Zuul 添加回退131
8.10 Zuul 的高可用133
8.10.1 Zuul 客户端也注册到了Eureka Server 上133
8.10.2 Zuul 客户端未注册到Eureka Server 上133
8.11 使用Sidecar 整合非JVM 微服务134
8.11.1 编写Node.js 微服务135
8.11.2 编写Sidecar 136
8.11.3 Sidecar 的端点138
8.11.4 Sidecar 与Node.js 微服务分离部署139
8.11.5 Sidecar 原理分析139
9 使用Spring Cloud Config 统一管理微服务配置. . . . . . . . . . . . . . . . . . . . . . . 142
9.1 为什么要统一管理微服务配置142
9.2 Spring Cloud Config 简介143
9.3 编写Config Server 144
9.3.1 Config Server 的端点145
9.4 编写Config Client 147
9.5 Config Server 的Git 仓库配置详解149
9.6 Config Server 的健康状况指示器152
9.7 配置内容的加解密153
9.7.1 安装JCE 153
9.7.2 Config Server 的加解密端点153
9.7.3 对称加密153
9.7.4 存储加密的内容154
9.7.5 非对称加密155
9.8 使用/refresh 端点手动刷新配置155
9.9 使用Spring Cloud Bus 自动刷新配置157
9.9.1 Spring Cloud Bus 简介157
9.9.2 实现自动刷新158
9.9.3 局部刷新159
9.9.4 架构改进159
9.9.5 跟踪总线事件160
9.10 Spring Cloud Config 与Eureka 配合使用161
9.11 Spring Cloud Config 的用户认证162
9.11.1 Config Client 连接需用户认证的Config Server 163
9.12 Config Server 的高可用164
9.12.1 Git 仓库的高可用164
9.12.2 RabbitMQ 的高可用164
9.12.3 Config Server 自身的高可用165
10 使用Spring Cloud Sleuth 实现微服务跟踪. . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
10.1 为什么要实现微服务跟踪167
10.2 Spring Cloud Sleuth 简介168
10.3 整合Spring Cloud Sleuth 170
10.4 Spring Cloud Sleuth 与ELK 配合使用172
10.5 Spring Cloud Sleuth 与Zipkin 配合使用176
10.5.1 Zipkin 简介176
10.5.2 编写Zipkin Server 176
10.5.3 微服务整合Zipkin 178
10.5.4 使用消息中间件收集数据181
10.5.5 存储跟踪数据183
11 Spring Cloud 常见问题与总结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186
11.1 Eureka 常见问题186
11.1.1 Eureka 注册服务慢186
11.1.2 已停止的微服务节点注销慢或不注销187
11.1.3 如何自定义微服务的Instance ID 188
11.1.4 Eureka 的UNKNOWN 问题总结与解决189
11.2 Hystrix/Feign 整合Hystrix 后首次请求失败190
11.2.1 原因分析191
11.2.2 解决方案191
11.3 Turbine 聚合的数据不完整191
11.3.1 解决方案192
11.4 Spring Cloud 各组件配置属性193
11.4.1 Spring Cloud 的配置193
11.4.2 原生配置193
11.5 Spring Cloud 定位问题思路总结194
12 Docker 入门. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
12.1 Docker 简介197
12.2 Docker 的架构197
12.3 安装Docker 199
12.3.1 系统要求199
12.3.2 移除非官方软件包199
12.3.3 设置Yum 源199
12.3.4 安装Dokcer 200
12.3.5 卸载Docker 201
12.4 配置镜像加速器201
12.5 Docker 常用命令202
12.5.1 Docker 镜像常用命令202
12.5.2 Docker 容器常用命令204
13 将微服务运行在Docker 上. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
13.1 使用Dockerfile 构建Docker 镜像209
13.1.1 Dockerfile 常用指令210
13.1.2 使用Dockerfile 构建镜像215
13.2 使用Docker Registry 管理Docker 镜像217
13.2.1 使用Docker Hub 管理镜像217
13.2.2 使用私有仓库管理镜像219
13.3 使用Maven 插件构建Docker 镜像220
13.3.1 快速入门221
13.3.2 插件读取Dockerfile 进行构建222
13.3.3 将插件绑定在某个phase 执行223
13.3.4 推送镜像224
13.4 常见问题与总结226
14 使用Docker Compose 编排微服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227
14.1 Docker Compose 简介227
14.2 安装Docker Compose 227
14.2.1 安装Compose 228
14.2.2 安装Compose 命令补全工具228
14.3 Docker Compose 快速入门229
14.3.1 基本步骤229
14.3.2 入门示例229
14.3.3 工程、服务、容器230
14.4 docker-compose.yml 常用命令230
14.4.1 build 230
14.4.2 command 231
14.4.3 dns 231
14.4.4 dns_search 231
14.4.5 environment 231
14.4.6 env_file 232
14.4.7 expose 232
14.4.8 external_links 232
14.4.9 image 232
14.4.10 links 232
14.4.11 networks 233
14.4.12 network_mode 233
14.4.13 ports 233
14.4.14 volumes 233
14.4.15 volumes_from 234
14.5 docker-compose 常用命令234
14.5.1 build 234
14.5.2 help 235
14.5.3 kill 235
14.5.4 logs 235
14.5.5 port 235
14.5.6 ps 235
14.5.7 pull 235
14.5.8 rm 236
14.5.9 run 236
14.5.10 scale 236
14.5.11 start 236
14.5.12 stop 236
14.5.13 up 236
14.6 Docker Compose 网络设置237
14.6.1 基本概念237
14.6.2 更新容器237
14.6.3 links 238
14.6.4 指定自定义网络238
14.6.5 配置默认网络239
14.6.6 使用已存在的网络239
14.7 综合实战：使用Docker Comose 编排Spring Cloud 微服务240
14.7.1 编排Spring Cloud 微服务240
14.7.2 编排高可用的Eureka Server 243
14.7.3 编排高可用Spring Cloud 微服务集群及动态伸缩245
14.8 常见问题与总结247
后记. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker微服务架构实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud 微服务架构开发实战
内容简介
前言
第1章 微服务概述
1.1 传统软件行业面临的挑战
1.2 常见分布式系统架构
1.3 单块架构如何进化为微服务架构
1.4 微服务架构的设计原则
1.5 如何来设计微服务系统
第2章 微服务的基石——Spring Boot
2.1 Spring Boot 简介
2.2 开启第一个 Spring Boot 项目
2.3 Hello World
2.4 如何搭建开发环境
2.5 Gradle 与 Maven 的抉择
第3章 Spring Boot 的高级主题
3.1 构建 RESTful 服务
3.2 Spring Boot 的配置详解
3.3 内嵌 Servlet 容器
3.4 实现安全机制
3.5 允许跨域访问
3.6 消息通信
3.7 数据持久化
3.8 实现热插拔（hot swapping）
第4章 微服务的测试
4.1 测试概述
4.2 测试的类型和范围
4.3 如何进行微服务的测试
第5章 微服务的协调者——Spring Cloud
5.1 Spring Cloud 简介
5.2 Spring Cloud 入门配置
5.3 Spring Cloud 的子项目介绍
第6章 服务拆分与业务建模
6.1 从一个天气预报系统讲起
6.2 使用Redis提升应用的并发访问能力
6.3 实现天气数据的同步
6.4 给天气预报一个“面子”
6.5 如何进行微服务的拆分
6.6 领域驱动设计与业务建模
第7章 天气预报系统的微服务架构设计与实现
7.1 天气预报系统的架构设计
7.2 天气数据采集微服务的实现
7.3 天气数据API微服务的实现
7.4 天气预报微服务的实现
7.5 城市数据API微服务的实现
第8章 微服务的注册与发现
8.1 服务发现的意义
8.2 如何集成 Eureka Server
8.3 如何集成 Eureka Client
8.4 实现服务的注册与发现
第9章 微服务的消费
9.1 微服务的消费模式
9.2 常见微服务的消费者
9.3 使用 Feign 实现服务的消费者
9.4 实现服务的负载均衡及高可用
第10章 API 网关
10.1 API 网关的意义
10.2 常见 API 网关的实现方式
10.3 如何集成Zuul
10.4 实现 API 网关
第11章 微服务的部署与发布
11.1 部署微服务将面临的挑战
11.2 持续交付与持续部署微服务
11.3 基于容器的部署与发布微服务
11.4 使用 Docker 来构建、运行、发布微服务
第12章 微服务的日志与监控
12.1 微服务日志管理将面临的挑战
12.2 日志集中化的意义
12.3 常见日志集中化的实现方式
12.4 Elastic Stack 实现日志集中化
第13章 微服务的集中化配置
13.1 为什么需要集中化配置
13.2 使用 Config 实现的配置中心
第14章 微服务的高级主题——自动扩展
14.1 什么是自动扩展
14.2 自动扩展的意义
14.3 自动扩展的常见模式
14.4 如何实现微服务的自动扩展
第15章 微服务的高级主题——熔断机制
15.1 什么是服务的熔断机制
15.2 熔断的意义
15.3 熔断与降级的区别
15.4 如何集成 Hystrix
15.5 实现微服务的熔断机制
第16章 微服务的高级主题——分布式消息总线
16.1 什么是消息总线
16.2 Spring Cloud Bus 设计原理
16.3 如何集成 Bus
16.4 实现配置信息的自动更新
附录A：本书所涉及到的技术及相关版本
参考资料
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud 微服务架构开发实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务：入门、实战与进阶
Contents 目　　录
赞誉
前言
第一部分　准备篇
第1章　Spring Cloud 与微服务概述  2
1.1　传统的单体应用  2
1.1.1　改进单体应用的架构  2
1.1.2　向微服务靠拢  3
1.2　什么是微服务  4
1.2.1　使用微服务架构的优势和劣势  4
1.2.2　重构前的准备工作  5
1.3　什么是Spring Cloud  5
1.3.1　Spring Cloud模块介绍  6
1.3.2　Spring Cloud版本介绍  6
1.4　本章小结  7
第2章　实战前的准备工作  8
2.1　开发环境的准备  8
2.2　Spring Boot入门  9
2.2.1　Spring Boot简介  9
2.2.2　搭建Spring Boot项目  9
2.2.3　编写第一个REST接口  11
2.2.4　读取配置文件  11
2.2.5　profiles多环境配置  13
2.2.6　热部署  13
2.2.7　actuator监控  15
2.2.8　自定义actuator端点  17
2.2.9　统一异常处理  18
2.2.10　异步执行  20
2.2.11　随机端口  22
2.2.12　编译打包  24
2.3　Spring Boot Starter自定义  25
2.3.1　Spring Boot Starter项目创建  25
2.3.2　自动创建客户端  26
2.3.3　使用Starter  27
2.3.4　使用注解开启Starter自动构建  27
2.3.5　使用配置开启Starter自动构建  28
2.3.6　配置Starter内容提示  29
2.4　本章小结  29
第二部分　基础篇
第3章　Eureka 注册中心  32
3.1　Eureka  32
3.2　使用 Eureka 编写注册中心服务  33
3.3　编写服务提供者  35
3.3.1　创建项目注册到Eureka  35
3.3.2　编写提供接口  36
3.4　编写服务消费者  37
3.4.1　直接调用接口  37
3.4.2　通过Eureka来消费接口  38
3.5　开启 Eureka 认证  38
3.6　Eureka 高可用搭建  39
3.6.1　高可用原理  39
3.6.2　搭建步骤  40
3.7　常用配置讲解  41
3.7.1　关闭自我保护  41
3.7.2　自定义Eureka的
InstanceID  41
3.7.3　自定义实例跳转链接  42
3.7.4　快速移除已经失效的服务信息  43
3.8　扩展使用  44
3.8.1　Eureka REST API  44
3.8.2　元数据使用  46
3.8.3　EurekaClient使用  47
3.8.4　健康检查  49
3.8.5　服务上下线监控  50
3.9　本章小结  51
第4章　客户端负载均衡 Ribbon  52
4.1　Ribbon  52
4.1.1　Ribbon模块  52
4.1.2　Ribbon 使用  53
4.2　RestTemplate 结合 Ribbon 使用  54
4.2.1　使用 RestTemplate 与整合 Ribbon  54
4.2.2　RestTemplate 负载均衡示例  57
4.2.3　@LoadBalanced 注解原理  58
4.2.4　Ribbon API 使用  62
4.2.5　Ribbon 饥饿加载  63
4.3　负载均衡策略介绍  64
4.4　自定义负载策略  65
4.5　配置详解  66
4.5.1　常用配置  66
4.5.2　代码配置 Ribbon  67
4.5.3　配置文件方式配置Ribbon  67
4.6　重试机制  68
4.7　本章小结  69
第5章　声明式REST客户端Feign  70
5.1　使用 Feign 调用服务接口  70
5.1.1　在Spring Cloud中集成Feign  71
5.1.2　使用Feign调用接口  71
5.2　自定义 Feign的配置  72
5.2.1　日志配置  72
5.2.2　契约配置  73
5.2.3　Basic认证配置  74
5.2.4　超时时间配置  75
5.2.5　客户端组件配置  75
5.2.6　GZIP压缩配置  76
5.2.7　编码器解码器配置  77
5.2.8　使用配置自定义Feign的配置  78
5.2.9　继承特性  78
5.2.10　多参数请求构造  80
5.3　脱离 Spring Cloud 使用 Feign  80
5.3.1　原生注解方式  81
5.3.2　构建Feign对象  82
5.3.3　其他配置  83
5.4　本章小结  83
第6章　Hystrix 服务容错处理  84
6.1　Hystrix  84
6.1.1　Hystrix的简单使用  84
6.1.2　回退支持  85
6.1.3　信号量策略配置  86
6.1.4　线程隔离策略配置  86
6.1.5　结果缓存  87
6.1.6　缓存清除  88
6.1.7　合并请求  89
6.2　在 Spring Cloud 中使用Hystrix  91
6.2.1　简单使用  91
6.2.2　配置详解  92
6.2.3　Feign整合Hystrix服务容错  95
6.2.4　Feign中禁用Hystrix  97
6.3　Hystrix 监控  97
6.4　整合 Dashboard 查看监控数据  98
6.5　Turbine 聚合集群数据  100
6.5.1　Turbine使用  100
6.5.2　context-path导致监控失败  101
6.6　本章小结  102
第7章　API网关  103
7.1　Zuul 简介  103
7.2　使用 Zuul 构建微服务网关  104
7.2.1　简单使用  104
7.2.2　集成Eureka  105
7.3　Zuul 路由配置  105
7.4　Zuul过滤器讲解  106
7.4.1　过滤器类型  106
7.4.2　请求生命周期  107
7.4.3　使用过滤器  108
7.4.4　过滤器禁用  109
7.4.5　过滤器中传递数据  110
7.4.6　过滤器拦截请求  111
7.4.7　过滤器中异常处理  113
7.5　Zuul 容错和回退  115
7.5.1　容错机制  115
7.5.2　回退机制  116
7.6　Zuul使用小经验  118
7.6.1　/routes 端点  118
7.6.2　/filters 端点  118
7.6.3　文件上传  119
7.6.4　请求响应信息输出  121
7.6.5　Zuul自带的Debug功能  124
7.7　Zuul 高可用  126
7.8　本章小结  127
第三部分　实战篇
第8章　API 网关之Spring Cloud Gateway  130
8.1　Spring Cloud Gateway介绍  130
8.2　Spring Cloud Gateway工作原理  131
8.3　Spring Cloud Gateway快速上手  131
8.3.1　创建Gateway项目  131
8.3.2　路由转发示例  132
8.3.3　整合Eureka路由  133
8.3.4　整合Eureka的默认路由  133
8.4　Spring Cloud Gateway路由断言工厂  134
8.4.1　路由断言工厂使用  134
8.4.2　自定义路由断言工厂  136
8.5　Spring Cloud Gateway过滤器工厂  137
8.5.1　Spring Cloud Gateway过滤器工厂使用  137
8.5.2　自定义Spring Cloud Gateway过滤器工厂  138
8.6　全局过滤器  140
8.7　实战案例  143
8.7.1　限流实战  143
8.7.2　熔断回退实战  145
8.7.3　跨域实战  145
8.7.4　统一异常处理  147
8.7.5　重试机制  150
8.8　本章小结  151
第9章　自研分布式配置管理  152
9.1　自研配置管理框架 Smconf 简介  152
9.2　Smconf 工作原理  153
9.3　Smconf 部署  154
9.3.1　Mongodb 安装  154
9.3.2　Zookeeper 安装  155
9.3.3　Smconf Server 部署  156
9.4　项目中集成 Smconf  157
9.4.1　集成Smconf  157
9.4.2　使用Smconf  158
9.4.3　配置更新回调  159
9.5　Smconf 详细使用  160
9.5.1　源码编译问题  160
9.5.2　后台账号管理  160
9.5.3　REST API  161
9.6　Smconf 源码解析  163
9.6.1　Client启动  163
9.6.2　启动加载配置  165
9.6.3　配置修改推送原理  166
9.7　本章小结  167
第10章　分布式配置中心Apollo  168
10.1　Apollo简介  168
10.2　Apollo的核心功能点  168
10.3　Apollo核心概念  170
10.4　Apollo本地部署  171
10.5　Apollo Portal管理后台使用  172
10.6　Java中使用Apollo  174
10.6.1　普通Java项目中使用  174
10.6.2　Spring Boot中使用  177
10.7　Apollo的架构设计  179
10.7.1　Apollo架构设计介绍  179
10.7.2　Apollo服务端设计  181
10.7.3　Apollo客户端设计  188
10.7.4　Apollo高可用设计  195
10.8　本章小结  196
第11章　Sleuth 服务跟踪  197
11.1　Spring Cloud 集成 Sleuth  197
11.2　整合 Logstash  198
11.2.1　ELK 简介  198
11.2.2　输出 JSON 格式日志  198
11.3　整合 Zipkin  200
11.3.1　Zipkin 数据收集服务  200
11.3.2　项目集成 Zipkin 发送调用链数据  201
11.3.3　抽样采集数据  203
11.3.4　异步任务线程池定义  203
11.3.5　TracingFilter  204
11.3.6　监控本地方法  205
11.3.7　过滤不想跟踪的请求  206
11.3.8　用 RabbitMq 代替 Http 发送调用链数据  206
11.3.9　用 Elasticsearch 存储调用链数据  207
11.4　本章小结  208
第12章　微服务之间调用的安全认证  209
12.1　什么是 JWT  209
12.2　创建统一的认证服务  210
12.2.1　表结构  210
12.2.2　JWT工具类封装  210
12.2.3　认证接口  212
12.3　服务提供方进行调用认证  212
12.4　服务消费方申请 Token  214
12.5　Feign 调用前统一申请 Token 传递到调用的服务中  216
12.6　RestTemplate调用前统一申请 Token 传递到调用的服务中  217
12.7　Zuul 中传递 Token 到路由的服务中  218
12.8　本章小结  219
第13章　Spring Boot Admin  220
13.1　Spring Boot Admin 的使用方法  220
13.1.1　创建 Spring Boot Admin项目  220
13.1.2　将服务注册到 Spring Boot Admin  221
13.1.3　监控内容介绍  223
13.1.4　如何在 Admin 中查看各个服务的日志  225
13.2　开启认证  226
13.3　集成 Eureka  227
13.4　监控服务  228
13.4.1　邮件警报  228
13.4.2　自定义钉钉警报  229
13.5　本章小结  232
第14章　服务的API文档管理  233
14.1　Swagger 简介  233
14.2　集成 Swagger 管理 API 文档  234
14.2.1　项目中集成 Swagger  234
14.2.2　使用 Swagger 生成文档  234
14.2.3　在线测试接口  235
14.3　Swagger 注解  236
14.4　Eureka 控制台快速查看 Swagger 文档  240
14.5　请求认证  240
14.6　Zuul中聚合多个服务Swagger  241
14.7　本章小结  242
第四部分　高级篇
第15章　API 网关扩展  244
15.1　用户认证  244
15.1.1　动态管理不需要拦截的 API 请求  244
15.1.2　创建认证的用户服务  246
15.1.3　路由之前的认证  247
15.1.4　向下游微服务中传递认证之后的用户信息  248
15.1.5　内部服务间的用户信息传递  248
15.2　服务限流  250
15.2.1　限流算法  250
15.2.2　单节点限流  251
15.2.3　集群限流  255
15.2.4　具体服务限流  258
15.2.5　具体接口限流  258
15.3　服务降级  262
15.4　灰度发布  264
15.4.1　原理讲解  264
15.4.2　根据用户做灰度发布  265
15.4.3　根据 IP 做灰度发布  268
15.5　本章小结  268
第16章　微服务之缓存  269
16.1　Guava Cache 本地缓存  269
16.1.1　Guava Cache 简介  269
16.1.2　代码示例  270
16.1.3　回收策略  270
16.2　Redis 缓存  271
16.2.1　用 Redistemplate 操作 Redis  271
16.2.2　用 Repository 操作 Redis  272
16.2.3　Spring Cache 缓存数据  274
16.2.4　缓存异常处理  278
16.2.5　自定义缓存工具类  279
16.3　防止缓存穿透方案  282
16.3.1　什么是缓存穿透  282
16.3.2　缓存穿透的危害  282
16.3.3　解决方案  282
16.3.4　布隆过滤器介绍  283
16.3.5　代码示例  283
16.4　防止缓存雪崩方案  284
16.4.1　什么是缓存雪崩  284
16.4.2　缓存雪崩的危害  284
16.4.3　解决方案  284
16.4.4　代码示例  285
16.4.5　分布式锁方式  285
16.5　本章小结  286
第17章　微服务之存储  287
17.1　存储选型  287
17.2　Mongodb  288
17.2.1　集成 Spring Data Mongodb  288
17.2.2　添加数据操作  288
17.2.3　索引使用  290
17.2.4　修改数据操作  291
17.2.5　删除数据操作  293
17.2.6　查询数据操作  294
17.2.7　GridFS 操作  295
17.2.8　用 Repository方式操作数据  296
17.2.9　自增 ID 实现  300
17.2.10　批量更新扩展  303
17.3　Mysql  304
17.3.1　集成 Spring Jdbc-Template  304
17.3.2　JdbcTemplate 代码示例  305
17.3.3　封装 JdbcTemplate 操作 Mysql 更简单  305
17.3.4　扩展 JdbcTemplate 使用方式  306
17.3.5　常见问题  310
17.4　Elasticsearch  312
17.4.1　集成 Spring Data Elasticsearch  312
17.4.2　Repository 示例  312
17.4.3　ElasticsearchTemplate 示例  315
17.4.4　索引构建方式  318
17.5　本章小结  319
第18章　微服务之分布式事务解决方案  320
18.1　两阶段型  320
18.2　TCC 补偿型  321
18.3　最终一致性  321
18.3.1　原理讲解  321
18.3.2　创建可靠性消息服务  323
18.3.3　消息存储表设计  324
18.3.4　提供服务接口  325
18.3.5　创建消息发送系统  329
18.3.6　消费消息逻辑  332
18.3.7　消息管理系统  335
18.4　最大努力通知型事务  335
18.5　本章小结  335
第19章　分布式任务调度  336
19.1　Elastic-Job  336
19.1.1　Elastic-Job 介绍  336
19.1.2　任务调度目前存在的问题  336
19.1.3　为什么选择 Elastic-Job  337
19.2　快速集成  338
19.3　任务使用  339
19.3.1　简单任务  339
19.3.2　数据流任务  340
19.3.3　脚本任务  340
19.4　配置参数讲解  341
19.4.1　注册中心配置  341
19.4.2　作业配置  342
19.4.3　dataflow 独有配置  343
19.4.4　script独有配置  343
19.5　多节点并行调度  344
19.5.1　分片概念  344
19.5.2　任务节点分片策略  344
19.5.3　业务数据分片处理  345
19.6　事件追踪  347
19.7　扩展功能  349
19.7.1　自定义监听器  349
19.7.2　定义异常处理  349
19.8　运维平台  350
19.8.1　功能列表  350
19.8.2　部署运维平台  351
19.8.3　运维平台使用  351
19.9　使用经验分享  355
19.9.1　任务的划分和监控  355
19.9.2　任务的扩展性和节点数量  355
19.9.3　任务的重复执行  355
19.9.4　overwrite 覆盖问题  356
19.9.5　流水式任务  356
19.10　本章小结  357
第20章　分库分表解决方案  358
20.1　Sharding-JDBC  358
20.1.1　介绍  358
20.1.2　功能列表  359
20.1.3　相关概念  359
20.2　快速集成  360
20.3　读写分离实战  362
20.3.1　准备数据  362
20.3.2　配置读写分离  363
20.3.3　验证读从库  363
20.3.4　验证写主库  365
20.3.5　Hint 强制路由主库  366
20.4　分库分表实战  367
20.4.1　常用分片算法  367
20.4.2　使用分片算法  368
20.4.3　不分库只分表实战  368
20.4.4　既分库又分表实战  372
20.5　分布式主键  375
20.6　本章小结  377
第21章　最佳生产实践经验  378
21.1　开发环境和测试环境共用Eureka  378
21.2　Swagger和Actuator访问进行权限控制  379
21.3　Spring Boot Admin监控被保护的服务  380
21.4　Apollo配置中心简化版搭建分享  380
21.5　Apollo使用小经验  382
21.5.1　公共配置  382
21.5.2　账号权限  383
21.5.3　环境配置和项目配置  385
21.6　Apollo动态调整日志级别  385
21.7　Apollo存储加密  387
21.8　扩展Apollo支持存储加解密  390
21.9　Apollo结合Zuul实现动态路由  391
21.10　Apollo整合Archaius  393
21.11　Elastic-Job的Spring-Boot-Starter封装  394
21.12　Spring Boot中Mongodb多数据源封装  396
21.13　Zuul中对API进行加解密  398
21.14　本章小结  400
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务：入门、实战与进阶
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker微服务架构实战（第2版）
1 微服务架构概述  1
1.1 单体应用架构存在的问题  . 1
1.2 如何解决单体应用架构存在的问题  3
1.3 什么是微服务  . 3
1.4 微服务架构的优点与挑战  . 4
1.4.1 微服务架构的优点  5
1.4.2 微服务架构面临的挑战  5
1.5 微服务设计原则  6
1.6 如何实现微服务架构  7
1.6.1 技术选型  7
1.6.2 架构图及常用组件  8
2 微服务开发框架——Spring Cloud  . 9
2.1 Spring Cloud 简介  . 9
2.2 Spring Cloud 特点  . 10
2.3 Spring Cloud 版本  . 10
2.3.1 版本简介  10
2.3.2 子项目一览  . 12
2.3.3 Spring Cloud/Spring Boot 版本兼容性  . 13
3 开始使用Spring Cloud 实战微服务  14
3.1 Spring Cloud 实战前提  14
3.1.1 技术储备  14
3.1.2 工具及软件版本  . 15
3.2 服务提供者与服务消费者  . 16
3.3 编写服务提供者  16
3.3.1 手动编写项目  . 17
3.3.2 使用Spring Initializr 快速创建Spring Boot 项目  . 21
3.4 编写服务消费者  23
3.5 为项目整合Spring Boot Actuator  . 25
3.6 硬编码有哪些问题  28
4 微服务注册与发现  30
4.1 服务发现简介  . 30
4.2 Eureka 简介  . 32
4.3 Eureka 原理  . 32
4.4 编写Eureka Server  34
4.5 将微服务注册到Eureka Server 上  36
4.6 Eureka Server 的高可用  38
4.6.1 编写高可用Eureka Server  38
4.6.2 将应用注册到Eureka Server 集群上  41
4.7 用户认证  . 41
4.7.1 为Eureka Server 添加用户认证  . 41
4.7.2 将微服务注册到需认证的Eureka Server  43
4.8 Eureka 的元数据  43
4.8.1 改造用户微服务  . 43
4.8.2 改造电影微服务  . 44
4.9 Eureka Server 的REST 端点  46
4.9.1 示例  47
4.9.2 注销微服务实例  . 52
4.10 Eureka 的自我保护模式  . 53
4.11 多网卡环境下的IP 选择  . 54
4.12 Eureka 的健康检查  56
4.13 排除Jersey 依赖  . 57
5 使用Ribbon 实现客户端侧负载均衡  . 59
5.1 Ribbon 简介  59
5.2 为服务消费者整合Ribbon  . 60
5.3 Ribbon 配置自定义  63
5.3.1 使用Java 代码自定义Ribbon 配置  63
5.3.2 使用属性自定义Ribbon 配置  67
5.4 脱离Eureka 使用Ribbon  68
5.5 饥饿加载  . 70
6 使用Feign 实现声明式REST 调用  . 72
6.1 Feign 简介  73
6.2 为服务消费者整合Feign  73
6.3 自定义Feign 配置  . 75
6.3.1 使用Java 代码自定义Feign 配置  . 75
6.3.2 使用属性自定义Feign 配置  79
6.4 手动创建Feign  80
6.4.1 修改用户微服务  . 80
6.4.2 修改电影微服务  . 84
6.5 Feign 对继承的支持  . 86
6.6 Feign 对压缩的支持  . 87
6.7 Feign 的日志  87
6.7.1 编码方式设置日志级别  88
6.7.2 使用属性配置日志级别  89
6.8 使用Feign 构造多参数请求  90
6.8.1 GET 请求多参数的URL  . 90
6.8.2 POST 请求包含多个参数  91
6.9 使用Feign 上传文件  92
7 使用Hystrix 实现微服务的容错处理  . 94
7.1 实现容错的手段  94
7.1.1 雪崩效应  95
7.1.2 如何容错  95
7.2 使用Hystrix 实现容错  . 97
7.2.1 Hystrix 简介  . 97
7.2.2 通用方式整合Hystrix  98
7.2.3 Hystrix 断路器的状态监控与深入理解  102
7.2.4 Hystrix 线程隔离策略与传播上下文  103
7.2.5 Feign 使用Hystrix  . 106
7.3 Hystrix 的监控  112
7.4 使用Hystrix Dashboard 可视化监控数据  . 113
7.5 使用Turbine 聚合监控数据  116
7.5.1 Turbine 简介  116
7.5.2 使用Turbine 监控多个微服务  117
7.5.3 使用消息中间件收集数据  119
8 使用Zuul 构建微服务网关  124
8.1 为什么要使用微服务网关  . 124
8.2 Zuul 简介  . 126
8.3 编写Zuul 微服务网关  . 126
8.4 管理端点  . 129
8.4.1 routes 端点  129
8.4.2 filters 端点  131
8.5 路由配置详解  . 132
8.6 Zuul 的安全与Header  . 136
8.6.1 敏感Header 的设置  . 136
8.6.2 忽略Header  . 136
8.7 使用Zuul 上传文件  . 137
8.8 Zuul 的过滤器  140
8.8.1 过滤器类型与请求生命周期  . 140
8.8.2 内置过滤器详解  . 141
8.8.3 编写Zuul 过滤器  144
8.8.4 禁用Zuul 过滤器  146
8.9 Zuul 的容错与回退  146
8.10 饥饿加载  . 149
8.11 Query String 编码  . 150
8.12 Hystrix 隔离策略与线程池  . 150
8.12.1 隔离策略  150
8.12.2 线程池配置  . 151
8.13 Zuul 的高可用  152
8.13.1 Zuul 客户端也注册到了Eureka Server 上  . 152
8.13.2 Zuul 客户端未注册到Eureka Server 上  152
8.14 使用Sidecar 整合非JVM 微服务  . 154
8.14.1 编写Node.js 微服务  . 154
8.14.2 编写Sidecar  . 155
8.14.3 Sidecar 的端点  . 157
8.14.4 Sidecar 与Node.js 微服务分离部署  . 158
8.14.5 Sidecar 原理分析  158
8.15 使用Zuul 聚合微服务  . 160
9 使用Spring Cloud Config 统一管理微服务配置  166
9.1 为什么要统一管理微服务配置  . 166
9.2 Spring Cloud Config 简介  167
9.3 编写Config Server  . 168
9.4 编写Config Client  . 171
9.5 Config Server 的Git 仓库配置详解  . 173
9.5.1 占位符支持  . 173
9.5.2 模式匹配  174
9.5.3 搜索目录  174
9.5.4 启动时加载配置文件  175
9.6 Config Server 的健康状况指示器  . 176
9.7 配置内容的加解密  177
9.7.1 安装JCE  177
9.7.2 Config Server 的加解密端点  177
9.7.3 对称加密  177
9.7.4 存储加密的内容  . 178
9.7.5 非对称加密  . 179
9.8 使用/refresh 端点手动刷新配置  180
9.9 使用Spring Cloud Bus 自动刷新配置  . 181
9.9.1 Spring Cloud Bus 简介  181
9.9.2 实现自动刷新  . 182
9.9.3 局部刷新  183
9.9.4 架构改进  184
9.9.5 跟踪总线事件  . 184
9.10 Spring Cloud Config 与Eureka 配合使用  186
9.11 Spring Cloud Config 的用户认证  . 187
9.12 Config Server 的高可用  188
9.12.1 Git 仓库的高可用  188
9.12.2 RabbitMQ 的高可用  . 189
9.12.3 Config Server 自身的高可用  189
10 使用Spring Cloud Sleuth 实现微服务跟踪  . 191
10.1 为什么要实现微服务跟踪  . 191
10.2 Spring Cloud Sleuth 简介  . 192
10.3 整合Spring Cloud Sleuth  . 194
10.4 Spring Cloud Sleuth 与ELK 配合使用  . 196
10.5 Spring Cloud Sleuth 与Zipkin 配合使用  . 200
10.5.1 Zipkin 简介  . 200
10.5.2 编写Zipkin Server  . 200
10.5.3 微服务整合Zipkin  . 202
10.5.4 Zipkin 与Eureka 配合使用  . 205
10.5.5 使用消息中间件收集数据  206
10.5.6 使用Elasticsearch 存储跟踪数据  209
10.5.7 依赖关系图  . 211
11 Spring Cloud 常见问题与总结  . 213
11.1 Eureka 常见问题  213
11.1.1 Eureka 注册服务慢  213
11.1.2 已停止的微服务节点注销慢或不注销  214
11.1.3 如何自定义微服务的Instance ID  . 215
11.1.4 Eureka 的UNKNOWN 问题总结与解决  217
11.2 整合Hystrix 后首次请求失败  218
11.2.1 原因分析  218
11.2.2 解决方案  218
11.3 Turbine 聚合的数据不完整  219
11.4 Spring Cloud 各组件超时  220
11.4.1 RestTemplate 的超时  . 221
11.4.2 Ribbon 的超时  . 221
11.4.3 Feign 的超时  221
11.4.4 Hystrix 的超时  222
11.4.5 Zuul 的超时  . 222
11.5 Spring Cloud 各组件重试  223
11.5.1 重试步骤  224
11.5.2 基于HTTP 响应码重试  224
11.5.3 关闭重试  224
11.5.4 注意点  224
11.6 Spring Cloud 各组件调优  225
11.6.1 Tomcat 参数  . 225
11.6.2 Hystrix 参数  . 225
11.6.3 Feign 参数  226
11.6.4 Zuul 参数  . 226
11.7 Spring Cloud 各组件配置属性  228
11.7.1 Spring Boot 的配置  228
11.7.2 Spring Cloud 的配置  . 228
11.7.3 原生配置  229
11.8 Spring Cloud 定位问题思路总结  . 229
12 Docker 入门  232
12.1 Docker 简介  232
12.2 版本与迭代计划  232
12.2.1 版本区别  233
12.2.2 迭代计划  233
12.3 Docker 的架构  234
12.4 安装Docker  236
12.4.1 CentOS 7 安装Docker  . 236
12.4.2 Ubuntu 安装Docker  . 239
12.4.3 Windows 安装Docker  244
12.4.4 Mac OS 安装Docker  . 245
12.5 配置镜像加速器  245
12.6 Docker 常用命令  246
12.6.1 Docker 镜像常用命令  246
12.6.2 Docker 容器常用命令  252
13 将微服务运行在Docker 上  260
13.1 使用Dockerfile 构建Docker 镜像  260
13.1.1 Dockerfile 常用指令  . 261
13.1.2 使用Dockerfile 构建镜像  266
13.2 使用Docker Registry 管理Docker 镜像  . 268
13.2.1 使用Docker Hub 管理镜像  . 268
13.2.2 使用私有仓库管理镜像  270
13.3 使用Maven 插件构建Docker 镜像  . 271
13.3.1 快速入门  272
13.3.2 插件读取Dockerfile 进行构建  273
13.3.3 将插件绑定在某个phase 执行  274
13.3.4 推送镜像  275
13.4 常见问题与总结  277
14 使用Docker Compose 编排微服务  . 278
14.1 Docker Compose 简介  . 278
14.2 安装Docker Compose  . 279
14.2.1 安装Compose  . 279
14.2.2 安装Compose 命令补全工具  . 279
14.3 Docker Compose 快速入门  . 280
14.3.1 基本步骤  280
14.3.2 入门示例  280
14.3.3 工程、服务、容器  281
14.4 docker-compose.yml 常用命令  . 281
14.5 docker-compose 常用命令  . 285
14.6 Docker Compose 网络设置  . 286
14.6.1 基本概念  286
14.6.2 更新容器  287
14.6.3 links  287
14.6.4 指定自定义网络  . 288
14.6.5 配置默认网络  . 289
14.6.6 使用已存在的网络  289
14.7 综合实战：使用Docker Comose 编排Spring Cloud 微服务  289
14.7.1 编排Spring Cloud 微服务  289
14.7.2 编排高可用的Eureka Server  293
14.7.3 编排高可用Spring Cloud 微服务集群及动态伸缩  . 295
14.8 常见问题与总结  297
后记  298
附录A：本书配套代码  . 299
附录B：Spring Cloud YES——快速开发脚手架  300
附录C：使用Docker 快速安装本书中的组件  301
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker微服务架构实战（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud Alibaba 微服务原理与实战
第1章　微服务的发展史	1
1.1　从单体架构到分布式架构的演进	2
1.1.1　单体架构	2
1.1.2　集群及垂直化	3
1.1.3　SOA	4
1.1.4　微服务架构	5
1.2　微服务架构带来的挑战	7
1.2.1　微服务架构的优点	7
1.2.2　微服务架构面临的挑战	7
1.3　如何实现微服务架构	8
1.3.1　微服务架构图	8
1.3.2　微服务架构下的技术挑战	9
第2章　微服务解决方案之Spring Cloud	10
2.1　什么是Spring Cloud	11
2.2　Spring Cloud版本简介	12
2.3　Spring Cloud规范下的实现	13
2.4　Spring Cloud Netflix	14
2.5　Spring Cloud Alibaba	15
2.5.1　Spring Cloud Alibaba的优势	15
2.5.2　Spring Cloud Alibaba的版本	16
第3章　Spring Cloud的核心之Spring Boot	18
3.1　重新认识Spring Boot	18
3.1.1　Spring IoC/DI	19
3.1.2　Bean装配方式的升级	21
3.1.3　Spring Boot的价值	23
3.2　快速构建Spring Boot应用	25
3.3　Spring Boot自动装配的原理	26
3.3.1　自动装配的实现	27
3.3.2　EnableAutoConfiguration	28
3.3.3　AutoConfigurationImportSelector	29
3.3.4　自动装配原理分析	31
3.3.5　@Conditional条件装配	34
3.3.6　spring-autoconfigure-metadata	37
3.4　手写实现一个Starter	38
3.4.1　Starter的命名规范	38
3.4.2　实现基于Redis的Starter	38
3.5　本章小结	41
第4章　微服务架构下的服务治理	42
4.1　如何理解Apache Dubbo	43
4.2　Apache Dubbo实现远程通信	44
4.3　Spring Boot集成Apache Dubbo	48
4.4　快速上手ZooKeeper	52
4.4.1　ZooKeeper的安装	52
4.4.2　ZooKeeper的数据结构	52
4.4.3　ZooKeeper的特性	53
4.4.4　Watcher机制	54
4.4.5　常见应用场景分析	54
4.5　Apache Dubbo集成ZooKeeper实现服务注册	56
4.5.1　Apache Dubbo集成ZooKeeper实现服务注册的步骤	57
4.5.2　ZooKeeper注册中心的实现原理	59
4.6　实战Dubbo Spring Cloud	60
4.6.1　实现Dubbo服务提供方	60
4.6.2　实现Dubbo服务调用方	63
4.7　Apache Dubbo的高级应用	65
4.7.1　集群容错	66
4.7.2　负载均衡	67
4.7.3　服务降级	68
4.7.4　主机绑定规则	69
4.8　Apache Dubbo核心源码分析	70
4.8.1　源码构建	71
4.8.2　Dubbo的核心之SPI	71
4.8.3　无处不在的自适应扩展点	81
4.8.4　Dubbo中的IoC和AOP	85
4.8.5　Dubbo和Spring完美集成的原理	89
4.9　本章小结	95
第5章　服务注册与发现	97
5.1　什么是Alibaba Nacos	98
5.2　Nacos的基本使用	99
5.2.1　Nacos的安装	99
5.2.2　Nacos服务注册发现相关API说明	100
5.2.3　Nacos集成Spring Boot实现服务注册与发现	101
5.3　Nacos的高可用部署	103
5.3.1　安装环境要求	104
5.3.2　安装包及环境准备	104
5.3.3　集群配置	104
5.3.4　配置MySQL数据库	105
5.3.5　启动Nacos服务	105
5.4　Dubbo使用Nacos实现注册中心	106
5.5　Spring Cloud Alibaba Nacos Discovery	109
5.5.1　服务端开发	109
5.5.2　消费端开发	113
5.6　Nacos实现原理分析	115
5.6.1　Nacos架构图	116
5.6.2　注册中心的原理	116
5.7　深入解读Nacos源码	117
5.7.1　Spring Cloud什么时候完成服务注册	117
5.7.2　NacosServiceRegistry的实现	122
5.7.3　从源码层面分析Nacos服务注册的原理	123
5.7.4　揭秘服务提供者地址查询	127
5.7.5　分析Nacos服务地址动态感知原理	130
5.8　本章小结	132
第6章　Nacos实现统一配置管理	133
6.1　Nacos配置中心简介	134
6.2　Nacos集成Spring Boot实现统一配置管理	134
6.2.1　项目准备	134
6.2.2　启动Nacos Server	135
6.2.3　创建配置	135
6.2.4　启动服务并测试	137
6.3　Spring Cloud Alibaba Nacos Config	137
6.3.1　Nacos Config的基本应用	137
6.3.2　动态更新配置	139
6.3.3　基于Data ID配置YAML的文件扩展名	140
6.3.4　不同环境的配置切换	141
6.3.5　Nacos Config自定义Namespace和Group	142
6.4　Nacos Config 实现原理解析	145
6.4.1　配置的CRUD	145
6.4.2　动态监听之Pull Or Push	146
6.5　Spring Cloud如何实现配置的加载	148
6.5.1　PropertySourceBootstrapConfiguration	148
6.5.2　PropertySourceLocator	150
6.6　Nacos Config核心源码解析	152
6.6.1　NacosFactory.createConfigService	154
6.6.2　NacosConfigService构造	155
6.6.3　ClientWorker	155
6.6.4　ClientWorker.checkConfigInfo	157
6.6.5　LongPollingRunnable.run	157
6.6.6　服务端长轮询处理机制	161
6.6.7　ClientLongPolling	164
6.7　本章小结	167
第7章　基于Sentinel的微服务限流及熔断	168
7.1　服务限流的作用及实现	168
7.1.1　计数器算法	169
7.1.2　滑动窗口算法	170
7.1.3　令牌桶限流算法	171
7.1.4　漏桶限流算法	172
7.2　服务熔断与降级	172
7.3　分布式限流框架Sentinel	174
7.3.1　Sentinel的特性	174
7.3.2　Sentinel的组成	175
7.3.3　Sentinel Dashboard的部署	175
7.4　Sentinel的基本应用	176
7.4.1　Sentinel实现限流	176
7.4.2　资源的定义方式	178
7.4.3　Sentinel资源保护规则	179
7.4.4　Sentinel实现服务熔断	183
7.5　Spring Cloud集成Sentinel实践	185
7.5.1　Sentinel接入Spring Cloud	185
7.5.2　基于Sentinel Dashboard来实现流控配置	187
7.5.3　自定义URL限流异常	189
7.5.4　URL资源清洗	189
7.6　Sentinel集成Nacos实现动态流控规则	190
7.7　Sentinel Dashboard集成Nacos实现规则同步	194
7.7.1　Sentinel Dashboard源码修改	194
7.7.2　Sentinel Dashboard规则数据同步	199
7.8　Dubbo集成Sentinel实现限流	200
7.8.1　Dubbo服务接入Sentinel Dashboard	200
7.8.2　Dubbo服务限流规则配置	201
7.9　Sentinel热点限流	203
7.9.1　热点参数限流的使用	204
7.9.2　@SentinelResource热点参数限流	205
7.9.3　热点参数规则说明	206
7.10　Sentinel的工作原理	206
7.11　Spring Cloud Sentinel工作原理分析	207
7.12　Sentinel核心源码分析	210
7.12.1　限流的源码实现	210
7.12.2　实时指标数据统计	216
7.12.3　服务降级的实现原理	225
7.13　本章小结	229
第8章　分布式事务	230
8.1　分布式事务问题的理论模型	231
8.1.1　X/Open分布式事务模型	231
8.1.2　两阶段提交协议	233
8.1.3　三阶段提交协议	234
8.1.4　CAP定理和BASE理论	236
8.2　分布式事务问题的常见解决方案	238
8.2.1　TCC补偿型方案	238
8.2.2　基于可靠性消息的最终一致性方案	239
8.2.3　最大努力通知型	242
8.3　分布式事务框架Seata	243
8.3.1　AT模式	243
8.3.2　Saga模式	244
8.4　Seata的安装	248
8.4.1　file存储模式	248
8.4.2　db存储模式	249
8.4.3　Seata服务端配置中心说明	251
8.5　AT模式Dubbo集成Seata	258
8.5.1　项目准备	259
8.5.2　数据库准备	259
8.5.3　核心方法说明	260
8.5.4　项目启动顺序及访问	264
8.5.5　整合Seata实现分布式事务	265
8.6　Spring Cloud Alibaba Seata	269
8.6.1　Spring Cloud项目准备	270
8.6.2　集成Spring Cloud Alibaba Seata	270
8.6.3　关于事务分组的说明	275
8.7　Seata AT模式的实现原理	276
8.7.1　AT模式第一阶段的实现原理	277
8.7.2　AT模式第二阶段的原理分析	279
8.7.3　关于事务的隔离性保证	280
8.8　本章小结	283
第9章　RocketMQ分布式消息通信	285
9.1　什么是RocketMQ	285
9.1.1　RocketMQ的应用场景	286
9.1.2　RocketMQ的安装	286
9.1.3　RocketMQ如何发送消息	287
9.1.4　RocketMQ如何消费消息	289
9.2　Spring Cloud Alibaba RocketMQ	291
9.2.1　Spring Cloud Alibaba RocketMQ架构图	293
9.2.2　Spring Cloud Stream消息发送流程	294
9.2.3　RocketMQ Binder集成消息发送	299
9.2.4　RocketMQ Binder集成消息订阅	303
9.2.5　Spring Cloud Stream消息订阅流程	308
9.3　RocketMQ集群管理	314
9.3.1　整体架构设计	314
9.3.2　基本概念	315
9.3.3　为什么放弃ZooKeeper而选择NameServer	316
9.4　如何实现顺序消息	318
9.4.1　顺序消息的使用场景	318
9.4.2　如何发送和消费顺序消息	319
9.4.3　顺序发送的技术原理	321
9.4.4　普通发送的技术原理	322
9.4.5　顺序消费的技术原理	324
9.4.6　并发消费的技术原理	325
9.4.7　消息的幂等性	325
9.5　如何实现事务消息	326
9.5.1　事务消息的使用场景	326
9.5.2　如何发送事务消息	327
9.5.3　事务消息的技术原理	330
9.6　高性能设计	331
9.6.1　顺序写盘	333
9.6.2　消费队列设计	334
9.6.3　消息跳跃读取	336
9.6.4　数据零拷贝	336
9.6.5　动态伸缩能力	336
9.6.6　消息实时投递	337
9.7　高可用设计	338
9.7.1　消息发送重试机制	339
9.7.2　故障规避机制	340
9.7.3　同步刷盘与异步刷盘	343
9.7.4　主从复制	350
9.7.5　读写分离	351
9.7.6　消费重试机制	351
9.7.7　ACK机制	352
9.7.8　Broker集群部署	352
9.8　本章小结	353
第10章　微服务网关之Spring Cloud Gateway	354
10.1　API网关的作用	355
10.1.1　统一认证鉴权	356
10.1.2　灰度发布	357
10.2　网关的本质及技术选型	358
10.2.1　OpenResty	358
10.2.2　Spring Cloud Zuul	360
10.2.3　Spring Cloud Gateway	361
10.3　Spring Cloud Gateway网关实战	361
10.3.1　spring-cloud-gateway-service	361
10.3.2　spring-cloud-gateway-sample	362
10.4　Spring Cloud Gateway原理分析	363
10.5　Route Predicate Factories	364
10.5.1　指定时间规则匹配路由	365
10.5.2　Cookie匹配路由	365
10.5.3　Header匹配路由	366
10.5.4　Host匹配路由	366
10.5.5　请求方法匹配路由	367
10.5.6　请求路径匹配路由	367
10.6　Gateway Filter Factories	367
10.6.1　GatewayFilter	368
10.6.2　GlobalFilter	372
10.7　自定义过滤器	375
10.7.1　自定义GatewayFilter	375
10.7.2　自定义GlobalFilter	377
10.8　Spring Cloud Gateway集成Nacos实现请求负载	378
10.9　Spring Cloud Gateway集成Sentinel网关限流	381
10.9.1　Route维度限流	382
10.9.2　自定义API分组限流	384
10.9.3　自定义异常	386
10.9.4　网关流控控制台	387
10.9.5　网关限流原理	388
10.10　本章小结	389
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud Alibaba 微服务原理与实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务架构实战派
-------------第1篇 入门
-
第1章 进入微服务世界 2
1.1 系统架构的发展阶段 2
|1.1.1 单体应用阶段 2
|1.1.2 垂直应用阶段 3
|1.1.3 分布式系统阶段 4
|1.1.4 服务治理阶段 5
|1.1.5 微服务阶段 6
|1.1.6 服务网格阶段 6
1.2 主流的微服务框架 8
|1.2.1 主流微服务框架一览表 8
|1.2.2 Dubbo 9
|1.2.3 Spring Cloud 10
1.3 服务网格（Service Mesh）框架Istio 11
1.4 比较Dubbo、Spring Cloud和Istio 12
|1.4.1 对比架构 12
|1.4.2 对比各项数据 15
|1.4.3 总结 15
-
第2章 准备开发环境和工具 17
2.1 搭建环境 17
|2.1.1 安装Java开发环境JDK 17
|2.1.2 配置JDK的环境变量 18
2.2 安装和配置Maven 20
|2.2.1 安装和配置 20
|2.2.2 认识pom.xml文件 22
|2.2.3 了解Maven的运作方式 25
|2.2.4 配置国内仓库 26
2.3 安装及配置开发工具IDEA 27
|2.3.1 安装IDEA 27
|2.3.2 配置IDEA的Maven环境 29
|2.3.3 安装Spring Assistant插件 29
2.4 安装及配置开发工具Eclipse 30
|2.4.1 安装Eclipse 30
|2.4.2 安装Spring Tools 4插件 30
|2.4.3 配置Eclipse的Maven环境 31
|2.4.4 创建Spring Cloud项目 32
2.5 熟悉Spring官方开发工具STS 32
2.6 如何使用本书源码 33
|2.6.1 在IDEA中使用 33
|2.6.2 在Eclipse（STS）中使用 33
-
第3章 实例1：用Spring Cloud实现一个微服务系统 35
3.1 本实例的架构和实现步骤 35
3.2 创建Spring Cloud项目 36
3.3 用Eureka实现“服务中心” 37
|3.3.1 添加配置 37
|3.3.2 实现“服务中心”集群（满足高可用） 38
|3.3.3 打包和部署“服务中心” 40
3.4 用Eureka实现“服务提供者” 42
|3.4.1 实现“服务提供者”的客户端 42
|3.4.2 实现“服务提供者”的接口 44
|3.4.3 检查服务的有效性 44
|3.4.4 实现“服务提供者”集群 44
3.5 用Feign实现“服务消费者” 45
|3.5.1 用Feign实现“服务消费者”的客户端 45
|3.5.2 调用“服务提供者”的接口 46
3.6 测试微服务系统 48
-
-------------第2篇 基础
-
第4章 认识微服务 50
4.1 微服务的优点和缺点 50
|4.1.1 微服务的优点 50
|4.1.2 微服务的缺点 52
4.2 微服务设计的原则 53
4.3 领域驱动设计（DDD） 56
4.4 跨服务的事务管理模式 57
|4.4.1 2PC/3PC算法模式 58
|4.4.2 TCC事务机制模式 60
|4.4.3 消息中间件模式 60
|4.4.4 Saga模式 61
|4.4.5 Paxos算法模式 61
4.5 跨服务的查询模式 62
|4.5.1 API组合器模式 62
|4.5.2 CQRS模式 62
4.6 微服务部署 63
|4.6.1 部署模式 63
|4.6.2 升级模式 64
4.7 微服务架构与云原生的关系 66
|4.7.1 了解云原生 66
|4.7.2 微服务架构和云原生架构的区别 67
-
第5章 Spring Cloud基础 68
5.1 了解Spring Cloud生态 68
|5.1.1 Spring Cloud的总体架构 68
|5.1.2 主要子项目 69
|5.1.3 Netflix家族项目 70
|5.1.4 阿里巴巴家族项目 71
|5.1.5 其他子项目 72
|5.1.6 常用的技术栈 73
5.2 了解Spring Cloud 74
|5.2.1 Spring Cloud与Spring、Spring Boot的关系 74
|5.2.2 Spring Cloud的版本 76
|5.2.3 Spring Cloud项目的结构 77
|5.2.4 Spring Cloud的入口类 78
|5.2.5 Spring Cloud的自动配置 78
|5.2.6 开箱即用 79
5.3 了解注解 80
|5.3.1 什么是注解 80
|5.3.2 Spring Boot的系统注解 80
|5.3.3 Spring Boot的常用注解 81
|5.3.4 Spring Cloud的常用注解 86
5.4 了解Starter 87
|5.4.1 Spring Boot的Starter 87
|5.4.2 Spring Cloud的Starter 88
|5.4.3 如何使用Starter 88
5.5 使用配置文件 88
|5.5.1 配置文件application.properties 89
|5.5.2 实例2：使用配置文件application.properties 91
|5.5.3 配置文件application.yml 93
|5.5.4 实例3：使用配置文件application.yml 94
|5.5.5 实例4：用application.yml和application.properties配置多环境 98
|5.5.6 了解application.yml和application.properties的迁移 100
|5.5.7 比较配置文件bootstrap和application 100
5.6 应用程序分层开发模式——MVC 101
|5.6.1 了解MVC模式 101
|5.6.2 MVC和三层架构的关系 102
5.7 响应式编程——WebFlux 103
|5.7.1 什么是WebFlux 103
|5.7.2 比较MVC和WebFlux 103
|5.7.3 比较Mono和Flux 105
|5.7.4 开发WebFlux的流程 106
5.8 了解Spring Cloud Commons 106
|5.8.1 Spring Cloud的上下文 107
|5.8.2 Spring Cloud的公共抽象类 107
-
-------------第3篇 进阶
-
第6章 用Consul实现服务治理 110
6.1 为什么需要服务治理 110
6.2 主流的“服务中心” 111
|6.2.1 Eureka 111
|6.2.2 Zookeeper 112
|6.2.3 ETCD 113
|6.2.4 Consul 113
|6.2.5 比较Eureka、Consul、ETCD、Zookeeper和Nacos 114
|6.2.6 了解CAP（一致性、可用性、分区容错性） 115
|6.2.7 在容器化时代如何选择“服务中心” 115
6.3 认识“服务发现”接口 116
|6.3.1 如何进行服务的注册和发现 116
|6.3.2 @EnableDiscoveryClient与@EnableEurekaClient的区别 117
6.4 认识Consul 117
|6.4.1 Consul的术语 117
|6.4.2 Consul的工作原理 118
|6.4.3 集群的实现原理 119
|6.4.4 健康检查 120
|6.4.5 安装和实现Consul集群 122
|6.4.6 在Linux中构建Consul集群 124
6.5 实例5：用Consul实现“服务提供者”集群和“服务消费者” 125
|6.5.1 实现“服务提供者”集群 126
|6.5.2 实现“服务消费者” 128
6.6 将“服务中心”从Eureka迁移到Consul 129
-
第7章 用Ribbon和Feign实现客户端负载均衡和服务调用 130
7.1 认识负载均衡 130
|7.1.1 服务器端负载均衡 130
|7.1.2 客户端负载均衡 131
7.2 认识Ribbon 131
|7.2.1 Ribbon的工作原理 131
|7.2.2 Ribbon的主要组件 132
|7.2.3 认识负载均衡器 133
|7.2.4 了解注解@LoadBalanced 135
|7.2.5 Ping机制 136
7.3 认识负载均衡策略 137
|7.3.1 Ribbon支持的9大负载均衡策略 137
|7.3.2 实例6：自定义负载均衡策略 139
7.4 实例7：在没有“服务中心”的情况下，实现自维护的客户端负载均衡 141
|7.4.1 添加依赖和配置，并启用客户端负载均衡 142
|7.4.2 编写负载均衡控制器 143
|7.4.3 测试客户端负载均衡 143
7.5 了解Feign 143
|7.5.1 Feign简介 143
|7.5.2 了解Feign的Bean 144
|7.5.3 压缩请求和响应 145
|7.5.4 了解注解@QueryMap 145
|7.5.5 使用Feign 146
7.6 实例8：覆盖Feign的默认配置 147
|7.6.1 添加依赖和配置，并启用支持 147
|7.6.2 自定义Feign的配置 147
|7.6.3 自定义Feign的接口 148
7.7 实例9：实现在Feign中记录日志 148
|7.7.1 添加配置项 148
|7.7.2 设置记录日志等级 149
|7.7.3 实现接口类 149
|7.7.4 实现调用接口 149
7.8 用Feign构建多参数请求 150
|7.8.1 用GET方式构建多参数请求 150
|7.8.2 用POST方式构建多参数请求 150
7.9 Ribbon和Feign的区别 151
-
第8章 用Hystrix实现容错处理 152
8.1 雪崩效应 152
|8.1.1 什么是雪崩效应 152
|8.1.2 造成服务雪崩的原因 153
8.2 主流的容错项目 155
|8.2.1 流量防卫兵Sentinel 155
|8.2.2 容错框架Resilience4j 156
|8.2.3 容错框架Hystrix 156
|8.2.4 对比Sentinel、Hystrix和Resilience4j 157
8.3 Hystrix处理容错的机制 157
|8.3.1 熔断机制 157
|8.3.2 隔离机制 158
|8.3.3 降级机制 160
|8.3.4 缓存机制 160
8.4 实例10：在Feign中用Hystrix实现服务调用的容错 160
|8.4.1 了解Feign对Hystrix的支持 161
|8.4.2 添加依赖和配置，并启用支持 162
|8.4.3 实现回调类 163
|8.4.4 添加fallback属性 163
|8.4.5 测试fallback状态 163
8.5 实例11：用Hystrix Dashboard实现数据的可视化监控 163
|8.5.1 添加依赖和配置 164
|8.5.2 配置启动类和Servlet 165
|8.5.3 查看监控数据 165
8.6 实例12：用Turbine聚合监控数据 166
|8.6.1 添加依赖并启用支持 166
|8.6.2 创建多个“服务消费者” 167
|8.6.3 配置多监控点 167
|8.6.4 启动并测试聚合监控 168
-
第9章 用Spring Cloud Gateway构建微服务网关 169
9.1 认识微服务网关 169
|9.1.1 什么是微服务网关 169
|9.1.2 为什么要使用微服务网关 169
|9.1.3 认识Spring Cloud Gateway 170
|9.1.4 Spring Cloud Gateway的工作流程 171
|9.1.5 比较Zuul与Spring Cloud Gateway 172
9.2 路由（Route） 173
|9.2.1 认识路由的谓词接口和谓词工厂 173
|9.2.2 认识配置路由规则的方式 173
|9.2.3 实例13：用Java API和配置文件方式构建路由 175
|9.2.4 实例14：应用Spring Cloud Gateway的11种路由规则 176
|9.2.5 实例15：测试多种路由规则匹配优先级 181
|9.2.6 实例16：将网关注册到“服务中心”，实现服务转发 183
9.3 过滤器（Filter） 184
|9.3.1 过滤器的基本知识 184
|9.3.2 网关过滤器（GatewayFilter） 184
|9.3.3 全局过滤器（GlobalFilter） 186
|9.3.4 实例17：用AddRequestHeader过滤器工厂给请求添加Header参数 189
9.4 实例18：实现路由容错 190
|9.4.1 处理未定义的路由 190
|9.4.2 用Hystrix处理路由熔断 191
9.5 限流 193
|9.5.1 为什么要限流 193
|9.5.2 常见的限流措施 193
|9.5.3 限流算法 194
|9.5.4 实例19：用Spring Cloud Gateway内置的限流工厂实现限流 195
9.6 高可用 197
9.7 Spring Cloud Gateway的端点 197
|9.7.1 认识Spring Cloud Gateway的端点 197
|9.7.2 实例20：通过Spring Cloud Gateway的端点添加动态路由 198
-
第10章 用Spring Cloud Sleuth实现微服务链路跟踪 200
10.1 微服务链路跟踪 200
|10.1.1 为什么要实现微服务链路跟踪 200
|10.1.2 微服务链路跟踪的技术要求 201
10.2 一些开源的链路跟踪项目——Skywalking、Pinpoint、Zipkin和CAT 202
10.3 认识Sleuth和Zipkin 203
|10.3.1 Sleuth 203
|10.3.2 Zipkin 203
10.4 实例21：用Sleuth实现日志采样 204
10.5 实例22：在Spring Cloud中使用Zipkin 205
|10.5.1 搭建Zipkin服务器 205
|10.5.2 添加依赖和配置 206
|10.5.3 测试链路数据 207
-
第11章 用Spring Cloud Config配置微服务 209
11.1 了解配置中心 209
|11.1.1 配置信息的管理方式 209
|11.1.2 对比主流配置中心 211
|11.1.3 了解Spring Cloud Config 212
|11.1.4 Spring Cloud Config的常用配置 213
11.2 设置配置中心的安全 214
11.3 加/解密配置文件 215
|11.3.1 实例23：用对称加密方式加/解密配置文件 215
|11.3.2 实例24：用非对称加密方式加/解密配置文件 217
11.4 实例25：用Git配置“配置服务器” 220
|11.4.1 在Git仓库中创建配置文件 220
|11.4.2 添加配置中心的依赖和配置，并启用支持 220
|11.4.3 读取配置信息 221
11.5 实例26：从客户端获取“配置服务器”放置在Git仓库中的配置文件 222
|11.5.1 添加依赖和配置 222
|11.5.2 创建用来获取配置的控制器 223
|11.5.3 测试获取到的数据 223
11.6 实例27：用Spring Cloud Bus自动刷新配置信息 224
|11.6.1 Spring Cloud Bus简介 224
|11.6.2 添加服务器端的依赖和配置，并启用支持 224
|11.6.3 添加客户端的依赖和配置，并启用支持 225
|11.6.4 启动并刷新客户端的配置 227
|11.6.5 实现配置的自动刷新 228
|11.6.6 局部刷新客户端的配置信息 229
|11.6.7 跟踪Bus事件 229
11.7 实例28：实现配置中心和配置客户端的服务化 230
|11.7.1 实现服务器端服务化 230
|11.7.2 实现客户端服务化 231
-
第12章 用Spring Cloud Alibaba组件实现服务治理和流量控制 232
12.1 认识Spring Cloud Alibaba组件 232
|12.1.1 Spring Cloud Alibaba是什么 232
|12.1.2 Spring Cloud Alibaba、Netflix和Spring Cloud的关系 233
|12.1.3 Spring Cloud Alibaba与Spring Boot、Spring Cloud的版本兼容关系 234
12.2 认识Sentinel 235
|12.2.1 Sentinel概述 235
|12.2.2 安装和启动Sentinel 239
|12.2.3 认识流控规则 239
|12.2.4 降级规则 241
|12.2.5 系统规则 241
|12.2.7 Sentinel对RestTemplate和Feign的支持 242
|12.2.8 Sentinel的规则持久化 243
12.3 用Sentinel实现Spring Cloud项目的流控和降级 244
|12.3.1 实例29：实现直接限流 244
|12.3.2 实例30：实现关联限流 246
|12.3.3 实例31：实现链路限流 247
|12.3.4 测试流控模式 249
|12.3.5 测试降级模式 250
12.4 认识Nacos 251
|12.4.1 Nacos概述 251
|12.4.2 下载和使用Nacos 251
12.5 实例32：用Nacos实现“服务提供者”和“服务消费者” 252
|12.5.1 用Nacos实现“服务提供者” 252
|12.5.2 用Nacos实现“服务消费者” 253
|12.5.3 测试服务接口 254
12.6 实例33：用Nacos实现“配置中心” 254
|12.6.1 添加依赖和配置 255
|12.6.2 创建属性承载类 255
|12.6.3 在Nacos控制台中添加配置 255
12.6.4 测试动态刷新 256
12.6.5 测试配置回滚 257
12.7 实例34：用Nacos存储Sentinel的限流规则 257
|12.7.1 添加依赖和配置 257
|12.7.2 自定义埋点 258
|12.7.3 添加Nacos配置 258
|12.7.4 测试配置的持久化 259
12.8 实例35：实现Nacos的数据持久化和集群 260
|12.8.1 实现Nacos的数据持久化 260
|12.8.2 部署集群 261
-
第13章 用Spring Cloud Security实现微服务安全 264
13.1 认识Spring Security与Spring Cloud Security 264
|13.1.1 Spring Security 264
|13.1.2 Spring Cloud Security 266
13.2 认识OAuth 2.0 267
|13.2.1 OAuth 2.0概述 267
|13.2.2 客户端的授权模式 268
13.3 Spring Cloud Security如何实现OAuth 2.0 273
|13.3.1 认识Oauth 2.0服务提供端 273
|13.3.2 配置授权服务器 274
|13.3.3 配置资源服务器 276
13.4 实例36：用Spring Security实现安全认证和授权 276
|13.4.1 添加依赖和配置数据库 276
|13.4.2 创建用户实体类 277
|13.4.3 实现用户注册和密码加密 278
|13.4.4 自定义认证管理器 279
|13.4.5 实现Spring Security配置类 279
|13.4.6 实现登录验证成功处理类 280
|13.4.7 实现登录验证失败处理类 281
|13.4.8 测试注册和登录 281
13.5 实例37：用OAuth 2.0实现认证和授权 282
|13.5.1 添加OAuth 2.0的依赖 282
|13.5.2 配置认证服务器 282
|13.5.3 配置资源服务器 284
|13.5.4 实现用户实体类和角色映射 284
|13.5.5 实现角色实体类 285
|13.5.6 实现测试控制器 286
|13.5.7 测试用密码模式获取Token 286
|13.5.8 测试携带Token访问资源 288
|13.5.9 测试用授权码模式获得Token 288
13.6 实例38：用MySQL实现Token信息的持久化 290
13.7 实例39：用Redis实现Token信息的持久化 292
-
-------------第4篇 项目实战
-
第14章 实例40：用Spring Cloud实现页面日访问量3000万的某平台微服务架构 296
14.1 本实例的整体架构 296
|14.1.1 实施方案 296
|14.1.2 整体架构 297
14.2 实现“配置中心”以提供配置信息 297
|14.2.1 创建配置文件，并将其上传到Git仓库中 297
|14.2.2 编写“配置服务器”的信息 298
14.3 实现“服务提供者”集群、“服务消费者”及客户端自动配置 298
|14.3.1 实现“服务提供者”集群 298
|14.3.2 实现“服务消费者”，并通过“配置中心”实现客户端的自动配置 299
14.4 用OAuth 2.0实现统一的认证和授权 301
|14.4.1 实现认证服务器 301
|14.4.2 配置“服务消费者”的资源安全 301
14.5 在Spring Cloud中用“Redis+MySQL”实现路由服务器 302
|14.5.1 整体思路 302
|14.5.2 设计并实现自定义路由模型 303
|14.5.3 实现路由信息和版本信息实体 303
|14.5.4 实现路由和版本的控制器 304
|14.5.5 实现路由服务器的服务化 306
14.6 用Spring Cloud Gateway实现网关集群 306
|14.6.1 同步路由信息 306
|14.6.2 转换路由对象 308
|14.6.3 开启计划任务和负载均衡 308
|14.6.4 实现网关的服务化 309
14.7 用Nginx实现负载均衡 309
|14.7.1 认识Nginx 309
|14.7.2 实现网关负载均衡 312
|14.7.3 实现Nginx自身负载均衡 313
14.8 用Spring Boot Admin监控Spring Cloud应用程序 314
|14.8.1 集成Actuator 314
|14.8.2 集成Spring Boot admin以监控应用 316
14.9 集成“Prometheus+Grafana”以监控服务 319
|14.9.1 安装和配置Prometheus 319
|14.9.2 在Spring Cloud中集成Prometheus 321
|14.9.3 用Grafana实现可视化监控 322
-
-------------第5篇 开发运维一体化（DevOps）
-
第15章 基于Docker、K8s、Jenkins的DevOps实践 324
15.1 认识DevOps 324
|15.1.1 软件开发的演变过程 324
|15.1.2 认识DevOps 326
|15.1.3 开发模式的关系 327
|15.1.4 为什么要践行DevOps 328
|15.1.5 了解DevOps工具 329
15.2 认识Docker 332
|15.2.1 认识虚拟机和容器 332
|15.2.2 什么是Docker 334
|15.2.3 Docker的特点 335
|15.2.4 Docker的基本概念 335
15.3 使用Docker 337
|15.3.1 在Linux中安装Docker 337
|15.3.2 在Windows中安装Docker 338
|15.3.3 配置国内镜像加速器 338
|15.3.4 Docker的常用操作 340
15.4 用Docker Compose管理容器 342
|15.4.1 了解Docker Compose工具 342
|15.4.2 安装Docker Compose工具 342
|15.4.3 用Docker Compose工具运行容器 344
15.5 管理镜像 344
|15.5.1 用Docker Hub管理镜像 344
|15.5.2 创建私有仓库 345
15.6 认识Docker Swarm、Kubernetes（K8s）和Jenkins 345
|15.6.1 Docker Swarm 345
|15.6.2 Kubernetes（K8s） 347
|15.6.3 Jenkins 349
|15.6.4 比较Docker、Compose、Swarm、K8s和Jenkins 350
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务架构实战派
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务
前言
第一部分　准备篇
第1章　Spring Cloud与微服务概述 2
1.1　传统的单体应用 2
1.1.1　改进单体应用的架构 2
1.1.2　向微服务靠拢 3
1.2　什么是微服务 4
1.2.1　使用微服务架构的优势和劣势 4
1.2.2　重构前的准备工作 5
1.3　什么是Spring Cloud 5
1.3.1　Spring Cloud模块介绍 5
1.3.2　Spring Cloud版本介绍 6
1.4　本章小结 7
第2章　实战前的准备工作 8
2.1　开发环境的准备 8
2.2　Spring Boot入门 9
2.2.1　Spring Boot简介 9
2.2.2　搭建Spring Boot项目 9
2.2.3　编写第一个REST接口 11
2.2.4　读取配置文件 11
2.2.5　profiles多环境配置 13
2.2.6　热部署 13
2.2.7　actuator监控 15
2.2.8　统一异常处理 16
2.2.9　异步执行 18
2.2.10　随机端口 21
2.3　本章小结 23
第二部分　基础篇
第3章　Eureka注册中心 26
3.1　Eureka 26
3.2　使用Eureka编写注册中心服务 27
3.3　编写服务提供者 29
3.3.1　创建项目注册到Eureka 29
3.3.2　编写提供接口 30
3.4　编写服务消费者 31
3.4.1　直接调用接口 31
3.4.2　通过Eureka来消费接口 32
3.5　开启Eureka认证 33
3.6　Eureka高可用搭建 33
3.6.1　高可用原理 33
3.6.2　搭建步骤 34
3.7　常用配置讲解 35
3.7.1　关闭自我保护 35
3.7.2　自定义Eureka的Instance ID 35
3.7.3　自定义实例跳转链接 36
3.7.4　快速移除已经失效的服务信息 37
3.8　扩展使用 38
3.8.1　Eureka REST API 38
3.8.2　元数据使用 40
3.8.3　EurekaClient使用 41
3.8.4　健康检查 43
3.8.5　服务上下线监控 45
3.9　本章小结 46
第4章　客户端负载均衡Ribbon 47
4.1　Ribbon 47
4.1.1　Ribbon模块 47
4.1.2　Ribbon使用 48
4.2　RestTemplate结合Ribbon使用 49
4.2.1　使用RestTemplate与整合Ribbon 49
4.2.2　RestTemplate负载均衡示例 52
4.2.3　@LoadBalanced注解原理 53
4.2.4　Ribbon API使用 57
4.2.5　Ribbon饥饿加载 58
4.3　负载均衡策略介绍 59
4.4　自定义负载策略 60
4.5　配置详解 61
4.5.1　常用配置 61
4.5.2　代码配置Ribbon 62
4.6　重试机制 63
4.7　本章小结 64
第5章　声明式REST客户端Feign 65
5.1　使用Feign调用服务接口 65
5.1.1　在Spring Cloud中集成Feign 66
5.1.2　使用Feign调用接口 66
5.2　自定义Feign的配置 67
5.2.1　日志配置 67
5.2.2　契约配置 69
5.2.3　Basic认证配置 69
5.2.4　超时时间配置 70
5.2.5　客户端组件配置 71
5.2.6　GZIP压缩配置 72
5.2.7　编码器解码器配置 72
5.3　脱离Spring Cloud 使用Feign 73
5.3.1　原生注解方式 73
5.3.2　构建Feign对象 74
5.3.3　其他配置 75
5.4　本章小结 76
第6章　Hystrix 服务容错处理 77
6.1　Hystrix 77
6.1.1　Hystrix的简单使用 77
6.1.2　回退支持 78
6.1.3　信号量策略配置 79
6.1.4　线程隔离策略配置 79
6.1.5　结果缓存 80
6.1.6　缓存清除 81
6.1.7　合并请求 83
6.2　在Spring Cloud中使用Hystrix 84
6.2.1　简单使用 84
6.2.2　配置详解 85
6.2.3　Feign整合Hystrix服务容错 88
6.2.4　Feign中禁用Hystrix 90
6.3　Hystrix监控 91
6.4　整合Dashboard查看监控数据 92
6.5　Turbine聚合集群数据 94
6.5.1　Turbine使用 94
6.5.2　context-path导致监控失败 95
6.6　本章小结 95
第7章　API网关 96
7.1　Zuul 简介 96
7.2　使用Zuul构建微服务网关 97
7.2.1　简单使用 97
7.2.2　集成Eureka 98
7.3　Zuul路由配置 98
7.4　Zuul过滤器讲解 99
7.4.1　过滤器类型 100
7.4.2　请求生命周期 100
7.4.3　使用过滤器 101
7.4.4　过滤器禁用 103
7.4.5　过滤器中传递数据 103
7.4.6　过滤器拦截请求 104
7.4.7　过滤器中异常处理 106
7.5　Zuul容错和回退 108
7.5.1　容错机制 108
7.5.2　回退机制 109
7.6　Zuul高可用 111
7.7　本章小结 111
第三部分　实战篇
第8章　分布式配置管理 114
8.1　自研配置管理框架Smconf简介 114
8.2　Smconf工作原理 115
8.3　Smconf 部署 116
8.3.1　Mongodb安装 116
8.3.2　Zookeeper安装 117
8.3.3　Smconf Server部署 118
8.4　项目中集成Smconf 119
8.4.1　集成Smconf 119
8.4.2　使用Smconf 120
8.4.3　配置更新回调 121
8.5　Smconf详细使用 122
8.5.1　源码编译问题 122
8.5.2　后台账号管理 122
8.5.3　REST API 123
8.6　Smconf源码解析 125
8.6.1　Client启动 125
8.6.2　启动加载配置 127
8.6.3　配置修改推送原理 128
8.7　本章小结 129
第9章　Sleuth服务跟踪 130
9.1　Spring Cloud集成Sleuth 130
9.2　整合Logstash 131
9.2.1　ELK简介 131
9.2.2　输出JSON格式日志 131
9.3　整合Zipkin 133
9.3.1　创建Zipkin数据收集服务 133
9.3.2　项目集成Zipkin发送调用链数据 134
9.3.3　抽样采集数据 135
9.3.4　用RabbitMq代替Http发送调用链数据 135
9.3.5　用Elasticsearch存储调用链数据 136
9.4　本章小结 137
第10章　微服务之间调用的安全认证 138
10.1　什么是JWT 138
10.2　创建统一的认证服务 139
10.2.1　表结构 139
10.2.2　JWT工具类封装 139
10.2.3　认证接口 141
10.3　服务提供方进行调用认证 142
10.4　服务消费方申请Token 143
10.5　Feign调用前统一申请Token传递到调用的服务中 145
10.6　Zuul中传递Token到路由的服务中 147
10.7　本章小结 148
第11章　Spring Boot Admin 149
11.1　Spring Boot Admin的使用方法 149
11.1.1　创建Spring Boot Admin项目 149
11.1.2　将服务注册到Spring Boot Admin 150
11.1.3　如何在Admin中查看各个服务的日志 151
11.2　开启认证 152
11.3　集成Eureka 153
11.4　集成Turbine 154
11.5　监控服务 155
11.5.1　邮件警报 156
11.5.2　自定义钉钉警报 156
11.6　本章小结 159
第12章　服务的API文档管理 160
12.1　Swagger简介 160
12.2　集成Swagger管理API文档 161
12.2.1　封装Swagger Starter 161
12.2.2　在项目中集成Swagger starter 162
12.2.3　使用Swagger生成文档 162
12.2.4　在线测试接口 163
12.3　Swagger注解 164
12.4　Eureka 控制台快速查看Swagger文档 169
12.5　本章小结 169
第四部分　高级篇
第13章　API网关扩展 172
13.1　用户认证 172
13.1.1　动态管理不需要拦截的API请求 172
13.1.2　创建认证的用户服务 174
13.1.3　路由之前的认证 175
13.1.4　向下游微服务中传递认证之后的用户信息 176
13.1.5　内部服务间的用户信息传递 177
13.2　服务限流 179
13.2.1　限流算法 179
13.2.2　单节点限流 179
13.2.3　集群限流 184
13.2.4　具体服务限流 187
13.2.5　具体接口限流 188
13.3　服务降级 194
13.4　灰度发布 196
13.4.1　原理讲解 196
13.4.2　根据用户做灰度发布 197
13.4.3　根据IP做灰度发布 200
13.5　本章小结 200
第14章　微服务之缓存 201
14.1　Guava Cache本地缓存 201
14.1.1　Guava Cache简介 201
14.1.2　代码示例 202
14.1.3　回收策略 202
14.2　Redis缓存 203
14.2.1　用Redistemplate 操作Redis 203
14.2.2　用Repository操作Redis 204
14.2.3　Spring Cache 缓存数据 206
14.2.4　扩展Spring Cache支持对每个缓存的时间配置 211
14.2.5　缓存异常处理 212
14.2.6　自定义缓存工具类 214
14.3　防止缓存穿透方案 216
14.3.1　什么是缓存穿透 216
14.3.2　缓存穿透的危害 216
14.3.3　解决方案 217
14.3.4　布隆过滤器介绍 217
14.3.5　代码示例 217
14.4　防止缓存雪崩方案 219
14.4.1　什么是缓存雪崩 219
14.4.2　缓存雪崩的危害 219
14.4.3　解决方案 219
14.4.4　代码示例 219
14.4.5　分布式锁方式 220
14.5　本章小结 221
第15章　微服务之存储 222
15.1　存储选型 222
15.2　Mongodb 223
15.2.1　集成Spring Data Mongodb 223
15.2.2　添加数据操作 223
15.2.3　索引使用 225
15.2.4　修改数据操作 227
15.2.5　删除数据操作 228
15.2.6　查询数据操作 229
15.2.7　GridFS操作 231
15.2.8　用Repository方式操作数据 232
15.2.9　自增ID实现 236
15.2.10　批量更新扩展 239
15.3　Mysql 243
15.3.1　集成Spring JdbcTemplate 243
15.3.2　JdbcTemplate代码示例 243
15.3.3　封装JdbcTemplate 操作Mysql更简单 244
15.3.4　扩展JdbcTemplate使用方式 244
15.3.5　常见问题 248
15.4　Elasticsearch 251
15.4.1　集成Spring Data Elasticsearch 251
15.4.2　Repository示例 251
15.4.3　ElasticsearchTemplate示例 254
15.4.4　索引构建方式 257
15.5　本章小结 259
第16章　微服务之分布式事物解决方案 260
16.1　两阶段型 260
16.2　TCC补偿型 261
16.3　最终一致性 261
16.3.1　原理讲解 261
16.3.2　创建可靠性消息服务 263
16.3.3　消息存储表设计 264
16.3.4　提供服务接口 265
16.3.5　创建消息发送系统 269
16.3.6　消费消息逻辑 273
16.3.7　消息管理系统 275
16.4　最大努力通知型事物 276
16.4.1　介绍 276
16.4.2　原理 276
16.5　本章小结 276
第17章　分布式任务调度 277
17.1　Elastic-Job 277
17.1.1　Elastic-Job介绍 277
17.1.2　任务调度目前存在的问题 277
17.1.3　为什么选择Elastic-Job 278
17.2　快速集成 279
17.3　任务使用 280
17.3.1　简单任务 280
17.3.2　数据流任务 281
17.3.3　脚本任务 282
17.4　配置参数讲解 282
17.4.1　注册中心配置 283
17.4.2　作业配置 283
17.4.3　dataflow独有配置 284
17.4.4　script独有配置 284
17.5　多节点并行调度 285
17.5.1　分片概念 285
17.5.2　任务节点分片策略 285
17.5.3　业务数据分片处理 286
17.6　事件追踪 289
17.7　扩展功能 290
17.7.1　自定义监听器 290
17.7.2　定义异常处理 291
17.8　运维平台 291
17.8.1　功能列表 292
17.8.2　部署运维平台 292
17.8.3　运维平台使用 293
17.9　使用经验分享 296
17.9.1　任务的划分和监控 296
17.9.2　任务的扩展性和节点数量 297
17.9.3　任务的重复执行 297
17.9.4　overwrite覆盖问题 298
17.9.5　流水式任务 298
17.10　本章小结 299
第18章　分库分表解决方案 300
18.1　Sharding-JDBC 300
18.1.1　介绍 300
18.1.2　功能列表 301
18.1.3　相关概念 301
18.2　快速集成 302
18.3　读写分离实战 304
18.3.1　准备数据 304
18.3.2　配置读写分离 304
18.3.3　验证读从库 305
18.3.4　验证写主库 307
18.3.5　Hint强制路由主库 308
18.4　分库分表实战 309
18.4.1　常用分片算法 310
18.4.2　使用分片算法 310
18.4.3　不分库只分表实战 311
18.4.4　既分库又分表实战 314
18.5　分布式主键 317
18.6　本章小结 319
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker高并发微服务架构设计实施
第一部分架 构 篇
1 微服务架构与 Spring Cloud  2
1.1 微服务概念的由来  2
1.2 微服务的定义  3
1.3 微服务架构与整体式架构的区别  5
1.4 微服务架构与SOA 的比较  8
1.5 为什么要使用微服务架构  9
1.6 为实施微服务架构做好准备  10
1.6.1 思想观念的转变  10
1.6.2 团队管理方式的改变  11
1.6.3 自动化基础设施的建设  11
1.7 为什么要使用Spring Cloud  12
1.8 Spring Cloud 组件介绍  13
1.9 Spring Cloud 的版本说明  15
1.10 小结  17
2 微服务架构最佳设计  18
2.1 合理划分微服务  19
2.2 微服务治理  19
2.3 Rest API 微服务设计  21
2.3.1 使用数据库集群  22
2.3.2 读写分离设计  22
2.3.3 使用缓存  22
2.3.4 保证Rest API 微服务的独立性  23
2.4 Web UI 微服务设计  23
2.4.1 使用FeignClient 实现负载均衡调用  23
2.4.2 使用Hystrix 实现容错设计  23
2.4.3 使用非阻塞的异步编程技术实现高并发调用  24
2.4.4 使用分布式文件系统  24
2.5 微服务之间调用规则设计  24
2.6 数据最终一致性设计  25
2.7 分布式集群架构设计  26
2.8 微服务运行环境安全设计  27
2.9 小结  27
3 电商平台微服务设计实例  29
3.1 电商平台总体设计  29
3.1.1 总体业务流程设计  29
3.1.2 总体业务功能设计  31
3.2 电商平台业务模型设计  32
3.2.1 移动商城业务模型  32
3.2.2 商家管理后台业务模型  33
3.2.3 平台管理后台业务模型  33
3.3 创建Rest API 微服务  34
3.4 创建Web UI 微服务  36
3.4.1 移动商城Web UI 微服务  36
3.4.2 商家管理后台的Web UI 微服务  37
3.4.3 平台管理后台Web UI 微服务  37
3.5 电商平台微服务体系结构  38
3.6 小结  39
第二部分 开 发 篇
4 开发工具选用及 Spring Boot 基础  41
4.1 开发工具选择  42
4.2 开发环境配置  42
4.3 创建Spring Boot 工程  43
4.4 使用JPA  47
4.4.1 数据源配置  48
4.4.2 JPA 配置  48
4.4.3 数据实体设计  49
4.4.4 存储库接口设计  49
4.4.5 单元测试  50
4.5 使用Thymeleaf  51
4.5.1 控制器设计  51
4.5.2 视图设计  52
4.6 运行与部署  52
4.7 小结  54
5 电商平台微服务工程设计  55
5.1 微服务工程结构  55
5.2 电商平台微服务工程组建  57
5.3 数据库选型  57
5.4 微服务工程创建步骤  58
5.5 项目基本配置  60
5.6 创建模块  64
5.7 小结  66
6 微服务治理基础服务开发  67
6.1 注册管理中心  68
6.1.1 创建注册管理中心  68
6.1.2 运行注册管理中心  70
6.1.3 微服务怎样使用注册管理中心  70
6.1.4 构建高可用的注册管理中心  72
6.2 配置管理中心  73
6.2.1 创建配置管理中心  73
6.2.2 微服务如何使用配置管理中心  76
6.2.3 在线更新配置信息  77
6.3 微服务监控中心  78
6.3.1 使用断路器仪表盘实现监控  79
6.3.2 聚合服务监控管理中心  81
6.4 服务跟踪分析中心  86
6.4.1 创建服务跟踪分析中心  86
6.4.2 在微服务中启用服务跟踪功能  90
6.5 日志分析平台  93
6.5.1 创建日志分析平台  93
6.5.2 使用日志分析平台  93
6.6 小结  94
7 Rest API 微服务开发  96
7.1 领域业务开发  96
7.1.1 使用Druid 数据源  98
7.1.2 JPA 及其配置  100
7.1.3 数据实体建模  101
7.1.4 查询对象设计  104
7.1.5 实体持久化设计  106
7.1.6 持久化测试  107
7.1.7 领域服务开发  109
7.1.8 领域服务的单元测试  111
7.1.9 使用Redis 实现缓存设计  112
7.2 Rest API 应用开发  117
7.2.1 Rest API 应用配置  117
7.2.2 启动程序设计  119
7.2.3 接口开发  119
7.3 使用消息处理事件  123
7.3.1 消息生产者设计  124
7.3.2 消息消费者设计  125
7.3.3 使用消息测试  128
7.4 小结  129
8 Web UI 微服务开发  131
8.1 高并发接口调用分层设计  131
8.2 通过FeignClient 调用Rest API  132
8.3 使用Hystrix 断路器  134
8.4 使用非阻塞异步编程方法  136
8.4.1 CompletableFuture 介绍  137
8.4.2 性能比较测试  140
8.5 Web 应用开发  145
8.5.1 项目引用配置  145
8.5.2 应用程序配置  146
8.5.3 业务功能开发  148
8.6 开发环境的热部署设置  154
8.7 使用分布式文件系统  157
8.7.1 分布式文件系统客户端开发  157
8.7.2 商品图片上传设计  159
8.7.3 富文本编辑器上传文件设计  160
8.7.4 建立本地文件信息库  163
8.8 小结  166
9 电商平台移动商城开发  167
9.1 移动商城首页设计  168
9.2 使用负载均衡的导航设计  174
9.3 按分类查询设计  176
9.4 商品详情页设计  179
9.5 购买下单实现  181
9.6 用户登录与账户切换设计  184
9.6.1 用户登录设计  184
9.6.2 切换账号设计  186
9.7 订单查询设计  188
9.8 集成测试  191
9.9 小结  192
10 商家管理后台与 SSO 设计  193
10.1 商家权限管理体系设计及开发  194
10.1.1 商家权限体系建模  195
10.1.2 商家权限体系的持久化设计  199
10.1.3 商家权限体系的领域服务开发  201
10.2 商家管理微服务开发  204
10.2.1 商家领域服务层单元测试  204
10.2.2 商家服务的接口开发  208
10.3 SSO 设计  213
10.3.1 SSO 基本配置  213
10.3.2 在SSO 中使用商家的权限体系  214
10.3.3 用户登录设计  216
10.3.4 有关验证码的说明  218
10.3.5 SSO 的主页设计  220
10.3.6 OAuth2 服务端设计  222
10.4 SSO 客户端设计  224
10.4.1 客户端的项目管理配置  224
10.4.2 客户端的安全管理配置  225
10.4.3 权限验证实现原理  226
10.4.4 如何在应用中接入SSO  228
10.4.5 有关跨站请求伪造防御的相关设置  230
10.4.6 根据用户权限自动分配菜单  230
10.5 小结  232
11 平台管理后台开发  233
11.1 平台管理后台领域设计  233
11.1.1 领域实体建模  233
11.1.2 实体的行为设计  236
11.1.3 领域服务开发  236
11.1.4 领域服务单元测试  239
11.2 平台管理后台访问控制设计  240
11.2.1 使用平台管理的用户体系  240
11.2.2 权限管理设计  242
11.3 商家的注册设计  245
11.4 商家菜单体系管理开发  248
11.4.1 分类菜单管理开发  248
11.4.2 模块菜单管理开发  249
11.4.3 访问资源管理开发  252
11.5 商家角色管理开发  255
11.6 小结  257
第三部分运 维 篇
12 服务器架构设计与 Docker 使用  259
12.1 服务器组建  259
12.2 安全的服务器架构设计  260
12.2.1 防火墙安装及配置  260
12.2.2 建立安全的局域网环境  264
12.3 服务器资源分配  266
12.4 CentOS 安装  269
12.4.1 IP 地址设置  270
12.4.2 安全设置  270
12.4.3 语言配置  270
12.4.4 时间同步配置  271
12.5 Docker 和docker-compose 安装  271
12.5.1 Docker 安装及使用  272
12.5.2 docker-compose 安装及使用  275
12.6 使用Docker 搭建微服务治理环境  279
12.6.1 服务器1 的部署配置  279
12.6.2 服务器2 的部署配置  281
12.7 使用Docker 部署日志分析平台  283
12.8 使用Docker 部署微服务应用  286
12.9 小结  286
13 数据库集群设计与高可用读写分离实施  288
13.1 MySQL 安装  289
13.2 主从同步设置  291
13.3 主主同步设置  294
13.4 数据库代理中间件选择  296
13.5 使用OneProxy 实现读写分离设计  297
13.5.1 OneProxy 安装  297
13.5.2 高可用读写分离配置  298
13.6 OneProxy 分库分区设计  302
13.6.1 按范围分库分表  303
13.6.2 按值分库分表  303
13.6.3 按哈希算法分库分表  304
13.7 双机热备设计  306
13.8 小结  307
14 分布式文件系统等基础设施安装与配置  308
14.1 高可用的分布式文件系统构建  308
14.1.1 FastDFS 安装  310
14.1.2 跟踪服务器配置  310
14.1.3 存储节点配置  311
14.1.4 上传文件测试  312
14.1.5 Nginx 安装及负载均衡配置  313
14.1.6 开机启动设置  317
14.2 GitLab 安装  322
14.3 Redis 安装  324
14.4 RabbitMQ 安装  326
14.5 小结  327
15 使用自动化构建工具 Jenkins 实现CI/CD  328
15.1 持续交付工作流程  330
15.2 Jenkins 安装  331
15.3 Jenkins 基本配置  333
15.4 Jenkins 自动部署实例  335
15.4.1 创建任务  336
15.4.2 任务配置  337
15.4.3 执行任务  340
15.5 小结  343
后记  345
参考文献  346
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker高并发微服务架构设计实施
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务架构进阶
前言
第1章 微服务架构介绍1
1.1 微服务架构的出现1
1.1.1 单体应用架构1
1.1.2 SOA架构2
1.1.3 微服务架构3
1.2 微服务架构的流派5
1.3 云原生与微服务9
1.4 本章小结12
第2章 Spring Cloud总览13
2.1 Spring Cloud架构13
2.2 Spring Cloud特性16
2.2.1 Spring Cloud Context：应用上下文16
2.2.2 Spring Cloud Commons：公共抽象19
2.3 本章小结21
第3章 Spring Cloud的基础：Spring Boot22
3.1 Spring Boot简介22
3.2 构建一个微服务24
3.3 Spring Boot配置文件29
3.3.1 默认配置文件29
3.3.2 外部化配置29
3.3.3 YAML30
3.3.4 自动载入外部属性到Bean30
3.3.5 多Profile31
3.3.6 Starter32
3.3.7 自制一个Starter32
3.3.8 Actuator36
3.4 本章小结38
第4章 服务注册与发现：Eureka39
4.1 基础应用40
4.1.1 Eureka简介40
4.1.2 搭建Eureka服务注册中心40
4.1.3 搭建Eureka服务提供者42
4.1.4 搭建Eureka服务调用者43
4.1.5 Eureka服务注册和发现44
4.1.6 Consul的简单应用46
4.2 服务发现原理48
4.3 Eureka Client源码解析49
4.3.1 读取应用自身配置信息50
4.3.2 服务发现客户端52
4.3.3 拉取注册表信息56
4.3.4 服务注册61
4.3.5 初始化定时任务62
4.3.6 服务下线68
4.4 Eureka Server源码解析70
4.4.1 服务实例注册表70
4.4.2 服务注册72
4.4.3 接受服务心跳74
4.4.4 服务剔除75
4.4.5 服务下线77
4.4.6 集群同步78
4.4.7 获取注册表中服务实例信息82
4.5 进阶应用84
4.5.1 Eureka Instance和Client的元数据84
4.5.2 状态页和健康检查页端口设置85
4.5.3 区域与可用区85
4.5.4 高可用性服务注册中心86
4.6 本章小结87
第5章 声明式RESTful客户端：Spring Cloud OpenFeign88
5.1 基础应用88
5.1.1 微服务之间的交互88
5.1.2 OpenFeign简介89
5.1.3 代码示例89
5.2 源码分析91
5.2.1 核心组件与概念91
5.2.2 动态注册BeanDefinition92
5.2.3 实例初始化98
5.2.4 函数调用和网络请求107
5.3 进阶应用111
5.3.1 Decoder与Encoder的定制化111
5.3.2 请求/响应压缩112
5.4 本章小结113
第6章 断路器：Hystrix114
6.1 基础应用114
6.1.1 RestTemplate与Hystrix115
6.1.2 OpenFeign与Hystrix117
6.2 Hystrix原理118
6.2.1 服务雪崩118
6.2.2 断路器119
6.2.3 服务降级操作120
6.2.4 资源隔离121
6.2.5 Hystrix实现思路122
6.3 源码解析123
6.3.1 封装HystrixCommand123
6.3.2 HystrixCommand类结构129
6.3.3 异步回调执行命令129
6.3.4 异步执行命令和同步执行命令137
6.3.5 断路器逻辑137
6.3.6 资源隔离143
6.3.7 请求超时监控148
6.3.8 失败回滚逻辑150
6.4 进阶应用152
6.4.1 异步与异步回调执行命令152
6.4.2 继承HystrixCommand153
6.4.3 请求合并157
6.5 本章小结161
第7章 客户端负载均衡器：Spring Cloud Netflix Ribbon162
7.1 负载均衡162
7.2 基础应用163
7.3 源码分析165
7.3.1 配置和实例初始化165
7.3.2 与OpenFeign的集成167
7.3.3 负载均衡器LoadBalancerClient171
7.3.4 ILoadBalancer173
7.3.5 负载均衡策略实现177
7.4 进阶应用184
7.4.1 Ribbon API184
7.4.2 使用Netty发送网络请求185
7.4.3 只读数据库的负载均衡实现186
7.5 本章小结187
第8章 API网关：Spring Cloud Gateway189
8.1 Spring Cloud Gateway介绍189
8.2 基础应用190
8.2.1 用户服务191
8.2.2 网关服务192
8.2.3 客户端的访问195
8.3 源码解析195
8.3.1 初始化配置196
8.3.2 网关处理器197
8.3.3 路由定义定位器202
8.3.4 路由定位器205
8.3.5 路由断言208
8.3.6 网关过滤器216
8.3.7 全局过滤器227
8.3.8 API端点234
8.4 应用进阶235
8.4.1 限流机制235
8.4.2 熔断降级238
8.4.3 网关重试过滤器240
8.5 本章小结241
第9章 配置中心：Spring Cloud Config243
9.1 基础应用244
9.1.1 配置客户端244
9.1.2 配置仓库245
9.1.3 服务端246
9.1.4 配置验证248
9.1.5 配置动态更新249
9.2 源码解析250
9.2.1 配置服务器251
9.2.2 配置客户端261
9.3 应用进阶267
9.3.1 为Config Server配置多个repo268
9.3.2 客户端覆写远端的配置属性268
9.3.3 属性覆盖269
9.3.4 安全保护269
9.3.5 加密解密270
9.3.6 快速响应失败与重试机制272
9.4 本章小结272
第10章 消息驱动：Spring Cloud Stream274
10.1 消息队列274
10.2 基础应用276
10.2.1 声明和绑定通道276
10.2.2 自定义通道276
10.2.3 接收消息276
10.2.4 配置278
10.3 源码分析278
10.3.1 动态注册BeanDefinition279
10.3.2 绑定服务282
10.3.3 获取绑定器284
10.3.4 绑定生产者289
10.3.5 消息发送的流程291
10.3.6 StreamListener注解的处理293
10.3.7 绑定消费者298
10.3.8 消息的接收304
10.4 进阶应用306
10.4.1 Bin
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务架构进阶
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务架构开发实战
第1篇  微服务开发基础——Spring Boot框架及使用
第1章  微服务架构开发    2
1.1  单体架构应用的困境   2
1.2  微服务架构   3
1.2.1  如何定义微服务架构       4
1.2.2  微服务架构的优点   5
1.2.3  微服务架构的缺点   6
1.3  微服务架构设计   7
1.3.1  微服务粒度       7
1.3.2  微服务拆分原则       8
1.3.3  微服务自治原则       9
1.3.4  微服务交互原则       10
1.3.5  微服务架构迁移       10
1.4  不应使用微服务架构的情形      11
第2章  微服务基础——Spring Boot 12
2.1  Spring与Spring Boot  12
2.2  快速启动Spring Boot  13
2.2.1  编写pom.xml文件   14
2.2.2  编写应用引导类       16
2.2.3  编写配置文件   17
2.2.4  运行项目   17
2.3  使用Spring Boot构建示例项目 19
2.3.1  经典三层应用架构   19
2.3.2  设计领域对象   20
2.3.3  实现数据管理   23
2.3.4  编写业务逻辑层       29
2.3.5  编写RESTful API     31
2.3.6  数据库初始化   35
2.3.7  启动测试   36
2.4  Spring Boot特性  37
2.4.1  Spring Boot自动配置机制      37
2.4.2  Spring Boot扩展属性配置      38
2.4.3  Spring Boot日志配置      39
2.5  关于敏捷开发      40
2.6  关于RESTful API设计       41
2.6.1  以资源为中心进行URL设计  42
2.6.2  正确使用HTTP方法及状态码       42
2.6.3  查询及分页处理原则       43
2.6.4  其他指导原则   43
第2篇  Spring Cloud组件实战
第3章  Spring Cloud简介  46
3.1  微服务架构的核心关键点   46
3.2  Spring Cloud技术概览       49
3.2.1  Spring Cloud子项目 50
3.2.2  为何选择Spring Cloud     53
3.3  Spring Cloud版Hello World示例      54
第4章  服务治理与负载均衡    58
4.1  什么是服务治理   58
4.2  构建服务治理——Eureka   59
4.2.1  搭建微服务Parent工程   60
4.2.2  搭建服务治理服务器——Eureka服务器       62
4.2.3  搭建服务提供者——注册服务       64
4.2.4  搭建服务消费者——获取服务       68
4.3  使用客户端负载均衡——Ribbon      72
4.3.1  什么是客户端负载均衡   72
4.3.2  启用Ribbon      74
4.3.3  负载均衡测试   75
4.4  使用Feign简化微服务调用       77
4.5  深入Eureka  80
4.5.1  服务注册及相关原理       80
4.5.2  Eureka自我保护模式       82
4.5.3  注册一个服务实例需要的时间       84
4.5.4  Eureka高可用集群及示例       84
4.5.5  多网卡及IP指定      88
4.5.6  Eureka服务访问安全       89
4.6  深入Ribbon  90
4.6.1  Ribbon客户端负载均衡原理   90
4.6.2  Ribbon负载均衡策略及配置   92
4.6.3  直接使用Ribbon API       94
4.7  深入Feign    96
4.7.1  Feign的参数绑定     96
4.7.2  Feign中的继承  97
4.7.3  Feign与Swagger的冲突  98
4.8  微服务健康监控   99
4.9  异构服务解决方案——Sidecar   101
第5章  微服务容错保护——Hystrix       102
5.1  什么是微服务容错保护      102
5.2  快速启动Hystrix  103
5.2.1  引入Hystrix依赖     104
5.2.2  开启Hystrix支持     104
5.2.3  修改UserService实现      104
5.2.4  容错测试   105
5.2.5  服务降级的两种实现方式       107
5.2.6  在Feign中使用Hystrix回退   109
5.3  Hystrix容错机制分析  110
5.3.1  Hystrix整体处理流程      111
5.3.2  HystrixCommand与HystrixObservableCommand   113
5.3.3  断路器原理分析       115
5.3.4  Hystrix异常——HystrixBadRequestException       117
5.4  服务隔离      117
5.4.1  线程池隔离与信号量隔离       118
5.4.2  服务隔离的颗粒度   119
5.4.3  服务隔离配置   119
5.4.4  小结   120
5.5  服务降级模式      121
5.5.1  快速失败   121
5.5.2  静默失败   121
5.5.3  返回默认值       122
5.5.4  返回组装的值   122
5.5.5  返回远程缓存   123
5.5.6  主/从降级模式  124
5.6  请求缓存      127
5.7  请求合并      128
5.8  Hystrix监控  130
5.8.1  Hystrix仪表盘   131
5.8.2  Turbine仪表盘集群监控  133
5.8.3  Turbine与消息服务器集成      136
……
第6章  API服务网关——Zuul 137
第7章  统一配置中心——Config     166
第8章  分布式服务跟踪——Sleuth  192
第9章  消息驱动——Stream    215
第10章  微服务应用安全——Security    258
第3篇  微服务与Docker容器技术
第11章  微服务与Docker  288
11.1  Docker简介 288
11.2  Docker的使用    289
11.3  Docker与Spring Cloud微服务 301
11.4  微服务与Jenkins       305
11.5  微服务编排 315
显示部分信息
前　　言
前言　　2014年3月，Martin Fowler在其博客上发表了Microservices（微服务）一文，对过去几年逐渐开始流行的微服务架构开发模式给出了正式的定义。同年，Netflix OSS将自己多年来在实际开发中所使用的微服务基础组件开源。随后，Pivotal在Netflix OSS的基础上对这些组件进行了封装和集成，推出了Spring Cloud。到如今，微服务架构已逐渐普及，在技术生态上也得到了不断完善和更新，其在容器、应用框架、发布管理及监控等方面都有了长足进步。微服务在日常开发中也崭露头角，逐渐得到了开发者的认同。与此同时，Spring Cloud在过去几年中快速发展，不断迭代和更新，已经形成了微服务开发“全家桶”式的解决方案，逐渐在微服务开发领域奠定了坚实的基础。
当我第一次接触微服务的概念时，以为这又是一个“新瓶装旧酒”的把戏。就像当年一些大公司为解决分布式大型应用所提出的COBRA、EJB、DCOM和ESB等概念一样难以使用，它们甚至还没有来得及等用户完全掌握就退出了历史的舞台。当我再次注意到微服务时，是因为Spring Cloud的推出。在大致阅读了相关文档之后顺便“跑”了一下示例项目，我就被其深深吸引了。正是这次接触，使我改变了对微服务的看法。正巧接下来的一段时间，公司内部正在做架构调整，也发现了微服务有其可用之处，所以便在架构调整中引入了Spring Cloud，并最终在项目中取得了不错的效果。这加深了我对微服务的好感，所以后续对Spring Cloud进行了更加深入和系统的学习与研究。
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务架构开发实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud实战演练
第一部分　基础篇
第1章　微服务概述　　2
1.1　应用架构概述　　2
1.1.1　单体架构　　2
1.1.2　微服务架构　　3
1.1.3　如何选择架构风格　　4
1.2　微服务现状及发展趋势　　4
1.2.1　微服务现状　　4
1.2.2　微服务发展趋势　　5
1.3　微服务架构面临的挑战　　5
1.4　怎样实现微服务架构　　6
1.4.1　技术选型　　6
1.4.2　整体架构思路　　7
1.5　小结　　7
第2章　Spring Boot基础　　9
2.1　Spring Boot简介　　9
2.2　第一个Spring Boot工程　　9
2.3　使用YAML文件配置属性　　12
2.3.1　YAML的基本用法　　12
2.3.2　多环境配置　　13
2.4　常用注解　　14
2.4.1　@SpringBootApplication　　15
2.4.2　@SpringBootConfiguration　　15
2.4.3　@Bean　　16
2.4.4　@Value　　18
2.5　Spring Boot集成模板引擎　　19
2.6　更改默认的JSON转换器　　21
2.7　打包发布到服务器上　　22
2.7.1　使用内置Tomcat发布jar包　　22
2.7.2　打包成war包发布　　24
2.8　WebFlux快速入门　　27
2.9　小结　　29
第3章　Spring Boot核心原理　　31
3.1　起步依赖机制　　31
3.2　自动配置管理　　32
3.3　Actuator监控管理　　34
3.4　Spring Boot CLI命令行工具　　36
3.4.1　安装　　36
3.4.2　用法　　37
3.5　小结　　38
第4章　Spring Cloud概述　　40
4.1　简介　　40
4.2　优缺点　　41
4.3　现状　　41
4.4　开始Spring Cloud实战　　42
4.4.1　技术储备　　42
4.4.2　准备工作　　42
4.4.3　从Hello World开始你的实战之旅　　43
4.5　小结　　52
第二部分　实战篇
第5章　项目准备阶段　　54
5.1　项目介绍　　54
5.2　需求分析　　54
5.3　产品设计　　55
5.4　架构方案分析　　58
5.4.1　技术选型　　58
5.4.2　架构图设计　　58
5.4.3　根据架构图创建工程　　59
5.5　数据库结构设计　　62
5.6　小结　　63
第6章　公共模块封装　　65
6.1　common工程常用类库的封装　　65
6.1.1　日期时间的处理　　65
6.1.2　字符串的处理　　68
6.1.3　加密/解密封装　　69
6.1.4　消息队列的封装　　74
6.2　接口版本管理　　78
6.3　输入参数的合法性校验　　80
6.4　异常的统一处理　　82
6.5　更换JSON转换器　　83
6.6　Redis的封装　　84
6.7　小结　　85
第7章　注册中心：Spring Cloud Netflix Eureka　　87
7.1　Eureka简介　　87
7.2　创建注册中心　　87
7.3　创建客户端工程以验证注册中心　　91
7.4　实现注册中心的高可用　　92
7.5　添加用户认证　　96
7.6　开启自我保护模式　　99
7.7　注册中心的健康检查　　100
7.8　多网卡环境下的IP选择问题　　101
7.9　小结　　103
第8章　配置中心：Spring Cloud Config　　105
8.1　Spring Cloud Config简介　　105
8.2　创建配置中心　　105
8.3　对配置内容进行加密　　111
8.3.1　安装JCE　　111
8.3.2　对称加密　　112
8.3.3　对配置内容加密　　114
8.3.4　非对称加密　　114
8.4　配置自动刷新　　118
8.4.1　使用refresh端点刷新配置　　118
8.4.2　Spring Cloud Bus自动刷新配置　　119
8.5　添加用户认证　　122
8.6　小结　　123
第9章　服务网关：Spring Cloud Gateway　　125
9.1　Gateway简介　　125
9.2　创建服务网关　　125
9.3　利用过滤器拦截API请求　　128
9.4　请求失败处理　　130
9.5　小结　　133
第10章　功能开发　　135
10.1　开发前的准备　　135
10.1.1　MyBatis的集成　　135
10.1.2　Elasticsearch的集成　　137
10.2　利用代码生成器提升开发效率　　140
10.3　使用代码生成器生成的代码操作数据库　　147
10.4　MyBatis应对复杂SQL　　149
10.4.1　注解　　149
10.4.2　Provider　　150
10.5　功能开发　　151
10.6　网关鉴权　　154
10.6.1　防止参数被篡改　　155
10.6.2　拦截非法请求　　157
10.7　单元测试　　159
10.8　小结　　160
第三部分　高级篇
第11章　服务间通信：Spring Cloud Netflix Ribbon和Spring Cloud OpenFeign　　162
11.1　Spring Cloud Netflix Ribbon的使用　　162
11.2　Spring Cloud OpenFeign　　164
11.3　自定义OpenFeign配置　　166
11.4　Spring Cloud OpenFeign熔断　　167
11.4.1　Spring Cloud Netflix Hystrix简介　　167
11.4.2　Spring Cloud Netflix Hystrix的使用　　168
11.4.3　OpenFeign集成Hystrix熔断器　　172
11.5　小结　　173
第12章　服务链路追踪：Spring Cloud Sleuth　　175
12.1　Spring Cloud Sleuth简介　　175
12.2　利用链路追踪监听网络请求　　176
12.2.1　服务端的实现　　176
12.2.2　客户端集成Spring Cloud Sleuth　　179
12.3　通过消息中间件实现链路追踪　　180
12.4　存储追踪数据　　182
12.5　小结　　184
第13章　服务治理：Spring Cloud Consul和Spring Cloud ZooKeeper　　186
13.1　服务治理简介　　186
13.2　Spring Cloud Consul的使用　　186
13.2.1　Consul的安装与部署　　187
13.2.2　Spring Cloud集成Consul　　189
13.3　Spring Cloud ZooKeeper的使用　　190
13.3.1　ZooKeeper的安装和部署　　191
13.3.2　Spring Cloud集成ZooKeeper　　191
13.4　小结　　193
第四部分　部署篇
第14章　系统发布上线　　195
14.1　发布前准备　　195
14.1.1　虚拟机的安装　　195
14.1.2　Linux常用命令　　198
14.1.3　安装常用软件　　198
14.2　编译、打包、发布　　207
14.3　利用Jenkins实现持续集成　　210
14.3.1　安装并配置Jenkins　　210
14.3.2　创建任务　　215
14.3.3　构建项目　　220
14.4　小结　　221
第15章　使用Kubernetes部署分布式集群　　223
15.1　Docker介绍　　223
15.1.1　Docker安装　　223
15.1.2　Docker镜像　　224
15.1.3　Docker容器　　228
15.2　K8S集群环境搭建　　229
15.2.1　环境准备　　229
15.2.2　集群搭建　　230
15.2.3　分布式应用部署　　232
15.3　小结　　237
附录A　如何编写优雅的Java代码　　239
附录B　IDEA插件之Alibaba Cloud Toolkit　　258


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud实战演练
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud
第 一部分 概述和基础
第 1章 分布式和微服务概述 3
1．1 互联网系统的特征 4
1．2 分布式系统概述 4
1．2．1 分布式的切分方法 5
1．2．2 分布式系统所面临的问题 8
1．2．3 分布式的衡量标准 9
1．3 分布式系统的设计原则 10
1．3．1 CAP原则 10
1．3．2 BASE理论 11
1．4 微服务架构 12
1．4．1 概述 12
1．4．2 微服务的风格 12
1．4．3 微服务和分布式系统的关系 15
1．5 Spring Cloud 15
1．5．1 Spring Cloud的各个组件的简介 16
1．5．2 Spring Cloud版本说明 16
1．6 微服务系统样例简介 17
第 2章 技术基础 19
2．1 Spring Boot 19
2．1．1 创建Spring Boot工程 19
2．1．2 Spring Boot开发简介 21
2．1．3 多文件配置 25
2．1．4 打包和运行 27
2．1．5 Spring Boot监控 28
2．1．6 Spring Boot小结 29
2．2 REST风格简介 29
2．2．1 REST风格概述 30
2．2．2 REST风格端点开发 31
2．2．3 状态码和响应头 35
2．2．4 客户端RestTemplate的使用 38
第二部分 Spring Cloud微服务
第3章 服务治理——Eureka 43
3．1 服务治理中心 43
3．1．1 搭建Eureka服务治理中心 43
3．1．2 服务发现 47
3．1．3 多个服务治理中心实例 51
3．2 Eureka治理机制 54
3．2．1 基础架构 54
3．2．2 服务治理中心工作原理 57
3．2．3 Region和Zone 60
3．2．4 Eureka关键源码解读 62
3．2．5 Eureka使用注意点 69
3．3 Eureka配置 69
3．3．1 客户端服务注册配置 70
3．3．2 客户端服务实例配置 71
第4章 客户端负载均衡——Ribbon 73
4．1 负载均衡概述 73
4．2 初识Ribbon 74
4．2．1 Ribbon概述 74
4．2．2 Ribbon是如何实现负载均衡的 75
4．3 Ribbon负载均衡器和策略 80
4．3．1 负载均衡器 80
4．3．2 负载均衡策略 84
4．4 Ribbon服务实例清单维护 93
4．4．1 获取服务实例清单 94
4．4．2 更新服务实例清单 96
4．4．3 服务实例的心跳监测 97
4．4．4 IPing接口 99
4．5 自定义Ribbon客户端 100
4．5．1 全局配置 101
4．5．2 局部定义 101
4．6 Ribbon使用实践 103
第5章 断路器——Hystrix 105
5．1 概述 105
5．1．1 熔断的概念 105
5．1．2 服务降级 107
5．1．3 Hystrix的功能简介 108
5．2 入门实例 108
5．3 Hystrix工作原理 112
5．3．1 Hystrix命令 113
5．3．2 缓存 114
5．3．3 断路器 115
5．3．4 隔离 119
5．4 Hystrix实践 122
5．4．1 使用Hystrix命令 123
5．4．2 请求缓存 129
5．4．3 请求合并 137
5．4．4 线程池划分 145
5．5 仪表盘 146
5．5．1 单体监控 147
5．5．2 Turbine聚合监控 151
5．6 Hystrix属性配置 153
5．6．1 命令属性配置 154
5．6．2 线程池属性配置 157
第6章 新断路器——Resilience4j 158
6．1 断路器（CircuitBreaker） 160
6．1．1 断路器配置和注册机 160
6．1．2 断路器的状态 162
6．1．3 使用断路器的实例 162
6．1．4 异常处理 165
6．1．5 拾遗 166
6．2 限速器（RateLimiter） 168
6．2．1 使用实践 168
6．2．2 拾遗 170
6．3 舱壁隔离（Bulkhead） 171
6．3．1 使用舱壁隔离 171
6．3．2 拾遗 173
6．4 重试器（Retry） 173
6．4．1 使用重试机制 173
6．4．2 拾遗 175
6．5 缓存（Cache） 176
6．5．1 使用Resilience4j缓存 176
6．5．2 拾遗 178
6．6 时间限制器（TimeLimiter） 178
6．7 组件混用 179
6．8 使用Spring Boot 2的配置方式 181
6．8．1 通过配置创建断路器 181
6．8．2 通过配置创建限速器 183
第7章 声明式调用——OpenFeign 185
7．1 OpenFeign的使用 186
7．1．1 入门实例 186
7．1．2 常见的传参场景 188
7．1．3 OpenFeign客户端接口的继承 190
7．1．4 OpenFeign客户端的配置 191
7．1．5 OpenFeign的全局配置 197
7．2 配置Hystrix 199
7．2．1 使用服务降级 200
7．2．2 Hystrix中关于OpenFeign的其他配置 203
7．2．3 使用建议 204
7．3 使用Resilience4j调用OpenFeign接口 204
第8章 旧API网关——Zuul 207
8．1 什么是网关 208
8．2 Zuul入门实例 209
8．3 Zuul原理——过滤器 211
8．3．1 过滤器设计和责任链 211
8．3．2 开发过滤器 214
8．3．3 Zuul自动装配的过滤器 218
8．4 限流 220
8．4．1 Resilience4j限速器限流 220
8．4．2 spring-cloud-zuul-ratelimit限速 222
8．5 动态路由 224
8．5．1 动态路由原理 224
8．5．2 动态路由实例 226
8．6 灰度发布（金丝雀发布） 230
8．6．1 标记微服务是否为灰色发布 230
8．6．2 网关过滤 231
8．7 使用Hystrix熔断 232
第9章 新网关——Spring CloudGateway 235
9．1 认识Gateway 236
9．1．1 入门实例 237
9．1．2 Gateway执行原理 238
9．2 断言（Predicate） 242
9．2．1 Before路由断言工厂 242
9．2．2 After路由断言工厂 243
9．2．3 Between路由断言工厂 244
9．2．4 Cookie路由断言工厂 245
9．2．5 Header路由断言工厂 246
9．2．6 Host路由断言工厂 246
9．2．7 Method路由断言工厂 247
9．2．8 Path路由断言工厂 248
9．2．9 Query路由断言工厂 249
9．2．10 RemoteAddr路由断言工厂 250
9．2．11 Weight路由断言工厂 250
9．3 过滤器（Filter）概述 253
9．4 内置过滤器工厂 253
9．4．1 AddRequestHeader过滤器工厂 254
9．4．2 AddRequestParameter过滤器工厂 254
9．4．3 AddResponseHeader过滤器工厂 255
9．4．4 Retry过滤器工厂 256
9．4．5 Hystrix过滤器工厂 258
9．4．6 RequestRateLimiter过滤器工厂 259
9．4．7 StripPrefix过滤器工厂 262
9．4．8 RewritePath过滤器工厂 263
9．4．9 SetStatus过滤器工厂 264
9．4．10 小结 265
9．5 自定义过滤器 265
9．5．1 自定义过滤器——使用Resilience4j限流 265
9．5．2 全局过滤器——转发token 268
9．5．3 过滤器的顺序 269
9．6 Gateway知识补充 273
9．6．1 基于服务发现的路由 273
9．6．2 度量和动态更新路由 274
第 10章 配置——Spring Cloud Config 277
10．1 入门实例——使用Git仓库 277
10．1．1 服务端开发 278
10．1．2 客户端开发 280
10．1．3 验证配置 281
10．1．4 小结 282
10．2 使用其他方式实现配置 282
10．2．1 使用本地文件 282
10．2．2 使用SVN配置 283
10．2．3 使用数据库 284
10．3 服务端的使用详解 286
10．3．1 敏感配置加密和解密 286
10．3．2 查看配置文件和监控端点 289
10．3．3 安全认证 291
10．3．4 高可用的Config配置 293
第 11章 Spring Cloud Sleuth全链路追踪 295
11．1 链路追踪的基本概念 295
11．2 Spring Cloud Sleuth和Zipkin 297
11．3 实例 298
11．3．1 搭建Zipkin服务器 298
11．3．2 搭建服务提供者和服务消费者 300
11．3．3 搭建网关服务 303
11．3．4 查看全链路追踪 304
11．3．5 在链路中自定义样本标记属性 306
11．4 持久化 308
11．4．1 在数据库中存储链路样本 308
11．4．2 在Elasticsearch中存储链路样本 309
第 12章 微服务的监控——Spring Boot Admin 312
12．1 本章实例简介 313
12．2 URL注册方式 313
12．2．1 Admin服务端开发 313
12．2．2 Admin客户端开发 314
12．2．3 查看Admin服务端监测平台 315
12．3 服务发现注册方式 316
12．4 使用Spring Security保护Admin服务端 319
第三部分 分布式技术
第 13章 生成唯一的ID——发号机制 323
13．1 生成ID的常见办法 323
13．1．1 使用UUID 324
13．1．2 为什么不用UUID 324
13．1．3 数据库自增长 325
13．1．4 使用Redis生成ID 327
13．1．5 时钟算法 329
13．1．6 变异时钟算法——SnowFlake算法 331
13．1．7 小结 334
13．2 自定义发号机制 334
第 14章 分布式数据库技术 337
14．1 基础知识 337
14．1．1 数据库的分表、分库和分区的概念 337
14．1．2 Spring多数据源支持 339
14．2 开发环境搭建 341
14．2．1 SSM框架整合 342
14．2．2 配置多数据源 345
14．3 分片算法 350
14．3．1 哈希分片之求余算法 351
14．3．2 一致性哈希算法 352
14．3．3 热点分配法 357
14．4 分片中间件ShardingSphere 358
14．4．1 概述 358
14．4．2 ShardingSphere的重要概念 359
14．4．3 ShardingSphere的分片 360
14．4．4 实例 361
14．4．5 结束语 363
第 15章 分布式数据库事务 364
15．1 强一致性事务 364
15．1．1 两阶段提交协议——XA协议 365
15．1．2 三阶段提交协议 371
15．1．3 为什么微服务不适合使用强一致性事务 372
15．2 弱一致性事务 373
15．2．1 本节样例模型和冲正交易的概念 374
15．2．2 使用状态表 375
15．2．3 使用可靠消息源——RabbitMQ 376
15．2．4 提高尝试次数和幂等性 380
15．2．5 TCC补偿事务 381
15．2．6 小结 383
15．3 分布式事务应用的实践理论 383
15．3．1 什么时候使用分布式事务 383
15．3．2 数据修复思路 384
第 16章 分布式缓存——Redis 387
16．1 Redis的高可用 388
16．1．1 哨兵模式 389
16．1．2 Redis集群 394
16．2 使用一致性哈希（ShardedJedis） 402
16．3 分布式缓存实践 403
16．3．1 大对象的缓存 403
16．3．2 缓存穿透、并发和雪崩 404
16．3．3 缓存实践的一些建议 406
第 17章 分布式会话 407
17．1 分布式会话的几种方式 407
17．2 黏性会话 408
17．3 服务器会话复制 408
17．4 使用缓存（spring-session-data-redis） 409
17．5 持久化到数据库 411
第 18章 分布式系统权限验证 412
18．1 Spring Security 412
18．1．1 简单使用Spring Security 413
18．1．2 使用自定义用户验证 415
18．1．3 使用缓存共享实现分布式权限 421
18．1．4 跨站点请求伪造（CSRF）攻击 423
18．1．5 使用自定义页面 425
18．2 自定义微服务权限控制 427
18．2．1 基础包开发 428
18．2．2 开发Eureka客户端 432
18．2．3 网关开发 434
18．2．4 服务调用 438
18．3 OAuth 2．0概述 441
18．3．1 OAuth的概念和流程 441
18．3．2 使用JWT进行安全认证 443
18．3．3 spring-security-oauth2 444
18．4 Spring Cloud Security 445
18．4．1 构建认证服务器 446
18．4．2 开发SSO客户端 450
18．4．3 测试 453
第四部分 微服务系统实践
第 19章 远程过程调用 459
19．1 远程过程调用 459
19．1．1 REST风格服务调用性能测试 459
19．1．2 RPC入门 460
19．1．3 RPC和REST风格服务调用的对比 461
19．2 Thrift简介 462
19．2．1 配置Thrift 462
19．2．2 Thrift的数据结构和服务接口 463
19．2．3 开发业务逻辑 464
19．2．4 启动Thrift服务器 465
19．2．5 Thrift客户端 466
19．2．6 使用断路器保护服务调用 468
19．3 RPC小结 469
第 20章 微服务设计和高并发实践 470
20．1 微服务设计原则 470
20．1．1 服务拆分方法 470
20．1．2 微服务的设计原则 471
20．1．3 微服务架构 471
20．2 高并发系统的一些优化经验 472
20．2．1 提高性能 473
20．2．2 服务高可用 479
20．3 简易微服务系统实例 488
20．3．1 服务治理中心（ms-eureka） 489
20．3．2 搭建产品微服务（ms-product） 490
20．3．3 网关微服务开发（ms-zuul） 498
20．3．4 资金微服务（ms-fund） 508
20．3．5 服务实例监测平台（ms-admin） 510
20．3．6 Hystrix仪表盘（ms-dashboard） 511
20．3．7 服务链路追踪（ms-sleuth） 512
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务架构实战
第一部分 架构
第1章 微服务架构与Spring Cloud  2
1.1 微服务架构的特点  2
1.2 微服务架构与整体式架构的区别  4
1.3 微服务架构与SOA的比较  7
1.4 微服务架构的优势  8
1.5 为实施微服务架构做好准备  9
1.5.1 思想观念  9
1.5.2 团队管理  10
1.5.3 自动化基础设施  10
1.6 Spring Cloud的优势  11
1.7 Spring Cloud工具套件介绍  12
1.8 Spring Cloud的版本说明  15
1.9 小结  15
第2章 高并发微服务架构设计  16
2.1 微服务总体架构设计  16
2.2 自然的压力分解  18
2.3 可弹性伸缩的集群环境  18
2.4 高度的独立性设计  19
2.5 API 的分层调用关系  19
2.6 高可用的基础资源支持  20
2.7 快速响应的自动化基础设施  21
2.8 完善的监控体系  21
2.9 微服务的安全保障  21
2.10 小结  22
第3章 大型电商平台设计实例  23
3.1 电商平台总体设计  23
3.1.1 总体业务流程设计  23
3.1.2 总体业务功能设计  25
3.2 电商平台业务模型设计  25
3.2.1 移动商城业务模型  26
3.2.2 商家管理后台业务模型  26
3.2.3 平台管理后台业务模型  27
3.3 合理划分微服务  28
3.4 创建REST API 微服务  29
3.5 创建Web UI微服务  30
3.5.1 移动商城Web UI微服务  30
3.5.2 商家管理后台的Web UI微服务  31
3.5.3 平台管理后台Web UI微服务  31
3.6 电商平台微服务体系架构  32
3.7 电商平台微服务项目工程  33
3.8 微服务项目数据库选型  33
3.9 电商平台微服务项目代码库  34
3.10 小结  34
第二部分 程序开发
第4章 开发环境准备  36
4.1 选择Java SDK的版本  36
4.2 下载InterlliJ IDEA  37
4.3 下载及配置Git 客户端  37
4.4 创建Spring Cloud项目  38
4.5 小结  39
第5章 微服务治理  40
5.1 使用Consul 创建注册中心  41
5.1.1 服务注册与发现  42
5.1.2 统一配置管理  44
5.2 合理发挥断路器的作用  46
5.3 如何实现有效的监控  47
5.3.1 服务健康状态监控  47
5.3.2 重大故障告警  49
5.3.3 断路器仪表盘  49
5.4 Zipkin链路跟踪  52
5.5 ELK日志分析平台  55
5.5.1 创建日志分析平台  55
5.5.2 使用日志分析平台  56
5.6 小结  57
第6章 类目管理微服务开发  58
6.1 了解领域驱动设计  58
6.1.1 DDD的分层结构  59
6.1.2 DDD的基本元素  59
6.2 Spring Data JPA  59
6.2.1 Druid数据源配置  60
6.2.2 JPA初始化和基本配置  62
6.3 实体建模  63
6.4 查询对象设计  65
6.5 数据持久化设计  66
6.6 数据管理服务设计  68
6.7 单元测试  70
6.8 类目接口微服务开发  71
6.8.1 RESTful接口开发  71
6.8.2 微服务接口调试  73
6.9 基于RESTful 的微服务接口调用  74
6.9.1 声明式FeignClient 设计  74
6.9.2 断路器的使用  76
6.10 类目管理Web 应用微服务开发  76
6.10.1 接口调用引用相关配置  77
6.10.2 Spring MVC控制器设计  77
6.11 使用Thymeleaf 模板  78
6.11.1 HTML页面设计  79
6.11.2 统一风格模板设计  80
6.12 总体测试  82
6.13 有关项目打包与部署  83
6.14 小结  84
第7章 库存管理与分布式文件系统  85
7.1 基于MyBatis 的数据库开发  85
7.1.1 使用经过组装的MyBatis 组件  85
7.1.2 数据对象及其表结构定义  86
7.1.3 Mapper与SQL定制  88
7.2 数据库服务组装  89
7.3 单元测试  91
7.4 库存微服务接口开发  92
7.4.1 在主程序中支持MyBatis  92
7.4.2 基于REST协议的控制器设计  93
7.5 库存管理的Web 应用开发  94
7.5.1 公共对象的依赖引用  95
7.5.2 商品分页数据调用设计  95
7.6 Web 应用项目热部署设置  97
7.7 使用分布式文件系统DFS  99
7.7.1 分布式文件系统客户端开发  99
7.7.2 商品图片上传设计  102
7.7.3 富文本编辑器上传图片设计  106
7.7.4 建立本地文件信息库  108
7.8 总体测试  112
7.9 小结  114
第8章 海量订单系统微服务开发  115
8.1 使用MongoDB 支持海量数据  115
8.1.1 使用Mongo插件  115
8.1.2 MongoDB数据源相关配置  116
8.2 订单文档建模  117
8.2.1 订单及其明细数据  117
8.2.2 订单状态枚举  119
8.3 反应式MongoDB编程设计  121
8.3.1 基于Spring Data的存储库接口设计  121
8.3.2 动态分页查询设计  121
8.4 Mongo单元测试  123
8.5 订单接口微服务开发  125
8.6 订单的分布式事务管理  127
8.6.1 订单取消的消息生成  127
8.6.2 订单取消的库存变化处理  129
8.7 订单管理后台微服务开发  131
8.7.1 订单查询主页设计  131
8.7.2 订单状态修改设计  133
8.8 集成测试  135
8.9 小结  137
第9章 移动商城的设计和开发  138
9.1 移动商城首页设计  139
9.2 商城的分类查询设计  143
9.3 商品详情页设计  145
9.4 用户下单功能实现  147
9.5 商城的用户登录与账户切换设计  152
9.5.1 用户登录设计  152
9.5.2 切换账号设计  155
9.6 订单查询设计  156
9.7 集成测试  160
9.8 小结  162
第10 章 商家管理后台与SSO 设计  163
10.1 商家权限体系的设计及开发  164
10.1.1 权限管理模型设计  165
10.1.2 权限管理模型的持久化设计  170
10.1.3 权限管理模型的服务封装  171
10.2 商家管理微服务设计  175
10.2.1 商家管理服务层单元测试  175
10.2.2 商家服务的接口开发  178
10.3 SSO设计  183
10.3.1 SSO的基本配置  183
10.3.2 SSO第三方应用授权设计  184
10.3.3 SSO登录认证设计  186
10.3.4 有关验证码的说明  191
10.3.5 SSO的主页设计  193
10.4 SSO客户端设计  196
10.4.1 安全认证的项目管理配置  196
10.4.2 安全认证项目的配置类  196
10.4.3 权限管理验证设计  198
10.4.4 客户端应用接入SSO  201
10.4.5 有关跨站请求的相关设置  203
10.4.6 根据用户权限自动分配菜单  203
10.5 小结  206
第11 章 平台管理后台与商家菜单资源管理  207
11.1 平台管理后台访问控制设计  207
11.1.1 实体建模  207
11.1.2 为实体赋予行为  210
11.1.3 数据访问服务设计  210
11.1.4 单元测试  213
11.2 平台管理后台的访问控制设计  214
11.2.1 在访问控制中使用操作员  215
11.2.2 平台管理后台的权限管理设计  215
11.3 商家的注册管理设计  219
11.4 商家权限及其菜单资源管理设计  222
11.4.1 分类菜单管理设计  222
11.4.2 模块菜单管理设计  224
11.4.3 资源菜单管理设计  228
11.5 商家角色管理设计  232
11.6 小结  236
第三部分 运维部署
第12 章 云服务环境与Docker 部署工具  238
12.1 虚拟机与基于Docker 创建的容器  238
12.2 安全可靠的云服务环境  239
12.3 Docker和docker-compose 的下载与配置  240
12.3.1 Docker引擎的安装及使用  240
12.3.2 docker-compose的下载及配置  241
12.4 使用Docker方式发布微服务  242
12.4.1 镜像创建及其生成脚本  242
12.4.2 服务发布与更新  243
12.5 使用Docker部署日志分析平台  243
12.6 基于Docker的高级部署工具  246
12.6.1 私域镜像仓库  246
12.6.2 Docker Swarm  247
12.6.3 Kubernetes  249
12.7 小结  253
第13 章 可扩展分布式数据库集群的搭建  254
13.1 MySQL 集群主机分配  255
13.2 主从同步设置  256
13.3 主主同步设置  259
13.4 数据库代理中间件选择  261
13.5 使用OneProxy 实现读写分离设计  261
13.5.1 安装OneProxy  262
13.5.2 高可用读写分离配置  263
13.6 OneProxy 分库分区设计  267
13.6.1 按范围分库分表  268
13.6.2 按值列表分库分表  268
13.6.3 按散列算法分库分表  269
13.7 双机热备设计  271
13.7.1 Real Server配置  272
13.7.2 LVS主机配置  273
13.7.3 LVS备用机配置  275
13.8 小结  277
第14 章 高可用分布式文件系统的组建  278
14.1 FastDFS 架构  278
14.2 FastDFS 的安装  279
14.3 跟踪服务器配置  280
14.4 存储节点配置  281
14.5 上传文件测试  282
14.6 Nginx的安装及负载均衡配置  283
14.6.1 在跟踪器上安装Nginx  283
14.6.2 在存储节点上安装Nginx  285
14.7 开机启动  287
14.7.1 开机启动Tracker  287
14.7.2 开机启动Storage  289
14.7.3 开机启动Nginx  291
14.8 小结  293
第15 章 使用Jenkins 实现自动化构建  294
15.1 持续交付工作流程  295
15.2 Jenkins的安装  296
15.3 Jenkins的基本配置  298
15.4 Jenkins的自动部署实例  300
15.4.1 创建任务  300
15.4.2 任务配置  301
15.4.3 执行任务  305
15.5 小结  309
后记  310
参考文献  311
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务架构实战
