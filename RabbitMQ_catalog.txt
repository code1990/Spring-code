>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>RabbitMQ实战
第1章 天降奇兵 1
1.1 住在别人的地下城堡 3
1.2 救世主AMQP 5
1.3 RabbitMQ简史 5
1.4 百里挑一 8
1.5 在UNIX系统上安装RabbitMQ 8
1.5.1 为什么环境很重要--生活在Erlang 的世界里 9
1.5.2 获取安装包 9
1.5.3 设置文件夹结构 9
1.5.4 首次运行Rabbit 10
1.6 总结 12
第2章 理解消息通信13
2.1 消费者和生产者（这可不是经济学课程哦） 14
2.2 从底部开始构造：队列 17
2.3 联合起来：交换器和绑定 22
2.4 多租户模式：虚拟主机和隔离 27
2.5 我的消息去哪儿了呢？持久化和你的策略 28
2.6 把所有内容结合起来：一条消息的一生 32
2.7 使用发送方确认模式来确认投递 37
2.8 总结 40
第3章 运行和管理Rabbit 42
3.1 服务器管理 43
3.1.1 启动节点 43
3.1.2 停止节点 45
3.1.3 关闭和重启应用程序：有何差别 46
3.1.4 Rabbit 配置文件 46
3.2 请求许可 48
3.2.1 管理用户 49
3.2.2 Rabbit 的权限系统 50
3.3 检查 54
3.3.1 查看数据统计 54
3.3.2 理解RabbitMQ 日志 59
3.4 修复Rabbit：疑难解答 63
由badrpc、nodedown 和其他Erlang 引起的问题 63
3.5 总结 68
第4章 解决Rabbit相关问题：编码与模式69
4.1 解耦风雨路：谁将我们推向消息通信 70
4.1.1 异步状态思维（分离请求和动作） 70
4.1.2 提供扩展性：没有负载均衡器的世界 73
4.1.3 零成本API ：语言不应成为枷锁 73
4.2 发后即忘模型 74
4.2.1 发送告警 75
4.2.2 并行处理 84
4.3 别忘了：用RabbitMQ实现RPC并等待响应 92
4.3.1 私有队列和发送确认 93
4.3.2 使用reply_to 来实现简单的JSON RPC 93
4.4 总结 98
第5章 集群并处理失败99
5.1 开足马力：RabbitMQ集群 100
5.2 集群架构 101
5.2.1 集群中的队列 101
5.2.2 分布交换器 103
5.2.3 是内存节点还是磁盘节点 104
5.3 在你的笔记本电脑上设置集群 106
5.4 将节点分布到更多的机器上 110
5.5 升级集群节点 114
5.6 镜像队列和保留消息 115
5.6.1 声明并使用镜像队列 115
5.6.2 镜像队列工作原理 118
5.7 总结 120
第6章 从故障中恢复121
6.1 为Rabbit做负载均衡 122
6.1.1 安装HAProxy 124
6.1.2 配置HAProxy 125
6.2 连接丢失和故障转移 127
6.3 总结 134
第7章 warren和Shovel：故障转移和复制 135
7.1 warren：另一种集群方式 136
7.2 设定负载均衡器--基于主/从的集群 138
7.3 远距离通信和复制 142
7.3.1 给Rabbit 装备Shovel ：Shovel 插件介绍 142
7.3.2 安装Shovel 145
7.3.3 配置并运行Shovel 146
7.4 总结 152
第8章 从Web端管理RabbitMQ 154
8.1 超越rabbitmqctl：RabbitMQ Management插件 155
8.1.1 为何需要Management 插件 155
8.1.2 Management 插件功能 155
8.1.3 启用Management 插件 156
8.2 从Web控制台来管理RabbitMQ 158
8.2.1 监控Erlang VM 158
8.2.2 从JSON 文件导入配置 159
8.3 从Web控制台管理用户 160
8.3.1 创建用户 161
8.3.2 管理用户的权限 162
8.4 从Web控制台管理交换器和队列 163
8.4.1 列出队列信息 165
8.4.2 创建队列 166
8.5 回到命令行 168
8.5.1 为什么需要另一个CLI 168
8.5.2 CLI 管理：一种更简单的方式 170
8.5.3 安装rabbitmqadmin 脚本 170
8.5.4 清空队列、创建交换器等 171
8.6 总结 172
第9章 使用REST API控制Rabbit 173
9.1 能用RabbitMQ REST API做什么 175
9.2 对客户端授权访问 177
9.3 访问数据统计 178
9.4 自动化vhost和用户配置 181
9.5 总结 .186
第10章 监控187
10.1 监控RabbitMQ：密切关注你的warren 188
10.1.1 为Nagios 编写健康检测 188
10.1.2 使用AMQP 模拟检测来确认RabbitMQ 是否运行 190
10.1.3 使用REST API 来检测 193
10.1.4 监控配置文件修改 196
10.1.5 监控集群状态 201
10.2 确保消费者正常工作 206
10.2.1 通过AMQP 监控队列等级 208
10.2.2 使用REST API 来监控队列级别 212
10.2.3 建立队列的消息计数基准经验法则 215
10.3 总结216
第11章 提升性能，保障安全217
11.1 对速度的需求 218
11.1.1 消息持久化 218
11.1.2 消息确认 219
11.1.3 路由算法和绑定规则 219
11.1.4 投递消息 221
11.2 内存使用率和进程限制 223
11.2.1 内存使用率 223
11.2.2 Erlang 进程计数 226
11.3 SSL连接 ..227
11.3.1 SSL 证书.228
11.3.2 设置证书颁发机构 ..229
11.3.3 生成根证书 233
11.3.4 生成服务器端证书 234
11.3.5 生成客户端证书 235
11.3.6 启用RabbitMQ 的SSL 监听器 236
11.3.7 测试你的RabbitMQ SSL 设置 237
11.4 总结 239
第12章 聪明的Rabbit：扩展RabbitMQ241
12.1 RabbitMQ插件 242
12.1.1 你可以用插件做什么 242
12.1.2 在哪里可以找到插件 244
12.1.3 安装插件 244
12.1.4 移除插件 245
12.2 制作你自己的插件 247
12.2.1 获取RabbitMQ Public Umbrella 248
12.2.2 设置文件夹结构 249
12.2.3 包含插件构建系统 250
12.2.4 创建Erlang 应用文件 250
12.3 创建自定义交换器模块 252
12.3.1 将交换器注册到RabbitMQ 254
12.3.2 实现交换器behaviour 257
12.3.3 编译自定义交换器 264
12.3.4 测试你的插件 267
12.4 总结 271
附录A 在Java和.NET上使用Rabbit 273
附录B 在线资源302
附录C 在Windows上安装RabbitMQ 307
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>RabbitMQ实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot实战派
目录
+++++++++入 门 篇
第1章  进入Spring Boot世界  /2
1.1  认识Spring Boot  /2
∣1.1.1  什么是Spring Boot  /2
∣1.1.2  Spring、Spring Boot、Spring Cloud的关系  /4
∣1.1.3  Spring Boot的特色  /5
∣1.1.4  Spring Boot支持的开发语言  /6
∣1.1.5  学习Spring Boot的前景展望  /6
1.2  学习Spring Boot的建议  /7
∣1.2.1  看透本书理论，模仿实战例子  /7
∣1.2.2  利用开发工具自动学习  /7
∣1.2.3  发现新功能的方法  /8
∣1.2.4  建立高阶的思维方式  /9
∣1.2.5  控制版本，降低犯错的代价  /10
∣1.2.6  获取最新、最全的资料  /11
∣1.2.7  学会自己发现和解决问题  /11
∣1.2.8  善于提问，成功一半  /12
第2章  准备开发环境  /14
2.1  搭建环境  /14
∣2.1.1  安装Java开发环境JDK  /14
∣2.1.2  配置JDK的环境变量  /15
2.2  熟悉Maven  /18
∣2.2.1  安装及配置Maven  /18
∣2.2.2  认识其中的pom.xml文件  /19
∣2.2.3  Maven的运作方式  /23
∣2.2.4  配置国内仓库  /23
第3章  使用开发工具  /25
3.1  安装开发工具IDEA及插件  /25
∣3.1.1  安装IDEA  /25
∣3.1.2  配置IDEA的Maven环境  /27
∣3.1.3  安装Spring Assistant插件  /27
∣3.1.4  安装插件Lombok  /28
3.2  【实例1】用Spring Boot输出“Hello World”  /30
∣3.2.1  构建Spring Boot项目  /30
∣3.2.2  编写控制器，实现输出功能  /31
∣3.2.3  在IDEA中运行程序  /33
∣3.2.4  打包成可执行的JAR包  /33
3.3  在Eclipse中开发Spring Boot应用程序  /35
∣3.3.1  安装Eclipse  /35
∣3.3.2  安装Spring Tools 4插件  /35
∣3.3.3  配置Eclipse的Maven环境  /36
∣3.3.4  创建Spring Boot项目  /37
3.4  了解Spring官方开发工具STS  /37
3.5  必会的IDEA实用技能  /38
∣3.5.1  智能提示代码  /38
∣3.5.2  自动提示参数  /39
∣3.5.3  实现自动转义  /39
∣3.5.4  自定义高复用代码块  /40
∣3.5.5  设置注释信息  /41
∣3.5.6  超能的“Alt+Enter”快捷键  /42
∣3.5.7  使用全局配置  /42
∣3.5.8  自动生成语句  /43
3.6  比较IDEA与Eclipse  /44
3.7  如何使用本书源代码  /47
∣3.7.1  在IDEA中使用  /47
∣3.7.2  在Eclipse（STS）中使用  /47
∣
+++++++++基 础 篇
第4章  Spring Boot基础  /50
4.1  了解Spring Boot  /50
∣4.1.1  了解Spring Boot项目结构  /50
∣4.1.2  了解Spring Boot的入口类  /51
∣4.1.3  了解Spring Boot的自动配置  /52
∣4.1.4  了解Spring Boot热部署  /52
∣4.1.5  【实例2】定制启动画面  /53
4.2  Spring Boot的常用注解  /54
∣4.2.1  什么是注解式编程  /55
∣4.2.2  了解系统注解  /55
∣4.2.3  Spring Boot的常用注解  /56
4.3  使用配置文件  /61
∣4.3.1  【实例3】演示如何使用application.yml文件  /62
∣4.3.2  【实例4】演示如何使用application.properties文件  /65
∣4.3.3  【实例5】用application.yml和application.properties配置多环境  /67
4.4  Spring Boot的Starter  /69
∣4.4.1  了解Starter  /69
∣4.4.2  使用Starter  /70
第5章  分层开发Web应用程序  /71
5.1  应用程序分层开发模式——MVC  /71
∣5.1.1  了解MVC模式  /71
∣5.1.2  MVC和三层架构的关系  /72
5.2  使用视图技术Thymeleaf  /73
∣5.2.1  认识Thymeleaf  /73
∣5.2.2  基础语法  /75
∣5.2.3  处理循环遍历  /78
∣5.2.4  处理公共代码块  /80
∣5.2.5  处理分页  /81
∣5.2.6  验证和提示错误消息  /82
∣5.2.7  【实例6】编写Thymeleaf视图以展示数据  /83
5.3  使用控制器  /85
∣5.3.1  常用注解  /85
∣5.3.2  将URL映射到方法  /86
∣5.3.3  处理HTTP请求的方法  /87
∣5.3.4  处理内容类型  /89
∣5.3.5  在方法中使用参数  /90
5.4  理解模型  /93
5.5  【实例7】实现MVC模式的Web应用程序  /94
∣5.5.1  添加依赖  /94
∣5.5.2  创建实体模型  /95
∣5.5.3  创建控制器  /95
∣5.5.4  创建用于展示的视图  /96
5.6  验证数据  /96
∣5.6.1  认识内置的验证器Hibernate∣validator  /96
∣5.6.2  自定义验证功能  /98
∣5.6.3  【实例8】验证表单数据并实现数据的自定义验证  /99
第6章  响应式编程  /103
6.1  认识响应式编程  /103
∣6.1.1  什么是WebFlux  /103
∣6.1.2  比较MVC和WebFlux  /103
∣6.1.3  认识Mono和Flux  /105
∣6.1.4  开发WebFlux的流程  /106
6.2  【实例9】用注解式开发实现Hello World  /107
∣6.2.1  配置WebFlux依赖  /107
∣6.2.2  编写控制器  /107
6.3  【实例10】用注解式开发实现数据的增、删、改、查  /108
∣6.3.1  创建实体类  /108
∣6.3.2  编写控制器  /108
∣6.3.3  测试API功能  /110
6.4  【实例11】用响应式开发方式开发WebFlux  /111
∣6.4.1  编写处理器类Handler  /111
∣6.4.2  编写路由器类Router  /112
6.5  【实例12】用WebFlux模式操作MongoDB数据库,实现数据的增、删、改、查功能  /112
∣6.5.1  添加依赖  /112
∣6.5.2  创建实体类  /113
∣6.5.3  编写接口  /113
6.5.4  编写增、删、改、查数据的API  /113
∣
+++++++++进 阶 篇
第7章  Spring Boot进阶  /118
7.1  面向切面编程  /118
∣7.1.1  认识Spring AOP  /118
∣7.1.2  【实例13】用AOP方式管理日志  /119
7.2  认识IoC容器和Servlet容器  /121
∣7.2.1  认识容器  /121
∣7.2.2  【实例14】用IoC管理Bean  /123
∣7.2.3  【实例15】用Servlet处理请求  /125
7.3  过滤器与监听器  /126
∣7.3.1  认识过滤器  /126
∣7.3.2  【实例16】实现过滤器  /128
∣7.3.3  认识监听器  /128
∣7.3.4  【实例17】实现监听器  /129
7.4  自动配置  /130
∣7.4.1  自定义入口类  /130
∣7.4.2  自动配置的原理  /131
∣7.4.3  【实例18】自定义Starter  /133
7.5  元注解  /136
∣7.5.1  了解元注解  /136
∣7.5.2  【实例19】自定义注解  /137
7.6  异常处理  /138
∣7.6.1  认识异常处理  /138
∣7.6.2  使用控制器通知  /141
∣7.6.3  【实例20】自定义错误处理控制器  /142
∣7.6.4  【实例21】自定义业务异常类  /143
7.7  单元测试  /145
∣7.7.1  了解单元测试  /145
∣7.7.2  Spring Boot 的测试库  /145
∣7.7.3  快速创建测试单元  /149
∣7.7.4  【实例22】Controller层的单元测试  /150
∣7.7.5  【实例23】Service层的单元测试  /153
∣7.7.6  【实例24】Repository层的单元测试  /154
第8章  用ORM操作SQL数据库  /156
8.1  认识Java的数据库连接模板JDBCTemplate  /156
∣8.1.1  认识JDBCTemplate  /156
∣8.1.2  【实例25】用JDBCTemplate实现数据的增、删、改、查  /157
∣8.1.3  认识ORM  /161
8.2  JPA——Java持久层API  /161
∣8.2.1  认识Spring Data  /161
∣8.2.2  认识JPA  /162
∣8.2.3  使用JPA  /164
∣8.2.4  了解JPA注解和属性  /165
∣8.2.5  【实例26】用JPA构建实体数据表  /167
8.3  认识JPA的接口  /169
∣8.3.1  JPA接口JpaRepository  /169
∣8.3.2  分页排序接口PagingAndSortingRepository  /169
∣8.3.3  数据操作接口CrudRepository  /170
∣8.3.4  分页接口Pageable和Page  /170
∣8.3.5  排序类Sort  /171
8.4  JPA的查询方式  /171
∣8.4.1  使用约定方法名  /171
∣8.4.2  用JPQL进行查询  /173
∣8.4.3  用原生SQL进行查询  /174
∣8.4.4  用Specifications进行查询  /175
∣8.4.5  用ExampleMatcher进行查询  /177
∣8.4.6  用谓语QueryDSL进行查询  /177
∣8.4.7  用NamedQuery进行查询  /177
8.5  【实例27】用JPA开发文章管理模块  /178
∣8.5.1  实现文章实体  /178
∣8.5.2  实现数据持久层  /179
∣8.5.3  实现服务接口和服务接口的实现类  /179
∣8.5.4  实现增、删、改、查的控制层API功能  /180
∣8.5.5  实现增、删、改、查功能的视图层  /182
8.6  实现自动填充字段  /185
8.7  掌握关系映射开发  /187
∣8.7.1  认识实体间关系映射  /187
∣8.7.2  【实例28】实现“一对一”映射  /188
∣8.7.3  【实例29】实现“一对多”映射  /192
∣8.7.4  【实例30】实现“多对多”映射  /195
8.8  认识MyBatis——Java数据持久层框架  /197
∣8.8.1  CRUD注解  /198
∣8.8.2  映射注解  /198
∣8.8.3  高级注解  /199
8.9  【实例31】用MyBatis实现数据的增加、删除、修改、查询和分页  /200
∣8.9.1  创建Spring Boot项目并引入依赖  /201
∣8.9.2  实现数据表的自动初始化  /201
∣8.9.3  实现实体对象建模  /202
∣8.9.4  实现实体和数据表的映射关系  /202
∣8.9.5  实现增、删、改、查功能  /203
∣8.9.6  配置分页功能  /204
∣8.9.7  实现分页控制器  /205
∣8.9.8  创建分页视图  /206
8.10  比较JPA与MyBatis  /207
第9章  接口架构风格——RESTful  /209
9.1  REST——前后台间的通信方式  /209
∣9.1.1  认识REST  /209
∣9.1.2  认识HTTP方法与CRUD动作映射  /210
∣9.1.3  实现RESTful风格的数据增、删、改、查  /210
9.2  设计统一的RESTful风格的数据接口  /212
∣9.2.1  版本控制  /212
∣9.2.2  过滤信息  /213
∣9.2.3  确定HTTP的方法  /213
∣9.2.4  确定HTTP的返回状态  /213
∣9.2.5  定义统一返回的格式  /214
9.3  【实例32】为手机APP、PC、H5网页提供统一风格的API  /214
∣9.3.1  实现响应的枚举类  /214
∣9.3.2  实现返回的对象实体  /215
∣9.3.3  封装返回结果  /215
∣9.3.4  统一处理异常  /215
∣9.3.5  编写测试控制器  /219
∣9.3.6  实现数据的增、删、改、查控制器  /220
∣9.3.7  测试数据  /221
9.4  【实例33】用Swagger实现接口文档  /222
∣9.4.1  配置Swagger  /222
∣9.4.2  编写接口文档  /224
9.5  用RestTemplate发起请求  /224
∣9.5.1  认识RestTemplate  /224
∣9.5.2  【实例34】用RestTemplate发送GET请求  /225
∣9.5.3  【实例35】用RestTemplate发送POST请求  /228
∣9.5.4  用RestTemplate发送PUT和DELETE请求  /231
第10章  集成安全框架，实现安全认证和授权  /233
10.1  Spring Security——Spring的安全框架  /233
∣10.1.1  认识Spring Security  /233
∣10.1.2  核心类  /235
10.2  配置Spring Security  /240
∣10.2.1  继承WebSecurityConfigurer Adapter  /240
∣10.2.2  配置自定义策略  /240
∣10.2.3  配置加密方式  /242
∣10.2.4  自定义加密规则  /242
∣10.2.5  配置多用户系统  /242
∣10.2.6  获取当前登录用户信息的几种方式  /244
10.3  【实例36】用Spring Security实现后台登录及权限认证功能  /246
∣10.3.1  引入依赖  /246
∣10.3.2  创建权限开放的页面  /246
∣10.3.3  创建需要权限验证的页面  /247
∣10.3.4  配置Spring Security  /247
∣10.3.5  创建登录页面  /248
∣10.3.6  测试权限  /249
10.4  权限控制方式  /249
∣10.4.1  Spring EL权限表达式  /249
∣10.4.2  通过表达式控制URL权限  /250
∣10.4.3  通过表达式控制方法权限  /252
∣10.4.4  【实例37】使用JSR∣250注解  /254
∣10.4.5  【实例38】实现RBAC权限模型  /256
10.5  认识JWT  /258
10.6  【实例39】用JWT技术为Spring Boot的API增加认证和授权保护  /260
∣10.6.1  配置安全类  /260
∣10.6.2  处理注册  /261
∣10.6.3  处理登录  /262
∣10.6.4  测试多方式注册和登录  /264
∣10.6.5  测试token方式登录和授权  /265
10.7  Shiro——Apache通用安全框架  /266
∣10.7.1  认识Shiro安全框架  /266
∣10.7.2  认识Shiro的核心组件  /267
10.8  【实例40】用Shiro实现管理后台的动态权限功能  /267
∣10.8.1  创建实体  /267
∣10.8.2  实现视图模板  /270
∣10.8.3  进行权限配置  /271
∣10.8.4  实现认证身份功能  /271
∣10.8.5  测试权限  /272
10.9   对比Spring Security与Shiro  /273
第11章  集成Redis，实现高并发  /275
11.1  认识Spring Cache  /275
∣11.1.1  声明式缓存注解  /276
∣11.1.2  【实例41】用Spring Cache进行缓存管理  /278
∣11.1.3  整合Ehcache  /281
∣11.1.4  整合Caffeine  /281
11.2  认识Redis  /282
∣11.2.1  对比Redis与Memcached  /282
∣11.2.2  Redis的适用场景  /285
11.3  Redis的数据类型  /285
11.4  用RedisTemplate操作Redis的5种数据类型  /287
∣11.4.1  认识opsFor方法  /287
∣11.4.2  【实例42】操作字符串  /287
∣11.4.3  【实例43】操作散列  /290
∣11.4.4  【实例44】操作列表  /294
∣11.4.5  【实例45】操作集合  /298
∣11.4.6  【实例46】操作有序集合  /301
∣11.4.7  比较RedisTemplate和StringRedisTemplate  /306
11.5  【实例47】用Redis和MyBatis完成缓存数据的增加、删除、修改、查询功能  /306
∣11.5.1  在Spring Boot中集成Redis  /306
∣11.5.2  配置Redis类  /307
∣11.5.3  创建测试实体类  /308
∣11.5.4  实现实体和数据表的映射关系  /309
∣11.5.5  创建Redis缓存服务层  /309
∣11.5.6  完成增、删、改、查测试API  /310
11.6  【实例48】用Redis和JPA实现缓存文章和点击量  /311
∣11.6.1  实现缓存文章  /311
∣11.6.2  实现统计点击量  /312
∣11.6.3  实现定时同步  /312
11.7  【实例49】实现分布式Session  /313
∣11.7.1  用Redis实现Session共享  /313
∣11.7.2  配置Nginx实现负载均衡  /314
第12章  集成RabbitMQ，实现系统间的数据交换  /316
12.1  认识RabbitMQ  /316
∣12.1.1  介绍RabbitMQ  /316
∣12.1.2  使用场景  /317
∣12.1.3  特性  /318
12.2  RabbitMQ的基本概念  /318
∣12.2.1  生产者、消费者和代理  /318
∣12.2.2  消息队列  /319
∣12.2.3  交换机  /319
∣12.2.4  绑定  /320
∣12.2.5  通道  /321
∣12.2.6  消息确认  /321
12.3  RabbitMQ的6种工作模式  /321
∣12.3.1  简单模式  /321
∣12.3.2  工作队列模式  /321
∣12.3.3  交换机模式  /322
∣12.3.4  Routing转发模式  /322
∣12.3.5  主题转发模式  /322
∣12.3.6  RPC模式  /323
12.4  认识AmqpTemplate接口  /323
∣12.4.1  发送消息  /324
∣12.4.2  接收消息  /324
∣12.4.3  异步接收消息  /325
12.5  在Spring Boot中集成RabbitMQ  /325
∣12.5.1  安装RabbitMQ  /325
∣12.5.2  界面化管理RabbitMQ  /326
∣12.5.3  在Spring Boot中配置RabbitMQ  /327
12.6  在Spring Boot中实现RabbitMQ的4种发送/接收模式  /328
∣12.6.1  【实例50】实现发送和接收队列  /328
∣12.6.2  【实例51】实现发送和接收对象  /330
∣12.6.3  【实例52】实现用接收器接收多个主题  /331
∣12.6.4  【实例53】实现广播模式  /334
12.7  【实例54】实现消息队列延迟功能  /336
第13章  集成NoSQL数据库，实现搜索引擎  /339
13.1  Elasticsearch——搜索应用服务器  /339
∣13.1.1  什么是搜索引擎  /339
∣13.1.2  用数据库实现搜索功能  /339
∣13.1.3  认识Elasticsearch  /343
∣13.1.4  Elasticsearch应用案例  /343
∣13.1.5  对比Elasticsearch与MySQL  /343
∣13.1.6  认识ElasticSearchRepository  /344
∣13.1.7  认识ElasticsearchTemplate  /345
∣13.1.8  认识注解@Document  /345
∣13.1.9  管理索引  /347
13.2  【实例55】用ELK管理Spring Boot应用程序的日志  /348
∣13.2.1  安装Elasticsearch  /348
∣13.2.2  安装Logstash  /349
∣13.2.3  安装Kibana  /350
∣13.2.4  配置Spring Boot项目  /350
∣13.2.5  创建日志计划任务  /351
∣13.2.6  用Kibana查看管理日志  /352
13.3  【实例56】在Spring Boot中集成Elasticsearch，实现增、删、改、查功能  /353
∣13.3.1  集成Elasticsearch  /353
∣13.3.2  创建实体  /353
∣13.3.3  实现增、删、改、查文档的功能  /355
13.4  Elasticsearch查询  /356
∣13.4.1  自定义方法  /356
∣13.4.2  精准查询  /357
∣13.4.3  模糊查询  /359
∣13.4.4  范围查询  /362
∣13.4.5  组合查询  /362
∣13.4.6  分页查询  /363
∣13.4.7  聚合查询  /364
13.5  【实例57】实现产品搜索引擎  /365
13.6  Solr——搜索应用服务器  /367
∣13.6.1  了解Solr  /367
∣13.6.2  安装配置Solr  /367
∣13.6.3  整合Spring Boot和Solr  /368
13.7  【实例58】在Sping Boot中集成Solr，实现数据的增、删、改和查  /369
∣13.7.1  创建User类  /369
∣13.7.2  测试增、删、改、查功能  /369
13.8  对比Elasticsearch和Solr  /372
∣
+++++++++项目实战篇
第14章  开发企业级通用的后台系统  /376
14.1  用JPA实现实体间的映射关系  /376
∣14.1.1  创建用户实体  /376
∣14.1.2  创建角色实体  /377
∣14.1.3  创建权限实体  /378
14.2  用Spring Security实现动态授权（RBAC）功能  /380
∣14.2.1  实现管理（增、删、改、查）管理员角色功能  /380
∣14.2.2  实现管理权限功能  /381
∣14.2.3  实现管理管理员功能  /383
∣14.2.4  配置安全类  /384
∣14.2.5  实现基于RBAC权限控制功能  /386
14.3  监控Spring Boot应用  /387
∣14.3.1  在Spring Boot中集成Actuator  /387
∣14.3.2  在Spring Boot中集成Spring Boot Admin应用监控  /390
∣14.3.3  在Spring Boot中集成Druid 连接池监控  /392
第15章  实现一个类似“京东”的电子商务商城  /394
15.1  用Spring Security实现会员系统  /394
∣15.1.1  实现会员实体  /394
∣15.1.2  实现会员接口  /395
∣15.1.3  实现用户名、邮箱、手机号多方式注册功能  /396
∣15.1.4  实现用RabbitMQ发送会员注册验证邮件  /398
∣15.1.5  实现用户名、邮箱、手机号多方式登录功能  /399
15.2  整合会员系统（Web、APP多端、多方式注册登录）和后台系统  /400
∣15.3  实现购物系统  /401
∣15.3.1  设计数据表  /401
∣15.3.2  实现商品展示功能  /402
∣15.3.3  实现购物车功能  /403
∣15.3.4  用Redis实现购物车数据持久化  /404
15.4  用Redis实现分布式秒杀系统  /406
∣15.4.1  实现抢购功能，解决并发超卖问题  /406
∣15.4.2  缓存页面和限流  /409
15.5  用RabbitMQ实现订单过期取消功能  /409
15.6  实现结算和支付功能  /411
∣15.6.1  实现结算生成订单功能  /411
∣15.6.2  集成支付  /412
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot实战派
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>RabbitMQ实战指南
第1章  RabbitMQ简介
1.1  什么是消息中间件
1.2  消息中间件的作用
1.3  RabbitMQ的起源
1.4  RabbitMQ的安装及简单使用
1.4.1  安装Erlang
1.4.2  RabbitMQ的安装
1.4.3  RabbitMQ的运行
1.4.4  生产和消费消息
1.5  小结
第2章  RabbitMQ入门
2.1  相关概念介绍
2.1.1  生产者和消费者
2.1.2  队列
2.1.3  交换器、路由键、绑定
2.1.4  交换器类型
2.1.5  RabbitMQ运转流程
2.2  AMQP协议介绍
2.2.1  AMQP生产者流转过程
2.2.2  AMQP消费者流转过程
2.2.3  AMQP命令概览
2.3  小结
第3章  客户端开发向导
3.1  连接RabbitMQ
3.2  使用交换器和队列
3.2.1  exchangeDeclare方法详解
3.2.2  queueDeclare方法详解
3.2.3  queueBind方法详解
3.2.4  exchangeBind方法详解
3.2.5  何时创建
3.3  发送消息
3.4  消费消息
3.4.1  推模式
3.4.2  拉模式
3.5  消费端的确认与拒绝
3.6  关闭连接
3.7  小结
第4章  RabbitMQ进阶
4.1  消息何去何从
4.1.1  mandatory参数
4.1.2  immediate参数
4.1.3  备份交换器
4.2  过期时间（TTL）
4.2.1  设置消息的TTL
4.2.2  设置队列的TTL
4.3  死信队列
4.4  延迟队列
4.5  优先级队列
4.6  RPC实现
4.7  持久化
4.8  生产者确认
4.8.1  事务机制
4.8.2  发送方确认机制
4.9  消费端要点介绍
4.9.1  消息分发
4.9.2  消息顺序性
4.9.3  弃用QueueingConsumer
4.10  消息传输保障
4.11  小结
第5章  RabbitMQ管理
5.1  多租户与权限
5.2  用户管理
5.3  Web端管理
5.4  应用与集群管理
5.4.1  应用管理
5.4.2  集群管理
5.5  服务端状态
5.6  HTTP API接口管理
5.7  小结
第6章  RabbitMQ配置
6.1  环境变量
6.2  配置文件
6.2.1  配置项
6.2.2  配置加密
6.2.3  优化网络配置
6.3  参数及策略
6.4  小结
第7章  RabbitMQ运维
7.1  集群搭建
7.1.1  多机多节点配置
7.1.2  集群节点类型
7.1.3  剔除单个节点
7.1.4  集群节点的升级
7.1.5  单机多节点配置
7.2  查看服务日志
7.3  单节点故障恢复
7.4  集群迁移
7.4.1  元数据重建
7.4.2  数据迁移和客户端连接的切换
7.4.3  自动化迁移
7.5  集群监控
7.5.1  通过HTTP API接口提供监控数据
7.5.2  通过客户端提供监控数据
7.5.3  检测RabbitMQ服务是否健康
7.5.4  元数据管理与监控
7.6  小结
第8章  跨越集群的界限
8.1  Federation
8.1.1  联邦交换器
8.1.2  联邦队列
8.1.3  Federation的使用
8.2  Shovel
8.2.1  Shovel的原理
8.2.2  Shovel的使用
8.2.3  案例：消息堆积的治理
8.3  小结
第9章  RabbitMQ高阶
9.1  存储机制
9.1.1  队列的结构
9.1.2  惰性队列
9.2  内存及磁盘告警
9.2.1  内存告警
9.2.2  磁盘告警
9.3  流控
9.3.1  流控的原理
9.3.2  案例：打破队列的瓶颈
9.4  镜像队列
9.5  小结
第10章  网络分区
10.1  网络分区的意义
10.2  网络分区的判定
10.3  网络分区的模拟
10.4  网络分区的影响
10.4.1  未配置镜像
10.4.2  已配置镜像
10.5  手动处理网络分区
10.6  自动处理网络分区
10.6.1  pause-minority模式
10.6.2  pause-if-all-down模式
10.6.3  autoheal模式
10.6.4  挑选哪种模式
10.7  案例：多分区情形
10.8  小结
第11章  RabbitMQ扩展
11.1  消息追踪
11.1.1  Firehose
11.1.2  rabbitmq_tracing插件
11.1.3  案例：可靠性检测
11.2  负载均衡
11.2.1  客户端内部实现负载均衡
11.2.2  使用HAProxy实现负载均衡
11.2.3  使用Keepalived实现高可靠负载均衡
11.2.4  使用Keepalived+LVS实现负载均衡
11.3  小结
附录A  集群元数据信息示例
附录B  /api/nodes接口详细内容
附录C  网络分区图谱
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>RabbitMQ实战指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot微服务实战
目录
第1 章 介绍 1
1.1 设置场景 1
1.2 读者对象 2
1.3 本书与其他图书和指南有何区别 2
1.3.1 工具背后的论证 2
1.3.2 学习：渐进的过程 3
1.3.3 这是一本指南还是一本图书 3
1.4 本书内容 3
1.4.1 从基础知识到高级话题 3
1.4.2 搭建Spring Boot骨架的专业方式 4
1.4.3 测试驱动开发 4
1.4.4 连接微服务 4
1.4.5 事件驱动的系统 5
1.4.6 端到端测试 5
1.5 本章小结 5
第2 章 一个基本的Spring Boot应用 7
2.1 业务需求 7
2.2 骨架应用 8
2.2.1 轻薄应用与真实应用 8
2.2.2 创建应用骨架 8
2.3 热身：一些TDD的实战 10
2.4 本章小结 16
第3 章 一个真实的三层Spring Boot 应用 17
3.1 简介 17
3.2 完成基本功能 18
3.3 领域设计 24
3.4 业务逻辑层 28
3.5 展示层(REST API) 30
3.5.1 Multiplication Controller 31
3.5.2 Results控制器 35
3.6 前端(Web客户端) 38
3.7 试玩(第1部分) 42
3.8 数据持久化的新需求 43
3.9 重构代码 45
3.10 数据层 50
3.10.1 数据模型 51
3.10.2 资源库 56
3.11 完成第二个用户故事：串联所有层 63
3.12 畅玩应用(第2部分) 69
3.13 本章小结 71
第4 章 初识微服务 73
4.1 小单体之路 73
4.1.1 单体分析 75
4.1.2 继续前进 76
4.2 游戏化基础 77
4.2.1 分数、徽章和排行榜 77
4.2.2 应用游戏化技术 78
4.3 转向微服务架构 78
4.3.1 职责分离和松耦合 78
4.3.2 独立变更 79
4.3.3 伸缩性 79
4.4 连接不同的微服务 80
4.5 事件驱动架构 81
4.5.1 相关技术 81
4.5.2 事件驱动架构的优缺点 82
4.5.3 深入阅读 84
4.5.4 应用事件驱动架构 84
4.6 使用RabbitMQ和Spring AMQP实现事件驱动 85
4.6.1 在系统中使用RabbitMQ 86
4.6.2 Spring AMQP 86
4.7 从乘法微服务发送事件 87
4.7.1 RabbitMQ配置 87
4.7.2 对事件建模 89
4.7.3 发送事件：分发器模式 91
4.7.4 深入新游戏化微服务 95
4.8 使用RabbitMQ接收事件 111
4.8.1 订阅者 111
4.8.2 RabbitMQ配置 111
4.8.3 事件处理程序 114
4.9 在微服务之间请求数据 115
4.9.1 结合反应式模式和REST 115
4.9.2 保持领域隔离 117
4.9.3 实现REST客户端 119
4.9.4 更新游戏化业务逻辑 123
4.10 使用微服务 126
4.11 本章小结 128
第5 章 使用工具的微服务架构 131
5.1 介绍 131
5.2 抽取UI部分，并连接游戏化服务 132
5.2.1 移动静态内容 133
5.2.2 连接UI和游戏化服务 134
5.2.3 改变现有服务 136
5.2.4 全新的、更好的UI，而且(几乎)不需要额外的代价 139
5.3 当前架构 146
5.4 服务发现和负载均衡 147
5.4.1 服务发现 147
5.4.2 负载均衡 149
5.4.3 多语言系统、Eureka以及 Ribbon 151
5.5 通过API网关路由 153
5.5.1 API网关模式 153
5.5.2 让Zuul、Eureka和Ribbon一起工作 156
5.6 动手准则 158
5.6.1 使用Zuul实现API网关 158
5.6.2 使用服务发现 172
5.6.3 微服务准备好扩展了吗 174
5.6.4 通过Ribbon实现负载均衡 176
5.7 断路器和REST客户端 183
5.7.1 Hystrix断路器 183
5.7.2 Hystrix和Zuul 183
5.7.3 来自REST客户端的Hystrix 186
5.7.4 使用Feign的REST消费者 189
5.8 微服务模式和PaaS 189
5.9 本章小结 190
第6 章 测试分布式系统 193
6.1 介绍 193
6.2 设置场景 194
6.3 Cucumber的工作方式 195
6.4 动手准则 197
6.4.1 创建一个空项目并选择工具 197
6.4.2 让系统可测试 200
6.4.3 编写第一个Cucumber测试 207
6.4.4 把功能测试连接到Java代码 210
6.4.5 支持类 218
6.4.6 在feature之间重用步骤 223
6.4.7 运行测试并检查报告 225
6.5 本章小结 226
附录A 升级到Spring Boot 2.0 229
A.1 介绍 229
A.2 升级依赖项 229
A.3 修复已破坏的变化 232
A.3.1 CrudRepository接口不包含findOne()方法 232
A.3.2 actuator端点被移动 233
A.4 应用可选的更新 234
A.5 使用Spring Boot 2.0 234
后记 235
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot微服务实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入RabbitMQ
第一篇  RabbitMQ和应用程序体系结构
第1章  RabbitMQ基础   3
1.1  RabbitMQ特性以及好处  4
1.1.1  RabbitMQ与Erlang  5
1.1.2  RabbitMQ与AMQP  6
1.2  谁在使用RabbitMQ，在怎么用  7
1.3  松耦合架构的优势  8
1.3.1  解耦你的应用  10
1.3.2  解耦数据库写入   11
1.3.3  无缝添加新功能  12
1.3.4  复制数据与事件  12
1.3.5  多主（Multi-Master）互联化数据与事件  13
1.3.6  高级消息队列模型  14
1.4  小结  16
第2章  使用AMQ协议与Rabbit进行交互   18
2.1  AMQP作为一种RPC传输机制  19
2.1.1  启动会话  20
2.1.2  调整正确的信道  20
2.2  AMQP RPC帧结构  21
2.2.1  AMQP帧组件  21
2.2.2  帧类型  22
2.2.3  将消息编组成帧  23
2.2.4  方法帧结构  24
2.2.5  内容头帧  26
2.2.6  消息体帧  26
2.3  使用协议  27
2.3.1  声明交换器  27
2.3.2  声明队列  28
2.3.3  绑定队列到交换器  29
2.3.4  发布消息到RabbitMQ  29
2.3.5  从RabbitMQ中消费消息  30
2.4  用Python编写消息发布者  32
2.5  从RabbitMQ中获取消息  36
2.6  小结  37
第３章  消息属性详解   38
3.1  合理使用属性  39
3.2  使用content-type属性创建显式的消息契约  41
3.3  通过gzip和content-encoding属性压缩消息大小  43
3.4  使用message-id和correlation-id引用消息  45
3.4.1  Message-id   45
3.4.2  Correlation-id   45
3.5  创建时间：timestamp属性  46
3.6  消息自动过期  47
3.7  使用delivery-mode平衡速度和安全性  48
3.8  使用app-id和user-id验证消息来源  49
3.8.1  app-id   50
3.8.2  user-id   51
3.9  使用type属性获取明细  51
3.10  使用reply-to属性实现动态工作流  52
3.11  使用消息头自定义属性  53
3.12  优先级属性  54
3.13  不能使用的属性：cluster-id/reserved  54
3.14  小结  55
第4章  消息发布的性能权衡   58
4.1  平衡投递速度与可靠投递  59
4.1.1  如果没有保证机制我们能期待什么  60
4.1.2  使用mandatory设置，RabbitMQ将不接受不可路由消息  62
4.1.3  发布者确认作为事务的轻量级替代方法  64
4.1.4  使用备用交换器处理无法路由的消息  66
4.1.5  基于事务的批量处理  68
4.1.6  使用HA队列避免节点故障  70
4.1.7   HA队列与事务  72
4.1.8  通过设置delivery-mode为2将消息持久化到磁盘  72
4.2  RabbitMQ回推  75
4.2.1  使用rabbitpy来检测连接状态  77
4.2.2  使用管理API管理连接状态  77
4.3  小结  78
第5章  消费消息，避免拉取   79
5.1  对比Basic.Get 和Basic.Consume  80
5.1.1  Basic.Get  80
5.1.2  Basic.Consume  82
5.2  优化消费者性能  84
5.2.1  使用no-ack模式实现更快的吞吐量  85
5.2.2  通过服务质量设置控制消费者预取  86
5.2.3  消费者使用事务  89
5.3  拒绝消息  90
5.3.1  Basic.Reject   90
5.3.2  Basic.Nack   91
5.3.3  死信交换器  92
5.4  控制队列  94
5.4.1  临时队列  94
5.4.2   永久队列  97
5.4.3  任意队列设置  99
5.5  小结  99
第6章  消息路由模式   101
6.1  通过direct交换器路由消息  102
6.1.1  创建应用架构  103
6.1.2  创建RPC工作者  107
6.1.3  编写简单的RPC发布者   110
6.2  通过fanout交换器广播消息   115
6.2.1  修改面部检测消费者   116
6.2.2  创建一个简单的图片哈希消费者   117
6.3  使用topic交换器有选择地路由消息   119
6.4  使用headers交换器有选择地路由消息  122
6.5  交换器性能基准  124
6.6  交换器间路由  125
6.7  使用一致性哈希交换器路由消息  127
6.8  小结  131
第二篇  管理数据中心或云中的RabbitMQ
第7章  RabbitMQ集群   135
7.1  集群简介  136
7.1.1  集群和管理界面  137
7.1.2  集群节点类型  138
7.1.3  集群和队列行为  139
7.2  集群设置  142
7.2.1  虚拟机设置  143
7.2.2  向集群中添加节点  144
7.3  小结  147
第8章  跨集群的消息分发   148
8.1  联合交换器和联合队列  149
8.1.1  联合交换器  149
8.1.2  联合队列  152
8.2  创建RabbitMQ虚拟机  153
8.2.1  创建首个实例  153
8.2.2  复制EC2实例  159
8.3  连接上游节点  162
8.3.1  定义联合中的上游节点  162
8.3.2  定义策略  164
8.3.3  利用上游集合  167
8.3.4  双向联合交换器  170
8.3.5  使用联合来升级集群  171
8.4  小结  173
第三篇  集成与定制
第９章  使用替代协议   177
9.1  MQTT和RabbitMQ  178
9.1.1  MQTT协议  178
9.1.2  通过MQTT发送消息  182
9.1.3  MQTT订阅者  184
9.1.4  MQTT插件配置  187
9.2  STOMP和RabbitMQ  189
9.2.1  STOMP协议  190
9.2.2  发布消息  191
9.2.3  消费消息  195
9.2.4  配置STOMP插件  198
9.2.5  在Web浏览器中使用STOMP  199
9.3   通过HTTP进行无状态发布  200
9.3.1  statelessd的由来  200
9.3.2  使用statelessd  201
9.3.3  运营架构  202
9.3.4  通过statelessd来发布消息  203
9.4  小结  203
第10章  数据库集成   205
10.1  PostgreSQL扩展：pg_amqp  206
10.1.1  安装pg_amqp扩展   207
10.1.2  配置pg_amqp扩展   209
10.1.3  通过pg_amqp发送消息   210
10.2  监听PostgreSQL通知   212
10.2.1  安装PostgreSQL LISTEN交换器  213
10.2.2  基于策略的配置  215
10.2.3  创建交换器  217
10.2.4  创建并绑定测试队列  217
10.2.5  通过NOTIFY发送消息  218
10.3  将消息存入InfluxDB中  219
10.3.1  InfluxDB的安装与设置  220
10.3.2  安装InfluxDB存储交换器  222
10.3.3  创建测试交换器  223
10.3.4  测试交换器  224
10.4  小结  227
附录  准备就绪   228
A.1  安装VirtualBox  228
A.2  安装Vagrant  230
A.3  设置Vagrant虚拟机  233
A.4  确认安装  234
A.5  小结  236
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入RabbitMQ
