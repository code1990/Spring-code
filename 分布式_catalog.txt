>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大规模分布式存储系统
前言
第1章　概述
1.1　分布式存储概念
1.2　分布式存储分类
第一篇　基础篇
第2章　单机存储系统
2.1　硬件基础
2.1.1　CPU架构
2.1.2　IO总线
2.1.3　网络拓扑
2.1.4　性能参数
2.1.5　存储层次架构
2.2　单机存储引擎
2.2.1　哈希存储引擎
2.2.2　B树存储引擎
2.2.3　LSM树存储引擎
2.3　数据模型
2.3.1　文件模型
2.3.2　关系模型
2.3.3　键值模型
2.3.4　SQL与NoSQL
2.4　事务与并发控制
2.4.1　事务
2.4.2　并发控制
2.5　故障恢复
2.5.1　操作日志
2.5.2　重做日志
2.5.3　优化手段
2.6　数据压缩
2.6.1　压缩算法
2.6.2　列式存储
第3章　分布式系统
3.1　基本概念
3.1.1　异常
3.1.2　一致性
3.1.3　衡量指标
3.2　性能分析
3.3　数据分布
3.3.1　哈希分布
3.3.2　顺序分布
3.3.3　负载均衡
3.4　复制
3.4.1　复制的概述
3.4.2　一致性与可用性
3.5　容错
3.5.1　常见故障
3.5.2　故障检测
3.5.3　故障恢复
3.6　可扩展性
3.6.1　总控节点
3.6.2　数据库扩容
3.6.3　异构系统
3.7　分布式协议
3.7.1　两阶段提交协议
3.7.2　Paxos协议
3.7.3　Paxos与2PC
3.8　跨机房部署
第二篇　范型篇
第4章　分布式文件系统
4.1　Google文件系统
4.1.1　系统架构
4.1.2　关键问题
4.1.3　Master设计
4.1.4　ChunkServer设计
4.1.5　讨论
4.2　Taobao File System
4.2.1　系统架构
4.2.2　讨论
4.3　Facebook Haystack
4.3.1　系统架构
4.3.2　讨论
4.4　内容分发网络
4.4.1　CDN架构
4.4.2　讨论
第5章　分布式键值系统
5.1　Amazon Dynamo
5.1.1　数据分布
5.1.2　一致性与复制
5.1.3　容错
5.1.4　负载均衡
5.1.5　读写流程
5.1.6　单机实现
5.1.7　讨论
5.2　淘宝Tair
5.2.1　系统架构
5.2.2　关键问题
5.2.3　讨论
第6章　分布式表格系统
6.1　Google Bigtable
6.1.1　架构
6.1.2　数据分布
6.1.3　复制与一致性
6.1.4　容错
6.1.5　负载均衡
6.1.6　分裂与合并
6.1.7　单机存储
6.1.8　垃圾回收
6.1.9　讨论
6.2　Google Megastore
6.2.1　系统架构
6.2.2　实体组
6.2.3　并发控制
6.2.4　复制
6.2.5　索引
6.2.6　协调者
6.2.7　读取流程
6.2.8　写入流程
6.2.9　讨论
6.3　Windows Azure Storage
6.3.1　整体架构
6.3.2　文件流层
6.3.3　分区层
6.3.4　讨论
第7章　分布式数据库
7.1　数据库中间层
7.1.1　架构
7.1.2　扩容
7.1.3　讨论
7.2　Microsoft SQL Azure
7.2.1　数据模型
7.2.2　架构
7.2.3　复制与一致性
7.2.4　容错
7.2.5　负载均衡
7.2.6　多租户
7.2.7　讨论
7.3　Google Spanner
7.3.1　数据模型
7.3.2　架构
7.3.3　复制与一致性
7.3.4　TrueTime
7.3.5　并发控制
7.3.6　数据迁移
7.3.7　讨论
第三篇　实践篇
第8章　OceanBase架构初探
8.1　背景简介
8.2　设计思路
8.3　系统架构
8.3.1　整体架构图
8.3.2　客户端
8.3.3　RootServer
8.3.4　MergeServer
8.3.5　ChunkServer
8.3.6　UpdateServer
8.3.7　定期合并&数据分发
8.4　架构剖析
8.4.1　一致性选择
8.4.2　数据结构
8.4.3　可靠性与可用性
8.4.4　读写事务
8.4.5　单点性能
8.4.6　SSD支持
8.4.7　数据正确性
8.4.8　分层结构
第9章　分布式存储引擎
9.1　公共模块
9.1.1　内存管理
9.1.2　基础数据结构
9.1.3　锁
9.1.4　任务队列
9.1.5　网络框架
9.1.6　压缩与解压缩
9.2　RootServer实现机制
9.2.1　数据结构
9.2.2　子表复制与负载均衡
9.2.3　子表分裂与合并
9.2.4　UpdateServer选主
9.2.5　RootServer主备
9.3　UpdateServer实现机制
9.3.1　存储引擎
9.3.2　任务模型
9.3.3　主备同步
9.4　ChunkServer实现机制
9.4.1　子表管理
9.4.2　SSTable
9.4.3　缓存实现
9.4.4　IO实现
9.4.5　定期合并&数据分发
9.4.6　定期合并限速
9.5　消除更新瓶颈
9.5.1　读写优化回顾
9.5.2　数据旁路导入
9.5.3　数据分区
第10章　数据库功能
10.1　整体结构
10.2　只读事务
10.2.1　物理操作符接口
10.2.2　单表操作
10.2.3　多表操作
10.2.4　SQL执行本地化
10.3　写事务
10.3.1　写事务执行流程
10.3.2　多版本并发控制
10.4　OLAP业务支持
10.4.1　并发查询
10.4.2　列式存储
10.5　特色功能
10.5.1　大表左连接
10.5.2　数据过期与批量删除
第11章　质量保证、运维及实践
11.1　质量保证
11.1.1　RD开发
11.1.2　QA测试
11.1.3　试运行
11.2　使用与运维
11.2.1　使用
11.2.2　运维
11.3　应用
11.3.1　收藏夹
11.3.2　天猫评价
11.3.3　直通车报表
11.4　最佳实践
11.4.1　系统发展路径
11.4.2　人员成长
11.4.3　系统设计
11.4.4　系统实现
11.4.5　使用与运维
11.4.6　工程现象
11.4.7　经验法则
第四篇　专题篇
第12章　云存储
12.1　云存储的概念
12.2　云存储的产品形态
12.3　云存储技术
12.4　云存储的核心优势
12.5　云平台整体架构
12.5.1　Amazon云平台
12.5.2　Google云平台
12.5.3　Microsoft云平台
12.5.4　云平台架构
12.6　云存储技术体系
12.7　云存储安全
第13章　大数据
13.1　大数据的概念
13.2　MapReduce
13.3　MapReduce扩展
13.3.1　Google Tenzing
13.3.2　Microsoft Dryad
13.3.3　Google Pregel
13.4　流式计算
13.4.1　原理
13.4.2　Yahoo S4
13.4.3　Twitter Storm
13.5　实时分析
13.5.1　MPP架构
13.5.2　EMC Greenplum
13.5.3　HP Vertica
13.5.4　Google Dremel
参考资料
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大规模分布式存储系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>从Paxos到Zookeeper
第1章分布式架构	1
1.1  从集中式到分布式	1
1.1.1  集中式的特点	2
1.1.2  分布式的特点	2
1.1.3  分布式环境的各种问题	4
1.2  从ACID到CAP/BASE	5
1.2.1  ACID	5
1.2.2  分布式事务	8
1.2.3  CAP和BASE理论	9
小结	15
第2章一致性协议	17
2.1  2PC与3PC	17
2.1.1  2PC	17
2.1.2  3PC	21
2.2  Paxos算法	24
2.2.1  追本溯源	25
2.2.2  Paxos理论的诞生	26
2.2.3  Paxos算法详解	27
小结	37
第3章Paxos的工程实践	39
3.1  Chubby	39
3.1.1  概述	39
3.1.2  应用场景	40
3.1.3  设计目标	40
3.1.4  Chubby技术架构	43
3.1.5  Paxos协议实现	52
3.2  Hypertable	55
3.2.1  概述	55
3.2.2  算法实现	57
小结	58
第4章ZooKeeper与Paxos	59
4.1  初识ZooKeeper	59
4.1.1  ZooKeeper介绍	59
4.1.2  ZooKeeper从何而来	62
4.1.3  ZooKeeper的基本概念	62
4.1.4  为什么选择ZooKeeper	64
4.2  ZooKeeper的ZAB协议	65
4.2.1  ZAB协议	65
4.2.2  协议介绍	66
4.2.3  深入ZAB协议	71
4.2.4  ZAB与Paxos算法的联系与区别	77
小结	78
第5章使用ZooKeeper	79
5.1  部署与运行	79
5.1.1  系统环境	79
5.1.2  集群与单机	80
5.1.3  运行服务	84
5.2  客户端脚本	88
5.2.1  创建	88
5.2.2  读取	89
5.2.3  更新	90
5.2.4  删除	91
5.3  Java客户端API使用	91
5.3.1  创建会话	91
5.3.2  创建节点	95
5.3.3  删除节点	99
5.3.4  读取数据	100
5.3.5  更新数据	109
5.3.6  检测节点是否存在	113
5.3.7  权限控制	115
5.4  开源客户端	120
5.4.1  ZkClient	120
5.4.2  Curator	130
小结	162
第6章ZooKeeper的典型应用场景	163
6.1  典型应用场景及实现注	163
6.1.1  数据发布/订阅	164
6.1.2  负载均衡	166
6.1.3  命名服务	170
6.1.4  分布式协调/通知	173
6.1.5  集群管理	179
6.1.6  Master选举	185
6.1.7  分布式锁	188
6.1.8  分布式队列	194
小结	197
6.2  ZooKeeper在大型分布式系统中的应用	197
6.2.1  Hadoop	198
6.2.2  HBase	203
6.2.3  Kafka	207
6.3  ZooKeeper在阿里巴巴的实践与应用	213
6.3.1  案例一消息中间件：Metamorphosis	213
6.3.2  案例二  RPC服务框架：Dubbo	217
6.3.3  案例三基于MySQL Binlog的增量订阅和消费组件：Canal	219
6.3.4  案例四分布式数据库同步系统：Otter	223
6.3.5  案例五轻量级分布式通用搜索平台：终搜	226
6.3.6  案例六实时计算引擎：JStorm	238
小结	242
第7章ZooKeeper技术内幕	243
7.1  系统模型	243
7.1.1  数据模型	243
7.1.2  节点特性	244
7.1.3  版本——保证分布式数据原子性操作	246
7.1.4  Watcher——数据变更的通知	249
7.1.5  ACL——保障数据的安全	265
7.2  序列化与协议	272
7.2.1  Jute介绍	272
7.2.2  使用Jute进行序列化	273
7.2.3  深入Jute	275
7.2.4  通信协议	277
7.3  客户端	284
7.3.1  一次会话的创建过程	286
7.3.2  服务器地址列表	289
7.3.3  ClientCnxn：网络I/O	295
7.4  会话	298
7.4.1  会话状态	298
7.4.2  会话创建	299
7.4.3  会话管理	304
7.4.4  会话清理	307
7.4.5  重连	309
7.5  服务器启动	311
7.5.1  单机版服务器启动	312
7.5.2  集群版服务器启动	315
7.6  Leader选举	321
7.6.1  Leader选举概述	321
7.6.2  Leader选举的算法分析	323
7.6.3  Leader选举的实现细节	328
7.7  各服务器角色介绍	335
7.7.1  Leader	335
7.7.2  Follower	338
7.7.3  Observer	339
7.7.4  集群间消息通信	339
7.8  请求处理	342
7.8.1  会话创建请求	343
7.8.2  SetData请求	351
7.8.3  事务请求转发	354
7.8.4  GetData请求	355
7.9  数据与存储	356
7.9.1  内存数据	356
7.9.2  事务日志	358
7.9.3  snapshot——数据快照	364
7.9.4  初始化	368
7.9.5  数据同步	372
小结	376
第8章ZooKeeper运维	379
8.1  配置详解	379
8.1.1  基本配置	379
8.1.2  高级配置	380
8.2  四字命令	384
8.3  JMX	390
8.3.1  开启远程JMX	390
8.3.2  通过JConsole连接ZooKeeper	391
8.4  监控	397
8.4.1  实时监控	397
8.4.2  数据统计	398
8.5  构建一个高可用的集群	398
8.5.1  集群组成	398
8.5.2  容灾	399
8.5.3  扩容与缩容	402
8.6  日常运维	402
8.6.1  数据与日志管理	402
8.6.2  Too many connections	404
8.6.3  磁盘管理	405
小结	405
附录AWindows平台上部署ZooKeeper	406
附录B从源代码开始构建	409
附录C各发行版本重大更新记录	414
附录DZooKeeper源代码阅读指引	418
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>从Paxos到Zookeeper
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式Java应用
前言
第1章 分布式Java应用
1.1 基于消息方式实现系统间的通信
1.1.1 基于Java自身技术实现消息方式的系统间通信
1.1.2 基于开源框架实现消息方式的系统间通信
1.2 基于远程调用方式实现系统间的通信
1.2.1 基于Java自身技术实现远程调用方式的系统间通信
1.2.2 基于开源框架实现远程调用方式的系统间通信
第2章 大型分布式Java应用与SOA
2.1 基于SCA实现SOA平台
2.2 基于ESB实现SOA平台
2.3 基于Tuscany实现SOA平台
2.4 基于Mule实现SOA平台
第3章 深入理解JVM
3.1 Java代码的执行机制
3.1.1 Java源码编译机制
3.1.2 类加载机制
3.1.3 类执行机制
3.2 JVM内存管理
3.2.1 内存空间
3.2.2 内存分配
3.2.3 内存回收
3.2.4 JVM内存状况查看方法和分析工具
3.3 JVM线程资源同步及交互机制
3.3.1 线程资源同步机制
3.3.2 线程交互机制
3.3.3 线程状态及分析
第4章 分布式应用与Sun JDK类库
4.1 集合包
4.1.1 ArrayList
4.1.2 LinkedList
4.1.3 Vector
4.1.4 Stack
4.1.5 HashSet
4.1.6 TreeSet
4.1.7 HashMap
4.1.8 TreeMap
4.1.9 性能测试
4.1.10 小结
4.2 并发包（java.util.concurrent）
4.2.1 ConcurrentHashMap
4.2.2 CopyOnWriteArrayList
4.2.3 CopyOnWriteArraySet
4.2.4 ArrayBlockingQueue
4.2.5 AtomicInteger
4.2.6 ThreadPoolExecutor
4.2.7 Executors
4.2.8 FutureTask
4.2.9 Semaphore
4.2.10 CountDownLatch
4.2.11 CyclicBarrier
4.2.12 ReentrantLock
4.2.13 Condition
4.2.14 ReentrantReadWriteLock
4.3 序列化/反序列化
4.3.1 序列化
4.3.2 反序列化
第5章 性能调优
5.1 寻找性能瓶颈
5.1.1 CPU消耗分析
5.1.2 文件IO消耗分析
5.1.3 网络IO消耗分析
5.1.4 内存消耗分析
5.1.5 程序执行慢原因分析
5.2 调优
5.2.1 JVM调优
5.2.2 程序调优
5.2.3 对于资源消耗不多，但程序执行慢的情况
第6章 构建高可用的系统
6.1 避免系统中出现单点
6.1.1 负载均衡技术
6.1.2 热备
6.2 提高应用自身的可用性
6.2.1 尽可能地避免故障
6.2.2 及时发现故障
6.2.3 及时处理故障
6.2.4 访问量及数据量不断上涨的应对策略
第7章 构建可伸缩的系统
7.1 垂直伸缩
7.1.1 支撑高访问量
7.1.2 支撑大数据量
7.1.3 提升计算能力
7.2 水平伸缩
7.2.1 支撑高访问量
7.2.2 支撑大数据量
7.2.3 提升计算能力
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式Java应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>RabbitMQ实战
第1章 天降奇兵 1
1.1 住在别人的地下城堡 3
1.2 救世主AMQP 5
1.3 RabbitMQ简史 5
1.4 百里挑一 8
1.5 在UNIX系统上安装RabbitMQ 8
1.5.1 为什么环境很重要--生活在Erlang 的世界里 9
1.5.2 获取安装包 9
1.5.3 设置文件夹结构 9
1.5.4 首次运行Rabbit 10
1.6 总结 12
第2章 理解消息通信13
2.1 消费者和生产者（这可不是经济学课程哦） 14
2.2 从底部开始构造：队列 17
2.3 联合起来：交换器和绑定 22
2.4 多租户模式：虚拟主机和隔离 27
2.5 我的消息去哪儿了呢？持久化和你的策略 28
2.6 把所有内容结合起来：一条消息的一生 32
2.7 使用发送方确认模式来确认投递 37
2.8 总结 40
第3章 运行和管理Rabbit 42
3.1 服务器管理 43
3.1.1 启动节点 43
3.1.2 停止节点 45
3.1.3 关闭和重启应用程序：有何差别 46
3.1.4 Rabbit 配置文件 46
3.2 请求许可 48
3.2.1 管理用户 49
3.2.2 Rabbit 的权限系统 50
3.3 检查 54
3.3.1 查看数据统计 54
3.3.2 理解RabbitMQ 日志 59
3.4 修复Rabbit：疑难解答 63
由badrpc、nodedown 和其他Erlang 引起的问题 63
3.5 总结 68
第4章 解决Rabbit相关问题：编码与模式69
4.1 解耦风雨路：谁将我们推向消息通信 70
4.1.1 异步状态思维（分离请求和动作） 70
4.1.2 提供扩展性：没有负载均衡器的世界 73
4.1.3 零成本API ：语言不应成为枷锁 73
4.2 发后即忘模型 74
4.2.1 发送告警 75
4.2.2 并行处理 84
4.3 别忘了：用RabbitMQ实现RPC并等待响应 92
4.3.1 私有队列和发送确认 93
4.3.2 使用reply_to 来实现简单的JSON RPC 93
4.4 总结 98
第5章 集群并处理失败99
5.1 开足马力：RabbitMQ集群 100
5.2 集群架构 101
5.2.1 集群中的队列 101
5.2.2 分布交换器 103
5.2.3 是内存节点还是磁盘节点 104
5.3 在你的笔记本电脑上设置集群 106
5.4 将节点分布到更多的机器上 110
5.5 升级集群节点 114
5.6 镜像队列和保留消息 115
5.6.1 声明并使用镜像队列 115
5.6.2 镜像队列工作原理 118
5.7 总结 120
第6章 从故障中恢复121
6.1 为Rabbit做负载均衡 122
6.1.1 安装HAProxy 124
6.1.2 配置HAProxy 125
6.2 连接丢失和故障转移 127
6.3 总结 134
第7章 warren和Shovel：故障转移和复制 135
7.1 warren：另一种集群方式 136
7.2 设定负载均衡器--基于主/从的集群 138
7.3 远距离通信和复制 142
7.3.1 给Rabbit 装备Shovel ：Shovel 插件介绍 142
7.3.2 安装Shovel 145
7.3.3 配置并运行Shovel 146
7.4 总结 152
第8章 从Web端管理RabbitMQ 154
8.1 超越rabbitmqctl：RabbitMQ Management插件 155
8.1.1 为何需要Management 插件 155
8.1.2 Management 插件功能 155
8.1.3 启用Management 插件 156
8.2 从Web控制台来管理RabbitMQ 158
8.2.1 监控Erlang VM 158
8.2.2 从JSON 文件导入配置 159
8.3 从Web控制台管理用户 160
8.3.1 创建用户 161
8.3.2 管理用户的权限 162
8.4 从Web控制台管理交换器和队列 163
8.4.1 列出队列信息 165
8.4.2 创建队列 166
8.5 回到命令行 168
8.5.1 为什么需要另一个CLI 168
8.5.2 CLI 管理：一种更简单的方式 170
8.5.3 安装rabbitmqadmin 脚本 170
8.5.4 清空队列、创建交换器等 171
8.6 总结 172
第9章 使用REST API控制Rabbit 173
9.1 能用RabbitMQ REST API做什么 175
9.2 对客户端授权访问 177
9.3 访问数据统计 178
9.4 自动化vhost和用户配置 181
9.5 总结 .186
第10章 监控187
10.1 监控RabbitMQ：密切关注你的warren 188
10.1.1 为Nagios 编写健康检测 188
10.1.2 使用AMQP 模拟检测来确认RabbitMQ 是否运行 190
10.1.3 使用REST API 来检测 193
10.1.4 监控配置文件修改 196
10.1.5 监控集群状态 201
10.2 确保消费者正常工作 206
10.2.1 通过AMQP 监控队列等级 208
10.2.2 使用REST API 来监控队列级别 212
10.2.3 建立队列的消息计数基准经验法则 215
10.3 总结216
第11章 提升性能，保障安全217
11.1 对速度的需求 218
11.1.1 消息持久化 218
11.1.2 消息确认 219
11.1.3 路由算法和绑定规则 219
11.1.4 投递消息 221
11.2 内存使用率和进程限制 223
11.2.1 内存使用率 223
11.2.2 Erlang 进程计数 226
11.3 SSL连接 ..227
11.3.1 SSL 证书.228
11.3.2 设置证书颁发机构 ..229
11.3.3 生成根证书 233
11.3.4 生成服务器端证书 234
11.3.5 生成客户端证书 235
11.3.6 启用RabbitMQ 的SSL 监听器 236
11.3.7 测试你的RabbitMQ SSL 设置 237
11.4 总结 239
第12章 聪明的Rabbit：扩展RabbitMQ241
12.1 RabbitMQ插件 242
12.1.1 你可以用插件做什么 242
12.1.2 在哪里可以找到插件 244
12.1.3 安装插件 244
12.1.4 移除插件 245
12.2 制作你自己的插件 247
12.2.1 获取RabbitMQ Public Umbrella 248
12.2.2 设置文件夹结构 249
12.2.3 包含插件构建系统 250
12.2.4 创建Erlang 应用文件 250
12.3 创建自定义交换器模块 252
12.3.1 将交换器注册到RabbitMQ 254
12.3.2 实现交换器behaviour 257
12.3.3 编译自定义交换器 264
12.3.4 测试你的插件 267
12.4 总结 271
附录A 在Java和.NET上使用Rabbit 273
附录B 在线资源302
附录C 在Windows上安装RabbitMQ 307
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>RabbitMQ实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式机器学习：算法、理论与实践
序言一
序言二
前　言
作者介绍
第1章　绪论/ 1
1.1　人工智能及其飞速发展/ 2
1.2　大规模、分布式机器学习/ 4
1.3　本书的安排/ 6
参考文献/ 7
第2章　机器学习基础/ 9
2.1　机器学习的基本概念/ 10
2.2　机器学习的基本流程/ 13
2.3　常用的损失函数/ 16
2.3.1　Hinge损失函数/ 16
2.3.2　指数损失函数/ 16
2.3.3　交叉熵损失函数/ 17
2.4　常用的机器学习模型/ 18
2.4.1　线性模型/ 18
2.4.2　核方法与支持向量机/ 18
2.4.3　决策树与Boosting/ 21
2.4.4　神经网络/ 23
2.5　常用的优化方法/ 32
2.6　机器学习理论/ 33
2.6.1　机器学习算法的泛化误差/ 34
2.6.2　泛化误差的分解/ 34
2.6.3　基于容度的估计误差的上界/ 35
2.7　总结/ 36
参考文献/ 36
第3章　分布式机器学习框架/ 41
3.1　大数据与大模型的挑战/ 42
3.2　分布式机器学习的基本流程/ 44
3.3　数据与模型划分模块/ 46
3.4　单机优化模块/ 48
3.5　通信模块/ 48
3.5.1　通信的内容/ 48
3.5.2　通信的拓扑结构/ 49
3.5.3　通信的步调/ 51
3.5.4　通信的频率/ 52
3.6　数据与模型聚合模块/ 53
3.7　分布式机器学习理论/ 54
3.8　分布式机器学习系统/ 55
3.9　总结/ 56
参考文献/ 57
第4章　单机优化之确定性算法/ 61
4.1　基本概述/ 62
4.1.1　机器学习的优化框架/ 62
4.1.2　优化算法的分类和发展历史/ 65
4.2　一阶确定性算法/ 67
4.2.1　梯度下降法/ 67
4.2.2　投影次梯度下降法/ 69
4.2.3　近端梯度下降法/ 70
4.2.4　Frank-Wolfe算法/ 71
4.2.5　Nesterov加速法/ 72
4.2.6　坐标下降法/ 75
4.3　二阶确定性算法/ 75
4.3.1　牛顿法/ 76
4.3.2　拟牛顿法/ 77
4.4　对偶方法/ 78
4.5　总结/ 81
参考文献/ 8
第5章　单机优化之随机算法/ 85
5.1　基本随机优化算法/ 86
5.1.1　随机梯度下降法/ 86
5.1.2　随机坐标下降法/ 88
5.1.3　随机拟牛顿法/ 91
5.1.4　随机对偶坐标上升法/ 93
5.1.5　小结/ 95
5.2　随机优化算法的改进/ 96
5.2.1　方差缩减方法/ 96
5.2.2　算法组合方法/ 100
5.3　非凸随机优化算法/ 101
5.3.1　Ada系列算法/ 102
5.3.2　非凸理论分析/ 104
5.3.3　逃离鞍点问题/ 106
5.3.4　等级优化算法/ 107
5.4　总结/ 109
参考文献/ 109
第6章　数据与模型并行/ 113
6.1　基本概述/ 114
6.2　计算并行模式/ 117
6.3　数据并行模式/ 119
6.3.1　数据样本划分/ 120
6.3.2　数据维度划分/ 123
6.4　模型并行模式/ 123
6.4.1　线性模型/ 123
6.4.2　神经网络/ 127
6.5　总结/ 133
参考文献/ 133
第7章　通信机制/ 135
7.1　基本概述/ 136
7.2　通信的内容/ 137
7.2.1　参数或参数的更新/ 137
7.2.2　计算的中间结果/ 137
7.2.3　讨论/ 138
7.3　通信的拓扑结构/ 139
7.3.1　基于迭代式MapReduce/AllReduce的通信拓扑/ 140
7.3.2　基于参数服务器的通信拓扑/ 142
7.3.3　基于数据流的通信拓扑/ 143
7.3.4　讨论/ 145
7.4　通信的步调/ 145
7.4.1　同步通信/ 146
7.4.2　异步通信/ 147
7.4.3　同步和异步的平衡/ 148
7.4.4　讨论/ 150
7.5　通信的频率/ 150
7.5.1　时域滤波/ 150
7.5.2　空域滤波/ 153
7.5.3　讨论/ 155
7.6　总结/ 156
参考文献/ 156
第8章　数据与模型聚合/ 159
8.1　基本概述/ 160
8.2　基于模型加和的聚合方法/ 160
8.2.1　基于全部模型加和的聚合/ 160
8.2.2　基于部分模型加和的聚合/ 162
8.3　基于模型集成的聚合方法/ 167
8.3.1　基于输出加和的聚合/ 168
8.3.2　基于投票的聚合/ 171
8.4　总结/ 174
参考文献/ 174
第9章　分布式机器学习算法/ 177
9.1　基本概述/ 178
9.2　同步算法/ 179
9.2.1　同步SGD方法/ 179
9.2.2　模型平均方法及其改进/ 182
9.2.3　ADMM算法/ 183
9.2.4　弹性平均SGD算法/ 185
9.2.5　讨论/ 186
9.3　异步算法/ 187
9.3.1　异步SGD/ 187
9.3.2　Hogwild!算法/ 189
9.3.3　Cyclades算法/ 190
9.3.4　带延迟处理的异步算法/ 192
9.3.5　异步方法的进一步加速/ 199
9.3.6　讨论/ 199
9.4　同步和异步的对比与融合/ 199
9.4.1　同步和异步算法的实验对比/ 199
9.4.2　同步和异步的融合/ 201
9.5　模型并行算法/ 203
9.5.1　DistBelief/ 203
9.5.2　AlexNet/ 204
9.6　总结/ 205
参考文献/ 205
第10章　分布式机器学习理论/ 209
10.1　基本概述/ 210
10.2　收敛性分析/ 210
10.2.1　优化目标和算法/ 211
10.2.2　数据和模型并行/ 213
10.2.3　同步和异步/ 215
10.3　加速比分析/ 217
10.3.1　从收敛速率到加速比/ 218
10.3.2　通信量的下界/ 219
10.4　泛化分析/ 221
10.4.1　优化的局限性/ 222
10.4.2　具有更好泛化能力的非凸优化算法/ 224
10.5　总结/ 226
参考文献/ 226
第11章　分布式机器学习系统/ 229
11.1　基本概述/ 230
11.2　基于IMR的分布式机器学习系统/ 231
11.2.1　IMR和Spark/ 231
11.2.2　Spark MLlib/ 234
11.3　基于参数服务器的分布式机器学习系统/ 236
11.3.1　参数服务器/ 236
11.3.2　Multiverso参数服务器/ 237
11.4　基于数据流的分布式机器学习系统/ 241
11.4.1　数据流/ 241
11.4.2　TensorFlow数据流系统/ 243
11.5　实战比较/ 248
11.6　总结/ 252
参考文献/ 252
第12章　结语/ 255
12.1　全书总结/ 256
12.2　未来展望/ 257
索引/ 260
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式机器学习：算法、理论与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式系统原理与范型
第1章 概述 1
1.1 分布式系统的定义 1
1.2 目标 3
1.2.1 使资源可访问 3
1.2.2 透明性 4
1.2.3 开放性 6
1.2.4 可扩展性 7
1.3 分布式系统的类型 12
1.3.1 分布式计算系统 12
1.3.2 分布式信息系统 14
1.3.3 分布式普适系统 17
本章小结 21
习题 22
第2章 体系结构 23
2.1 体系结构的样式 23
2.2 系统体系结构 25
2.2.1 集中式体系结构 25
2.2.2 非集中式体系结构 30
2.2.3 混合体系结构 36
2.3 体系结构与中间件 38
2.3.1 中断器 38
2.3.2 自适应软件的常见方法 40
2.3.3 讨论 40
2.4 分布式系统的自我管理 41
2.4.1 反馈控制模型 42
2.4.2 示例：用Astrolabe监视系统 43
2.4.3 示例：Globule中的差分复制策略 44
2.4.4 示例：Jade的自动组件修复管理 45
本章小结 46
习题 47
第3章 进程 48
3.1 线程 48
3.1.1 线程简介 49
3.1.2 分布式系统中的线程 52
3.2 虚拟化 55
3.2.1 虚拟化在分布式系统中的作用 55
3.2.2 虚拟机体系结构 56
3.3 客户 57
3.3.1 网络连接的用户接口 58
3.3.2 客户端软件与分布透明性 61
3.4 服务器 62
3.4.1 常见的设计问题 62
3.4.2 服务器集群 65
3.4.3 管理服务器集群 69
3.5 代码迁移 72
3.5.1 代码迁移方案 72
3.5.2 迁移与本地资源 75
3.5.3 异构系统中的代码迁移 77
本章小结 79
习题 80
第4章 通信 81
4.1 基础知识 81
4.1.1 分层协议 82
4.1.2 通信类型 87
4.2 远程过程调用 89
4.2.1 基本的RPC操作 89
4.2.2 参数传递 92
4.2.3 异步RPC 95
4.2.4 示例：DCE RPC 96
4.3 面向消息的通信 101
4.3.1 面向消息的瞬时通信 101
4.3.2 面向消息的持久通信 104
4.3.3 示例：IBM WebSphere消息队列系统 109
4.4 面向流的通信 113
4.4.1 为连续媒体提供支持 114
4.4.2 流与服务质量 115
4.4.3 流同步 117
4.5 多播通信 120
4.5.1 应用层多播 120
4.5.2 基于gossip的数据通信 123
本章小结 126
习题 127
第5章 命名系统 129
5.1 名称、标识符和地址 129
5.2 无层次命名 131
5.2.1 简单方法 131
5.2.2 基于宿主位置的方法 134
5.2.3 分布式散列表 135
5.2.4 分层方法 138
5.3 结构化命名 141
5.3.1 名称空间 141
5.3.2 名称解析 143
5.3.3 名称空间的实现 146
5.3.4 示例：域名系统 151
5.4 基于属性的命名 157
5.4.1 目录服务 157
5.4.2 分层实现：LDAP 158
5.4.3 非集中式实现 161
本章小结 164
习题 165
第6章 同步化 167
6.1 时钟同步 167
6.1.1 物理时钟 168
6.1.2 全球定位系统 171
6.1.3 时钟同步算法 172
6.2 逻辑时钟 176
6.2.1 Lamport逻辑时钟 176
6.2.2 向量时钟 179
6.3 互斥 182
6.3.1 概述 182
6.3.2 集中式算法 182
6.3.3 非集中式算法 183
6.3.4 分布式算法 184
6.3.5 令牌环算法 186
6.3.6 四种算法的比较 187
6.4 结点的全局定位 188
6.5 选举算法 190
6.5.1 传统的选举算法 190
6.5.2 无线系统环境中的选举算法 192
6.5.3 大型系统中的选举算法 193
本章小结 195
习题 196
第7章 一致性和复制 198
7.1 概述 198
7.1.1 进行复制的原因 198
7.1.2 作为扩展技术的复制 199
7.2 以数据为中心的一致性模型 200
7.2.1 持续一致性 201
7.2.2 一致的操作顺序 204
7.3 以客户为中心的一致性模型 209
7.3.1 最终一致性 209
7.3.2 单调读 211
7.3.3 单调写 212
7.3.4 读写一致性 213
7.3.5 写读一致性 214
7.4 复制管理 214
7.4.1 副本服务器的放置 215
7.4.2 内容复制与放置 216
7.4.3 内容分发 219
7.5 一致性协议 222
7.5.1 持续一致性 222
7.5.2 基于主备份的协议 223
7.5.3 复制的写协议 225
7.5.4 高速缓存相关性协议 227
7.5.5 实现以客户为中心的一致性 228
本章小结 230
习题 231
第8章 容错性 233
8.1 容错性概述 233
8.1.1 基本概念 233
8.1.2 故障模式 235
8.1.3 使用冗余掩盖故障 237
8.2 进程恢复 238
8.2.1 设计问题 238
8.2.2 故障掩盖和复制 240
8.2.3 故障系统的协定 240
8.2.4 故障检测 243
8.3 可靠的客户-服务器通信 244
8.3.1 点对点通信 244
8.3.2 失败时的RPC语义 244
8.4 可靠的组通信 248
8.4.1 基本的可靠多播方法 249
8.4.2 可靠多播中的可扩展性 249
8.4.3 原子多播 252
8.5 分布式提交 257
8.5.1 两阶段提交 257
8.5.2 三阶段提交 262
8.6 恢复 263
8.6.1 概述 263
8.6.2 检查点 266
8.6.3 消息日志 268
8.6.4 面向恢复的计算 270
本章小结 271
习题 271
第9章 安全性 273
9.1 安全性概述 273
9.1.1 安全威胁、策略和机制 273
9.1.2 设计问题 277
9.1.3 加密 281
9.2 安全通道 287
9.2.1 身份认证 287
9.2.2 消息的完整性和机密性 293
9.2.3 安全组通信 295
9.2.4 示例：Kerberos 298
9.3 访问控制 299
9.3.1 访问控制中的常见问题 299
9.3.2 防火墙 302
9.3.3 安全的移动代码 304
9.3.4 拒绝服务 309
9.4 安全管理 310
9.4.1 密钥管理 310
9.4.2 安全组管理 313
9.4.3 授权管理 314
本章小结 318
习题 319
第10章 基于对象的分布式系统 320
10.1 体系结构 320
10.1.1 分布式对象 320
10.1.2 示例：企业级Java Bean 322
10.1.3 示例：Globe分布式共享对象 324
10.2 进程 325
10.2.1 对象服务器 325
10.2.2 示例：Ice运行时系统 327
10.3 通信 329
10.3.1 把客户绑定到对象上 329
10.3.2 静态远程方法调用与动态远程方法调用 330
10.3.3 参数传递 331
10.3.4 示例：Java RMI 332
10.3.5 基于对象的消息传递 334
10.4 命名 337
10.4.1 CORBA对象引用 337
10.4.2 Globe对象引用 338
10.5 同步 340
10.6 一致性与复制 341
10.6.1 入口一致性 341
10.6.2 复制的调用 343
10.7 容错性 344
10.7.1 示例：CORBA的容错性 345
10.7.2 示例：Java的容错性 346
10.8 安全性 348
10.8.1 示例：Globe 348
10.8.2 远程对象的安全性 351
本章小结 352
习题 353
第11章 分布式文件系统 354
11.1 体系结构 354
11.1.1 客户-服务器体系结构 354
11.1.2 基于群集的分布式文件系统 358
11.1.3 对称式体系结构 360
11.2 进程 361
11.3 通信 362
11.3.1 NFS中的RPC 362
11.3.2 RPC2子系统 363
11.3.3 Plan 9中面向文件的通信 365
11.4 命名 366
11.4.1 NFS中的命名 366
11.4.2 构造全局名称空间 370
11.5 同步 371
11.5.1 文件共享的语义 371
11.5.2 文件锁定 373
11.5.3 在Coda中共享文件 375
11.6 一致性和复制 376
11.6.1 客户端缓存 376
11.6.2 服务器端复制 379
11.6.3 对等文件系统中的复制 381
11.6.4 网格系统中的文件复制 382
11.7 容错性 383
11.7.1 处理Byzantine故障 383
11.7.2 对等系统中的高度可用性 385
11.8 安全性 386
11.8.1 NFS中的安全性 386
11.8.2 分散式身份认证 388
11.8.3 安全的对等文件共享系统 391
本章小结 393
习题 394
第12章 基于Web的分布式系统 395
12.1 体系结构 395
12.1.1 传统的基于Web的系统 396
12.1.2 Web服务 399
12.2 进程 402
12.2.1 客户 402
12.2.2 Apache Web服务器 403
12.2.3 Web服务器群集 405
12.3 通信 406
12.3.1 超文本传输协议 407
12.3.2 简单对象访问协议 411
12.4 命名 412
12.5 同步 414
12.6 一致性与复制 414
12.6.1 Web代理缓存 415
12.6.2 Web宿主系统的复制 417
12.6.3 Web应用程序的复制 421
12.7 容错性 423
12.8 安全性 424
本章小结 425
习题 426
第13章 基于协作的分布式系统 428
13.1 协作模型介绍 428
13.2 体系结构 430
13.2.1 一般方法 430
13.2.2 传统的体系结构 431
13.2.3 对等体系结构 434
13.2.4 移动性和协作 436
13.3 进程 437
13.4 通信 437
13.4.1 基于内容的路由 437
13.4.2 支持复合订阅 439
13.5 命名 439
13.5.1 描述复合事件 440
13.5.2 匹配事件与订阅 441
13.6 同步 442
13.7 一致性和复制 442
13.7.1 静态方法 442
13.7.2 动态复制 445
13.8 容错性 447
13.8.1 可靠的发布-订阅通信 447
13.8.2 共享数据空间中的容错性 449
13.9 安全性 450
13.9.1 保密性 450
13.9.2 安全的共享数据空间 452
本章小结 452
习题 453
第14章 补充读物与参考文献 454
14.1 进一步阅读的建议 454
14.1.1 介绍性和综述性的著作 454
14.1.2 体系结构 455
14.1.3 进程 455
14.1.4 通信 456
14.1.5 命名 456
14.1.6 同步化 457
14.1.7 一致性与复制 457
14.1.8 容错性 458
14.1.9 安全性 458
14.1.10 面向对象的分布式系统 459
14.1.11 分布式文件系统 459
14.1.12 基于Web的分布式系统 460
14.1.13 基于协作的分布式系统 460
14.2 参考文献 461
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式系统原理与范型
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式系统
出版者的话
译者序
前言
第1章　分布式系统的特征1
1.1　简介1
1.2　分布式系统的例子2
1.2.1　Web搜索2
1.2.2　大型多人在线游戏3
1.2.3　金融交易3
1.3　分布式系统的趋势4
1.3.1　泛在联网和现代互联网5
1.3.2　移动和无处不在计算5
1.3.3　分布式多媒体系统7
1.3.4　把分布式计算作为一个公共设施7
1.4　关注资源共享8
1.5　挑战9
1.5.1　异构性9
1.5.2　开放性10
1.5.3　安全性11
1.5.4　可伸缩性11
1.5.5　故障处理12
1.5.6　并发性13
1.5.7　透明性14
1.5.8　服务质量15
1.6　实例研究：万维网15
1.7　小结20
练习20
第2章　系统模型22
2.1　简介22
2.2　物理模型23
2.3　体系结构模型24
2.3.1　体系结构元素24
2.3.2　体系结构模式30
2.3.3　相关的中间件解决方案34
2.4　基础模型36
2.4.1　交互模型36
2.4.2　故障模型39
2.4.3　安全模型41
2.5　小结44
练习45
第3章　网络和网际互连46
3.1　简介46
3.2　网络类型48
3.3　网络原理50
3.3.1　数据包的传输50
3.3.2　数据流50
3.3.3　交换模式51
3.3.4　协议52
3.3.5　路由55
3.3.6　拥塞控制57
3.3.7　网际互连58
3.4　互联网协议60
3.4.1　IP寻址62
3.4.2　IP协议63
3.4.3　IP路由64
3.4.4　IPv667
3.4.5　移动IP69
3.4.6　TCP和UDP70
3.4.7　域名71
3.4.8　防火墙72
3.5　实例研究：以太网、WiFi、蓝牙74
3.5.1　以太网75
3.5.2　IEEE 802.11无线LAN78
3.5.3　IEEE 802.15.1蓝牙无线PAN79
3.6　小结81
练习81
第4章　进程间通信83
4.1　简介83
4.2　互联网协议的API84
4.2.1　进程间通信的特征84
4.2.2　套接字85
4.2.3　UDP数据报通信85
4.2.4　TCP流通信88
4.3　外部数据表示和编码91
4.3.1　CORBA的公共数据表示92
4.3.2　Java对象序列化93
4.3.3　可扩展标记语言94
4.3.4　远程对象引用97
4.4　组播通信98
4.4.1　IP组播——组播通信的实现98
4.4.2　组播的可靠性和排序100
4.5　网络虚拟化：覆盖网络101
4.5.1　覆盖网络101
4.5.2　Skype：一个覆盖网络的例子102
4.6　实例研究：MPI103
4.7　小结104
练习105
第5章　远程调用107
5.1　简介107
5.2　请求-应答协议107
5.3　远程过程调用112
5.3.1　RPC的设计问题113
5.3.2　RPC的实现115
5.3.3　实例研究：Sun RPC116
5.4　远程方法调用118
5.4.1　RMI的设计问题118
5.4.2　RMI的实现121
5.4.3　分布式无用单元收集124
5.5　实例研究：Java RMI125
5.5.1　创建客户和服务器程序127
5.5.2　Java RMI的设计和实现130
5.6　小结130
练习131
第6章　间接通信133
6.1　简介133
6.2　组通信134
6.2.1　编程模型135
6.2.2　实现问题136
6.2.3　实例研究：JGroups工具箱138
6.3　发布-订阅系统140
6.3.1　编程模型142
6.3.2　实现问题143
6.3.3　发布-订阅系统的例子146
6.4　消息队列146
6.4.1　编程模型147
6.4.2　实现问题148
6.4.3　实例研究：Java消息服务149
6.5　共享内存的方式152
6.5.1　分布式共享内存152
6.5.2　元组空间通信153
6.6　小结159
练习161
第7章　操作系统支持162
7.1　简介162
7.2　操作系统层163
7.3　保护164
7.4　进程和线程165
7.4.1　地址空间166
7.4.2　新进程的生成167
7.4.3　线程169
7.5　通信和调用176
7.5.1　调用性能177
7.5.2　异步操作181
7.6　操作系统的体系结构183
7.7　操作系统层的虚拟化185
7.7.1　系统虚拟化186
7.7.2　实例研究：系统虚拟化的Xen方法186
7.8　小结193
练习194
第8章　分布式对象和组件196
8.1　简介196
8.2　分布式对象197
8.3　实例研究：CORBA198
8.3.1　CORBA RMI199
8.3.2　CORBA的体系结构203
8.3.3　CORBA远程对象引用205
8.3.4　CORBA服务206
8.3.5　CORBA客户和服务器实例206
8.4　从对象到组件209
8.5　实例研究：企业JavaBeans和Fractal212
8.5.1　企业JavaBeans213
8.5.2　Fractal217
8.6　小结220
练习220
第9章　Web服务222
9.1　简介222
9.2　Web服务223
9.2.1　SOAP225
9.2.2　Web服务与分布式对象模型的比较228
9.2.3　在Java中使用SOAP229
9.2.4　Web服务和CORBA的比较232
9.3　Web服务的服务描述和接口定义语言233
9.4　Web服务使用的目录服务235
9.5　XML安全性237
9.6　Web服务的协作239
9.7　Web服务的应用241
9.7.1　面向服务的体系结构241
9.7.2　网格241
9.7.3　云计算243
9.8　小结244
练习245
第10章　对等系统247
10.1　简介247
10.2　Napster及其遗留系统250
10.3　对等中间件251
10.4　路由覆盖252
10.5　路由覆盖实例研究：Pastry和Tapestry254
10.5.1　Pastry254
10.5.2　Tapestry260
10.5.3　从结构化对等方法到非结构化对等方法260
10.6　应用实例研究：Squirrel、OceanStore和Ivy262
10.6.1　Squirrel Web缓存263
10.6.2　OceanStore文件存储264
10.6.3　Ivy文件系统267
10.7　小结269
练习269
第11章　安全性271
11.1　简介271
11.1.1　威胁和攻击272
11.1.2　保护电子事务274
11.1.3　设计安全系统275
11.2　安全技术概述276
11.2.1　密码学277
11.2.2　密码学的应用277
11.2.3　证书279
11.2.4　访问控制280
11.2.5　凭证282
11.2.6　防火墙283
11.3　密码算法283
11.3.1　密钥（对称）算法285
11.3.2　公钥（不对称）算法288
11.3.3　混合密码协议289
11.4　数字签名289
11.4.1　公钥数字签名290
11.4.2　密钥数字签名——MAC291
11.4.3　安全摘要函数291
11.4.4　证书标准和证书权威机构292
11.5　密码实用学293
11.5.1　密码算法的性能293
11.5.2　密码学的应用和政治障碍294
11.6　实例研究：Needham-Schroeder、Kerberos、TLS和802.11 WiFi295
11.6.1　Needham-Schroeder认证协议295
11.6.2　Kerberos296
11.6.3　使用安全套接字确保电子交易安全300
11.6.4　IEEE 802.11 WiFi安全设计中最初的缺陷302
11.7　小结303
练习304
第12章　分布式文件系统305
12.1　简介305
12.1.1　文件系统的特点307
12.1.2　分布式文件系统的需求308
12.1.3　实例研究309
12.2　文件服务体系结构310
12.3　实例研究：SUN网络文件系统313
12.4　实例研究：Andrew文件系统321
12.4.1　实现322
12.4.2　缓存的一致性324
12.4.3　其他方面326
12.5　最新进展327
12.6　小结330
练习331
第13章　名字服务332
13.1　简介332
13.2　名字服务和域名系统334
13.2.1　名字空间335
13.2.2　名字解析337
13.2.3　域名系统339
13.3　目录服务344
13.4　实例研究：全局名字服务344
13.5　实例研究：X.500目录服务346
13.6　小结349
练习349
第14章　时间和全局状态351
14.1　简介351
14.2　时钟、事件和进程状态352
14.3　同步物理时钟353
14.3.1　同步系统中的同步354
14.3.2　同步时钟的Cristian方法354
14.3.3　Berkeley算法355
14.3.4　网络时间协议355
14.4　逻辑时间和逻辑时钟357
14.5　全局状态359
14.5.1　全局状态和一致割集360
14.5.2　全局状态谓词、稳定性、安全性和活性362
14.5.3　Chandy和Lamport的“快照”算法362
14.6　分布式调试365
14.6.1　收集状态366
14.6.2　观察一致的全局状态366
14.6.3　判定可能的367
14.6.4　判定明确的368
14.6.5　在同步系统中判定可能的和明确的369
14.7　小结369
练习369
第15章　协调和协定371
15.1　简介371
15.2　分布式互斥373
15.3　选举377
15.4　组通信中的协调与协定380
15.4.1　基本组播381
15.4.2　可靠组播381
15.4.3　有序组播383
15.5　共识和相关问题388
15.5.1　系统模型和问题定义389
15.5.2　同步系统中的共识问题391
15.5.3　同步系统中的拜占庭将军问题392
15.5.4　异步系统的不可能性394
15.6　小结395
练习396
第16章　事务和并发控制398
16.1　简介398
16.1.1　简单的同步机制（无事务）399
16.1.2　事务的故障模型400
16.2　事务400
16.2.1　并发控制402
16.2.2　事务放弃时的恢复405
16.3　嵌套事务406
16.4　锁408
16.4.1　死锁413
16.4.2　在加锁机制中增加并发度415
16.5　乐观并发控制417
16.6　时间戳排序419
16.7　并发控制方法的比较423
16.8　小结425
练习425
第17章　分布式事务429
17.1　简介429
17.2　平面分布式事务和嵌套分布式事务429
17.3　原子提交协议431
17.3.1　两阶段提交协议432
17.3.2　嵌套事务的两阶段提交协议434
17.4　分布式事务的并发控制437
17.4.1　加锁437
17.4.2　时间戳并发控制437
17.4.3　乐观并发控制438
17.5　分布式死锁439
17.6　事务恢复444
17.6.1　日志445
17.6.2　影子版本446
17.6.3　为何恢复文件需要事务状态和意图列表447
17.6.4　两阶段提交协议的恢复448
17.7　小结450
练习450
第18章　复制453
18.1　简介453
18.2　系统模型和组通信的作用454
18.2.1　系统模型455
18.2.2　组通信的作用456
18.3　容错服务459
18.3.1　被动（主备份）复制461
18.3.2　主动复制462
18.4　高可用服务的实例研究：闲聊体系结构、Bayou和Coda463
18.4.1　闲聊体系结构464
18.4.2　Bayou系统和操作变换方法469
18.4.3　Coda文件系统471
18.5　复制数据上的事务475
18.5.1　复制事务的体系结构476
18.5.2　可用拷贝复制477
18.5.3　网络分区479
18.5.4　带验证的可用拷贝479
18.5.5　法定数共识方法480
18.5.6　虚拟分区算法481
18.6　小结483
练习484
第19章　移动和无处不在计算486
19.1　简介486
19.2　关联491
19.2.1　发现服务492
19.2.2　物理关联495
19.2.3　小结和前景496
19.3　互操作497
19.3.1　易变系统的面向数据编程497
19.3.2　间接关联和软状态500
19.3.3　小结和前景501
19.4　感知和上下文敏感501
19.4.1　传感器502
19.4.2　感知体系结构502
19.4.3　位置感知506
19.4.4　小结和前景509
19.5　安全性和私密性510
19.5.1　背景510
19.5.2　一些解决办法511
19.5.3　小结和前景515
19.6　自适应515
19.6.1　内容的上下文敏感自适应515
19.6.2　适应变化的系统资源517
19.6.3　小结和前景518
19.7　实例研究：Cooltown518
19.7.1　Web存在519
19.7.2　物理超链接520
19.7.3　互操作和eSquirt协议521
19.7.4　小结和前景522
19.8　小结523
练习523
第20章　分布式多媒体系统525
20.1　简介525
20.2　多媒体数据的特征527
20.3　服务质量管理528
20.3.1　服务质量协商531
20.3.2　许可控制534
20.4　资源管理534
20.5　流自适应535
20.5.1　调整536
20.5.2　过滤536
20.6　实例研究：Tiger视频文件服务器、BitTorrent和端系统多播537
20.6.1　Tiger视频文件服务器537
20.6.2　BitTorrent540
20.6.3　端系统多播541
20.7　小结544
练习544
第21章　分布式系统设计：Google实例研究546
21.1　简介546
21.2　实例研究简介：Google547
21.3　总体结构和设计理念550
21.3.1　物理模型550
21.3.2　总的系统体系结构551
21.4　底层通信范型553
21.4.1　远程调用554
21.4.2　发布-订阅556
21.4.3　通信的关键设计选择总结557
21.5　数据存储和协调服务557
21.5.1　Google文件系统557
21.5.2　Chubby561
21.5.3　Bigtable565
21.5.4　关键设计选择总结570
21.6　分布式计算服务571
21.6.1　MapReduce571
21.6.2　Sawzall574
21.6.3　关键设计选择总结575
21.7　小结576
练习576
参考文献578
索引615
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ZooKeeper:分布式过程协同技术详解
前言1
第一部分ZooKeeper的概念和基础
第1章简介7
1.1ZooKeeper的使命8
1.1.1ZooKeeper改变了什么10
1.1.2ZooKeeper不适用的场景10
1.1.3关于Apache项目11
1.1.4通过ZooKeeper构建分布式系统11
1.2示例：主—从应用12
1.2.1主节点失效13
1.2.2从节点失效14
1.2.3通信故障14
1.2.4任务总结15
1.3分布式协作的难点16
1.4ZooKeeper的成功和注意事项18
第2章了解ZooKeeper19
2.1ZooKeeper基础19
2.1.1API概述20
2.1.2znode的不同类型21
2.1.3监视与通知22
2.1.4版本24
2.2ZooKeeper架构25
2.2.1ZooKeeper仲裁26
2.2.2会话27
2.3开始使用ZooKeeper28
2.3.1第一个ZooKeeper会话28
2.3.2会话的状态和声明周期31
2.3.3ZooKeeper与仲裁模式33
2.3.4实现一个原语：通过ZooKeeper实现锁36
2.4一个主—从模式例子的实现37
2.4.1主节点角色37
2.4.2从节点、任务和分配40
2.4.3从节点角色40
2.4.4客户端角色41
2.5小结43
第二部分使用ZooKeeper进行开发
第3章开始使用ZooKeeper的API47
3.1设置ZooKeeper的CLASSPATH47
3.2建立ZooKeeper会话47
3.2.1实现一个Watcher49
3.2.2运行Watcher的示例51
3.3获取管理权53
3.3.1异步获取管理权57
3.3.2设置元数据60
3.4注册从节点62
3.5任务队列化65
3.6管理客户端66
3.7小结68
第4章处理状态变化70
4.1单次触发器71
4.2如何设置监视点72
4.3普遍模型73
4.4主—从模式的例子74
4.4.1管理权变化74
4.4.2主节点等待从节点列表的变化77
4.4.3主节点等待新任务进行分配80
4.4.4从节点等待分配新任务83
4.4.5客户端等待任务的执行结果86
4.5另一种调用方式：Multiop88
4.6通过监视点代替显式缓存管理90
4.7顺序的保障91
4.7.1写操作的顺序91
4.7.2读操作的顺序91
4.7.3通知的顺序92
4.8监视点的羊群效应和可扩展性93
4.9小结94
第5章故障处理96
5.1可恢复的故障98
5.2不可恢复的故障102
5.3群首选举和外部资源103
5.4小结106
第6章ZooKeeper注意事项107
6.1使用ACL107
6.1.1内置的鉴权模式108
6.1.2SASL和Kerberos111
6.1.3增加新鉴权模式111
6.2恢复会话111
6.3当znode节点重新创建时，重置版本号112
6.4sync方法112
6.5顺序性保障114
6.5.1连接丢失时的顺序性114
6.5.2同步API和多线程的顺序性115
6.5.3同步和异步混合调用的顺序性115
6.6数据字段和子节点的限制116
6.7嵌入式ZooKeeper服务器116
6.8小结117
第7章C语言客户端118
7.1配置开发环境118
7.2开始会话119
7.3引导主节点121
7.4行使管理权126
7.5任务分配129
7.6单线程与多线程客户端132
7.7小结135
第8章Curator：ZooKeeperAPI的高级封装库136
8.1Curator客户端程序136
8.2流畅式API137
8.3监听器138
8.4Curator中状态的转换140
8.5两种边界情况141
8.6菜谱141
8.6.1群首闩142
8.6.2群首选举器143
8.6.3子节点缓存器146
8.7小结148
第三部分ZooKeeper的管理
第9章ZooKeeper内部原理151
9.1请求、事务和标识符152
9.2群首选举153
9.3Zab：状态更新的广播协议157
9.4观察者161
9.5服务器的构成162
9.5.1独立服务器163
9.5.2群首服务器164
9.5.3追随者和观察者服务器165
9.6本地存储166
9.6.1日志和磁盘的使用166
9.6.2快照167
9.7服务器与会话169
9.8服务器与监视点170
9.9客户端170
9.10序列化171
9.11小结171
第10章运行ZooKeeper173
10.1配置ZooKeeper服务器174
10.1.1基本配置175
10.1.2存储配置175
10.1.3网络配置177
10.1.4集群配置179
10.1.5认证和授权选项181
10.1.6非安全配置182
10.1.7日志183
10.1.8专用资源185
10.2配置ZooKeeper集群185
10.2.1多数原则186
10.2.2法定人数的可配置性186
10.2.3观察者188
10.3重配置188
10.4配额管理194
10.5多租赁配置196
10.6文件系统布局和格式197
10.6.1事务日志198
10.6.2快照199
10.6.3时间戳文件200
10.6.4已保存的ZooKeeper数据的应用200
10.7四字母命令201
10.8通过JMX进行监控202
10.9工具209
10.10小结209
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ZooKeeper:分布式过程协同技术详解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据
目　　录

第1章　 数据挖掘基本概念　　1
1.1　 数据挖掘的定义　　1
1.1.1　 统计建模　　1
1.1.2　 机器学习　　1
1.1.3　 建模的计算方法　　2
1.1.4　 数据汇总　　2
1.1.5　 特征抽取　　3
1.2　 数据挖掘的统计限制　　4
1.2.1　 整体情报预警　　4
1.2.2　 邦弗朗尼原理　　4
1.2.3　 邦弗朗尼原理的一个例子　　5
1.2.4　 习题　　6
1.3　 相关知识　　6
1.3.1　 词语在文档中的重要性　　6
1.3.2　 哈希函数　　7
1.3.3　 索引　　8
1.3.4　 二级存储器　　10
1.3.5　 自然对数的底e　　10
1.3.6　 幂定律　　11
1.3.7　 习题　　12
1.4　 本书概要　　13
1.5　 小结　　14
1.6　 参考文献　　14
第2章　 大规模文件系统及Map-Reduce　　16
2.1　 分布式文件系统　　16
2.1.1　 计算节点的物理结构　　17
2.1.2　 大规模文件系统的结构　　18
2.2　 Map-Reduce　　18
2.2.1　 Map任务　　19
2.2.2　 分组和聚合　　20
2.2.3　 Reduce任务　　20
2.2.4　 组合器　　21
2.2.5　 Map-Reduce的执行细节　　21
2.2.6　 节点失效的处理　　22
2.3　 使用Map-Reduce的算法　　22
2.3.1　 基于Map-Reduce的矩阵—向量乘法实现　　23
2.3.2　 向量v无法放入内存时的处理　　23
2.3.3　 关系代数运算　　24
2.3.4　 基于Map-Reduce的选择运算　　26
2.3.5　 基于Map-Reduce的投影运算　　26
2.3.6　 基于Map-Reduce的并、交和差运算　　27
2.3.7　 基于Map-Reduce的自然连接运算　　27
2.3.8　 一般性的连接算法　　28
2.3.9　 基于Map-Reduce的分组和聚合运算　　28
2.3.10　 矩阵乘法　　29
2.3.11　 基于单步Map-Reduce的矩阵乘法　　29
2.3.12　 习题　　30
2.4　 Map-Reduce的扩展　　31
2.4.1　 工作流系统　　31
2.4.2　 Map-Reduce的递归扩展版本　　32
2.4.3　 Pregel系统　　34
2.4.4　 习题　　35
2.5　 集群计算算法的效率问题　　35
2.5.1　 集群计算的通信开销模型　　35
2.5.2　 实耗通信开销　　36
2.5.3　 多路连接　　37
2.5.4　 习题　　40
2.6　 小结　　40
2.7　 参考文献　　42
第3章　 相似项发现　　44
3.1　 近邻搜索的应用　　44
3.1.1　 集合的Jaccard相似度　　44
3.1.2　 文档的相似度　　45
3.1.3　 协同过滤——一个集合相似问题　　46
3.1.4　 习题　　47
3.2　 文档的Shingling　　47
3.2.1　 k-Shingle　　47
3.2.2　 shingle大小的选择　　48
3.2.3　 对shingle进行哈希　　48
3.2.4　 基于词的shingle　　49
3.2.5　 习题　　49
3.3　 保持相似度的集合摘要表示　　49
3.3.1　 集合的矩阵表示　　50
3.3.2　 最小哈希　　50
3.3.3　 最小哈希及Jaccard相似度　　51
3.3.4　 最小哈希签名　　52
3.3.5　 最小哈希签名的计算　　52
3.3.6　 习题　　54
3.4　 文档的局部敏感哈希算法　　55
3.4.1　 面向最小哈希签名的LSH　　56
3.4.2　 行条化策略的分析　　57
3.4.3　 上述技术的综合　　58
3.4.4　 习题　　59
3.5　 距离测度　　59
3.5.1　 距离测度的定义　　59
3.5.2　 欧氏距离　　60
3.5.3　 Jaccard距离　　60
3.5.4　 余弦距离　　61
3.5.5　 编辑距离　　62
3.5.6　 海明距离　　63
3.5.7　 习题　　63
3.6　 局部敏感函数理论　　64
3.6.1　 局部敏感函数　　65
3.6.2　 面向Jaccard距离的局部敏感函数族　　66
3.6.3　 局部敏感函数族的放大处理　　66
3.6.4　 习题　　68
3.7　 面向其他距离测度的LSH函数族　　68
3.7.1　 面向海明距离的LSH函数族　　69
3.7.2　 随机超平面和余弦距离　　69
3.7.3　 梗概　　70
3.7.4　 面向欧氏距离的LSH函数族　　71
3.7.5　 面向欧氏空间的更多LSH函数族　　72
3.7.6　 习题　　72
3.8　 LSH函数的应用　　73
3.8.1　 实体关联　　73
3.8.2　 一个实体关联的例子　　74
3.8.3　 记录匹配的验证　　74
3.8.4　 指纹匹配　　75
3.8.5　 适用于指纹匹配的LSH函数族　　76
3.8.6　 相似新闻报道检测　　77
3.8.7　 习题　　78
3.9　 面向高相似度的方法　　79
3.9.1　 相等项发现　　79
3.9.2　 集合的字符串表示方法　　79
3.9.3　 基于长度的过滤　　80
3.9.4　 前缀索引　　81
3.9.5　 位置信息的使用　　82
3.9.6　 使用位置和长度信息的索引　　83
3.9.7　 习题　　85
3.10　 小结　　85
3.11　 参考文献　　87
第4章　 数据流挖掘　　89
4.1　 流数据模型　　89
4.1.1　 一个数据流管理系统　　89
4.1.2　 流数据源的例子　　90
4.1.3　 流查询　　91
4.1.4　 流处理中的若干问题　　92
4.2　 流当中的数据抽样　　92
4.2.1　 一个富于启发性的例子　　93
4.2.2　 代表性样本的获取　　93
4.2.3　 一般的抽样问题　　94
4.2.4　 样本规模的变化　　94
4.2.5　 习题　　95
4.3　 流过滤　　95
4.3.1　 一个例子　　95
4.3.2　 布隆过滤器　　96
4.3.3　 布隆过滤方法的分析　　96
4.3.4　 习题　　97
4.4　 流中独立元素的数目统计　　98
4.4.1　 独立元素计数问题　　98
4.4.2　 FM算法　　98
4.4.3　 组合估计　　99
4.4.4　 空间需求　　100
4.4.5　 习题　　100
4.5　 矩估计　　100
4.5.1　 矩定义　　100
4.5.2　 二阶矩估计的AMS算法　　101
4.5.3　 AMS算法有效的原因　　102
4.5.4　 更高阶矩的估计　　103
4.5.5　 无限流的处理　　103
4.5.6　 习题　　104
4.6　 窗口内的计数问题　　105
4.6.1　 精确计数的开销　　105
4.6.2　 DGIM算法　　105
4.6.3　 DGIM算法的存储需求　　107
4.6.4　 DGIM算法中的查询应答　　107
4.6.5　 DGIM条件的保持　　108
4.6.6　 降低错误率　　109
4.6.7　 窗口内计数问题的扩展　　109
4.6.8　 习题　　110
4.7　 衰减窗口　　110
4.7.1　 最常见元素问题　　110
4.7.2　 衰减窗口的定义　　111
4.7.3　 最流行元素的发现　　111
4.8　 小结　　112
4.9　 参考文献　　113
第5章　 链接分析　　115
5.1　 PageRank　　115
5.1.1　 早期的搜索引擎及词项作弊　　115
5.1.2　 PageRank的定义　　117
5.1.3　 Web结构　　119
5.1.4　 避免终止点　　121
5.1.5　 采集器陷阱及“抽税”法　　123
5.1.6　 PageRank在搜索引擎中的使用　　125
5.1.7　 习题　　125
5.2　 PageRank的快速计算　　126
5.2.1　 转移矩阵的表示　　127
5.2.2　 基于Map-Reduce的PageRank迭代计算　　128
5.2.3　 结果向量合并时的组合器使用　　128
5.2.4　 转移矩阵中块的表示　　129
5.2.5　 其他高效的PageRank迭代方法　　130
5.2.6　 习题　　131
5.3　 面向主题的PageRank　　131
5.3.1　 动机　　131
5.3.2　 有偏的随机游走模型　　132
5.3.3　 面向主题的PageRank的使用　　133
5.3.4　 基于词汇的主题推断　　134
5.3.5　 习题　　134
5.4　 链接作弊　　135
5.4.1　 垃圾农场的架构　　135
5.4.2　 垃圾农场的分析　　136
5.4.3　 与链接作弊的斗争　　137
5.4.4　 TrustRank　　137
5.4.5　 垃圾质量　　137
5.4.6　 习题　　138
5.5　 导航页和权威页　　139
5.5.1　 HITS的直观意义　　139
5.5.2　 导航度和权威度的形式化　　139
5.5.3　 习题　　142
5.6　 小结　　143
5.7　 参考文献　　145
第6章　 频繁项集　　146
6.1　 购物篮模型　　146
6.1.1　 频繁项集的定义　　146
6.1.2　 频繁项集的应用　　148
6.1.3　 关联规则　　149
6.1.4　 高可信度关联规则的发现　　150
6.1.5　 习题　　151
6.2　 购物篮及A-Priori算法　　152
6.2.1　 购物篮数据的表示　　152
6.2.2　 项集计数中的内存使用　　153
6.2.3　 项集的单调性　　154
6.2.4　 二元组计数　　155
6.2.5　 A-Priori算法　　155
6.2.6　 所有频繁项集上的A-Priori算法　　157
6.2.7　 习题　　158
6.3　 更大数据集在内存中的处理　　159
6.3.1　 PCY算法　　160
6.3.2　 多阶段算法　　161
6.3.3　 多哈希算法　　163
6.3.4　 习题　　164
6.4　 有限扫描算法　　166
6.4.1　 简单的随机化算法　　166
6.4.2　 抽样算法中的错误规避　　167
6.4.3　 SON算法　　168
6.4.4　 SON算法和Map-Reduce　　168
6.4.5　 Toivonen算法　　169
6.4.6　 Toivonen算法的有效性分析　　170
6.4.7　 习题　　170
6.5　 流中的频繁项计数　　171
6.5.1　 流的抽样方法　　171
6.5.2　 衰减窗口中的频繁项集　　172
6.5.3　 混合方法　　172
6.5.4　 习题　　173
6.6　 小结　　173
6.7　 参考文献　　175
第7章　 聚类　　176
7.1　 聚类技术介绍　　176
7.1.1　 点、空间和距离　　176
7.1.2　 聚类策略　　177
7.1.3　 维数灾难　　178
7.1.4　 习题　　179
7.2　 层次聚类　　179
7.2.1　 欧氏空间下的层次聚类　　180
7.2.2　 层次聚类算法的效率　　183
7.2.3　 控制层次聚类的其他规则　　183
7.2.4　 非欧空间下的层次聚类　　185
7.2.5　 习题　　186
7.3　 k-均值算法　　187
7.3.1　 k-均值算法基本知识　　187
7.3.2　 k-均值算法的簇初始化　　187
7.3.3　 选择k的正确值　　188
7.3.4　 BFR算法　　189
7.3.5　 BFR算法中的数据处理　　191
7.3.6　 习题　　192
7.4　 CURE算法　　193
7.4.1　 CURE算法的初始化　　194
7.4.2　 CURE算法的完成　　195
7.4.3　 习题　　195
7.5　 非欧空间下的聚类　　196
7.5.1　 GRGPF算法中的簇表示　　196
7.5.2　 簇表示树的初始化　　196
7.5.3　 GRGPF算法中的点加入　　197
7.5.4　 簇的分裂及合并　　198
7.5.5　 习题　　199
7.6　 流聚类及并行化　　199
7.6.1　 流计算模型　　199
7.6.2　 一个流聚类算法　　200
7.6.3　 桶的初始化　　200
7.6.4　 桶合并　　200
7.6.5　 查询应答　　202
7.6.6　 并行环境下的聚类　　202
7.6.7　 习题　　203
7.7　 小结　　203
7.8　 参考文献　　205
第8章　 Web广告　　207
8.1　 在线广告相关问题　　207
8.1.1　 广告机会　　207
8.1.2　 直投广告　　208
8.1.3　 展示广告的相关问题　　208
8.2　 在线算法　　209
8.2.1　 在线和离线算法　　209
8.2.2　 贪心算法　　210
8.2.3　 竞争率　　211
8.2.4　 习题　　211
8.3　 广告匹配问题　　212
8.3.1　 匹配及完美匹配　　212
8.3.2　 最大匹配贪心算法　　213
8.3.3　 贪心匹配算法的竞争率　　213
8.3.4　 习题　　214
8.4　 Adwords问题　　214
8.4.1　 搜索广告的历史　　215
8.4.2　 Adwords问题的定义　　215
8.4.3　 Adwords问题的贪心方法　　216
8.4.4　 Balance算法　　217
8.4.5　 Balance算法竞争率的一个下界　　217
8.4.6　 多投标者的Balance算法　　219
8.4.7　 一般性的Balance算法　　220
8.4.8　 Adwords问题的最后论述　　221
8.4.9　 习题　　221
8.5　 Adwords的实现　　221
8.5.1　 投标和搜索查询的匹配　　222
8.5.2　 更复杂的匹配问题　　222
8.5.3　 文档和投标之间的匹配算法　　223
8.6　 小结　　224
8.7　 参考文献　　226
第9章　 推荐系统　　227
9.1　 一个推荐系统的模型　　227
9.1.1　 效用矩阵　　227
9.1.2　 长尾现象　　228
9.1.3　 推荐系统的应用　　230
9.1.4　 效用矩阵的填充　　230
9.2　 基于内容的推荐　　231
9.2.1　 项模型　　231
9.2.2　 文档的特征发现　　231
9.2.3　 基于Tag的项特征获取　　232
9.2.4　 项模型的表示　　233
9.2.5　 用户模型　　234
9.2.6　 基于内容的项推荐　　235
9.2.7　 分类算法　　235
9.2.8　 习题　　237
9.3　 协同过滤　　238
9.3.1　 相似度计算　　238
9.3.2　 相似度对偶性　　241
9.3.3　 用户聚类和项聚类　　242
9.3.4　 习题　　243
9.4　 降维处理　　243
9.4.1　 UV分解　　244
9.4.2　 RMSE　　244
9.4.3　 UV分解的增量式计算　　245
9.4.4　 对任一元素的优化　　247
9.4.5　 一个完整UV分解算法的构建　　248
9.4.6　 习题　　250
9.5　 NetFlix竞赛　　250
9.6　 小结　　251
9.7　 参考文献　　253
索引　　254

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式服务架构：原理、设计与实战
第1章  分布式微服务架构设计原理	1
1.1  从传统单体架构到服务化架构	2
1.1.1  JEE架构	2
1.1.2  SSH架构	5
1.1.3  服务化架构	8
1.2  从服务化到微服务	11
1.2.1  微服务架构的产生	12
1.2.2  微服务架构与传统单体架构的对比	13
1.2.3  微服务架构与SOA服务化的对比	15
1.3  微服务架构的核心要点和实现原理	16
1.3.1  微服务架构中职能团队的划分	16
1.3.2  微服务的去中心化治理	18
1.3.3  微服务的交互模式	18
1.3.4  微服务的分解和组合模式	22
1.3.5  微服务的容错模式	35
1.3.6  微服务的粒度	41
1.4  Java平台微服务架构的项目组织形式	42
1.4.1  微服务项目的依赖关系	42
1.4.2  微服务项目的层级结构	43
1.4.3  微服务项目的持续发布	45
1.5  服务化管理和治理框架的技术选型	45
1.5.1  RPC	46
1.5.2  服务化	47
1.5.3  微服务	49
1.6  本章小结	52
第2章  彻底解决分布式系统一致性的问题	54
2.1  什么是一致性	55
2.2  一致性问题	56
2.3  解决一致性问题的模式和思路	57
2.3.1  酸碱平衡理论	58
2.3.2  分布式一致性协议	61
2.3.3  保证最终一致性的模式	67
2.4  超时处理模式	75
2.4.1  微服务的交互模式	76
2.4.2  同步与异步的抉择	77
2.4.3  交互模式下超时问题的解决方案	78
2.4.4  超时补偿的原则	85
2.5  迁移开关的设计	87
2.6  本章小结	88
第3章  服务化系统容量评估和性能保障	89
3.1  架构设计与非功能质量	90
3.2  全面的非功能质量需求	91
3.2.1  非功能质量需求的概述	91
3.2.2  非功能质量需求的具体指标	92
3.3  典型的技术评审提纲	97
3.3.1  现状	97
3.3.2  需求	98
3.3.3  方案描述	98
3.3.4  方案对比	99
3.3.5  风险评估	100
3.3.6  工作量评估	100
3.4  性能和容量评估经典案例	100
3.4.1  背景	100
3.4.2  目标数据量级	101
3.4.3  量级评估标准	101
3.4.4  方案	102
3.4.5  小结	107
3.5  性能评估参考标准	108
3.5.1  常用的应用层性能指标参考标准	108
3.5.2  常用的系统层性能指标参考标准	109
3.6  性能测试方案的设计和最佳实践	112
3.6.1  明确压测目标	112
3.6.2  压测场景设计和压测方案制定	114
3.6.3  准备压测环境	121
3.6.4  压测的执行	122
3.6.5  问题修复和系统优化	123
3.7  有用的压测工具	123
3.7.1  ab	123
3.7.2  jmeter	125
3.7.3  mysqlslap	125
3.7.4  sysbench	129
3.7.5  dd	134
3.7.6  LoadRunner	135
3.7.7  hprof	136
3.8  本章小结	138
第4章  大数据日志系统的构建	140
4.1  开源日志框架的原理分析与应用实践	142
4.1.1  JDK Logger	142
4.1.2  Apache Commons Logging	143
4.1.3  Apache Log4j	147
4.1.4  Slf4j	156
4.1.5  Logback	160
4.1.6  Apache Log4j 2	164
4.2  日志系统的优化和最佳实践	168
4.2.1  开发人员的日志意识	168
4.2.2  日志级别的设置	168
4.2.3  日志的数量和大小	169
4.2.4  切割方式	170
4.2.5  日志格式的配置	170
4.2.6  一行日志导致的线上事故	177
4.3  大数据日志系统的原理与设计	178
4.3.1  通用架构和设计	179
4.3.2  日志采集器	180
4.3.3  日志缓冲队列	186
4.3.4  日志解析器	187
4.3.5  日志存储和搜索	187
4.3.6  日志展示系统	188
4.3.7  监控和报警	188
4.3.8  日志系统的容量和性能评估	188
4.4  ELK系统的构建与使用	190
4.4.1  Elasticsearch	191
4.4.2  Logstash	193
4.4.3  Kibana	196
4.5  本章小结	198
第5章  基于调用链的服务治理系统的设计与实现	199
5.1  APM系统简介	200
5.1.1  优秀的开源APM系统	200
5.1.2  国内商业APM产品的介绍	202
5.2  调用链跟踪的原理	203
5.2.1  分布式系统的远程调用过程	204
5.2.2  TraceID	207
5.2.3  SpanID	208
5.2.4  业务链	210
5.3  调用链跟踪系统的设计与实现	211
5.3.1  整体架构	211
5.3.2  TraceID和SpanID在服务间的传递	213
5.3.3  采集器的设计与实现	217
5.3.4  处理器的设计与实现	222
5.3.5  调用链系统的展示	225
5.4  本章小结	226
第6章  Java服务的线上应急和技术攻关	227
6.1  海恩法则和墨菲定律	227
6.2  线上应急的目标、原则和方法	229
6.2.1  应急目标	229
6.2.2  应急原则	229
6.2.3  线上应急的方法和流程	230
6.3  技术攻关的方法论	233
6.4  环境搭建和示例服务启动	236
6.5  高效的服务化治理脚本	240
6.5.1  show-busiest-java-threads	240
6.5.2  find-in-jar	243
6.5.3  grep-in-jar	244
6.5.4  jar-conflict-detect	245
6.5.5  http-spy	247
6.5.6  show-mysql-qps	248
6.5.7  小结	249
6.6  JVM提供的监控命令	249
6.6.1  jad	249
6.6.2  btrace	250
6.6.3  jmap	252
6.6.4  jstat	255
6.6.5  jstack	256
6.6.6  jinfo	258
6.6.7  其他命令	258
6.6.8  小结	259
6.7  重要的Linux基础命令	260
6.7.1  必不可少的基础命令和工具	260
6.7.2  查看活动进程的命令	268
6.7.3  窥探内存的命令	270
6.7.4  针对CPU使用情况的监控命令	272
6.7.5  监控磁盘I/O的命令	273
6.7.6  查看网络信息和网络监控命令	275
6.7.7  Linux系统的高级工具	287
6.7.8  /proc文件系统	288
6.7.9  摘要命令	288
6.7.10  小结	290
6.8  现实中的应急和攻关案例	291
6.8.1  一次OOM事故的分析和定位	291
6.8.2  一次CPU 100%的线上事故排查	301
6.9  本章小结	304
第7章  服务的容器化过程	306
7.1  容器vs虚拟机	306
7.1.1  什么是虚拟机	306
7.1.2  什么是容器	306
7.1.3  容器和虚拟机的区别	307
7.1.4  容器主要解决的问题	307
7.1.5  Docker的优势	310
7.2  Docker实战	311
7.2.1  Docker的架构	311
7.2.2  Docker的安装	315
7.2.3  Docker初体验	319
7.2.4  Docker后台服务的管理	322
7.2.5  Docker的客户端命令	328
7.2.6  Docker Compose编排工具的使用	372
7.3  容器化项目	379
7.3.1  传统的应用部署	380
7.3.2  将应用程序部署在虚拟机上	380
7.3.3  容器化部署应用	381
7.3.4  Docker实现的应用容器化示例	382
7.4  本章小结	384
第8章  敏捷开发2.0的自动化工具	385
8.1  什么是敏捷开发2.0	385
8.1.1  常用的4种开发模式	385
8.1.2  什么是DevOps	390
8.1.3  敏捷开发2.0解决的问题	392
8.2  敏捷开发的自动化流程	393
8.2.1  持续集成	393
8.2.2  持续交付和持续部署	397
8.3  敏捷开发的常用自动化工具	400
8.3.1  分布式版本控制工具Git	400
8.3.2  持续集成和持续交付工具Jenkins	410
8.3.3  基础平台管理工具SaltStack	418
8.3.4  Docker容器化工具	421
8.4  本章小结	422
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式服务架构：原理、设计与实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向模式的软件架构 卷4：分布式计算的模式语言
第一部分　概念
第1章　模式与模式语言 2
1.1　模式 2
1.2　模式内幕 3
1.2.1　问题的环境 3
1.2.2　驱动因素：所有模式的核心 4
1.2.3　解决方案与结果 4
1.2.4　模式命名 4
1.2.5　模式表现形式概述 5
1.3　模式的关系 5
1.3.1　模式的互补 5
1.3.2　模式的组合 6
1.3.3　模式故事 6
1.3.4　模式序列 7
1.4　模式语言 7
1.4.1　从模式序列到模式语言 7
1.4.2　展现和使用模式语言 7
1.5　模式的连接 8
第2章　分布式系统 9
2.1　分布式的优点 9
2.2　分布式的挑战 11
2.3　用以支持分布式的技术 12
2.3.1　分布式对象计算中间件 13
2.3.2　组件中间件 14
2.3.3　发布/订阅中间件和面向消息的中间件 15
2.3.4　面向服务架构和Web服务 16
2.4　中间件技术的局限性 17
第3章　模式语言 18
3.1　意图、范畴和对象 18
3.2　起源 18
3.3　结构和内容 19
3.4　模式的表现 24
3.5　实际应用 26
第二部分　模式故事
第4章　仓库管理流程控制 33
4.1　系统范畴 33
4.2　仓库管理流程控制 34
第5章　基线架构 37
5.1　架构环境 37
5.2　划分大泥球 38
5.3　层次分解 38
5.4　访问领域对象功能 40
5.5　网络桥接 41
5.6　分离用户界面 43
5.7　功能分布 45
5.8　支持并发的领域对象访问 47
5.9　获得可扩展的并发性 48
5.10　将面向对象与关系型数据库连接起来 49
5.11　领域对象的运行时配置 50
5.12　基线架构总结 51
第6章　通信中间件 54
6.1　分布式系统的中间件架构 54
6.2　对中间件的内部设计进行结构化 57
6.3　封装底层系统机制 58
6.4　分离ORB核心事件 59
6.5　ORB连接管理 61
6.6　提高ORB的可伸缩性 63
6.7　实现同步请求队列 65
6.8　可互换的内部ORB机制 66
6.9　管理ORB策略 68
6.10　ORB动态配置 69
6.11　通信中间件总结 71
第7章　仓库拓扑 74
7.1　仓库拓扑基线 74
7.2　表现层次化的存储结构 74
7.3　存储结构导航 77
7.4　存储属性建模 78
7.5　不同的存储单元行为 79
7.6　实现全局功能 81
7.7　遍历仓库拓扑 81
7.8　支持控制流扩展 83
7.9　连接数据库 84
7.10　维护内存中的存储单元数据 85
7.11　配置仓库拓扑 86
7.12　细述显式接口 88
7.13　仓库拓扑总结 89
第8章　模式故事背后的故事 91
第三部分　模式语言
第9章　从混沌到结构 97
9.1　Domain Model** 106
9.2　Layers** 108
9.3　Model-View-Controller** 109
9.4　Presentation-Abstraction-Control 111
9.5　Microkernel** 113
9.6　Reflection* 114
9.7　Pipes and Filters** 116
9.8　Shared Repository** 117
9.9　Blackboard 119
9.10　Domain Object** 121
第10章　分布式基础设施 123
10.1　Messaging** 129
10.2　Message Channel** 130
10.3　Message Endpoint** 132
10.4　Message Translator** 133
10.5　Message Router** 134
10.6　Publisher-Subscriber** 135
10.7　Broker** 137
10.8　Client Proxy** 139
10.9　Requestor** 140
10.10　Invoker** 142
10.11　Client Request Handler** 143
10.12　Server Request Handler** 144
第11章　事件分离和分发 147
11.1　Reactor** 150
11.2　Proactor* 152
11.3　Acceptor-Connector** 154
11.4　Asynchronous Completion Token** 155
第12章　接口划分 157
12.1　Explicit Interface** 163
12.2　Extension Interface** 165
12.3　Introspective Interface** 166
12.4　Dynamic Invocation Interface* 167
12.5　Proxy** 169
12.6　Business Delegate** 170
12.7　Facade** 171
12.8　Combined Method** 172
12.9　Iterator** 173
12.10　Enumeration Methond** 174
12.11　Batch Method** 175
第13章　组件划分 177
13.1　Encapsulated Implementation** 181
13.2　Whole-Part** 183
13.3　Composite** 185
13.4　Master-Slave** 186
13.5　Half-Object plus Protocol** 188
13.6　Replicated Component Group** 189
第14章　应用控制 191
14.1　Page Controller** 196
14.2　Front Controller** 197
14.3　Application Controller** 198
14.4　Command Processor** 199
14.5　Template View** 200
14.6　Transform View** 201
14.7　Firewall Proxy** 202
14.8　Authorization** 204
第15章　并发 206
15.1　Half-Sync/Half-Async** 209
15.2　Leader/Followers** 211
15.3　Active Object** 212
15.4　Monitor Object** 214
第16章　同步 216
16.1　Guarded Suspension** 221
16.2　Future** 223
16.3　Thread-Safe Interface* 224
16.4　Double-Checked Locking 225
16.5　Strategized Locking** 226
16.6　Scoped Locking** 227
16.7　Thread-Specific Storage 228
16.8　Copied Value** 230
16.9　Immutable Value** 231
第17章　对象间的交互 233
17.1　Observer** 237
17.2　Double Dispatch ** 238
17.3　Mediator* 239
17.4　Command** 240
17.5　Memento** 242
17.6　Context Object** 243
17.7　Data Transfer Object** 244
17.8　Message** 245
第18章　适配与扩展 247
18.1　Bridge** 255
18.2　Object Adapter** 256
18.3　Chain of Responsibility* 257
18.4　Interpreter 258
18.5　Interceptor** 260
18.6　Visitor** 261
18.7　Decorator 262
18.8　Execute-Around Object** 264
18.9　Template Method* 265
18.10　Strategy** 266
18.11　Null Object** 267
18.12　Wrapper Facade** 269
18.13　Declarative Component Configuration* 270
第19章　模态行为 272
19.1　Objects for States* 274
19.2　Methods for States* 275
19.3　Collections for States* 276
第20章　资源管理 278
20.1　Container* 288
20.2　Component Configurator* 289
20.3　Object Manager** 291
20.4　Lookup** 292
20.5　Virtual Proxy** 294
20.6　Lifecycle Callback** 295
20.7　Task Coordinator* 296
20.8　Resource Pool** 298
20.9　Resource Cache** 299
20.10　Lazy Acquisition** 300
20.11　Eager Acquisition** 301
20.12　Partial Acquisition* 303
20.13　Activator** 304
20.14　Evictor** 305
20.15　Leasing** 306
20.16　Automated Garbage Collection** 307
20.17　Counting Handles** 309
20.18　Abstract Factory** 311
20.19　Builder* 312
20.20　Factory Method** 313
20.21　Disposal Method** 314
第21章　数据库访问 316
21.1　Database Access Layer** 318
21.2　Data Mapper** 320
21.3　Row Data Gateway** 321
21.4　Table Data Gateway ** 323
21.5　Active Record 324
第22章　最后的思考 326
术语表 327
参考书目 340
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向模式的软件架构 卷4：分布式计算的模式语言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型分布式网站架构设计与实践
第1章　面向服务的体系架构（SOA）	1
本章主要介绍和解决以下问题，这些也是全书的基础：
HTTP协议的工作方式与HTTP网络协议栈的结构。
如何实现基于HTTP协议和TCP协议的RPC调用，它们之间有何差别，分别适应何种场景。
如何实现服务的动态注册和路由，以及软负载均衡的实现。
1.1　基于TCP协议的RPC	3
1.1.1　RPC名词解释	3
1.1.2　对象的序列化	4
1.1.3　基于TCP协议实现RPC	6
1.2　基于HTTP协议的RPC	9
1.2.1　HTTP协议栈	9
1.2.2　HTTP请求与响应	15
1.2.3　通过HttpClient发送HTTP请求	16
1.2.4　使用HTTP协议的优势	17
1.2.5　JSON和XML	18
1.2.6　RESTful和RPC	20
1.2.7　基于HTTP协议的RPC的实现	22
1.3　服务的路由和负载均衡	30
1.3.1　服务化的演变	30
1.3.2  负载均衡算法	33
1.3.3  动态配置规则	39
1.3.4  ZooKeeper介绍与环境搭建	40
1.3.5  ZooKeeper API使用简介	43
1.3.6  zkClient的使用	47
1.3.7  路由和负载均衡的实现	50
1.4  HTTP服务网关	54
第2章　分布式系统基础设施	58
本章主要介绍和解决如下问题：
分布式缓存memcache的使用及分布式策略，包括Hash算法的选择。
常见的分布式系统存储解决方案，包括MySQL的分布式扩展、HBase的API及使用场景、Redis的使用等。
如何使用分布式消息系统ActiveMQ来降低系统之间的耦合度，以及进行应用间的通信。
垂直化的搜索引擎在分布式系统中的使用，包括搜索引擎的基本原理、Lucene详细的使用介绍，以及基于Lucene的开源搜索引擎工具Solr的使用。
2.1  分布式缓存	60
2.1.1  memcache简介及安装	60
2.1.2  memcache API与分布式	64
2.1.3  分布式session	69
2.2  持久化存储	71
2.2.1  MySQL扩展	72
2.2.2  HBase	80
2.2.3  Redis	91
2.3  消息系统	95
2.3.1  ActiveMQ & JMS	96
2.4  垂直化搜索引擎	104
2.4.1  Lucene简介	105
2.4.2  Lucene的使用	108
2.4.3  Solr	119
2.5  其他基础设施	125
第3章　互联网安全架构	126
本章主要介绍和解决如下问题：
常见的Web攻击手段和防御方法，如XSS、CRSF、SQL注入等。
常见的一些安全算法，如数字摘要、对称加密、非对称加密、数字签名、数字证书等。
如何采用摘要认证方式防止信息篡改、通过数字签名验证通信双方的合法性，以及通过HTTPS协议保障通信过程中数据不被第三方监听和截获。
在开放平台体系下，OAuth协议如何保障ISV对数据的访问是经过授权的合法行为。
3.1  常见的Web攻击手段	128
3.1.1  XSS攻击	128
3.1.2  CRSF攻击	130
3.1.3  SQL注入攻击	133
3.1.4  文件上传漏洞	139
3.1.5  DDoS攻击	146
3.1.6  其他攻击手段	149
3.2  常用的安全算法	149
3.2.1  数字摘要	149
3.2.2  对称加密算法	155
3.2.3  非对称加密算法	158
3.2.4  数字签名	162
3.2.5  数字证书	166
3.3  摘要认证	185
3.3.1  为什么需要认证	185
3.3.2  摘要认证的原理	187
3.3.3  摘要认证的实现	188
3.4  签名认证	192
3.4.1  签名认证的原理	192
3.4.2  签名认证的实现	193
3.5  HTTPS协议	200
3.5.1  HTTPS协议原理	200
3.5.2  SSL/TLS	201
3.5.3  部署HTTPS Web	208
3.6  OAuth协议	215
3.6.1  OAuth的介绍	215
3.6.2  OAuth授权过程	216
第4章　系统稳定性	218
本章主要介绍和解决如下问题：
常用的在线日志分析命令的使用和日志分析脚本的编写，如cat、grep、wc、less等命令的使用，以及awk、shell脚本的编写。
如何进行集群的监控，包括监控指标的定义、心跳检测、容量评估等。
如何保障高并发系统的稳定运行，如采用流量控制、依赖管理、服务分级、开关等策略，以及介绍如何设计高并发系统。
如何优化应用的性能，包括前端优化、Java程序优化、数据库查询优化等。
如何进行Java应用故障的在线排查，包括一系列排查工具的使用，以及一些实际案例的介绍等。
4.1  在线日志分析	220
4.1.1  日志分析常用命令	220
4.1.2  日志分析脚本	230
4.2  集群监控	239
4.2.1  监控指标	239
4.2.2  心跳检测	247
4.2.3  容量评估及应用水位	252
4.3  流量控制	255
4.3.1  流量控制实施	255
4.3.2  服务稳定性	260
4.3.3  高并发系统设计	265
4.4  性能优化	277
4.4.1  如何寻找性能瓶颈	277
4.4.2  性能测试工具	285
4.4.3  性能优化措施	292
4.5  Java应用故障的排查	314
4.5.1  常用的工具	314
4.5.2  典型案例分析	331
第5章　数据分析	337
本章主要介绍和解决如下问题：
分布式系统中日志收集系统的架构。
如何通过Storm进行实时的流式数据分析。
如何通过Hadoop进行离线数据分析，通过Hive建立数据仓库。
如何将关系型数据库中存储的数据导入HDFS，以及从HDFS中将数据导入关系型数据库。
如何将分析好的数据通过图形展示给用户。
5.1  日志收集	339
5.1.1  inotify机制	339
5.1.2  ActiveMQ-CPP	343
5.1.3  架构和存储	359
5.1.4  Chukwa	362
5.2  离线数据分析	369
5.2.1  Hadoop项目简介	370
5.2.2  Hadoop环境搭建	374
5.2.3  MapReduce编写	384
5.2.4  Hive使用	389
5.3  流式数据分析	403
5.3.1  Storm的介绍	404
5.3.2  安装部署Storm	407
5.3.3  Storm的使用	418
5.4  数据同步	422
5.4.1  离线数据同步	423
5.4.2  实时数据同步	429
5.5  数据报表	431
5.5.1  数据报表能提供什么	431
5.5.2  报表工具Highcharts	432
参考文献	445
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型分布式网站架构设计与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入分布式缓存：从原理到实践
赞誉
推荐序1
推荐序2
推荐序3
作者寄语
前言
第1章　缓存为王1
1.1　什么是缓存？1
1.2　为什么使用缓存？2
1.2.1　从用户体验说起3
1.2.2　关于系统的性能3
1.3　从网站的架构发展看缓存4
1.4　客户端缓存5
1.4.1　页面缓存6
1.4.2　浏览器缓存7
1.4.3　APP上的缓存8
1.5　网络中的缓存11
1.5.1　Web代理缓存11
1.5.2　边缘缓存12
1.6　服务端缓存14
1.6.1　数据库缓存14
1.6.2　平台级缓存16
1.6.3　应用级缓存18
第2章　分布式系统理论24
2.1　分布式系统概论24
2.2　分布式系统概念26
2.2.1　进程与线程26
2.2.2　并发26
2.2.3　锁26
2.2.4　并行27
2.2.5　集群27
2.2.6　状态特性28
2.2.7　系统重发与幂等性28
2.2.8　硬件异常30
2.3　分布式系统理论31
2.3.1　CAP理论32
2.3.2　CAP理论澄清34
2.3.3　Paxos35
2.3.4　2PC38
2.3.5　3PC39
2.3.6　Raft40
2.3.7　Lease机制41
2.3.8　解决“脑裂”问题43
2.3.9　Quorum NWR44
2.3.10　MVCC45
2.3.11　Gossip46
2.4　分布式系统设计策略49
2.4.1　心跳检测50
2.4.2　高可用设计50
2.4.3　容错性52
2.4.4　负载均衡53
2.5　分布式系统设计实践54
2.5.1　全局ID生成54
2.5.2　哈希取模56
2.5.3　一致性哈希57
2.5.4　路由表58
2.5.5　数据拆分58
第3章　动手写缓存60
3.1　缓存定义的规范60
3.1.1　新规范的主要内容及特性60
3.1.2　新规范的API介绍61
3.2　缓存框架的实现62
3.2.1　前期准备63
3.2.2　缓存的架构介绍63
3.2.3　设计思路以及知识点详解64
3.3　缓存框架的使用示例74
第4章 　Ehcache与Guava Cache76
4.1　Ehcache的主要特性76
4.2　Ehcache使用介绍77
4.2.1　Ehcache架构图77
4.2.2　缓存数据过期策略78
4.2.3　Ehcache缓存的基本用法81
4.2.4　在Spring中使用Ehcache83
4.3　Ehcache集群介绍85
4.3.1　集群的方式86
4.3.2　如何配置集群88
4.4　 Ehcache的适用场景89
4.5　Guava Cache的使用92
4.5.1　Guava Cache的适用场景92
4.5.2　Guava Cache的创建方式93
4.5.3　缓存数据删除95
4.5.4　并发场景下的使用95
4.6　本章小结96
第5章　从Memcached开始了解集中式缓存97
5.1　Memcached基本知识98
5.1.1　Memcached的操作命令98
5.1.2　Memcached使用场景100
5.1.3　Memcached特征100
5.1.4　Memcached的一些问题101
5.2　Memcached内存存储102
5.2.1　Slab Allocation机制102
5.2.2　使用 Growth Factor进行调优104
5.2.3　Item105
5.3　典型问题解析106
5.3.1　过期机制106
5.3.2　哈希算法107
5.3.3　热点问题108
5.3.4　缓存与数据库的更新问题108
5.3.5　别把缓存当存储109
5.3.6　命名空间110
5.3.7　CAS110
5.4　Memcached客户端分析110
5.4.1　Memcached的Client111
5.4.2　Spymemcached设计思想解析111
5.5　Memcached周边工具发展117
第6章　Memcached 周边技术119
6.1　Twemcache119
6.1.1　Twemcache 的设计原理120
6.1.2　Twemcache的安装及命令行详解122
6.1.3　基于Java的Twemcache用法125
6.2　Twemproxy126
6.2.1　Twemproxy的常用部署模式127
6.2.2　Twemproxy的可扩展性129
6.2.3　Twemproxy源代码简析131
6.3　Mcrouter137
6.3.1　Mcrouter路由算法138
6.3.2　典型的使用场景139
6.3.3　Mcrouter的可扩展性142
6.3.4　源码简要解析144
第7章　Redis探秘148
7.1　数据结构148
7.1.1　value对象的通用结构149
7.1.2　String149
7.1.3　List152
7.1.4　Map155
7.1.5　Set157
7.1.6　Sorted-Set159
7.2　客户端与服务器的交互160
7.2.1　客户端/服务器协议161
7.2.2　请求/响应模式163
7.2.3　事务模式164
7.2.4　脚本模式168
7.2.5　发布/订阅模式169
7.3　单机处理逻辑171
7.3.1　多路复用171
7.3.2　定时任务处理173
7.4　持久化174
7.4.1　基于全量模式的持久化174
7.4.2　基于增量模式的持久化176
7.4.3　基于增量模式持久化的优化178
第8章　分布式Redis180
8.1　水平拆分（sharding）181
8.1.1　数据分布181
8.1.2　请求路由182
8.2　主备复制（replication）182
8.2.1　主备复制流程183
8.2.2　断点续传183
8.3　故障转移（failover）184
8.3.1　sentinel间的相互感知185
8.3.2　master的故障发现186
8.3.3　failover决策186
8.4　Redis Cluster187
8.4.1　拓扑结构187
8.4.2　配置的一致性188
8.4.3　sharding190
8.4.4　failover193
8.4.5　可用性和性能196
第9章　Tair探秘198
9.1　Tair总体架构198
9.2　Config Server简介199
9.3　Data Server简介201
9.4　Tair高可用和负载均衡204
9.4.1　对照表204
9.4.2　数据迁移219
9.5　存储引擎220
9.6　Tair的API222
9.6.1　key/value相关API223
9.6.2　prefix相关的API226
第10章　EVCache探秘229
10.1　EVCache项目介绍230
10.1.1　EVCache的由来231
10.1.2　EVCache的发展232
10.1.3　EVCache的演进234
10.2　EVCache 的使用场景238
10.2.1　典型用例238
10.2.2　典型部署239
10.3　EVCache的性能240
10.3.1　EVCache集群的性能240
10.3.2　全局化复制时的性能问题242
10.3.3　Moneta项目中的组件性能243
10.4　EVCache 的高可用性244
10.4.1　AWS的多可用区244
10.4.2　EVCache对AWS高可用性的增强245
10.5　源码与示例245
10.5.1　源码浅析245
10.5.2　EVCache 示例253
第11章　Aerospike原理及广告业务应用259
11.1　Aerospike架构259
11.2　Aerospike具体实现261
11.2.1　Aerospike集群管理261
11.2.2　数据分布263
11.3　Aerospike集群配置和部署265
11.3.1　搭建集群的方式与配置266
11.3.2　部署集群267
11.4　Aerospike与Redis的对比271
11.5　Aeropsike在广告行业的具体应用272
11.5.1　Aerospike在个性化推荐广告中的应用273
11.5.2　Aerospike在实时竞价广告中的应用274
第12章　社交场景架构进化：从数据库到缓存283
12.1　社交业务示例283
12.1.1　业务模型283
12.1.2　业务场景284
12.1.3　业务特点285
12.2　关系（relation）的存储286
12.2.1　基于DB的最简方案286
12.2.2　DB的sharding方案288
12.2.3　引入缓存290
12.2.4　缓存的优化方案292
12.3　帖子（post）的存储293
12.3.1　基于DB的方案294
12.3.2　引入服务端缓存296
12.3.3　本地缓存297
12.4　时间线（timeline）的存储297
12.4.1　基于DB的方案—push模式298
12.4.2　基于DB的方案—pull模式300
12.4.3　增量查询引入服务端缓存302
第13章　缓存在社交网络Feed系统中的架构实践304
13.1　Feed系统架构304
13.2　Feed缓存模型307
13.3　Feed缓存架构的设计309
13.3.1　简单数据类型的缓存设计310
13.3.2　集合类数据的缓存设计312
13.3.3　其他类型数据的缓存设计314
13.4　Feed缓存的扩展 315
13.4.1　Redis的扩展315
13.4.2　计数器的扩展316
13.4.3　存在性判断的扩展318
13.5　Feed缓存的服务化319
第14章　典型电商应用与缓存324
14.1　电商类应用的挑战及特点324
14.2　应用数据静态化架构高性能单页Web应用325
14.2.1　整体架构326
14.2.2　CMS系统326
14.2.3　前端展示系统328
14.2.4　控制系统328
14.3　应用多级缓存模式支撑海量读服务329
14.3.1　多级缓存介绍329
14.3.2　如何缓存数据331
14.3.3　分布式缓存与应用负载均衡332
14.3.4　热点数据与更新缓存334
14.3.5　更新缓存与原子性336
14.3.6　缓存崩溃与快速修复336
14.4　构建需求响应式亿级商品详情页337
14.4.1　商品详情页前端结构338
14.4.2　单品页技术架构发展338
14.4.3　详情页架构设计原则343
14.4.4　遇到的一些问题349
第15章　同程凤凰缓存系统基于Redis的设计与实践357
15.1　同程凤凰缓存系统要解决什么问题357
15.1.1　Redis用法的凌乱358
15.1.2　从实际案例再看Redis的使用360
15.1.3　如何改变Redis用不好的误区362
15.1.4　凤凰缓存系统对Redis系统化改造364
15.2　用好Redis先运维好它366
15.2.1　传统的Redis运维方式366
15.2.2　Redis的Docker化部署368
15.2.3　凤凰缓存系统对Redis的监控369
15.2.4　凤凰缓存系统对Redis的集群分片优化370
15.2.5　客户端在运维中的作用371
15.2.6　凤凰缓存系统在Redis运维上的工具372
15.3　凤凰缓存系统的使用效果373
第16章　新的旅程374
16.1　更好的引入缓存技术374
16.1.1　缓存引入前的考量374
16.1.2　缓存组件的选择375
16.1.3　缓存架构的设计376
16.1.4　缓存系统的监控及演进377
16.2　缓存分类总结377
16.3　缓存知识结构更多Tips378
16.3.1　缓存使用模式379
16.3.2　缓存协议379
16.3.3　缓存连接池380
16.3.4　几个关注点383
16.3.5　管理缓存387
16.3.6　缓存可用性390
16.3.7　数据一致性392
16.3.8　热点数据处理393
16.3.9　注意事项Tips396
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入分布式缓存：从原理到实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算与分布式系统
出版者的话
中文版序
序
前言
第一部分系统建模、集群化和虚拟化
第1章分布式系统模型和关键技术
1.1互联网之上的可扩展计算
1.1.1互联网计算的时代
1.1.2可扩展性计算趋势和新的范式
1.1.3物联网和CPS
1.2基于网络的系统技术
1.2.1多核CPU和多线程技术
1.2.2大规模和超大规模GPU计算
1.2.3内存、外部存储和广域网
1.2.4虚拟机和虚拟化中间件
1.2.5云计算的数据中心虚拟化
1.3分布式和云计算系统模型
1.3.1协同计算机集群
1.3.2网格计算的基础设施
1.3.3对等网络家族
1.3.4互联网上的云计算
1.4分布式系统和云计算软件环境
1.4.1面向服务的体系结构（SOA）
1.4.2分布式操作系统趋势
1.4.3并行和分布式编程模型
1.5性能、安全和节能
1.5.1性能度量和可扩展性分析
1.5.2容错和系统可用性
1.5.3网络威胁与数据完整性
1.5.4分布式计算中的节能
1.6参考文献和习题
第2章可扩展并行计算集群
2.1大规模并行集群
2.1.1集群发展趋势
2.1.2计算机集群的设计宗旨
2.1.3基础集群设计问题
2.1.4Top500超级计算机分析
2.2计算机集群和MPP体系结构
2.2.1集群组织和资源共享
2.2.2节点结构和MPP封装
2.2.3集群系统互连
2.2.4硬件、软件和中间件支持
2.2.5大规模并行GPU集群
2.3计算机集群的设计原则
2.3.1单系统镜像特征
2.3.2冗余高可用性
2.3.3容错集群配置
2.3.4检查点和恢复技术
2.4集群作业和资源管理
2.4.1集群作业调度方法
2.4.2集群作业管理系统
2.4.3集群计算的负载共享设备(LSF)
2.4.4MOSIX: Linux集群和云的操作系统
2.5顶尖超级计算机系统的个案研究
2.5.1Tianhe1A：2010年的世界最快超级计算机
2.5.2Gray XT5 Jaguar：2009年的领先超级计算机
2.5.3IBM Roadrunner：2008年的领先超级计算机
2.6参考文献和习题
第3章虚拟机和集群与数据中心虚拟化
3.1虚拟化的实现层次
3.1.1虚拟化实现的层次
3.1.2VMM的设计需求和提供商
3.1.3操作系统级的虚拟化支持
3.1.4虚拟化的中间件支持
3.2虚拟化的结构/工具与机制
3.2.1hypervisor与Xen体系结构
3.2.2全虚拟化的二进制翻译
3.2.3编译器支持的半虚拟化技术
3.3CPU、内存和I/O设备的虚拟化
3.3.1虚拟化的硬件支持
3.3.2CPU虚拟化
3.3.3内存虚拟化
3.3.4I/O虚拟化
3.3.5多核处理器的虚拟化
3.4虚拟集群和资源管理
3.4.1物理集群与虚拟集群
3.4.2在线迁移虚拟机的步骤与性能影响
3.4.3内存、文件与网络资源的迁移
3.4.4虚拟集群的动态部署
3.5数据中心的自动化与虚拟化
3.5.1数据中心服务器合并
3.5.2虚拟存储管理
3.5.3虚拟化数据中心的云操作系统
3.5.4虚拟化数据中心的可信管理
3.6参考文献与习题
第二部分云平台、面向服务的体系结构和云编程
第4章构建在虚拟化数据中心上的云平台体系结构
4.1云计算和服务模型
4.1.1公有云、私有云和混合云
4.1.2云生态系统和关键技术
4.1.3基础设施即服务(IaaS)
4.1.4平台即服务 (PaaS) 和软件即服务(SaaS)
4.2数据中心设计与互连网络
4.2.1仓库规模的数据中心设计
4.2.2数据中心互连网络
4.2.3运送集装器的模块化数据中心
4.2.4模块化数据中心的互连
4.2.5数据中心管理问题
4.3计算与存储云的体系结构设计
4.3.1通用的云体系结构设计
4.3.2层次化的云体系结构开发
4.3.3虚拟化支持和灾难恢复
4.3.4体系结构设计挑战
4.4公有云平台：GAE、AWS和Azure
4.4.1公有云及其服务选项
4.4.2谷歌应用引擎（GAE）
4.4.3亚马逊的Web服务（AWS）
4.4.4微软的Windows Azure
4.5云间的资源管理
4.5.1扩展的云计算服务
4.5.2资源配置和平台部署
4.5.3虚拟机创建和管理
4.5.4云资源的全球交易
4.6云安全与信任管理
4.6.1云安全的防御策略
4.6.2分布式入侵/异常检测
4.6.3数据和软件保护技术
4.6.4数据中心的信誉指导保护
4.7参考文献与习题
第5章面向服务的分布式体系结构
5.1服务和面向服务的体系结构
5.1.1REST和系统的系统
5.1.2服务和Web服务
5.1.3企业多层体系结构
5.1.4网格服务和OGSA
5.1.5其他的面向服务的体系结构和系统
5.2面向消息的中间件
5.2.1企业总线
5.2.2发布-订阅模型和通知
5.2.3队列和消息传递系统
5.2.4云或网格中间件应用
5.3门户和科学网关
5.3.1科学网关样例
5.3.2科学协作的HUBzero平台
5.3.3开放网关计算环境（OGCE）
5.4发现、注册表、元数据和数据库
5.4.1UDDI和服务注册表
5.4.2数据库和订阅-发布
5.4.3元数据目录
5.4.4语义Web和网格
5.4.5作业执行环境和监控
5.5面向服务的体系结构中的工作流
5.5.1工作流的基本概念
5.5.2工作流标准
5.5.3工作流体系结构和规范
5.5.4工作流运行引擎
5.5.5脚本工作流系统Swift
5.6参考文献与习题
第6章云编程和软件环境
6.1云和网格平台的特性
6.1.1云的功能和平台的特性
6.1.2网格和云的公共传统特性
6.1.3数据特性和数据库
6.1.4编程和运行时支持
6.2并行和分布式编程范式
6.2.1并行计算和编程范式
6.2.2MapReduce、Twister和迭代MapReduce
6.2.3来自Apache的Hadoop软件库
6.2.4微软的Dryad和DryadLINQ
6.2.5Sawzall和Pig Latin高级语言
6.2.6并行和分布式系统的映射应用
6.3GAE的编程支持
6.3.1GAE编程
6.3.2谷歌文件系统（GFS）
6.3.3BigTable——谷歌的NOSQL系统
6.3.4Chubby——谷歌的分布式锁服务
6.4亚马逊AWS与微软Azure中的编程
6.4.1亚马逊EC2上的编程
6.4.2亚马逊简单存储服务（S3）
6.4.3亚马逊弹性数据块存储服务（EBS）和SimpleDB
6.4.4微软Azure编程支持
6.5新兴云软件环境
6.5.1开源的Eucalyptus和Nimbus
6.5.2OpenNebula、Sector/Sphere和Open Stack
6.5.3Manjrasoft Aneka云和工具机
6.6参考文献与习题
第三部分网格、P2P和未来互联网
第7章网格计算系统和资源管理
7.1网格体系结构和服务建模
7.1.1网格历史与服务类别
7.1.2CPU清除和虚拟超级计算机
7.1.3开放网格服务体系结构（OGSA）
7.1.4数据密集型网格服务模型
7.2网格项目和网格系统创建
7.2.1国家网格和国际项目
7.2.2美国的NSF TeraGrid
7.2.3欧盟的DataGrid
7.2.4ChinaGrid设计经验
7.3网格资源管理和资源中介
7.3.1资源管理和作业调度
7.3.2CGSP的网格资源监控
7.3.3服务记账和经济模型
7.3.4Gridbus的资源中介
7.4网格计算的软件与中间件
7.4.1开源网格中间件包
7.4.2Globus Tookit体系结构（GT4）
7.4.3集装器和资源/数据管理
7.4.4ChinaGrid支持平台（CGSP）
7.5网格应用趋势和安全措施
7.5.1网格应用技术融合
7.5.2网格负载与性能预测
7.5.3网格安全执行的信任模型
7.5.4认证与授权方法
7.5.5网格安全基础设施（GSI）
7.6参考文献与习题
第8章对等计算和覆盖网络
8.1P2P计算系统
8.1.1P2P计算系统的基本概念
8.1.2P2P计算面临的基础挑战
8.1.3P2P网络系统分类
8.2P2P覆盖网络及其性质
8.2.1无结构P2P覆盖网络
8.2.2分布式哈希表（DHT）
8.2.3结构化P2P覆盖网络
8.2.4混合式覆盖网络
8.3路由、邻近性和容错
8.3.1P2P覆盖网络的路由
8.3.2P2P覆盖网络中的网络邻近性
8.3.3容错和失效恢复
8.3.4抗扰动与失效
8.4信任、信誉和安全管理
8.4.1节点信任和信誉系统
8.4.2信任覆盖网络和DHT实现
8.4.3PowerTrust：可扩展的信誉系统
8.4.4加强覆盖网络安全，抵御DDoS攻击
8.5P2P文件共享和版权保护
8.5.1快速搜索、副本和一致性
8.5.2P2P内容分发网络
8.5.3版权保护问题和解决方案
8.5.4P2P网络中的共谋盗版预防
8.6参考文献与习题
第9章普适云计算、物联网与社会网络
9.1支持普适计算的云趋势
9.1.1云计算在HPC/HTC和普适计算中的应用
9.1.2NASA和CERN的大规模私有云
9.1.3灵活和可扩展的云混搭系统
9.1.4移动云计算平台Cloudlet
9.2分布式系统和云的性能
9.2.1科研云综述
9.2.2数据密集型扩展计算（DISC）
9.2.3HPC/HTC系统的性能指标
9.2.4云计算的服务质量
9.2.5MPI、Azure、EC2、MapReduce、Hadoop的基准测试
9.3物联网关键技术
9.3.1实现普适计算的物联网
9.3.2射频标识（RFID）
9.3.3传感器网络和ZigBee技术
9.3.4全球定位系统（GPS）
9.4物联网创新应用
9.4.1物联网应用
9.4.2零售和供应链管理
9.4.3智能电网和智能建筑
9.4.4信息物理系统（CPS）
9.5在线社会网络和专业网络
9.5.1在线社会网络特征
9.5.2基于图论的社会网络分析
9.5.3社会网络社区和应用
9.5.4Facebook：世界上最大的社会网络
9.5.5Twitter：微博、新闻和提醒服务平台
9.6参考文献与习题
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算与分布式系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式系统常用技术及案例分析
第1章　分布式系统基础知识	1
1.1　概述	2
1.1.1　什么是分布式系统	2
1.1.2　集中式系统VS.分布式系统	3
1.1.3　如何设计分布式系统	4
1.1.4　分布式系统所面临的挑战	5
1.2　线程	6
1.2.1　什么是线程	6
1.2.2　进程和线程	7
1.2.3　编程语言中的线程对象	8
1.2.4　SimpleThreads示例	11
1.3　通信	14
1.3.1　网络基础知识	14
1.3.2　网络I/O模型的演进	19
1.3.3　远程过程调用（RPC）	33
1.3.4　面向消息的通信	41
1.4 一致性	43
1.4.1　以数据为中心的一致性模型	44
1.4.2　以客户为中心的一致性	45
1.5　容错性	46
1.5.1　基本概念	46
1.5.2　故障分类	47
1.5.3　使用冗余来掩盖故障	48
1.5.4　分布式提交	48
1.6　CAP理论	52
1.6.1　什么是CAP理论	52
1.6.2　为什么说CAP只能三选二	53
1.6.3　CAP常见模型	55
1.6.4　CAP的意义	56
1.6.5　CAP最新发展	56
1.7　安全性	57
1.7.1　基本概念	58
1.7.2　加密算法	60
1.7.3　安全通道	63
1.7.4　访问控制	72
1.8　并发	74
1.8.1　线程与并发	75
1.8.2　并发与并行	75
1.8.3　并发带来的风险	76
1.8.4　同步（Synchronization）	78
1.8.5  原子访问（Atomic Access）	83
第2章　分布式系统架构体系	85
2.1　基于对象的体系结构	86
2.1.1　分布式对象	86
2.1.2　微软DCOM（COM+）	87
2.1.3　CORBA	88
2.1.4　Java RMI	90
2.2　面向服务的架构（SOA）	93
2.2.1　架构VS.标准	94
2.2.2　SOA的基本概念	95
2.2.3　基于Web Services的SOA	97
2.2.4　SOA的演变	112
2.3　REST风格的架构	112
2.3.1　什么是REST	112
2.3.2　REST有哪些特征	113
2.3.3　Java实现REST的例子	115
2.3.4　REST API最佳实践	125
2.4　微服务架构（MSA）	128
2.4.1　什么是MSA	128
2.4.2　MSA VS. SOA	130
2.4.3　何时采用MSA	134
2.4.4　如何构建微服务	135
2.5　容器技术	139
2.5.1　虚拟化技术	139
2.5.2　容器VS.虚拟机	139
2.5.3　基于容器的持续部署	142
2.6　Serverless架构	149
2.6.1　什么是Serverless架构	150
2.6.2　Serverless典型的应用场景	151
2.6.3　常见的Serverless框架	153
2.6.4　Serverless架构原则	155
2.6.5　例子：使用Serverless实现游戏全球同服	157
第3章　分布式消息服务	164
3.1　Apache ActiveMQ	165
3.1.1　Apache ActiveMQ简介	165
3.1.2　Apache ActiveMQ安装配置	166
3.1.3  例子：producer-consumer	173
3.1.4  例子：使用JMX来监控ActiveMQ	174
3.1.5  例子：使用Java实现producer-consumer	176
3.2  RabbitMQ	180
3.2.1  RabbitMQ简介	180
3.2.2  RabbitMQ安装配置	181
3.2.3　例子：Work Queues	185
3.2.4　例子：Publish/Subscribe	191
3.2.5　例子：Routing	195
3.2.6　例子：Topics	200
3.2.7  例子：RPC	204
3.3  RocketMQ	210
3.3.1  RocketMQ简介	210
3.3.2  RocketMQ安装配置	213
3.3.3  例子：使用Java实现producer-consumer	214
3.3.4  RocketMQ最佳实践	219
3.4  Apache Kafka	223
3.4.1  Apache Kafka简介	224
3.4.2  Apache Kafka的核心概念	225
3.4.3  Apache Kafka的使用场景	228
3.4.4  Apache Kafka的安装、配置、使用	229
第4章　分布式计算	236
4.1　MapReduce	237
4.1.1　MapReduce简介	237
4.1.2  MapReduce的编程模型	238
4.1.3  MapReduce的实现	243
4.1.4　MapReduce的使用技巧	248
4.2  Apache Hadoop	251
4.2.1  Apache Hadoop简介	252
4.2.2  Apache Hadoop核心组件	253
4.2.3  Apache Hadoop单节点上的安装配置	254
4.2.4  Apache Hadoop集群上的安装配置	258
4.2.5  例子：词频统计WordCount程序	267
4.3  Apache Spark	272
4.3.1  Apache Spark简介	272
4.3.2  Apache Spark与Apache Hadoop的关系	274
4.3.3  Apache Spark 2.0的新特性	275
4.3.4　Apache Spark的安装和使用	279
4.3.5　Apache Spark集群模式	280
4.4  Apache Mesos	282
4.4.1  Apache Mesos简介	283
4.4.2　Apache Mesos的安装、使用	285
4.4.3  设计高可用的Mesos framework	289
第5章　分布式存储	296
5.1　Bigtable	297
5.1.1　Bigtable简介	297
5.1.2　Bigtable的数据模型	298
5.1.3　Bigtable的实现	300
5.1.4　Bigtable的性能优化	304
5.2　Apache HBase	308
5.2.1　Apache HBase简介	308
5.2.2　Apache HBase基本概念	310
5.2.3　Apache HBase架构	318
5.2.4　Apache HBase的安装、配置、使用	332
5.2.5　本地伪分布式	336
5.2.6　完全分布式	338
5.3　Apache Cassandra	342
5.3.1　Apache Cassandra简介	342
5.3.2　Apache Cassandra的应用场景	345
5.3.3　Apache Cassandra的架构、数据模型	346
5.3.4　用于配置Apache Cassandra的核心组件	347
5.3.5　Apache Cassandra的安装、配置、使用	349
5.4　Memcached	352
5.4.1　Memcached简介	352
5.4.2　Memcached的架构	353
5.4.3　Memcached的安装、使用	355
5.4.4　Memcached客户端	358
5.5　Redis	370
5.5.1　Redis简介	370
5.5.2　Redis的下载、安装、使用	372
5.5.3　Redis的数据类型及抽象	372
5.6　MongoDB	392
5.6.1　MongoDB简介	392
5.6.2　MongoDB的安装、配置、运行	394
5.6.3　MongoDB核心概念	401
5.6.4　MongoDB的数据模型	406
5.6.5　示例：Java连接MongoDB	420
第6章　分布式监控	422
6.1　Nagios	423
6.1.1　Nagios简介	423
6.1.2　Nagios的安装、使用	424
6.1.3　Nagios监控	428
6.1.4　Nagios插件	446
6.2　Zabbix	448
6.2.1　Zabbix简介	449
6.2.2　安装Zabbix	451
6.2.3　Zabbix对于容器的支持	460
6.2.4　Zabbix基本概念	463
6.3　Consul	474
6.3.1　Consul简介	475
6.3.2　Consul架构	476
6.3.3　Consul的安装和使用	478
6.3.4　Consul agent	492
6.4　ZooKeeper	501
6.4.1　ZooKeeper简介	501
6.4.2　ZooKeeper的安装和使用	505
6.4.3　ZooKeeper内部工作原理	509
6.4.4　例子：ZooKeeper实现barrier和producer-consumer queue	514
第7章　分布式版本控制系统	522
7.1　Bazaar	523
7.1.1　Bazaar简介	523
7.1.2　Bazaar的核心概念	525
7.1.3　Bazaar的安装	526
7.1.4　Bazaar的使用	528
7.2　Mercurial	533
7.2.1　Mercurial简介	533
7.2.2　Mercurial的核心概念	533
7.2.3　Mercurial的安装	537
7.2.4　Mercurial的使用	538
7.3　Git	545
7.3.1　Git简介	545
7.3.2　Git的安装	546
7.3.3　Git的基础概念	548
7.3.4　Git的使用	551
第8章　RESTful API、微服务及容器技术	578
8.1　Jersey	579
8.1.1　Jersey简介	579
8.1.2　Jersey的模块和依赖	580
8.1.3　JAX-RS核心概念	583
8.1.4　例子：用SSE构建实时Web应用	595
8.2　Spring Boot	603
8.2.1　Spring Boot简介	603
8.2.2　Spring Boot的安装	604
8.2.3　Spring Boot的使用	610
8.2.4　Spring Boot的属性与配置	615
8.3　Docker	620
8.3.1　Docker简介	621
8.3.2　Docker的特性	621
8.3.3　Docker的概念和原理	622
8.3.4　Docker Engine的安装	628
8.3.5　Docker的使用	633
第9章　淘宝网：“双11”神话的缔造者	636
9.1　从LAMP到Java平台的转变	637
9.1.1　淘宝网的诞生与发展	637
9.1.2　“平民英雄”LAMP架构	638
9.1.3　数据库更改为Oracle	639
9.1.4　向Java平台转变	642
9.2　坚定不移地走“去IOE”的道路	643
9.2.1　使用小型机、EMC存储	644
9.2.2　考虑“去IOE”	644
9.2.3　如何去“I”	646
9.2.4　如何去“O”	649
9.2.5　如何去“E”	650
9.3　打造云计算，决战“双11”	653
9.3.1　“大淘宝”战略简介	653
9.3.2　成立阿里云，专注云计算	656
9.3.3　利用大数据优化物流	660
9.3.4　技术是决胜“双11”的关键	661
第10章　Twitter：实时信息传递的王者	664
10.1　缓存，让响应更快	665
10.1.1　Twitter的诞生	665
10.1.2　RoR的蛮荒时代	666
10.1.3　使用Memcached	667
10.2　服务拆分与治理	668
10.2.1　关系数据库不是万灵药	668
10.2.2　系统拆分，平台转换	670
10.2.3　Finagle	670
10.3　抗击流量的洪流	672
10.3.1　业务的重新设计	673
10.3.2　Storm处理实时的大数据	675
10.3.3　从Storm到Heron	676
参考文献	680
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式系统常用技术及案例分析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式服务框架：原理与实践
第1章　应用架构演进 1
1.1 传统垂直应用架构 2
1.1.1 垂直应用架构介绍 2
1.1.2 垂直应用架构面临的挑战 4
1.2 RPC架构 6
1.2.1　RPC框架原理 6
1.2.2　最简单的RPC框架实现 8
1.2.3　业界主流RPC框架 14
1.2.4　RPC框架面临的挑战 17
1.3 SOA服务化架构 18
1.3.1　面向服务设计的原则 18
1.3.2　服务治理 19
1.4 微服务架构 21
1.4.1　什么是微服务 21
1.4.2　微服务架构对比SOA 22
1.5　总结 23
第2章　分布式服务框架入门 25
2.1　分布式服务框架诞生背景 26
2.1.1 应用从集中式走向分布式 26
2.1.2 亟需服务治理 28
2.2 业界分布式服务框架介绍 29
2.2.1　阿里Dubbo 30
2.2.2　淘宝HSF 33
2.2.3　亚马逊Coral Service 35
2.3 分布式服务框架设计 36
2.3.1　架构原理 36
2.3.2　功能特性 37
2.3.3　性能特性 39
2.3.4　可靠性 39
2.3.5　服务治理 40
2.4 总结 41
第3章　通信框架 42
3.1　关键技术点分析 43
3.1.1 长连接还是短连接 43
3.1.2 BIO还是NIO 43
3.1.3 自研还是选择开源NIO框架 46
3.2 功能设计 47
3.2.1　服务端设计 48
3.2.2　客户端设计 50
3.3 可靠性设计 53
3.3.1　链路有效性检测 54
3.3.2　断连重连机制 56
3.3.3　消息缓存重发 57
3.3.4　资源优雅释放 58
3.4 性能设计 59
3.4.1　性能差的三宗罪 59
3.4.2　通信性能三原则 60
3.4.3　高性能之道 61
3.5 最佳实践 61
3.6 总结 64
第4章　序列化与反序列化 65
4.1　几个关键概念澄清 66
4.1.1 序列化与通信框架的关系 66
4.1.2 序列化与通信协议的关系 66
4.1.3 是否需要支持多种序列化方式 67
4.2 功能设计 67
4.2.1　功能丰富度 67
4.2.2　跨语言支持 68
4.2.3　兼容性 69
4.2.4　性能 70
4.3 扩展性设计 71
4.3.1　内置的序列化/反序列化功能类 71
4.3.2　反序列化扩展 72
4.3.3　序列化扩展 75
4.4 最佳实践 77
4.4.1　接口的前向兼容性规范 77
4.4.2　高并发下的稳定性 78
4.5 总结 78
第5章　协议栈 79
5.1　关键技术点分析 80
5.1.1 是否必须支持多协议 80
5.1.2 公有协议还是私有协议 80
5.1.3 集成开源还是自研 81
5.2 功能设计 82
5.2.1　功能描述 82
5.2.2　通信模型 82
5.2.3　协议消息定义 84
5.2.4　协议栈消息序列化支持的字段类型 85
5.2.5　协议消息的序列化和反序列化 86
5.2.6　链路创建 89
5.2.7　链路关闭 90
5.3 可靠性设计 90
5.3.1　客户端连接超时 90
5.3.2　客户端重连机制 91
5.3.3　客户端重复握手保护 91
5.3.4　消息缓存重发 92
5.3.5　心跳机制 92
5.4 安全性设计 92
5.5 最佳实践—协议的前向兼容性 94
5.6 总结 95
第6章　服务路由 96
6.1　透明化路由 97
6.1.1 基于服务注册中心的订阅发布 97
6.1.2 消费者缓存服务提供者地址 98
6.2 负载均衡 98
6.2.1　随机 98
6.2.2　轮循 99
6.2.3　服务调用时延 99
6.2.4　一致性哈希 100
6.2.5　粘滞连接 101
6.3 本地路由优先策略 102
6.3.1　injvm模式 102
6.3.2　innative模式 102
6.4 路由规则 103
6.4.1　条件路由规则 103
6.4.2　脚本路由规则 104
6.5　路由策略定制 105
6.6　配置化路由 106
6.7　最佳实践—多机房路由 107
6.8 总结 108
第７章　集群容错 109
7.1　集群容错场景 110
7.1.1 通信链路故障 110
7.1.2 服务端超时 111
7.1.3 服务端调用失败 111
7.2 容错策略 112
7.2.1　失败自动切换（Failover） 112
7.2.2　失败通知（Failback） 113
7.2.3　失败缓存（Failcache） 113
7.2.4　快速失败（Failfast） 114
7.2.5　容错策略扩展 114
7.3 总结 115
第8章　服务调用 116
8.1　几个误区 117
8.1.1 NIO就是异步服务 117
8.1.2 服务调用天生就是同步的 118
8.1.3 异步服务调用性能更高 120
8.2 服务调用方式 120
8.2.1　同步服务调用 120
8.2.2　异步服务调用 121
8.2.3　并行服务调用 125
8.2.4　泛化调用 129
8.3 最佳实践 130
8.4 总结 131
第９章　服务注册中心 132
9.1　几个概念 133
9.1.1 服务提供者 133
9.1.2 服务消费者 133
9.1.3 服务注册中心 133
9.2 关键功能特性设计 134
9.2.1　支持对等集群 135
9.2.2　提供CRUD接口 136
9.2.3　安全加固 136
9.2.4　订阅发布机制 137
9.2.5　可靠性 138
9.3　基于ZooKeeper的服务注册中心设计 139
9.3.1　服务订阅发布流程设计 139
9.3.2　服务健康状态检测 141
9.3.3　对等集群防止单点故障 142
9.3.4　变更通知机制 144
9.4 总结 144
第10章　服务发布和引用 145
10.1　服务发布设计 146
10.1.1　服务发布的几种方式 146
10.1.2　本地实现类封装成代理 148
10.1.3　服务发布成指定协议 148
10.1.4　服务提供者信息注册 149
10.2 服务引用设计 150
10.2.1　本地接口调用转换成远程服务调用 150
10.2.2　服务地址本地缓存 151
10.2.3　远程服务调用 151
10.3　最佳实践 152
10.3.1　对等设计原则 152
10.3.2　启动顺序问题 153
10.3.3　同步还是异步发布服务 153
10.3.4　警惕网络风暴 154
10.3.5　配置扩展 154
10.4 总结 156
第11章　服务灰度发布 157
11.1　服务灰度发布流程设计 158
11.1.1　灰度环境准备 158
11.1.2　灰度规则设置 159
11.1.3　灰度规则下发 160
11.1.4　灰度路由 161
11.1.5　失败回滚 162
11.1.6　灰度发布总结 163
11.2　总结 163
第12章　参数传递 164
12.1　内部传参 165
12.1.1　业务内部参数传递 165
12.1.2　服务框架内部参数传递 168
12.2　外部传参 169
12.2.1　通信协议支持 169
12.2.2　传参接口定义 170
12.3　最佳实践 171
12.3.1　防止参数互相覆盖 171
12.3.2　参数生命周期管理 171
12.4　总结 172
第13章　服务多版本 173
13.1　服务多版本管理设计 174
13.1.1　服务版本号管理 174
13.1.2　服务提供者 175
13.1.3　服务消费者 175
13.1.4　基于版本号的服务路由 176
13.1.5　服务热升级 177
13.2　与OSGi的对比 178
13.2.1　模块化开发 179
13.2.2　插件热部署和热升级 184
13.2.3　不使用OSGi的其他理由 185
13.3　总结 185
第14章　流量控制 186
14.1　静态流控 187
14.1.1　传统静态流控设计方案 187
14.1.2　传统方案的缺点 188
14.1.3　动态配额分配制 188
14.1.4　动态配额申请制 190
14.2　动态流控 191
14.2.1　动态流控因子 192
14.2.2　分级流控 192
14.3　并发控制 193
14.3.1　服务端全局控制 193
14.3.2　服务消费者流控 194
14.4　连接控制 195
14.4.1　服务端连接数流控 195
14.4.2　服务消费者连接数流控 195
14.5　并发和连接控制算法 195
14.6　总结 197
第15章　服务降级 198
15.1　屏蔽降级 199
15.1.1　屏蔽降级的流程 199
15.1.2　屏蔽降级的设计实现 200
15.2　容错降级 202
15.2.1　容错降级的工作原理 202
15.2.2　运行时容错降级 204
15.3　业务层降级 205
15.4　总结 205
第16章　服务优先级调度 207
16.1　设置服务优先级 208
16.2　线程调度器方案 209
16.3　Java优先级队列 210
16.4　加权优先级队列 211
16.5　服务迁入迁出 212
16.6　总结 213
第17章　服务治理 214
17.1　服务治理技术的历史变迁 215
17.1.1　SOA Governance 215
17.1.2　分布式服务框架服务治理 217
17.1.3　AWS云端微服务治理 217
17.2　应用服务化后面临的挑战 218
17.2.1　跨团队协作问题 219
17.2.2　服务的上下线管控 220
17.2.3　服务安全 220
17.2.4　服务SLA保障 221
17.2.5　故障快速定界定位 221
17.3　服务治理 222
17.3.1　服务治理架构设计 223
17.3.2　运行态服务治理功能设计 225
17.3.3　线下服务治理 232
17.3.4　安全和权限管理 234
17.4　总结 237
第18章　分布式消息跟踪 239
18.1　业务场景分析 240
18.1.1　故障的快速定界定位 240
18.1.2　调用路径分析 241
18.1.3　调用来源和去向分析 242
18.2　分布式消息跟踪系统设计 242
18.2.1　系统架构 243
18.2.2　埋点日志 244
18.2.3　采样率 247
18.2.4　采集和存储埋点日志 248
18.2.5　计算和展示 249
18.2.6　调用链扩展 251
18.3　总结 251
第19章　可靠性设计 253
19.1　服务状态检测 254
19.1.1　基于服务注册中心状态检测 254
19.1.2　链路有效性状态检测机制 255
19.2　服务健康度检测 256
19.3　服务故障隔离 257
19.3.1　进程级故障隔离 257
19.3.2　VM级故障隔离 259
19.3.3　物理机故障隔离 260
19.3.4　机房故障隔离 261
19.4　其他可靠性特性 262
19.4.1　服务注册中心 262
19.4.2　监控中心 262
19.4.3　服务提供者 262
19.5　总结 263
第20章　微服务架构 264
20.1　微服务架构产生的历史背景 265
20.1.1　研发成本挑战 265
20.1.2　运维成本高 267
20.1.3　新需求上线周期长 268
20.2　微服务架构带来的改变 268
20.2.1　应用解耦 268
20.2.2　分而治之 270
20.2.3　敏捷交付 271
20.3　微服务架构解析 271
20.3.1　微服务划分原则 272
20.3.2　开发微服务 272
20.3.3　基于Docker容器部署微服务 274
20.3.4　治理和运维微服务 277
20.3.5　特点总结 278
20.4　总结 279
第21章　服务化最佳实践 280
21.1　性能和时延问题 281
21.1.1　RPC框架高性能设计 281
21.1.2　业务最佳实践 285
21.2　事务一致性问题 286
21.2.1　分布式事务设计方案 287
21.2.2　分布式事务优化 288
21.3　研发团队协作问题 289
21.3.1　共用服务注册中心 290
21.3.2　直连提供者 290
21.3.3　多团队进度协同 291
21.3.4　服务降级和Mock测试 291
21.3.5　协同调试问题 292
21.3.6　接口前向兼容性 292
21.4　总结 292
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式服务框架：原理与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SOA实践指南
前言
第1章：动机
1.1 大型分布式系统的特征
1.2 魔术总线故事
1.3 魔术总线故事给我们的启示
1.4 SOA历史
1.5 五页幻灯讲完SOA
第2章：SOA
2.1 SOA定义
2.2 SOA驱动因素
2.3 SOA概念
2.4 SOA要素
2.5 SOA不是银弹
2.6 SOA不是特定技术
2.7 对比SOA与分布式对象
2.8 SOA术语
2.9 总结
第3章：服务
3.1 服务
3.2 接口和契约
3.3 额外的服务特性
3.4 总结
第4章：松耦合
4.1 对容错的需求
4.2 松耦合的形式
4.3 处理松耦合
4.4 总结
第5章：企业服务总线
5.1 ESB职责
5.2 异质的ESB
5.3 ESB的差异
5.4 ESB增值服务
5.5 总结
第6章：服务分类
6.1 基础服务分类
6.2 基本服务
6.3 组合服务
6.4 流程服务
6.5 其他服务分类法
6.6 技术服务和基础设施服务
6.7 服务之外
6.8 总结
第7章：业务流程管理
7.1 BPM术语
7.2 BPM和SOA
7.3 用于服务的BPM的例子
7.4 业务流程建模
7.5 识别服务的其他方法
7.6 配制和编排
7.7 更多思考
7.8 总结
第8章：SOA和组织
8.1 角色和组织
8.2 出资模型
8.3 总结
第9章：上下文环境中的SOA
9.1 基于SOA的架构模型
9.2 处理前端和后端
9.3 总结
第10章：消息交换模式
10.1 MEP简介
10.2 基本MEP
10.3 更复杂的MEP
10.4 处理可靠性和错误
10.5 处理不同MEP层
10.6 事件驱动的架构
10.7 总结
第11章：服务生命周期
11.1 开发中的服务
11.2 生产中的服务
11.3 总结
第12章：版本划分
12.1 版本划分需求
12.2 领域驱动的版本划分
12.3 数据类型的版本划分
12.4 配置管理驱动的版本划分
12.5 实践中的版本划分
12.6 总结
第13章：SOA和性能
13.1 性能在哪儿重要
13.2 从远程存储过程到服务
13.3 性能和可重用性
13.4 性能和向后兼容性
13.5 总结
第14章：SOA和安全
14.1 安全需求
14.2 处理安全需求
14.3 实践中的SOA安全.
14.4 XML和Web Services的安全
14.5 安全问题何时凸现
14.6 总结
第15章：技术细节
15.1 服务和状态
15.2 幂等性
15.3 测试和调试
15.4 处理技术性数据（头数据）
15.5 数据类型
15.6 错误处理
15.7 总结
第16章：Web Services
16.1 使用Web Services的动机
16.2 基础Web Services标准
16.3 实践中的Web Services
16.4 结束按语
16.5 总结
第17章：服务管理
17.1 服务中间人的历史
17.2 业务库和注册中心
17.3 总结
第18章：模型驱动的服务开发
18.1 生成的服务代码
18.2 建模服务
18.3 实践中的元模型
18.4 建立MDSD过程
18.5 工具
18.6 避免瓶颈
18.7 总结
第19章：建立SOA和SOA监管
19.1 引入SOA
19.2 SOA监管
19.3 按部就班SOA
19.4 其他SOA方法
19.5 其他建议
19.6 总结
第20章：后记
20.1 SOA是新东西吗？
20.2 SOA增加了复杂性吗？
20.3 SOA关键的成功要素是什么？
20.4 SOA在哪些地方不合适？
20.5 SOA替代了OOP吗？
参考文献
词汇表
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SOA实践指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式系统概念与设计
第1章 分布式系统的特征 1
1.1 简介 1
1.2 分布式系统的实例 2
1.2.1 因特网 2
1.2.2 企业内部网 3
1.2.3 移动计算和无处不在计算 3
1.3 资源共享和Web 5
1.4 挑战 10
1.4.1 异构性 11
1.4.2 开放性 11
1.4.3 安全性 12
1.4.4 可伸缩性 13
1.4.5 故障处理 14
1.4.6 并发性 15
1.4.7 透明性 15
1.5 小结 16
练习 17
第2章 系统模型 19
2.1 简介 19
2.2 体系结构模型 20
2.2.1 软件层 20
2.2.2 系统体系结构 22
2.2.3 变体 23
2.2.4 接口和对象 27
2.2.5 分布式体系结构的设计需求 27
2.3 基础模型 30
2.3.1 交互模型 31
2.3.2 故障模型 34
2.3.3 安全模型 36
2.4 小结 39
练习 40
第3章 网络和网际互连 42
3.1 简介 42
3.2 网络类型 44
3.3 网络原理 46
3.3.1 数据包的传输 47
3.3.2 数据流 47
3.3.3 交换模式 47
3.3.4 协议 48
3.3.5 路由 52
3.3.6 拥塞控制 54
3.3.7 网际互连 55
3.4 因特网协议 57
3.4.1 IP寻址 59
3.4.2 IP协议 60
3.4.3 IP路由 62
3.4.4 IPv6 65
3.4.5 移动IP 67
3.4.6 TCP和UDP 68
3.4.7 域名 69
3.4.8 防火墙 70
3.5 实例研究：以太网、WiFi、蓝牙和ATM 72
3.5.1 以太网 73
3.5.2 IEEE 802.11无线LAN 76
3.5.3 IEEE 802.15.1蓝牙无线PAN 78
3.5.4 异步传输模式网络 80
3.6 小结 82
练习 82
第4章 进程间通信 84
4.1 简介 84
4.2 因特网协议的API 85
4.2.1 进程间通信的特征 85
4.2.2 套接字 86
4.2.3 UDP数据报通信 87
4.2.4 TCP流通信 90
4.3 外部数据表示和编码 93
4.3.1 CORBA的公共数据表示 94
4.3.2 Java对象序列化 95
4.3.3 可扩展标记语言 97
4.3.4 远程对象引用 99
4.4 客户－服务器通信 100
4.5 组通信 105
4.5.1 IP组播—组通信的实现 106
4.5.2 组播的可靠性和排序 108
4.6 实例研究：UNIX中的进程间通信 108
4.6.1 数据报通信 109
4.6.2 流通信 110
4.7 小结 110
练习 111
第5章 分布式对象和远程调用 114
5.1 简介 114
5.2 分布式对象间的通信 116
5.2.1 对象模型 117
5.2.2 分布式对象 117
5.2.3 分布式对象模型 118
5.2.4 RMI的设计问题 120
5.2.5 RMI的实现 122
5.2.6 分布式无用单元收集 125
5.3 远程过程调用 126
5.4 事件和通知 129
5.4.1 分布式事件通知的参与者 131
5.4.2 实例研究：Jini分布式事件规约 132
5.5 实例研究：Java RMI 133
5.5.1 创建客户和服务器程序 136
5.5.2 Java RMI的设计和实现 138
5.6 小结 139
练习 139
第6章 操作系统支持 142
6.1 简介 142
6.2 操作系统层 143
6.3 保护 144
6.4 进程和线程 145
6.4.1 地址空间 146
6.4.2 新进程的生成 147
6.4.3 线程 149
6.5 通信和调用 157
6.5.1 调用性能 158
6.5.2 异步操作 162
6.6 操作系统的体系结构 164
6.7 小结 167
练习 167
第7章 安全性 169
7.1 简介 169
7.1.1 威胁和攻击 170
7.1.2 保护电子事务 172
7.1.3 设计安全系统 173
7.2 安全技术概述 174
7.2.1 密码学 175
7.2.2 密码学的应用 175
7.2.3 证书 177
7.2.4 访问控制 178
7.2.5 凭证 180
7.2.6 防火墙 181
7.3 密码算法 181
7.3.1 密钥（对称）算法 184
7.3.2 公钥（不对称）算法 186
7.3.3 混合密码协议 188
7.4 数字签名 188
7.4.1 公钥数字签名 189
7.4.2 密钥数字签名—MAC 189
7.4.3 安全摘要函数 190
7.4.4 证书标准和证书权威机构 191
7.5 密码实用学 192
7.5.1 密码算法的性能 192
7.5.2 密码学的应用和政治障碍 193
7.6 案例研究：Needham-Schroeder、Kerberos、TLS和802.11 WiFi 194
7.6.1 Needham-Schroeder认证协议 194
7.6.2 Kerberos 195
7.6.3 使用安全套接字确保电子交易安全 199
7.6.4 IEEE 802.11 WiFi 安全设计中的缺陷 201
7.7 小结 203
练习 204
第8章 分布式文件系统 205
8.1 简介 205
8.1.1 文件系统的特点 207
8.1.2 分布式文件系统的需求 208
8.1.3 实例研究 209
8.2 文件服务体系结构 210
8.3 实例研究：SUN网络文件系统 214
8.4 实例研究：Andrew文件系统 222
8.4.1 实现 223
8.4.2 缓存的一致性 225
8.4.3 其他方面 227
8.5 最新进展 228
8.6 小结 232
练习 232
第9章 名字服务 234
9.1 简介 234
9.2 名字服务和域名系统 236
9.2.1 名字空间 237
9.2.2 名字解析 239
9.2.3 域名系统 241
9.3 目录服务 246
9.4 实例研究：全局名字服务 246
9.5 实例研究：X.500目录服务 248
9.6 小结 251
练习 252
第10章 对等系统 253
10.1 简介 253
10.2 Napster及其遗留系统 256
10.3 对等中间件 257
10.4 路由覆盖 259
10.5 路由覆盖实例研究：Pastry和Tapestry 261
10.5.1 Pastry 261
10.5.2 Tapestry 266
10.6 应用实例研究：Squirrel、OceanStore和Ivy 267
10.6.1 Squirrel Web缓存 267
10.6.2 OceanStore文件存储 269
10.6.3 Ivy文件系统 272
10.7 小结 274
练习 275
第11章 时间和全局状态 277
11.1 简介 277
11.2 时钟、事件和进程状态 278
11.3 同步物理时钟 279
11.3.1 同步系统中的同步 280
11.3.2 同步时钟的Cristian方法 281
11.3.3 Berkeley算法 281
11.3.4 网络时间协议 282
11.4 逻辑时间和逻辑时钟 284
11.5 全局状态 286
11.5.1 全局状态和一致割集 287
11.5.2 全局状态谓词、稳定性、安全性和活性 288
11.5.3 Chandy和Lamport的“快照”算法 289
11.6 分布式调试 291
11.6.1 观察一致的全局状态 293
11.6.2 判定可能的f 294
11.6.3 判定明确的f 294
11.6.4 在同步系统中判定可能的f和明确的f 295
11.7 小结 296
练习 296
第12章 协调和协定 298
12.1 简介 298
12.2 分布式互斥 300
12.3 选举 305
12.4 组播通信 308
12.4.1 基本组播 309
12.4.2 可靠组播 310
12.4.3 有序组播 312
12.5 共识和相关问题 317
12.5.1 系统模型和问题定义 317
12.5.2 同步系统中的共识问题 320
12.5.3 同步系统中的拜占庭将军问题 320
12.5.4 异步系统的不可能性 323
12.6 小结 324
练习 325
第13章 事务和并发控制 327
13.1 简介 327
13.1.1 简单的同步机制（无事务） 328
13.1.2 事务的故障模型 329
13.2 事务 329
13.2.1 并发控制 332
13.2.2 事务放弃时的恢复 334
13.3 嵌套事务 336
13.4 锁 337
13.4.1 死锁 342
13.4.2 在加锁机制中增加并发度 345
13.5 乐观并发控制 346
13.6 时间戳排序 349
13.7 并发控制方法的比较 353
13.8 小结 354
练习 355
第14章 分布式事务 359
14.1 简介 359
14.2 平面分布式事务和嵌套分布式事务 359
14.3 原子提交协议 361
14.3.1 两阶段提交协议 362
14.3.2 嵌套事务的两阶段提交协议 364
14.4 分布式事务的并发控制 367
14.4.1 加锁 367
14.4.2 时间戳并发控制 368
14.4.3 乐观并发控制 368
14.5 分布式死锁 369
14.6 事务恢复 374
14.6.1 日志 375
14.6.2 影子版本 377
14.6.3 为何恢复文件需要事务状态和意图列表 378
14.6.4 两阶段提交协议的恢复 378
14.7 小结 380
练习 381
第15章 复制 383
15.1 简介 383
15.2 系统模型和组通信 385
15.2.1 系统模型 385
15.2.2 组通信 386
15.3 容错服务 390
15.3.1 被动（主备份）复制 392
15.3.2 主动复制 393
15.4 高可用服务的实例研究：gossip体系结构、Bayou和Coda 394
15.4.1 gossip体系结构 395
15.4.2 Bayou系统和操作变换方法 401
15.4.3 Coda文件系统 402
15.5 复制数据上的事务 407
15.5.1 复制事务的体系结构 407
15.5.2 可用拷贝复制 409
15.5.3 网络分区 410
15.5.4 带验证的可用拷贝 411
15.5.5 法定数共识方法 411
15.5.6 虚拟分区算法 413
15.6 小结 415
练习 415
第16章 移动计算和无处不在计算 417
16.1 简介 417
16.2 关联 423
16.2.1 发现服务 424
16.2.2 物理关联 427
16.2.3 小结和前景 428
16.3 互操作 428
16.3.1 易变系统的面向数据编程 429
16.3.2 间接关联和软状态 432
16.3.3 小结和前景 433
16.4 感知和上下文敏感 433
16.4.1 传感器 434
16.4.2 感知体系结构 434
16.4.3 位置感知 438
16.4.4 小结和前景 441
16.5 安全和私密性 442
16.5.1 背景 442
16.5.2 一些解决办法 443
16.5.3 小结和前景 447
16.6 自适应 447
16.6.1 内容的上下文敏感自适应 448
16.6.2 适应变化的系统资源 449
16.6.3 小结和前景 450
16.7 Cooltown实例研究 450
16.7.1 Web存在 451
16.7.2 物理超链接 452
16.7.3 互操作和eSquirt协议 454
16.7.4 小结和前景 455
16.8 小结 455
练习 456
第17章 分布式多媒体系统 458
17.1 简介 458
17.2 多媒体数据的特征 461
17.3 服务质量管理 462
17.3.1 服务质量协商 464
17.3.2 许可控制 467
17.4 资源管理 468
17.5 流适应 469
17.5.1 调整 470
17.5.2 过滤 471
17.6 实例研究：Tiger视频文件服务器 471
17.7 小结 474
练习 474
第18章 分布式共享内存 476
18.1 简介 476
18.1.1 消息传递机制和DSM 477
18.1.2 DSM的实现方法 478
18.2 设计和实现问题 479
18.2.1 结构 479
18.2.2 同步模型 480
18.2.3 一致性模型 481
18.2.4 更新选项 483
18.2.5 粒度 485
18.2.6 系统颠簸 485
18.3 顺序一致性和lvy实例研究 485
18.3.1 系统模型 486
18.3.2 写失效 487
18.3.3 失效协议 488
18.3.4 一个动态分布式管理器算法 489
18.3.5 系统颠簸 490
18.4 释放一致性和Munin实例研究 491
18.4.1 内存访问 491
18.4.2 释放一致性 492
18.4.3 Munin 493
18.5 其他一致性模型 494
18.6 小结 495
练习 496
第19章 Web服务 498
19.1 简介 498
19.2 Web服务 499
19.2.1 SOAP 501
19.2.2 Web服务与分布式对象模型的比较 504
19.2.3 在Java中使用SOAP 505
19.2.4 Web服务和CORBA的比较 508
19.3 服务描述和Web服务接口定义语言 509
19.4 Web服务使用的目录服务 512
19.5 XML安全性 513
19.6 Web服务的协作 516
19.7 实例研究：网格 517
19.7.1 World-Wide Telescope—一种网格应用 518
19.7.2 数据密集型科学应用的特征 518
19.7.3 开放的网格服务体系结构 519
19.7.4 一些网格应用的例子 521
19.7.5 Globus工具包 522
19.8 小结 523
练习 524
第20章 CORBA实例研究 526
20.1 简介 526
20.2 CORBA RMI 527
20.2.1 CORBA客户和服务器实例 529
20.2.2 CORBA体系结构 532
20.2.3 CORBA接口定义语言 534
20.2.4 CORBA远程对象引用 537
20.2.5 CORBA语言映射 538
20.2.6 CORBA与Web的集成 538
20.3 CORBA服务 539
20.3.1 CORBA名字服务 540
20.3.2 CORBA事件服务 542
20.3.3 CORBA通知服务 543
20.3.4 CORBA安全服务 544
20.4 小结 544
练习 545
索引 548
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式系统概念与设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构修炼之道——亿级网关、平台开放、分布式、微服务、容错等核心技术修炼实践
第1章  网关之道
1.1  认识API网关
1.1.1  API网关是什么
1.1.2  API网关涵盖的基本功能
1.1.3  API网关架构示例
1.2  一个API的生命周期
1.2.1  什么是API
1.2.2  生命周期
1.2.3  生命周期的过程
1.3  API网关的基石—泛化调用
1.4  如何发布API到网关系统
1.5  管道技术
1.5.1  管道实现
1.5.2  如何获取管道
1.5.3  管道信息传递
1.5.4  管道的优点
1.5.5  责任链模式
1.6  一个传统网关系统有几种“死”法
1.6.1  关注CPU
1.6.2  关注磁盘
1.6.3  关注网络
1.7  Servlet 3异步原理与实践
1.7.1  什么是Servlet
1.7.2  什么是Servlet规范
1.7.3  同步、异步、阻塞、非阻塞
1.7.4  Servlet 3的异步流程
1.7.5  Servlet 3的异步使用步骤
1.7.6  Servlet 3的异步使用示例
1.7.7  Tomcat NIO Connector、Servlet 3.0 Async和Spring MVC Async的关系
1.7.8  Servlet 3非阻塞I/O
1.8  全异步网关
1.9  脱库与多级缓存
1.9.1  脱库
1.9.2  多级缓存
1.10  热更新
1.11  网关系统的七种武器
1.12  本章小结
第2章  开放之道
2.1  认识OAuth 2.0
2.1.1  什么是OAuth 2.0
2.1.2  角色
2.1.3  OAuth 2.0协议流程
2.1.4  采用OAuth 2.0协议的开放平台
2.1.5  京东宙斯开放（授权码方式场景）
2.2  开放平台
2.2.1  一名开发者的基本需求
2.2.2  完整性
2.2.3  稳定性
2.2.4  安全性
2.2.5  整体技术架构
2.2.6  意义
2.3  如何设计一套SPI应用架构
2.3.1  API和SPI区别
2.3.2  术语约定
2.3.3  业务场景
2.3.4  架构实现
2.3.5  测试
2.3.6  SPI是一种思想
2.4  讲一讲越权
2.4.1  什么是越权访问
2.4.2  越权访问的种类
2.4.3  发生越权访问的根本原因
2.4.4  如何避免与解决
2.4.5  开放平台环境下的越权访问
2.5  从Facebook数据泄漏谈开放安全
2.5.1  OAuth 2.0授权
2.5.2  数据加/解密
2.5.3  IP地址白名单
2.5.4  平台内环境
2.6  API治理
2.6.1  性能
2.6.2  可用率
2.6.3  文档可读性
2.7  API经济
2.7.1  API盈利模式
2.7.2  API市场
2.7.3  API经济价值链
2.8  沙箱环境
2.8.1  协同
2.8.2  维护
2.9  本章小结
第3章  分布式之道
3.1  认识分布式
3.2  分布式事务
3.2.1  什么是分布式事务
3.2.2  CAP和BASE理论
3.3  分布式锁
3.3.1  为什么需要分布式锁
3.3.2  分布式锁的实现方式
3.4  分布式限流
3.4.1  计数器
3.4.2  限速器
3.4.3  限流的维度
3.4.4  流量包
3.4.5  再来谈令牌桶
3.5  衡量性能的指标QPS、TPS等
3.5.1  什么是QPS
3.5.2  什么是TPS
3.5.3  什么是RT
3.5.4  什么是并发数
3.6  本章小结
第4章  MQ之道
4.1  认识JMS
4.1.1  JMS的组成
4.1.2  JMS编程模型
4.1.3  JMS消息结构
4.1.4  JMS消息模型
4.2  带着思考理解MQ下的基本概念
4.2.1  生产者—消费者（Producer-Consumer）
4.2.2  空间解耦
4.2.3  时间解耦
4.2.4  观察者模式与发布/订阅
4.3  消费幂等
4.3.1  什么是幂等操作
4.3.2  是什么引起我们关注消费幂等
4.3.3  如何处理消费幂等
4.4  详述MQ各种功能场景
4.4.1  解耦
4.4.2  削峰填谷
4.4.3  最终一致性
4.4.4  广播消费
4.4.5  使用集群消费模拟广播
4.4.6  重试之坑
4.5  数据异构的武器—MQ+canal
4.5.1  定义
4.5.2  常见应用场景
4.5.3  数据异构方向
4.5.4  数据异构的常用方法
4.5.5  binlog和MQ方式
4.6  关于MQ再问自己几个问题
4.6.1  我想自己控制开始消费如何做
4.6.2  为什么需要消息过滤
4.6.3  过期消息是怎么处理的
4.6.4  消息重试的注意点
4.6.5  为什么需要事务消息
4.6.6  消息为什么没有了顺序
4.7  本章小结
第5章  消息推送之道
5.1  认识消息推送
5.2  构建长连接推送系统之HTTP实践
5.2.1  Web网络结构及配置
5.2.2  基本配置
5.2.3  Transfer-Encoding: chunked
5.2.4  HTTP长连接系统组成结构
5.2.5  Session管理
5.2.6  心跳
5.2.7  消息接收的概念
5.2.8  消息推送的概念
5.2.9  消息追踪
5.2.10  HTTP长连接系统时序调用
5.2.11  创建会话（连接）
5.2.12  心跳逻辑
5.2.13  消息接收实例
5.2.14  消息推送实例
5.2.15  半推半拉
5.2.16  系统优化
5.2.17  测试
5.3  构建消息推送系统之Netty实践
5.3.1  启动
5.3.2  创建会话
5.3.3  心跳
5.3.4  发送消息
5.3.5  注销会话
5.3.6  黏包
5.4  一台服务器可以“跑”多少个连接
5.5  一台服务器可以“跑”多少个线程
5.6  弱网络环境
5.7  发送APNs
5.7.1  认识APNs
5.7.2  HTTP/2
5.7.3  Pushy的使用
5.8  本章小结
第6章  RPC之道
6.1  认识RPC
6.2  RPC是如何实现通信的
6.2.1  动态代理
6.2.2  反射
6.2.3  序列化
6.2.4  网络编程
6.3  一次RPC调用时间都去哪儿了
6.4  异步RPC
6.4.1  异步调用
6.4.2  异步监听
6.4.3  callback调用
6.5  本章小结
第7章  I/O之道
7.1 认识I/O
7.2  解读I/O多路复用技术
7.2.1  I/O多路复用概述
7.2.2  用户进程和内核
7.2.3  select和recvfrom
7.2.4  阻塞、非阻塞
7.2.5  适用场景
7.3  解读Tomcat中的NIO模型
7.3.1  Tomcat对I/O模型的支持
7.3.2  Tomcat中NIO的配置与使用
7.3.3  NioEndpoint组件关系图解读
7.3.4  NioEndpoint执行序列图
7.3.5  关于性能
7.4  本章小结
第8章  微服务之道
8.1  认识微服务
8.2  微服务后如何做一次系统梳理
8.2.1  系统分类与演进
8.2.2  梳理目的要搞清楚
8.2.3  如何做
8.2.4  核心功能的核心流程梳理
8.3  朝着微服务的方向去做一次数据库拆分
8.3.1  现状
8.3.2  方法
8.3.3  拆库的步骤（MySQL）
8.4  本章小结
第9章  容错之道
9.1  认识容错
9.2  降级与限流
9.3  线程池隔离
9.3.1  为什么要做线程池隔离
9.3.2  实现一个线程池隔离
9.3.3  线程池隔离的优点
9.3.4  线程池隔离的缺点
9.4  快速失败
9.5  熔断
9.5.1  熔断器介绍
9.5.2  熔断使用注意
9.6  Hystrix的使用
9.6.1  认识Hystrix
9.6.2  线程池隔离
9.6.3  信号量隔离
9.6.4  熔断
9.6.5  回退降级
9.7  大促备战都“备”什么
9.7.1  分离技术
9.7.2  缓存技术
9.7.3  SQL优化
9.7.4  快速失败
9.7.5  降级限流
9.7.6  性能压测
9.8  本章小结
第10章  程序之外
10.1  程序与健身
10.2  程序员的硬件装备
10.3  程序员应该看的四本技术书籍
10.4  程序员应该熟悉的常用定律法则
10.5  知识、数据、工具
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构修炼之道——亿级网关、平台开放、分布式、微服务、容错等核心技术修炼实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大规模分布式系统架构与设计实战（含光盘）
前　言
第1章概述	1
1.1分布式计算、并行计算、云计算概述	1
1.2分布式产品Hadoop、ZooKeeper、HBase概述	6
1.3Fourinone的产生背景	12
第2章分布式并行计算的原理与实践	14
2.1分布式并行计算模式	14
2.1.1最初想到的master-slave结构	14
2.1.2“包工头-职介所-手工仓库-工人”模式	15
2.1.3基于消息中枢的计算模式	17
2.1.4基于网状直接交互的计算模式	18
2.1.5并行结合串行模式	22
2.1.6包工头内部批量多阶段处理模式	23
2.1.7计算集群模式和兼容遗留计算系统	24
2.1.8工人计算的服务化模式	26
2.2跟Hadoop的区别	28
2.3关于分布式的一些概念与产品	30
2.4配置文件和核心API介绍	35
2.5实践与应用	36
2.5.1一个简单的示例	36
2.5.2工头工人计算模式更完整的示例	39
2.5.3工人合并互相say hello的示例	44
2.5.4 实现Hadoop经典实例Word Count	48
2.5.5分布式多机部署的示例	52
2.5.6分布式计算自动部署的示例	53
2.5.7计算过程中的故障和容灾处理	57
2.5.8计算过程中的相关时间属性设置	60
2.5.9如何在一台计算机上一次性启动多个进程	63
2.5.10如何调用C/C++程序实现	68
2.5.11如何中止工人计算和超时中止	68
2.5.12使用并行计算大幅提升递归算法效率	73
2.5.13使用并行计算求圆周率π	81
2.5.14从赌钱游戏看PageRank算法	86
2.5.15使用并行计算实现上亿排序	96
2.5.16工人服务化模式应用示例	104
2.6实时流计算	107
第3章分布式协调的实现	111
3.1协调架构原理简介	111
3.2核心API	113
3.3权限机制	115
3.4相对于ZooKeeper的区别	116
3.5与Paxos算法的区别	117
3.6实践与应用	119
3.6.1如何实现公共配置管理	119
3.6.2如何实现分布式锁	126
3.6.3如何实现集群管理	129
3.6.4多节点权限操作示例	134
3.6.5领导者选举相关属性设置	137
第4章分布式缓存的实现	139
4.1小型网站或企业应用的缓存实现架构	139
4.2大型分布式缓存系统实现过程	140
4.3一致性哈希算法的原理、改进和实现	147
4.4解决任意扩容的问题	152
4.5解决扩容后数据均匀的问题	153
4.6分布式Session的架构设计和实现	154
4.7缓存容量的相关属性设置	156
4.8缓存清空的相关属性设置	158
第5章消息队列的实现	162
5.1闲话中间件与MQ	162
5.2JMS的两种经典模式	163
5.3如何实现发送接收的队列模式	164
5.4如何实现主题订阅模式	168
第6章分布式文件系统的实现	173
6.1FTTP架构原理解析 	174
6.2搭建配置FttpAdapter环境	177
6.3访问集群文件根目录	179
6.4访问和操作远程文件	181
6.5集群内文件复制和并行复制	184
6.6读写远程文件	187
6.7解析远程文件	189
6.8并行读写远程文件	191
6.9批量并行读写远程文件和事务补偿处理	194
6.10如何进行整型读写	198
6.11基于整型读写的上亿排序	205
第7章分布式作业调度平台的实现	219
7.1调度平台的设计与实现	219
7.2资源隔离的实现	224
7.3资源调度算法	226
7.4其他作业调度平台简介	227
7.4.1其他MPI作业资源调度技术	227
7.4.2Mesos和Yarn简介	229
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大规模分布式系统架构与设计实战（含光盘）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>超大流量分布式系统架构解决方案：人人都是架构师2.0
第 1 章 大系统小做——大规模服务化架构  1
1.1 分布式系统的架构演变过程  1
1.1.1 单机架构  3
1.1.2 集群架构  4
1.1.3 垂直拆分业务子系统  6
1.1.4 服务化架构演进  8
1.1.5 服务化与微服务架构的区别  9
1.1.6 集群与分布式的区别  10
1.1.7 前后端分离架构演进  11
1.1.8 API 网关服务  14
1.1.9 分布式多活数据中心架构演进  17
1.2 服务治理需求  20
1.2.1 服务化与 RPC 协议  20
1.2.2 基于服务治理框架 Dubbo 实现服务化  22
1.2.3 警惕因超时和重试引起的系统雪崩  26
1.2.4 为什么需要实施服务治理  28
1.2.5 关于服务化后的分布式事务问题  31
1.2.6 注册中心性能瓶颈方案  32
1.2.7 分布式多活架构下的服务就近调用方案  34
1.3 服务治理之调用链  35
1.3.1 Google 的 Dapper 论文简介  36
1.3.2 调用链的实现方案  38
1.3.3 基于非侵入式运行期 AOP 方案实现数据采集上报  48
1.3.4 调配采样率  57
1.4 本章小结  58
第 2 章 大促备战核弹——全链路压测  59
2.1 为什么要在线上实施全链路压测  60
2.2 业务系统如何区分压测流量  63
2.2.1 压测流量打标方案  63
2.2.2 在链路上下文信息中传递压测标记  65
2.2.3 外部第三方接口走 Mock  67
2.2.4 压测数据的隔离方案  68
2.3 如何发起大规模的压测流量  69
2.3.1 数据构造平台  69
2.3.2 自研全链路压测军演系统的一些经验分享  71
2.4 本章小结  74
第 3 章 削峰填谷——流控方案  75
3.1 为什么需要限流  76
3.2 限流方案  79
3.2.1 常见的限流算法  80
3.2.2 基于 Guava 实现平均速率限流  83
3.2.3 接入层限流方案  86
3.2.4 应用层限流——限时抢购限流方案  89
3.3 基于时间分片的削峰方案  92
3.3.1 活动分时段进行实现削峰  93
3.3.2 通过答题验证实现削峰  93
3.4 基于消息队列的解耦、削峰、最终一致性方案  94
3.4.1 基于消息队列实现解耦  95
3.4.2 常见消息中间件的使用  96
3.4.3 基于消息队列的一些典型案例  113
3.5 本章小结  116
第 4 章 大促抢购核心技术难题——读/写优化方案  117
4.1 缓存技术简介  118
4.1.1 本地缓存  119
4.1.2 本地缓存的痛点  121
4.1.3 神秘的 off-heap 技术  122
4.2 高性能分布式缓存 Redis  127
4.2.1 基于 Jedis 客户端操作 Redis  128
4.2.2 基于 RedisCluster 模式实现 Sharding  129
4.3 同一热卖商品高并发读难题  133
4.3.1 多级缓存方案  135
4.3.2 缓存穿透思考  139
4.3.3 RedisCluster 模式下的读/写分离方案  140
4.4 同一热卖商品高并发写难题  143
4.4.1 InnoDB 引擎的行锁问题  143
4.4.2 基于 Redis 乐观锁的库存扣减方案  145
4.4.3 嵌入 Lua 脚本的库存扣减方案  149
4.4.4 基于 AliSQL 数据库提升并发写性能  155
4.5 本章小结  161
第 5 章 星罗棋布——分库分表方案  162
5.1 关系数据库的架构演变  163
5.1.1 数据库读/写分离  163
5.1.2 数据库垂直分库  164
5.1.3 数据库水平分库与水平分表  165
5.1.4 MySQL Sharding 与 MySQL Cluster 的区别  166
5.2 Sharding 中间件  167
5.2.1 常见的 Sharding 中间件对比  167
5.2.2 Shark 简介  169
5.2.3 Shark 的架构模型  170
5.2.4 使用 Shark 实现分库分表后的数据路由任务  171
5.2.5 分库分表后所带来的影响  178
5.2.6 全局唯一 SequenceID 解决方案  179
5.2.7 基于 Solr 满足多维度的复杂条件查询  182
5.2.8 关于分布式事务  183
5.3 数据库的 HA 方案  184
5.3.1 基于配置中心实现主备切换  185
5.3.2 基于 Keepalived 实现主备切换  186
5.3.3 保障主备切换过程中的数据一致性  188
5.4 订单业务冗余表需求  190
5.4.1 冗余表的实现方案  190
5.4.2 数据最终一致性方案  192
5.5 本章小结  195
附录  196
后记  223
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>超大流量分布式系统架构解决方案：人人都是架构师2.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式系统原理与范型
第1章 绪论
第2章 通信
第3章 进程 
第4章 命名 
第5章 同步
第6章 一致性和复制
第7章 容错性
第8章 安全性
第9章 基于对象的分布式系统 
第10章 分布式文件系统 
第11章 基于文档的分布式系统 
第12章 基于协作的分布式系统 
第13章 阅读材料和参考书目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式系统原理与范型
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式系统设计
作者简介
译者序
前言
第1章 概论
第2章 分布式程序设计语言
第3章 分布式系统设计的形式方法
第4章 互斥和选举算法
第5章 死锁的预防、避免和检测
第6章 分布式路由算法
第7章 自适应、无死锁和容错路由
第8章 分布式系统的可靠性
第9章 静态负载分配
第10章 动态负载分配
第11章 分布式数据管理
第12章 分布式系统的应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式系统设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>人人都是架构师：分布式系统架构落地与瓶颈突破
第1章  分布式服务案例	1
1.1  分布式系统的架构演变过程	2
1.1.1  单机系统	3
1.1.2  集群架构	4
1.1.3  拆系统之业务垂直化	6
1.1.4  为什么需要实现服务化架构	8
1.1.5  服务拆分粒度之微服务	10
1.2  系统服务化需求	11
1.2.1  服务化与RPC协议	11
1.2.2  使用阿里分布式服务框架Dubbo实现服务化	12
1.2.3  警惕Dubbo因超时和重试引起的系统雪崩	16
1.2.4  服务治理方案	18
1.2.5  关于服务化后的分布式事务问题	20
1.3  分布式调用跟踪系统需求	21
1.3.1  Google的Dapper论文简介	22
1.3.2  基于Dubbo实现分布式调用跟踪系统方案	25
1.3.3  采样率方案	35
1.4  本章小结	37
第2章  大流量限流/消峰案例	38
2.1  分布式系统为什么需要进行流量管制	39
2.2  限流的具体方案	42
2.2.1  常见的限流算法	43
2.2.2  使用Google的Guava实现平均速率限流	45
2.2.3  使用Nginx实现接入层限流	48
2.2.4  使用计数器算法实现商品抢购限流	49
2.3  基于时间分片的消峰方案	51
2.3.1  活动分时段进行实现消峰	52
2.3.2  通过答题验证实现消峰	52
2.4  异步调用需求	53
2.4.1  使用MQ实现系统之间的解耦	54
2.4.2  使用Apache开源的ActiveMQ实现异步调用	55
2.4.3  使用阿里开源的RocketMQ实现互联网场景下的流量消峰	61
2.4.4  基于MQ方案实现流量消峰的一些典型案例	72
2.5  本章小结	75
第3章  分布式配置管理服务案例	76
3.1  本地配置	77
3.1.1  将配置信息耦合在业务代码中	77
3.1.2  将配置信息配置在配置文件中	79
3.2  集中式资源配置需求	82
3.2.1  分布式一致性协调服务ZooKeeper简介	83
3.2.2  ZooKeeper的下载与集群安装	84
3.2.3  ZooKeeper的基本使用技巧	86
3.2.4  基于ZooKeeper实现分布式配置管理平台方案	87
3.2.5  从配置中心获取Spring的Bean定义实现Bean动态注册	93
3.2.6  容灾方案	95
3.2.7  使用淘宝Diamond实现分布式配置管理服务	96
3.2.8  Diamond与ZooKeeper的细节差异	101
3.2.9  使用百度Disconf实现分布式配置管理服务	102
3.3  本章小结	110
第4章  大促场景下热点数据的读/写优化案例	111
4.1  缓存技术简介	112
4.1.1  使用Ehcache实现数据缓存	114
4.1.2  LocalCache存在的弊端	116
4.1.3  神秘的off-heap技术	117
4.2  高性能分布式缓存Redis简介	120
4.2.1  使用Jedis客户端操作Redis	121
4.2.2  使用Redis集群实现数据水平化存储	122
4.3  同一热卖商品高并发读需求	124
4.3.1  Redis集群多写多读方案	125
4.3.2  保障多写时的数据一致性	126
4.3.3  LocalCache结合Redis集群的多级Cache方案	128
4.3.4  实时热点自动发现方案	130
4.4  同一热卖商品高并发写需求	132
4.4.1  InnoDB行锁引起数据库TPS下降	132
4.4.2  在Redis中扣减热卖商品库存方案	134
4.4.3  热卖商品库存扣减优化方案	138
4.4.4  控制单机并发写流量方案	141
4.4.5  使用阿里开源的AliSQL数据库提升秒杀场景性能	142
4.5  本章小结	148
第5章  数据库分库分表案例	149
5.1  关系型数据库的架构演变	150
5.1.1  数据库读写分离	150
5.1.2  数据库垂直分库	151
5.1.3  数据库水平分库与水平分表	152
5.1.4  MySQL Sharding与MySQL Cluster的区别	153
5.2  Sharding中间件	154
5.2.1  常见的 Sharding中间件对比	155
5.2.2  Shark简介	156
5.2.3  Shark的架构模型	157
5.2.4  使用Shark实现分库分表后的数据路由任务	159
5.2.5  分库分表后所带来的影响	166
5.2.6  多机SequenceID解决方案	167
5.2.7  使用Solr满足多维度的复杂条件查询	170
5.2.8  关于分布式事务	172
5.3  数据库的HA方案	173
5.3.1  基于配置中心实现主从切换	174
5.3.2  基于Keepalived实现主从切换	176
5.3.3  保障主从切换过程中的数据一致性	179
5.4  订单业务冗余表需求	180
5.4.1  冗余表的实现方案	181
5.4.2  保障冗余表的数据一致性	183
5.5  本章小结	186
后记	187
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>人人都是架构师：分布式系统架构落地与瓶颈突破
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式算法
出版者的话 专家指导委员会 译者

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式算法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式计算
第一章 引言
1.1 定义
1.2 与计算机系统部件的关系
1.3 动机
1.4 与并行多处理器／多计算机系统的关系
1.4.1 并行系统的特性
1.4.2 nynn的分类法
1.4.3 耦合、并行、并发及粒度
1.5 消息传递系统与共享内存系统的对比
1.5.1 在共享内存的系统上仿真消息传递
1.5.2 在消息传递系统上仿真共享内存
1.6 分布式通信的原语
1.6.1 阻塞／非阻塞，同步／异步原语
1.6.2 处理器同步性
1.6.3 库与标准
1.7 同步与异步执行
1.7.1 通过同步系统仿真异步系统
1.7.2 通过异步系统仿真同步系统
1.7.3 仿真
1.8 设计主题与挑战
1.8.1 从系统角度看分布式系统的挑战
1.8.2 分布式计算中的算法挑战
1.8.3 分布式计算的应用以及更新的挑战
1.9 关于主题的选择与覆盖
1.10 本章小结
1.11 习题
1.12 参考文献说明
参考文献
第二章 分布式计算模型
2.1 分布式程序
2.2 分布式运行模型
2.3 通信网络模型
2.4 分布式系统的全局状态
2.4.1 全局状态
2.5 分布式计算的运行分割
2.6 事件的过去和未来锥面
2.7 进程通信模型
2.8 本章小结
2.9 习题
2.10 参考文献说明
参考文献
第三章 逻辑时间
3.1 引言
3.2 逻辑时钟框架
3.2.1 定义
3.2.2 实现逻辑时钟
3.3 标量时间
3.3.1 定义
3.3.2 基本性质
3.4 向量时间
3.4.1 定义
3.4.2 基本性质
3.4.3 有关向量时钟的大小
3.5 向量时钟的有效实现
3.5.1 Singhal-Kshemkalyani的差量技术
3.5.2 Fowler-Zwaenepoel的直接依赖技术
3.6 Jard-jourdan的自适应技术
3.7 矩阵时间
3.7.1 定义
……
第四章 记录全局状态与快照算法
第五章 术语和基本算法
第六章 消息序与组通信
第七章 终止检测
第八章 知识推理
第九章 分布式互斥算法
第十章 死锁检测
第十一章 全局谓词的检测
第十二章 分布式共享内存
第十三章 检查点和卷回恢复
第十四章 共识和协定算法
第十五章 失效检测
第十六章 分布式系统中的验证
第十七章 自稳定
第十八章 对等计算及覆盖网络
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式计算
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高可用性的HDFS
目录
第1章 HDFS HA及解决方案 1
1.1 HDFS系统架构 2
1.2 HA定义 3
1.3 HDFS HA原因分析及应对措施 4
1.3.1 可靠性 4
1.3.2 可维护性 5
1.4 现有HDFS HA解决方案 5
1.4.1 Hadoop的元数据备份方案 6
1.4.2 Hadoop的SecondaryNameNode方案 7
1.4.3 Hadoop的Checkpoint ode方案 7
1.4.4 Hadoop的BackupNode方案 8
1.4.5 DRDB方案 9
1.4.6 FaceBook的AvatarNode方案 10
1.5 方案优缺点比较 10
第2章 HDFS元数据解析 13
2.1 概述 14
2.2 内存元数据结构 14
2.2.1 INode 15
2.2.2 Block 16
2.2.3 BlockInfo和DatanodeDescriptor 17
2.2.4 小结 17
2.2.5 代码分析——元数据结构 18
2.3 磁盘元数据文件 24
2.4 Format情景分析 27
2.5 元数据应用场景分析 45
第3章 Hadoop的元数据备份方案 47
3.1 运行机制分析 48
3.1.1 NameNode启动加载元数据情景分析 50
3.1.2 元数据更新及日志写入情景分析 64
3.1.3 Checkpoint过程情景分析 73
3.1.4 元数据可靠性机制 109
3.1.5 元数据一致性机制 110
3.2 使用说明 110
第4章 Hadoop的Backup Node方案 113
4.1 Backup Node概述 114
4.1.1 系统架构 115
4.1.2 使用原则 115
4.1.3 优缺点 116
4.2 运行机制分析 116
4.2.1 启动流程 117
4.2.2 元数据操作情景分析 141
4.2.3 日志池（journal spool）机制 151
4.2.4 故障切换机制 156
4.3 实验方案说明 158
4.4 构建实验环境 158
4.4.1 网络拓扑 159
4.4.2 系统安装及配置 160
4.4.3 安装JDK 170
4.4.4 虚拟机集群架设 171
4.4.5 NameNode安装及配置 173
4.4.6 Backup Node安装及配置 173
4.4.7 Data Node安装及配置 174
4.4.8 Clients安装及配置 175
4.5 异常解决方案 175
4.5.1 异常情况分析 175
4.5.2 NameNode配置 175
4.5.3 Backup Node配置 182
4.5.4 Data Node配置 185
4.5.5 NameNode宕机切换实验 189
4.5.6 NameNode宕机读写测试 196
第5章 AvatarNode运行机制 205
5.1 方案说明 206
5.1.1 系统架构 206
5.1.2 思路分析 208
5.1.3 性能数据 209
5.2 元数据分析 209
5.2.1 类FSNamesystem 210
5.2.2 类FSDirectory 210
5.2.3 AvatarNode的磁盘元数据文件 211
5.3 AvatarNode Primary启动过程 211
5.4 AvatarNode Standby启动过程 217
5.4.1 AvatarNode的构造方法 217
5.4.2 Standby线程的run()方法 218
5.4.3 Ingest线程的run()方法 220
5.4.4 Ingest线程的ingestFSEdits ()方法 220
5.4.5 Standby线程的doCheckpoint()方法 221
5.5 用户操作情景分析 223
5.5.1 创建目录情景分析 223
5.5.2 创建文件情景分析 231
5.6 AvatarNode Standby故障切换过程 240
5.7 元数据一致性保证机制 242
5.7.1 元数据目录树信息 242
5.7.2 Data Node与Block数据块映射信息 243
5.8 Block更新同步问题 246
5.8.1 问题描述 246
5.8.2 结论 246
5.8.3 源码分析 246
第6章 AvatarNode使用 253
6.1 方案说明 254
6.1.1 网络拓扑 254
6.1.2 操作系统安装及配置 255
6.2 使用Avatar打补丁版本 255
6.2.1 Hadoop源码联机Build 256
6.2.2 Hadoop源码本地Build 262
6.2.3 NFS服务器构建 264
6.2.4 Avatar分发与部署 267
6.2.5 Primary（namenode0）节点配置 269
6.2.7 Data Node节点配置 276
6.2.8 Client节点配置 278
6.2.9 创建目录 279
6.2.10 挂载NFS 280
6.2.11 启动Ucarp 280
6.2.12 格式化 281
6.2.13 系统启动 281
6.2.14 检查 282
6.2.15 NameNode失效切换写文件实验 283
6.2.16 NameNode失效切换读文件实验 291
6.3 Avatar FaceBook版本的使用 294
6.3.1 Hadoop FaceBook版本安装 294
6.3.2 节点配置 295
6.3.3 启动HDFS 300
6.3.4 NameNode失效切换 302
第7章 AvatarNode异常解决方案 305
7.1 测试环境 306
7.2 Primary失效 306
7.2.1 解决方案 306
7.2.2 写操作实验步骤 307
7.2.3 改进写操作机制 313
7.2.4 读操作实验步骤 313
7.2.5 小结 317
7.3 Standby失效 317
7.4 NFS失效（数据未损坏） 317
7.4.1 解决方案 317
7.4.2 写操作实验步骤 318
7.4.3 读操作实验步骤 320
7.4.4 小结 322
7.5 NFS失效（数据已损坏） 323
7.5.1 解决方案 323
7.5.2 写操作实验步骤 324
7.5.3 读操作实验步骤 327
7.5.4 小结 330
7.6 Primary先失效，NFS后失效（数据未损坏） 331
7.6.1 解决方案 331
7.6.2 写操作实验步骤 331
7.6.3 读操作实验步骤 333
7.6.4 小结 334
7.7 Primary先失效（数据未损坏），NFS后失效（数据损坏） 335
7.7.1 解决方案 335
7.7.2 写操作实验步骤 335
7.7.3 读操作实验步骤 338
7.7.4 小结 339
7.8 NFS先失效（数据未损坏），Primary后失效 340
7.8.1 解决方案 340
7.8.2 写操作实验步骤 340
7.8.3 读操作实验步骤 342
7.8.4 小结 343
7.9 NFS先失效（数据损坏），Primary后失效（数据损坏） 344
7.9.1 解决方案 344
7.9.2 写操作实验步骤 344
7.9.3 读操作实验步骤 346
7.9.4 小结 348
7.10 实验结论 348
第8章 Cloudera HA NameNode使用 349
8.1 HA NameNode说明 350
8.2 CDH4B1版本HDFS集群配置 351
8.2.1 虚拟机安装 351
8.2.2 nn1配置 351
8.2.3 dn1~dn3配置 355
8.2.4 HDFS集群构建 358
8.3 HA NameNode配置 361
8.3.1 nn1配置 361
8.3.2 其他节点配置 365
8.4 HA NameNode使用 367
8.4.1 启动HA HDFS集群 367
8.4.2 第1次failover 368
8.4.3 模拟写操作 368
8.4.4 模拟Active Name Node失效，第2次failover 369
8.3.5 模拟新的Standby NameNode加入 370
8.5 小结 371
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高可用性的HDFS
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式操作系统
第1章 分布式系统概述
1.1 什么是分布式系统
1.2 目标
1.3 硬件概念
1.4 软件概念
1.5 设计中的问题
1.6 小结
习题
第2章 分布式系统的通信
2.1 分层协议
2.2 ATM网络
2.3 客户—服务器模式
2.4 远程过程调用
2.5 组通信
2.6 小结
习题
第3章 分布式系统的同步
3.1 时钟同步
3.2 互斥
3.3 选举算法
3.4 原子事务
3.5 分布式系统中的死锁
3.6 小结
习题
第4章 分布式系统的进程和处理机
4.1 线程
4.2 系统模型
4.3 处理机分配
4.4 分布式系统的调度
4.5 容错
4.6 实时分布式系统
4.7 小结
习题
第5章 分布式文件系统
5.1 分布式文件系统设计
5.2 分布式文件系统的实现
5.3 分布式文件系统的发展趁势
5.4 小结
习题
第6章 分布式共享存储器
6.1 简介
6.2 什么是共享存储器
6.3 一致性模型
6.4 基于分页的分布式共享存储器
6.5 共享变量的分布式共享存储器
6.6 基于对象的分布共享内存
6.7 比较
6.8 小结
习题
第7章 实例研究1：Amoeba
7.1 Amoeba介绍
7.2 Amoeba中的对象和权能
……
第8章 实例研究2：Mach
第9章 实例研究3：Chorus
第10章 实例研究4：DCE
第11章 读物列表与参考书目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式操作系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式计算
第1章 引言
1.1 分布式系统
1.2 分布式计算理论
1.3 内容概要
1.4 理论和实践的关系
本章注释
第一部分
第2章 消息传递系统中的基本算法
2.1 消息传递系统的形式化模型
2.2 生成树上的广播和敛播
2.3 洪泛算法及构造生成树
2.4 构造指定根的深度—优先搜索生成树
2.5 构造不指定根的深度—优先搜索生成树
练习
本章注释
第3章 环中领导者选举算法
3.1 领导者选举问题
3.2 匿名环
3.3 异步环
练习
本章注释
第4章 共享存储器中的互斥
4.1 共享存储器系统的形式化模型
4.2 互斥问题
4.3 使用强原语的互斥
4.4 使用强原语的互斥
练习
本章注释
第5章 容错一致性
5.1 有损毁故障的同步系统
5.2 有Byzantine故障的同步系统
5.3 异步系统中的不可能性
练习
本章注释
第6章 因果关系和时间
6.1 捕获因果关系
6.2 应用因果关系的例子
6.3 时钟同步
练习
本章注释
第二部分
第7章 模拟的形式化模型
第8章 广播与多播
第9章 分布式共享存储器
第10章 读/写对象的容错模拟
第11章 模拟同步
第12章 改进算法的容错性
第13章 容错的时钟同步
第三部分
第14章 随机化
第15章 任意对象的无等待模拟
第16章 异步系统中的可解问题
第17章 解决最终稳定系统的一致性问题
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式计算
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式计算原理与应用
第1章 分布式计算简介
第2章 进程间通信
第3章 分布式计算范型
第4章 socket API
第5章 客户-服务器范型
第6章 组通信
第7章 分布式对象
第8章 高级RMI
第9章 Internet应用(一)
第10章 CORBA
第11章 Internet应用(二)
第12章 高级分布计算范型
后记
术语对照表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式计算原理与应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式实时计算框架原理及实践案例
第1 章 分布式实时计算框架介绍.1
1.1 分布式计算Hadoop.1
1.2 分布式实时计算........3
1.2.1 Spark Streaming..3
1.2.2 Storm .......6
1.2.3 其他框架.8
1.3 为什么自研......8
1.4 总结......10
第2 章 light_drtc 简介及使用说明......... 11
2.1 light_drtc 框架简介 11
2.2 light_drtc 代码结构12
2.3 light_drtc 重要配置项.......14
2.4 light_drtc 和Storm 比较...15
2.5 light_drtc 使用说明16
2.5.1 ACN（AN 和CN 整合）作为独立服务....16
2.5.2 CN、AN 作为独立服务........20
2.5.3 任务计算JN.....23
2.6 总结......26
第3 章 light_drtc 核心技术实现...27
3.1 light_drtc 技术架构27
3.2 light_drtc 计算框架设计思想....30
3.2.1 CN 设计思想....30
3.2.2 AN 多主模式设计思想..........31
3.2.3 JN 设计思想.....34
3.3 light_drtc 核心技术的实现.........36
3.3.1 实时收集数据CN.......36
3.3.2 任务协调管理AN.......40
3.3.3 任务计算JN.....49
3.4 总结......50
第4 章 消息队列MQ.51
4.1 消息队列使用场景.51
4.2 消息队列原理..........53
4.2.1 MQ 使用流程...53
4.2.2 MQ 基本概念...54
4.2.3 MQ 通信模式...55
4.2.4 目前知名MQ 比较.....56
4.3 MQ 消费状态监控..61
4.3.1 KafkaOffsetMonitor 介绍.......62
4.3.2 KafkaOffsetMonitor 部署.......62
4.4 RabbitMQ 和Kafka 的基本使用.........64
4.4.1 RabbitMQ 读写实例...64
4.4.2 Kafka 读写实例68
4.5 总结......71
第5 章 内存数据库Redis3.0 及SSDB..........72
5.1 Redis 相关介绍........72
5.1.1 Redis3.0 集群架构......73
5.1.2 Redis3.0 集群选举与容错......74
5.1.3 SSDB 简介.......75
5.2 Redis3.0 集群搭建..76
5.2.1 集群所依赖的Ruby 环境......77
5.2.2 Redis 集群创建77
5.2.3 Redis 集群验证78
5.2.4 SSDB 简单部署..........79
5.3 Redis 管理及使用...81
5.3.1 Redis 基本使用81
5.3.2 Redis 管理........83
5.4 Redis 客户端应用...86
5.4.1 Redis3.0 客户端..........86
5.4.2 SSDB 客户端...89
5.5 本地缓存Guava Cache.....90
5.5.1 认识Guava Cache .......90
5.5.2 Guava Cache 使用.......91
5.5.3 Java 客户端使用.........94
5.6 总结......97
第6 章 NoSQL：MongoDB3.0 和HBase1.0 .........98
6.1 MongoDB3.0 和HBase1.0 新特性......99
6.1.1 MongoDB3.0 新特性..99
6.1.2 HBase1.0 新特性.......102
6.1.3 MongoDB 和HBase 比较....104
6.2 MongoDB3.0 集群和索引........105
6.2.1 MongoDB3.0 集群....105
6.2.2 Mongo 索引介绍.......107
6.3 HBase 底层实现介绍......108
6.3.1 HBase 相关Hadoop 体系....108
6.3.2 HBase 系统架构........ 110
6.4 Mongo 和HBase 客户端使用. 113
6.4.1 Mongo 客户端 113
6.4.2 HBase 客户端. 119
6.5 总结.....124
第7 章 全文检索：ElasticSearch2.x..125
7.1 认识ElasticSearch 和Solr........125
7.1.1 ElasticSearch 和Solr 基本介绍......125
7.1.2 ES 基本概念...127
7.1.3 ES 和SolrCloud 集群结构...129
7.1.4 ES 使用案例...130
7.2 ES 和Solr 比较分析.......131
7.2.1 ES 和Solr 发展比较.131
7.2.2 ES 和Solr 综合比较.132
7.3 ES 集群介绍135
7.3.1 插件安装........135
7.3.2 中文分词安装136
7.3.3 ES2.X 集群节点类型138
7.3.4 ES 配置事项...142
7.4 ES 客户端使用......144
7.4.1 ES 客户端连接..........145
7.4.2 ES 基本操作...146
7.4.3 ES 高级使用...150
7.5 ES 在自研框架中的作用..........154
7.6 总结.....155
第8 章 微服务架构通信——RPC 和Web Service ........156
8.1 微服务架构由来....156
8.1.1 微服务与SOA 比较..157
8.1.2 微服务架构的优缺点159
8.1.3 微服务雪崩效应的防范.......161
8.2 RPC 介绍及实践...163
8.2.1 Thrift/Nifty 介绍........163
8.2.2 Avro 介绍.......168
8.2.3 Dubbo/Dubbox 介绍..180
8.2.4 GRPC/ProtoBuf 介绍185
8.2.5 ZeroC ICE.......191
8.3 Web Service 介绍及实践..........199
8.3.1 SOAP 和Rest .200
8.3.2 JWS（JDK 自身实现Web Service）........202
8.3.3 Jetty：嵌入式Servlet 容器..204
8.3.4 基于Spring MVC......206
8.3.5 其他Web Service 框架........ 211
8.4 总结.....212
第9 章 综合实例：新闻推荐中的用户画像近实时更新213
9.1 个性化推荐系统组成.....213
9.1.1 用户行为收集214
9.1.2 行为日志解析216
9.1.3 常用推荐算法221
9.1.4 用户画像数据仓库...245
9.1.5 元数据索引库247
9.1.6 用户推荐服务248
9.2 新闻推荐中用户画像近实时更新设计......248
9.2.1 新闻推荐中用户画像构成...250
9.2.2 新闻推荐中用户画像标签数据字典.........251
9.2.3 新闻推荐用户画像实时更新流程..257
9.3 新闻推荐用户画像近实时更新技术实现..260
9.3.1 Storm 接入Kafka 实时计算实例...260
9.3.2 Spark Streaming 接入Kafka 实时计算实例........265
9.3.3 Light_drtc 接入Kafka..........270
9.3.4 用户画像实时更新核心实现..........270
9.4 总结.....280
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式实时计算框架原理及实践案例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Zabbix企业级分布式监控系统
t目 录
第1部分 基础部分
第1章 监控系统简介 2
1.1 为何需要监控系统 2
1.2 监控系统的实现 2
1.3 监控系统的开源软件现状 4
1.4 监控系统的原理探究 11
第2章 Zabbix简介 14
2.1 Zabbix的客户 14
2.2 使用Zabbix的准备 15
2.3 Zabbix为何物 15
2.4 选择Zabbix的理由 16
2.5 Zabbix的架构 17
2.6 Zabbix的运行流程 18
2.7 Zabbix的功能特性 19
第3章 安装与部署 21
3.1 安装环境概述 21
3.2 Zabbix-Server服务端的安装 25
3.3 Zabbix-Agent客户端的安装 39
3.4 SNMP监控方式的配置 40
3.5 在Windows中安装Zabbix-Agent 40
3.6 其他平台的安装 43
3.7 Zabbix-Get的使用 43
3.8 Zabbix相关术语（命令） 44
3.9 Zabbix-Server对数据的存储 45
3.10 Zabbix init脚本解释 55
3.11 高可用和安全 56
3.12 Zabbix数据库的备份 57
第4章 快速配置使用 59
4.1 配置流程 59
4.2 主机组的添加 61
4.3 模板的添加 63
4.4 添加主机 65
4.5 Graphs的配置 68
4.6 Screen的配置 74
4.7 Slide shows的配置 78
4.8 Zatree的使用 79
4.9 Map的配置 80
4.10 Web监控 85
4.11 IT服务 92
4.12 报表 95
4.13 资产管理 97
第5章 深入配置使用 99
5.1 Items的添加 99
5.2 Items key的添加 105
5.3 Items的类型 109
5.4 宏的配置 129
5.5 维护时间 131
5.6 事件确认 132
5.7 数据的导入/导出配置 134
第6章 告警配置 135
6.1 告警概述 135
6.2 Trigger的配置 136
6.3 添加Actions 151
6.4 邮件告警配置的实例 160
6.5 自定义脚本告警 163
6.6 邮件告警脚本的配置实例 165
6.7 告警升级的机制 169
6.8 告警配置故障排查 172
第2部分 中级部分
第7章 监控方式剖析 176
7.1 Zabbix支持的监控方式 176
7.2 Zabbix监控方式的逻辑 177
7.3 Agent监控方式 177
7.4 Trapper监控方式 177
7.5 SNMP监控方式 180
7.6 IPMI监控方式 189
7.7 JMX监控方式 194
7.8 命令的执行 201
第8章 分布式监控 202
8.1 代理架构 202
8.2 节点架构 205
8.3 被动模式和主动模式 206
第9章 Zabbix与自动化运维 211
9.1 监控自动化 211
9.2 网络发现 212
9.3 主动方式的自动注册 215
9.4 Low level discovery功能 222
9.5 Zabbix与自动化配置管理工具SaltStack 238
第10章 使用的经验技巧 242
10.1 如何有效地设置监控告警 242
10.2 监控项的使用技巧 246
10.3 触发器的使用技巧 246
10.4 触发器配置 247
10.5 谷歌浏览器告警插件 249
10.6 数据图断图 250
第11章 监控案例 252
11.1 监控TCP连接数 252
11.2 监控Nginx 254
11.3 监控PHP-FPM 256
11.4 监控MySQL 260
11.6 监控DELL服务器 272
11.7 监控Cisco路由器 272
11.8 监控VMware 275
第3部分 高级部分
第12章 性能优化 282
12.1 Zabbix性能优化概述 282
12.2 Zabbix性能优化的依据 283
12.3 配置文件的参数优化 285
12.4 Zabbix的架构优化 287
12.5 Items工作模式及Trigger的优化 287
12.6 Zabbix的数据库优化 287
12.7 其他方面 289
第13章 Zabbix API的使用 290
13.1 Zabbix API简介 290
13.2 JSON-RPC 290
13.3 Zabbix API的使用流程 293
13.4 第三方Zabbix API模块 302
第14章 使用Zabbix协议 304
14.1 Zabbix协议概述 304
14.2 Zabbix Sender协议 305
14.3 Zabbix-Get协议 310
14.4 Zabbix-Agent协议 310
第15章 定制Zabbix安装包 313
15.1 为什么要定制安装包 313
15.2 如何定制安装包 313
第16章 大型分布式监控案例 316
16.1 监控系统构建概述 316
16.2 监控环境架构图 317
16.3 架构实现的过程 317
16.4 业务相关的配置 335
16.5 其他需求 338
附录A 源码安装及相关配置 339
A.1 安装Zabbix-Server 339
A.2 安装Zabbix-Agent 341
A.3 关于Zabbix的升级 342
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Zabbix企业级分布式监控系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构解密：从分布式到微服务
第1章  大话分布式系统	1
1.1  IT争霸战	1
1.1.1  划时代的第一台计算机	1
1.1.2  IT界的恐龙时代	4
1.1.3  贵族的没落与平民的胜利	6
1.1.4  ARM新贵的爆发	10
1.1.5  超级计算机的绝地反击	11
1.2  分布式系统的开国元勋	13
1.3  分布式系统的基石：TCP/IP	17
1.4  从无奈到崛起的CDN网	19
1.5  这是一个最好的时代	21
第2章  “知识木桶”中的短板—— 网络基础	23
2.1  即使高手也不大懂的网络	23
2.2  NIO，一本难念的经	30
2.2.1  难懂的ByteBuffer	30
2.2.2  晦涩的“非阻塞”	39
2.2.3  复杂的Reactor模型	41
2.3  AIO，大道至简的设计与苦涩的现实	45
2.4  网络传输中的对象序列化问题	50
第3章  分布式系统的经典基础理论	55
3.1  从分布式系统的设计理念说起	55
3.2  分布式系统的一致性原理	58
3.3  分布式系统的基石之ZooKeeper	61
3.3.1  ZooKeeper的原理与功能	61
3.3.2  ZooKeeper的场景案例分析	65
3.4  经典的CA理论	69
3.5  BASE准则，一个影响深远的指导思想	72
3.6  重新认识分布式事务	73
3.6.1  数据库单机事务的实现原理	73
3.6.2  经典的X/OpenDTP事务模型	75
3.6.3  互联网中的分布式事务解决方案	78
第4章  聊聊RPC	83
4.1  从IPC通信说起	83
4.2  古老又有生命力的RPC	85
4.3  从RPC到服务治理框架	91
4.4  基于ZeroC Ice的微服务架构指南	94
4.4.1  微服务架构概述	95
4.4.2  ZeroC Ice微服务架构指南	100
第5章  深入浅析内存	107
5.1  你所不知道的内存知识	107
5.1.1  复杂的CPU与单纯的内存	107
5.1.2  多核CPU与内存共享的问题	110
5.1.3  著名的Cache伪共享问题	113
5.1.4  深入理解不一致性内存	115
5.2  内存计算技术的前世今生	118
5.3  内存缓存技术分析	123
5.3.1  缓存概述	123
5.3.2  缓存实现的几种方式	125
5.3.3  学习Memcache的内存管理技术	127
5.3.4  Redis的独特之处	129
5.4  内存计算产品分析	131
5.4.1  SAP HANA	131
5.4.2  Hazelcast	133
5.4.3  VoltDB	135
第6章  深入解析分布式存储	138
6.1  数据存储进化史	138
6.2  经典的网络文件系统NFS	145
6.3  高性能计算领域的分布式文件系统	148
6.4  企业级分布式文件系统GlusterFS	150
6.5  创新的Linux分布式存储系统—— Ceph	153
6.6  软件定义存储	160
第7章  聊聊分布式计算	166
7.1  不得不说的Actor模型	166
7.2  Actor原理与实践	170
7.3  初识Akka	177
7.4  适用面很广的Storm	185
7.5  MapReduce及其引发的新世界	194
第8章  全文检索与消息队列中间件	201
8.1  全文检索	201
8.1.1  什么是全文检索	201
8.1.2  起于Lucene	202
8.1.3  Solr	206
8.1.4  ElasticSearch	209
8.2  消息队列	217
8.2.1  消息队列概述	217
8.2.2  JEE专属的JMS	221
8.2.3  生生不息的ActiveMQ	226
8.2.4  RabbitMQ	231
8.2.5  Kafka	238
第9章  微服务架构	244
9.1  微服务架构概述	244
9.1.1  微服务架构兴起的原因	244
9.1.2  不得不提的容器技术	246
9.1.3  如何全面理解微服务架构	249
9.2  几种常见的微服务架构方案	253
9.2.1  ZeroC IceGrid微服务架构	253
9.2.2  Spring Cloud微服务架构	256
9.2.3  基于消息队列的微服务架构	259
9.2.4  Docker Swarm微服务架构	261
9.3  深入Kubernetes微服务平台	263
9.3.1  Kubernetes的概念与功能	263
9.3.2  Kubernetes的组成与原理	268
9.3.3  基于Kubernetes的PaaS平台	272
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构解密：从分布式到微服务
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式实时处理系统：原理、架构与实现
目录
本书赞誉
序一
序二
序三
前言
第1章　分布式计算概述 1
1.1　分布式概念 1
1.2　分布式计算及其原理 2
1.3　分布式系统特性 3
1.3.1　容错性 3
1.3.2　高可扩展性 4
1.3.3　开放性 5
1.3.4　并发处理能力 5
1.3.5　透明性 6
1.4　通用分布式计算系统 6
1.4.1　Apache Hadoop 6
1.4.2　Apache Spark 8
1.4.3　Apache Storm 9
1.5　分布式存储系统 10
1.5.1　分布式存储概念 10
1.5.2　分布式存储系统特点 12
1.5.3　分布式存储系统分类 12
1.5.4　常见分布式存储系统 13
1.6　本章小结 14
第2章　分布式系统通信基础 15
2.1　时代的浪潮 15
2.1.1　集中式通信网 16
2.1.2　去中心化 16
2.2　可靠的数据链路 17
2.2.1　数据分组 17
2.2.2　帧同步 18
2.2.3　差错控制 18
2.2.4　链路管理 18
2.2.5　问题与解决方案 19
2.3　分层架构 19
2.4　网络层 22
2.4.1　寻找路径 22
2.4.2　网络分层 23
2.4.3　TCP/IP概述 23
2.4.4　IP协议 24
2.5　传输层 30
2.5.1　数据自动分包 30
2.5.2　端到端的传输 30
2.5.3　数据的可靠传输 30
2.6　应用层 35
2.6.1　ping 35
2.6.2　telnet 36
2.6.3　OSPF 36
2.6.4　DNS 36
2.6.5　HTTP协议 37
2.7　基于消息协议的公告牌 38
2.7.1　需求描述 38
2.7.2　制定协议 38
2.8　分布式通信举例——MapReduce 39
2.9　本章小结 41
第3章　通信系统高层抽象 42
3.1　RPC介绍 42
3.2　RESTful 44
3.2.1　资源和表现层 45
3.2.2　状态转移 45
3.2.3　RESTful总结 46
3.3　消息队列 46
3.4　序列化 49
3.5　使用Thrift实现公告牌服务 50
3.5.1　Apache Thrift介绍 51
3.5.2　安装Apache Thrift 51
3.5.3　编写Thrift文件 52
3.5.4　实现服务器 53
3.5.5　实现客户端 54
3.6　本章小结 56
第4章　走进C++高性能编程 57
4.1　基于C++的留言板系统 58
4.1.1　基于Socket的通信 58
4.1.2　C++中的内存与资源管理 64
4.2　来自服务器的天书 69
4.2.1　编码 69
4.2.2　C++98的编码缺陷 72
4.2.3　C++11编码支持 73
4.3　繁忙的服务器 75
4.3.1　分身乏术 75
4.3.2　fork——分身术 76
4.3.3　进程间通信 79
4.3.4　轻量级分身——线程 85
4.3.5　C++11线程 86
4.3.6　竞争问题与解决方案 88
4.3.7　多线程优化 95
4.3.8　异步I/O 99
4.4　消失不见的内存 105
4.4.1　内存分配与内存碎片 106
4.4.2　tcmalloc 108
4.4.3　内存池 110
4.5　本章小结 112
第5章　分布式实时处理系统 113
5.1　Hadoop与MapReduce 113
5.1.1　HDFS 114
5.1.2　MapReduce模型 115
5.2　Storm实时处理系统 129
5.2.1　历史 129
5.2.2　计算模型 130
5.2.3　总体架构 133
5.2.4　Storm元数据 133
5.2.5　Storm与Hadoop比较 138
5.3　有保证的消息处理 139
5.3.1　完全处理与元组树 139
5.3.2　元组的唯一标识 139
5.3.3　确认和失败 141
5.3.4　高效实现 143
5.4　本章小结 144
第6章　实时处理系统编程接口设计 145
6.1　总体架构设计 145
6.1.1　Hurricane与Storm比较 145
6.1.2　总体架构 146
6.1.3　任务接口 148
6.2　消息源接口设计 149
6.3　消息处理器接口设计 150
6.4　数据收集器设计 151
6.5　元组接口设计 154
6.6　序列化接口设计 160
6.7　本章小结 161
第7章　服务组件设计与实现 162
7.1　Executor设计与实现 162
7.1.1　事件驱动的消息队列 162
7.1.2　动态装载技术 167
7.1.3　Executor实现 169
7.2　Task设计与实现 171
7.3　本章小结 172
第8章　管理服务设计与实现 173
8.1　President功能与设计 173
8.2　President实现 174
8.2.1　简单的网络通信实现 175
8.2.2　Topology装载实现 182
8.2.3　Manager管理调度实现 184
8.2.4　序列化实现 193
8.3　本章小结 198
第9章　实时处理系统编程接口实现 199
9.1　消息源接口实现 200
9.1.1　消息源执行器 200
9.1.2　WordCount实现实例 205
9.2　消息处理单元接口实现 207
9.2.1　消息处理单元执行器 207
9.2.2　事件处理 212
9.2.3　WordCount实现实例 215
9.3　数据收集器实现 218
9.3.1　分发策略 218
9.3.2　传输层实现 224
9.4　本章小结 226
第10章　可靠消息处理 227
10.1　基本概念 227
10.1.1　完全处理 227
10.1.2　失败与重发 229
10.2　接口设计 229
10.3　具体实现 233
10.3.1　简单实现 233
10.3.2　高效实现 235
10.4　本章小结 237
第11章　通信系统设计与实现 238
11.1　I/O多路复用方案解析 239
11.1.1　基本网络编程接口 239
11.1.2　非阻塞的服务器程序 241
11.1.3　使用select()接口的基于事件驱动的服务器模型 242
11.1.4　使用epoll实现异步事件通知模型 245
11.2　基础工具 249
11.2.1　线程工具 250
11.2.2　日志工具 254
11.3　传输层实现 263
11.3.1　Reactor模式 263
11.3.2　定义抽象TP传输层 264
11.3.3　实现基于epoll的TP传输层 269
11.3.4　实现基于IOCP的TP传输层 290
11.4　应用层HTTP实现 307
11.4.1　HttpContext 307
11.4.2　HttpRequest 311
11.4.3　HttpResponse 313
11.4.4　HttpConnection 315
11.4.5　HttpServer 317
11.4.6　总结 319
11.5　跨平台分割编译 320
11.5.1　Makefile 320
11.5.2　Kake 323
11.6　与实时处理系统集成 325
11.6.1　修改NetListener 325
11.6.2　修改NetConnector 327
11.7　本章小结 330
第12章　事务性Topology实现 331
12.1　Exact-once语义解决方案 331
12.2　设计细节 333
12.2.1　构造事务性Topology 333
12.2.2　消息处理单元 334
12.3　事务性Topology API 337
12.3.1　消息处理单元 337
12.3.2　事务性消息源 339
12.4　本章小结 339
第13章　多语言接口 340
13.1　C语言通用接口 340
13.1.1　元组接口 342
13.1.2　消息源接口 346
13.1.3　消息处理单元接口 349
13.1.4　计算拓扑接口 352
13.2　Python接口 354
13.2.1　ctypes 354
13.2.2　元组接口 356
13.2.3　消息源接口 359
13.2.4　消息处理单元接口 360
13.2.5　计算拓扑接口 361
13.2.6　应用示例 364
13.3　JavaScript接口 365
13.3.1　V8引擎 366
13.3.2　Node.js 366
13.3.3　V8的互操作接口 367
13.3.4　任务接口 368
13.3.5　消息源接口 369
13.3.6　消息处理单元接口 370
13.3.7　计算拓扑接口 371
13.3.8　应用示例 373
13.4　Java接口 375
13.4.1　任务接口 375
13.4.2　消息源接口 376
13.4.3　消息处理单元接口 377
13.4.4　计算拓扑接口 377
13.4.5　本地代码 380
13.4.6　应用示例 382
13.5　Swift接口 384
13.5.1　应用范围 385
13.5.2　任务接口 385
13.5.3　消息源接口 386
13.5.4　消息处理单元接口 387
13.5.5　计算拓扑接口 388
13.6　本章小结 390
第14章　Squared设计与实现——实现高级抽象元语 391
14.1　Storm Trident介绍 391
14.1.1　Squared示例 391
14.1.2　DRPC示例 394
14.2　Squared实现 396
14.2.1　SquaredTopology和Spout 396
14.2.2　SquaredBolt 401
14.2.3　Stream 405
14.2.4　状态存储 410
14.2.5　DRPC实现 412
14.2.6　操作与处理节点 416
14.2.7　流操作 419
14.3　本章小结 423
第15章　实战：日志流处理 425
15.1　日志流处理设计方案 425
15.2　实现Topology 427
15.2.1　编写消息源 427
15.2.2　编写索引消息处理单元 428
15.2.3　编写统计消息处理单元 429
15.3　本章小结 431
第16章　实战：频繁组合查找 432
16.1　背景介绍 432
16.1.1　数据挖掘概念 432
16.1.2　关联规则和频繁项集 433
16.1.3　啤酒与尿布 435
16.2　频繁二项集挖掘方法 435
16.2.1　频繁二项集 435
16.2.2　算法设计思路 438
16.2.3　Hurricane实现思路 439
16.3　编写Spout 439
16.4　编写Bolt 441
16.4.1　SplitBolt 441
16.4.2　PairCountBolt 442
16.4.3　PairTotalCountBolt 443
16.4.4　ConfidenceComputeBolt 444
16.4.5　SupportComputeBolt 445
16.4.6　FilterBolt 447
16.5　编写Topology 448
16.6　本章小结 449
第17章　实战：在AWS和阿里云上部署Hurricane实时处理系统 450
17.1　AWS部署 450
17.1.1　搭建虚拟私有云 452
17.1.2　配置安全组 455
17.1.3　加载EC2实例 456
17.1.4　弹性IP地址管理 461
17.2　阿里云部署 464
17.2.1　创建虚拟私有云 464
17.2.2　管理安全组 467
17.2.3　创建ECS 468
17.2.4　SSH登录 471
17.3　Hurricane分布式部署与管理 471
17.3.1　分布式部署原理 472
17.3.2　分布式安装配置 472
17.3.3　分布式启动 476
17.4　部署分布式实时处理系统 477
17.5　未来之路 478
17.6　本章小结 479
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式实时处理系统：原理、架构与实现
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式操作系统
第1章 分布式系统概述
第2章 分布式系统的通信
第3章 分布式系统的同步
第4章 分布式系统中的进程和处理机
第5章 分布式文件系统
第6章 分布式共享存储器
第7章 实例研究1：Amoeba
第8章 实例研究2：Mach
第9章 实例研究3：Chorus
第10章 实例研究所：DCE
第11章 读物列表与参考书目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式操作系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.NET分布式应用程序
前言
第I部分 关键技术
第

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.NET分布式应用程序
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式数据库架构及企业实践——基于Mycat中间件
第 1 章数据库中间件与分布式数据库的实现 1
1.1 什么是分布式系统  1
1.2 为什么需要分布式数据库  2
1.3 分布式数据库的实现原理  3
1.4 Mycat 数据库中间件简介 5
1.4.1 Mycat 的历史与未来规划 5
1.4.2 Mycat 与其他中间件的区别 8
1.4.3 Mycat 的优势  10
1.4.4 Mycat 的适用场合  11
第 2 章 Mycat 入门  13
2.1 环境搭建 13
2.1.1 Windows 环境搭建  13
2.1.2 Linux 环境搭建  15
2.2 Mycat 核心概念详解 16
2.2.1 逻辑库（schema） 16
2.2.2 逻辑表（table） 16
2.2.3 分片节点（dataNode） 17
2.2.4 节点主机（dataHost）  17
2.3 Mycat 原理介绍  18
2.4 参与 Mycat 源码开发  19
2.4.1 Mycat 源码环境搭建  19
2.4.2 Mycat 源码调试  19
第 3 章 Mycat 进阶  22
3.1 Mycat 配置详解 22
3.1.1 Mycat 支持的两种配置方式 22
3.1.2 server.xml 配置文件 23
3.1.3 schema.xml 配置文件  28
3.1.4 sequence 配置文件 37
3.1.5 zk-create.yaml 配置文件  41
3.1.6 其他配置文件  44
3.2 Mycat 分片规则详解  46
3.2.1 分片表与非分片表  46
3.2.2 ER 关系分片表  46
3.2.3 分片规则 rule.xml 文件详解  46
3.2.4 取模分片  47
3.2.5 枚举分片  48
3.2.6 范围分片  49
3.2.7 范围求模算法  49
3.2.8 固定分片 hash 算法 50
3.2.9 取模范围算法 52
3.2.10 字符串 hash 求模范围算法  53
3.2.11 应用指定的算法  54
3.2.12 字符串 hash 解析算法  54
3.2.13 一致性 hash 算法  55
3.2.14 按日期（天）分片算法  56
3.2.15 按单月小时算法  57
3.2.16 自然月分片算法  58
3.2.17 日期范围 hash 算法  58
3.3 Mycat 管理命令详解 59
3.3.1 Reload 命令 61
3.3.2 Show 命令  62
第 4 章 Mycat 高级技术实战  68
4.1 用 Mycat 搭建读写分离  68
4.1.1 MySQL 读写分离 69
4.1.2 MySQL Galera Cluster 读写分离 73
4.1.3 SQL Server 读写分离  83
4.2 Mycat 故障切换 86
4.2.1 Mycat 主从切换 86
4.2.2 MySQL Galera 节点切换 99
4.3 Mycat+Percona+HAProxy+Keepalived 113
4.3.1 Mycat 113
4.3.2 Percona 集群 124
4.3.3 HAProxy 131
4.3.4 Keepalived 138
4.4 MHA+Keepalived 集群搭建  140
4.4.1 配置 MySQL 半同步方式  142
4.4.2 安装配置 MHA 150
4.4.3 测试重构 153
4.4.4 扩展 Keepalived  155
4.5 用 ZooKeeper 搭建 Mycat 高可用集群 158
4.5.1 ZooKeeper 概述  158
4.5.2 ZooKeeper 的运用场景  161
4.5.3 ZooKeeper 在 Mycat 中的使用 163
4.6 Mycat 高可用配置 165
4.7 Mycat 注解技术  170
4.7.1 balance 注解实战  170
4.7.2 master/slave 注解实战  172
4.7.3 SQL 注解实战 173
4.7.4 schema 注解实战  176
4.7.5 dataNode 注解实战 176
4.7.6 catlet 注解实战  177
第 5 章 Mycat 企业运维 179
5.1 Mycat 性能监控——Mycat-web 详解 179
5.1.1 Mycat-web 简介 179
5.1.2 Mycat-web 的配置和使用 180
5.1.3 Mycat 性能监控指标 181
5.2 Mycat 性能优化 183
5.3 MySQL 优化技术  186
5.3.1 数据库建表设计规范 186
5.3.2 SQL 语句与索引 195
5.3.3 配置文件 206
5.3.4 InnoDB 选择文件系统  212
5.3.5 系统架构  213
第 6 章 Mycat 架构剖析 215
6.1 Mycat 总体架构介绍  215
6.2 Mycat 网络 I/O 架构与实现  218
6.2.1 Mycat I/O 架构概述 218
6.2.2 前端通信框架  221
6.3 Mycat 线程架构与实现  224
6.3.1 多线程基础 224
6.3.2 Mycat 线程架构  226
6.4 Mycat 内存管理及缓存架构与实现  228
6.4.1 Mycat 内存管理  229
6.4.2 Mycat 缓存架构与实现  231
6.5 Mycat 连接池架构与实现 232
6.5.1 Mycat 连接池 232
6.5.2 Mycat 连接池架构及代码实现 234
6.6 Mycat 主从切换架构与实现  235
6.6.1 Mycat 主从切换概述 236
6.6.2 Mycat 主从切换的实现  238
第 7 章 Mycat 核心技术分析  241
7.1 Mycat 分布式事务的实现  241
7.1.1 XA 规范 241
7.1.2 二阶段提交  242
7.1.3 三阶段提交  243
7.1.4 Mycat 中分布式事务的实现 244
7.2 Mycat SQL 路由的实现 249
7.2.1 路由的作用  249
7.2.2 SQL 解析器 250
7.2.3 路由计算  252
7.3 Mycat 跨库 Join 的实现 260
7.3.1 全局表  261
7.3.2 ER 分片  262
7.3.3 catlet 263
7.3.4 ShareJoin  264
7.4 Mycat 数据汇聚和排序的实现 270
7.4.1 数据排序  270
7.4.2 数据汇聚  273
第 8 章 Mycat多数据库支持原理与实现  275
8.1 MySQL 协议在 Mycat 中的实现 275
8.1.1 MySQL 协议概述  275
8.1.2 Mycat 的 MySQL 协议实现 283
8.2 PostgreSQL 协议在 Mycat 中的实现 287
8.2.1 PostgreSQL 介绍  287
8.2.2 PostgreSQL 协议  288
8.2.3 PostgreSQL 实现  293
8.3 Mycat 对 JDBC 支持的实现  298
8.3.1 Oracle 配置  299
8.3.2 SQL Server 配置  300
8.3.3 MongoDB 配置 301
8.3.4 源码分析 306
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式数据库架构及企业实践——基于Mycat中间件
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据
第1章 数据挖掘基本概念　　1
1.1 数据挖掘的定义　　1
1.1.1 统计建模　　1
1.1.2 机器学习　　1
1.1.3 建模的计算方法　　2
1.1.4 数据汇总　　2
1.1.5 特征抽取　　3
1.2 数据挖掘的统计限制　　4
1.2.1 整体情报预警　　4
1.2.2 邦弗朗尼原理　　4
1.2.3 邦弗朗尼原理的一个例子　　5
1.2.4 习题　　6
1.3 相关知识　　6
1.3.1 词语在文档中的重要性　　6
1.3.2 哈希函数　　7
1.3.3 索引　　8
1.3.4 二级存储器　　9
1.3.5 自然对数的底e　　10
1.3.6 幂定律　　11
1.3.7 习题　　12
1.4 本书概要　　13
1.5 小结　　14
1.6 参考文献　　15
第2章 MapReduce及新软件栈　　16
2.1 分布式文件系统　　17
2.1.1 计算节点的物理结构　　17
2.1.2 大规模文件系统的结构　　18
2.2 MapReduce　　19
2.2.1 Map任务　　20
2.2.2 按键分组　　20
2.2.3 Reduce任务　　21
2.2.4 组合器　　21
2.2.5 MapReduce的执行细节　　22
2.2.6 节点失效的处理　　23
2.2.7 习题　　23
2.3 使用MapReduce的算法　　23
2.3.1 基于MapReduce的矩阵—向量乘法实现　　24
2.3.2 向量v无法放入内存时的处理　　 24
2.3.3 关系代数运算　　25
2.3.4 基于MapReduce的选择运算27
2.3.5 基于MapReduce的投影运算27
2.3.6 基于MapReduce的并、交和差运算　　28
2.3.7 基于MapReduce的自然连接运算　　28
2.3.8 基于MapReduce的分组和聚合运算　　29
2.3.9 矩阵乘法　　29
2.3.10 基于单步MapReduce的矩阵乘法　　30
2.3.11 习题　　31
2.4 MapReduce的扩展　　31
2.4.1 工作流系统　　32
2.4.2 MapReduce的递归扩展版本.33
2.4.3 Pregel系统　　35
2.4.4 习题　　35
2.5 通信开销模型　　36
2.5.1 任务网络的通信开销　　36
2.5.2 时钟时间　　37
2.5.3 多路连接　　38
2.5.4 习题　　41
2.6 MapReduce复杂性理论　　41
2.6.1 Reducer规模及复制率　　41
2.6.2 一个例子：相似性连接　　42
2.6.3 MapReduce问题的一个图模型　　 44
2.6.4 映射模式　　45
2.6.5 并非所有输入都存在时的处理　　 46
2.6.6 复制率的下界　　46
2.6.7 案例分析：矩阵乘法　　48
2.6.8 习题　　51
2.7 小结　　51
2.8 参考文献　　53
第3章 相似项发现　　55
3.1 近邻搜索的应用　　55
3.1.1 集合的Jaccard相似度　　55
3.1.2 文档的相似度　　56
3.1.3 协同过滤——一个集合相似问题　　57
3.1.4 习题　　58
3.2 文档的shingling　　58
3.2.1 k-shingle　　58
3.2.2 shingle大小的选择　　59
3.2.3 对shingle进行哈希　　59
3.2.4 基于词的shingle　　60
3.2.5 习题　　60
3.3 保持相似度的集合摘要表示　　61
3.3.1 集合的矩阵表示　　61
3.3.2 最小哈希　　62
3.3.3 最小哈希及Jaccard相似度　　62
3.3.4 最小哈希签名　　63
3.3.5 最小哈希签名的计算　　63
3.3.6 习题　　66
3.4 文档的局部敏感哈希算法　　67
3.4.1 面向最小哈希签名的LSH　　67
3.4.2 行条化策略的分析　　68
3.4.3 上述技术的综合　　69
3.4.4 习题　　70
3.5 距离测度　　70
3.5.1 距离测度的定义　　71
3.5.2 欧氏距离　　71
3.5.3 Jaccard距离　　72
3.5.4 余弦距离　　72
3.5.5 编辑距离　　73
3.5.6 海明距离　　74
3.5.7 习题　　74
3.6 局部敏感函数理论　　75
3.6.1 局部敏感函数　　76
3.6.2 面向Jaccard距离的局部敏感函数族　　77
3.6.3 局部敏感函数族的放大处理.77
3.6.4 习题　　79
3.7 面向其他距离测度的LSH函数族　　80
3.7.1 面向海明距离的LSH函数族　　 80
3.7.2 随机超平面和余弦距离　　80
3.7.3 梗概　　81
3.7.4 面向欧氏距离的LSH函数族　　 82
3.7.5 面向欧氏空间的更多LSH函数族　　83
3.7.6 习题　　83
3.8 LSH 函数的应用　　84
3.8.1 实体关联　　84
3.8.2 一个实体关联的例子　　85
3.8.3 记录匹配的验证　　86
3.8.4 指纹匹配　　87
3.8.5 适用于指纹匹配的LSH函数族　　87
3.8.6 相似新闻报道检测　　88
3.8.7 习题　　89
3.9 面向高相似度的方法　　90
3.9.1 相等项发现　　90
3.9.2 集合的字符串表示方法　　91
3.9.3 基于长度的过滤　　91
3.9.4 前缀索引　　92
3.9.5 位置信息的使用　　93
3.9.6 使用位置和长度信息的索引.94
3.9.7 习题　　96
3.10 小结　　97
3.11 参考文献　　98
第4章 数据流挖掘　　100
4.1 流数据模型　　100
4.1.1 一个数据流管理系统　　100
4.1.2 流数据源的例子　　101
4.1.3 流查询　　102
4.1.4 流处理中的若干问题　　103
4.2 流当中的数据抽样　　103
4.2.1 一个富于启发性的例子　　104
4.2.2 代表性样本的获取　　104
4.2.3 一般的抽样问题　　105
4.2.4 样本规模的变化　　105
4.2.5 习题　　106
4.3 流过滤　　106
4.3.1 一个例子　　106
4.3.2 布隆过滤器　　107
4.3.3 布隆过滤方法的分析　　107
4.3.4 习题　　108
4.4 流中独立元素的数目统计　　109
4.4.1 独立元素计数问题　　109
4.4.2 FM 算法　　109
4.4.3 组合估计　　110
4.4.4 空间需求　　111
4.4.5 习题　　111
4.5 矩估计　　111
4.5.1 矩定义　　111
4.5.2 二阶矩估计的AMS算法　　112
4.5.3 AMS算法有效的原因　　113
4.5.4 更高阶矩的估计　　113
4.5.5 无限流的处理　　114
4.5.6 习题　　115
4.6 窗口内的计数问题　　116
4.6.1 精确计数的开销　　116
4.6.2 DGIM算法　　116
4.6.3 DGIM算法的存储需求　　118
4.6.4 DGIM算法中的查询应答　　118
4.6.5 DGIM条件的保持　　119
4.6.6 降低错误率　　120
4.6.7 窗口内计数问题的扩展　　120
4.6.8 习题　　121
4.7 衰减窗口　　121
4.7.1 最常见元素问题　　121
4.7.2 衰减窗口的定义　　122
4.7.3 最流行元素的发现　　123
4.8 小结　　123
4.9 参考文献　　124
第5章 链接分析　　126
5.1 PageRank　　126
5.1.1 早期的搜索引擎及词项作弊　　 126
5.1.2 PageRank 的定义　　128
5.1.3 Web结构　　130
5.1.4 避免终止点　　132
5.1.5 采集器陷阱及“抽税”法　　134
5.1.6 PageRank 在搜索引擎中的使用　　136
5.1.7 习题　　136
5.2 PageRank的快速计算　　137
5.2.1 转移矩阵的表示　　137
5.2.2 基于MapReduce的PageRank迭代计算　　138
5.2.3 结果向量合并时的组合器使用　　139
5.2.4 转移矩阵中块的表示　　140
5.2.5 其他高效的PageRank迭代方法　　141
5.2.6 习题　　142
5.3 面向主题的PageRank　　142
5.3.1 动机　　142
5.3.2 有偏的随机游走模型　　143
5.3.3 面向主题的PageRank 的使用　　 144
5.3.4 基于词汇的主题推断　　144
5.3.5 习题　　145
5.4 链接作弊　　145
5.4.1 垃圾农场的架构　　145
5.4.2 垃圾农场的分析　　147
5.4.3 与链接作弊的斗争　　147
5.4.4 TrustRank　　148
5.4.5 垃圾质量　　148
5.4.6 习题　　149
5.5 导航页和权威页　　149
5.5.1 HITS的直观意义　　150
5.5.2 导航度和权威度的形式化　　150
5.5.3 习题　　153
5.6 小结　　153
5.7 参考文献　　155
第6章 频繁项集　　157
6.1 购物篮模型　　157
6.1.1 频繁项集的定义　　157
6.1.2 频繁项集的应用　　159
6.1.3 关联规则　　160
6.1.4 高可信度关联规则的发现　　161
6.1.5 习题　　162
6.2 购物篮及A-Priori算法　　163
6.2.1 购物篮数据的表示　　163
6.2.2 项集计数中的内存使用　　164
6.2.3 项集的单调性　　165
6.2.4 二元组计数　　166
6.2.5 A-Priori算法　　166
6.2.6 所有频繁项集上的A-Priori算法　　168
6.2.7 习题　　169
6.3 更大数据集在内存中的处理　　170
6.3.1 PCY算法　　171
6.3.2 多阶段算法　　172
6.3.3 多哈希算法　　174
6.3.4 习题　　175
6.4 有限扫描算法　　177
6.4.1 简单的随机化算法　　177
6.4.2 抽样算法中的错误规避　　178
6.4.3 SON算法　　179
6.4.4 SON算法和MapReduce　　179
6.4.5 Toivonen算法　　180
6.4.6 Toivonen算法的有效性分析　　 181
6.4.7 习题　　181
6.5 流中的频繁项计数　　182
6.5.1 流的抽样方法　　182
6.5.2 衰减窗口中的频繁项集　　183
6.5.3 混合方法　　183
6.5.4 习题　　184
6.6 小结　　184
6.7 参考文献　　186
第7章 聚类　　187
7.1 聚类技术介绍　　187
7.1.1 点、空间和距离　　187
7.1.2 聚类策略　　188
7.1.3 维数灾难　　189
7.1.4 习题　　190
7.2 层次聚类　　190
7.2.1 欧氏空间下的层次聚类　　191
7.2.2 层次聚类算法的效率　　194
7.2.3 控制层次聚类的其他规则　　194
7.2.4 非欧空间下的层次聚类　　196
7.2.5 习题　　197
7.3 k-均值算法　　198
7.3.1 k-均值算法基本知识　　198
7.3.2 k-均值算法的簇初始化　　198
7.3.3 选择正确的k值　　199
7.3.4 BFR算法　　200
7.3.5 BFR算法中的数据处理　　202
7.3.6 习题　　203
7.4 CURE算法　　204
7.4.1 CURE算法的初始化　　205
7.4.2 CURE算法的完成　　206
7.4.3 习题　　206
7.5 非欧空间下的聚类　　207
7.5.1 GRGPF算法中的簇表示　　207
7.5.2 簇表示树的初始化　　207
7.5.3 GRGPF算法中的点加入　　208
7.5.4 簇的分裂及合并　　209
7.5.5 习题　　210
7.6 流聚类及并行化　　210
7.6.1 流计算模型　　210
7.6.2 一个流聚类算法　　211
7.6.3 桶的初始化　　211
7.6.4 桶合并　　211
7.6.5 查询应答　　213
7.6.6 并行环境下的聚类　　213
7.6.7 习题　　214
7.7 小结　　214
7.8 参考文献　　216
第8章 Web广告　　218
8.1 在线广告相关问题　　218
8.1.1 广告机会　　218
8.1.2 直投广告　　219
8.1.3 展示广告的相关问题　　219
8.2 在线算法　　220
8.2.1 在线和离线算法　　220
8.2.2 贪心算法　　221
8.2.3 竞争率　　222
8.2.4 习题　　222
8.3 广告匹配问题　　223
8.3.1 匹配及完美匹配　　223
8.3.2 最大匹配贪心算法　　224
8.3.3 贪心匹配算法的竞争率　　224
8.3.4 习题　　225
8.4 adwords问题　　225
8.4.1 搜索广告的历史　　226
8.4.2 adwords问题的定义　　226
8.4.3 adwords问题的贪心方法　　227
8.4.4 Balance算法　　228
8.4.5 Balance算法竞争率的一个下界　　228
8.4.6 多投标者的Balance算法　　230
8.4.7 一般性的Balance算法　　231
8.4.8 adwords问题的最后论述　　232
8.4.9 习题　　232
8.5 adwords的实现　　232
8.5.1 投标和搜索查询的匹配　　233
8.5.2 更复杂的匹配问题　　233
8.5.3 文档和投标之间的匹配算法　　 234
8.6 小结　　235
8.7 参考文献　　237
第9章 推荐系统　　238
9.1 一个推荐系统的模型　　238
9.1.1 效用矩阵　　238
9.1.2 长尾现象　　239
9.1.3 推荐系统的应用　　241
9.1.4 效用矩阵的填充　　241
9.2 基于内容的推荐　　242
9.2.1 项模型　　242
9.2.2 文档的特征发现　　242
9.2.3 基于Tag的项特征获取　　243
9.2.4 项模型的表示　　244
9.2.5 用户模型　　245
9.2.6 基于内容的项推荐　　246
9.2.7 分类算法　　247
9.2.8 习题　　248
9.3 协同过滤　　249
9.3.1 相似度计算　　249
9.3.2 相似度对偶性　　252
9.3.3 用户聚类和项聚类　　253
9.3.4 习题　　254
9.4 降维处理　　254
9.4.1 UV分解　　255
9.4.2 RMSE　　255
9.4.3 UV分解的增量式计算　　256
9.4.4 对任一元素的优化　　259
9.4.5 一个完整UV 分解算法的构建　　259
9.4.6 习题　　261
9.5 NetFlix竞赛　　262
9.6 小结　　263
9.7 参考文献　　264
第10章 社会网络图挖掘　　265
10.1 将社会网络看成图　　265
10.1.1 社会网络的概念　　265
10.1.2 将社会网络看成图　　266
10.1.3 各种社会网络的例子　　267
10.1.4 多类型节点构成的图　　268
10.1.5 习题　　269
10.2 社会网络图的聚类　　269
10.2.1 社会网络图的距离计算　　269
10.2.2 应用标准的聚类算法　　270
10.2.3 中介度　　271
10.2.4 Girvan-Newman算法　　271
10.2.5 利用中介度来发现社区　　274
10.2.6 习题　　275
10.3 社区的直接发现　　275
10.3.1 团的发现　　276
10.3.2 完全二部图　　276
10.3.3 发现完全二部子图　　277
10.3.4 完全二部子图一定存在的原因　　277
10.3.5 习题　　279
10.4 图划分　　280
10.4.1 图划分的好坏标准　　280
10.4.2 归一化割　　280
10.4.3 描述图的一些矩阵　　281
10.4.4 拉普拉斯矩阵的特征值　　282
10.4.5 其他图划分方法　　284
10.4.6 习题　　284
10.5 重叠社区的发现　　285
10.5.1 社区的本质　　285
10.5.2 极大似然估计　　286
10.5.3 关系图模型　　287
10.5.4 避免成员隶属关系的离散式变化　　288
10.5.5 习题　　290
10.6 Simrank　　290
10.6.1 社会网络上的随机游走者　　 290
10.6.2 带重启的随机游走　　291
10.6.3 习题　　293
10.7 三角形计数问题　　293
10.7.1 为什么要对三角形计数　　294
10.7.2 一个寻找三角形的算法　　294
10.7.3 三角形寻找算法的最优性　　 295
10.7.4 基于MapReduce寻找三角形　　295
10.7.5 使用更少的Reduce任务.297
10.7.6 习题　　297
10.8 图的邻居性质　　298
10.8.1 有向图和邻居　　298
10.8.2 图的直径　　299
10.8.3 传递闭包和可达性　　300
10.8.4 基于MapReduce的传递闭包求解　　301
10.8.5 智能传递闭包　　303
10.8.6 基于图归约的传递闭包　　304
10.8.7 邻居规模的近似计算　　305
10.8.8 习题　　306
10.9 小结　　307
10.10 参考文献　　310
第11章 降维处理　　312
11.1 特征值和特征向量　　312
11.1.1 定义　　312
11.1.2 特征值与特征向量计算　　313
11.1.3 基于幂迭代方法的特征对求解　　315
11.1.4 特征向量矩阵　　317
11.1.5 习题　　317
11.2 主成分分析　　318
11.2.1 一个示例　　318
11.2.2 利用特征向量进行降维　　321
11.2.3 距离矩阵　　322
11.2.4 习题　　323
11.3 奇异值分解　　323
11.3.1 SVD的定义　　323
11.3.2 SVD解析　　325
11.3.3 基于SVD的降维　　326
11.3.4 将较低奇异值置为0后有效的原因　　327
11.3.5 使用概念进行查询处理　　328
11.3.6 矩阵SVD的计算　　329
11.3.7 习题　　330
11.4 CUR 分解　　331
11.4.1 CUR 的定义　　331
11.4.2 合理选择行和列　　332
11.4.3 构建中间矩阵　　333
11.4.4 完整的CUR 分解　　334
11.4.5 去除重复行和列　　335
11.4.6 习题　　335
11.5 小结　　336
11.6 参考文献　　337
第12章 大规模机器学习　　338
12.1 机器学习模型　　338
12.1.1 训练集　　338
12.1.2 一些例子　　339
12.1.3 机器学习方法　　341
12.1.4 机器学习架构　　342
12.1.5 习题　　344
12.2 感知机　　344
12.2.1 训练阈值为0 的感知机　　344
12.2.2 感知机的收敛性　　347
12.2.3 Winnow算法　　347
12.2.4 允许阈值变化的情况　　349
12.2.5 多类感知机　　350
12.2.6 变换训练集　　351
12.2.7 感知机的问题　　351
12.2.8 感知机的并行实现　　353
12.2.9 习题　　354
12.3 支持向量机　　354
12.3.1 支持向量机的构成　　354
12.3.2 超平面归一化　　356
12.3.3 寻找最优逼近分界面　　357
12.3.4 基于梯度下降法求解SVM　　 359
12.3.5 随机梯度下降　　363
12.3.6 SVM的并行实现　　363
12.3.7 习题　　363
12.4 近邻学习　　364
12.4.1 近邻计算的框架　　364
12.4.2 最近邻学习　　365
12.4.3 学习一维函数　　365
12.4.4 核回归　　367
12.4.5 处理高维欧氏空间数据　　368
12.4.6 对非欧距离的处理　　369
12.4.7 习题　　369
12.5 各种学习方法的比较　　370
12.6 小结　　371
12.7 参考文献　　372
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构探险：从零开始写分布式服务框架
第1章  常用的RPC框架	1
1.1  RPC框架原理	1
1.2  RMI介绍	2
1.2.1  原生RMI代码示例	3
1.2.2  RMI穿透防火墙	5
1.3  CXF/Axis2介绍	7
1.3.1  CXF介绍	7
1.3.2  Axis2介绍	14
1.4  Thrift介绍	21
1.4.1  Thrift工作原理介绍	23
1.4.2  Thrift IDL语法说明	26
1.4.3  基于Apache Thrift的Java版完整案例	28
1.4.4  基于Java注解的简化实现	36
1.5  gRPC介绍	42
1.5.1  protobuf3语法介绍	43
1.5.2  gRPC使用示例	45
1.6  HTTP Client介绍	53
1.6.1  构建HttpClient对象	54
1.6.2  构建URI对象	55
1.6.3  构建请求对象（HttpGet、HttpPost）	56
1.6.4  HttpClient发起调用及获取调用返回结果	56
1.7  实现自己的RPC框架	61
1.8  RPC框架与分布式服务框架的区别	68
1.9  本章小结	68
第2章  分布式服务框架总体架构与功能	69
2.1  面向服务的体系架构（SOA）	69
2.1.1  面向服务架构范式	69
2.1.2  服务拆分原则	71
2.2  分布式服务框架现实需求	72
2.3  分布式服务框架总体架构及所需的技术概述	72
2.4  本章小结	74
第3章  分布式服务框架序列化与反序列化实现	75
3.1  序列化原理及常用的序列化介绍	75
3.2  Java默认的序列化	77
3.3  XML序列化框架介绍	80
3.4  JSON序列化框架介绍	82
3.5  Hessian序列化框架介绍	87
3.6  protobuf序列化框架介绍	88
3.7  protostuff序列化框架介绍	93
3.8  Thrift序列化框架介绍	98
3.9  Avro序列化框架介绍	100
3.9.1  Avro介绍	100
3.9.2  Avro IDL语言介绍	101
3.9.3  Schema定义介绍	103
3.9.4  Maven配置及使用IDL与Schema自动生成代码	103
3.9.5  Avro序列化/反序列化实现	105
3.10  JBoss Marshalling序列化框架介绍	110
3.11  序列化框架的选型	112
3.12  实现自己的序列化工具引擎	113
3.13  本章小结	118
第4章  实现分布式服务框架服务的发布与引入	119
4.1  Spring Framework框架概述	119
4.1.1  Spring Framework介绍	119
4.1.2  Spring Framework周边生态项目介绍	121
4.2  FactoryBean的秘密	122
4.2.1  FactoryBean的作用及使用场景	123
4.2.2  FactoryBean实现原理及示例说明	124
4.3  Spring框架对于已有RPC框架集成的支持	127
4.3.1  Spring支持集成RPC框架介绍	127
4.3.2  基于RmiProxyFactoryBean 实现RMI与Spring的集成	128
4.3.3  基于HttpInvokerProxyFactoryBean实现HTTP Invoker与Spring的集成	131
4.3.4  基于HessianProxyFactoryBean实现Hessian与Spring的集成	133
4.4  实现自定义服务框架与Spring的集成	136
4.4.1  实现远程服务的发布	136
4.4.2  实现远程服务的引入	144
4.5  在Spring中定制自己的XML标签	150
4.6  本章小结	158
第5章  分布式服务框架注册中心	159
5.1  服务注册中心介绍	159
5.2  ZooKeeper实现服务的注册中心原理	161
5.2.1  ZooKeeper介绍	161
5.2.2  部署ZooKeeper	161
5.2.3  ZkClient使用介绍	164
5.2.4  ZooKeeper实现服务注册中心	173
5.3  集成ZooKeeper实现自己的服务注册与发现	175
5.3.1  服务注册中心服务提供方	175
5.3.2  服务注册中心服务消费方	176
5.3.3  服务注册中心实现	178
5.4  本章小结	189
第6章  分布式服务框架底层通信实现	190
6.1  Java I/O模型及I/O类库的进化	190
6.1.1  Linux下实现的I/O模型	190
6.1.2  Java语言实现的I/O模型	194
6.1.3  Java Classic I/O（Blocking I/O）介绍	194
6.1.4  Java Non-blocking I/O（NIO）介绍	211
6.1.5  NIO2及Asynchronous I/O介绍	233
6.2  Netty使用介绍	255
6.2.1  Netty开发入门	256
6.2.2  Netty粘包/半包问题解决	265
6.3  使用Netty构建服务框架底层通信	320
6.3.1  构建分布式服务框架Netty服务端	320
6.3.2  构建分布式服务框架服务调用端Netty客户端	330
6.4  本章小结	347
第7章  分布式服务框架软负载实现	348
7.1  软负载的实现原理	348
7.2  负载均衡常用算法	349
7.2.1  软负载随机算法实现	349
7.2.2  软负载加权随机算法实现	350
7.2.3  软负载轮询算法实现	351
7.2.4  软负载加权轮询算法实现	352
7.2.5  软负载源地址hash算法实现	354
7.3  实现自己的软负载机制	355
7.4  软负载在分布式服务框架中的应用	357
7.5  本章小结	361
第8章  分布式服务框架服务治理	362
8.1  服务治理介绍	362
8.2  服务治理的简单实现	364
8.2.1  服务分组路由实现	364
8.2.2  简单服务依赖关系分析实现	374
8.2.3  服务调用链路跟踪实现原理	380
8.3  本章小结	380
附录A  如何配置运行本书完成的分布式服务框架	381
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构探险：从零开始写分布式服务框架
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式发电与微电网技术
第1章　从分布式发电到微电网　1　1.1　分布式发电　1　　1.1.1　分布式发电的概念　1　　1.1.2　分布式发电技术　2　　1.1.3　分布式发电并网技术　3　　1.1.4　分布式发电的研究与发展　4　1.2　微电网　5　　1.2.1　微电网的概念　5　　1.2.2　微电网技术　6　　1.2.3　微电网的研究与发展　7第一部分　分布式发电第2章　典型分布式电源　11　2.1　概述　11　2.2　太阳能光伏发电　11　　2.2.1　光伏发电基本原理　11　　2.2.2　光伏电池数学模型　12　　2.2.3　光伏发电功率特性　15　　2.2.4　光伏发电运行失配现象及机理　17　2.3　风力发电　21　　2.3.1　风力发电基本原理　21　　2.3.2　风力发电机分类　22　　2.3.3　感应发电机型风电机组　23　　2.3.4　双馈恒频型风电机组　25　　2.3.5　直驱型风电机组　30　2.4　燃料电池发电　34　　2.4.1　燃料电池发电基本原理　34　　2.4.2　PEMFC数学模型　38　　2.4.3　PEMFC运行特性　40　2.5　微型燃气轮机发电　40　　2.5.1　微型燃气轮机发电系统　41　　2.5.2　微型燃气轮机动态数学模型　44　　2.5.3　微型燃气轮机运行特性　45　　2.5.4　不同结构MT运行特点比较　46第3章　分布式电源并网及控制　48　3.1　概述　48　3.2　光伏发电并网及控制　48　　3.2.1　并网系统描述　48　　3.2.2　并网方式　49　　3.2.3　并网控制策略　52　　3.3　风力发电并网及控制　54　3.3.1　并网方式　54　　3.3.2　控制系统　61　3.4　燃料电池发电并网及控制　70　　3.4.1　并网系统结构　71　　3.4.2　并网控制策略　72　3.5　微型燃气轮机发电并网及控制　74　　3.5.1　并网系统结构　74　　3.5.2　系统建模　74　　3.5.3　控制方式　76第4章　含分布式发电的配电网潮流计算　78　4.1　概述　78　4.2　传统配电网数学模型　78　4.3　传统配电网潮流计算方法　79　　4.3.1　牛顿类潮流计算方法　79　　4.3.2　母线类潮流计算方法　80　　4.3.3　支路类潮流计算方法　81　　4.3.4　3类潮流算法的比较　83　4.4　分布式电源在潮流计算中的节点处理方法　84　4.5　含分布式发电的配电网潮流计算方法　87　4.6　算例分析　88第5章　分布式电源在配电网中的优化配置　93　5.1　概述　93　5.2　分布式电源的选址和定容　94　　5.2.1　目标函数　94　　5.2.2　约束条件　95　5.3　基于图示的优化配置方法　95　　5.3.1　功率分布　95　　5.3.2　馈线电压分布　97　　5.3.3　目标函数与约束条件　99　5.4　基于“功率圆”的优化配置方法　101　　5.4.1　假设条件与目标函数　101　　5.4.2　功率圆　102　　5.4.3　DG最佳接入位置　103　　5.4.4　算例分析　106第二部分　微电网第6章　微电网概况　112　6.1　概述　112　　6.1.1　微电网产生的背景　112　　6.1.2　微电网的定义　112　　6.1.3　微电网的典型结构　113　　6.1.4　微电网的特点　114　　6.1.5　储能技术　116　6.2　国内外发展现状　118　　6.2.1　国外微电网的发展现状　118　　6.2.2　国内微电网的发展形势　122第7章　微电网管理与控制　125　7.1　微源接口类型　125　7.2　微电网基本控制策略　127　　7.2.1　微电网控制的特殊性　127　　7.2.2　主从控制法　129　　7.2.3　对等控制法　129　7.3　典型主从控制法介绍　131　　7.3.1　微电源控制器　131　　7.3.2　中央控制器　135第8章　孤岛型微电网　143　8.1　孤岛效应　143　8.2　孤岛检测的基本问题　144　　8.2.1　注意事项　144　　8.2.2　检测标准　144　　8.2.3　测试电路　145　　8.2.4　基本原理　145　　8.2.5　检测盲区　147　8.3　孤岛检测方法　148　　8.3.1　基于通信的孤岛检测方法　148　　8.3.2　基于同步发电机的本地孤岛检测方法　149　　8.3.3　基于逆变器的本地孤岛检测方法　150　　8.3.4　各种孤岛检测方法的比较　156第9章　市场环境下的微电网　157　9.1　微电网参与市场　157　9.2　竞价流程　158　9.3　MCP规则　158　9.4　MCP理论　158　　9.4.1　单边竞价市场　159　　9.4.2　双边竞价市场　160　9.5　案例分析　160　　9.5.1　需求恒定时的线性供给竞价　161　　9.5.2　需求线性变化时的线性供给竞价　162　9.6　对电力市场的影响　164附录1　分布式发电IEEE1547技术标准主要内容(中英文对照)　165附录2　其他分布式发电相关技术标准　178参考文献　182
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式发电与微电网技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云系统管理
第一章 分布式世界中的设计
第二章 为运营而设计
第三章 选择服务平台
第四章 应用程序框架
第五章 伸缩性设计模式
第六章·弹性设计模式
第七章 分布式世界中的运营
第八章 DevOps文化
第九章 服务交付：构建阶段
第十章 服务交付：部署阶段
第十一章 升级运行中的服务
第十二章 自动化
第十三章 设计文档
第十四章 随时待命
第十五章 灾难准备
第十六章 监控基础知识
第十七章 监控架构与实践
第十八章 容量规划
第十九章 建立KPI
第二十章 卓越运营
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云系统管理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>用Mesos框架构建分布式应用
序  ix
第1 章 Mesos 介绍 1
如何使用Mesos2
Mesos 作为部署系统 3
Mesos 作为执行平台 4
本书是如何组织的4
本章小结 5
第2 章 开启Mesos 之旅 7
框架7
Master 和Slave 8
Master8
Slave 10
资源13
配置自定义资源 15
配置slave 属性16
角色16
静态和动态slave 预留 17
任务和执行器 20
CommandExecutor 21
理解mesos.proto 21
不通过Mesos 管理 24
本章小结 25
第3 章 将已有应用程序迁移到Mesos 上27
将Web 应用程序迁移到Mesos 上27
搭建Marathon 28
使用Marathon 30
扩展应用程序 35
使用位置约束 35
运行容器化的应用程序37
挂载主机卷38
健康检查40
应用版本化和滚动升级42
事件总线43
搭建Marathon 上的HAProxy43
在Marathon 上运行Mesos 框架 47
Chronos 是什么47
在Marathon 上运行Chronos48
Chronos 运维注意事项 49
Marathon 上的Chronos ：小结 50
Marathon+Chronos 的备选方案50
Singularity50
Aurora51
本章小结 51
第4 章 为Mesos 创建新的框架53
调度器 53
服务器池调度器 54
工作队列调度器 54
作业处理器调度器 55
没什么用的远程BASH 56
实现基本的作业处理器 62
将任务匹配到Offer 上65
搭建Offers 和Jobs 之间语义差别的桥梁68
增加高可用性 70
添加核对 76
高级调度器技术77
分布式通信78
强制故障转移 79
合并Offer79
加固调度器80
检查点82
CommandInfo 83
启动进程83
配置进程环境 83
本章小结 84
第5 章 构建Mesos 执行器85
执行器 85
构建工作队列worker 86
运行pickled 任务 86
共享资源86
更好地看护87
增强的日志88
重写CommandExecutor88
引导执行器的安装97
添加心跳 99
高级执行器特性 102
进度报告 103
添加远程日志  104
多个任务 104
本章小结  106
第6 章 Mesos 的进阶主题 107
libprocess 和actor 模型  107
一致性模型  108
如何处理slave 的故障  109
如何处理master（或者registry）的故障 110
故障转移期间的核对 111
容器机  112
使用Docker. 113
新的Offer API 114
框架动态预留API 114
数据库使用的持久化卷 118
本章小结  119
第7 章 Mesos 的未来121
多租户工作负载 121
超配 123
数据库和Turnkey 基础架构  125
基于容器的IP  125
本章小结  126
索引 129
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>用Mesos框架构建分布式应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式系统应用设计
前言1
第1章 概述7
系统开发简介7
软件开发中的模式简介8
模式，实践和组件的价值10
小结12
第Ⅰ部分 单节点模式
第2章 边车模式17
一个边车模式的例子：为遗留系统增加HTTPS 功能18
基于边车模式的动态配置19
模块化应用容器20
使用边车模式构建一个简单的PaaS22
基于边车模式的模块化和可重用性设计23
小结27
第3章 大使模式28
使用大使模式来做服务分片29
使用大使模式实现服务代理33
使用大使模式做请求验证或拆分33
第4章 适配器37
监控38
日志40
第Ⅱ部分 服务模式
第5章 基于副本的负载均衡51
无状态服务51
会话跟踪服务55
应用层复制服务56
缓存层介绍56
扩展缓存层60
小结64
第6章 分片服务65
缓存分片66
深入了解分片函数73
支持副本的分配服务77
热分片系统77
第7章 分散模式与聚集模式79
在根节点上进行分散/聚集80
叶子分片82
第8章 函数与事件驱动处理87
何时采用FaaS87
FaaS的模式91
第9章 所有权选举98
是否需要主副本选举99
主副本选举概要101
处理并发操作109
第Ⅲ部分 批处理计算模式
第10章 工作队列系统115
通用工作队列系统115
实践：实现视频缩略图器122
动态扩展执行器123
多执行器模式125
第11章 事件驱动的批处理127
事件驱动批处理模式128
实践：为新用户注册构建事件驱动流程134
发布者/订阅者基础结构136
实践：部署Kafka137
第12章 协调批处理140
连接（或栏栅同步）140
Reduce142
实践：图像标记和处理流水线145
第13章 结论：一个新的开始149
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式系统应用设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>发布！设计与部署稳定的分布式系统（第2版）
第 1 章　生产环境的生存法则	阅读
第一部分　创造稳定性
第 2 章　案例研究：让航空公司停飞的代码异常
第 3 章　让系统稳定运行
第 4 章　稳定性的反模式
第 5 章　稳定性的模式
第二部分　为生产环境而设计
第 6 章　案例研究：屋漏偏逢连夜雨
第 7 章　基础层
第 8 章　实例层
第 9 章　互连层
第 10 章　控制层
第 11 章　安全性
第三部分　将系统交付
第 12 章　案例研究：等待戈多
第 13 章　为部署而设计
第 14 章　处理版本问题
第四部分　解决系统性问题
第 15 章　案例研究：不能承受的巨大顾客流量
第 16 章　适应性
第 17 章　混沌工程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>发布！设计与部署稳定的分布式系统（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据技术丛书
前言
作者简介
第1章 分布式单词计数
1.1 Storm topology的组成部分——stream、spout和bolt
1.1.1 Storm
1.1.2 spout
1.1.3 bolt
1.2 单词计数topology的数据流
1.2.1 语句生成bolt
1.2.2 语句分割bolt
1.2.3 单词计割bolt
1.2.4 上报bolt
1.3 实现单词计数top
1.3.1 配置开发环境
1.3.2 实现Sentence
1.3.3 实现语句分割bolt
1.3.4 实现单词计割bolt
1.3.5 实现上报bolt
1.3.6 实现单词计数topo
1.4 Storm的并发机制
1.4.1 WordCountTopology的并发机制
1.4.2 给topology增加woker
1.4.3 配置executor和task
1.5 理解数据流分组
1.6 有保障机制的数据处理
1.6.1 spout的可靠性
1.6.2 bolt的可靠性
1.6.3 可靠的单词计数
总结
第2章 配置Storm集群
2.1 Storm集群的框架
2.1.1 理解nimbus守护进程
2.1.2 supervisor守护进程的工作方式
2.1.3 Apache ZooKeeper简介
……
第3章 Trident和传感器数据
第4章 实时趋势分析
第5章 实时图形分析
第6章 人工智能
第7章 整合Druid进行金融分析
第8章 自然语言处理
第9章 在Hadoop上部署Storm进行广告分析
第10章 云环境下的S
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据技术丛书
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Mesos：大数据资源调度与大规模容器运行最佳实践
目录
前言 xiv
第1章运行Mesos 1
1.1 现代数据中心 1
1.2 集群计算框架 2
1.3 Mesos简介 2
1.3.1 master 3
1.3.2 slave 4
1.3.3 框架 4
1.4 为什么使用Mesos 4
1.5 单节点Mesos集群 5
1.5.1 Mac OS 5
1.5.2 Fedora 6
1.5.3 安装依赖软件包 6
1.5.4 构建Mesos 8
1.5.5 启动Mesos 10
1.6 运行测试框架 11
1.7 Mesos Web UI 15
1.8 多节点Mesos集群 15
1.9 Amazon EC2 上的Mesos集群 16
1.10 使用 Vagrant 运行Mesos 18
1.11 Mesos社区 19
1.11.1 案例研究 19
1.11.2 邮件列表 20
1.12小结 20
第 2 章在Mesos上运行 Hadoop 21
2.1 Hadoop 介绍 21
2.2 Mesos上的 Hadoop 22
2.3 在Mesos上安装 Hadoop 23
2.4 Hadoop 作业示例 26
2.5 Mesos上 Hadoop 的高级配置 27
2.5.1 任务资源分配 27
2.5.2 度量报告 29
2.5.3 认证 32
2.5.4 容器隔离 33
2.5.5 其他配置参数 33
2.6 小结 34
第 3 章在Mesos上运行 Spark 35
3.1 Spark 介绍 35
3.2 Spark 作业调度 36
3.3 Spark Standalone模式 38
3.4 在Mesos上的 Spark 40
3.5 在Mesos上 Spark 的调优 41
3.6 小结 43
第 4 章Mesos上的复杂数据分析44
4.1 复杂数据和 Lambda 架构的兴起 44
4.2 Storm 46
4.2.1 Mesos上的 Storm 47
4.2.2 Storm-Mesos配置 49
4.3 Spark Streaming 50
4.3.1 在Mesos上运行 Spark Streaming 52
4.3.2 Spark Streaming 调优 53
4.4 Mesos上的 NoSQL 55
4.4.1 Mesos上的 Cassandra 55
4.5 小结 57
第 5 章在Mesos上运行服务 59
5.1 服务的介绍 59
5.2 Marathon 60
5.2.1 Marathon API 61
5.2.2运行 Marathon 62
5.2.3 Marathon 样例 63
5.2.4约束条件 65
5.2.5事件总线 66
5.2.6 artifact store 66
5.2.7应用组 66
5.2.8应用程序健康检查 67
5.3 Chronos 68
5.3.1 Chronos REST API 68
5.3.2运行Chronos 70
5.3.3 Chronos样例 71
5.4 Aurora 71
5.4.1 作业的生命周期 73
5.4.2运行 Aurora 74
5.4.3 Aurora 集群配置 75
5.4.4 Aurora 作业配置 76
5.4.5 Aurora 客户端 80
5.4.6 Aurora 样例 82
5.4.7 Aurora cron作业 83
5.5 服务发现 83
5.5.1 Mesos-DNS 83
5.5.2安装Mesos-DNS 84
5.5.3 Mesos-DNS 配置 85
5.5.4运行Mesos-DNS 86
5.6 打包 87
5.7 小结 87
第 6 章理解Mesos内部机制 88
6.1Mesos架构 88
6.1.1 Mesos slave 90
6.1.2 Mesos master 91
6.1.3框架 92
6.1.4通信 92
6.1.5附属服务 93
6.2 资源分配 94
6.2.1 Mesos调度器 95
6.2.2 加权 DRF 96
6.2.3 资源预留 97
6.3 资源隔离 101
6.3.1 Mesos容器机 102
6.3.2 Docker 容器机 103
6.3.3 外部容器机 105
6.4 容错 107
6.4.1 ZooKeeper 108
6.4.2 故障检测及处理 109
6.4.3 Registry 111
6.5 扩展Mesos 112
6.5.1 Mesos模块 112
6.5.2分配模块 116
6.5.3 Mesos hook 和修饰器 119
6.5.4任务标签 119
6.6 小结 119
第 7 章开发Mesos框架 120
7.1 Mesos API 120
7.1.1 Mesos消息 121
7.1.2调度器 API 122
7.1.3调度器驱动 API 124
7.1.4执行器 API 125
7.1.5调度器驱动 API 126
7.2 开发一个Mesos框架 127
7.2.1 搭建开发环境 127
7.2.2加入框架调度器 128
7.2.3加入框架启动器 130
7.2.4部署框架 131
7.3 构建框架 133
7.3.1 给框架加入执行器 137
7.3.2 更新框架调度器 141
7.3.3 运行多个执行器 144
7.4 高级主题 147
7.4.1 一致性调解 147
7.4.2 有状态应用 148
7.5 开发者资料 148
7.5.1 框架设计模式 149
7.5.2 框架测试 149
7.5.3 RENDLER 149
7.5.4 Akka-mesos 150
7.6 小结 150
第 8 章管理Mesos 151
8.1 部署 151
8.2 升级 152
8.3 监控 153
8.3.1 容器网络监控 153
8.4 多租户 155
8.4.1 授权和鉴权 155
8.4.2 API 速率限制 158
8.5 高可用 160
8.5.1 master 高可用 160
8.5.2 限制 slave 移除速率 162
8.5.3 slave 恢复 162
8.6 维护状态 163
8.7 Mesos接口 165
8.7.1 Mesos REST 接口 165
8.7.2 Mesos CLI 167
8.8配置 170
8.8.1 Mesos master 171
8.8.2 Mesos slave 174
8.8.3 Mesos构建选项 179
小结 181
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Mesos：大数据资源调度与大规模容器运行最佳实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式数据库系统原理与应用
前言
教学建议
第1章 分布式数据库系统概述
1.1 引言及准备知识
1.1.1 相关基本概念
1.1.2 相关基础知识
1.2 分布式数据库系统的基本概念
1.2.1 节点/场地
1.2.2 分布式数据库
1.2.3 分布式数据库管理系统
1.2.4 分布式数据库系统应用举例
1.2.5 分布式数据库的特性
1.3 分布式数据库系统的作用和特点
1.3.1 分布式数据库系统的作用
1.3.2 分布式数据库系统的特点
1.4 典型的分布式数据库原型系统简介
1.5 分布式数据库系统中的关键技术
1.6 本章小结
习题
第2章 分布式数据库系统的结构
2.1 DDBS的物理结构和逻辑结构
2.2 DDBS的体系结构
2.2.1 基于客户端/服务器结构的体系结构
2.2.2 基于“中间件”的客户端/服务器结构
2.3 DDBS的模式结构
2.4 DDBS的组件结构
2.4.1 应用处理器功能
2.4.2 数据处理器功能
2.5 多数据库集成系统
2.5.1 数据库集成
2.5.2 多数据库系统
2.6 对等型数据库系统
2.6.1 P2PDBS的数据集成体系结构
2.6.2 P2PDBS的体系结构
2.6.3 P2PDBS与DDBS的典型区别
2.7 DDBS的分类
2.7.1 非集中式数据库系统及P2PDBS的特性
2.7.2 DDBS的分类图
2.8 元数据的管理
2.8.1 数据字典的主要内容
2.8.2 数据字典的主要用途
2.8.3 数据字典的组织
2.9 Oracle系统体系结构
2.9.1 Oracle系统体系结构简介
2.9.2 Oracle中实现分布式功能的关键组件
2.9.3 Oracle分布式数据库架构
2.10 本章小结
习题
第3章 分布式数据库设计
3.1 设计策略
3.1.1 TopDown设计过程
3.1.2 BottomUp设计过程
3.2 分片的定义及作用
3.2.1 分片的定义
3.2.2 分片的作用
3.2.3 分片设计过程
3.2.4 分片的原则
3.2.5 分片的种类
3.2.6 分布透明性
3.3 水平分片
3.3.1 水平分片的定义
3.3.2 水平分片的操作
3.3.3 水平分片的设计
3.3.4 水平分片的正确性判断
3.4 垂直分片
3.4.1 垂直分片的定义
3.4.2 垂直分片的操作
3.4.3 垂直分片的设计
3.4.4 垂直分片的正确性判断
3.5 混合分片
3.6 分片的表示方法
3.6.1 图形表示法
3.6.2 分片树表示法
3.7 分配设计
3.7.1 分配类型
3.7.2 分配设计原则
3.7.3 分配模型
3.8 数据复制技术
3.8.1 数据复制的优势
3.8.2 数据复制的分类
3.8.3 数据复制的常用方法
3.9 Oracle数据分布式设计案例
3.9.1 Oracle分布式数据库的水平分片
3.9.2 Oracle分布式数据库的垂直分片
3.9.3 Oracle集中式数据库的数据分区技术
3.10 本章小结
习题
第4章 分布式查询处理与优化
4.1 查询处理基础
4.1.1 查询处理目标
4.1.2 查询优化的意义
4.1.3 查询优化的基本概念
4.1.4 查询优化的过程
4.2 查询处理器
4.2.1 查询处理器的特性
4.2.2 查询处理层次
4.3 查询分解
4.3.1 查询规范化
4.3.2 查询分析
4.3.3 查询约简
4.3.4 查询重写
4.4 数据局部化
4.5 片段查询的优化
4.6 Oracle分布式查询处理与优化案例
4.7 本章小结
习题
第5章 分布式查询的存取优化
5.1 分布式查询的基本概念
5.1.1 分布式查询的执行与处理
5.1.2 查询存取优化的内容
5.2 存取优化的理论基础
5.2.1 查询代价模型
5.2.2 数据库的特征参数
5.2.3 关系运算的特征参数
5.3 基于半连接的优化方法
5.3.1 半连接操作及相关规则
5.3.2 半连接运算的作用
5.3.3 使用半连接算法的通信代价估计
5.3.4 半连接算法优化原理
5.4 基于枚举法的优化技术
5.4.1 嵌套循环连接算法
5.4.2 基于排序的连接算法
5.4.3 散列连接算法
5.4.4 连接关系的传输方法
5.5 集中式系统中的查询优化算法
5.5.1 INGRES
5.5.2 System R 方法
5.5.3 考虑代价的动态规划方法
5.5.4 PostgreSQL的遗传算法
5.6 分布式系统中的查询优化算法
5.6.1 Distributed INGRES方法
5.6.2 System R*方法
5.6.3 SDD-1方法
5.7 Oracle分布式查询优化案例
5.8 本章小结
习题
第6章 分布式事务管理
6.1 事务的基本概念
6.1.1 事务的定义
6.1.2 事务的基本性质
6.1.3 事务的种类
6.2 分布式事务
6.2.1 分布式事务的定义
6.2.2 分布式事务的实现模型
6.2.3 分布式事务管理的目标
6.3 分布式事务的提交协议
6.3.1 协调者和参与者
6.3.2 两段提交协议的基本思想
6.3.3 两段提交协议的基本流程
6.4 分布式事务管理的实现
6.4.1 LTM与DTM
6.4.2 分布式事务执行的控制模型
6.4.3 分布式事务管理的实现模型
6.5 两段提交协议（2PC）的实现方法
6.5.1 集中式方法
6.5.2 分布式的2PC
6.5.3 分层式方法
6.5.4 线性方法
6.6 非阻塞分布式事务提交协议
6.6.1 三段提交协议的基本思想
6.6.2 三段提交协议执行的基本流程
6.7 Oracle分布式事务管理案例
6.8 本章小结
习题
第7章 分布式恢复管理
7.1 分布式恢复概述
7.1.1 故障类型
7.1.2 恢复模型
7.2 集中式数据库的故障恢复
7.2.1 局部恢复系统的体系结构
7.2.2 数据更新策略
7.2.3 针对不同更新事务的恢复方法
7.3 分布式事务的故障恢复
7.3.1 两段提交协议对故障的恢复
7.3.2 三段提交协议对故障的恢复
7.4 分布式可靠性协议
7.4.1 可靠性和可用性
7.4.2 分布式可靠性协议的组成
7.4.3 两段提交协议的终结协议
7.4.4 两段提交协议的演变
7.4.5 三段提交协议的终结协议
7.4.6 三段提交协议的演变
7.5 Oracle故障恢复案例
7.6 本章小结
习题
第8章 分布式并发控制
8.1 分布式并发控制的基本概念
8.1.1 并发控制问题
8.1.2 并发控制定义
8.2 并发控制理论基础
8.2.1 事务执行过程的形式化描述
8.2.2 集中式数据库的可串行化问题
8.2.3 分布式事务的可串行化问题
8.3 基于锁的并发控制方法
8.3.1 锁的类型和相容性
8.3.2 封锁规则
8.3.3 锁的粒度
8.4 两段封锁协议（2PL）
8.4.1 基本的两段封锁协议
8.4.2 严格的两段封锁协议（2PL）
8.4.3 可串行化证明
8.5 分布式数据库并发控制方法
8.5.1 基于锁的并发控制方法的实现
8.5.2 基于时间戳的并发控制算法
8.5.3 乐观的并发控制算法
8.6 分布式死锁管理
8.6.1 死锁等待图
8.6.2 死锁的检测
8.6.3 死锁的预防和避免
8.7 Oracle并发控制案例
8.7.1 Oracle中的锁机制
8.7.2 Oracle中的并发控制
8.8 本章小结
习题
第9章 P2P数据管理系统
9.1 P2P系统概述
9.2 P2P系统的体系结构
9.2.1 集中式P2P网络
9.2.2 全分布式P2P网络
9.2.3 混合型的P2P网络
9.3 P2P系统中的数据管理
9.4 资源的定位和路由
9.4.1 面向非结构化P2P网络的资源定位方法
9.4.2 面向结构化P2P网络的资源定位方法
9.5 处理语义异构性
9.6 查询处理与优化
9.6.1 查询处理
9.6.2 查询优化
9.7 本章小结
习题
第10章 Web数据库集成系统
10.1 Web数据库集成系统概述
10.2 三种体系结构介绍
10.2.1 数据供应模式
10.2.2 数据收集模式
10.2.3 元搜索模式
10.3 基于元搜索模式的Web数据库集成系统WDBIntegrator
10.3.1 系统总体结构
10.3.2 Web数据库资源搜索子系统
10.3.3 资源查询子系统
10.4 本章小结
习题
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式数据库系统原理与应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式处理实践
第1章 什么是分布式处理 1
1.1 概述 1
1.2 计算和网络的发展 2
1.3 分布式处理 2
1.4 应用领域 3
1.5 模型 3
1.6 移动代码 4
1.7 分布式系统面临的挑战 4
1.8 本章小结 5
练习题 6
第2章 并发的概念 7
2.1 概述 7
2.2 并发中的有关结构 8
2.3 命名和寻址 8
2.3.1 名称和地址示例 9
2.3.2 地址映射机制 9
2.4 共享与同步 11
2.4.1 资源分配 11
2.4.2 示例: 文件同步 12
2.5 低级同步 12
2.5.1 竞争条件 13
2.5.2 互斥 13
2.5.3 信号量 13
2.5.4 管程 16
2.5.5 会合18分布式处理实践目录
2.6 定时和实时系统 18
2.7 可靠性 19
2.7.1 故障和失效的类型 19
2.7.2 对故障的响应 20
2.8 服务器类型 20
2.9 簇、负载平衡和网格 21
2.10 本章小结 22
练习题 22
第3章 并发模型 24
3.1 概述 24
3.2 状态机和自动机 24
3.3 SPIN和Promela 25
3.4 进程代数 26
3.4.1 通信顺序进程 27
3.4.2 π演算和灵活性 28
3.5 Linda 30
3.5.1 JavaSpaces 31
3.6 再谈死锁 33
3.7 本章小结 34
练习题 35
第4章 操作系统中的并发 37
4.1 概述 37
4.2 为什么使用操作系统 37
4.3 进程和线程 38
4.3.1 进程概念 39
4.3.2 CPU中的用户模式和管理员模式 39
4.3.3 多任务 40
4.3.4 线程和轻量级进程 40
4.4 Linux中的进程和线程示例 41
4.4.1 Fork 41
4.4.2 Pthreads 43
4.5 Ada中的任务处理 45
4.6 本章小结 47
练习题 47
第5章 进程间通信 49
5.1 概述 49
5.2 Linux中的Pthreads IPC示例 50
5.2.1 互斥量和共享内存 50
5.2.2 信号量 52
5.2.3 条件变量 54
5.3 Ada中的互斥 57
5.4 BSD套接字 60
5.5 TCP客户-服务器示例 61
5.5.1 一个简单的TCP服务器 61
5.5.2 字符串终止和网络 67
5.5.3 一个简单的TCP客户端 68
5.5.4 具有名称查找功能的TCP客户端 72
5.6 UDP客户-服务器示例 72
5.6.1 UDP服务器 72
5.6.2 UDP客户端 75
5.7 双向通信 77
5.8 分叉模式的TCP服务器 79
5.9 阻塞处理和select 83
5.9.1 用于双向通信的select 84
5.9.2 用于多个连接的select 86
5.10 容错和IPC定时处理 87
5.11 本章小结 87
练习题 87
第6章 协议 89
6.1 概述 89
6.2 协议的目的 89
6.3 协议中的有关问题 90
6.3.1 高级和低级协议 90
6.3.2 消息 91
6.3.3 平台依赖 92
6.3.4 容错 93
6.4 定义协议 95
6.4.1 编码 96
6.4.2 表示法 96
6.5 示例: HTTP 97
6.6 示例: SMTP 98
6.7 示例: 交替位协议 99
6.8 本章小结 101
练习题 101
第7章 安全性 103
7.1 概述 103
7.2 定义、概念和术语 103
7.2.1 风险、威胁和漏洞 103
7.2.2 安全性的目标 104
7.2.3 设计 104
7.3 分布式系统中的安全问题 105
7.4 加密 107
7.4.1 加密示例: 数字签名 108
7.4.2 密钥管理 108
7.4.3 将公开密钥与用户匹配 109
7.5 案例研究: Needham-Schroeder 109
7.6 实际问题 110
7.6.1 C编程 110
7.6.2 Web应用程序 111
7.6.3 操作系统和网络问题 112
7.6.4 SSL 112
7.6.5 使用SSL 113
7.7 本章小结 114
练习题 115
第8章 语言和分布式处理 116
8.1 概述 116
8.2 语言的适用性 116
8.3 C中的分布式处理 117
8.3.1 C概述 118
8.3.2 调试C 118
8.4 Java中的分布式处理 119
8.4.1 概述: RMI模型 119
8.4.2 示例 120
8.4.3 其他方法 123
8.5 Ada中的分布式处理 123
8.6 Eiffel和SCOOP中的分布式处理 125
8.6.1 SCOOP: Eiffel的一种并发模型 126
8.6.2 相关工作和原型 128
8.7 语言的比较 129
8.7.1 语言模式 130
8.7.2 类型规则 130
8.7.3 网络支持 131
8.7.4 并发支持 132
8.7.5 进程间通信支持 132
8.8 本章小结 133
练习题 133
第9章 构建分布式系统 134
9.1 概述 134
9.2 方法 135
9.3 案例分析: 电子邮件 135
9.3.1 典型使用和需求 136
9.3.2 平台和语言要求 136
9.3.3 结构 137
9.3.4 协议和形式 137
9.3.5 示例: 使用PHP发送电子邮件 139
9.4 案例分析: 安全外壳 142
9.4.1 典型使用和需求 142
9.4.2 平台要求 143
9.4.3 结构 143
9.4.4 协议 144
9.5 案例分析: 版本控制和同步 145
9.5.1 典型使用和需求 146
9.5.2 平台要求 146
9.5.3 结构 146
9.5.4 协议 147
9.6 案例分析: Web应用程序 148
9.7 本章小结 149
练习题 149
第10章 案例分析: 一个网络游戏 151
10.1 动机和组织 151
10.2 大概结构和基本需求 152
10.3 分析和设计 152
10.3.1 大纲用例 153
10.3.2 详细设计问题 155
10.3.3 安全性 156
10.4 协议 157
10.4.1 协议消息 157
10.4.2 客户端登录 157
10.4.3 地图服务器启动和关闭 158
10.4.4 UDP消息 159
10.4.5 协议备注 161
10.4.6 数据视图 161
10.5 实现 162
10.5.1 管理服务器 163
10.5.2 地图服务器 164
10.5.3 玩家客户端 164
10.5.4 运行示例 165
10.6 测试 165
10.7 本章小结 166
练习题 166
第11章 结束 168
11.1 小结 168
11.2 建议 169
11.2.1 将来方向 171
11.2.2 有趣的项目 171
附录A 练习题: 提示和注解 173
第1章 什么是分布式处理 173
第2章 并发的概念 175
第3章 并发模型 177
第4章 操作系统中的并发 180
第5章 进程间通信 184
第6章 协议 185
第7章 安全性 189
第8章 语言和分布式处理 191
第9章 构建分布式系统 192
第10章 案例分析: 一个网络游戏 194
附录B 关于示例代码 197
参考文献 198
词汇表 202
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式处理实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云原生分布式存储基石：etcd深入解析
前言
第一部分 基础篇
第1章 分布式系统与一致性协议 2
1.1 CAP原理 3
1.2 一致性 5
1.2.1 一致性模型 7
1.2.2 一致性模型分述 9
1.2.3 复制状态机 16
1.2.4 拜占庭将军问题 18
1.2.5 FLP不可能性 19
1.2.6 小结 21
1.3 Paxos协议 22
1.4 Raft协议：为可理解性而生 24
1.4.1 Raft一致性算法 26
1.4.2 可用性与时序 45
1.4.3 异常情况 46
1.4.4 日志压缩与快照 52
1.4.5 Raft算法性能评估 56
1.4.6 小结 58
第二部分 实战篇
第2章 为什么使用etcd 62
2.1 etcd是什么 64
2.2 etcd架构简介 66
2.2.1 etcd数据通道 69
2.2.2 etcd架构 71
2.3 etcd典型应用场景举例 72
2.3.1 服务注册与发现 72
2.3.2 消息发布和订阅 75
2.3.3 负载均衡 76
2.3.4 分布式通知与协调 77
2.3.5 分布式锁 78
2.3.6 分布式队列 80
2.3.7 集群监控与Leader竞选 81
2.3.8 小结 82
2.4 etcd性能测试 82
2.4.1 etcd读性能 82
2.4.2 etcd写性能 83
2.5 etcd与其他键值存储系统的对比 84
2.5.1 ZooKeeper VS etcd 85
2.5.2 Consul VS etcd 88
2.5.3 NewSQL（Cloud Spanner、CockroachDB、TiDB）VS etcd 88
2.5.4 使用etcd做分布式协同 89
2.5.5 小结 90
2.6 使用etcd的项目 90
2.7 etcd概念词汇表 91
2.8 etcd发展里程碑 92
2.8.1 etcd 0.4版本 93
2.8.2 etcd 2.0版本 93
2.8.3 etcd 3.0版本 93
第3章 etcd初体验 95
3.1 单机部署 95
3.1.1 单实例etcd 95
3.1.2 多实例etcd 98
3.2 多节点集群化部署 100
3.2.1 静态配置 101
3.2.2 服务发现 104
3.3 etcdctl常用命令行 107
3.3.1 key的常规操作 107
3.3.2 key的历史与watch 112
3.3.3 租约 115
3.4 etcd常用配置参数 117
3.4.1 member相关参数项 117
3.4.2 cluster相关参数项 118
3.4.3 proxy相关参数项 120
3.4.4 安全相关参数项 120
3.4.5 日志相关参数项 121
3.4.6 不安全参数项 121
3.4.7 统计相关参数项 122
3.4.8 认证相关参数项 122
第4章 etcd开放API之v 2123
4.1 API保证 124
4.2 etcd v2 API 126
4.2.1 集群管理API 126
4.2.2 键值API 126
4.2.3 键的TTL 130
4.2.4 等待变化通知：watch 134
4.2.5 自动创建有序key 146
4.2.6 目录TTL 148
4.2.7 原子的CAS 149
4.2.8 原子的CAD 151
4.2.9 创建目录 153
4.2.10 罗列目录 154
4.2.11 删除目录 156
4.2.12 获取一个隐藏节点 157
4.2.13 通过文件设置key 158
4.2.14 线性读 158
4.3 统计数据 158
4.3.1 Leader数据 159
4.3.2 节点自身的数据 160
4.3.3 更多统计数据 161
4.4 member API 162
4.4.1 List member 162
4.4.2 加入一个member 163
4.4.3 删除一个member 163
4.4.4 修改member的peer URL 164
第5章 etcd开放API之v 3165
5.1 从etcd v2到etcd v 3166
5.1.1 gRPC 167
5.1.2 序列化和反序列化优化 167
5.1.3 减少TCP连接 167
5.1.4 租约机制 167
5.1.5 etcd v3的观察者模式 168
5.1.6 etcd v3的数据存储模型 169
5.1.7 etcd v3的迷你事务 170
5.1.8 快照 171
5.1.9 大规模watch 171
5.2 gRPC服务 172
5.3 请求和响应 174
5.4 KV API 176
5.4.1 键值对 176
5.4.2 revision 177
5.4.3 键区间 178
5.4.4 Range API 178
5.4.5 PUT调用 181
5.4.6 事务 182
5.4.7 Compact调用 186
5.5 watch API 186
5.5.1 Event 187
5.5.2 流式watch 187
5.6 Lease API 190
5.6.1 获得租约 190
5.6.2 Keep Alives 192
5.7 API使用示例 192
第6章 etcd集群运维与稳定性 195
6.1 etcd升级 195
6.1.1 etcd从2.3升级到3. 0195
6.1.2 etcd从3.0升级到3. 1199
6.2 从etcd v2切换到v 3202
6.2.1 切换客户端代码 202
6.2.2 数据迁移 203
6.3 运行时重配置 204
6.3.1 两阶段配置更新保证集群安全 205
6.3.2 永久性失去半数以上member 206
6.4 参数调优 207
6.4.1 时间参数 207
6.4.2 快照 208
6.4.3 磁盘 209
6.4.4 网络 209
6.5 监控 209
6.6 维护 210
6.6.1 压缩历史版本 210
6.6.2 消除碎片化 211
6.6.3 存储配额 211
6.6.4 快照备份 213
6.7 灾难恢复 213
6.7.1 快照 214
6.7.2 恢复集群 214
6.8 etcd网关 215
6.8.1 什么时候使用etcd网关 216
6.8.2 什么时候不该使用etcd网关 216
6.8.3 启动etcd网关 217
6.9 gRPC代理 217
6.9.1 可扩展的watch API 218
6.9.2 限制 219
6.9.3 可扩展的带租约的API 219
6.9.4 服务端保护 220
6.9.5 启动gRPC代理 220
6.9.6 客户端节点同步和域名解析 221
6.9.7 名字空间 222
6.10 故障恢复 223
6.10.1 小部分从节点故障 223
6.10.2 主节点故障 224
6.10.3 大部分节点故障 224
6.10.4 网络分区 224
6.10.5 集群启动异常 225
6.11 硬件 225
第7章 etcd安全 231
7.1 访问安全 231
7.1.1 权限资源 232
7.1.2 键值资源 234
7.1.3 配置资源 234
7.2 etcd访问控制实践 235
7.2.1 User相关命令 235
7.2.2 Role相关命令 236
7.2.3 启用用户权限功能 237
7.3 传输安全 238
7.3.1 TLS/SSL工作原理 239
7.3.2 使用TLS加密etcd通信 241
7.3.3 etcd安全配置详解 247
第三部分 高级篇
第8章 多版本并发控制 252
8.1 为什么选择MVCC 253
8.2 etcd v2存储机制实现 255
8.3 etcd v3数据模型 255
8.3.1 逻辑视图 256
8.3.2 物理视图 259
8.4 etcd v3的MVCC的实现 259
8.5 etcd v3 MVCC源码分析 261
8.5.1 revision 262
8.5.2 key到revision之间的映射关系 263
8.5.3 从BoltDB中读取key的value值 264
8.5.4 压缩历史版本 266
8.6 为什么选择BoltDB作为底层的存储引擎 267
第9章 etcd的日志和快照管理 269
9.1 数据的持久化和复制 271
9.2 etcd的日志管理 272
9.2.1 WAL数据结构 272
9.2.2 WAL文件物理格式 273
9.2.3 WAL文件的初始化 274
9.2.4 WAL追加日志项 276
9.2.5 WAL日志回放 277
9.2.6 Master向Slave推送日志 278
9.2.7 Follower日志追加 280
9.3 etcd v2的快照管理 280
9.3.1 快照数据结构 281
9.3.2 创建快照 281
9.3.3 快照复制 284
9.3.4 快照之后的日志回收 286
第10章 etcd v3的事务和隔离 288
10.1 事务ACID 288
10.2 事务的隔离性 289
10.2.1 Read uncommitted（读未提交） 290
10.2.2 Read committed（读提交） 290
10.2.3 Repeatable read（重复读） 290
10.3 etcd的事务 291
10.3.1 Serializability的重要性 291
10.3.2 etcd v3的事务实现 293
10.3.3 软件事务内存 295
10.3.4 etcd v3 STM实现 296
第11章 etcd watch机制详解 300
11.1 etcd v2的watch机制详解 300
11.1.1 客户端的watch请求 300
11.1.2 key发生变更时通知客户端 303
11.1.3 带版本号的watch 303
11.1.4 etcd v2 watch的限制 304
11.2 etcd v3的watch实现机制 306
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云原生分布式存储基石：etcd深入解析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>COM+和Microsoft Visual Basic 6.0分布式应用程序开发
前言
简介
第一章 COM+

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>COM+和Microsoft Visual Basic 6.0分布式应用程序开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Ceph分布式存储实战
本书赞誉
序
前言
第1章　初识Ceph	1
1.1　Ceph概述	1
1.2　Ceph的功能组件	5
1.3　Ceph架构和设计思想	7
1.4　Ceph快速安装	9
1.4.1　Ubuntu/Debian安装	10
1.4.2　RHEL/CentOS安装	13
1.5　本章小结	16
第2章　存储基石RADOS	17
2.1　Ceph功能模块与RADOS	18
2.2　RADOS架构	20
2.2.1　Monitor介绍	20
2.2.2　Ceph OSD简介	22
2.3　RADOS与LIBRADOS	26
2.4　本章小结	31
第3章　智能分布CRUSH	32
3.1　引言	32
3.2　CRUSH基本原理	33
3.2.1　Object与PG	34
3.2.2　PG与OSD	34
3.2.3　PG与Pool	35
3.3　CRUSH关系分析	37
3.4　本章小结	41
第4章　三大存储访问类型	42
4.1　Ceph FS文件系统	42
4.1.1　Ceph FS和MDS介绍	43
4.1.2　部署MDS	45
4.1.3　挂载Ceph FS	46
4.2　RBD块存储	47
4.2.1　RBD介绍	47
4.2.2　librbd介绍	48
4.2.3　KRBD介绍	48
4.2.4　RBD操作	50
4.2.5　RBD应用场景	56
4.3　Object对象存储	57
4.3.1　RGW介绍	57
4.3.2　Amazon S3简介	58
4.3.3　快速搭建RGW环境	61
4.3.4　RGW搭建过程的排错指南	68
4.3.5　使用S3客户端访问RGW服务	71
4.3.6　admin管理接口的使用	75
4.4　本章小结	78
第5章　可视化管理Calamari	79
5.1　认识Calamari	79
5.2　安装介绍	79
5.2.1　安装calamari-server	80
5.2.2　安装romana（calamari-client）	82
5.2.3　安装diamond	85
5.2.4　安装salt-minion	86
5.2.5　重启服务	87
5.3　基本操作	87
5.3.1　登录Calamari	87
5.3.2　WORKBENCH页面	88
5.3.3　GRAPH页面	89
5.3.4　MANAGE页面	90
5.4　本章小结	92
第6章　文件系统—高性能计算与大数据	93
6.1　Ceph FS作为高性能计算存储	93
6.2　Ceph FS作为大数据后端存储	98
6.3　本章小结	101
第7章　块存储—虚拟化与数据库	102
7.1　Ceph与KVM	102
7.2　Ceph与OpenStack	106
7.3　Ceph与CloudStack	110
7.4　Ceph与ZStack	114
7.5　Ceph提供iSCSI存储 122
7.6　本章小结	128
第8章　对象存储—云盘与RGW异地灾备	129
8.1　网盘方案：RGW与OwnCloud的整合	129
8.2　RGW的异地同步方案	133
8.2.1　异地同步原理与部署方案设计	134
8.2.2　Region异地同步部署实战	137
8.3　本章小结	146
第9章　Ceph硬件选型、性能测试与优化	147
9.1　需求模型与设计	147
9.2　硬件选型	148
9.3　性能调优	151
9.3.1　硬件优化	152
9.3.2　操作系统优化	155
9.3.3　网络层面优化	161
9.3.4　Ceph层面优化	170
9.4　Ceph测试	174
9.4.1　测试前提	175
9.4.2　存储系统模型	175
9.4.3　硬盘测试	176
9.4.4　云硬盘测试	182
9.4.5　利用Cosbench来测试Ceph	185
9.5　本章小结	189
第10章　自定义CRUSH	191
10.1　CRUSH解析	191
10.2　CRUSH设计：两副本实例	201
10.3　CRUSH设计：SSD、SATA混合实例	207
10.3.1　场景一：快–慢存储方案	207
10.3.2　场景二：主–备存储方案	214
10.4　模拟测试CRUSH分布	217
10.5　本章小结	222
第11章　缓冲池与纠删码	223
11.1　缓冲池原理	223
11.2　缓冲池部署	225
11.2.1　缓冲池的建立与管理	226
11.2.2　缓冲池的参数配置	226
11.2.3　缓冲池的关闭	228
11.3　纠删码原理	229
11.4　纠删码应用实践	232
11.4.1　使用Jerasure插件配置纠删码	232
11.4.2　ISA-L插件介绍	234
11.4.3　LRC插件介绍	235
11.4.4　其他插件介绍	235
11.5　本章小结	235
第12章　生产环境应用案例	237
12.1　Ceph FS应用案例	237
12.1.1　将Ceph FS导出成NFS使用	238
12.1.2　在Windows客户端使用Ceph FS	239
12.1.3　OpenStack Manila项目对接Ceph FS案例	242
12.2　RBD应用案例	244
12.2.1　OpenStack对接RBD典型架构	244
12.2.2　如何实现Cinder Multi-Backend	246
12.3　Object RGW应用案例：读写分离方案	248
12.4　基于HLS的视频点播方案	249
12.5　本章小结	251
第13章　Ceph运维与排错	252
13.1　Ceph集群运维	252
13.1.1　集群扩展	252
13.1.2　集群维护	259
13.1.3　集群监控	266
13.2　Ceph常见错误与解决方案	277
13.2.1　时间问题	277
13.2.2　副本数问题	279
13.2.3　PG问题	282
13.2.4　OSD问题	286
13.3　本章小结	292
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Ceph分布式存储实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务分布式构架开发实战
1 微服务介绍 1
1.1 什么是微服务架构 2
1.2 垂直应用与微服务 2
1.3 实现一个最简单的微服务框架 3
1.3.1 公共接口 4
1.3.2 服务端 4
1.3.3 客户端 7
1.3.4 完善框架 8
1.4 主流微服务框架介绍 9
1.4.1 Dubbo 9
1.4.2 Spring Cloud 10
2 模块拆分 12
2.1 拆分逻辑 13
2.2 单模块 14
2.3 基础模块 14
2.4 复杂模块 15
3 Spring Boot 16
3.1 目录结构 17
3.2 主要文件 18
3.3 编辑器集成 18
4 Dubbo 20
4.1 注册中心 21
4.2 接口工程 22
4.3 服务端 23
4.4 消费方 28
4.5 网关 30
4.6 监控中心 33
4.7 服务管理 35
4.8 负载均衡 36
4.9 服务降级 37
4.10 集群容错 38
5 Spring Cloud 40
5.1 注册中心 41
5.2 注册服务 44
5.3 调用服务 45
5.3.1 Ribbon 46
5.3.2 Feign 49
5.4 Zuul网关 51
5.5 Hystrix 断路器 54
5.5.1 Ribbon 54
5.5.2 Fegin 57
5.6 服务监控 58
5.7 应用监控 61
5.8 熔断器监控 62
5.8.1 单应用的熔断数据 63
5.8.2 使用Turbine聚合数据 64
5.8.3 Cloud Admin整合Turbine 65
5.9 统一管理配置文件 66
6 数据持久化 70
6.1 Spring Data MySQL 71
6.1.1 依赖与配置 71
6.1.2 实体映射 72
6.1.3 Repository 76
6.1.4 JdbcTemplate 79
6.1.5 事务管理 80
6.2 Spring Data MongoDB 81
6.2.1 依赖与配置 81
6.2.2 实体映射 82
6.2.3 Repository 83
6.2.4 MongoTemplate 84
6.3 Spring Data ElasticSearch 85
6.3.1 基本概念 85
6.3.2 安装与运行 86
6.3.3 基于HTTP交互 87
6.3.4 配置分词器 91
6.3.5 依赖与配置 94
6.3.6 实体映射 94
6.3.7 Repository 95
6.3.8 ElasticsearchTemplate 96
6.4 TCC 分布式事务 98
6.5 Spring Data Redis 100
6.5.1 安装运行 100
6.5.2 依赖与配置 101
6.5.3 缓存支持 102
6.5.4 RedisTemplate 106
6.5.5 全局锁 107
7 表单验证 110
8 定时任务 113
8.1 Spring Task 单机定时任务 114
8.2 Cron 表达式 114
8.3 QuartZ 分布式定时任务 116
9 分布式会话 122
10 消息队列 124
10.1 安装及配置RabbitMQ 125
10.2 配置及使用 128
11 构建Web应用 130
12 异常处理 133
13 安全认证 139
13.1 OAuth2.0 协议介绍 140
13.2 shouquan模式 141
13.3 在Dubbo中使用OAuth 2.0 142
13.4 在Spring Cloud 中使用OAuth 2.0 151
13.4.1 shouquan中心 151
13.4.2 服务模块配置 154
13.4.3 网关配置 157
13.4.4 测试运行 159
14 日志管理 161
14.1 Spring Boot 日志 162
14.1.1 日志格式 162
14.1.2 输出到文件 163
14.1.3 扩展配置 163
14.2 分布式日志管理 166
14.2.1 ELK 搭建 167
14.2.2 Spring Boot 配置 169
15 热部署 171
16 接口文档管理 173
16.1 Dubbo中使用Swagger2 174
16.2 Spring Cloud中使用Swagger2 178
16.2.1 微服务模块配置 179
16.2.2 网关模块配置 181
17 Nexus私库 184
17.1 Nexus 安装 185
17.2 从Nexus私库下载jar包 187
17.3 上传jar包到Nexus私库 189
18 发布系统 191
18.1 Jenkins 安装配置 192
18.2 构建任务 194
19 分布式架构总结 201
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务分布式构架开发实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式数据库系统原理
第1章 引言
1.1 分布式数据处理
1.2 什么是分布式数据库系统
1.3 数据发送的不同选择
1.4 DDBS的承诺
1.4.1 分布及复制数据的透明管理
1.4.2 分布式事务提供的可靠性
1.4.3 改进的性能
1.4.4 更为容易的系统扩展
1.5 分布所带来的复杂性
1.6 设计问题
1.6.1 分布式数据库设计
1.6.2 分布式目录管理
1.6.3 分布式查询处理
1.6.4 分布式并发控制
1.6.5 分布式死锁管理
1.6.6 分布式数据库的可靠性
1.6.7 复制
1.6.8 问题之间的相互关系
1.6.9 其他方面的问题
1.7 分布式DBMS体系架构
1.7.1 ANSI／SPARC体系架构
1.7.2 集中式DBMS的通用体系架构
1.7.3 分布式DBMS体系架构的模型
1.7.4 自治性
1.7.5 分布
1.7.6 异构性
1.7.7 体系架构的不同选择
1.7.8 客户／服务器系统
1.7.9 P2P系统
1.7.10 多数据库体系架构
1.8 参考文献说明
第2章 背景知识
2.1关系DBMS概述
2.1.1关系数据库概念
2.1.2规范化
2.1.3关系语言
2.2计算机网络概述
2.2.1不同类型的网络
2.2.2通信方式
2.2.3数据通信的基本概念
2.2.4通信协议
2.3参考文献说明
第3章分布式数据库设计
3.1自顶向下的设计过程
3.2分布设计的研究问题
3.2.1为什么要分片
3.2.2不同的分片方法
3.2.3划分程度
3.2.4分片的正确性规则
3.2.5不同的分配方法
3.2.6信息需求
3.3分片
3.3.1水平分片
3.3.2垂直分片
3.3.3混合分片
3.4分配
3.4.1分配问题的定义
3.4.2信息需求
3.4.3分配模型
3.4.4解决办法
3.5数据目录
3.6本章小结
3.7参考文献说明
练习
第4章数据库集成
4.1自底向上的设计方法
4.2模式匹配
4.2.1模式异构性
4.2.2语言匹配方法
4.2.3基于限制的匹配方法
4.2.4基于学习的匹配方法
4.2.5组合匹配方法
4.3模式集成
4.4模式映像
4.4.1映像建立
4.4.2映像维护
4.5数据清洗
4.6本章小结
4.7参考文献说明
练习
第5章数据与访问控制
5.1 视图管理
5.1.1集中式DBMS中的视图
5.1.2分布式DBMS中的视图
5.1.3物化视图的维护
5.2数据安全
5.2.1裁决式访问控制
5.2.2多级访问控制
5.2.3分布式访问控制
5.3语义完整性控制
5.3.1集中式语义完整性控制
5.3.2分布式语义完整性控制
5.4本章小结
5.5参考文献说明
练习
第6章查询处理概述
6.1查询处理问题
6.2查询处理的目标
6.3关系代数运算的复杂度
6.4查询处理程序的刻画
6.4.1语言
6.4.2优化类型
6.4.3优化时机
6.4.4统计
6.4.5决策站点
6.4.6网络拓扑的利用
6.4.7利用复制的片段
6.4.8使用半连结
6.5查询处理的层次
6.5.1查询分解
6.5.2数据本地化
6.5.3全局查询优化
6.5.4分布式查询执行
6.6本章小结
6.7参考文献说明
第7章查询分解与数据本地化
7.1查询分解
7.1.1规范化
7.1.2分析
7.1.3去除冗余
7.1.4重写
7.2分布数据的本地化
7.2.1主水平划分的归约
7.2.2垂直分片的归约
7.2.3诱导分片的归约
7.2.4混合分片的归约
7.3本章小结
7.4参考文献说明
练习
第8章分布式查询的优化
8.1查询优化
8.1.1搜索空间
8.1.2搜索策略
8.1.3分布式代价模型
8.2集中式查询优化
8.2.1动态查询优化
8.2.2静态查询优化
8.2.3混合查询优化
8.3分布查询的连结排序
8.3.1连结排序
8.3.2基于半连结的算法
8.3.3连结与半连结的对比
8.4分布式查询优化
8.4.1动态方法
8.4.2静态方法
8.4.3基于半连结的方法
8.4.4混合方法
8.5本章小结
8.6参考文献说明
练习
……
第9章 多数据库查询处理
第10章 事务管理介绍
第11章 分布式并发控制
第12章 分布式DBMS的可靠性
第13章 数据复制
第14章 并行数据库系统
第15章 分布式对象数据库管理
第16章 P2P数据管理
第17章 万维网数据管理
第18章 前沿研究：流数据和云计算
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式数据库系统原理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>新能源与分布式发电技术
第1章  能源概述  1.1 能源利用的历史  1.2 能源的概念    1.2.1 资源和能源的概念    1.2.2 能源的分类    1.2.3 能源的品质  1.3 能源与环境问题    1.3.1 常规能源的环境影响    1.3.2 世界能源与环境问题  1.4 新能源发展战略    1.4.1  欧美的新能源发展政策与规划    1.4.2 我国的新能源发展政策与规划  习题第2章  太阳能及其利用  ……第3章  风能与风力发电第4章  潮汐能与潮汐发电第5章  海洋能多种发电技术第6章  地热能及其利用第7章  生物质能及其利用第8章  氢能和燃料电池第9章  互补发电与综合利用第10章  分布式发电技术附录参考答案参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>新能源与分布式发电技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java分布式应用程序设计
第1章  分布式应用模式概览	1
1.1  客户机-服务器应用模式	1
1.1.1  客户机-服务器（C/S）
体系结构	1
1.1.2  浏览器-服务器（B/S）
体系结构	3

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java分布式应用程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Microsoft Windows2000分布式服务
第1章 Windows 2000

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Microsoft Windows2000分布式服务
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式云数据中心的建设与管理
第1章 云数据中心的历史和发展趋势
1.1 云计算给数据中心带来的变革和好处
1.2 云数据中心3.0：分布式云数据中心的定义
1.3 分布式云数据中心是数据中心发展的必然趋势
第2章 分布式云数据中心提供的关键服务与关键技术
2.1　分布式云数据中心总体架构
2.2 　DCaaS服务介绍
2.3　IaaS服务关键技术：数据中心云操作系统
2.4 NaaS服务关键技术：TRILL，VXLAN，SDN
2.5　MaaS服务关键技术：自动化和管理系统
2.6 管理解决方案
第3章 IaaS的规划与建设
3.1　IaaS的规划
3.2　计算资源池的建设
3.3 存储资源池的建设
第4章 NaaS的规划与建设
4.1 Naas的规划
4.2 网络资源池的建设
应用举例
4.3 安全解决方案的建设
第5章 MaaS的设计与建设
5.1 数据中心运维管理
5.2 分布式云数据中心运营管理系统
第6章 FaaS的规划与建设
6.1 从土建到施工的蓝图
6.2 绿色机房的规划
6.3 绿色机房的建设要点
第7章 灾备解决方案的规划与建设
7.1　灾备解决方案规划
7.2 灾备解决方案的建设要点
第8章 传统数据中心的改造和整合
8.1　IT架构治理介绍
8.2　传统数据中心的改造和整合
第9章 分布式云数据中心的成功实践
9.1　某知名全球化电信运营商分布式
云数据中心
9.2　华为分布式云数据中心建设经验
9.3　分析师对华为数据中心的
评价
附录
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式云数据中心的建设与管理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Akka应用模式：分布式应用程序设计实践指南
前言 .......................................................................................... xvii
第1 章 Actor 模型 ........................................................................1
现实是最终一致的 .................................................................................................1
解构Actor 模型 .....................................................................................................3
所有的计算都在一个actor 中执行 .........................................................................4
actor 之间只能通过消息进行通信 .........................................................................5
actor 可以创建子actor ...........................................................................................6
actor 可以改变自己的状态或行为 .........................................................................8
一切都是actor .......................................................................................................9
Actor 模型的使用 .................................................................................................10
定义清晰的边界 ................................................................................................... 11
何时适合使用Actor 模型 ....................................................................................13
结论 .....................................................................................................................13
第2 章 Akka 简介 .......................................................................15
Akka 是什么......................................................................................................... 15
Akka 是开源的 .............................................................................................. 15
Akka 正在蓬勃发展 .......................................................................................16
Akka 是为分布式设计的 ...............................................................................16
Akka 组件 ............................................................................................................17
Akka actor .....................................................................................................17
子actor .......................................................................................................... 18
remoting ：不同JVM 上的actor ....................................................................20
clustering ：集群成员的自动化管理 ..............................................................20
Akka HTTP ...................................................................................................24
TestKit ........................................................................................................... 25
contrib ........................................................................................................... 25
Akka OSGi ................................................................................................... 25
Akka HTTP ...................................................................................................26
Akka Streams ................................................................................................26
Akka 实现的Actor 模型 ......................................................................................26
Actor 模型中的Akka actor ..................................................................................26
消息传递 .......................................................................................................27
actor 系统 ...................................................................................................... 28
Akka Typed 项目 .................................................................................................. 28
结论 ....................................................................................................................29
第3 章 分布式领域驱动设计 ........................................................31
DDD 概述 ............................................................................................................31
DDD 的好处 .........................................................................................................32
DDD 组件 ............................................................................................................33
域实体 ..................................................................................................................34
域值对象 .............................................................................................................34
聚合与聚合根 ..................................................................................................... 35
仓储 .....................................................................................................................37
工厂和对象创建 ................................................................................................... 38
域服务 .................................................................................................................. 38
有界上下文 ..........................................................................................................39
结论 ....................................................................................................................41
第4 章 优秀的Actor 设计 ...........................................................43
大系统小做 ..........................................................................................................43
封装actor 中的状态 ............................................................................................44
使用字段封装状态 .......................................................................................44
使用“状态”容器封装状态 ........................................................................47
使用become 封装状态 ................................................................................. 48
将futures 与actors 混合 ............................................................................... 50
Ask 模式和替代方案 ............................................................................................ 54
Ask 模式的问题 ........................................................................................... 55
附带的复杂性 ................................................................................................ 57
Ask 的替代方案 ........................................................................................... 57
命令与事件 .......................................................................................................... 59
构造函数的依赖注入 ....................................................................................61
使用路径查找actor ......................................................................................61
结论 ....................................................................................................................62
第5 章 数据流 ............................................................................63
吞吐量与延迟 ......................................................................................................63
流 .........................................................................................................................64
路由器 ..................................................................................................................66
邮箱 ..................................................................................................................... 68
无界邮箱 ...................................................................................................... 68
有界邮箱 ......................................................................................................69
拉取的工作模式 ..................................................................................................70
背压 .....................................................................................................................73
ack .................................................................................................................73
高水位标记 ...................................................................................................73
队列长度监控 ................................................................................................74
速率监控 ......................................................................................................74
Akka 数据流.........................................................................................................74
源 .................................................................................................................. 75
汇 ..................................................................................................................77
RunnableGraph ............................................................................................. 78
流 ..................................................................................................................79
交叉点 ........................................................................................................... 80
Akka 流中的背压 ......................................................................................... 81
Akka 流的使用 ............................................................................................. 82
结论 .................................................................................................................... 84
第6 章 一致性和可扩展性 ...........................................................85
事务和一致性 ...................................................................................................... 85
强一致性与最终一致性 ....................................................................................... 86
并发性与并行性 ................................................................................................... 86
为什么全局一致的分布式状态影响可扩展性 ...................................................... 86
位置透明性 ......................................................................................................... 87
交付保证 ............................................................................................................. 87
最多投递一次 ................................................................................................ 87
最少投递一次 ................................................................................................ 88
恰好一次交付是不可能的（但可以近似做到） .............................................91
如何近似做到恰好一次交付 .........................................................................91
集群单例 .......................................................................................................92
可扩展性 ..............................................................................................................94
避免全局状态 ............................................................................................... 98
避免共享状态 ............................................................................................... 98
遵循Actor 模型 .............................................................................................99
避免顺序操作 ...............................................................................................99
隔离阻塞型操作 ...........................................................................................99
监控和调优 ..................................................................................................99
集群分片和一致性 ...............................................................................................99
分片 ............................................................................................................. 100
Akka 中的分片 ........................................................................................... 101
分片键的生成 ............................................................................................. 102
分片的分布 ................................................................................................ 103
一致性边界 ................................................................................................. 103
可扩展性边界 ............................................................................................. 104
分片聚合根 ................................................................................................ 105
持久化 ......................................................................................................... 106
钝化 ............................................................................................................. 106
使用集群分片保证一致性 ........................................................................... 107
结论 .................................................................................................................. 109
第7 章 容错 .............................................................................111
故障类型 ........................................................................................................... 112
异常 ............................................................................................................ 112
JVM 中的致命错误 .................................................................................... 113
外部服务故障 ............................................................................................. 113
不符合服务等级协议 .................................................................................. 113
操作系统和硬件级故障 .............................................................................. 114
故障隔离 ........................................................................................................... 114
舱壁模式 .................................................................................................... 114
优雅降级 ..................................................................................................... 117
使用Akka 集群隔离故障 ............................................................................ 119
使用熔断器控制故障 ................................................................................... 119
故障处理 ............................................................................................................ 122
异常处理 ..................................................................................................... 123
外部服务的故障处理 .................................................................................. 128
结论 ................................................................................................................... 131
第8 章 可用性 ..........................................................................133
微服务和单体式应用 ........................................................................................ 133
用有界上下文划分微服务 ................................................................................. 134
细粒度的微服务 ................................................................................................. 135
集群感知路由器 ................................................................................................. 135
分布式数据 ....................................................................................................... 137
优雅降级 ............................................................................................................ 140
部署 ................................................................................................................... 141
分阶段部署/ 滚动重启 ..................................................................................... 142
蓝/ 绿部署 ........................................................................................................ 142
崩溃恢复/ 运维监测 ......................................................................................... 143
健康检查和应用状态页面 .......................................................................... 143
度量 ............................................................................................................ 145
日志 ............................................................................................................. 146
看门狗工具 ................................................................................................. 146
结论 .................................................................................................................. 147
第9 章 性能 ...........................................................................149
隔离瓶颈 ........................................................................................................... 150
优化Akka ......................................................................................................... 150
减少或隔离阻塞型操作 .............................................................................. 150
缩短消息处理时间 ...................................................................................... 151
增加处理消息的actor ................................................................................ 151
派发器 ................................................................................................................ 151
标准派发器 ................................................................................................. 151
固定派发器 ................................................................................................. 153
平衡派发器 ................................................................................................ 154
calling-thread 派发器 .................................................................................. 154
何时使用单独的派发器 .............................................................................. 155
提高并行性 ................................................................................................ 157
结论 .................................................................................................................. 158
后记 ..........................................................................................159
参考文献 ...................................................................................161
关于作者 ...................................................................................162
封面介绍 ...................................................................................163
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Akka应用模式：分布式应用程序设计实践指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Delhpi 5.X分布式多层应用系统篇
第1章 Delphi和分布式多层

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Delhpi 5.X分布式多层应用系统篇
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot 2精髓
第1章　Java EE简介
1.1　Java EE
1.1.1　Java EE架构
1.1.2　Java EE的缺点
1.2　Spring
1.2.1　Spring IoC容器和AOP
1.2.2　Spring的缺点
1.3　Spring Boot
1.4　Hello，Spring Boot
1.4.1　创建一个Maven工程
1.4.2　增加Web支持
1.4.3　Hello Spring Boot示例
1.4.4　使用热部署
1.4.5　添加REST支持
第2章　Spring Boot基础
2.1　检查Java环境与安装Java
2.2　安装和配置Maven
2.2.1　Maven介绍
2.2.2　安装Maven
2.2.3　设置Maven
2.2.4　使用IDE设置Maven
2.2.5　Maven的常用命令
2.3　Spring核心技术
2.3.1　Spring的历史
2.3.2　Spring容器介绍
2.3.3　Spring AOP介绍
第3章　MVC框架
3.1　集成MVC框架
3.1.1　引入依赖
3.1.2　Web应用目录结构
3.1.3　Java包名结构
3.2　使用Controller
3.3　URL映射到方法
3.3.1　@RequestMapping
3.3.2　URL路径匹配
3.3.3　HTTP method匹配
3.3.4　consumes和produces
3.3.5　params和header匹配
3.4　方法参数
3.4.1　PathVariable
3.4.2　Model&ModelAndView
3.4.3　JavaBean接受HTTP参数
3.4.4　@RequsetBody接受JSON
3.4.5　MultipartFile
3.4.6　@ModelAttribute
3.4.7　@InitBinder
3.5　验证框架
3.5.1　JSR-303
3.5.2　MVC中使用@Validated
3.5.3　自定义校验
3.6　WebMvcConfigurer
3.6.1　拦截器
3.6.2　跨域访问
3.6.3　格式化
3.6.4　注册Controller
3.7　视图技术
3.7.1　使用Freemarker
3.7.2　使用Beetl
3.7.3　使用Jackson
3.7.4　Redirect和Forward
3.8　通用错误处理
3.9　@Service和@Transactional
3.9.1　声明一个Service类
3.9.2　事务管理
3.10　curl命令
第4章　视图技术
4.1　Beetl模板引擎
4.1.1　安装Beetl
4.1.2　设置定界符号和占位符
4.1.3　配置Beetl
4.1.4　groupTemplate
4.2　使用变量
4.2.1　全局变量
4.2.2　局部变量
4.2.3　共享变量
4.2.4　模板变量
4.3　表达式
4.3.1　计算表达式
4.3.2　逻辑表达式
4.4　控制语句
4.4.1　循环语句
4.4.2　条件语句
4.4.3　try catch
4.5　函数调用
4.6　格式化函数
4.7　直接调用Java
4.8　标签函数
4.9　HTML标签
4.10　安全输出
4.11　高级功能
4.11.1　配置Beetl
4.11.2　自定义函数
4.11.3　自定义格式化函数
4.11.4　自定义标签函数
4.11.5　自定义HTML标签
4.11.6　布局
4.11.7　AJAX局部渲染
4.12　脚本引擎
4.13　JSON技术
4.13.1　在Spring Boot中使用Jackson
4.13.2　自定义ObjectMapper
4.13.3　Jackson的三种使用方式
4.13.4　Jackson树遍历
4.13.5　对象绑定
4.13.6　流式操作
4.13.7　Jackson注解
4.13.8　集合的反序列化
4.14　MVC分离开发
4.14.1　集成WebSimulate
4.14.2　模拟JSON响应
4.14.3　模拟模板渲染
第5章　数据库访问
5.1　配置数据源
5.2　Spring JDBC Template
5.2.1　查询
5.2.2　修改
5.2.3　JdbcTemplate增强
5.3　BeetlSQL介绍
5.3.1　BeetlSQL功能概览
5.3.2　添加Maven依赖
5.3.3　配置BeetlSQL
5.3.4　SQLManager
5.3.5　使用SQL文件
5.3.6　Mapper
5.3.7　使用实体
5.4　SQLManager内置CRUD
5.4.1　内置的插入API
5.4.2　内置的更新（删除）API
5.4.3　内置的查询API
5.4.4　代码生成方法
5.5　使用sqlId
5.5.1　md文件命名
5.5.2　md文件构成
5.5.3　调用sqlId
5.5.4　翻页查询
5.5.5　TailBean
5.5.6　ORM查询
5.5.7　其他API
5.5.8　Mapper详解
5.6　BeetlSQL的其他功能
5.6.1　常用函数和标签
5.6.2　主键设置
5.6.3　BeetlSQL注解
5.6.4　NameConversion
5.6.5　锁
第6章　Spring Data JPA
6.1　集成Spring Data JPA
6.1.1　集成数据源
6.1.2　配置JPA支持
6.1.3　创建Entity
6.1.4　简化Entity
6.2　Repository
6.2.1　CrudRepository
6.2.2　PagingAndSortingRepository
6.2.3　JpaRepository
6.2.4　持久化Entity
6.2.5　Sort
6.2.6　Pageable和Page
6.2.7　基于方法名字查询
6.2.8　@Query查询
6.2.9　使用JPA Query
6.2.10　Example查询
第7章　Spring Boot配置
7.1　配置Spring Boot
7.1.1　服务器配置
7.1.2　使用其他Web服务器
7.1.3　配置启动信息
7.1.4　配置浏览器显示ico
7.2　日志配置
7.3　读取应用配置
7.3.1　Environment
7.3.2　@Value
7.3.3　@ConfigurationProperties
7.4　Spring Boot自动装配
7.4.1　@Configuration和@Bean
7.4.2　Bean条件装配
7.4.3　Class条件装配
7.4.4　Environment装配
7.4.5　其他条件装配
7.4.6　联合多个条件
7.4.7　Condition接口
7.4.8　制作Starter
第8章　部署Spring Boot应用
8.1　以jar文件运行
8.2　以war方式部署
8.3　多环境部署
8.4　@Profile注解
第9章　Testing单元测试
9.1　JUnit介绍
9.1.1　JUnit的相关概念
9.1.2　JUnit测试
9.1.3　Assert
9.1.4　Suite
9.2　Spring Boot单元测试
9.2.1　测试范围依赖
9.2.2　Spring Boot测试脚手架
9.2.3　测试Service
9.2.4　测试MVC
9.2.5　完成MVC请求模拟
9.2.6　比较MVC的返回结果
9.2.7　JSON比较
9.3　Mockito
9.3.1　模拟对象
9.3.2　模拟方法参数
9.3.3　模拟方法返回值
9.4　面向数据库应用的单元测试
9.4.1　@Sql
9.4.2　XLSUnit
9.4.3　XLSUnit的基本用法
第10章　REST
10.1　REST简介
10.1.1　REST风格的架构
10.1.2　使用“api”作为上下文
10.1.3　增加一个版本标识
10.1.4　标识资源
10.1.5　确定HTTP Method
10.1.6　确定HTTP Status
10.1.7　REST VS. WebService
10.2　Spring Boot集成REST
10.2.1　集成REST
10.2.2　@RestController
10.2.3　REST Client
10.3　Swagger UI
10.3.1　集成Swagger
10.3.2　Swagger规范
10.3.3　接口描述
10.3.4　查询参数描述
10.3.5　URI中的参数
10.3.6　HTTP头参数
10.3.7　表单参数
10.3.8　文件上传参数
10.3.9　整个请求体作为参数
10.4　模拟REST服务
第11章　MongoDB
11.1　安装MongoDB
11.2　使用shell
11.2.1　指定数据库
11.2.2　插入文档
11.2.3　查询文档
11.2.4　更新操作
11.2.5　删除操作
11.3　Spring Boot集成MongoDB
11.4　增删改查
11.4.1　增加API
11.4.2　根据主键查询API
11.4.3　查询API
11.4.4　修改API
11.4.5　删除API
11.4.6　使用MongoDatabase
11.4.7　打印日志
第12章　Redis
12.1　安装Redis
12.2　使用redis-cli
12.2.1　安全设置
12.2.2　基本操作
12.2.3　keys
12.2.4　Redis List
12.2.5　Redis Hash
12.2.6　Set
12.2.7　Pub/Sub
12.3　Spring Boot集成Redis
12.4　使用StringRedisTemplate
12.4.1　opsFor
12.4.2　绑定Key的操作
12.4.3　RedisConnection
12.4.4　Pub/Sub
12.5　序列化策略
12.5.1　默认序列化策略
12.5.2　自定义序列化策略
第13章　Elasticsearch
13.1　Elasticsearch介绍
13.1.1　安装Elasticsearch
13.1.2　Elasticsearch的基本概念
13.2　使用REST访问Elasticsearch
13.2.1　添加文档
13.2.2　根据主键查询
13.2.3　根据主键更新
13.2.4　根据主键删除
13.2.5　搜索文档
13.2.6　联合多个索引搜索
13.3　使用RestTemplate访问ES
13.3.1　创建Book
13.3.2　使用RestTemplate获取搜索结果
13.4　Spring Data Elastic
13.4.1　安装Spring Data
13.4.2　编写Entity
13.4.3　编写Dao
13.4.4　编写Controller
第14章　Cache
14.1　关于Cache
14.1.1　Cache的组件和概念
14.1.2　Cache的单体应用
14.1.3　使用专有的Cache服务器
14.1.4　使用一二级缓存服务器
14.2　Spring Boot Cache
14.3　注释驱动缓存
14.3.1　@Cacheable
14.3.2　Key生成器
14.3.3　@CachePut
14.3.4　@CacheEvict
14.3.5　@Caching
14.3.6　@CacheConfig
14.4　使用Redis Cache
14.4.1　集成Redis缓存
14.4.2　禁止缓存
14.4.3　定制缓存
14.5　Redis缓存原理
14.6　实现Redis两级缓存
14.6.1　实现TwoLevelCacheManager
14.6.2　创建RedisAndLocalCache
14.6.3　缓存同步说明
14.6.4　将代码组合在一起
第15章　Spring Session
15.1　水平扩展实现
15.2　Nginx的安装和配置
15.2.1　安装Nginx
15.2.2　配置Nginx
15.3　Spring Session
15.3.1　Spring Session介绍
15.3.2　使用Redis
15.3.3　Nginx+Redis
第16章　Spring Boot和ZooKeeper
16.1　ZooKeeper
16.1.1　ZooKeeper的数据结构
16.1.2　安装ZooKeeper
16.1.3　ZooKeeper的基本命令
16.1.4　领导选取演示
16.1.5　分布式锁演示
16.1.6　服务注册演示
16.2　Spring Boot集成ZooKeeper
16.2.1　集成Curator
16.2.2　Curator API
16.3　实现分布式锁
16.4　服务注册
16.4.1　通过ServiceDiscovery注册服务
16.4.2　获取服务
16.5　领导选取
第17章　监控Spring Boot应用
17.1　安装Acutator
17.2　HTTP跟踪
17.3　日志查看
17.4　线程栈信息
17.5　内存信息
17.6　查看URL映射
17.7　查看Spring容器管理的Bean
17.8　其他监控
17.9　编写自己的监控信息
17.9.1　编写HealthIndicator
17.9.2　自定义监控
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot 2精髓
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ASP.NET分布式数据应用程序高级编程
第一章 分布式应用程序
第二章 组织和数据访问
第三章 访问XML文档
第四章 应用程序管道化
第五章 处理低端客户机
第六章 处理胖客户机
第七章 远程访问.NET客户机
第八章 在低端客户机上更新数据
第九章 更新远程高速缓存数据
第十章 更新数据的组件
第十一章 胖客户机更新应用程序
第十二章 协调更新错误
第十三章 远程.NET应用程序的数据更新

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ASP.NET分布式数据应用程序高级编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式数据库管理系统实现技术
第一章分布式数据库管理系统概论
1.1引论
1.2分布式数据库系统的特征
1.3若干研制计划和原型系统
1.4小结
参考文献
第二章分布式灵敏据库管理系统的体系结构
2.1DDBMS体系结构综述
2.2DDBMS的分层体系结构
2.3DDBMS的进程结构
参考文献
第三章分布式数据库系统的编程语言
3.1编程语言的设计要点
3.2RDBL语言简介
3.2.1数据说明语句

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式数据库管理系统实现技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>VisualBasic与分布式监控系统－RS232/485串行通信1cd
第1章 串行通信概念
1. 1

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>VisualBasic与分布式监控系统－RS232/485串行通信1cd
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA分布式程序设计
第一部分 Socket编程
第1章 了解分布式程序设计
第2章 了解Socket编程
……
第二部分 RMI
第7章 了解RMI
第8章 从RMI开始
……
第三部分 CORBA
第11章 CORBA概述
第12章 开始使用CORBA
……
第四部分 移动代理和Voyager
第20章 移动软件代理概述
第21章 开始使用Voyager
……
参考文献
在线参考

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA分布式程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式领导
作者简介
第一部分  背景概述
导言
第一章  分布式领国导：我们知多少
一、引言
二、我们之所知
三、分布式领导与学生学习结果
四、分布的方式
五、评论
第二部分  实证视角
第二章  分布式领导与教学变革的关系研究
一、引言
二、实现教学变革的固有障碍
三、分布式领导与CSR计划下的教学变革
四、实施“美国之选择”设计的学校中的教学变革
五、研究方法
六、结果
七、结论
第三章  以分布观研究学校的领导与管理：研究操作法的挑战
一、引言
二、概念及实证的固着点
三、方法
四、审察领导者增量方面的操作化过程
五、方法论和认识论方面的考虑
六、不同学校、不同活动类型、不同学校类型之间的差异
七、讨论和结论
第四章  分布式领导与教师学术乐观的关系
一、引言
二、框架
三、方法
四、结果
五、结论
第五章  学校中的分布式领导：系统政策造成了差异?
一、学校领导观
二、学校改进的领导
三、学校改进的动态模型
四、我们的研究
五、结果
六、发展分布式领导的政策背景
七、分布式领导对学校改进过程的影响
八、分布式领导对学生学习结果的影响
九、校长的领导角色与影响
十、结论
第三部分  实践视角
第六章  以分层式领导进行能力建设：对转向的支撑
一、引言
二、背景
三、校长
四、四个发展阶段
五、讨论：分层式领导
第七章  学校中分布式领导与行动学习的关系：一项案例研究
一、引言
二、分布式领导
三、领导与学生的成就
四、本研究
五、分布式领导和研究的发现
六、进一步的讨论和最终的评论
第四部分  概念理论视角
第八章  意义建构和信任在分布式领导发展中的作用
一、引言
二、分布式领导：工作重设的视角
三、我们对分布式领导发展的研究
四、分布式领导在欧佛顿的发展、
五、分布式领导在福克斯的发展
六、讨论与结论
第九章  分布式领导：民主制还是传递?
一、引言
二、三个概念
三、两个样本
四、一个选择?
第五部分  未来视角
第十章  从分布式到混合型领导实践
一、引言
二、分布就是一切吗
三、回到未来?
四、点计人数
五、未竟的事业
六、结论
第十一章  符合目的：一种与教育关联的分布式领导阐释
一、何谓领导
二、从领导到分布式领导
三、分布式领导——一个更为丰满的故事
四、从分布式领导到教育结果
五、分布的领导岗位和教育的结果
六、讨论
第十二章  结语
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式领导
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式冷热电联产系统装置及应用
前言第一章  概述  第一节  科学用能与能的梯级利用    一、科学用能    二、能的梯级利用原理与技术  第二节  冷热电联产系统与分布式能源系统    第三节  国外冷热电联产系统发展与应用  第四节  我国冷热电联产系统发展概况    一、我国冷热电联产系统应用进展    二、我国冷热电联产系统发展中面临的问题与解决途径第二章  用户冷热电负荷  第一节  计算负荷的指标法与静态负荷    一、电力负荷的指标法    二、热负荷的指标法    三、冷负荷的指标法    四、负荷计算指标法的缺陷  第二节  冷热电联产系统动态负荷与计算方法    一、动态电负荷计算方法    二、动态热负荷计算方法    三、动态冷负荷计算方法  第三节  负荷动态变化与冷热电联产系统的关系    一、冷热电联产系统负荷动态特征    二、动态负荷变化与冷热电联产系统耦合第三章  冷热电联产系统集成  第一节  冷热电联产系统的分类与典型流程    一、系统分类    二、典型流程  第二节  冷热电联产系统的集成原则    一、化学能和物理能的综合梯级利用    二、热的梯级利用    三、正循环和逆循环的耦合    四、多种动力系统的耦合    五、系统深度集成    六、多能源互补系统    七、系统配置与调控优化的全工况系统集成    八、主动蓄能的全工况系统集成    第三节  冷热电联产系统性能    一、热力学性能    二、系统节能特性评价    三、变工况性能    四、环保性能指标    五、安全可靠性    六、经济性  第四节  可再生能源与化石能源互补的冷热电联产系统    一、系统特色    二、系统概述    三、系统技术经济分析第四章  动力系统及主要部件  第一节  概述  第二节  燃气轮机    一、概述    二、压气机    三、燃烧室    四、燃气透平    五、燃气轮机热力循环原理    六、燃气轮机全工况特性    七、微型燃气轮机    八、燃气轮机与冷热电联产  第三节  内燃机    一、概述    二、内燃机的构造与工作原理    三、内燃机的性能指标    四、内燃机的工况与特性    五、燃料    六、内燃机与冷热电联产  第四节  燃料电池    一、概述    二、磷酸型燃料电池(PAFC)     三、熔融碳酸盐燃料电池(MCFC)    四、固体氧化物燃料电池(SOFC)      五、燃料电池与冷热电联产系统第五章  制冷与热泵  第一节  概述    一、制冷机与热泵的分类    二、工作方式    三、性能系数    四、升温幅度  第二节  机械压缩式制冷    一、蒸汽压缩式制冷循环的原理    二、制冷工质    三、活塞式、螺杆式和离心式的冷水机组    四、压缩式制冷循环的变工况特性  第三节  吸收式制冷    一、吸收式制冷循环的原理    二、溴化锂吸收式制冷机的分类    三、演化锂吸收式机组的变工况特性    四、氨吸收式制冷机    五、其他热制冷方式  第四节  热泵第六章  蓄热蓄冷与除湿  第一节  蓄热技术与蓄热材料概述    一、显热式蓄热    二、相变蓄热    三、热化学过程蓄热  第二节  水蓄冷空调系统    一、概述    二、自然分层水蓄冷系统    三、水蓄冷槽蓄冷量和体积的确定  第三节  冰蓄冷空调系统    一、概述    二、完全冻结式冰蓄冷空调系统    三、密封件式冰蓄冷空调系统  第四节  共晶盐蓄冷空调系统    一、共晶盐蓄冷系统布置形式    二、共晶盐蓄冷系统流程    三、共晶盐蓄冷系统的蓄冷和释冷特性  第五节  低温送风系统    一、概述    二、低温送风系统的构成形式    三、冰蓄冷应用  第六节  除湿    一、概述    二、除湿基础    三、冷却除湿    四、液体吸收式除湿    五、固体吸附除湿与转轮除湿第七章  冷热电联产系统的应用案例  第一节  成都美好花园分布式冷热电联产系统      一、项目背景    二、系统概况    三、系统的运行和经济性    四、简评  第二节  东莞信泰光学工业园区能源中心    一、项目背景    二、园区能源需求与系统集成的总体思路    三、能源中心冷热电联产系统    四、简评  第三节  奥斯汀区域能源项目    一、项目背景    二、项目流程    三、主要部件性能参数    四、项目实施与运行情况    五、简评  第四节  Beloit Memorial医院联产系统    一、项目背景    二、系统概况    三、系统的运行和经济性    四、其他方面的考虑    五、简评  第五节  New Belgium酿酒厂联产系统    一、项目背景    二、系统概况    三、系统的运行和经济性    四、经验和教训    五、简评  第六节  伊利诺斯大学联产系统    一、项目背景    二、东校区联产系统    三、西校区联产系统    四、简评  第七节  达科他天然气液化储备中心联产系统      一、项目背景    二、系统概况    三、其他    四、简评  第八节  巴赛罗纳文化论坛项目    一、项目背景    二、系统概况    三、项目实施与运行    四、简评  第九节  马德里机场冷热电联产系统    一、项目背景    二、系统概况    三、系统的运行    四、简评  第十节  NTT武藏野研究开发中心本馆的冷热电联产系统    一、项目背景    二、系统特征    三、运行实效    四、简评  第十一节  惠比寿地区区域冷热电联产系统      一、项目背景    二、系统概况    三、运行实效    四、简评附录参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式冷热电联产系统装置及应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式发电技术
前言第1章 绪论   1.1 分布式发电的起源   1.2 分布式发电与经济和环境的关系   1.3 分布式发电系统中的控制和通信技术第2章 分布式电源   2.1 微型涡轮发电机   2.2 光伏电源   2.3 燃料电池   2.4 风力发电   2.5 能量存储系统第3章 分布式发电系统的热电联产   3.1 概述   3.2 热电联产系统   3.3 热电联产系统的典型应用   3.4 热电联产系统的经济性分析   3.5 热电联产系统的效益分析   3.6 热电联产系统的性能和燃料优化第4章 分布式发电系统的控制   4.1 概述   4.2 电力系统发展   4.3 系统频率性能与分布式发电   4.4 分布式电源模型   4.5 分布式发电系统模型及频率调节   4.6分布式发电与市场结构集成时的控制第5章 分布式发电系统的孤岛检测   5.1 反孤岛保护的基本原理   5.2 远程孤岛检测   5.3 分布式同步发电机孤岛的本地检测   5.4 基于逆变器的分布式发电系统的本地孤岛检测方法   5.5 孤岛检测标准和测试技术参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式发电技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式发电接入电力系统
译者序
原书前言
第1章引言
第2章能源
2.1风能
2.1.1现状
2.1.2特点
2.1.3风速变化
2.1.4发电容量的变化
2.1.5风速的Weibull分布
2.1.6以风速为随机变量的发电功率分布
2.1.7发电量的分布
2.1.8风力发电的期望值
2.2太阳能
2.2.1现状
2.2.2特点
2.2.3空间要求
2.2.4光伏
2.2.5天空中太阳的位置
2.2.6云层覆盖
2.2.7发电量的季节性变化
2.2.8随时间快速变化
2.3热电联供
2.3.1现状
2.3.2室内供暖
2.3.3特点
2.3.4随时间变化的发电量
2.3.5热电联供和电能消耗之间的关系
2.4水力发电
2.4.1大型水电特点
2.4.2小水电特点
2.4.3随时间变化
2.5潮汐能
2.6波浪能
2.7地热能
2.8热能发电厂
2.9电网接人
2.9.1发电机直接并网
2.9.2全功率电力电子变换器并网
2.9.3部分功率电力电子变换器并网
2.9.4分布式电力电子接入方式
2.9.5并网形式对电力系统的影响
2.9.6分布式发电的本地控制
第3章电力系统性能
3.1分布式发电对电力系统的影响
3.1.1发生的变化
3.1.2变化的影响
3.1.3这些问题有多严重 一
3.2电力系统的目标
3.3承载容量方法
3.4电能质量
3.4.1电压质量
3.4.2电流质量
3.4.3发电机跳闸
3.5电压质量及分布式发电设计
3.5.1正常运行；变化
3.5.2正常事件
3.5.3不正常事件
3.6用于电能质量事件的承载容量方法
3.7增加承载容量
第4章过载和损耗
4.1分布式发电的影响
4.2过载：辐射型配电网
4.2.1仅有功潮流
4.2.2有功和无功潮流
4.2.3案例研究l：恒定发电量
4.2.4案例研究2：风力发电
4.2.5案例研究3：采用异步发电机的风力发电
4.2.6案例研究4：旅馆光伏发电
4.2.7最小用电量
4.3过载：冗余和环网运行
4.3.1配电网的冗余
4.3.2环网运行
4.3.3环网运行的冗余
4.4损耗
4.4.1案例研究1：恒定发电
4.4.2案例研究2：风力发电
4.5增加承载容量
4.5.1增加负荷容量
4.5.2建造新的线路
4.5.3联动跳闸策略
4.5.4高级保护策略
4.5.5能量管理系统
4.5.6电力电子方式
4.5.7需求控制
4.5.8基于风险的方法
4.5.9增加可再生能源发电的优先级
4.5. 10动态承载
第5章电压幅值变化
5.1分布式发电的影响
5.2电压裕量和承载容量
5.2.1配电网中的电压控制
5.2.2由于分布式发电造成的电压上升
5.2.3承载容量
5.2.4异步发电机
5.2.5通过测量确定承载容量
5.2.6不通过测量来估计承载容量
5.2.7过电压极限的选择
5.2.8承载容量的分配
5.3设计馈线
5.3.1基本设计原则
5.3.2术语
5.3.3沿中压馈线的独立发电机
5.3.4低压馈线
5.3.5串联和并联补偿
?5.4 -种电压变化的数值方法
5.4.1两级电压抬升实例
5.4.2两级电压抬升的通用公式
5.4.3单级电压抬升
5.4.4微型发电
5.5采用带线降补偿器的变压器抽头
5.5.1只有一条单独馈线的变压器
5.5.2增加一台发电机
5.5.3承载容量的计算
5.5.4从相同变压器中接出多条馈线
5.6设计配电馈线采用的概率统计方法
5.6.1对概率统计方法的需要
5.6.2所研究的系统
5.6.3概率密度函数和概率分布函数
5.6.4随机变量的分布函数
5.6.5平均值和标准方差
5.6.6正态分布
5.6.7通过测量实现的概率统计计算
5.6.8发电量恒定的发电
5.6.9加入风力发电
5.7利用统计方法来计算承载容量
5.8增加承载容量
5.8.1新型或更硬的馈线
5.8.2电压控制的其他方法
5.8.3准确测量电压幅值变化
5.8.4允许更高的过电压
5.8.5对于过电压的基于风险的方法
5.8.6过电压保护
5.8.7过电压缩减
5.8.8动态电压控制
5.8.9补偿发电机的电压变化
5.8. 10可控制电压的分布式发电
5.8. 11协同电压控制
5.8. 12增加最小负荷
第6章电能质量干扰
6.1分布式发电的影响
6.2快速的电压波动
? 6.2.1风力发电系统能量的快速波动
6.2.2光伏发电系统的快速波动
6.2.3快速电压变化
6.2.4很短的变化
6.2.5电压波动的扩散
6.3电压不平衡
6.3.1 比较虚弱的输电系统
6.3.2强健的配电网系统
6.3.3大型单相发电机
6.3.4多台单相发电机
6.4低频谐波一
6.4.1风力发电：异步发电机
6.4.2有电力电子接口的发电机
6.4.3同步发电机
6.4.4测量实例
6.4.5谐波谐振
6.4.6更弱的输电网
6.4.7更强的配电网
6.5高频畸变
6.5.1单台发电机的谐波发射
6.5.2低于和高于2kHz的分组
6.5.3低于和高于2kHz的极限值
6.6电压跌落
6.6.1同步电机：平衡电压跌落
6.6.2同步电机：不平衡电压跌落 一
6.6.3异步发电机和不平衡电压跌落
6.7增加承载容量
6.7.1加强电网
6.7.2发电机的发射限制
6.7.3对其他用户造成的发射进行限制
6.7.4更高的干扰水平
6.7.5无源谐波滤波器
6.7.6电力电子变换器
6.7.7降低电压跌落次数
6.7.8宽频和高频畸变
第7章保护
7.1 分布式发电的影响
7.2过电流保护
7.2.1上游和下游故障
7.2.2承载容量
7.2.3熔断器．重合器协同工作
7.2.4反时限过电流保护
7.3计算故障电流
7.3.1上游故障
7.3.2下游故障
7.3.3异步发电机、电力电子装置和电动机负荷
7.4承载容量的计算
7.5母线保护
7.6过大的故障电流
7.7发电机保护
7.7.1 -般要求
7.7.2故障电流不足
7.7.3不可控孤岛运行
7.7.4孤岛检测
7.7.5孤岛运行的谐波谐振
7.7.6协同保护
7.8增加承载容量
7.8.1专用馈线
7.8.2增加发电机阻抗
7.8.3发电机跳闸
7.8.4时间，电流设定
7.8.5增加额外断路器
7.8.6方向保护
7.8.7差动或距离保护
7.8.8先进的保护方案
7.8.9孤岛保护
第8章输电系统的运行
8.1分布式发电的影响
8.2输电系统运行的基本原则
8.2.1运行储备和（N-l）准则
8.2.2不同类型的储备
8.2.3 自动或手动二次控制
8.3频率控制，平衡和储备
8.3.1储备需求
8.3.2 -次控制和储备
8.3.3二次控制和储备
8.3.4三次控制和储备
8.3.5减少发电量对储备的影响
8.4发电量和用电量的预测
8.5停电恢复
8.6电压稳定
8.6.1短期电压稳定
8.6.2长期电压稳定
8.7动能和惯性常数
8.8频率稳定性
8.9功角稳定性
8.9.1单一区域对无穷大电网
8.9.2分布式发电的影响：故障前
8.9.3分布式发电的影响：故障中
8.9.4分布式发电的影响：临界故障切除时间
8.9.5分布式发电的影响：故障后
8.9.6分布式发电的影响：输入区域
8. 10故障穿越
8. 10.1背景
8. 10.2历史事件
8. 10.3抗干扰要求
8. 10.4实现故障穿越
8. 11存储
8. 12高压直流输电与柔性交流输电系统
8. 13增加承载容量
8. 13.1储备的替代计划
8. 13.2增加传输容量
8. 13.3大规模储能
8. 13.4分布式发电作为储备
8. 13.5用电作为储备
8. 13.6对分布式发电的要求
8. 13.7无功功率控制
8. 13.8概率方法
8. 13.9分布式发电标准模型的发展
第9章总结
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式发电接入电力系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Delphi6分布式应用系统开发
PARTⅠ 分布式应用的基础理论
第1章 分布式应用的概念
……
PARTⅡ 开发SOCKETS通信应用
第4章 Sockets基本概念
……
PARTⅢ 使用FastNet组件开发Internet应用
第9章 FastNet组件概述
……
PARTⅣ 开发Web服务器应用
第14章 Web服务器应用概述
……
PARTⅤ 开发基于CORBA的分布式应用
第21章 CORBA原理概述
……
PARTⅥ 开发基于COM/COM+的分布式应用
第26章 COM/DCOM原理概述
……
PARTⅦ 开发多层数据库应用
第34章 多层数据库应用开发概述
……
附录A 名词与术语索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Delphi6分布式应用系统开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式虚拟现实技术及其应用
一、虚拟现实技术概论
二、计算机立体显示技术
三、虚拟现实系统高级建模技术
四、虚拟现实建模技术基础--NURBS和LOD
五、基于图象的绘制技术
六、生成真实感图形的全局光照模型解决方案
七、虚拟现实系统的纹理贴图技术
八、虚拟现实系统的交互技术
九、虚拟现实在通讯领域的应用
十、虚拟建筑环境
十一、虚拟现实技术在仿真中的应用

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式虚拟现实技术及其应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式数据库
第一章 概述
1?1 分布式数据库系统定义
1?2 分布式数据库系统的特点
1?3 分布式数据库系统的环境
1?4 分布式数据库系统的分类及问题
1?4?1 分布式数据库系统的分类
1?4?2 异构分布式数据库系统的问题
1?4?3 同构分布式数据库系统的问题
1?4?4 语言转换
1?5 分布式数据库系统的研究现状及应用
第二章 分布式数据库系统体系结构
2?1 分布式数据

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式数据库
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式数据库技术
第1章  概论
1. 1  问题背景
1. 1. 1  数据分布的需求
1. 1. 2  异构环境中数据集成的需求
1. 1. 3  信息系统集成的需求

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式数据库技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式水文模型EasyDHM
前言
1 分布式水文模型研究综述
1.1 水文模型的发展历程
1.2 分布式水文模型技术支撑
1.3 水文模型的分类
1.4 分布式水文模型研究进展
1.5 分布式水文模型的应用领域
1.6 典型分布式水文模型
1.7 分布式水文模型存在的主要问题
1.8 分布式水文模型发展趋势
1.9 分布式水文模型相关软件系统
2 流域水循环模拟模型体系
2.1 流域水循环系统及其划分
2.2 流域水循环模拟面临的问题及求解模型体系
2.3 结论
3 分布式水循环模拟模型Easy DHM理论方法
3.1 Easy DHM模型框架
3.2 Easy DHM模型空间结构及空间单元划分
3.3 Easy DHM模型输入数据空间离散
3.4 Easy DHM水循环过程模拟
3.5 Easy DHM模型参数推求
3.6 Easy DHM参数识别
3.7 Easy DHM模型建模流程
3.8 小结
4 基于DEM的水文分析技术
4.1 数字高程模型（DEM）
4.2 基于DEM的水文分析
4.3 结论
5 分布式水文模型子流域划分方法
5.1 水文模型空间离散方法
5.2 子流域划分方法
5.3 通用复杂流域／区域的子流域划分方法PGSDM
5.4 汉江流域应用实例
5.5 南水北调中线受水区应用实例
5.6 松辽流域应用实例
5.7 小结
6 分布式水文模型气象数据时空展布技术
6.1 空间展布方法
6.2 时间插值方法
6.3 实例应用
6.4 结论
7 分布式水文模型参数识别及率定方法
7.1 水文模型参数敏感性分析方法综述
7.2 水文模型参数率定方法综述
7.3 水文模型参数不确定性研究进展
7.4 LH-OAT方法及SCE-UA方法在Auto WEP模型中的应用
7.5 MOSCEM-UA方法在Easy DHM模型中的应用
7.6 NSGAII方法在Easy DHM模型中的应用
8 Easy DHM模型在汉江流域的应用
8.1 流域概况
8.2 基础数据准备
8.3 流域的空间离散
8.4 气象要素空间展布
8.5 模型参数率定
8.6 模型验证期模拟结果分析
8.7 气候变化条件及人类活动影响下汉江上游径流响应情况分析
8.8 小结
9 Easy DHM模型在南水北调中线受水区的应用
9.1 南水北调中线受水区概况
9.2 南水北调中线受水区模拟范围的确定
9.3 基础数据准备
9.4 南水北调中线受水区分布式水文模型建立
9.5 结论
10 Easy DHM模型在嫩江洪水预报中的应用
10.1 洪水预报技术发展综述
10.2 洪水预报误差
10.3 洪水预报实时校正技术
10.4 洪水预报研究展望
10.5 Easy DHM模型在嫩江洪水预报中的应用
11 Easy DHM模型在珠江典型喀斯特流域的应用
11.1 概述
11.2 研究区概况
11.3 喀斯特流域水文模拟方法
11.4 基础数据准备
11.5 Easy DHM模型构建
11.6 本章小结
12 Easy DHM分布式水文模型软件系统——MW Easy DHM
12.1 MW Easy DHM系统开发
12.2 MW Easy DHM系统主要功能
12.3 本章小结
13结语
13.1 小结
13.2 需要进一步研究的问题
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式水文模型EasyDHM
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式能源与热电冷联产
前言
第一章 概述
第一节 分布式能源系统
第二节 热电冷联产系统
参考文献
第二章 分布式供能技术
第一节 基于化石燃料的分布式供能技术
第二节 基于可再生能源的分布式供能技术
第三节 基于混合能源的分布式供能技术
参考文献
第三章 分布式能源系统综合优化技术
第一节 制冷与热泵技术
第二节 蓄能技术
第三节 多种能源系统整合优化
第四节 分布式能源与大规模电动汽车互动优化
第五节 网络式能源系统
第六节 分布式供能系统对配电网的影响
参考文献
第四章 热电冷联产
第一节 热电冷联产设备选型及运行维护
第二节 热电冷联产系统综合评估
第三节 热电冷联产案例分析
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式能源与热电冷联产
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式微服务架构：原理与实战
目录
第1章 从架构演进启程 1
1.1 水平分层架构 1
1.1.1 概述 1
1.1.2 MVC架构/水平分层架构 2
1.2 SOA服务化架构 4
1.2.1 SOA概述 5
1.2.2 SOA的特征 5
1.2.3 SOA面临的问题 5
1.3 分布式微服务架构 5
1.3.1 微服务概述 5
1.3.2 SOA与微服务 6
1.3.3 微服务架构的特点 6
1.3.4 微服务架构的缺点 7
1.3.5 微服务架构全景图 7
1.3.6 微服务类型 9
1.3.7 微服务拆分原则与步骤 9
第2章 微服务开发框架 11
2.1 环境准备 11
2.1.1 安装JDK 11
2.1.2 安装 Intellij IDEA 14
2.1.3 安装 Apache Maven 14
2.2 一分钟快速搭建Spring Boot项目 15
2.2.1 使用Spring Initializr新建项目 15
2.2.2 测试 18
2.3 Spring Boot简单介绍 18
2.3.1 Spring Boot核心功能及特性 19
2.3.2 Spring Boot的缺点 20
2.4 Spring Boot目录介绍 20
2.4.1 Spring Boot工程目录 20
2.4.2 Spring Boot入口类 21
2.4.3 Spring Boot测试类 22
2.4.4 pom文件 23
2.5 Spring Boot生产级特性 24
2.5.1 应用监控 24
2.5.2 健康检查 28
2.5.3 跨域访问 29
2.5.4 外部配置 30
第3章 分布式RPC框架 31
3.1 RPC框架概述 31
3.1.1 定义 31
3.1.2 RPC核心组件 31
3.1.3 RPC调用过程 32
3.1.4 RPC框架调用分类 33
3.1.5 RPC框架性能 35
3.1.6 RPC框架与分布式服务框架 35
3.2 RPC框架 36
3.2.1 RMI远程方法调用 36
3.2.2 Thrift 37
3.2.3 Hessian 38
3.2.4 Avro-RPC 38
3.2.5 gRPC 38
3.2.6 其他RPC框架 39
第4章 序列化与反序列化 40
4.1 序列化与反序列化 40
4.1.1 序列化/反序列化概念 40
4.1.2 序列化/反序列化特性 41
4.2 常用序列化框架 41
4.2.1 Java默认序列化 41
4.2.2 XML序列化框架 46
4.2.3 JSON序列化框架 48
4.2.4 ProtoBuf序列化框架 50
第5章 微服务底层通信与协议 54
5.1 Java网络通信 54
5.1.1 传统BIO编程 54
5.1.2 伪异步I/O编程 60
5.1.3 NIO编程 62
5.2 Netty框架 78
5.2.1 Netty概述 78
5.2.2 第一个Netty应用程序 78
5.2.3 Netty架构设计 84
5.3 分布式服务框架协议 89
5.3.1 主流公有协议 89
5.3.2 私有协议设计 90
第6章 服务路由与负载均衡 94
6.1 服务路由概述 94
6.1.1 定义 94
6.1.2 服务信息存放方式 94
6.2 服务路由概述 95
6.2.1 定义 95
6.2.2 负载均衡的实现 95
6.2.3 负载均衡算法 98
第7章 微服务注册中心 103
7.1 微服务注册中心 103
7.1.1 注册中心几个概念 103
7.1.2 注册中心 104
7.2 ZooKeeper实现服务注册中心 104
7.2.1 ZooKeeper概述 104
7.2.2 ZooKeeper的原理 105
7.2.3 ZooKeeper的安装 106
7.2.4 ZooKeeper搭建集群环境 109
7.2.5 ZooKeeper集群总体架构 110
7.2.6 命令行客户端zkCli.sh 112
7.2.7 ZkClient连接ZooKeeper 116
7.2.8 ZooKeeper实现服务注册与发现 120
第8章 微服务框架服务调用与容错 122
8.1 服务调用概述 122
8.2 服务调用方式 123
8.2.1 同步服务调用 123
8.2.2 异步服务调用 125
8.2.3 并行服务调用 130
8.2.4 泛化调用 132
第9章 分布式微服务封装与部署 133
9.1 微服务封装技术 133
9.1.1 Docker概述 133
9.1.2 Docker的基本概念 135
9.1.3 Docker架构 135
9.1.4 Docker的安装 137
9.1.5 Docker的常用命令 138
9.1.6 制作镜像 142
9.1.7 使用Dockerfile构建镜像 144
9.1.8 Spring Boot集成Docker 147
9.2 微服务部署概述 150
9.2.1 蓝绿部署 150
9.2.2 滚动发布 152
9.2.3 灰度发布/金丝雀部署 154
第10章 分布式服务限流 155
10.1 服务限流概述 155
10.1.1 限流定义 155
10.1.2 限流算法 155
10.2 限流设计 157
10.2.1 限流设计 157
10.2.2 分级限流 158
第11章 服务降级、熔断、调度 159
11.1 服务降级概述 159
11.2 服务降级方式 159
11.2.1 服务降级开关 159
11.2.2 自动降级 160
11.2.3 读服务降级 161
11.2.4 写服务降级 161
11.3 服务容错策略 161
11.3.1 失败转移（Failover） 162
11.3.2 失败自动恢复（Failback） 162
11.3.3 快速失败（Failfast） 162
11.3.4 失败缓存（FailCache） 162
11.4 Hystrix降级、熔断 162
11.4.1 Hystrix简介 162
11.4.2 Hystrix实现降级/熔断 164
11.5 服务优先级设计 165
11.5.1 服务实例数量调整 165
11.5.2 加权优先级队列 166
11.5.3 线程调度器 167
第12章 服务版本与服务发布 168
12.1 概述 168
12.2 服务版本概述 168
12.2.1 概述 168
12.2.2 Snapshot和Release 169
12.3 服务发布 169
12.3.1 概述 169
12.3.2 服务发布方式 170
第13章 分布式微服务日志中心 173
13.1 分布式日志概述 173
13.1.1 结构化日志/非结构化日志 173
13.1.2 日志类型 175
13.2 日志框架 175
13.2.1 JDK Logger 175
13.2.2 Apache Commons Logging 177
13.2.3 Log4j/Log4j 2 177
13.2.4 Spring Boot集成Log4j 179
13.2.5 Docker日志框架 181
13.2.6 Linux系统Syslog 183
13.3 搭建日志中心 183
13.3.1 ELK概述 183
13.3.2 Elasticsearch日志存储 184
13.3.3 Logstash日志收集 189
13.3.4 Fluentd日志收集 191
13.3.5 Kibana日志查询 193
13.3.6 ELK架构与Docker整合 194
13.3.7 ELK架构原理 195
第14章 分布式微服务监控 197
14.1 分布式服务架构监控 197
14.1.1 监控的价值 197
14.1.2 监控的完整体系 197
14.1.3 微服务监控类型 198
14.1.4 Spring Boot应用监控 198
14.1.5 Spring Boot Admin监控系统 201
14.2 搭建系统监控中心 206
14.2.1 概述 206
14.2.2 时序数据收集系统：cAdvisor 206
14.2.3 时序数据存储系统：InfluxDB 209
14.2.4 时序数据分析系统：Grafana 212
14.2.5 集成InfluxDB + cAdvisor + Grafana 214
第15章 分布式微服务配置中心 218
15.1 配置中心概述 218
15.1.1 概述 218
15.1.2 配置中心解决问题 218
15.1.3 全局配置 219
15.1.4 配置中心 221
15.2 Spring Cloud Config 223
15.2.1 概述 223
15.2.2 Spring Cloud Config快速入门 224
第16章 分布式微服务存储与解耦 232
16.1 分布式数据库架构 232
16.1.1 分库 232
16.1.2 分表 233
16.1.3 水平切分的方式 233
16.1.4 垂直切分的方式 235
16.1.5 分组 235
16.1.6 Mycat分库分表实战 236
16.1.7 Spring+MyBatis+Mycat快速体验 240
16.2 分布式事务 249
16.2.1 数据库事务 249
16.2.2 分布式事务 249
16.2.3 CAP定理 250
16.2.4 BASE理论 251
16.2.5 两阶段提交（2PC） 252
16.2.6 补偿事务（TCC） 252
16.2.7 后置提交 254
16.2.8 本地消息表（异步确保） 255
16.3 分布式缓存架构 256
16.3.1 Memcache与Redis 256
16.3.2 进程内缓存 257
16.3.3 Redis单节点安装 259
16.3.4 Redis持久化策略 260
16.3.5 Redis主从复制模式 263
16.3.6 Redis哨兵模式 266
16.3.7 Redis哨兵模式安装部署 271
16.3.8 Redis集群模式 277
16.3.9 Redis集群环境搭建 280
16.3.10 Redis缓存穿透和雪崩 288
16.4 微服务解耦 294
16.4.1 服务解耦概述 294
16.4.2 Kafka介绍 295
16.4.3 Kafka安装 299
16.4.4 Kafka搭建集群环境 300
16.4.5 Kafka Manager的安装 301
16.4.6 Kafka常用命令 301
16.4.7 Spring Boot集成Kafka 311
16.5 分布式服务Session 315
16.5.1 Session与Cookie 315
16.5.2 Session一致性问题 315
16.5.3 Session同步 316
第17章 分布式微服务测试 318
17.1 分布式微服务测试 318
17.1.1 概述 318
17.1.2 微服务测试 319
17.2 Spring Boot单元测试 321
17.3 Mockito/PowerMockito测试框架 323
17.3.1 Mockito概述 323
17.3.2 Mockito简单实例 324
17.3.3 PowerMock概述 327
17.3.4 PowerMockito简单实例 327
17.4 H2内存型数据库 330
17.4.1 H2概述 330
17.4.2 Spring Boot集成H2 330
17.5 REST API测试 333
17.5.1 Postman概述 333
17.5.2 Postman简单使用 333
17.6 性能测试 336
17.6.1 ab概述 336
17.6.2 ab测试 336
17.6.3 其他性能测试工具 338
第18章 分布式微服务架构经典案例 341
18.1 微服务架构案例 341
18.1.1 概述 341
18.1.2 微服务架构平台选择 342
18.1.3 微服务接口类型 342
18.1.4 微服务类型 343
18.2 分布式服务框架Dubbo 344
18.2.1 Dubbo概述 344
18.2.2 Dubbo原理 344
18.3 Spring Boot + Spring Cloud解决方案 345
18.3.1 Spring Boot概述 345
18.3.2 Spring Cloud概述 345
18.3.3 微服务、Spring Boot、Spring Cloud的关系 347
18.3.4 Spring Cloud与Dubbo的优劣 348
18.4 Spring Boot + Kubernetes + Docker解决方案 348
18.4.1 Docker概述 348
18.4.2 Kubernetes概述 349
18.4.3 Kubernetes的基本概念 349
18.4.4 Kubernetes的使用 352
18.4.5 Kubernetes的架构 356
18.4.6 Kubernetes集群监控 360
18.4.7 Kubernetes集群日志管理 360
18.4.8 Kubernetes解决方案 360
参考文献 362
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式微服务架构：原理与实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分形图形分布式并行生成技术
第1章&nbsp; 绪论&nbsp;11.1&nbsp; 概述&nbsp;21.2&nbsp; 分布式分形图形处理的研究内容&nbsp;31.3&nbsp; 分布式分形图形处理的研究意义&nbsp;41.4&nbsp; 分布式分形图形处理系统的定义&nbsp;51.5&nbsp; 分布式分形图形处理的研究概况&nbsp;51.5.1&nbsp; 消息传递环境&nbsp;51.5.2&nbsp; 分

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分形图形分布式并行生成技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>多层分布式数据库实战
第1章  Delphi多层分布式数据库应用初步
l. l  数据库应用的结构模型概述
1. 1. 1  数据库应用的任务切割
l. 1. 2  单层. 两层和三层的数据库应用
1. 1. 3  迎接多

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>多层分布式数据库实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Delphi分布式多层应用程序开发
第一章 COM基础
第二章 利用ACTIVEX开发以浏览器为界面的系统
第三章 DCOM和MTS
第四章 MIDAS开发
第五章 利用WEBBROKER编写基于WEB的应用
第六章 INTERNETEXPRESS编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Delphi分布式多层应用程序开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>并行与分布式可视化技术及应用
第1章 绪论
第2章 并行与分布式可视化基础
第3章 等值线和等值面生成技术及其并行算法
第4章 并行与分布式体绘制技术
第5章 向量场可视化技术
第6章 模块可视化环境及其并行与分布处理技术
第7章 可视化的典型应用
第8章 面向对象可视化
第9章 基于Web的可视化
第10章 虚拟现实
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>并行与分布式可视化技术及应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>DVENET分布式虚拟环境:863计算机专著 (平装)
前&nbsp;&nbsp;言
第一章&nbsp;分布式虚拟环境的发展
1.1&nbsp;分布式虚拟环境的发展变化
1.2&nbsp;几个重要的分布式虚拟环境&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
第二章&nbsp;DVENET&nbsp;研究计划&nbsp;
2.1&nbsp;研究背景和意义
2.2&nbsp;研究目

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>DVENET分布式虚拟环境:863计算机专著 (平装)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式发电系统中的光伏发电技术（第2版）
第2版前言
第1版前言
第1章绪论1
11分布式发电系统的研究概况1
111分布式发电系统的基本概念1
112分布式发电系统的发展现状2
12分布式发电系统中的光伏发电技术3
121我国太阳能资源及光伏发展潜力3
122分布式发电系统中光伏发电的关键技术5
13本书的主要内容6
第2章光伏发电基础8
21光伏电池的基本原理和等效电路8
211光伏效应8
212单体光伏电池的等效电路和电量方程8
213光伏电池阵列10
22光伏电池的数学物理模型和伏安特性曲线11
221光伏电池的数学物理模型11
222光伏电池的伏安特性曲线和填充因数12
23光伏电池的转换效率及其影响因素13
231光伏电池的转换效率13
232光谱响应13
233光照特性14
234温度特性15
235环境因素对光伏电池数学物理模型的修正15
24阴影条件下光伏阵列的输出特性16
241热斑现象分析17
242多峰现象分析18
243引起光伏阵列多峰输出特性的因素19
25光伏电池的分类22
251按结构分类23
252按材料分类23
26光伏系统的组成24
261独立光伏系统24
262并网光伏系统25
263光伏系统与分布式发电系统28
第3章光伏发电技术中的电力电子技术30
31DCDC变换电路的拓扑结构及控制策略30
311单象限直接DCDC变换电路30
312多象限直接DCDC变换电路34
313隔离型DCDC变换电路38
314DCDC变换电路的控制技术43
32DCAC变换电路的拓扑结构46
321逆变电路基本结构47
322高频链逆变器48
323多电平逆变器55
324逆变器的串联与并联61
33逆变器的调制技术62
331SPWM技术63
332空间矢量调制(SVM)技术72
333谐波注入PWM技术77
334优化PWM技术80
335多电平变流器和多重化变流器的PWM技术89
34并网光伏逆变器拓扑结构的新进展92
341并网光伏逆变器拓扑结构的发展现状92
342Z源逆变器93
343组合型逆变器98
第4章直流母线分布式光伏发电技术105
41直流母线分布式光伏发电系统的网络结构105
411微型直流光伏系统105
412独立直流光伏母线供电系统106
413并网混合系统107
42直流母线分布式光伏发电系统与交流电网的接口107
43直流母线分布式光伏发电系统的控制方法108
431下垂特性控制108
432电压水平信号法110
433直流母线信号法111
第5章交流母线分布式光伏发电技术113
51交流母线分布式光伏发电系统的网络结构113
52逆变器并网技术115
521光伏逆变器并网相关的国际标准115
522光伏并网逆变器的交流侧滤波器结构117
523光伏并网逆变器的控制模式118
524分布式光伏并网逆变器的功率调节技术121
53逆变器并联技术125
531逆变器并联的控制方法125
532逆变器并联的环流及其抑制131
533功率计算方法135
54逆变器控制策略138
541控制策略概述138
542坐标变换法线性控制139
543非坐标变换法线性控制145
544非线性控制154
545并网逆变器直流侧控制165
第6章光伏发电系统的最大功率点跟踪170
61光伏发电系统最大功率点跟踪技术的基本原理170
62恒定电压控制171
63最大功率点跟踪算法172
631扰动观察法172
632三点比较法175
633电导增量法177
634二次插值法179
635自适应模糊控制法181
64计及阴影的最大功率点跟踪方法182
641传统方法改进的MPPT技术183
642添加硬件电路实现的MPPT技术184
643智能算法185
第7章分布式光伏发电系统的储能后备元件及系统集成188
71蓄电池储能系统188
711铅酸蓄电池特性分析189
712蓄电池充放电控制方法191
713光伏系统中的充放电技术194
72超级电容储能系统196
73燃料电池后备系统197
731燃料电池的基本原理198
732燃料电池的输出特性198
733燃料电池的数学模型199
734燃料电池的控制实现200
74光伏发电系统集成202
741光伏发电系统集成概况202
742多端口DCDC变换器204
743SST单元介绍213
第8章分布式发电系统的综合管理217
81直流母线分布式发电系统的能量优化管理217
811DBS能量优化管理217
812变换器控制结构218
813控制实现220
82含光伏直流微电网系统综合管理221
821系统控制223
822独立运行模式与模式切换224
823变流器单元控制225
83直流混合网络能量的优化管理227
831数据中心电力系统能量优化管理227
832中心直流微电网的操作方式229
833自适应控制系统的设计232
第9章分布式光伏发电系统的其他关键技术235
91光伏并网逆变器的直流分量及共模漏电流问题235
911直流分量注入的危害、成因及其解决方法235
912共模漏电流的危害、成因及其解决方法240
92孤岛效应及其检测技术248
921并网逆变系统孤岛检测分析249
922无源检测方法250
923有源检测方法253
924混合孤岛检测方法256
93分布式发电系统的稳定性分析260
931阻抗分析研究261
932影响阻抗的因素262
933系统稳定性测量265
参考文献268
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式发电系统中的光伏发电技术（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式发电
原书前言
作者简介
第1章绪论 1
11电力系统发展概述 1
12分布式发电的价格和上网电价 3
13智能电网4
14发展分布式发电的原因5
15分布式发电技术的发展前景7
151未来常规经营模式7
152智能电网8
153并网优势8
16分布式发电与配电网9
17分布式发电对配电系统的技术影响10
171电网电压变化10
172电网故障电流水平增加12
173电能质量13
174保护13
175稳定性和故障穿越15
18分布式发电对配电系统的经济影响16
19分布式发电对输电系统的影响16
110分布式发电对集中式发电的影响16
参考文献17
第2章分布式发电站18
21概述18
22热电联产19
23可再生能源发电23
231小水电23
232风力发电25
233海上风电32
234太阳能光伏发电32
24总结37
参考文献38
第3章分布式发电及其并网接口39
31概述39
32分布式发电机组40
321同步发电机40
322异步发电机43
323双馈异步发电机49
324全功率变流器（FPC）接口的发电设备53
33系统分析55
331简单辐射式配电系统的潮流分析55
332网状配电系统的潮流分析57
333对称故障分析63
334不对称故障分析65
34案例分析71
341峰值负荷及最小负荷运行方式下的稳态电压分析71
342电磁暂态分析75
A31附录：不对称故障77
参考文献79
第4章故障电流和电气保护80
41引言80
42分布式发电机的故障电流81
421同步发电机82
422异步发电机84
423双馈异步发电机86
424通过电力电子变流器连接的发电机87
43故障限流器88
431电网解列88
432限流电抗器88
433限流熔断器88
434故障限流器89
44分布式发电的保护90
441发电设备内部故障保护92
442分布式发电机提供故障电流的配电网故障保护97
443孤岛效应和失电保护100
45分布式发电对现有配电网保护装置的影响101
451相过电流保护101
452方向过电流保护104
453阻抗继电器105
A 41附录105
参考文献106
第5章电力系统规划中分布式发电的集成109
51引言109
52分布式发电及供电裕度110
521常规热力发电系统的发电容量裕度110
522分布式发电的影响112
53分布式发电对网络设计的影响114
531传统配电网规划原则115
532分布式发电对网络安全贡献的评价方法115
533方法的应用120
参考文献121
第6章含分布式发电的配电网定价122
61引言122
62竞争环境下电网定价的主要目标123
63网络投资成本推动因素综述123
631网络规划标准124
632电压推动的网络支出124
633故障水平推动的网络支出125
634损耗推动的网络设计支出126
64配电系统使用费用评估（DUoS费用）126
641静态和动态网络定价的概念127
642分布式发电网络DUoS费用的分时电价特征127
643网络成本在用户中的分摊128
65含分布式发电的网络DUoS收费评估实例128
651简单双母线例子128
652多电压等级的例子132
参考文献138
第7章分布式发电和未来电网架构139
71引言139
72主动电网管理141
721发电机输出减少和特殊保护方案141
722动态线路输送容量142
723主动电网电压控制142
724集成广域主动电网管理143
725智能电表143
73虚拟电厂144
731虚拟的电厂144
732商业虚拟电厂146
733技术虚拟电厂147
74微电网148
741微电网的研究和示范项目149
742微电网控制152
743孤岛运行控制策略152
参考文献153
教程Ⅰ交流电力系统155
Ⅰ1引言155
Ⅰ2交流电流156
Ⅰ3电流和电压的方均根平均值156
Ⅰ4交流量的相量表示157
Ⅰ5交流电路的电阻、电感和电容159
Ⅰ51交流电路的电阻159
Ⅰ52交流电路的电感159
Ⅰ53交流电路的电容160
Ⅰ54R-L交流电路160
Ⅰ6交流电路的功率162
Ⅰ7三相电压发电165
Ⅰ8三相绕组的连接166
Ⅰ81星形联结166
Ⅰ82三角形联结167
Ⅰ9负荷连接168
Ⅰ10三相四线系统168
Ⅰ11三相三角形联结的三线制系统169
Ⅰ12三相系统的功率169
Ⅰ13习题172
Ⅰ14延伸阅读173
教程Ⅱ交流电机174
Ⅱ1引言174
Ⅱ2同步电机175
Ⅱ21结构和操作175
Ⅱ22电气和机械角度177
Ⅱ23等效电路178
Ⅱ24同步发电机的运行图180
Ⅱ25励磁系统181
Ⅱ3异步电机184
Ⅱ31结构与运行184
Ⅱ32稳态运行185
Ⅱ4习题190
Ⅱ5延伸阅读191
教程Ⅲ电力电子192
Ⅲ1引言192
Ⅲ2导体、绝缘体和半导体193
Ⅲ21导体193
Ⅲ22绝缘体193
Ⅲ23半导体194
Ⅲ3PN结195
Ⅲ4二极管196
Ⅲ5开关器件198
Ⅲ51电流型控制器件199
Ⅲ52电压型控制器件201
Ⅲ6电压型逆变器204
Ⅲ61单相电压型逆变器205
Ⅲ62三相电压型逆变器207
Ⅲ7问题208
Ⅲ8延伸阅读208
教程Ⅳ电力系统209
Ⅳ1引言209
Ⅳ2功率变压器211
Ⅳ3标幺制214
Ⅳ31功率变压器的标幺值215
Ⅳ32发电机215
Ⅳ33系统研究216
Ⅳ4对称分量法217
Ⅳ5问题220
Ⅳ6延伸阅读221
术语222
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式发电
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>移动云计算
译者序
原书序
原书前言
第1部分移动云的简介与背景知识
第1章动机
1.1引言
1.2从“大哥大”到智能手机
1.3移动连接的演进：从单一到多种空中接口设备
1.4网络演进：高级架构需求
1.5结论
参考文献
第2章移动云简介
2.1引言
2.2移动云定义
2.2.1移动云通用定义
2.2.2移动云定义：协作云
2.2.3移动云定义：资源云
2.2.4移动云定义：社交云
2.3移动云中的协作与认知
2.4移动云类型及相关协作方法
2.5协作与激励类型
2.5.1强制/自主协作
2.5.2利他协作
2.5.3利己协作
2.5.4社会协作
2.5.5嵌入式技术协作
2.6结论
参考文献
第3章移动云中的设备资源共享
3.1引言
3.2资源共享实例
3.3扬声器共享
3.4传声器共享
3.5图像传感器共享
3.6显示屏共享
3.7通用传感器共享
3.8键盘共享
3.9数据管道共享
3.10移动应用共享
3.11大容量存储器共享
3.12处理单元共享
3.13电池共享
3.14结论
参考文献
第2部分移动云的支撑技术
第4章无线通信技术
4.1引言
4.2蜂窝通信系统
4.3短距离通信技术
4.3.1蓝牙
4.3.2IEEE 802.11
4.4组合空中接口
4.5构建移动云
4.6结论
参考文献
第5章移动云的网络编码
5.1网络编码简介
5.2流间网络编码
5.3移动云中用户协作所需的流间网络编码
5.3.1模拟网络编码
5.3.2模拟网络编码与数字网络编码的对比
5.3.3媒体接入控制策略的影响
5.4流内网络编码
5.5移动云中用户协作所需的流内网络编码
5.5.1移动云的信息交换与信息播种
5.5.2移动云中的分布式存储
5.5.3移动云中的安全、隐私和数据完整性
5.6结论
参考文献
第6章移动云的形成和维护
6.1引言
6.2移动云形成阶段
6.3移动云的服务发现
6.4结论
参考文献
第3部分移动云的社会问题
第7章自然界的协作原则
7.1引言
7.2猎豹和鬣狗
7.3虎鲸（杀人鲸）
7.4吸血蝙蝠
7.5猴子
7.6囚徒困境
7.7结论
参考文献
第8章社会移动云
8.1引言
8.2不同形式的协同
8.3社交网络与移动云
8.3.1演进阶段Ⅰ：不可知时代
8.3.2演进阶段Ⅱ：移动网络支持社交网络
8.3.3演进阶段Ⅲ：深度整合：社交网络和移动网络的互相作用
8.4中继网络中的协作：一个简单实例
8.5结论
参考文献
第4部分绿色移动云
第9章绿色移动云：使移动设备更节能
9.1引言
9.2协作下载
9.2.1序贯本地交换的能耗
9.2.2并行本地交换的能耗
9.3协作流媒体
9.4不同方法之间的比较
9.5结论与展望
9.6网络运营商的能量增益
9.7结论
参考文献
第5部分移动云的应用
第10章移动云应用
10.1引言
10.2强制协作——覆盖网络
10.2.1由网络运营商提供的众包信息
10.2.2由制造商提供的众包信息
10.2.3由移动应用提供的众包信息
10.3技术支持协作——覆盖网络
10.4社交支持协作——覆盖网络
10.5利他主义——覆盖网络
10.6强制协作——直接移动云
10.7技术支持协作——直接移动云
10.7.1CoopLoc
10.7.2协作接入
10.8社交支持协作——直接移动云
10.8.1共享互联网连接
10.8.2共享应用
10.9利他主义——直接移动云
10.10业界活动
10.11结论
参考文献
第6部分移动云展望和结论
第11章愿景与展望
11.1关于移动云未来发展的见解
11.2移动云及相关技术的发展
11.2.1物联网
11.2.2机器对机器通信
11.2.3设备到设备技术
11.3移动云的潜在新应用
11.4资源共享成为社交互动的支柱之一：分享型经济的诞生
参考文献
附录英文缩略语
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>移动云计算
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式缓存
第 1部分 基本功能
第　1章 基于HTTP的内存缓存服务　3
1．1　缓存服务的接口　3
1．1．1　REST接口　3
1．1．2　缓存Set流程　5
1．1．3　缓存Get流程　6
1．1．4　缓存Del流程　7
1．2　Go语言实现　8
1．2．1　main包的实现　8
1．2．2　cache包的实现　9
1．2．3　HTTP包的实现　14
1．3　功能演示　19
1．4　与Redis比较　21
1．4．1　Redis介绍　21
1．4．2　redis-benchmark介绍　23
1．4．3　cache-benchmark介绍　24
1．4．4　性能对比　26
1．5　小结　30
第　2章 基于TCP的内存缓存服务　32
2．1　基于TCP的缓存协议规范　33
2．1．1　协议范式　33
2．1．2　缓存Set流程　35
2．1．3　缓存Get流程　36
2．1．4　缓存Del流程　36
2．2　Go语言实现　37
2．2．1　main函数的变化　37
2．2．2　TCP包的实现　38
2．2．3　客户端的实现　44
2．3　功能演示　45
2．4　性能测试　47
2．5　小结　48
第3章　数据持久化　50
3．1　RocksDB简介　50
3．2　RocksDB性能测试　51
3．2．1　基本读写性能　52
3．2．2　大容量测试　52
3．3　用cgo调用C++库函数　55
3．4　Go语言实现　58
3．4．1　main函数的实现　58
3．4．2　cache包的实现　59
3．5　功能演示　65
3．6　性能测试　67
3．7　小结　69
第　2部分 性能相关
第4章　用pipelining加速性能　73
4．1　pipelining原理　73
4．2　redis pipelining性能对比　75
4．3　Go语言实现　77
4．3．1　main包的实现　77
4．3．2　cacheClient包的实现　86
4．4　性能测试　97
4．5　小结　99
第5章　批量写入　101
5．1　批量写入能够提升写入性能的原理　101
5．2　RocksDB批量写入性能测试　102
5．3　Go语言实现　103
5．4　性能测试　108
5．5　小结　112
第6章　异步操作　113
6．1　异步操作能够提升读取性能的原理　114
6．2　Go语言实现　117
6．3　性能测试　122
6．4　小结　127
第3部分　服务集群
第7章　分布式缓存　131
7．1　为什么我们需要集群服务　131
7．2　负载均衡和一致性散列　133
7．3　获取节点列表的接口　140
7．4　Go语言实现　140
7．4．1　main函数的实现　140
7．4．2　cluster包的实现　141
7．4．3　HTTP包的实现　145
7．4．4　TCP包的实现　147
7．5　功能演示　149
7．6　小结　152
第8章　节点再平衡　154
8．1　节点再平衡的技术细节　154
8．2　节点再平衡的接口　155
8．3　Go语言实现　155
8．3．1　HTTP包的实现　155
8．3．2　cache包的实现　157
8．4　功能演示　162
8．5　小结　164
第9章　缓存生存时间　166
9．1　缓存生存时间的作用　166
9．2　Go语言实现　167
9．2．1　main函数的实现　167
9．2．2　cache包的实现　168
9．3　功能演示　172
9．4　小结　174
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式缓存
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Unity与C++网络游戏开发实战：基于VR、AI与分布式架构
序言
前言
第1篇 Unity基础（客户端）
第1章 Unity介绍与相关环境的搭建和调试 2
1.1 Unity引擎介绍 2
1.1.1 Unity3D引擎部分 2
1.1.2 Unity3D编辑器部分 3
1.2 Unity引擎发展 5
1.3 Unity引擎应用场景和使用范围介绍 5
1.4 Unity软件安装 7
1.5 Unity Windows环境的安装和搭建 9
1.6 Unity Android环境的安装和搭建 11
1.7 Unity授权 15
1.8 Unity服务 16
第2章 编写Hello World与仿真系统体验 18
2.1 创建第一个空的工程 18
2.2 创建第一个脚本程序 20
2.3 编写第一个Hello Word程序 21
2.4 编译输出第一个程序 22
2.5 运行Hello World 23
2.6 打开仿真程序Demo 23
2.7 这是一个很好玩的仿真系统 25
2.8 进入训练场准备体验训练操作 25
2.9 控制人物行走 26
2.10 开动第一辆汽车 27
2.11 完成第一个仿真任务 27
2.12 本章小结与分析 28
第3章 Unity游戏开发语言 29
3.1 C#语言介绍 29
3.2 C#常用数据结构介绍 31
3.2.1 ArrayList链表结构 31
3.2.2 泛型List 31
3.2.3 Stack栈 32
3.2.4 队列Queue 33
3.2.5 字典Dictionary 34
3.3 C#的接口与继承 35
3.3.1 实现继承和接口继承 35
3.3.2 多重继承 35
3.3.3 结构的继承 35
3.4 C#的委托 37
3.5 C#多线程使用介绍 38
3.6 C#的反射机制 39
3.7 Unity中使用泛型 42
3.8 Unity中使用协程 42
3.9 Unity的序列化和网络协议库介绍 45
3.10 Unity中使用CLR进行Native交互 46
3.11 Unity中使用热更新语言Lua 47
3.12 本章小结与分析 50
第4章 在Unity中使用图形学知识 51
4.1 3D数学基本知识在游戏中的应用 51
4.2 三维坐标系 52
4.3 顶点坐标变换 53
4.3.1 向量是什么 53
4.3.2 矩阵是什么 54
4.3.3 如何操作向量 55
4.3.4 如何处理点或者向量与矩阵的乘法 55
4.3.5 点和向量通过矩阵的变换 56
4.4 光照与材质 58
4.4.1 什么是Shader的基本光照模型 59
4.4.2 什么是光照模型 59
4.4.3 什么是材质 61
4.5 Unity引擎中的渲染管线流程 67
4.6 Unity中实现模型的缩放和旋转等程序处理 70
4.7 Unity中计算射线相关的程序处理 74
4.8 Unity中制作一个简单的渲染特效 77
4.9 本章小结与分析 84
第5章 Unity编辑器的使用 86
5.1 创建一个空的工程 86
5.2 编辑器界面布局介绍 88
5.3 编辑器的常用功能介绍 89
5.4 编辑器模型编辑——旋转控制第一个模型 95
5.5 编辑器动作骨骼编辑——让人物动起来 96
5.6 编辑器光照和相机的编辑——让人物更真实 98
5.7 编辑器粒子特效编辑——让环境更绚丽 101
5.8 编辑器场景编辑——创建简单的战场 104
5.9 编辑器地形和光照贴图烘焙——让战场真实起来 105
5.10 编辑器遮挡剔除——提高战场的运行效率 107
5.11 编辑器资源管理——让工程更容易管理 109
5.12 编辑器控制台和调试——输出调试信息 110
5.13 编辑器资源商店和常用插件 111
5.14 编辑器材质编辑——让车辆变化一下样式 114
5.15 编辑器物理系统介绍——让人和车辆发生碰撞 116
5.16 本章小结与分析 118
第2篇 Unity实战（客户端）
第6章 虚拟仿真训练系统的架构和模块 122
6.1 什么是虚拟仿真训练 122
6.1.1 战斗模拟仿真训练 122
6.1.2 车辆仿真和工业操作 123
6.2 物理架构介绍——虚拟仿真训练系统 123
6.3 使用态势端发布授权任务 126
6.4 将分队长学员配置加入授权任务 127
6.5 启动仿真任务——完成一次美妙的任务体验 128
6.6 本章小结与分析 130
第7章 人物资源编辑与程序开发 132
7.1 模型资源的导入和整理编辑 132
7.2 人物动作资源的编辑和管理 134
7.3 数据资源的导入和整理 137
7.4 人物的控制和脚本程序开发 141
7.5 人物的行为状态机开发 147
7.6 人物特效的控制和状态交互 150
7.7 人物的物理状态和碰撞瞄准的程序交互 151
7.8 人物的属性和程序接口开发 154
7.9 在场景中运行人物资源和调试程序 158
7.10 本章小结与分析 159
第8章 场景资源编辑与程序开发 161
8.1 场景资源的导入和整理管理 161
8.2 场景数据资源的导入和场景程序管理 162
8.3 地形的编辑和程序相关功能开发 169
8.4 添加碰撞体树木和非碰撞体植被 172
8.5 创建光源和阴影渲染 174
8.6 添加场景静态物体和动态物体 176
8.7 添加场景水的插件并使用代码集成 182
8.8 添加天气系统插件并集成代码系统 187
8.9 添加场景道路插件并制作道路 192
8.10 添加天空盒和雾态效果 194
8.11 场景预览和渲染效率优化 196
8.12 场景系统加载切换和系统程序开发 198
8.13 本章小结与分析 202
第9章 资源组件和交互物品开发 203
9.1 资源组件的导入和整理管理 203
9.2 资源物品的数据导入和整理管理 205
9.3 AssetBundle的资源组成和功能API 207
9.4 开发自己的AssetBundle打包工具插件 208
9.5 加载和管理AssetBundle资源 212
9.6 车辆动力系统的插件使用和系统集成开发 216
9.7 关于飞行器直升机的开发和使用 223
9.8 地雷组件的开发和功能交互 225
9.9 物品管理器系统开发 230
9.10 本章小结与分析 235
第10章 NGUI组件开发和操作交互开发 236
10.1 NGUI插件介绍和导入工程 236
10.2 NGUI图集的使用和制作 237
10.3 NGUI图集的优化和DrawCall的优化策略 239
10.4 NGUI的底层实现原理和分析 240
10.5 UILable的使用 242
10.6 UISprite的使用 243
10.7 UIPanel的使用 244
10.8 UIScrollView的使用 245
10.9 UIButton的使用 247
10.10 UIRoot和UICamera的自适应 250
10.11 打造UI面向对象的动态加载和管理 251
10.12 登录UI功能开发 257
10.13 大厅任务信息系统UI功能开发 261
10.14 战场场景中主视角UI系统功能开发 268
10.15 VR开发——VR可以使用的VRGUI 276
10.16 本章小结与分析 277
第3篇 C++网络开发基础（服务器）
第11章 C++语言基础 280
11.1 C++简介 280
11.2 C++基本语法 281
11.3 C++数据结构 283
11.4 C++变量类型 289
11.5 C++修饰符类型 290
11.6 C++存储类 291
11.7 C++运算符和运算方式 294
11.8 C++函数 297
11.9 C++数组和高级功能 300
11.10 C++指针和高级功能 301
11.11 C++引用和常用方式 303
11.12 C++类和对象 305
11.13 C++继承和多态 307
11.14 C++接口和抽象 309
11.15 C++文件和流的处理 311
11.16 C++ STL库介绍 314
11.17 本章小结与分析 319
第12章 C++网络编程基础 321
12.1 Socket套接字 321
12.2 套接字寻址方式 326
12.3 Winsocket网络程序开发流程 328
12.4 在Visual Studio中创建网络工程 330
12.5 Winsocket编程准备 331
12.6 基于TCP的Socket编程 332
12.7 基于UDP的Socket编程 336
12.8 本章小结与分析 343
第13章 多线程和异步套接字 345
13.1 C++多线程开发 345
13.2 C++多线程互斥对象和同步 347
13.3 C++进程间通信 350
13.4 C++设置异步I/O的模式和方法 356
13.5 本章小结与分析 358
第14章 MySQL数据库的使用 359
14.1 MySQL数据库介绍和使用范围 359
14.2 安装MySQL数据库 360
14.3 MySQL可视化管理工具的使用 362
14.4 使用C++连接MySQL数据库 364
14.5 SQL语句和语法 369
14.6 MySQL备份导出数据和导入转移数据 371
14.7 本章小结与分析 374
第15章 网络协议Protobuf的使用 376
15.1 什么是Protobuf 376
15.2 Protobuf的功能是什么 378
15.3 Protobuf序列化的原理是什么 385
15.4 如何编写Protobuf的.proto文件 387
15.5 如何编译和生成Protobuf的编译程序 389
15.6 使用Protobuf协议制作一段网络小程序 392
15.7 本章小结与分析 399
第4篇 C++网络开发实战（服务器）
第16章 设计架构简单的互动服务器体系 402
16.1 Visio：一个绘制架构图的软件 402
16.2 如何使用图和连接线来表示架构 404
16.3 需要哪些服务来构建整个服务体系 406
16.4 登录服务器（LoginServer） 407
16.5 网关服务器（GateServer） 410
16.6 中心服务器（CenterServer） 413
16.7 战场服务器（BattleServer） 414
16.8 本章小结与分析 418
第17章 开发登录服务器LoginServer 420
17.1 登录服务器的作用 420
17.2 使用Protobuf生成登录授权文件和协议 421
17.3 创建LoginServer网络会话层底层模块 429
17.4 创建LoginServer服务逻辑模块 436
17.5 导入LoginServer的Protobuf协议 440
17.6 客户端Protobuf协议的导入和使用 443
17.7 从客户端登录到授权的逻辑处理过程 445
17.8 启动LoginServer，完成第一次授权登录 449
17.9 Redis缓存存储和信息处理 450
17.10 本章小结与分析 452
第18章 开发网关服务器GateServer 453
18.1 网关服务器及其作用 453
18.2 创建GateServer的框架主程序 454
18.3 创建网关转发和验证所需要的Protobuf协议脚本 461
18.4 生成服务器所需要的C++协议程序 464
18.5 生成客户端所需要的C#协议程序 466
18.6 完成网关服务器的逻辑功能开发 468
18.7 完成客户端从网关授权进入大厅的逻辑 478
18.8 本章小结与分析 481
第19章 开发中心服务器CenterServer 482
19.1 中心服务器及其作用 482
19.2 创建CenterServer框架主程序 484
19.3 创建中心服务器的Protobuf协议脚本 488
19.4 生成服务器所需要的C++协议程序 495
19.5 生成客户端所需要的C#协议程序 497
19.6 生成服务器data数据和协议代码 500
19.7 完成中心服务器的逻辑功能开发 504
19.8 启动客户端完成任务配置并开始仿真任务 513
19.9 本章小结与分析 520
第20章 开发战场服务器BattleServer 522
20.1 战场服务器及其作用 522
20.2 创建BattleServer框架主程序 524
20.3 创建战场服务器Protobuf协议脚本 527
20.4 生成服务器所需要的C++协议程序 537
20.5 生成客户端所需要的C#协议程序 539
20.6 生成服务器data数据和协议代码 550
20.7 创建战场服务器的聊天模块 553
20.8 创建战场逻辑模块 556
20.9 创建战场仿真人员同步模块 558
20.10 创建战场仿真车辆和飞行器模块 564
20.11 创建战场动态资源管理和监控模块 568
20.12 创建战场AI仿真敌人和飞行器AI状态机 571
20.13 调试战场服务器和客户端，启动仿真任务 576
20.14 本章小结与分析 579
第21章 一些仿真框架和人工智能的介绍 581
21.1 VR-LINK与HLA框架：高层体系模型框架的使用 581
21.2 游戏中常用的人工智能算法和深度学习引申 584
后记——全书总结与个人发展建议 588
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Unity与C++网络游戏开发实战：基于VR、AI与分布式架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式系统常用技术及案例分析（第2版）
第1章　分布式系统基础知识
1.1　概述
1.1.1　什么是分布式系统
1.1.2　集中式系统与分布式系统
1.1.3　如何设计分布式系统
1.1.4　分布式系统所面临的挑战
1.2　线程
1.2.1　什么是线程
1.2.2　进程和线程
1.2.3　线程和纤程
1.2.4　编程语言中的线程对象
1.2.5　SimpleThreads示例
1.3　通信
1.3.1　网络I/O模型的演进
1.3.2　远程过程调用（RPC）
1.3.3　面向消息的通信
1.4 一致性
1.4.1　以数据为中心的一致性模型
1.4.2　以客户为中心的一致性
1.5　容错性
1.5.1　基本概念
1.5.2　故障分类
1.5.3　使用冗余来掩盖故障
1.5.4　分布式提交
1.6　CAP理论
1.6.1　什么是CAP理论
1.6.2　为什么CAP只能三选二
1.6.3　CAP常见模型
1.6.4　CAP的意义
1.6.5　CAP最新发展
1.7　安全性
1.7.1　基本概念
1.7.2　加密算法
1.7.3　安全通道
1.7.4　访问控制
1.8　并发
1.8.1　线程与并发
1.8.2　并发与并行
1.8.3　并发带来的风险
1.8.4　同步（Synchronization）
1.8.5  原子访问（Atomic Access）
1.8.6  无锁化设计提升并发能力
1.8.7  缓存提升并发能力
1.8.8  更细颗粒度的并发单元
第2章　分布式系统架构体系
2.1　基于对象的体系结构
2.1.1　分布式对象
2.1.2　Java RMI
2.2　面向服务的架构（SOA）
2.2.1　SOA的基本概念
2.2.2　基于Web Services的SOA
2.2.3　SOA的演变
2.3　REST风格的架构
2.3.1　什么是REST
2.3.2　REST有哪些特征
2.3.3　Java实现REST的例子
2.3.4　REST API最佳实践
2.4　微服务架构（MSA）
2.4.1　什么是MSA
2.4.2　MSA与SOA
2.4.3　何时采用MSA
2.4.4　如何构建微服务
2.5　容器技术
2.5.1　虚拟化技术
2.5.2　容器与虚拟机
2.5.3　基于容器的持续部署
2.6　Serverless架构
2.6.1　什么是Serverless架构
2.6.2　Serverless典型的应用场景
2.6.3　Serverless架构原则
2.6.4　例子：使用Serverless实现游戏全球同服
第3章　分布式消息服务
3.1　分布式消息概述
3.1.1　基本概念
3.1.2　使用场景
3.1.3　常用技术
3.2　Apache ActiveMQ
3.2.1  例子：producer-consumer
3.2.2  例子：使用JMX来监控ActiveMQ
3.2.3  例子：使用Java实现producer-consumer
3.3  RabbitMQ
3.3.1　例子：Work Queues
3.3.2　例子：Publish/Subscribe
3.3.3　例子：Routing
3.3.4　例子：Topics
3.3.5  例子：RPC
3.4  Apache RocketMQ
3.4.1  例子：使用Java实现producer-consumer
3.4.2  RocketMQ最佳实践
3.5  Apache Kafka
3.5.1  Apache Kafka的核心概念
3.5.2  Apache Kafka的使用场景
3.6  实战：基于JMS的消息发送和接收
3.6.1  项目概述
3.6.2  项目配置
3.6.3  编码实现
3.6.4  运行
第4章　分布式计算
4.1　分布式计算概述
4.1.1　使用场景
4.1.2　常用技术
4.2　MapReduce
4.2.1　MapReduce简介
4.2.2  MapReduce的编程模型
4.2.3  MapReduce接口实现
4.2.4　MapReduce的使用技巧
4.3  Apache Hadoop
4.3.1  Apache Hadoop的核心组件
4.3.2  例子：词频统计WordCount程序
4.4  Spark
4.4.1  Spark简介
4.4.2  Spark与Hadoop的关系
4.4.3  Spark 2.0的新特性
4.4.4　Spark集群模式
4.5  Mesos
4.5.1  Mesos简介
4.5.2  设计高可用的Mesos framework
4.6  实战：基于Spark的词频统计
4.6.1  项目概述
4.6.2  项目配置
4.6.3  编码实现
4.6.4  运行
第5章　分布式存储
5.1　分布式存储概述
5.1.1　使用场景
5.1.2　常用技术
5.2　Bigtable
5.2.1　Bigtable的数据模型
5.2.2　Bigtable的实现
5.2.3　Bigtable的性能优化
5.3　Apache HBase
5.3.1　Apache HBase的基本概念
5.3.2　Apache HBase的架构
5.4　Apache Cassandra
5.4.1　Apache Cassandra简介
5.4.2　Apache Cassandra的应用场景
5.4.3　Apache Cassandra的架构和数据模型
5.4.4　用于配置Apache Cassandra的核心组件
5.5　Memcached
5.5.1　Memcached简介
5.5.2　Memcached的架构
5.5.3　Memcached客户端
5.6　Redis
5.6.1　Redis简介
5.6.2　Redis的下载与简单使用
5.6.3　Redis的数据类型及抽象
5.7　MongoDB
5.7.1　MongoDB简介
5.7.2　MongoDB核心概念
5.7.3　MongoDB的数据模型
5.7.4　示例：Java连接MongoDB
5.8  实战：基于Redis的分布式锁
5.8.1  项目概述
5.8.2  项目配置
5.8.3  编码实现
5.8.4  运行
第6章　分布式监控
6.1　分布式监控概述
6.1.1　使用场景
6.1.2　常用技术
6.2　Nagios
6.2.1　Nagios监控
6.2.2　Nagios插件
6.3　Zabbix
6.3.1　Zabbix对容器的支持
6.3.2　Zabbix的基本概念
6.4　Consul
6.4.1　Consul架构
6.4.2　Consul agent
6.5　ZooKeeper
6.5.1　ZooKeeper简介
6.5.2　ZooKeeper内部工作原理
6.5.3　例子：ZooKeeper实现barrier和producer-consumer queue
6.6  实战：基于ZooKeeper的服务注册和发现
6.6.1  项目概述
6.6.2  项目配置
6.6.3  编码实现
6.6.4  运行
第7章　分布式版本控制系统
7.1　分布式版本控制系统概述
7.1.1　集中式与分布式
7.1.2　分布式版本控制系统的核心概念
7.2　Bazaar
7.2.1　Bazaar的核心概念
7.2.2　Bazaar的使用
7.3　Mercurial
7.3.1　Mercurial的核心概念
7.3.2　Mercurial的使用
7.4　Git
7.4.1　Git的基础概念
7.4.2　Git的使用
7.5　Git Flow—团队协作最佳实践
7.5.1　分支定义
7.5.2　新功能开发工作流
7.5.3　Bug修复工作流
7.5.4　版本发布工作流
第8章　RESTful API、微服务及容器技术
8.1　Jersey
8.1.1　Jersey简介
8.1.2　Jersey的模块和依赖
8.1.3　JAX-RS核心概念
8.1.4　例子：用SSE构建实时Web应用
8.2　Spring Boot
8.2.1　Spring Boot简介
8.2.2　Spring Boot的安装
8.2.3　Spring Boot的使用
8.2.4　Spring Boot的属性与配置
8.3　Docker
8.3.1　Docker简介
8.3.2　Docker的核心组成、架构及工作原理
8.3.3　Docker的使用
8.4　实战：基于Docker构建、运行、发布微服务
8.4.1　编写微服务
8.4.2　微服务容器化
8.4.3　构建Docker image
8.4.4　运行image
8.4.5　访问应用
8.4.6　发布微服务
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式系统常用技术及案例分析（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>智能电网
译者序
原书序一
原书序二
作者简介
前言
第1部分 背景：智能电网的概念、产生原因、发展方式、发展条件和实现时间
第1章 智能电网不再仅仅是一项“技术”
1.1引言
1.2不可阻挡的脚步
1.3智能电网展望：我们希望什么样的智能电网
1.4智能电网发展路径
1.5小结
参考文献
第2章 从智能电网到能源的智能使用
2.1引言
2.2剥夺用户的权利——供应方主权的出现
2.3改革的压力：需求增长、能源安全和气候变化
2.4把终端用户置于能源决策的核心位置：新兴智能电网和分布式能源
2.5能源的智能使用的市场和监管创新
2.6小结
参考文献
第3章 动态定价机制的公平问题
3.1引言
3.2背景
3.3动态定价的分配效应
3.4其他行业的动态定价
3.5克服实施动态定价的障碍
3.6消除潜在的反对意见
3.7小结
附录 量化风险溢价
参考文献
第4章 智能电网的公平问题：智能电网成本与效益的规模与分配情况
4.1引言
4.2智能电网概念不统一，致使其成本收益不一致
4.3智能电网的强制实施引发了最基本的公平问题
4.4智能电网引发的其他公平问题
4.5小结
参考文献
第2部分 日益增长的可再生能源和分布式发电
第5章 可再生能源的前景：用储能迎接挑战
5.1引言
5.2高渗透率的可再生能源发电
5.3储能并网
5.4联邦政府资助下的储能技术研究
5.5小结
参考文献
第6章 加州智能电网的愿景和蓝图
6.1引言
6.2可再生能源并网的挑战和对电力市场的影响
6.3加州独立系统运营商（CAISO）对智能电网的期望
6.4小结
附录 缩略语
第7章 实现可再生能源发电和分布式发电的潜能
7.1引言
7.2建模方法
7.3结果和讨论
7.4小结
参考文献
第8章 微电网的作用是什么？
8.1引言
8.2背景
8.3微电网定义
8.4关键技术
8.5微电网的优点
8.6微电网发展面临的挑战
8.7微电网的研究现状
8.8微电网的未来发展
8.9小结
致谢
参考文献
第9章 通过直接负荷控制和需求响应消纳可再生能源
9.1引言
9.2变化较大且地理分布不均的资源并网
9.3需求响应：过去、现在和未来
9.4辅助服务
9.5风电接入成本
9.6需求响应资源拓扑
9.7需求响应潜力评估
9.8风电接入和需求响应
9.9小结
附录 缩略语
参考文献
第10章 平抑波动：用需求侧响应消纳间歇性资源
10.1引言
10.2电力系统运行灵活性问题概述
10.3风电接入研究及其辅助服务要求
10.4系统的额外挑战
10.5负荷作为弹性资源纳入系统调度和实践
10.6间歇性能源的负荷控制策略构建
10.7小结
参考文献
第3部分 智能设施、智能定价和智能设备
第11章 软件基础和智能电网
11.1引言
11.2智能电网信息技术难点
11.3智能电网的基本软件平台
11.4智能电网的应用
11.5案例研究
11.6小结
第12章 大规模工商业用户对动态定价的反应——加州经验
12.1引言
12.2加州的动态定价和需求响应项目
12.3 CPP用户、费率和尖峰事件特征
12.4分析方法
12.5CPP负荷影响的估计
12.6展望
12.7小结
参考文献
附录
第13章 通过智能电价在降低智能配电网投资——德国经验
13.1引言
13.2节点定价
13.3德国的节点分布定价
13.4小结
参考文献
第14章 通过聆听股东和用户的需求来实现智能电网的成功
14.1引言
14.2从智能电网技术角度出发，需求响应和能效管理有何区别
14.3从智能电网、需求响应和能效管理角度如何定义和衡量客户的利益
14.4智能电网实施提案的监管审查经验
14.5电力公司和用户在智能电网及相关技术方面的实施经验
14.6弥补不足：智能电网设计者应该聚焦于如何更好地确保用户利益
14.7小结
参考文献
第15章 消费者眼中的智能电网——一劳永逸？
15.1引言
15.2科技飞速发展的世界中智能电网的出现
15.3智能电网的愿景
15.4消费者的接受程度
15.5决策者的重担
15.6跟随智能电网浪潮的家庭自动化
15.7小结
参考文献
第16章 电表的用户侧
16.1引言
16.2当前需求响应情况
16.3新技术和进行中的试点项目
16.4现有的用户参与模式
16.5未来发展：将技术与用户参与模式结合
16.6小结
参考文献
第4部分 案例研究、应用及试点项目
第17章 需求响应参与到有序的电力市场：PJM案例研究
17.1引言
17.2作为需求响应参与到PJM市场中的实体
17.3需求响应参与容量市场
17.4 需求响应参与能源市场（日前和实时）
17.5 需求响应参与辅助服务市场
17.6 PJM市场中的需求响应管理
17.7 需求响应的未来：当前需求响应的相关问题
第18章 完美搭档：风力发电和电动汽车——新西兰案例研究
18.1引言
18.2新西兰的风力发电和电动汽车
18.3当前的机遇
18.4新西兰地区风电与电动汽车并网的成本分析
18.5通过插电式电动汽车提高系统可靠性
18.5.1新西兰电网的频率波动
18.5.2基于DDC的频率控制
18.5.3 DDC的发展趋势
18.5.4 DDC的经济性分析
18.6小结
致谢
参考文献
第19章 法国电力市场中智能电动汽车对日前价格的影响
19.1引言
19.2仿真方法
19.3 2020年的仿真结果
19.4小结
致谢
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>智能电网
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>-分布式多智能体网络一致性协调控制理论
目录
前言
第1章多智能体网络一致性问题概述1
1.1引言1
1.2多智能体网络2
1.3多智能体网络的一致性问题及其应用3
1.3.1多智能体网络的一致性问题3
1.3.2一致性问题的主要应用3
1.4一致性问题研究现状4
1.5本章小结9
参考文献9
第2章时滞多智能体网络的一致性15
2.1引言15
2.2预备知识17
2.3问题描述与收敛性分析17
2.3.1具有不同时滞的一阶连续多智能体网络的一致性17
2.3.2具有不同时滞的一阶离散多智能体网络的一致性22
2.3.3具有不同时滞的二阶连续多智能体网络的一致性24
2.4例子与数值仿真26
2.5本章小结31
参考文献32
第3章线性耦合多智能体网络的分组一致性35
3.1引言35
3.2预备知识37
3.3问题描述与收敛性分析38
3.3.1一阶线性耦合多智能体网络的分组一致性38
3.3.2二阶线性耦合多智能体网络的分组一致性42
3.4例子与数值仿真44
3.5本章小结49
参考文献49
第4章时滞多智能体网络的分组一致性52
4.1引言52
4.2预备知识53
4.3问题描述与收敛性分析54
4.3.1拓扑结构为连通二分图的一阶时滞系统的分组一致性54
4.3.2拓扑结构为无向连通图的一阶时滞系统的分组一致性56
4.4例子与数值仿真57
4.5本章小结60
参考文献61
5.1引言63
5.2预备知识64
5.3问题描述与收敛性分析65
5.3.1基于m矩阵的一阶连续多智能体网络的牵制一致性65
5.3.2一阶离散多智能体网络的牵制一致性67
5.3.3牵制策略69
5.4例子与数值仿真70
5.5本章小结75
参考文献75
第6章多智能体网络的牵制分组一致性77
6.1引言77
6.2预备知识78
6.3问题描述与收敛性分析79
6.4例子与数值仿真83
6.5本章小结87
参考文献87
第7章基于广义线性交互协议的二阶非线性多智能体网络的一致性89
7.1引言89
7.2预备知识90
7.3问题描述与收敛性分析91
7.4例子与数值仿真98
7.5本章小结104
参考文献104
第8章有领航者的二阶非线性多智能体网络的鲁棒一致性106
8.1引言106
8.2预备知识108
8.3问题描述与收敛性分析109
8.4例子与数值仿真115
8.5本章小结119
参考文献119
第9章二阶非线性多智能体随机动态网络的局部一致性122
9.1引言122
9.2预备知识124
9.3问题描述与收敛性分析126
9.3.1非时滞耦合情形131
9.3.2时滞耦合情形134
9.4例子与数值仿真139
9.5本章小结142
参考文献143
第10章二阶非线性多智能体随机动态网络的全局一致性145
10.1引言145
10.2预备知识145
10.3问题描述与收敛性分析147
10.4例子与数值仿真156
10.5本章小结160
参考文献161
第11章任意快速切换的二阶非线性多智能体网络的局部一致性162
11.1引言162
11.2预备知识162
11.3问题描述与收敛性分析163
11.4例子与数值仿真170
11.5本章小结173
参考文献173
第12章时滞与非时滞二阶非线性多智能体网络的全局一致性175
12.1引言175
12.2预备知识175
12.3问题描述与收敛性分析176
12.4例子与数值仿真184
12.5本章小结187
参考文献188
第13章基于gossip算法的分布式多智能体网络的平均一致性189
13.1引言189
13.2预备知识190
13.3问题描述与收敛性分析191
13.3.1基于广播的随机多gossip对算法192
13.3.2基于广播的多gossip对算法的收敛分析195
13.3.3基于广播的多gossip对算法的性能分析202
13.4例子与数值仿真205
13.5本章小结207
参考文献208
第14章基于预测机制的离散时间多智能体网络的加速收敛211
14.1引言211
14.2预备知识212
14.3问题描述与收敛性分析213
14.3.1有向网络的收敛性分析213
14.3.2无向网络的收敛性分析216
14.3.3加速预测机制简介216
14.3.4基于加速预测机制的一致性分析219
14.4例子与数值仿真223
14.5本章小结225
参考文献225
第15章基于预测机制的连续时间多智能体网络的加速收敛228
15.1引言228
15.2预备知识229
15.3问题描述与收敛性分析232
15.3.1预测协议对于通信时滞的鲁棒性分析236
15.3.2预测协议的收敛速率性能分析238
15.3.3基于预测机制的一致性协议的性能分析242
15.4例子与数值仿真243
15.5本章小结247
参考文献247
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>-分布式多智能体网络一致性协调控制理论
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统编程
出版者的话
译者序
前言
第1章　绪论1
1.1　基本原理1
1.1.1　计算机科学的传统讲授方法1
1.1.2　本书采用的系统方法2
1.2　网络和分布式系统在现代计算中的重要性—简明历史回顾4
1.3　分布式系统简介6
1.3.1　分布式系统的优势和挑战6
1.3.2　分布的本质7
1.3.3　分布式应用程序的软件体系结构8
1.3.4　分布式系统与应用的质量度量指标9
1.3.5　透明性简介9
1.4　案例研究简介10
1.4.1　主案例研究（分布式游戏）11
1.4.2　附加案例研究11
1.5　教辅材料和练习简介12
1.6　交互式教学工具Workbench套件14
1.7　示例代码和相关练习14
第2章　进程视角16
2.1　基本原理和概述16
2.2　进程16
2.2.1　基本概念16
2.2.2　创建进程16
2.3　进程调度21
2.4　实时系统调度46
2.5　在现代操作系统中使用的特定调度算法及其变体56
2.6　进程间通信57
2.7　线程：导论62
2.7.1　一般概念62
2.7.2　线程实现62
2.7.3　线程调度方法63
2.7.4　同步（顺序的）与异步（并发的）线程操作64
2.7.5　线程带来的额外复杂性68
2.7.6　多线程IPC举例70
2.8　操作系统的其他角色77
2.9　程序中使用定时器77
2.10　进程视角的透明性80
2.11　进程视角的案例研究80
2.11.1　调度要求80
2.11.2　定时器的使用81
2.11.3　多线程需求81
2.11.4　IPC、端口和套接字81
2.12　章末练习82
2.12.1　问题82
2.12.2　基于Workbench的练习83
2.12.3　编程练习87
2.12.4　章末问题答案88
2.12.5　本章活动列表88
2.12.6　配套资源列表89
第3章　通信视角90
3.1　基本原理和概述90
3.2　通信视角90
3.3　通信技术91
3.3.1　单向通信91
3.3.2　请求-应答通信96
3.3.3　双向数据传输100
3.3.4　寻址方法100
3.3.5　远程过程调用103
3.3.6　远程方法调用105
3.4　通信的分层模型107
3.4.1　OSI模型109
3.4.2　TCP/IP模型110
3.5　TCP/IP协议簇111
3.5.1　IP112
3.5.2　TCP113
3.5.3　TCP连接115
3.5.4　UDP116
3.5.5　TCP和UDP的比较118
3.5.6　TCP和UDP的选择119
3.6　地址119
3.6.1　扁平与分级编址120
3.6.2　链路层地址120
3.6.3　网络层地址121
3.6.4　传输层地址（端口）123
3.6.5　熟知端口号124
3.7　套接字125
3.7.1　套接字API：概述126
3.7.2　套接字API：UDP原语序列126
3.7.3　套接字API：TCP原语序列130
3.7.4　绑定（进程到端口）132
3.8　阻塞和非阻塞套接字行为135
3.8.1　非阻塞套接字行为的处理138
3.8.2　通信死锁138
3.9　错误检测与校正140
3.10　应用特定协议142
3.11　面向业务逻辑的通信整合143
3.12　帮助组件相互定位的技术144
3.13　通信视角的透明性需求145
3.14　通信视角的案例研究146
3.15　章末练习154
3.15.1　问题154
3.15.2　基于Workbench的练习154
3.15.3　编程练习157
3.15.4　章末问题答案157
3.15.5　Workbench练习的答案/结果158
3.15.6　本章活动列表159
3.15.7　配套资源列表159
第4章　资源视角169
4.1　基本原理和概述169
4.2　CPU资源169
4.3　通信中的存储器资源170
4.4　内存管理175
4.5　资源管理185
4.5.1　私有存储空间资源的静态分配与动态分配185
4.5.2　共享资源189
4.5.3　事务190
4.5.4　锁190
4.5.5　死锁193
4.5.6　资源复制196
4.6　网络资源197
4.6.1　网络带宽197
4.6.2　数据压缩技术202
4.6.3　消息格式205
4.6.4　序列化206
4.6.5　网络链路序列209
4.6.6　路由器与路由210
4.6.7　通信额外开销215
4.6.8　恢复机制及其与网络拥塞的相互作用215
4.7　虚拟资源217
4.7.1　套接字218
4.7.2　端口218
4.7.3　网络地址218
4.7.4　资源名称219
4.8　分布式应用程序设计对网络效率的影响220
4.9　资源视角的透明性220
4.10　资源视角的案例研究220
4.11　章末练习223
4.11.1　问题223
4.11.2　基于Workbench的练习223
4.11.3　编程练习226
4.11.4　章末问题答案226
4.11.5　Workbench练习的答案/结果227
4.11.6　本章活动列表228
4.11.7　配套资源列表228
第5章　体系结构视角229
5.1　基本原理和概述229
5.2　体系结构视角229
5.2.1　关注点分离230
5.2.2　网络化与分布性230
5.2.3　分布式系统的复杂性231
5.2.4　分层体系结构232
5.2.5　层级体系结构234
5.3　异构性234
5.3.1　异构性的定义和来源235
5.3.2　性能异构性235
5.3.3　平台异构性236
5.3.4　操作系统异构性236
5.3.5　异构性影响238
5.3.6　软件移植239
5.4　硬件和系统级体系结构240
5.4.1　紧耦合（硬件）系统240
5.4.2　松散耦合（硬件）系统240
5.4.3　并行处理241
5.5　软件体系结构242
5.6　软件体系结构分类法246
5.6.1　单层应用程序247
5.6.2　双层应用程序247
5.6.3　三层应用程序248
5.6.4　多层应用程序248
5.7　客户端-服务器249
5.7.1　客户端和服务器的生命周期249
5.7.2　连接的主动方和被动方250
5.7.3　CS体系结构模型250
5.7.4　CS模型的变体251
5.7.5　有状态服务与无状态服务252
5.7.6　模块化和层级CS系统253
5.8　三层和多层体系结构254
5.9　对等体系结构263
5.9.1　对等应用程序的特性264
5.9.2　对等体系结构连接的复杂性264
5.9.3　探索对等行为265
5.10　分布式对象268
5.11　中间件对软件体系结构的支持270
5.12　提供集体资源和计算资源的系统模型271
5.12.1　集群272
5.12.2　网格272
5.12.3　数据中心272
5.12.4　云273
5.13　软件库273
5.13.1　软件库案例275
5.13.2　静态链接和动态链接280
5.13.3　语言相关的特性：C/C++头文件281
5.14　硬件虚拟化283
5.14.1　虚拟机283
5.14.2　Java虚拟机284
5.15　静态和动态配置285
5.15.1　静态配置285
5.15.2　动态配置286
5.15.3　上下文感知286
5.16　分布式应用程序的非功能性需求287
5.16.1　复制288
5.16.2　复制的语义291
5.16.3　复制的实现291
5.17　分布式应用程序与网络之间的关系299
5.18　体系结构视角的透明性300
5.19　体系结构视角的案例研究301
5.19.1　有状态服务器设计301
5.19.2　游戏组件的关注点分离302
5.19.3　游戏应用程序的物理和逻辑体系结构302
5.19.4　游戏的透明性303
5.20　章末练习304
5.20.1　问题304
5.20.2　编程练习305
5.20.3　章末问题答案305
5.20.4　本章活动列表307
5.20.5　配套资源列表307
第6章　分布式系统309
6.1　基本原理和概述309
6.2　透明性309
6.2.1　访问透明性310
6.2.2　位置透明性311
6.2.3　复制透明性313
6.2.4　并发透明性316
6.2.5　迁移透明性319
6.2.6　故障透明性320
6.2.7　规模扩展透明性322
6.2.8　性能透明性323
6.2.9　分布透明性324
6.2.10　实现透明性324
6.3　公共服务324
6.4　名称服务325
6.4.1　名称服务的运行326
6.4.2　目录服务327
6.4.3　名称服务设计和实现的挑战332
6.5　域名系统333
6.5.1　域名空间334
6.5.2　DNS实现336
6.5.3　DNS名称服务器：权威和授权338
6.5.4　复制339
6.5.5　名称解析的进一步细节340
6.5.6　DNS中的缓存341
6.5.7　探索地址解析341
6.5.8　反向DNS查找344
6.6　时间服务344
6.6.1　时间服务简介344
6.6.2　物理时钟同步346
6.6.3　逻辑时钟与同步350
6.7　选举算法352
6.7.1　操作简介353
6.7.2　bully选举算法354
6.7.3　ring选举算法355
6.7.4　领导者预选356
6.7.5　针对一个选举算法的探索356
6.8　组通信 362
6.9　通知服务363
6.10　中间件：机制和操作365
6.11　中间件例子和支持技术367
6.11.1　公共对象请求代理体系结构367
6.11.2　接口定义语言373
6.11.3　可扩展标记语言375
6.11.4　JavaScript对象表示法376
6.11.5　Web服务与REST376
6.11.6　简单对象访问协议378
6.12　分布式系统的确定性和不确定性379
6.13　章末练习380
6.13.1　问题380
6.13.2　编程练习380
6.13.3　章末问题答案381
6.13.4　本章活动列表382
6.13.5　配套资源列表382
第7章　案例研究：融会贯通384
7.1　基本原理和概述384
7.2　用例说明384
7.3　案例研究1：时间服务客户端（基于库）385
7.3.1　学习目标385
7.3.2　需求分析385
7.3.3　体系结构和代码结构386
7.3.4　关注点的分离390
7.3.5　组件之间的耦合与绑定390
7.3.6　设计的通信特性391
7.3.7　实现394
7.3.8　测试395
7.3.9　用例的透明性396
7.3.10　案例研究资源397
7.4　案例研究2：事件通知服务397
7.4.1　学习目标398
7.4.2　需求分析398
7.4.3　体系结构和代码结构399
7.4.4　关注点的分离399
7.4.5　组件之间的耦合与绑定400
7.4.6　设计的通信特性401
7.4.7　事件通知服务的应用程序使用场景示例405
7.4.8　测试407
7.4.9　事件通知服务的透明性410
7.4.10　案例研究资源410
7.5　分布式应用程序的优秀设计实践410
7.5.1　需求分析410
7.5.2　架构方面411
7.5.3　通信方面412
7.5.4　尽可能重用代码412
7.5.5　为通过测试的代码和信任的代码创建库412
7.5.6　测试方面413
7.6　章末练习414
7.6.1　编程练习414
7.6.2　配套资源列表414
索引416
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式数据库系统及其应用
《中国科学院研究生教学丛书》序
前言
第一章 分布式数据库系统概述
1?1 分布式数据库系统的由来与发展
1?1?1 分布式数据库系统的由来
1?1?2 分布式数据库系统的发展
1?2 分布式数据库系统的定义与特点
1?3 分布式数据库系统的分类
1?3?1 按局部数据库管理系统的数据模型分类
1?3?2 按分布式数据库控制系统的类型分类
1?4 分布式数据库系统的体系结构和组

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式数据库系统及其应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>多传感器分布式统计判决
第一章引论
1.1经典的统计判决理论
1.2多传感器统计判决的发展概况
1.3用无穷维空间优化的观点认识统计判决问题
第二章两传感器二元判决
2.1传统的单传感器判决
2.1.1Bayes判决
2.1.2Neyman??Pearson判决
2.1.3序贯判决
2.1.4二元判决系统性能评价――接收机工作特性(ROC)曲线
2.2两传感器分布式判决概论
2.2.1模型与历史发展

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>多传感器分布式统计判决
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual Basic.NET 分布式应用程序设计
第一部分
.NET 概念第1章

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual Basic.NET 分布式应用程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Delphi6分布式开发
第一篇 分布式结构介绍
第1章 分布式结构与多层应用系统概述
第二篇 Delphi 6的COM/DCOM/COM+编程
第2章 Delphi 6的COM编程基础
第3章 COM的高级技术
……
第三篇 Delphi 6的CORBA编程
第6章 CORBA编程基础
第7章 高级CORBA编程
第四篇 多层分布式数据库系统MIDAS的开发
第8章 数据库的链接
第9章 用DCOM数据模块来实现基本多层分布式系统
第10章 MIDAS的高级应用开发
第11章 用CORBA数据模块来实现MIDAS
第五篇 分布式Web应用开发
第12章 分布式Web应用开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Delphi6分布式开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式多媒体计算机系统教程
第1章 引言
第2章 分布式计算机系统
第3章 分布式计算环境（DCE）
第4章 分布式对象技术
第5章 分布式计算模型
第6章 数字化多媒体关键技术
第7章 支持多媒体通信的高速网络技术
第8章 多媒体通信技术及网络协议支持
第9章 分布式多媒体流服务质量（QoS）保证
第10章 分布式多媒体资源管理
第11章 分布式多媒体调度算法
第12章 分布式多媒体系统的应用
第13章 应用实例――SBF摄编放分布式多媒体数学系统
附录A 定理说明
附录B 参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式多媒体计算机系统教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>遥感分布式面源污染评估模型-理论方法与应用
前言
第1章 绪论
1.1 面源污染研究方法概述
1.1.1 野外实地监测
1.1.2 人工降雨模拟试验
1.1.3 模型模拟
1.2 我国现有面源污染地面监测方法
1.2.1 种植业氮磷流失监测
1.2.2 畜禽养殖业排污监测
1.2.3 农村生活源排污监测
1.2.4 流域内河流水质监测
1.3 面源污染模型方法研究
1.3.1 国内外面源污染模型研究现状
1.3.2 典型的面源污染模型
1.4 面源污染控制与管理研究进展
1.4.1 美国TMDL计划
1.4.2 最佳管理措施
1.4.3 美国农业部CEAP项目
1.5 存在问题与发展趋势
第2章 遥感分布式DPeRS模型原理与构建
2.1 大尺度模型简介
2.2 DPeRS模型构建
2.3 农田氮磷平衡估算模块
2.3.1 化肥输入
2.3.2 有机肥输入
2.3.3 灌溉带入
2.3.4 种子带入
2.3.5 生物固氮
2.3.6 大气干湿沉降
2.3.7 作物带走
2.3.8 气态氮损失
2.3.9 径流侵蚀损失
2.3.10 淋溶损失
2.4 植被覆盖度定量遥感反演模块
2.5 溶解态面源污染负荷估算方法
2.6 吸附态面源污染负荷估算方法
2.7 面源污染物入河量估算方法
2.8 DPeRS模型适应性
第3章 基于环境星的.DPeRS模型新安江流域应用
3.1 环境星数据介绍
3.2 新安江流域现状
3.2.1 自然地理概况
3.2.2 经济社会概况
3.2.3 水资源与水环境现状
3.2.4 示范区位置
3.3 新安江流域(黄山片)面源污染数据库构建
3.3.1 土地利用和植被覆盖度
3.3.2 土壤数据
3.3.3 降水数据
3.3.4 农田氮磷养分平衡数据
3.3.5 坡度坡长数据
3.3.6 主要模型参数
3.4 新安江流域面源污染负荷结果与分析
3.4.1 溶解态面源污染负荷空间分布
3.4.2 新安江流域土壤侵蚀及泥沙时空分布
3.4.3 吸附态面源污染负荷空间分布
3.4.4 新安江流域面源污染物产生量时空分布
3.4.5 新安江流域面源污染物人河量核算
3.4.6 新安江流域面源污染分级分区
第4章 DPeRS模型与SWAT模型在新安江流域的对比研究
4.1 SWAT模型原理
4.1.1 水量模拟
4.1.2 水质模拟
4.2 数据的收集与整理
4.3 模型的建立
4.4 模型率定及验证
4.5 面源污染负荷分布
4.6 面源污染负荷模拟结果
4.7 新安江流域双模型对比分析和验证
4.7.1 调查数据验证
4.7.2 SWAT模型结果对比分析
第5章 巢湖流域DPeRS面源模型推广应用
5.1 巢湖流域现状
5.2 巢湖流域主要空问数据库
5.2.1 土地利用解译
5.2.2 植被盖度反演
5.2.3 降雨量插值
5.2.4 土壤数据
5.2.5 坡度坡长数据
5.2.6 农田氮磷平衡空间数据
5.2.7 统计调查数据
5.2.8 人河系数参数估计
5.3 巢湖流域氮磷面源污染与水华关系研究
5.3.1 基于NDVI的蓝藻水华遥感识别及年度分析
5.3.2 巢湖流域面源污染物空间分布特征
5.3.3 巢湖流域面源污染量估算结果分析
5.3.4 巢湖流域氮磷面源污染源解析
5.3.5 巢湖流域面源污染与巢湖水华时空分布分析
5.3.6 巢湖流域DPeRS模型情景分析
5.4 巢湖流域氨氮和化学需氧量典型污染物空间特征分析
5.4.1 畜禽养殖密度计算
5.4.2 氨氮和化学需氧量产污时空特征
5.4.3 氨氮和化学需氧量入河量估算
5.4.4 巢湖流域面源DPeRS模型污染源解析
5.4.5 人口密度、农田养分平衡与氨氮负荷相关分析
5.4.6 畜禽养殖与化学需氧量负荷相关分析
5.5 主要结论
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>遥感分布式面源污染评估模型-理论方法与应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式创新网络中的知识黏滞研究
第1章绪论
1.1研究背景与意义
1.2国内外研究现状
1.3本书的主要内容
第2章分布式创新网络的概念、要素及特征
2.1分布式创新的定义
2.2分布式创新网络概念的界定
2.3分布式创新网络系统及网络构建影响因素
2.4分布式创新网络的特征
第3章知识黏滞的含义、特征及影响因素
3.1知识黏滞的含义与类型
3.2知识黏滞的特征
3.3知识黏滞的影响因素
第4章分布式创新网络中的知识转移机制
4.1网络中的知识分布
4.2网络中的知识转移过程
4.3分布式创新网络中的知识转移机制
第5章分布式创新网络中知识黏滞的形成机理
5.1“S—A—C”理论视角的形成
5.2分布式创新网络中节点间知识的分布与流动
5.3“S—A—C”视角下分布式创新网络中节点间知识黏滞的因素系统
5.4分布式创新网络节点间知识黏滞形成的动态机制模型
第6章分布式创新网络知识黏滞度的模型与评价
6.1分布式创新网络知识黏滞度的提出
6.2分布式创新网络节点知识黏滞度理论模型及指标体系
6.3分布式创新网络知识黏滞度的结构方程模型分析
6.4分布式创新网络知识黏滞度模型检验与分析
6.5模型的进一步理论探讨
第7章分布式创新网络中知识黏滞削弱系统构建
7.1知识黏滞削弱系统的总体框架
7.2情境削弱子系统
7.3活动削弱子系统
7.4认知削弱子系统
第8章产学研协同创新中知识黏滞的分析
8.1产学研协同创新的过程
8.2产学研协同创新中知识黏滞的影响因素
8.3产学研协同创新中知识黏滞影响因素的检验
8.4产学研协同创新中知识黏滞的管控
第9章削弱和转移知识黏滞的案例研究
9.1IBM“1亿美元买创意”
9.2宝洁设置“技术企业家”职位
9.3西门子建立“分享网”
9.4英特尔的“外部技术内部化”战略
9.5华为的R&D国际化战略
9.6美的“让消费者帮助企业创新”
第10章研究展望
参考文献
附录1分布式创新网络中的知识黏滞调查
附录2产学研协同创新过程中知识黏滞的成因研究调查
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式创新网络中的知识黏滞研究
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>区块链革命：分布式自律型社会出现
前言
序章　区块链引发地壳变动
第 1 章　区块链革命的来临
第 2 章　区块链的应用：比特币的发展
第 3 章　区块链的应用：银行也导入
第 4 章　区块链的应用：证券业发生革命性变化
第 5 章　传统技术型 Fintech（金融科技）及其局限
第 6 章　区块链将如何改变货币和金融
第 7 章　区块链的应用：事实证明
第 8 章　区块链的应用：IoT（物联网）
第 9 章　 分布式自律组织和分布式市场已诞生
第 10 章　分布式自律组织将创造怎样的未来
终章　我们能够重塑怎样的社会
补论 A　虚拟货币和电子货币法律上的定义
补论 B　当今结算系统概要
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>区块链革命：分布式自律型社会出现
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式计算、云计算与大数据
前言
第1章 分布式计算概述
1.1 分布式计算的概念
1.1.1 定义
1.1.2 分布式计算的优缺点
1.1.3 分布式计算的相关计算形式
1.2 分布式系统概述
1.2.1 分布式系统的定义
1.2.2 经典的分布式系统与项目
1.2.3 分布式系统的特征
1.3 分布式计算的基础技术
1.3.1 进程间通信
1.3.2 IPC程序接口原型
1.3.3 事件同步
1.3.4 死锁和超时
1.3.5 事件状态图
1.3.6 进程间通信范型的演变
习题
参考文献
第2章 分布式计算范型
2.1 消息传递范型
2.2 客户/服务器范型
2.3 P2P范型
2.4 消息系统范型
2.5 远程过程调用范型
2.6 分布式对象范型
2.6.1 远程方法调用
2.6.2 对象请求代理
2.7 网络服务范型
2.8 移动代理范型
2.9 云服务范型
习题
参考文献
第3章 Socket编程与客户/服务器应用开发
3.1 Socket概述与分类
3.2 数据包Socket API
3.2.1 无连接数据包Socket API
3.2.2 面向连接数据包Socket API
3.3 流式Socket API
3.4 客户/服务器范型概述与应用开发方法
3.4.1 客户/服务器范型概念
3.4.2 客户/服务器范型的关键问题
3.5 基于三层软件的客户/服务器应用开发方法
3.5.1 软件体系结构
3.5.2 采用无连接数据包Socket的Daytime客户/服务器应用
3.5.3 采用流式Socket的Daytime客户/服务器应用
3.6 无连接与面向连接服务器程序的开发
3.6.1 无连接Echo客户/服务器
3.6.2 面向连接Echo客户/服务器
3.7 迭代与并发服务器程序的开发
3.8 有状态与无状态服务器程序的开发
习题
参考文献
第4章 RMI范型与应用
4.1 分布式对象范型
4.1.1 分布式对象范型的概念
4.1.2 分布式对象范型的体系结构
4.1.3 分布式对象系统
4.2 RMI
4.2.1 远程过程调用
4.2.2 RMI概述
4.2.3 Java RMI体系结构
4.2.4 stub和skeleton
4.2.5 对象注册
4.3 RMI基本应用开发
4.3.1 远程接口
4.3.2 服务器端软件
4.3.3 客户端软件
4.3.4 RMI应用代码示例
4.3.5 RMI应用构建步骤
4.3.6 RMI和Socket API的比较
4.4 RMI高级应用
4.4.1 客户回调
4.4.2 stub下载
4.4.3 RMI安全管理器
习题
参考文献
第5章 Web原理与应用开发
5.1 HTTP协议
5.1.1 WWW
5.1.2 TCP/IP
5.1.3 HTTP协议原理
5.2 Web开发技术
5.2.1 HTML
5.2.2 JavaScript
5.2.3 CSS
5.2.4 XML
5.2.5 动态网页技术
5.3 CGI
5.3.1 CGI原理
5.3.2 Web表单
5.4 Web会话
5.4.1 Cookie机制
5.4.2 Session机制
5.5 Applet
5.6 Servlet
5.7 SSH框架与应用开发
5.7.1 SSH
5.7.2 Struts
5.7.3 Spring
5.7.4 Hibernate
5.7.5 基于SSH的应用开发
案例
习题
参考文献
第6章 P2P原理与实践
6.1 P2P概述
6.1.1 P2P的概念
6.1.2 P2P的发展历程
6.1.3 P2P的技术特点
6.1.4 P2P的实践应用
6.2 P2P网络的分类
6.3 P2P的典型应用系统
6.4 P2P编程实践
6.5 P2P的研究现状与未来发展
6.5.1 P2P的研究现状
6.5.2 P2P的未来发展
习题
参考文献
第7章 Web Services
7.1 Web Services概述
7.1.1 Web Services的背景和概念
7.1.2 Web Services的特点
7.1.3 Web Services的应用场合
7.1.4 Web Services技术架构
7.1.5 Web Services工作原理
7.1.6 Web Services的开发
7.2 XML
7.2.1 XML概述
7.2.2 XML文档和语法
7.2.3 XML命名空间
7.2.4 XML模式
7.3 基于SOAP的Web Services
7.3.1 SOAP概述
7.3.2 SOAP消息结构
7.3.3 SOAP消息交换模型
7.3.4 SOAP应用模式
7.3.5 WSDL
7.3.6 UDDI
7.3.7 开发基于SOAP的Web Services
习题
参考文献
第8章 云计算原理与技术
8.1 云计算概述
8.1.1 云计算的起源
8.1.2 云计算的定义
8.1.3 云计算的分类
8.1.4 云计算与其他计算形式
8.2 云计算关键技术
8.2.1 体系结构
8.2.2 数据存储
8.2.3 计算模型
8.2.4 资源调度
8.2.5 虚拟化
8.3 Google云计算原理
8.3.1 GFS
8.3.2 MapReduce
8.3.3 BigTable
8.3.4 Dremel
8.4 Amazon云服务
8.4.1 Amazon云平台存储架构
8.4.2 其他组件
8.5 云计算研究与发展方向
8.5.1 云资源调度与任务调度
8.5.2 云计算能耗管理
8.5.3 基于云计算的应用
8.5.4 云计算安全
习题
参考文献
第9章 云计算模拟编程实践
9.1 CloudSim体系结构和API
9.1.1 CloudSim体系结构
9.1.2 CloudSim3.0 API
9.2 CloudSim环境搭建及程序运行
9.2.1 环境配置
9.2.2 运行样例程序
9.3 CloudSim扩展编程
9.3.1 调度策略的扩展
9.3.2 仿真核心代码
9.3.3 平台重编译
9.4 CloudSim编程实践
9.4.1 CloudSim任务调度编程
9.4.2 CloudSim网络编程
9.4.3 CloudSim能耗编程
习题
参考文献
第10章 云存储技术
10.1 存储概述
10.1.1 存储组网形态
10.1.2 RAID
10.1.3 磁盘热备
10.1.4 快照
10.1.5 数据分级存储的概念
10.2 云存储的概念与技术原理
10.2.1 分布式存储
10.2.2 存储虚拟化
10.3 云存储产品与系统
10.3.1 公有云的云存储产品
10.3.2 私有云的云存储产品
10.4 对象存储技术
10.4.1 对象存储架构
10.4.2 传统块存储与对象存储
10.4.3 对象
10.4.4 对象存储系统的组成
10.5 存储技术的发展趋势
习题
参考文献
第11章 大数据技术与实践
11.1 大数据概述
11.1.1 大数据产生的背景
11.1.2 大数据的定义
11.1.3 大数据的4V特征
11.2 大数据存储平台
11.2.1 HDFS
11.2.2 HBase
......
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式计算、云计算与大数据
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Akka实战：快速构建高可用分布式应用
Contents  目录
前言
第1章　认识Akka1
1.1　Akka简介1
1.1.1　技术背景1
1.1.2　Akka是什么3
1.2　Akka应用场景4
1.3　Akka架构体系4
1.3.1　Actor模型4
1.3.2　体系结构4
1.4　本章小结7
第2章　走进Actor8
2.1　Actor组件8
2.1.1　Akka中的Actor8
2.1.2　ActorSystem与监管9
2.1.3　生命周期监控9
2.1.4　引用与路径10
2.2　Akka环境搭建10
2.2.1　环境准备11
2.2.2　使用Lightbend Activator平台12
2.3　创建一个Actor14
2.3.1　定义Actor14
2.3.2　创建Actor实例14
2.3.3　工厂模式---Props/Creator15
2.4　发送-接收消息16
2.4.1　tell方法16
2.4.2　ask方法17
2.4.3　消息转发18
2.5　查找一个Actor18
2.6　消息不可变21
2.7　Actor行为切换21
2.8　Actor生命周期25
2.9　停掉一个Actor26
2.10　监督与容错处理29
2.11　Circuit Breaker（熔断）33
2.12　配置相关35
2.13　本章小结36
第3章　线程调度38
3.1　什么是Dispatcher？38
3.2　Executor选择39
3.3　配置Dispatcher39
3.4　使用Dispatcher41
3.5　PinnedDispatcher41
3.6　本章小结42
第4章　邮箱43
4.1　消息处理顺序43
4.2　默认邮箱配置44
4.3　内置邮箱45
4.3.1　内置邮箱说明45
4.3.2　自定义优先级45
4.3.3　控制指令优先48
4.4　Actor使用邮箱的多种方式49
4.4.1　配置Actor邮箱49
4.4.2　配置dispatcher邮箱49
4.4.3　实现RequiresMessageQueue接口50
4.5　自定义邮箱类型50
4.6　本章小结52
第5章　消息路由53
5.1　Router和Routee53
5.2　路由器及路由逻辑53
5.3　路由Actor56
5.3.1　Pool方式56
5.3.2　Group方式58
5.4　常见路由类型59
5.4.1　广播-Broadcast60
5.4.2　最快响应-ScatterGatherFirstCompleted61
5.4.3　随机-最快响应-TailChopping62
5.4.4　创建可修改容量的池62
5.5　特殊消息处理63
5.5.1　Broadcast消息64
5.5.2　PoisonPill消息64
5.5.3　其他管理类消息64
5.6　本章小结65
第6章　实用工具67
6.1　定时调度—Scheduler67
6.2　处理并发结果—Future68
6.2.1　Future常规用法68
6.2.2　函数式Future70
6.3　事件总线72
6.3.1　实现事件总线72
6.3.2　事件流处理74
6.4　日志处理75
6.4.1　基础配置76
6.4.2　使用slf4j76
6.5　Akka扩展78
6.5.1　TypedActor初探78
6.5.2　自定义扩展81
6.5.3　集成Spring83
6.6　Akka I/O87
6.6.1　TCP服务87
6.6.2　UDP服务90
6.7　Akka Streams91
6.7.1　Streams组件91
6.7.2　组合Source、Sink94
6.7.3　案例：日志处理95
6.7.4　错误处理99
6.7.5　关联Actor101
6.8　本章小结102
第7章　远程103
7.1　远程介绍103
7.1.1　Java RPC103
7.1.2　Akka远程106
7.2　创建远程ActorSystem107
7.3　Actor远程访问108
7.4　创建远程Actor109
7.5　远程路由器110
7.6　远程事件113
7.7　序列化114
7.7.1　Protobuf框架114
7.7.2　序列化API115
7.8　本章小结116
第8章　集群117
8.1　Akka集群概述117
8.1.1　种子节点118
8.1.2　领导节点118
8.1.3　节点状态及生命周期118
8.1.4　故障检测119
8.2　创建Akka集群119
8.2.1　代码及集群配置119
8.2.2　启动集群122
8.2.3　加入集群123
8.2.4　akka-cluster集群工具123
8.3　集群示例—实现文章单词统计125
8.3.1　示例分析125
8.3.2　代码实现127
8.4　使用路由133
8.4.1　Group路由133
8.4.2　Pool路由133
8.5　集群指标136
8.5.1　指标收集136
8.5.2　基于指标的负载均衡138
8.6　集群单例139
8.7　集群客户端140
8.7.1　集群客户端概述140
8.7.2　使用 ClusterClient141
8.7.3　事件监听142
8.8　集群分片143
8.8.1　分片概念143
8.8.2　持久化Actor144
8.8.3　分片示例148
8.9　本章小结155
第9章　HTTP服务156
9.1　HTTP协议156
9.1.1　header信息157
9.1.2　状态码159
9.2　Akka HTTP159
9.2.1　配置依赖159
9.2.2　HTTP服务端160
9.2.3　请求和响应160
9.2.4　HTTP客户端163
9.2.5　使用Routing DSL163
9.2.6　常用Directive165
9.3　Akka WebSocket166
9.3.1　WebSocket协议167
9.3.2　Akka WebSocket167
9.3.3　WebSocket应用之聊天室169
9.4　本章小结176
第10章　微服务全家桶之Lagom177
10.1　Lagom简介177
10.2　Lagom初探178
10.3　搭建Lagom服务181
10.3.1　项目结构181
10.3.2　编写Lagom服务182
10.4　持久化实体186
10.4.1　持久化简介186
10.4.2　PersistentEntity API187
10.4.3　持久化示例187
10.4.4　MySQL支持191
10.5　Lagom部署（SandBox）192
10.5.1　安装ConductR SandBox192
10.5.2　部署Maven项目195
10.6　本章小结199
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Akka实战：快速构建高可用分布式应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式对象存储

前言
资源与支持
第1章　对象存储简介
第2章　可扩展的分布式系统
第3章　元数据服务
第4章　数据校验和去重
第5章　数据冗余和即时修复
第6章　断点续传
第7章　数据压缩
第8章　数据维护
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式对象存储
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式消息中间件实践
第1 章 消息队列  1
1.1 系统间通信技术介绍  1
1.2 为何要用消息队列  2
1.3 消息队列的功能特点  6
1.4 设计一个简单的消息队列  8
1.4.1 消息处理中心  9
1.4.2 客户端访问  12
第2 章 消息协议  16
2.1 AMQP  17
2.2 MQTT  22
2.3 STOMP  31
2.4 XMPP  37
2.5 JMS  48
第3 章 RabbitMQ  59
3.1 简介  59
3.2 工程实例  63
3.2.1 Java 访问RabbitMQ 实例  63
3.2.2 Spring 整合RabbitMQ  67
3.2.3 基于RabbitMQ 的异步处理  69
3.2.4 基于RabbitMQ 的消息推送  75
3.3 RabbitMQ 实践建议  80
3.3.1 虚拟主机  80
3.3.2 消息保存  81
3.3.3 消息确认模式  83
3.3.4 消费者应答  84
3.3.5 流控机制  87
3.3.6 通道  88
3.3.7 总结  88
第4 章 ActiveMQ  89
4.1 简介  89
4.2 工程实例  95
4.2.1 Java 访问ActiveMQ 实例  95
4.2.2 Spring 整合ActiveMQ  100
4.2.3 基于ActiveMQ 的消息推送  108
4.2.4 基于ActiveMQ 的分布式事务  113
4.3 ActiveMQ 实践建议  136
4.3.1 消息转发模式  136
4.3.2 消息积压  137
4.3.3 消息事务  139
4.3.4 消息应答模式  140
4.3.5 消息发送优化  141
4.3.6 消息消费优化  142
4.3.7 消息协议  145
4.3.8 消息持久化  147
第5 章 Kafka  148
5.1 简介  148
5.2 工程实例  150
5.2.1 Java 访问Kafka 实例  150
5.2.2 Spring 整合Kafka  154
5.2.3 基于Kafka 的用户行为数据采集  158
5.2.4 基于Kafka 的日志收集  174
5.2.5 基于Kafka 的流量削峰  177
5.3 Kafka 实践建议  191
5.3.1 分区  191
5.3.2 复制  192
5.3.3 消息发送  193
5.3.4 消费者组  196
5.3.5 消费偏移量  197
第6 章 RocketMQ  201
6.1 简介  201
6.2 工程实例  206
6.2.1 Java 访问RocketMQ 实例  206
6.2.2 Spring 整合RocketMQ  211
6.2.3 基于RocketMQ 的消息顺序处理  219
6.2.4 基于RocketMQ 的分布式事务  234
6.3 RocketMQ 实践建议  261
6.3.1 消息重试  261
6.3.2 消息重复  264
6.3.3 集群  266
6.3.4 顺序消息  270
6.3.5 定时消息  270
6.3.6 批量发送消息  271
6.3.7 事务消息  274
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式消息中间件实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>区块链经济学
前 言
第1章 货币本源——货币的本质是一种记账技术
货币，智人独有的社会技术
货币是一种记账的“方便法门”
货币的起源是一种自发秩序
货币的虚拟化
作为记账凭据的货币
弗里德曼预言的虚拟货币
铸币是战争的产物
以武力为后盾的信用货币
明朝的金融危机
自发秩序与顶层设计
失败的“竞争货币”实践
第2章 数字法币——区块链的第一个“杀手级应用”
私人货币
数字货币的萌芽
为什么要推出数字法币
智能货币——区块链经济1.0
网络效应决定了数字法币更强大
数字法币的推出只是一个时机问题
第3章 价值网络——从信息互联到价值互联
军备竞赛产生了互联网
军事欺骗产生了密码学
密码朋克
“互联网精神”的回归
区块链是一种价值网络
双重支付与“拜占庭将军问题”
对黄金自发秩序的临摹
提高做叛徒的成本
公钥和私钥
哈希算法
算力怪兽与尴尬的中心化
硬分叉，分裂的共识
PoS机制与DPoS机制
第4章 加密账术——金融危机的本质是账本危机
古老的记账技术
文艺复兴时代的“纸质版本区块链”
现代会计的灵魂
复式记账法催生股份制公司
账本炼金术
弱中心化，一种切实可行的方案
第5章 通证经济——加密经济学与人类行为
代币与人类行为
无币区块链与有币区块链
Q币模式是代币监管的底线
网游是通证经济的急先锋
加密经济学与以太坊
Steemit的“脑力证明机制”
第6章 智能合约——智能化可编程经济形态
尼克•萨博，神似中本聪的人
图灵完备的智能合约平台
智能合约——区块链经济2.0
智能财产与分享经济
彩票——呼之欲出的区块链应用
第7章 智能社群——群体智慧与分布式自律
分布式管理的真义
自律与管理的仿生学
预测市场与预言机
智能社群——区块链经济3.0
DAO与大规模强协作
第8章 机器信任——事实证明与履历追踪
降低“非市场性交易成本”
数字身份与“区块链共和国”
食品“上链”，安全溯源
学历认证
医疗卫生
公益慈善
第9章 金融科技——区块链与金融技术创新
原有金融科技（FinTech）已经落伍
危机驱使巨头做出改变
委内瑞拉的“石油币”实验
保险业，向互助式社群回归
第10章 技术融合——区块链赋能第四次工业革命
“万物互联”与“万物账本”
区块链赋能第四次工业革命
分布式能源与分布式账本
第11章 文创复兴——重构文创、教育产业的新生态
知识产权的“加密容器”
IP存证服务
版权“指纹”与艺术认证
智能资产的确权、加密和流通
产消者崛起，免费模式势微
区块链为文化教育产业赋能
第12章 理性繁荣——区别对待，合理监管
ICO乱象——代币证券化
区块链的“浮士德契约”
预测市场与暗杀赌局
代码即法律吗
去中心化，听起来很美
监管科技（RegTech），以链治链
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>区块链经济学
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Cloud Native 分布式架构原理与实践
第1章 Cloud Native 概述
1.1 当今软件发展的现状
1.1.1 软件需求的发展
1.1.2 开发方式的巨变
1.1.3 云是大势所趋
1.2 Cloud Native 的特性
1.2.1 以云为基础架构
1.2.2 云服务
1.2.3 无服务
1.2.4 可扩展
1.2.5 高可用
1.2.6 敏捷
1.2.7 云优先
1.3 12-Factor
1.3.1 基准代码
1.3.2 依赖
1.3.3 配置
1.3.4 后端服务
1.3.5 构建、发布和运行
1.3.6 进程
1.3.7 端口绑定
1.3.8 并发
1.3.9 易处理
1.3.10 开发环境与线上环境等价
1.3.11 日志
1.3.12 管理进程
1.4 成功案例
1.4.1 Amazon
1.4.2    Netflix
1.4.3 淘宝网
1.5 Cloud Native 与微服务
1.5.1 微服务概述
1.5.2 从单块架构向微服务演进
1.5.3 Cloud Native 与微服务部署
1.6 总结
1.6.1 Cloud Native 的优点
1.6.2 Cloud Native 不是“银弹”
1.6.3 面临的挑战
第2章 REST API
2.1 REST 概述
2.1.1 REST 的定义
2.1.2 REST 设计原则
2.2 成熟度模型
2.2.1 第0级：使用 HTTP 作为传输方式
2.2.2 第1级：引入了资源的概念
2.2.3 第2级：根据语义使用 HTTP 动词
2.2.4 第3级：使用 HATEOAS
2.3 Java REST
2.3.1 JAX-RS 规范
2.3.2 Jersey 框架
2.3.3 Apache CXF 框架
2.3.4 Spring Web MVC 框架
2.4 内容协商
2.4.1 二进制数据
2.4.2 Google Protocol Buffers 传输协议
2.5 异常处理
2.5.1 HTTP 状态码
2.5.2 自定义异常信息
2.6 API 管理
2.6.1 版本化
2.6.2 文档化
2.6.3 可视化
2.7 客户端
2.7.1 浏览器插件
2.7.2 JAX-RS 客户端
2.7.3 Spring 客户端
2.8 实战：开启第一个微服务
2.8.1 初始化一个 Spring Boot 原型
2.8.2 用 Gradle 编译项目
2.8.3 探索项目
2.8.4 实现第一个服务
第3章 Cloud Native 测试
3.1 测试概述
3.1.1 传统测试所面临的问题
3.1.2 如何破解测试面临的问题
3.2 测试的类型、范围和比例
3.2.1 测试类型
3.2.2 测试范围
3.2.3 测试比例
3.3 如何进行微服务的测试
3.3.1 微服务的单元测试
3.3.2 Mock 与 Stub 的区别
3.3.3 微服务的集成测试
3.3.4 微服务的系统测试
3.3.5 保障代码覆盖率
3.4 Spring 测试框架
3.4.1 Spring TestContext 框架
3.4.2 Spring MVC Test 框架
3.4.3 Spring Boot Test 框架
第4章 服务路由
4.1 如何找到服务
4.1.1 DNS
4.1.2 服务注册与发现
4.1.3 客户端发现机制
4.1.4 服务端发现机制
4.2 实战：实现服务注册与发现
4.2.1 选择 Eureka的原因
4.2.2 集成 Eureka Server
4.2.3 集成 Eureka Client
4.2.4 服务的注册与发现
第5章 Cloud Native 安全
5.1 认证与授权
5.1.1 基本认证
5.1.2 摘要认证
5.1.3 摘要认证的密码加密
5.1.4 通用密码加密
5.1.5 基于散列的令牌方法
5.1.6 基于持久化的令牌方法
5.2 Java 安全框架
5.2.1 Apache Shiro
5.2.2 Spring Security
5.2.3 Spring Cloud Security
5.3 OAuth 2.0 认证
5.3.1 OAuth 2.0 的认证原理
5.3.2 OAuth 2.0 的核心概念
5.3.3 OAuth 2.0 的认证流程
5.4 实战：实现单点登录
5.4.1 项目依赖
5.4.2 编码实现
5.4.3 应用配置
5.4.4 运行
第6章 Cloud Native 数据管理
6.1 数据的存储方式
6.1.1 关系型数据库
6.1.2 NoSQL
6.2 DDD 与数据建模
6.2.1 DDD 概述
6.2.2 运用 DDD 进行数据建模
6.3 常用数据访问方式
6.3.1 JDBC
6.3.2 Spring JDBC
6.3.3 JPA
6.4 Spring Data
6.4.1 Spring Data 概述
6.4.2 Spring Data JPA
6.4.3 Spring Data Elasticsearch
6.4.4 Spring Data Redis
6.4.5 Spring Data MongoDB
6.4.6 实战：基于 MongoDB 的文件服务器
第7章 Cloud Native 消息通信
7.1 消息通信概述
7.1.1 消息通信的基本概念
7.1.2 JMS
7.1.3 事件驱动的架构
7.2 消息通信常用模式
7.2.1 点对点模式
7.2.2 发布—订阅模式
7.3 CQRS
7.3.1 CQRS 概述
7.3.2 CQRS 的好处
7.3.3 实战：实现 CQRS
7.4 Spring Cloud Stream
7.4.1 Spring Cloud Stream 概述
7.4.2 Spring Cloud Stream 实现发布者
7.4.3 Spring Cloud Stream 实现消费者
7.4.4 实战：基于 Spring Cloud Stream 的消息通信
第8章 Cloud Native 批处理
8.1 批处理概述
8.1.1 需要批处理的原因
8.1.2 常用批处理实现方式
8.2 JDBC Batch
8.2.1 Statement 与 PreparedStatement
8.2.2 实战：使用 JDBC Batch 的例子
8.3 Spring 批处理
8.3.1 使用 JdbcTemplate 实现批处理
8.3.2 批量更新 List
8.3.3 多个批次更新
8.4 Spring Batch
8.4.1 Spring Batch 概述
8.4.2 Job
8.4.3 JobLauncher
8.4.4 JobRepository
8.4.5 Step
8.4.6 ItemReader
8.4.7 ItemWriter
8.4.8 ItemProcessor
8.4.9 实战：使用 Spring Batch 的例子
第9章 Cloud Native 任务调度
9.1 任务执行与调度概述
9.2 Spring TaskExecutor
9.2.1 TaskExecutor 类型
9.2.2 TaskExecutor 应用
9.3 Spring TaskScheduler
9.3.1 Trigger 接口
9.3.2 Trigger 接口的实现
9.4 Spring 任务调度及异步执行
9.4.1 启用调度注解
9.4.2 @Scheduled 注解
9.4.3 @Async 注解
9.4.4 @Async 的异常处理
9.4.5 命名空间
9.5 使用 Quartz Scheduler
9.5.1 使用 JobDetailFactoryBean
9.5.2 使用 MethodInvokingJobDetailFactoryBean
9.6 实战：基于 Quartz Schedule 的天气预报系统
9.6.1 项目概述
9.6.2 后台编码实现
9.6.3 运行
第10章 Cloud Native 运营
10.1 CAP 理论
10.1.1 CAP 理论概述
10.1.2 CAP 只能三选二的原因
10.1.3 CAP 常见模型
10.1.4 CAP 的意义
10.1.5 CAP 的发展
10.2 服务的熔断
10.2.1 熔断的意义
10.2.2 Hystrix 概述
10.2.3 实战：实现微服务的熔断机制
10.3 代码管理
10.3.1 Git 简介
10.3.2 Git 核心概念
10.3.3 Git Flow
10.4 日志管理
10.4.1 日志框架概述
10.4.2 分布式下的日志管理
10.4.3 集中化日志分析
10.4.4 实战：基于 Elastic Stack 的集中化日志管理
10.5 配置管理
10.5.1 分布式下的配置管理的痛点
10.5.2 集中化配置
10.5.3  Spring Cloud Config
10.5.4 实战：基于 Config 实现的配置中心
10.6 应用监控
10.6.1 心跳
10.6.2 Eureka 监测机制
10.6.3 Spring Boot Actuator
10.6.4 实战：基于 Spring Boot Actuator 监测的例子
第11章 Cloud Native 持续发布
11.1 持续集成与持续交付
11.1.1 持续集成概述
11.1.2 持续交付与持续部署
11.1.3 持续交付与持续部署的意义
11.2 持续交付流水线
11.2.1 流水线概述
11.2.2 构建持续交付流水线
11.2.3 构建流水线的工具
11.3 微服务的管理与发布
11.3.1 两个比萨的故事
11.3.2 DevOps 文化
11.3.3 微服务的发布
11.4 容器
11.4.1 虚拟化技术
11.4.2 容器与虚拟机
11.4.3 基于容器的持续部署流程
11.4.4 实战：使用 Docker 来构建、运行和发布微服务
11.5 发布到云
11.5.1 常用云服务
11.5.2 实战：发布应用到云
附录 本书所涉及的技术及相关版本
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Cloud Native 分布式架构原理与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>电子商务环境中分布式数据挖掘的研究
摘  要	I
ABSTRACT	III
目  录	V
第一章 绪论	1
第一节 研究背景及意义	1
第二节 国内外研究现状与分析	2
一、研究现状简述	2
二、研究现状分析	7
第三节 本文主要研究内容	9
第四节 本文主要研究成果	10
第五节 本文的组织结构	11
第二章 数据挖掘、WEB服务与AGENT技术	13
第一节 电子商务分析	13
一、电子商务的概念	13
二、电子商务系统的构成	13
三、电子商务的主要模式	14
四、电子商务的发展阶段	18
五、电子商务发展的现状	18
六、电子商务环境的特征	19
七、电子商务应用集成的不足	21
第二节 数据挖掘技术	24
一、数据挖掘的功能	24
二、数据挖掘方法	26
三、数据挖掘的分类	34
四、数据挖掘的过程	35
五、数据准备问题	36
六、模式评价方法	37
第三节 数据挖掘算法	39
一、数据挖掘算法的组成	40
二、数据挖掘算法综述	40
第四节 分布式数据挖掘	44
一、分布式数据挖掘定义	45
二、分布式数据挖掘的特点	46
三、分布式数据挖掘策略	47
第五节 电子商务环境与数据挖掘	48
一、电子商务环境中挖掘数据分类	48
二、电子商务环境中数据挖掘的优势	49
三、电子商务环境中分布式数据挖掘的特点	49
第六节 服务与面向服务的分布计算	50
第七节 WEB服务技术	52
一、Web服务的基本概念	54
二、Web Services核心技术	56
三、Web服务组合	60
四、P2P环境中的Web服务	68
五、Web服务和网格计算	69
六、利用Web服务进行电子商务集成的优点	71
第八节 移动AGENT技术	72
一、软件Agent的定义及特性	72
二、移动Agent概述	74
三、移动Agent技术与其他分布式计算技术的比较	78
四、移动Agent的应用领域	79
五、移动Agent技术应用于电子商务的优势	80
第九节 本章小结	81
第三章 基于P2P的K最近邻自适应搜索算法的研究	82
第一节 问题提出	82
第二节 KNNS简介	83
第三节 相关研究	85
一、度量空间	85
二、相似性度量	86
三、GHT*规则	87
第四节 P2PAKNNS算法	87
一、高维数据的相似度函数 	88
二、GHT*中插入和范围查找算法	88
三、搜索算法	90
四、实验分析	96
第五节 本章小结	97
第四章 基于距离和密度的无监督聚类算法的研究	99
第一节 问题提出	99
第二节 聚类简介	99
一、概述	99
二、数据挖掘对聚类算法的要求	101
三、相似性度量方法	102
四、聚类的质心、半径、直径	103
第三节 DENCLUE算法分析	103
第四节 KNDC聚类算法	105
一、分析	105
二、模糊簇的划分	105
三、参数 的讨论	108
四、参数 和 的估计	109
五、KNDC算法描述	110
第五节 本章小结	111
第五章 电子商务环境下关联规则算法的研究	112
第一节 问题提出	112
第二节 关联规则算法分析	113
一、基本概念	113
二、Apriori关联规则算法	114
三、多重最小支持度Apriori算法	116
四、相关支持度Apriori 算法	118
五、平均项目集分割法	120
第三节 RSAA-BOUIGA关联规则算法	122
一、无向项集图UISG的构造	122
二、BOUIGA算法	123
三、RSAA-BOUIGA算法	124
第四节 双阈值法	126
第五节 本章小结	128
第六章 电子商务环境中分布式数据挖掘架构研究	129
第一节 问题提出	129
第二节 分布式数据挖掘系统分析	130
第三节 BWADM研究	131
第四节 服务组合规范与执行	135
第五节 BWADM关键组件研究	138
一、数据预处理组件	138
二、算法管理组件	142
三、控制中心组件	143
四、算法库组件	144
五、模型表示组件	144
第六节 BWADM原型	145
一、数据挖掘系统实现方案	145
二、原型系统的数据流程图	146
三、系统模块设计与实现	147
第七节 原型系统的运行实例	158
一、数据源信息和结果数据库信息设定	158
二、数据预处理设定	159
三、挖掘任务设定	160
四、挖掘结果	161
第八节 系统架构的优点	162
第九节 本章小结	163
第七章 电子商务推荐系统研究	164
第一节 问题提出	164
第二节 电子商务推荐系统简介	164
一、信息检索和信息过滤	166
二、电子商务推荐系统模型简介	168
三、传统推荐算法简介	176
四、基于数据挖掘的电子商务推荐系统	184
第三节 电子商务推荐系统关键算法研究	186
一、基于P2PAKNNS的协同过滤推荐算法	186
二、基于KNDC的协同过滤推荐算法	189
第四节 基于BWADM的隐式评分推荐系统研究	191
一、BP学习算法简介	194
二、系统结构	195
三、项档案的建立	196
四、用户档案的建立	197
五、协同过滤推荐的产生	204
六、面向推荐结果的自动谈判协商	205
第五节 本章小结	210
第八章 基于BWADM的电子商务推荐系统设计与实现	211
第一节 简介	211
第二节 BDBRS功能结构图	213
第三节 BDBRS原型系统的体系结构	214
第四节 BDBRS的设计与实现	216
一、数据库设计	216
二、BDBRS系统部分模块设计介绍	219
第五节 本章小结	222
第九章 全文总结	224
一、研究工作总结	224
二、进一步的研究工作	225
参考文献	226
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>电子商务环境中分布式数据挖掘的研究
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>智能运维：从0搭建大规模分布式AIOps系统
第1篇 开门见山：运维发展史
第1章 运维现状  2
1.1 运维工程  2
1.1.1 认识运维  2
1.1.2 主要职责  4
1.1.3 运维技术  5
1.2 运维发展历程  6
1.2.1 人工阶段  6
1.2.2 工具和自动化阶段  7
1.2.3 平台化阶段  7
1.2.4 智能运维阶段  8
1.3 运维现状  9
1.3.1 故障频发  9
1.3.2 系统复杂性  10
1.3.3 大数据环境  12
1.4 本章小结  14
1.5 参考文献  14
第2章 智能运维  15
2.1 海量数据的存储、分析和处理  16
2.2 多维度、多数据源  18
2.3 信息过载  19
2.4 复杂业务模型下的故障定位  21
2.5 本章小结  22
2.6 参考文献  22
第2篇 站在巨人肩上：智能运维基础设施
第3章 开源数据采集技术  25
3.1 数据采集工具对比  25
3.2 轻量级采集工具Filebeat  26
3.2.1 Filebeat工作原理  26
3.2.2 Filebeat的安装与配置  28
3.2.3 启动和运行Filebeat  38
3.3 日志采集解析工具  38
3.3.1 Logstash工作原理  39
3.3.2 安装Logstash  40
3.3.3 配置Logstash  41
3.3.4 启动Logstash  49
3.4 本章小结  49
3.5 参考文献  50
第4章 分布式消息队列  51
4.1 开源消息队列对比与分析  51
4.1.1 概述  51
4.1.2 ZeroMQ  51
4.1.3 ActiveMQ  52
4.1.4 RocketMQ  52
4.1.5 Kafka  53
4.2 Kafka的安装与使用  53
4.2.1 组件概念  53
4.2.2 基本特性  53
4.2.3 安装与使用  54
4.2.4 Java API的使用  55
4.3 案例分析  57
4.3.1 日志采集  58
4.3.2 实时结算  58
4.3.3 实时计算  58
4.4 本章小结  58
4.5 参考文献  59
第5章 大数据存储技术  60
5.1 传统数据存储  60
5.1.1 传统应用的架构  60
5.1.2 传统存储的运行机制  61
5.1.3 传统存储带来的问题  62
5.2 基于HDFS的分布式存储  63
5.2.1 分布式存储的定义  63
5.2.2 HDFS的基本原理  64
5.2.3 HDFS架构解析  65
5.2.4 HDFS的优势  66
5.2.5 HDFS不适合的场景  67
5.3 分层存储  68
5.3.1 数据仓库  68
5.3.2 数据仓库分层架构  70
5.3.3 分层存储的好处  73
5.4 案例分析  73
5.4.1 数据存储架构  73
5.4.2 数据仓库建模  74
5.4.3 常见的存储问题及解决方案  80
5.5 本章小结  80
5.6 参考文献  80
第6章 大规模数据离线计算分析  82
6.1 经典的离线计算  82
6.1.1 Linux神级工具sed和awk  82
6.1.2 Python数据处理Pandas基础  84
6.1.3 Python的优势和不足  88
6.2 分布式离线计算  89
6.2.1 MapReduce离线计算  89
6.2.2 离线计算的数据倾斜问题  97
6.2.3 分布式离线计算的技术栈  100
6.3 案例分析  101
6.3.1 离线计算管理  102
6.3.2 离线计算原子控制  103
6.3.3 离线计算的数据质量  103
6.4 本章小结  104
6.5 参考文献  105
第7章 实时计算框架  106
7.1 关于实时流计算  106
7.1.1 如何提高实时流计算的实时性  106
7.1.2 如何提高实时流计算结果的准确性  107
7.1.3 如何提高实时流计算结果的响应速度  107
7.2 Spark Streaming计算框架介绍  107
7.2.1 概述  107
7.2.2 基本概念  108
7.2.3 运行原理  108
7.2.4 编程模型  109
7.2.5 Spark Streaming的使用  110
7.2.6 优化运行时间  114
7.3 Flink计算框架  115
7.3.1 基本概念  116
7.3.2 Flink特点  116
7.3.3 运行原理  118
7.3.4 Java API的使用  121
7.4 案例分析  124
7.4.1 背景介绍  125
7.4.2 架构设计  126
7.4.3 效果分析  126
7.5 本章小结  126
7.6 参考文献  126
第8章 时序数据分析框架  127
8.1 时序数据库简介  127
8.1.1 什么是时序数据库  127
8.1.2 时序数据库的特点  128
8.1.3 时序数据库的对比  130
8.2 时序数据库Graphite  131
8.2.1 Graphite简介  131
8.2.2 Graphite在微博广告监控系统中的应用  137
8.3 多维分析利器Druid  139
8.3.1 什么是Druid  139
8.3.2 Druid架构  140
8.3.3 Druid在微博广告监控平台中的应用  144
8.4 性能神器ClickHouse  147
8.4.1 什么是ClickHouse  147
8.4.2 ClickHouse的特性  148
8.4.3 ClickHouse的不足  149
8.4.4 安装配置ClickHouse  149
8.4.5 表引擎  153
8.4.6 函数支持  157
8.5 本章小结  160
8.6 参考文献  160
第9章 机器学习框架  161
9.1 简介  161
9.2 TensorFlow介绍  162
9.2.1 什么是TensorFlow  162
9.2.2 下载安装  162
9.2.3 “Hello TensorFlow”示例  166
9.3 TensorFlow进阶  166
9.3.1 基础理论  167
9.3.2 模型准备  169
9.3.3 训练数据  169
9.3.4 模型训练  171
9.3.5 生成seq2seq句子  174
9.3.6 运行演示  175
9.4 本章小结  178
9.5 参考文献  179
第3篇 运维新时代：智能运维技术详解
第10章 数据聚合与关联技术  182
10.1 数据聚合  182
10.1.1 聚合运算  183
10.1.2 多维度聚合  186
10.2 降低维度  188
10.2.1 将告警聚合成关联“事件”  189
10.2.2 减少误报：告警分类  190
10.3 数据关联  192
10.4 实时数据关联案例  193
10.4.1 设计方案  193
10.4.2 效果  195
10.5 本章小结  195
10.6 参考文献  195
第11章 数据异常点检测技术  196
11.1 概述  196
11.2 异常检测方法  198
11.2.1 基于统计模型的异常点检测  199
11.2.2 基于邻近度的异常点检测  202
11.2.3 基于密度的异常点检测  203
11.3 独立森林  204
11.4 本章小结  207
11.5 参考文献  207
第12章 故障诊断和分析策略  208
12.1 日志标准化  209
12.2 全链路追踪  210
12.3 SLA的统一  210
12.4 传统的故障定位方法  211
12.4.1 监控告警型  211
12.4.2 日志分析型  212
12.5 人工智能在故障定位领域的应用  213
12.5.1 基于关联规则的相关性分析  213
12.5.2 基于决策树的故障诊断  217
12.6 本章小结  222
12.7 参考文献  222
第13章 趋势预测算法  223
13.1 移动平均法  223
13.2 指数平滑法  224
13.3 ARIMA模型  226
13.3.1 简介  226
13.3.2 重要概念  226
13.3.3 参数解释  228
13.3.4 建模步骤  230
13.3.5 ARIMA模型案例  232
13.4 神经网络模型  236
13.4.1 卷积神经网络  236
13.4.2 循环神经网络  238
13.4.3 长短期记忆网络  239
13.4.4 应用说明  241
13.5 本章小结  241
13.6 参考文献  242
第4篇 智能运维架构实践：技术案例详解
第14章 快速构建日志监控系统  244
14.1 Elasticsearch分布式搜索引擎  244
14.1.1 基本概念  244
14.1.2 分布式文档存储与读取  248
14.1.3 分布式文档检索  250
14.1.4 分片管理  252
14.1.5 路由策略  254
14.1.6 映射  255
14.2 可视化工具Kibana  258
14.2.1 Management  260
14.2.2 Discover  260
14.2.3 Visualize  262
14.2.4 Dashboard  263
14.2.5 Timelion  263
14.2.6 Dev Tools  264
14.3 ELK搭建实践  265
14.3.1 Logstash安装配置  265
14.3.2 Elasticsearch集群安装配置  266
14.3.3 Kibana安装配置  273
14.4 本章小结  274
14.5 参考文献  274
第15章 微博广告智能监控系统  275
15.1 背景介绍  275
15.1.1 监控指标体系  275
15.1.2 功能设计原则  276
15.2 整体架构  277
15.3 核心功能分析  278
15.3.1 全景监控  278
15.3.2 趋势预测  281
15.3.3 动态阈值  285
15.3.4 服务治理  285
15.4 本章小结  287
第16章 微博平台通用监控系统  288
16.1 背景  289
16.2 整体架构  290
16.3 核心模块  291
16.3.1 数据采集（Logtailer）  291
16.3.2 数据路由（Statsd-proxy）  293
16.3.3 聚合运算（Statsd）  294
16.3.4 数据分发（C-Relay）和数据存储  294
16.3.5 告警模块  295
16.3.6 API设计  299
16.3.7 数据可视化  300
16.4 第三方应用  301
16.4.1 决策支持系统  301
16.4.2 运维自动化  302
16.4.3 成本分析和容量日报  302
16.4.4 机器学习  302
16.5 本章小节  302
附录A 中国大数据技术大会2017（BDTC 2017）CSDN专访实录  303
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>智能运维：从0搭建大规模分布式AIOps系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高伸缩性系统：Erlang/OTP大型分布式容错设计
第 1章　概述    1
定义问题   2
OTP   4
Erlang   6
工具和库   7
系统设计原则   9
Erlang 节点   10
分布式、基础设施、多核   11
总结   12
通过本书你将学到什么   13
第 2章　Erlang.简介.    18
递归与模式匹配   18
受函数式的影响   22
玩转匿名函数   22
列表推导：生成与测试   23
进程与消息传递   25
不怕出错   30
用于监督的链接与监视器   31
链接   31
监视器   33
记录   34
映射组   37
宏   38
模块升级   39
ETS：Erlang 元素存储   41
分布式 Erlang   44
命名与通信   45
节点间的连接与可见性   45
总结   47
接下来是什么   47
第 3章　行为模式.    49
进程的骨架   49
设计模式   52
回调模块   53
抽取出通用的行为模式   56
启动 server   57
client函数   60
server循环   62
server内部函数   64
通用服务器   65
消息传递：冰山之下   68
总结   71
接下来是什么   72
第 4章　通用型服务器.gen_server.   73
gen_server   73
behavior指令   74
启动一个 server   75
消息传递   77
同步式消息传递   78
异步式消息传递   79
其他消息   81
未处理的消息   82
同步客户端   83
终止   84
调用超时   86
死锁   89
通用型 server的超时问题   90
使 behavior休眠   92
全局化   92
链接 behavior   94
总结   94
接下来是什么   95
第 5章　深入控制 OTP行为模式   96
sys模块   96
追踪与记录   96
系统消息   98
你自己的追踪函数   98
统计信息和当前状态   99
sys 模块总结   102
分裂时的可选项   103
内存管理与垃圾回收   104
分裂时应该避免使用的可选项    108
超时   109
总结   109
接下来是什么   109
第 6章　有限状态机.    110
Erlang 风格的有限状态机   111
Coffee FSM   112
硬件桩   114
Erlang 版咖啡机   114
gen_fsm   118
一个基于行为模式的例子   119
启动 FSM   119
发送事件   123
终止   132
总结   133
亲力亲为   134
电话控制器   134
让我们测试一下   136
接下来是什么   138
第 7章　事件处理器.    139
事件   139
通用事件管理器／处理器   141
启动／停止事件管理器   141
添加事件处理器   142
删除事件处理器   144
发送同步的或异步的事件   145
获取数据   148
对错误以及无效返回值的处理    150
交换事件处理器   152
融会贯通   154
SASL警报处理器   157
总结   159
接下来是什么   159
第 8章　监督者    160
监督树   161
OTP监督者   165
监督者行为模式   166
启动监督者   166
监督者规格   169
动态子进程   176
非 OTP兼容进程   184
可伸缩性和短期进程   186
确定性同步启动   187
测试你的监督策略   188
与传统方法相比又如何   190
总结   190
接下来是什么   191
第.9.章　OTP.application   192
OTP application是如何运行的   193
OTP application的结构   194
回调模块   198
启动和停止 application   198
application资源文件   202
基站控制器的 application文件    204
启动 application   205
环境变量   208
application的类型与终止策略   210
分布式 application   211
分阶段启动   215
内含型 application   217
内含型 application 的分阶段启动    217
将监督者与 application组合到一起    219
SASL应用   220
进度报告   224
错误报告   225
崩溃报告   226
监督者报告   227
总结   228
接下来是什么   229
第.10.章　基于特殊进程打造自己的 behavior   230
特殊进程   230
互斥体   231
启动特殊进程   232
互斥体的状态   235
处理退出   236
系统消息   237
跟踪与日志事件   238
合在一起   239
动态模块和休眠   243
属于你自己的 behavior   244
创建 behavior 时的要求   245
一个处理 TCP流的例子   245
总结   249
接下来是什么   250
第 11章　系统原则与发行包制作.   251
系统原则   252
发行包目录结构   253
发行包资源文件   257
创建发行包   260
创建 boot 文件   262
打包发行包   271
启动脚本以及目标上的配置  275
参数和标志   277
init模块   289
rebar3   290
生成一个 rebar3 发行包项目  292
使用 rebar3 创建发行包   295
使用 rebar3 处理制作发行包时的项目依赖问题   298
总结   300
接下来是什么   304
第 12章　发行包升级   305
软件升级   305
第一个版本的咖啡机 FSM   308
添加一个新状态   311
为发行包创建升级   314
负责升级的代码   318
应用程序升级文件   322
高级指令   325
发行包升级文件   328
低级指令   330
安装升级   332
发行包处理器   334
升级环境变量   338
升级特殊进程   338
在分布式环境下升级   339
升级模拟器和核心 application   340
使用 Rebar3进行升级   341
总结   344
接下来是什么   346
第 13章　分布式架构   347
节点类型与家族   348
联网   351
分布式 Erlang   353
套接字与 SSL   359
面向服务和微服务的架构   361
点对点   362
接口   364
总结   366
接下来是什么   367
第.14.章　永不停止的系统   368
可用性   368
容错   369
弹性   370
可靠性   371
数据共享   375
一致性和可用性之间的权衡  383
总结   384
接下来是什么   385
第.15.章　水平规模伸缩   386
水平规模伸缩与垂直规模伸缩   386
容量规划   390
容量测试   392
平衡你的系统   394
找寻瓶颈   396
系统蓝图   398
负载调节与背压   399
总结   401
接下来是什么   403
第 16章　监视与抢救性支持   404
监视   405
日志   406
指标   411
警报   414
抢救性支持   416
总结   418
接下来是什么   420
索引   421
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高伸缩性系统：Erlang/OTP大型分布式容错设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>商业银行分布式架构实践
目　录
第1章　商业银行科技转型思考与探索	1
1.1　当前时代背景下的银行业务特性	2
1.2　新业态下银行科技特性与架构转型思考	6
1.2.1　新时代背景下银行信息科技特性	7
1.2.2　银行科技架构转型思考	9
1.3　分布式架构的选择	12
第2章　分布式系统建设理念	17
2.1　分布式架构	17
2.2　分布式架构转型理念	19
2.3　分布式架构转型中的挑战	21
2.3.1　“分”的挑战	21
2.3.2　“合”的挑战	22
2.4　分布式经典理论	24
2.4.1　ACID理论	25
2.4.2　CAP理论	26
2.4.3　BASE理论	28
第3章　分布式架构设计模式	31
3.1　分布式应用设计	31
3.1.1　分布式应用设计原则	31
3.1.2　分布式应用服务设计在金融行业中面临的问题和挑战	32
3.1.3　分布式应用服务实施建议	33
3.2　应用设计模式	38
3.2.1　通道型应用	39
3.2.2　前置网关型应用	41
3.2.3　读写分离产品型应用(包括数据型应用)	42
3.2.4　分库分表型应用	44
3.2.5　分区多活产品型应用	47
第4章　关键技术能力建设	51
4.1　云平台(基础设施弹性)	51
4.1.1　发现云计算	51
4.1.2　认识云计算	53
4.1.3　云计算和分布式技术	56
4.1.4　金融行业遇到云计算	57
4.1.5　金融行业IaaS建设探索	60
4.1.6　金融行业PaaS参考架构	62
4.1.7　云计算技术未来展望	64
4.2　服务治理	65
4.2.1　服务治理技术概述	65
4.2.2　金融行业服务治理实施策略	78
4.3　分布式数据访问	86
4.3.1　选择分布式数据库方案	87
4.3.2　金融核心数据分库分表拆分方案	88
4.3.3　分库分表中间件	90
4.3.4　数据扩容	98
4.3.5　结语	100
4.4　分布式事务	101
4.4.1　单库事务	101
4.4.2　最大努力一阶段提交(Best Effort 1PC)	102
4.4.3　XA两阶段提交	103
4.5　消息中心	104
4.5.1　应用场景和解决问题	105
4.5.2　实现方式及通用设计	106
4.5.3　消息中心实践	108
4.5.4　应用使用要点和规范	112
4.5.5　典型开源技术及对比	114
4.6　全局序列号生成器 	116
4.6.1　全局序列生成器技术架构	116
4.6.2　全局序列号生成器服务接口设计	118
4.7　缓存	118
4.7.1　缓存介绍	118
4.7.2　本地缓存	120
4.7.3　应用级缓存	122
4.7.4　分布式缓存	129
4.7.5　探索和实践	129
4.7.6　总结和展望	131
4.8　分布式存储	131
4.8.1　分布式存储介绍	131
4.8.2　分布式存储在金融行业的前景	132
4.8.3　分布式存储发展方向	134
4.8.4　分布式存储部署使用原则	135
4.8.5　分布式存储部署架构	136
4.9　大数据技术	137
4.9.1　大数据概述	137
4.9.2　银行数据架构设计	140
4.9.3　结语	152
第5章　高可用、同城双活与灾备	155
5.1　分布式多活技术架构	155
5.1.1　分布式架构双活设计原则	155
5.1.2　分区多活架构设计	156
5.2　数据库高可用与灾备技术	158
5.2.1　数据库高可用性选型	158
5.2.2　MySQL高可用方案的具体实现	159
5.2.3　MySQL的同城与容灾方案	160
5.3　小结	164
第6章　开发运行效能建设	165
6.1　挑战、背景与目标	165
6.1.1　机遇与挑战	165
6.1.2　银行信息科技的发展趋势	166
6.1.3　分布式架构下的特点与难题	167
6.1.4　目标	167
6.2　DevOps体系	169
6.3　DevOps流程体系	174
6.4　DevOps整体设计思路	175
6.4.1　金融行业流程体系现状	175
6.4.2　DevOps整体设计思路	176
6.5　DevOps体系建设	178
6.5.1　快速类流程体系整体思路	178
6.5.2　传统类流程体系整体思路	180
6.6　DevOps核心领域建设	180
6.6.1　需求条目化管理	180
6.6.2　分支管理	181
6.6.3　持续集成	182
6.6.4　持续交付	184
6.7　运维体系化建设	187
6.7.1　分布式环境下运维的特点与挑战	187
6.7.2　分布式运维支撑体系	187
第7章　组织架构建设	193
7.1　文化	193
7.1.1　组织意识	193
7.1.2　风险意识	194
7.1.3　规范意识	195
7.1.4　工具意识	196
7.1.5　运营意识	197
7.2　组织结构	198
7.3　制度建设	203
7.3.1　关于制度制定方面	203
7.3.2　关于工程作业以及制度执行方面	205
7.4　人才	205
7.4.1　专业化	206
7.4.2　多元化	206
7.4.3　积累和传承	207
7.4.4　外部合作	208
7.5　小结	208
第8章　银行分布式架构改造要点与实施阶段划分	209
8.1　金融行业分布式架构改造需求点	209
8.1.1　吞吐量与性能需求	209
8.1.2　系统可用性需求	210
8.1.3　数据一致性需求	210
8.1.4　容灾与备份需求	210
8.1.5　系统安全性需求	211
8.1.6　运维自动化需求	211
8.2　分布式架构分层解决方案及实施阶段划分	212
8.3　分布式金融架构愿景	215
第9章　大型商业银行分布式系统建设实例	219
9.1　大型商业银行分布式核心账务系统	219
9.1.1　中国民生银行分布式核心系统建设背景与历程	219
9.1.2　构建过程	221
9.1.3　项目成果	228
9.1.4　未来展望	230
9.2　大型商业银行分布式支付结算系统	230
9.2.1　分布式支付结算系统建设项目背景	230
9.2.2　分布式支付结算系统建设的意义	231
9.2.3　支付结算系统面对的交易环境	231
9.2.4　分布式支付结算系统建设方案	232
9.2.5　结语	246
9.3　大型商业银行分布式线上贷款系统	247
9.3.1　背景与概述	247
9.3.2　贷款领域模型设计实现	247
9.3.3　分布式贷款系统的架构设计	252
9.3.4　批处理方案设计	257
9.3.5　分布式改造的数据迁移方案	261
9.3.6　日常运维工具介绍	264
9.3.7　结语	265
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>商业银行分布式架构实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式中间件技术实战（Java版）
前言
第1篇 开发工具准备
第1章 走进分布式中间件 2
1.1 分布式系统概述 2
1.1.1 白话分布式系统 3
1.1.2 分布式系统发展历程 3
1.1.3 分布式系统特性 6
1.1.4 分布式系统常见问题 7
1.2 分布式中间件概述 7
1.2.1 白话分布式中间件 7
1.2.2 常见中间件介绍 8
1.3 本书核心知识要点 9
1.4 本书实战要求与建议 10
第2章 搭建微服务项目 11
2.1 Spring Boot概述 11
2.1.1 什么是Spring Boot 11
2.1.2 Spring Boot的优势 12
2.1.3 Spring Boot的几大特性 13
2.2 搭建规范与搭建流程 13
2.2.1 Spring Boot项目搭建规范 14
2.2.2 Spring Boot项目搭建流程 14
2.2.3 写个Hello World吧 26
2.3 总结 28
第2篇 开发实战
第3章 缓存中间件Redis 30
3.1 Redis概述与典型应用场景介绍 30
3.2 Redis的使用 32
3.2.1 快速安装Redis 32
3.2.2 在Windows环境下使用Redis 34
3.2.3 Spring Boot项目整合Redis 37
3.2.4 Redis自定义注入Bean组件配置 38
3.2.5 RedisTemplate实战 39
3.2.6 StringRedisTemplate实战 43
3.3 Redis常见数据结构实战 45
3.3.1 字符串 45
3.3.2 列表 47
3.3.3 集合 48
3.3.4 有序集合 50
3.3.5 哈希Hash存储 52
3.3.6 Key失效与判断是否存在 54
3.4 Redis实战场景之缓存穿透 56
3.4.1 什么是缓存穿透 57
3.4.2 缓存穿透的解决方案 58
3.4.3 实战过程 58
3.4.4 其他典型问题介绍 65
3.5 总结 66
第4章 Redis典型应用场景实战之抢红包系统 67
4.1 整体业务流程介绍 67
4.1.1 抢红包系统业务流程 68
4.1.2 业务流程分析 68
4.1.3 业务模块划分 70
4.2 数据库表设计与环境搭建 71
4.2.1 数据库表设计 71
4.2.2 开发环境搭建 73
4.2.3 开发流程介绍 83
4.3 “红包金额”随机生成算法实战 85
4.3.1 随机数算法 86
4.3.2 红包随机金额生成算法要求 86
4.3.3 二倍均值法简介 87
4.3.4 红包随机金额生成算法实战 88
4.3.5 红包随机金额生成算法自测 90
4.4 “发红包”模块实战 91
4.4.1 业务模块分析 92
4.4.2 整体流程实战 93
4.4.3 业务模块自测 99
4.5 “抢红包”模块实战 101
4.5.1 业务模块分析 101
4.5.2 整体流程 102
4.5.3 业务模块自测 105
4.5.4 总结 109
4.6 Jmeter压力测试高并发抢红包 110
4.7 问题分析与优化方案 116
4.7.1 问题分析 117
4.7.2 优化方案介绍 118
4.7.3 优化方案之Redis分布式锁实战 118
4.7.4 不足之处 122
4.8 总结 122
第5章 消息中间件RabbitMQ 124
5.1 RabbitMQ简介 124
5.1.1 认识RabbitMQ 125
5.1.2 典型应用场景介绍 126
5.1.3 RabbitMQ后端控制台介绍 132
5.1.4 基于Spring的事件驱动模型实战 133
5.2 Spring Boot项目整合RabbitMQ 137
5.2.1 RabbitMQ相关词汇介绍 138
5.2.2 Spring Boot项目整合RabbitMQ 139
5.2.3 自定义注入配置Bean相关组件 140
5.2.4 RabbitMQ发送、接收消息实战 142
5.2.5 其他发送接收消息方式实战 147
5.3 RabbitMQ多种消息模型实战 152
5.3.1 基于FanoutExchange的消息模型实战 152
5.3.2 基于DirectExchange的消息模型实战 160
5.3.3 基于TopicExchange的消息模型实战 165
5.4 RabbitMQ确认消费机制 171
5.4.1 消息高可用和确认消费 172
5.4.2 常见的确认消费模式介绍 174
5.4.3 基于自动确认消费模式实战 176
5.4.4 基于手动确认消费模式实战 182
5.5 典型应用场景实战之用户登录成功写日志 188
5.5.1 整体业务流程介绍与分析 188
5.5.2 数据库表设计 189
5.5.3 开发环境搭建 197
5.5.4 基于TopicExchange构建日志消息模型 200
5.5.5 异步发送接收登录日志消息实战 201
5.5.6 整体业务模块自测实战 205
5.6 总结 208
第6章 死信队列/延迟队列实战 209
6.1 死信队列概述 209
6.1.1 死信队列简介与作用 209
6.1.2 典型应用场景介绍 212
6.2 RabbitMQ死信队列实战 213
6.2.1 死信队列专有词汇介绍 214
6.2.2 死信队列消息模型实战 215
6.2.3 死信队列延迟发送消息实战 221
6.3 典型应用场景实战之商城平台订单支付超时 226
6.3.1 整体业务场景介绍 227
6.3.2 整体业务流程分析 228
6.3.3 数据库设计 229
6.3.4 构建RabbitMQ死信队列消息模型 236
6.3.5 Controller层开发用户下单及订单失效功能 240
6.3.6 “用户下单支付超时”延迟发送接收实战 246
6.3.7 “用户下单支付超时”整体功能自测 250
6.4 总结 254
第7章 分布式锁实战 256
7.1 分布式锁概述 256
7.1.1 锁机制 257
7.1.2 分布式锁登场 263
7.1.3 典型应用场景介绍 265
7.1.4 小结 268
7.2 基于数据库实现分布式锁 268
7.2.1 乐观锁简介 268
7.2.2 乐观锁实战 269
7.2.3 Jmeter高并发测试乐观锁 280
7.2.4 悲观锁简介 286
7.2.5 悲观锁实战 288
7.2.6 Jmeter高并发测试悲观锁 290
7.2.7 小结 291
7.3 基于Redis实现分布式锁 292
7.3.1 Redis温故而知新 292
7.3.2 分布式锁的实现流程与原理分析 294
7.3.3 基于Redis实战实现分布式锁 295
7.3.4 Jmeter高并发测试 303
7.3.5 小结 307
7.4 基于ZooKeeper实现分布式锁 308
7.4.1 ZooKeeper简介与作用 308
7.4.2 分布式锁的实现流程与原理分析 310
7.4.3 Spring Boot整合ZooKeeper 312
7.4.4 基于ZooKeeper实现分布式锁 315
7.4.5 Jmeter高并发测试 317
7.4.6 小结 319
7.5 典型应用场景之书籍抢购模块设计与实战 319
7.5.1 整体业务流程介绍与分析 319
7.5.2 数据库表设计与用例设计 321
7.5.3 书籍抢购核心业务逻辑开发实战 324
7.5.4 Jmeter重现“库存超卖”的问题 328
7.5.5 采用分布式锁解决问题 330
7.5.6 小结 334
7.6 总结 334
第8章 综合中间件Redisson 336
8.1 Redisson概述 336
8.1.1 Redisson简介与作用 337
8.1.2 Redisson的功能特性 339
8.1.3 典型应用场景之布隆过滤器与主题 340
8.1.4 典型应用场景之延迟队列与分布式锁 345
8.1.5 Spring Boot整合Redisson 348
8.2 Redisson常见功能组件实战 352
8.2.1 布隆过滤器 352
8.2.2 发布-订阅式主题 355
8.2.3 数据结构之映射Map 361
8.2.4 数据结构之集合Set 366
8.2.5 队列Queue实战 370
8.2.6 延迟队列Delayed Queue实战1 374
8.2.7 延迟队列Delayed Queue实战2 381
8.3 分布式锁实战 385
8.3.1 重温分布式锁 385
8.3.2 分布式锁之一次性锁实战 387
8.3.3 分布式锁之可重入锁实战 392
8.4 总结 398
第9章 Redisson典型应用场景实战之高性能点赞 399
9.1 整体业务流程介绍与分析 399
9.1.1 业务背景介绍 400
9.1.2 业务流程介绍与分析 401
9.1.3 业务模块划分与数据库设计 404
9.2 “点赞与取消点赞”操作模块实战 409
9.2.1 “点赞与取消点赞”业务流程分析 409
9.2.2 Controller层接收请求信息 412
9.2.3 Service层插入、更新并缓存记录信息 415
9.2.4 业务模块自测 421
9.3 “排行榜”业务模块实战 424
9.3.1 “排行榜”业务流程分析 425
9.3.2 接收前端请求并触发缓存排行榜 426
9.3.3 业务模块自测 428
9.4 总结 432
第3篇 总结
第10章 总结与回顾 434
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式中间件技术实战（Java版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>项目管理2.0：利用工具、分布式协作和度量指标助力项目成功（修订版）
第1章项目管理2．0概述	1
1．0 简介：变化的时代	1
1．1 PM 1．0的特征	1
1．2 PM1．0的其他关键问题	2
1．3 项目管理2．0的定义	4
1．4 对PM2．0的批评	7
1．5 项目管理2．0：技术祝福
或诅咒	7
1．6 监管PM2．0	12
1．7 在PM2．0中与干系人共事	14
1．8 发现信息	16
1．9 完成百分比困境	17
1．10 信息过载	18
1．11 客户满意“头痛症”	19
1．12 确定项目健康	20
1．13 显示数据的仪表板规则	22
1．14 减少纸面工作成本	22
1．15 减少行政干预	24
1．16 项目管理技能	24
1．17 应急规划	25
讨论题	26
第2章项目管理未来一瞥	27
2．0 变化的时代	27
2．1 经济衰退的影响	27
2．2 项目管理的高管视角	28
2．3 参与式项目管理	30
2．4 更加复杂项目的增长	32
2．5 对更多度量指标的需要	33
2．6 项目管理的新发展	34
2．7 项目管理工具箱	35
2．8 持续改进的需要	36
2．9 结论	36
讨论题	37
第３章理解成功与失败	38
3．0 简介	38
3．1 项目管理――早期：1945―1960年	39
3．2 项目管理开始成长：1970―1985年	40
3．3 竞争性制约因素的增长	41
3．4 反演规则	43
3．5 测量技术的成长	44
3．6 权衡	46
3．7 聚拢成功组件	47
3．8 成功的新定义	48
3．9 理解项目失败	49
3．10 项目失败的原因	53
讨论题	55
第４章价值驱动型项目管理	56
4．0 简介	56
4．1 理解今天的价值观点	57
4．2 价值模型	60
4．3 PM2．0的价值与领导力
变化	61
4．4 基于价值的权衡	67
4．5 价值度量的需要	68
4．6 创建价值度量指标	69
4．7 在仪表板上显示价值
度量指标	76
4．8 选择价值属性	76
4．9 价值度量指标的额外
复杂性	77
讨论题	81
第5章日益重要的PM2．0
度量指标	82
5．0 简介	82
5．1 企业资源计划（ERP）	83
5．2 对更好的项目度量指标
的需要	83
5．3 度量指标管理缺乏支持
的原因	85
5．4 度量指标的特征	87
5．5 度量指标选择	88
5．6 关键绩效指标	89
5．7 仪表板和计分卡	97
5．8 商业智能	100
5．9 仪表板信息系统
的增长	100
5．10 选择信息图表设计师	101
5．11 项目健康检查度量
指标	102
5．12 维持项目方向	106
5．13 度量指标和虚拟团队	107
5．14 度量指标狂热症	108
5．15 度量指标培训会议	109
5．16 度量指标负责人	110
5．17 回答度量指标问题	111
讨论题	112
第6章项目管理方法论：
1．0 与2．0	113
6．0 简介	113
6．1 PM 2．0 对项目管理
卓越的定义	113
6．2 方法论的必要性	114
6．3 企业级方法论的需求	116
6．4 标准化方法论的收益	122
6．5 关键组件	123
6．6 从方法论到框架	125
6．7 生命周期阶段	126
6．8 PM2．0的以客户为
本灵活性的驱动力	127
6．9 理解目标偏移	128
6．10 客户专属度量指标
的需求	129
6．11 商业论证开发	129
6．12 验证假设	131
6．13 设计冻结	133
6．14 客户批准	134
6．15 敏捷项目管理
方法论	135
6．16 实施方法论	137
6．17 实施的错误	138
6．18 克服开发和
实施障碍	139
6．19 在方法论中使用
危机仪表板	139
6．20 终止项目	149
讨论题	151
第7章项目治理	152
7．0 简介	152
7．1 项目治理的需要	152
7．2 定义项目治理	153
7．3 项目治理与公司治理	154
7．4 角色、职责和决策权	155
7．5 治理框架	156
7．6 项目治理的三大支柱	157
7．7 信息的曲解	162
7．8 过滤信息	163
7．9 理解项目环境中
的政治	163
7．10 管理全球性干系人
关系	170
7．11项目治理的失败	172
7．12 挽救危难项目	173
讨论题	174
第8章项目经理在战略规划
和组合管理中的角色	175
8．0 简介	175
8．1 战略规划为何失败	176
8．2 项目管理：高管的视角	177
8．3 战略规划：项目管理
的视角	177
8．4 通用战略规划	178
8．5 项目管理的好处	182
8．6 走出误区	183
8．7 项目管理协助战略规划
的方法	185
8．8 变革型项目管理
领导力	189
8．9 项目经理在组合管理中
的角色	193
8．10 价值管理和收益实现	194
8．11 收益实现度量指标	203
8．12 组合管理治理	205
讨论题	207
第9章研发项目管理	208
9．0 简介	208
9．1 战略规划中研发的角色	209
9．2 产品组合分析	211
9．3 研发项目经理参与
市场营销	214
9．4 产品生命周期	217
9．5 依据市场份额的
研发项目规划	217
9．6 研发项目分类	218
9．7 研究与开发	219
9．8 研发比率	220
9．9 进攻型研发与
防守型研发	221
9．10 为研发规划职能建模	222
9．11 优先级设置	226
9．12 合同研发	228
9．13 保密协议	229
9．14 政府的影响	229
9．15 创意来源	230
9．16 项目的经济评价	233
9．17 研发项目的重新调整	236
9．18 项目终止	238
9．19 跟踪研发绩效	239
讨论题	239
第10章问题解决与决策	240
10．0 简介	240
10．1 理解概念	241
10．2 项目环境：对问题
解决和决策的影响	245
10．3 概念性问题解决和
决策过程	247
10．4 识别并理解问题	249
10．5 收集问题相关数据	253
10．6 分析数据	261
10．7 制订备选方案	262
10．8 问题解决工具与技术	265
10．9 创造力与创新	273
10．10 决策――选择最佳
解决方案	276
10．11 决策――工具与方法	287
10．12 评估决策并采取
纠正措施	294
讨论题	297
第11章项目管理的需求	298
11．0 项目管理成熟度模型
的背景	298
11．1 使用成熟度模型的
一些益处	299
11．2 确定所需的成熟度	299
11．3 准备工作	300
11．4 事情会出错	300
11．5 选择合适的
成熟度模型	300
11．6 实现成熟度的
估算时间	301
11．7 项目管理成熟度的
战略规划	301
11．8 项目管理成熟度模型	302
11．9 PM 2．0对PMMM的
输入	305
讨论题	308
第12章让PMO成为
推行PM 2．0的先锋	309
12．0 简介	309
12．1 传统型项目办公室	310
12．2 传统PMO	310
12．3 实施风险	311
12．4 专项PMO	313
12．5 战略PMO	313
12．6 PMO间的互联	314
12．7 对项目治理的信任	314
12．8 PMO可能失败的方式	316
讨论题	324
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>项目管理2.0：利用工具、分布式协作和度量指标助力项目成功（修订版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式供能系统设计手册
第一 章能 源
第一 节能 源 及 其 重 要 性
一 、 能 源 定 义
二 、 能 源 的 重 要 性
三 、 能 源 费 与 社 会 发 展 环 境
四 、 能 源 革 与 科 技 创 新
第二 节能 源 源
一 、 能 源 源 的 分 类
二 、 界 各 国 传 统 能 源 源
三 、 中 国 传 统 能 源 源
四 、 中 国 能 源 费 及 其 点
第三 节能 源 发 展 的 基 本 情 况
一 、 能 源 发 展 的 主 要 技 * 指 标
二 、 清 洁 能 源 可 再 生 能 源
三 、 中 国 建 筑 能 耗
第四 节持 续 发 展 实 现 低 碳 济 型 社 会
一 、 低 碳 济
二 、 社 会 济 发 展 “ ３Ｅ 要 素 ”
三 、 中 国 生 态 能 源 新 略
第二 章分 布 式 供 能 系 统
第一 节分 布 式 供 能 系 统 概 述
一 、 供 能 系 统 及 其 分 类
二 、 分 布 式 供 能 系 统
三 、 分 布 式 能 源 系 统 的 优 势
四 、 分 布 式 供 能 系 统 主 要 市 场
第二 节 界 各 国 分 布 式 供 能 系 统 发 展
一 、 美 国 分 布 式 供 能 系 统 的 发 展
二 、 日 本 分 布 式 供 能 系 统 的 发 展
三 、 欧 洲 分 布 式 供 能 系 统 的 发 展
第三 节中 国 分 布 式 供 能 系 统 的 发 展
一 、 中 国 分 布 式 供 能 系 统 发 展 概 况
二 、 中 国 分 布 式 供 能 系 统 发 展 形 势
三 、 中 国 分 布 式 供 能 系 统 主 要 项 目
第三 章清 洁 能 源 分 布 式 供 能 系 统
第 一 节清 洁 能 源 分 布 式 供 能 系 统 组 成
一 、 内 燃 机 分 布 式 供 能 系 统
二 、 燃 气 机 分 布 式 供 能 系 统
三 、 微 燃 机 分 布 式 供 能 系 统
四 、 燃 气 热 泵 分 布 式 供 能 系 统
五 、 燃 料 电 池 分 布 式 供 能 系 统
第二 节内 燃 机 分 布 式 供 能 系 统
一 、 内 燃 机 分 布 式 供 能 系 统 简 介
二 、 内 燃 机 基 本 结 构 及 工 作 原
三 、 内 燃 机 分 布 式 供 能 系 统
四 、 内 燃 机 分 布 式 供 能 系 统 案 例
五 、 内 燃 机 分 布 式 供 能 系 统 主 要 设 备
第 三 节燃 气 机 分 布 式 供 能 系 统
一 、 燃 气 机 分 布 式 供 能 系 统 简 介
二 、 燃 气 机 的 基 本 结 构 及 工 作 原
三 、 燃 气 机 发 电 主 要 系 统
四 、 燃 气 机 发 电 系 统 的 全 性
五 、 燃 气 机 分 布 式 供 能 系 统 案 例
六 、 燃 气 机 分 布 式 供 能 系 统 设 备
第四 节微 型 燃 气 机 分 布 式 供 能 系 统
一 、 微 型 燃 气 机
二 、 微 燃 机 的 工 作 原 及 结 构
三 、 微 型 燃 气 机 点
四 、 我 国 微 型 燃 气 机 发 展
五 、 微 型 燃 气 机 分 布 式 供 能 系 统 设 备
第五 节燃 气 热 泵 分 布 式 供 能 系 统
一 、 燃 气 热 泵 分 布 式 供 能 系 统 简 介
二 、 燃 气 热 泵 基 本 结 构 及 工 作 原
三 、 燃 气 热 泵 机 组 主 要 性 能
四 、 燃 气 热 泵 空 调 系 统 主 要 点
五 、 燃 气 热 泵 机 组 设 计 及 择
六 、 燃 气 热 泵 供 能 系 统
第六 节燃 料 电 池 分 布 式 供 能 系 统
一 、 燃 料 电 池 发 电 基 本 原
二 、 燃 料 电 池 种 类
三 、 燃 料 电 池 基 本 点
四 、 燃 料 电 池 分 布 式 供 能 的 可 行 性
五 、 燃 料 电 池 适 合 于 分 布 式 供 能 系 统
六 、 界 各 国 燃 料 电 池 分 布 式 供 能 系 统
七 、 燃 料 电 池 主 要 造 及 其 品
八 、 燃 料 电 池 应 用 范 围
第四 章可 再 生 能 源 分 布 式 供 能 系 统
第 一 节可 再 生 能 源 分 布 式 供 能 系 统
概 述
一 、 可 再 生 能 源
二 、 开 发 利 用 可 再 生 能 源 的 意 义
三 、 可 再 生 能 源 发 电 的 发 展
第二 节太 阳 能 分 布 式 供 能 系 统
一 、 太 阳 辐射 能
二 、 太 阳 能 源
三 、 我 国 太 阳 能 发 电 系 统 的 发 展
四 、 太 阳 能 光 伏 发 电 系 统
五 、 太 阳 能 光 热 发 电 系 统
六 、 太 阳 能 光 热 供 热 系 统
第 三 节 能 分 布 式 供 能 系 统
一 、 能 及 其 利 用
二 、 能 源
三 、 我 国 电 的 发 展
四 、 力 发 电 场
五 、 海 力 发 电
六 、 电 分 布 式 供 能 系 统
七 、 我 国 力 发 电 面 临 的 主 要 课 题
八 、 力 发 电 新 技术 的 发 展
第 四 节生 物 质 能 分 布 式 供 能 系 统
一 、 生 物 质 能
二 、 生 物 质 源
三 、 生 物 质 能 的 点
四 、 生 物 质 转 技术
五 、 生 物 质 能 发 电
第五 节地 热 能 分 布 式 供 能 系 统
一 、 地 热 能
二 、 地 热 供 能 系 统
三 、 地 热 能 利 用
四 、 地 热 发 电 系 统
五 、 地 热 能 源
六 、 我 国 地 热 能 发 电 的 发 展
第 六 节海 洋 能 分 布 式 供 能 系 统
一 、 海 洋 能
二 、 我 国 海 洋 能 利 用
三 、 海 洋 能 点 及 种 类
四 、 潮 汐 能 发 电 系 统
五 、 波 浪 能 发 电 系 统
六 、 海 流 能 发 电 系 统
七 、 海 洋 温 差 发 电 系 统
第 七 节 热 泵 分 布 式 供 能 系 统
一 、 热 泵 原 及 其 点
二 、 电 动 压 缩 式 热 泵 系 统
三 、 热 力 溴 锂 收 式 热 泵 系 统
四 、 热 泵 供 能 系 统 的 济 性
五 、 热 泵 主 要 设 备
第 八 节多 种 能 源 互 补 性 综 合 分 布 式 供 能 系 统
一 、 能 源 生 与 费 不 平 衡 性
二 、 多 种 能 源 互 补 性 分 布 式 供 能 系 统
三 、 绿 能 源 分 布 式 供 能 系 统
四 、 氢 能 村 庄
第五 章分 布 式 供 能 系 统 设 计 及 设 备 择
第 一 节分 布 式 供 能 系 统 设 计
一 、 分 布 式 供 能 系 统 设 计 条 件
二 、 分 布 式 供 能 系 统 设 计 流 程
三 、 分 布 式 供 能 系 统 设 计 原 则
四 、 分 布 式 供 能 系 统 设 备 的 择 原 则
五 、 分 布 式 供 能 系 统 运 行 原 则 与 式
第 二 节分 布 式 供 能 系 统 能 源 站
一 、 分 布 式 供 能 站 站 规 划 及 布 置
二 、 分 布 式 供 能 站 工 艺 布 置
三 、 分 布 式 供 能 站 建 筑 与 结 构
四 、 分 布 式 供 能 站 防 及 辅 助 设 施
五 、 分 布 式 供 能 站 系 统 流 程 图
第三 节燃 气 系 统 及 设 备
一 、 燃 气 供 应 系 统
二 、 燃 气 输 送 系 统
三 、 燃 气 调 压 及 增 压 系 统
四 、 燃 气 辅 助 设 施
五 、 然 气 系 统 流 程 图
第四 节原 动 机 设 备 及 系 统
一 、 一 般 设 计 原 则
二 、 原 动 机 设 备
三 、 原 动 机 系 统
第五 节余 热 利 用 系 统
一 、 设 计 原 则 及 其 利 用 式
二 、 余 热 锅 炉 及 其 系 统
三 、 汽 机 及 其 辅 助 系 统
四 、 溴 锂 收 式 冷 （温 ） * 机 组 及 系 统
五 、 烟 气 系 统
六 、 主 蒸 汽 系 统 及 烟 气 系 统 图
第六 节余 热 利 用 设 备
一 、 余 热 利 用 设 备 用 原 则
二 、 余 热 利 用 主 要 设 备 料
三 、 余 热 利 用 系 统 流 程 图
第 七 节热 能 备 、 输 送 系 统 及 设 备
一 、 热 能 备 系 统 介 质 及 参 数 择
二 、 供 热 调 节
三 、 循 环 * 泵 择
四 、 补 * 定 压
五 、 换 热 设 备 择
第 八 节供 热 （冷 ） 系 统 计 算
一 、 供 热 系 统 热 量 及 流 量 计 算
二 、 供 热 系 统 定 压 计 算
三 、 * 力 计 算
四 、 供 热 系 统 换 热 计 算
五 、 供 热 系 统 * 泵 率 计 算
第九 节供 * 系 统 及 设 施
一 、 一 般 设 计 原 则
二 、 * 源 * 务 管
三 、 供 * 系 统
四 、 冷 却 设 施
五 、 生 活 给 * 废 *
六 、 * 处 系 统
第六 章分 布 式 供 能 系 统 负 荷 计 算
第一 节概 述
一 、 分 布 式 供 能 系 统 负 荷 点 及 其 分 类
二 、 供 暖 空 调 设 计 用 室 内 、 室 外 计 算 参 数
三 、 分 布 式 供 能 系 统 热 （冷 ）、 电 负 荷 的 确 定 原 则
四 、 分 布 式 供 能 系 统 负 荷 计 算 （估 算 ） 法
第二 节供 暖 热 负 荷 计 算
一 、 供 暖 热 负 荷 计 算
二 、 供 暖 全 年 耗 热 量 计 算
三 、 热 负 荷 图
四 、 全 年 供 暖 标 准 煤 耗 量 计 算
第三 节通 热 负 荷 计 算
一 、 通 热 负 荷 计 算
二 、 供 暖 期 通 耗 热 量
第四 节生 活 热 * 热 负 荷 计 算
一 、 生 活 热 * 热 负 荷 计 算
二 、 生 活 热 * 全 年 耗 热 量 计 算
第五 节空 调 热 、 冷 负 荷 计 算
一 、 空 调 冬 （夏 ） 季 热 （冷 ） 负 荷 计 算
二 、 空 调 平 均 负 荷 系 数
三 、 空 调 供 暖 （冷 ） 耗 热 （冷 ） 量 计 算
第六 节工 业 热 负 荷 计 算
一 、 工 业 热 负 荷
二 、 工 业 热 负 荷 计 算
三 、 生 工 艺 全 年 耗 热 量 及 用 汽 量 计 算
第 七 节电 力 负 荷 计 算
一 、 设 备 率 的 确 定
二 、 电 力 负 荷 计 算
三 、 平 均 电 力 负 荷 系 数
四 、 年 用 电 量 计 算
第七 章分 布 式 供 能 系 统 蓄 能 技 *
第 一 节蓄 能 技 * 综 述
一 、 蓄 能 技 * 的 重 要 性
二 、 蓄 能 技 * 的 分 类
三 、 分 布 式 供 能 系 统 中 蓄 能 技 * 的 应 用
第 二 节蓄 热 系 统 分 类
一 、 蓄 热 系 统 点
二 、 热 传 递 式
三 、 蓄 热 系 统 分 类
第三 节显 热 蓄 能 系 统
一 、 * 蓄 冷 （热 ） 系 统
二 、 蒸 汽 蓄 热
三 、 熔 融 盐 蓄 能 系 统
第四 节潜 热 蓄 冷 （热 ） 系 统
一 、 蓄 冷 系 统
二 、 四 丁 基 溴 铵 * 合 物 浆 体 （ ＴＢ Ａ Ｂ ） 蓄 冷 系 统
三 、 相 蓄 能 罐 蓄 能 系 统
第五 节蓄 能 系 统 设 计 计 算
一 、 电 锅 炉 蓄 热 系 统 的 计 算
二 、 蒸 汽 蓄 能 系 统 计 算
三 、 蓄 冷 系 统 的 计 算
四 、 * 蓄 冷 槽 容 积 计 算
第六 节各 种 蓄 能 系 统 较
一 、 常 用 的 蓄 冷 介 质 的 较
二 、 蓄 能 系 统 式 的 较
三 、 蓄 能 系 统 的 较
四 、 * 蓄 冷 系 统 与 蓄 冷 系 统 的 较
第七 节 能 源 形 式 的 蓄 能 式
一 、 利 用 可 再 生 能 源 的 蓄 能 系 统
二 、 太 阳 能 蓄 能 系 统 的 应 用
三 、 太 阳 能 氢 的 式
四 、 氢 气 的 储 存
第八 章分 布 式 供 能 系 统 技 * 济 指 标 及 能 耗 计 算
第 一 节分 布 式 供 能 系 统 技 * 济 指 标 计 算
一 、 供 热 计 算
二 、 供 热 发 电 计 算
三 、 热 电 计 算
四 、 发 电 机 组 发 电 气 （煤 ） 耗 率 计 算
五 、 发 电 机 组 供 热 气 （煤 ） 耗 率 计 算
六 、 燃 气 （汽 ） 发 电 机 组 热 耗 率 计 算
七 、 燃 气 （汽 ） 发 电 机 组 热 效 率 计 算
八 、 锅 炉 标 准 煤 （气 ） 耗 率 计 算
九 、 分 布 式 供 能 系 统 能 源 利 用 效 率
第二 节发 电 量 及 燃 料 耗 量 计 算
一 、 设 备 运 行 小 时 计 算
二 、 分 布 式 供 能 系 统 发 电 量 计 算
三 、 分 布 式 供 能 系 统 燃 气 耗 量 计 算
四 、 分 布 式 供 能 系 统 能 耗 指 标 汇
第 三 节污 染 物 量 计 算
一 、 污 染 物 量 计 算
二 、 氮 氧 物 量 估 算
三 、 污 染 物 系 数 汇
四 、 国 家 标 准五 、 燃 机 污 染 物
第四 节能 源 价 格 估 算
一 、 能 源 价 格 估 算 的 要 性
二 、 电 价 估 算
三 、 热 （冷 ） 价 估 算
四 、 电 能 供 热 成 本 估 算
五 、 蒸 汽 供 热 成 本 估 算
六 、 按 平 米 与 热 量 计 费 换 算
第五 节可 再 生 能 源 发 电 成 本
一 、 电 成 本
二 、 太 阳 能 发 电 成 本
三 、 生 物 质 发 电 成 本
四 、 可 再 生 能 源 发 电 成 本 趋 势
第 六 节能 量 平 衡 计 算
一 、 分 布 式 供 能 系 统 的 能 量 平 衡
二 、 冬 季 供 能 系 统 供 暖 热 平 衡
三 、 夏 季 供 能 系 统 空 调 冷 平 衡
四 、 全 年 供 能 系 统 热 * 供 应 热 平 衡
五 、 全 年 供 能 系 统 热 （冷 ） 平 衡
六 、 电 力 平 衡
第九 章分 布 式 供 能 电 力 系 统 设 计
第一 节接 入 系 统
一 、 分 布 式 供 能 接 入 系 统
二 、 分 布 式 供 能 系 统 并 网 案 例
第二 节电 气 主 接 线
一 、 主 接 线 式
二 、 如 何 确 定 供 能 站 电 气 主 接 线
第三 节分 布 式 供 能 站 用 电 系 统 设 计
一 、 分 布 式 供 能 站 电 网 络 的 构 成 点
二 、 分 布 式 供 能 主 体 供 电 用 电 网 络 设 计
三 、 分 布 式 供 能 站 用 电 网 络 设 计
四 、 分 布 式 供 能 站 用 电 系 统 的 智 能 设 计
第四 节主 要 电 力 设 备 型 设 计
一 、 高 压 电 力 设 备
二 、 控 、 信 号 测 量 系 统
三 、 直 流 电 源
四 、 Ｕ ＰＳ 或 ＥＰＳ 系 统
五 、 照 明 系 统
六 、 其 他 辅 助 系 统
第五 节二 次 部 分 设 计
一 、 分 布 式 供 能 电 源 接 入 对 于 继 电 保 护 的 影 响
二 、 系 统 继 电 保 护 及 全 自 动 装 置
三 、 电 力 元 件 保 护
四 、 全 自 动 装 置
五 、 通 信 系 统
六 、 微 电 网 的 继 电 保 护 问 题
七 、 分 布 式 供 能 系 统 的 继 电 保 护 置 案 例
第 六 节计 量
一 、 技术原 则
二 、 置 及 要 求
第 七 节 体 及 电 缆 的 择 与 敷 设
一 、 分 布 式 供 能 系 统 体 及 电 缆 的 择
二 、 分 布 式 供 能 系 统 体 及 电 缆 的 敷 设
第 八 节过 电 压 保 护 与 接 地
一 、 过 电 压 保 护
二 、 接 地 保 护
三 、 常 用 接 地 分 块
第十 章分 布 式 供 能 系 统 自 动 控 系 统
第 一 节自 动 控 系 统 基 础
一 、 自 动 控 系 统 的 概 念
二 、 开 环 控 系 统
三 、 闭 环 控 系 统
四 、 可 编 程 逻 辑 控 ＰＬＣ
五 、 分 散 控 系 统
第二 节分 布 式 供 能 系 统 控 策 略
一 、 燃 料 电 池 分 布 式 供 能 系 统 控 策 略
二 、 内 燃 机 分 布 式 供 能 系 统 控 策 略
三 、 燃 气 机 分 布 式 供 能 系 统 控 策 略
四 、 微 型 燃 气 机 分 布 式 供 能 系 统 控 策 略
五 、 燃 气 热 泵 分 布 式 供 能 系 统 控 策 略
第三 节分 布 式 供 能 系 统 控 系 统 构 成 及 工 程 设 计
一 、 现 场 层 构 成 及 能
二 、 实 时 控 层 构 成 及 能
三 、 监 控 层 构 成 及 能
四 、 厂 管 层 构 成 及 能
五 、 分 布 式 供 能 系 统 控 系 统 工 程 设 计
第四 节分 布 式 供 能 系 统 控 系 统 案 例
一 、 某 内 燃 机 分 布 式 供 能 系 统 控 系 统 案 例
二 、 某 燃 气 机 分 布 式 供 能 系 统 控 系 统 案 例
第 十 一 章 分 布 式 供 能 系 统 技 * 济
第一 节分 布 式 供 能 工 程 技 * 济 工 作 概 述
一 、 技 * 济 在 能 源 工 程 项 目 中 的 作 用
二 、 国 家 对 发 展 分 布 式 能 源 的 相 政 策
三 、 分 布 式 供 能 系 统 项 目 的 点
四 、 分 布 式 供 能 工 程 项 目 技 * 济 的 目 的 意 义
五 、 分 布 式 供 能 工 程 技 * 济 的 点
第二 节分 布 式 供 能 系 统 项 目 技 * 济 工 作 任 务
一 、 分 布 式 供 能 项 目 申 报 步 骤
二 、 分 布 式 供 能 项 目 技 * 济 工 作 的 范 围
三 、 分 布 式 供 能 系 统 投 编 的 主 要 内 容
四 、 分 布 式 能 源 的 务 分 析 及 济 评 价
第三 节技 * 济 在 分 布 式 供 能 项 目 应 用 案 例 及 效 益 分 析
一 、 燃 气 模 式 的 分 布 式 供 能 站
二 、 以 太 阳 能 发 电 为 动 力 的 分 布 式 供 能 站
三 、 以 能 发 电 为 动 力 的 分 布 式 供 能 站
附 录Ａ 全 国 主 要 城 市 用 建 筑 单 位 面 积 供 暖 年 供 热 量
附 录Ｂ 全 国 主 要 城 市 用 建 筑 单 位 面 积 供 热 年 标 准 煤 耗 量
附 录Ｃ 分 布 式 供 能 系 统 常 用 技 * 指 标
附 录Ｄ 热 （冷 ） 网 估 算 指 标附 录Ｅ 供 热 锅 炉 房 建 设 估 算 指 标
附 录Ｆ 热 量 换 算 单 位 表
附 录Ｇ 燃 料 当 量 换 算 表
附 录Ｈ 燃 料 燃 烧 时 污 染 物 系 数
附 录Ｉ全 国 主 要 城 市 太 阳 能 设 计 料
附 录Ｊ 全 国 主 要 城 市 气 象 料
附 录Ｋ 室 外 管 网 * 力 计 算 表
参 考 文 献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式供能系统设计手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Zabbix企业级分布式监控系统（第2版）
第1章  开篇——监控系统简介  1
1.1  监控系统的功能概述  1
1.2  监控系统的实现原理  2
1.2.1  模块组成  2
1.2.2  采集协议  2
1.2.3  采集模式  3
1.2.4  监控指标  3
1.2.5  代理架构  3
1.2.6  数据存储  4
1.2.7  告警功能  5
1.2.8  可扩展性  5
1.2.9  总结归纳  6
1.3  监控系统的开源产品  7
1.3.1  Cacti  7
1.3.2  Nagios  8
1.3.3  InfluxDB套件  9
1.3.4  Prometheus  10
1.3.5  OpenFalcon  11
1.3.6  Netdata  12
1.3.7  ELK家族  13
1.3.8  Zabbix  14
第2章  Zabbix简介  16
2.1  Zabbix的用户群体都有谁  16
2.2  使用Zabbix需要具备什么基础  17
2.3  Zabbix是一个什么样的产品  18
2.4  为何选择Zabbix作为监控系统  19
2.5  该选用Zabbix的哪个版本  20
2.6  Zabbix的架构是什么样的  21
2.7  Zabbix的功能特性都有哪些  22
第3章  安装与部署  25
3.1  安装环境概述  25
3.1.1  硬件环境需求  25
3.1.2  软件环境需求  28
3.1.3  网络环境需求  30
3.2  Zabbix-Server服务器端的安装  30
3.2.1  安装Zabbix-Server  33
3.2.2  安装MySQL  33
3.2.3  配置zabbix_server.conf  36
3.2.4  防火墙、SELinux和权限的设置  38
3.2.5  配置Zabbix-Web  40
3.2.6  相关故障的处理  46
3.2.7  zabbix_server程序的参数  49
3.3  Zabbix-Agent客户端的安装  51
3.3.1  安装Zabbix-Agent  51
3.3.2  防火墙的设置  51
3.3.3  配置zabbix_agentd.conf  52
3.4  SNMP监控配置  52
3.5  在Windows中安装Zabbix-Agent  53
3.5.1  安装与配置  53
3.5.2  注册服务  53
3.5.3  启动服务  54
3.6  在其他平台安装Zabbix-Agent  56
3.7  Zabbix-Get的使用  56
3.8  Zabbix相关术语（命令）  57
3.9  Zabbix-Server对数据的存储  58
3.9.1  监控数据的存储  58
3.9.2  MySQL表分区实例  62
3.10  高可用和安全  70
3.10.1  高可用  70
3.10.2  通信安全  70
3.10.3  禁用Zabbix的guest用户  70
3.11  Zabbix数据库备份  70
3.12  升级Zabbix  73
3.12.1  同版本升级的方法  73
3.12.2  跨版本升级的方法  74
3.12.3  数据库自动升级的原理  74
3.12.4  升级失败的处理案例  75
第4章  快速配置和使用  77
4.1  配置流程  77
4.2  添加主机组  78
4.2.1  如何划分主机组  78
4.2.2  如何添加主机组  78
4.2.3  层级主机分组  80
4.3  添加模板  81
4.4  添加主机  82
4.5  配置图形  86
4.6  配置大屏  92
4.7  配置幻灯片  94
4.8  配置地图  96
4.8.1  添加背景图  96
4.8.2  添加地图  96
4.9  使用IT服务  102
4.10  使用报表  105
4.11  资产管理  108
4.12  图形共享  109
4.13  全局搜索  110
4.14  最新数据  111
4.15  故障  112
4.16  数据的导入/导出  112
4.17  用户权限  113
4.17.1  用户组  113
4.17.2  用户组权限  114
4.17.3  用户  116
4.17.4  匿名用户  117
4.18  调试模式  117
4.19  与LDAP对接  118
4.20  维护模式  119
4.21  故障确认  121
4.22  批量更新  123
第5章  处理监控指标数据  124
5.1  添加新的监控项  124
5.1.1  监控项的含义  124
5.1.2  如何添加监控项  124
5.2  监控指标的自定义  130
5.2.1  key的格式  130
5.2.2  key名称的定义范围  130
5.2.3  key的参数数组应用实例  131
5.2.4  用户自定义参数  131
5.3  Zabbix内置的监控方式  133
5.3.1  Zabbix-Agent监控方式  134
5.3.2  Simple check监控方式  140
5.3.3  日志监控方式  144
5.3.4  计算型监控方式  152
5.3.5  聚合型监控方式  156
5.3.6  内部检测监控方式  163
5.3.7  SSH监控方式  163
5.3.8  Telnet监控方式  167
5.3.9  扩展检测监控方式  169
5.4  监控项指标数据的预处理  171
5.4.1  预处理概述  171
5.4.2  预处理的运行流程  172
5.4.3  预处理的数据类型  173
5.5  配置宏  177
5.5.1  全局宏  177
5.5.2  模板宏  178
5.5.3  主机宏  178
5.5.4  监控项宏  179
5.5.5  宏的函数运算  180
5.5.6  宏使用总结  181
5.5.7  宏的上下文  182
5.6  配置值映射  183
第6章  精通告警配置  185
6.1  告警流程  185
6.2  告警触发器的配置  186
6.2.1  Trigger的作用  186
6.2.2  Trigger的故障等级定义  187
6.2.3  Trigger的配置步骤  187
6.2.4  Trigger告警依赖  191
6.2.5  Trigger中的数值单位  192
6.2.6  Trigger表达式  192
6.3  告警处理的配置  200
6.3.1  如何发送告警  200
6.3.2  Action功能概述  200
6.3.3  Action配置步骤  201
6.3.4  告警处理措施  203
6.3.5  在告警消息中使用宏  207
6.3.6  告警恢复措施  208
6.3.7  告警更新措施  209
6.3.8  发送告警消息的步骤总结  210
6.3.9  查看告警消息的发送记录  211
6.3.10  执行远程命令  211
6.3.11  不支持的Item发送告警  215
6.4  邮件告警配置  215
6.4.1  创建Media类型  215
6.4.2  创建用户  216
6.4.3  创建Action  217
6.5  自定义脚本告警  218
6.5.1  自定义脚本告警的原理  218
6.5.2  电话告警  220
6.5.3  短信接口告警  221
6.5.4  微信告警  221
6.6  邮件告警脚本的配置  222
6.6.1  Zabbix-Server自定义告警脚本  222
6.6.2  Zabbix-Server重启服务  224
6.6.3  Zabbix-Web配置自定义脚本  225
6.6.4  告警接收邮件的配置  226
6.6.5  查看邮件发送状态  227
6.7  告警升级机制  227
6.7.1  告警升级的作用  227
6.7.2  告警升级的配置  228
6.8  触发器标签配置  230
6.8.1  标签设置  230
6.8.2  标签的复杂匹配  231
6.9  手动关闭告警  233
6.10  如何取消告警发送  235
6.11  如何删除故障信息  235
6.12  告警聚合  236
6.12.1  告警聚合的原理  236
6.12.2  基于触发器的告警聚合  236
6.12.3  基于全局的告警聚合  239
6.13  告警配置故障排查  242
6.13.1  告警消息未发送示例  242
6.13.2  邮件服务器连接失败示例  243
第7章  探究告警触发器  244
7.1  Trigger函数的意义  244
7.2  Trigger函数的分类  244
7.3  Trigger函数——比较与查找  245
7.3.1  求最近两值差的绝对值——abschange  245
7.3.2  求最大值与最小值的差——delta  248
7.3.3  判断最近两值是否相同——diff  251
7.3.4  求最近两值的变化量——change  254
7.3.5  数值的位与运算——band  256
7.3.6  数据失联——nodata  261
7.3.7  获取最新数据——last  264
7.3.8  求前一个值——prev  266
7.4  Trigger函数——计算  268
7.4.1  求最大值——max  268
7.4.2  求最小值——min  271
7.4.3  求平均值——avg  273
7.4.4  值求和——sum  276
7.4.5  统计个数——count  278
7.5  Trigger函数——时间  286
7.5.1  返回当前时间（年月日时分秒）——now  286
7.5.2  返回当前日期（年月日）——date  288
7.5.3  返回当前时间（时分秒）——time  289
7.5.4  本月第几天——dayofmonth  291
7.5.5  本周第几天——dayofweek  292
7.5.6  时间对比——fuzzytime  293
7.6  Trigger函数——日志  295
7.6.1  日志ID——logeventid  295
7.6.2  获取日志等级——logseverity  296
7.6.3  获取日志来源——logsource  297
7.7  Trigger函数——字符串匹配  299
7.7.1  正则表达式不区分大小写——iregexp  299
7.7.2  正则表达式区分大小写——regexp  301
7.7.3  字符串匹配——str  302
7.7.4  字符串长度——strlen  304
7.8  Trigger函数——趋势预测  305
7.8.1  百分线——percentile  305
7.8.2  趋势预测——forecast  307
7.8.3  剩余时间——timeleft  311
7.8.4  趋势预测计算型监控方式  314
7.9  参考资料  318
第8章  剖析监控方式  319
8.1  Zabbix支持的监控方式  319
8.2  Zabbix监控方式的逻辑  320
8.3  Zabbix-Agent的工作模式  321
8.3.1  工作模式概述  321
8.3.2  被动模式的配置  323
8.3.3  主动模式的配置  324
8.4  Zabbix-Trapper（zabbix_sender）监控方式  326
8.4.1  Zabbix-Trapper的配置步骤  326
8.4.2  Zabbix-Trapper的配置示例  326
8.4.3  使用zabbix_sender程序发送数据  328
8.4.4  使用zabbix_sender程序批量读取文件  329
8.5  SNMP监控方式  330
8.5.1  SNMP协议概述  330
8.5.2  SNMP协议的工作方式  331
8.5.3  SNMP协议的工作原理  331
8.5.4  SNMP MIB简介  334
8.5.5  SNMP相关术语  336
8.5.6  配置Zabbix-Server的SNMP监控  337
8.5.7  SNMP监控中的LLD原理  340
8.6  SNMPTraps监控方式  343
8.6.1  SNMPTraps的概念  343
8.6.2  SNMPTraps的工作原理  343
8.6.3  SNMPTraps的安装与配置  343
8.6.4  SNMPTraps的测试  346
8.7  IPMI监控方式  348
8.7.1  IPMI的概念  348
8.7.2  IPMI的特性  349
8.7.3  配置Zabbix-Server监控IPMI  349
8.7.4  Zabbix自带的IPMI模板  350
8.7.5  在Linux系统中使用OpenIPMI  350
8.7.6  创建IPMI模板  352
8.7.7  IPMI监控主机  353
8.8  JMX监控方式  354
8.8.1  JMX在Zabbix中的运行流程  354
8.8.2  JMX监控的安装和配置  355
8.8.3  安装Zabbix-Java-Gateway  355
8.8.4  配置Zabbix-Java-Gateway  356
8.8.5  查看Zabbix-Java-Gateway日志  357
8.8.6  监控Java应用程序的方法  357
8.8.7  开启Tomcat的JMX  358
8.8.8  获取JMX数据  359
8.8.9  JMX数据的LLD  363
8.8.10  JMX监控的核心技术实现  367
8.9  HTTP agent监控方式  369
8.9.1  HTTP agent监控概述  369
8.9.2  HTTP agent监控实例  369
8.9.3  HTTP agent监控配置  370
8.9.4  转换HTTP agent获取的数据结果  371
8.10  Web监控方式  372
8.10.1  Web监控的原理  372
8.10.2  Web监控指标  372
8.10.3  Web监控的配置步骤  373
8.10.4  Web监控用户认证支持  376
8.10.5  Web监控触发器的配置  379
8.10.6  Web监控排错  381
8.11  Dependent item监控方式  381
8.12  ODBC监控方式  381
8.12.1  安装ODBC软件包  381
8.12.2  查看ODBC配置  381
8.12.3  安装MySQL ODBC驱动  382
8.12.4  使用ODBC驱动连接MySQL  382
8.12.5  配置Item  383
8.12.6  ODBC错误处理  385
8.12.7  安装Oracle OBDC驱动  385
8.12.8  安装PostgresSQL OBDC驱动  387
8.12.9  OBDC的监控项自动发现  388
8.13  其他监控方式  391
8.14  命令执行的监控方式  391
8.14.1  system.run  391
8.14.2  远程命令  391
第9章  分布式监控与自动化  392
9.1  Zabbix-Proxy分布式监控  392
9.1.1  安装Zabbix-Proxy  395
9.1.2  导入Zabbix-Proxy的数据库  396
9.1.3  配置zabbix_proxy.conf  397
9.1.4  启动Zabbix-Proxy服务  397
9.1.5  查看Zabbix-Proxy日志  397
9.1.6  添加Proxy  398
9.1.7  添加Proxy的主机监控  398
9.2  监控的自动化功能  399
9.3  网络自动发现  400
9.4  主动方式的自动注册功能  403
9.4.1  功能概述  403
9.4.2  配置过程  404
9.5  监控项自动发现功能  406
9.5.1  功能概述  406
9.5.2  LLD的原理  406
9.5.3  LLD的数据格式  407
9.5.4  LLD应用案例  411
9.5.5  配置Zabbix客户端  411
9.5.6  编写自动发现脚本  412
9.5.7  自定义key配置文件  415
9.5.8  在Web页面添加LLD  416
9.5.9  主机信息数据LLD  425
9.5.10  定期删除不存在的监控元素  426
9.5.11  自动创建监控项分组  427
9.6  使用自动化工具SaltStack批量部署Zabbix  428
9.6.1  使用SaltStack配置管理Zabbix  428
9.6.2  安装salt-master  428
9.6.3  安装salt-minion  429
9.6.4  接受客户端密钥申请  429
9.6.5  状态同步文件  429
9.6.6  执行状态同步  431
第10章  监控功能案例  433
10.1  监控TCP连接状态  433
10.1.1  TCP连接状态监控原理  433
10.1.2  TCP连接状态监控脚本的实现  434
10.1.3  TCP监控模板指标  434
10.2  监控Nginx  435
10.2.1  Nginx监控原理  435
10.2.2  Nginx状态数据配置的开启  435
10.2.3  Nginx监控脚本的实现  436
10.2.4  Nginx监控key的配置  437
10.3  监控PHP-FPM  438
10.3.1  PHP-FPM监控原理  438
10.3.2  PHP-FPM状态数据配置的开启  438
10.3.3  PHP-FPM监控脚本的实现  439
10.3.4  PHP-FPM监控key的配置  441
10.4  监控MySQL  442
10.4.1  MySQL监控原理  442
10.4.2  创建MySQL监控专用账户  443
10.4.3  MySQL监控模板  443
10.4.4  MySQL监控指标  444
10.4.5  MySQL模板触发器  445
10.4.6  MySQL监控效果展示  446
10.5  监控物理服务器  447
10.5.1  DELL服务器监控原理  447
10.5.2  DELL服务器IPMI的配置  447
10.5.3  通过IPMI获取数据  449
10.5.4  DELL服务IPMI监控指标  450
10.5.5  添加IPMI监控主机  450
10.6  监控物理机磁盘  451
10.6.1  物理机磁盘监控原理  451
10.6.2  物理机磁盘监控的配置  453
10.6.3  物理机磁盘监控指标  453
10.6.4  物理机磁盘监控触发器  454
10.6.5  物理机磁盘监控数据展示  454
10.7  监控Cisco路由器  455
10.7.1  Cisco路由器监控原理  455
10.7.2  Cisco路由器SNMP的配置  455
10.7.3  通过snmpwalk获取SNMP数据  455
10.7.4  添加Cisco模板  455
10.8  监控VMware  458
10.8.1  VMware监控原理  458
10.8.2  Zabbix-Server的配置  458
10.8.3  vCenter监控账户的配置  459
10.8.4  添加监控主机  459
10.8.5  监控账户宏的配置  460
10.8.6  查看监控数据  461
10.9  监控RabbitMQ  462
10.9.1  RabbitMQ监控原理  462
10.9.2  RabbitMQ监控账户的配置  462
10.9.3  RabbitMQ监控指标  463
10.9.4  RabbitMQ监控触发器  463
10.9.5  RabbitMQ监控效果展示  464
10.10  监控Elasticsearch  465
10.10.1  Elasticsearch监控原理  465
10.10.2  Elasticsearch监控指标  465
10.10.3  Elasticsearch监控触发器  465
10.11  监控Kafka  466
10.11.1  Kafka监控原理  466
10.11.2  Kafka监控的配置  466
10.11.3  Kafka监控指标  466
10.11.4  Kafka监控触发器  467
10.11.5  Kafka监控效果展示  467
10.12  监控Redis  468
10.12.1  Redis监控原理  468
10.12.2  Redis监控的配置  468
10.12.3  Redis监控指标  469
10.12.4  Redis监控触发器  469
10.12.5  Redis监控效果展示  469
10.13  监控Oracle数据库  470
10.13.1  Oracle监控原理  470
10.13.2  Oracle监控账户的配置  470
10.13.3  Oracle监控指标  472
10.13.4  Oracle监控触发器  473
10.13.5  Oracle监控效果展示  473
10.14  监控WebLogic  474
10.14.1  WebLogic监控原理  474
10.14.2  WebLogic监控的配置  474
10.14.3  WebLogic监控指标  474
10.14.4  WebLogic监控触发器  475
10.15  监控SQL Server  475
10.15.1  SQL Server监控原理  475
10.15.2  SQL Server监控指标  475
10.15.3  SQL Server监控触发器  476
10.15.4  SQL Server监控效果展示  476
10.16  监控HTTPS证书过期  477
10.16.1  HTTPS证书过期监控原理  477
10.16.2  HTTPS证书过期监控指标  478
10.16.3  HTTPS证书过期监控触发器  480
10.16.4  HTTPS证书过期监控效果展示  480
第11章  监控数据可视化  482
11.1  Grafana  482
11.1.1  Grafana简介  482
11.1.2  安装Grafana  484
11.1.3  安装并启用Grafana Zabbix插件  485
11.1.4  添加并配置Zabbix数据源  488
11.1.5  添加Grafana图形  489
11.2  Graphtrees  492
11.2.1  安装Graphtrees  492
11.2.2  展示效果  493
11.3  谷歌浏览器告警插件  493
11.4  Mac App的使用  495
11.5  手机App的使用  495
11.6  导出实时监控数据  496
11.6.1  需求来源  496
11.6.2  参数配置  496
11.6.3  数据格式  497
11.6.4  修改源码  500
11.6.5  数据对接  501
11.7  网络拓扑自动发现  502
11.7.1  需求概述  502
11.7.2  实现原理  503
11.7.3  网络拓扑自动发现实例  503
11.7.4  通过SNMP获取LLDP数据  505
11.7.5  通过Zabbix-Server获取LLDP数据  507
11.7.6  网络拓扑可视化的实现  508
11.8  监控数据可视化的意义  509
11.9  总结  509
第12章  监控性能优化  510
12.1  Zabbix性能优化概述  510
12.2  Zabbix性能优化依据  511
12.3  Zabbix配置文件参数的优化  515
12.4  Zabbix架构的优化  517
12.5  Item的工作模式及Trigger的优化  517
12.6  Zabbix数据库的优化  517
12.7  Zabbix运行硬件的优化  518
12.8  Zabbix压力测试  518
12.8.1  压力测试原理  518
12.8.2  压力测试准备  518
12.8.3  压力测试过程  520
12.8.4  压力测试总结  522
12.9  Zabbix-Server内部实现原理  522
12.9.1  Zabbix-Server的整体流程  522
12.9.2  Zabbix-Server采集器的工作流程  523
12.9.3  Zabbix-Proxy工作流程  524
12.9.4  Zabbix-Server告警的工作流程  525
12.10  Zabbix-Server配置参数  526
12.11  Zabbix-Server性能优化总结  528
第13章  Zabbix API的使用  530
13.1  Zabbix API简介  530
13.2  JSON-RPC  530
13.3  Zabbix API的使用流程  532
13.3.1  使用API的基本步骤  532
13.3.2  如何使用官方文档获取帮助  533
13.3.3  使用CURL调用API  534
13.3.4  HTTP头部Content-Type设置  536
13.3.5  用户认证结果的返回值  536
13.3.6  获取主机信息（用Python实现的示例）  537
13.3.7  添加主机（host.create）  540
13.3.8  删除主机（host.delete）  543
13.4  第三方Zabbix API模块  544
13.5  编写命令行管理工具zbx-tool  547
第14章  安装与部署的扩展  549
14.1  源码安装Zabbix-Server  549
14.1.1  安装依赖软件包  549
14.1.2  安装Zabbix-Server  549
14.1.3  导入Zabbix数据库  550
14.1.4  复制Zabbix启动脚本  551
14.1.5  配置zabbix_server.conf  551
14.1.6  复制前端代码文件到apache目录  551
14.1.7  配置PHP参数  551
14.1.8  配置Zabbix-Web  552
14.2  源码安装Zabbix-Agent  552
14.3  定制安装包  552
14.4  使用RPMbuild定制RPM包  553
14.5  使用Elasticsearch作为数据库  557
14.5.1  安装Elasticsearch  557
14.5.2  配置Elasticsearch  557
14.5.3  启动Elasticsearch  557
14.5.4  初始化Elasticsearch数据  558
14.5.5  配置Zabbix-Server  565
14.5.6  配置Zabbix-Web  566
14.5.7  验证数据配置  566
第15章  分布式监控项目实践  567
15.1  监控系统项目概述  567
15.2  监控系统项目的背景  568
15.3  监控系统项目的步骤  570
15.4  监控系统项目的规划——工作计划  570
15.5  监控系统项目的启动——需求调研  572
15.6  监控系统架构的设计——架构设计图  572
15.7  监控系统项目的推进——软硬件环境配置  573
15.7.1  安装环境的硬件要求  573
15.7.2  安装环境的软件要求  573
15.8  监控系统项目的实施——安装与部署  574
15.8.1  MySQL数据库主从库的部署  574
15.8.2  MySQL数据库主库的配置  575
15.8.3  MySQL数据库从库的配置  576
15.8.4  MySQL数据库表分区与备份  577
15.8.5  Zabbix-Server的高可用配置  577
15.8.6  Zabbix前端管理界面的安装  580
15.8.7  Zabbix-Proxy的安装与部署  580
15.9  监控功能的实现——配置与定制开发  580
15.9.1  业务组的划分  580
15.9.2  创建用户组  581
15.9.3  添加用户  581
15.9.4  定制监控模板  581
15.9.5  自动发现的配置  582
15.9.6  配置告警与告警聚合  582
15.10  监控系统与其他系统的集成  582
15.11  监控系统项目的总结  583
第16章  后记—探究监控系统  584
16.1  监控系统的使用场景  584
16.2  如何设置监控指标  585
16.3  如何度量设置告警指标  586
16.4  如何发送告警与处理告警风暴  587
16.5  告警轮班机制  588
16.6  DevOps与监控  588
16.6.1  DevOps概述  588
16.6.2  DevOps实施的方式  588
16.6.3  DevOps与监控的关系  589
16.7  ITIL与监控  589
16.7.1  ITIL概述  589
16.7.2  ITIL服务设计——可用性管理  591
16.7.3  ITIL服务设计——IT服务连续性管理  591
16.7.4  ITIL服务设计——服务目录管理  592
16.7.5  ITIL服务设计——服务级别管理  593
16.7.6  ITIL服务运营——事件管理  594
16.7.7  ITIL服务运营——事故管理  596
16.7.8  ITIL服务运营——问题管理  597
16.8  参考资料  598
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Zabbix企业级分布式监控系统（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud
第 一部分 概述和基础
第 1章 分布式和微服务概述 3
1．1 互联网系统的特征 4
1．2 分布式系统概述 4
1．2．1 分布式的切分方法 5
1．2．2 分布式系统所面临的问题 8
1．2．3 分布式的衡量标准 9
1．3 分布式系统的设计原则 10
1．3．1 CAP原则 10
1．3．2 BASE理论 11
1．4 微服务架构 12
1．4．1 概述 12
1．4．2 微服务的风格 12
1．4．3 微服务和分布式系统的关系 15
1．5 Spring Cloud 15
1．5．1 Spring Cloud的各个组件的简介 16
1．5．2 Spring Cloud版本说明 16
1．6 微服务系统样例简介 17
第 2章 技术基础 19
2．1 Spring Boot 19
2．1．1 创建Spring Boot工程 19
2．1．2 Spring Boot开发简介 21
2．1．3 多文件配置 25
2．1．4 打包和运行 27
2．1．5 Spring Boot监控 28
2．1．6 Spring Boot小结 29
2．2 REST风格简介 29
2．2．1 REST风格概述 30
2．2．2 REST风格端点开发 31
2．2．3 状态码和响应头 35
2．2．4 客户端RestTemplate的使用 38
第二部分 Spring Cloud微服务
第3章 服务治理——Eureka 43
3．1 服务治理中心 43
3．1．1 搭建Eureka服务治理中心 43
3．1．2 服务发现 47
3．1．3 多个服务治理中心实例 51
3．2 Eureka治理机制 54
3．2．1 基础架构 54
3．2．2 服务治理中心工作原理 57
3．2．3 Region和Zone 60
3．2．4 Eureka关键源码解读 62
3．2．5 Eureka使用注意点 69
3．3 Eureka配置 69
3．3．1 客户端服务注册配置 70
3．3．2 客户端服务实例配置 71
第4章 客户端负载均衡——Ribbon 73
4．1 负载均衡概述 73
4．2 初识Ribbon 74
4．2．1 Ribbon概述 74
4．2．2 Ribbon是如何实现负载均衡的 75
4．3 Ribbon负载均衡器和策略 80
4．3．1 负载均衡器 80
4．3．2 负载均衡策略 84
4．4 Ribbon服务实例清单维护 93
4．4．1 获取服务实例清单 94
4．4．2 更新服务实例清单 96
4．4．3 服务实例的心跳监测 97
4．4．4 IPing接口 99
4．5 自定义Ribbon客户端 100
4．5．1 全局配置 101
4．5．2 局部定义 101
4．6 Ribbon使用实践 103
第5章 断路器——Hystrix 105
5．1 概述 105
5．1．1 熔断的概念 105
5．1．2 服务降级 107
5．1．3 Hystrix的功能简介 108
5．2 入门实例 108
5．3 Hystrix工作原理 112
5．3．1 Hystrix命令 113
5．3．2 缓存 114
5．3．3 断路器 115
5．3．4 隔离 119
5．4 Hystrix实践 122
5．4．1 使用Hystrix命令 123
5．4．2 请求缓存 129
5．4．3 请求合并 137
5．4．4 线程池划分 145
5．5 仪表盘 146
5．5．1 单体监控 147
5．5．2 Turbine聚合监控 151
5．6 Hystrix属性配置 153
5．6．1 命令属性配置 154
5．6．2 线程池属性配置 157
第6章 新断路器——Resilience4j 158
6．1 断路器（CircuitBreaker） 160
6．1．1 断路器配置和注册机 160
6．1．2 断路器的状态 162
6．1．3 使用断路器的实例 162
6．1．4 异常处理 165
6．1．5 拾遗 166
6．2 限速器（RateLimiter） 168
6．2．1 使用实践 168
6．2．2 拾遗 170
6．3 舱壁隔离（Bulkhead） 171
6．3．1 使用舱壁隔离 171
6．3．2 拾遗 173
6．4 重试器（Retry） 173
6．4．1 使用重试机制 173
6．4．2 拾遗 175
6．5 缓存（Cache） 176
6．5．1 使用Resilience4j缓存 176
6．5．2 拾遗 178
6．6 时间限制器（TimeLimiter） 178
6．7 组件混用 179
6．8 使用Spring Boot 2的配置方式 181
6．8．1 通过配置创建断路器 181
6．8．2 通过配置创建限速器 183
第7章 声明式调用——OpenFeign 185
7．1 OpenFeign的使用 186
7．1．1 入门实例 186
7．1．2 常见的传参场景 188
7．1．3 OpenFeign客户端接口的继承 190
7．1．4 OpenFeign客户端的配置 191
7．1．5 OpenFeign的全局配置 197
7．2 配置Hystrix 199
7．2．1 使用服务降级 200
7．2．2 Hystrix中关于OpenFeign的其他配置 203
7．2．3 使用建议 204
7．3 使用Resilience4j调用OpenFeign接口 204
第8章 旧API网关——Zuul 207
8．1 什么是网关 208
8．2 Zuul入门实例 209
8．3 Zuul原理——过滤器 211
8．3．1 过滤器设计和责任链 211
8．3．2 开发过滤器 214
8．3．3 Zuul自动装配的过滤器 218
8．4 限流 220
8．4．1 Resilience4j限速器限流 220
8．4．2 spring-cloud-zuul-ratelimit限速 222
8．5 动态路由 224
8．5．1 动态路由原理 224
8．5．2 动态路由实例 226
8．6 灰度发布（金丝雀发布） 230
8．6．1 标记微服务是否为灰色发布 230
8．6．2 网关过滤 231
8．7 使用Hystrix熔断 232
第9章 新网关——Spring CloudGateway 235
9．1 认识Gateway 236
9．1．1 入门实例 237
9．1．2 Gateway执行原理 238
9．2 断言（Predicate） 242
9．2．1 Before路由断言工厂 242
9．2．2 After路由断言工厂 243
9．2．3 Between路由断言工厂 244
9．2．4 Cookie路由断言工厂 245
9．2．5 Header路由断言工厂 246
9．2．6 Host路由断言工厂 246
9．2．7 Method路由断言工厂 247
9．2．8 Path路由断言工厂 248
9．2．9 Query路由断言工厂 249
9．2．10 RemoteAddr路由断言工厂 250
9．2．11 Weight路由断言工厂 250
9．3 过滤器（Filter）概述 253
9．4 内置过滤器工厂 253
9．4．1 AddRequestHeader过滤器工厂 254
9．4．2 AddRequestParameter过滤器工厂 254
9．4．3 AddResponseHeader过滤器工厂 255
9．4．4 Retry过滤器工厂 256
9．4．5 Hystrix过滤器工厂 258
9．4．6 RequestRateLimiter过滤器工厂 259
9．4．7 StripPrefix过滤器工厂 262
9．4．8 RewritePath过滤器工厂 263
9．4．9 SetStatus过滤器工厂 264
9．4．10 小结 265
9．5 自定义过滤器 265
9．5．1 自定义过滤器——使用Resilience4j限流 265
9．5．2 全局过滤器——转发token 268
9．5．3 过滤器的顺序 269
9．6 Gateway知识补充 273
9．6．1 基于服务发现的路由 273
9．6．2 度量和动态更新路由 274
第 10章 配置——Spring Cloud Config 277
10．1 入门实例——使用Git仓库 277
10．1．1 服务端开发 278
10．1．2 客户端开发 280
10．1．3 验证配置 281
10．1．4 小结 282
10．2 使用其他方式实现配置 282
10．2．1 使用本地文件 282
10．2．2 使用SVN配置 283
10．2．3 使用数据库 284
10．3 服务端的使用详解 286
10．3．1 敏感配置加密和解密 286
10．3．2 查看配置文件和监控端点 289
10．3．3 安全认证 291
10．3．4 高可用的Config配置 293
第 11章 Spring Cloud Sleuth全链路追踪 295
11．1 链路追踪的基本概念 295
11．2 Spring Cloud Sleuth和Zipkin 297
11．3 实例 298
11．3．1 搭建Zipkin服务器 298
11．3．2 搭建服务提供者和服务消费者 300
11．3．3 搭建网关服务 303
11．3．4 查看全链路追踪 304
11．3．5 在链路中自定义样本标记属性 306
11．4 持久化 308
11．4．1 在数据库中存储链路样本 308
11．4．2 在Elasticsearch中存储链路样本 309
第 12章 微服务的监控——Spring Boot Admin 312
12．1 本章实例简介 313
12．2 URL注册方式 313
12．2．1 Admin服务端开发 313
12．2．2 Admin客户端开发 314
12．2．3 查看Admin服务端监测平台 315
12．3 服务发现注册方式 316
12．4 使用Spring Security保护Admin服务端 319
第三部分 分布式技术
第 13章 生成唯一的ID——发号机制 323
13．1 生成ID的常见办法 323
13．1．1 使用UUID 324
13．1．2 为什么不用UUID 324
13．1．3 数据库自增长 325
13．1．4 使用Redis生成ID 327
13．1．5 时钟算法 329
13．1．6 变异时钟算法——SnowFlake算法 331
13．1．7 小结 334
13．2 自定义发号机制 334
第 14章 分布式数据库技术 337
14．1 基础知识 337
14．1．1 数据库的分表、分库和分区的概念 337
14．1．2 Spring多数据源支持 339
14．2 开发环境搭建 341
14．2．1 SSM框架整合 342
14．2．2 配置多数据源 345
14．3 分片算法 350
14．3．1 哈希分片之求余算法 351
14．3．2 一致性哈希算法 352
14．3．3 热点分配法 357
14．4 分片中间件ShardingSphere 358
14．4．1 概述 358
14．4．2 ShardingSphere的重要概念 359
14．4．3 ShardingSphere的分片 360
14．4．4 实例 361
14．4．5 结束语 363
第 15章 分布式数据库事务 364
15．1 强一致性事务 364
15．1．1 两阶段提交协议——XA协议 365
15．1．2 三阶段提交协议 371
15．1．3 为什么微服务不适合使用强一致性事务 372
15．2 弱一致性事务 373
15．2．1 本节样例模型和冲正交易的概念 374
15．2．2 使用状态表 375
15．2．3 使用可靠消息源——RabbitMQ 376
15．2．4 提高尝试次数和幂等性 380
15．2．5 TCC补偿事务 381
15．2．6 小结 383
15．3 分布式事务应用的实践理论 383
15．3．1 什么时候使用分布式事务 383
15．3．2 数据修复思路 384
第 16章 分布式缓存——Redis 387
16．1 Redis的高可用 388
16．1．1 哨兵模式 389
16．1．2 Redis集群 394
16．2 使用一致性哈希（ShardedJedis） 402
16．3 分布式缓存实践 403
16．3．1 大对象的缓存 403
16．3．2 缓存穿透、并发和雪崩 404
16．3．3 缓存实践的一些建议 406
第 17章 分布式会话 407
17．1 分布式会话的几种方式 407
17．2 黏性会话 408
17．3 服务器会话复制 408
17．4 使用缓存（spring-session-data-redis） 409
17．5 持久化到数据库 411
第 18章 分布式系统权限验证 412
18．1 Spring Security 412
18．1．1 简单使用Spring Security 413
18．1．2 使用自定义用户验证 415
18．1．3 使用缓存共享实现分布式权限 421
18．1．4 跨站点请求伪造（CSRF）攻击 423
18．1．5 使用自定义页面 425
18．2 自定义微服务权限控制 427
18．2．1 基础包开发 428
18．2．2 开发Eureka客户端 432
18．2．3 网关开发 434
18．2．4 服务调用 438
18．3 OAuth 2．0概述 441
18．3．1 OAuth的概念和流程 441
18．3．2 使用JWT进行安全认证 443
18．3．3 spring-security-oauth2 444
18．4 Spring Cloud Security 445
18．4．1 构建认证服务器 446
18．4．2 开发SSO客户端 450
18．4．3 测试 453
第四部分 微服务系统实践
第 19章 远程过程调用 459
19．1 远程过程调用 459
19．1．1 REST风格服务调用性能测试 459
19．1．2 RPC入门 460
19．1．3 RPC和REST风格服务调用的对比 461
19．2 Thrift简介 462
19．2．1 配置Thrift 462
19．2．2 Thrift的数据结构和服务接口 463
19．2．3 开发业务逻辑 464
19．2．4 启动Thrift服务器 465
19．2．5 Thrift客户端 466
19．2．6 使用断路器保护服务调用 468
19．3 RPC小结 469
第 20章 微服务设计和高并发实践 470
20．1 微服务设计原则 470
20．1．1 服务拆分方法 470
20．1．2 微服务的设计原则 471
20．1．3 微服务架构 471
20．2 高并发系统的一些优化经验 472
20．2．1 提高性能 473
20．2．2 服务高可用 479
20．3 简易微服务系统实例 488
20．3．1 服务治理中心（ms-eureka） 489
20．3．2 搭建产品微服务（ms-product） 490
20．3．3 网关微服务开发（ms-zuul） 498
20．3．4 资金微服务（ms-fund） 508
20．3．5 服务实例监测平台（ms-admin） 510
20．3．6 Hystrix仪表盘（ms-dashboard） 511
20．3．7 服务链路追踪（ms-sleuth） 512
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式智能制造
第1章新一轮工业革命与分布式智能制造
1.1新一轮工业革命的本质
1.2新一代信息技术与分布式系统
1.3大批量定制与分布式智能制造
1.4东西方对新一轮工业革命的观点
1.5新一代信息技术
第2章分布式智能制造概述
2.1分布式智能制造的趋势
2.2分布式智能制造的体系
2.3分布式智能制造模式
2.4分布式智能制造的理论基础
第3章分布式智能创新
3.1分布式智能创新概述
3.2分布式知识管理
3.3企业内外的分布式创新
3.4企业与用户的分布式互动创新
3.5分布式知识产权协同保护
第4章分布式智能设计
4.1分布式智能设计概述
4.2分布式智能模块化设计
4.3分布式产品信息标准化
4.4分布式智能设计方法
第5章分布式智能生产
5.1分布式智能生产概述
5.2分布式智能生产装备
5.3分布式智能车间/企业
5.4分布式智能供应链
5.5智能生产面临的挑战和对策
第6章分布式智能制造服务
6.1分布式智能制造服务概述
6.2分布式智能制造服务模式和发展方向
6.3产品营销阶段的分布式智能制造服务
6.4产品售后阶段的分布式智能制造服务
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式智能制造
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业IT架构转型之道：阿里巴巴中台战略思想与架构实战
序言一
序言二
前言
第一部分 引  子
第1章 阿里巴巴集团中台战略引发的思考 2
1.1 阿里巴巴共享业务事业部的发展史 4
1.2 企业信息中心发展的症结 8
第2章 构建业务中台的基础——共享服务体系 15
2.1 回归SOA的本质——服务重用 15
2.2 服务需要不断的业务滋养 17
2.3 共享服务体系是培育业务创新的土壤 19
2.4 赋予业务快速创新和试错能力 21
2.5 为真正发挥大数据威力做好储备 25
2.6 改变组织阵型会带来组织效能的提升 28
第二部分 共享服务体系搭建
第3章 分布式服务框架的选择 35
3.1 淘宝平台“服务化”历程 35
3.2 “中心化”与“去中心化”服务框架的对比 39
3.3 阿里巴巴分布式服务框架HSF 45
3.4 关于微服务 53
第4章 共享服务中心建设原则 57
4.1 淘宝的共享服务中心概貌 58
4.2 什么是服务中心 61
4.3 服务中心的划分原则 63
第5章 数据拆分实现数据库能力线性扩展 67
5.1 数据库瓶颈阻碍业务的持续发展 67
5.2 数据库分库分表的实践 69
第6章 异步化与缓存原则 89
6.1 业务流程异步化 90
6.2 数据库事务异步化 91
6.3 事务与柔性事务 94
6.4 大促秒杀活动催生缓存技术的高度使用 124
第7章 打造数字化运营能力 132
7.1 业务服务化带来的问题 132
7.2 鹰眼平台的架构 137
7.3 埋点和输出日志 138
7.4 海量日志分布式处理平台 141
7.5 日志收集控制 143
7.6 典型业务场景 144
第8章 打造平台稳定性能力 157
8.1 限流和降级 158
8.2 流量调度 165
8.3 业务开关 171
8.4 容量压测及评估规划 173
8.5 全链路压测平台 176
8.6 业务一致性平台 179
第9章 共享服务中心对内和对外的协作共享 184
9.1 服务化建设野蛮发展带来的问题 184
9.2 共享服务平台的建设思路 188
9.3 共享服务平台与业务方协作 194
9.4 业务中台与前端应用协作 196
9.5 业务中台绩效考核 198
9.6 能力开放是构建生态的基础 200
第三部分 阿里巴巴能力输出与案例
第10章 大型央企互联网转型 207
10.1 项目背景 207
10.2 项目实施 208
10.3 客户收益 210
10.4 笔者感想 211
10.5 项目后记 212
第11章 时尚行业品牌公司互联网转型 216
11.1 项目背景 216
11.2 供应链的改造 219
11.3 基于SCRM的全渠道整合营销 225
11.4 小结 229
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业IT架构转型之道：阿里巴巴中台战略思想与架构实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据密集型应用系统设计
前言 .....................................................1
第一部分 数据系统基础
第1章 可靠、可扩展与可维护的应用系统 ................... 11
认识数据系统 ...........................................12
可靠性 ..................................................14
可扩展性 ................................................18
可维护性 ................................................25
小结 .....................................................28
第2章 数据模型与查询语言 ............................... 33
关系模型与文档模型 .......................................34
数据查询语言 ...........................................46
图状数据模型 ......................................52
小结 ...................................................65
第3章 数据存储与检索 .................................. 71
数据库核心：数据结构 ...................................72
事务处理与分析处理 ...................................89
列式存储 .........................................94
小结 ..............................................101
第4章 数据编码与演化 .............................. 109
数据编码格式 .................................... 110
数据流模式 ......................................124
小结 .............................................134
第二部分 分布式数据系统
第5章 数据复制 ................................. 145
主节点与从节点 ..................................146
复制滞后问题 ......................................154
多主节点复制 .......................................160
无主节点复制 .....................................168
小结 ..............................................181
第6章 数据分区 ............................... 189
数据分区与数据复制 .................................190
键-值数据的分区 ...................................190
分区与二级索引 ...................................195
分区再平衡 ....................................198
请求路由 ..................................202
小结 .................................204
第7章 事务 .............................. 211
深入理解事务 ......................................212
弱隔离级别 .................................221
串行化 ...........................................237
小结 ...........................................250
第8章 分布式系统的挑战 ...................... 259
故障与部分失效 ...............................260
不可靠的网络 ..................................262
不可靠的时钟 ..................................271
知识，真相与谎言 ...............................282
小结 ..........................................292
第9章 一致性与共识 ..................... 303
一致性保证 ....................................304
可线性化 ........................................305
顺序保证 ........................................319
分布式事务与共识 .................................330
小结 ...............................................349
第三部分 派生数据
第10章 批处理系统 ................................ 367
使用UNIX工具进行批处理 .............................368
MapReduce与分布式文件系统 .........................375
超越MapReduce ....................................394
小结 ............................................403
第11章 流处理系统 .............................. 413
发送事件流 .......................................414
数据库与流 .......................................424
流处理 .........................................435
小结 ............................................449
第12章 数据系统的未来 ............................ 461
数据集成 .........................................461
分拆数据库 .......................................469
端到端的正确性 ....................................484
做正确的事情 .......................................500
小结 ..............................................509
术语表 ............................................ 521
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据密集型应用系统设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型网站系统与Java中间件开发实践
第1章  分布式系统介绍	1
1.1  初识分布式系统	1
1.1.1  分布式系统的定义	1
1.1.2  分布式系统的意义	3
1.2  分布式系统的基础知识	5
1.2.1  组成计算机的5要素	5
1.2.2  线程与进程的执行模式	6
1.2.3  网络通信基础知识	13
1.2.4  如何把应用从单机扩展到分布式	18
1.2.5  分布式系统的难点	31
第2章  大型网站及其架构演进过程	35
2.1  什么是大型网站	35
2.2  大型网站的架构演进	37
2.2.1  用Java技术和单机来构建的网站	37
2.2.2  从一个单机的交易网站说起	38
2.2.3  单机负载告警，数据库与应用分离	40
2.2.4  应用服务器负载告警，如何让应用服务器走向集群	41
2.2.5  数据读压力变大，读写分离吧	50
2.2.6  弥补关系型数据库的不足，引入分布式存储系统	56
2.2.7  读写分离后，数据库又遇到瓶颈	58
2.2.8  数据库问题解决后，应用面对的新挑战	60
2.2.9  初识消息中间件	63
2.2.10  总结	64
第3章  构建Java中间件	67
3.1  Java中间件的定义	67
3.2  构建Java中间件的基础知识	68
3.2.1  跨平台的Java运行环境——JVM	69
3.2.2  垃圾回收与内存堆布局	70
3.2.3  Java并发编程的类、接口和方法	72
3.2.4  动态代理	89
3.2.5  反射	91
3.2.6  网络通信实现选择	93
3.3  分布式系统中的Java中间件	94
第4章  服务框架	97
4.1  网站功能持续丰富后的困境与应对	97
4.2  服务框架的设计与实现	100
4.2.1  应用从集中式走向分布式所遇到的问题	100
4.2.2  透过示例看服务框架原型	101
4.2.3  服务调用端的设计与实现	107
4.2.4  服务提供端的设计与实现	132
4.2.5  服务升级	137
4.3  实战中的优化	138
4.4  为服务化护航的服务治理	142
4.5  服务框架与ESB的对比	146
4.6  总结	147
第5章  数据访问层	149
5.1  数据库从单机到分布式的挑战和应对	149
5.1.1  从应用使用单机数据库开始	149
5.1.2  数据库垂直/水平拆分的困难	150
5.1.3  单机变为多机后，事务如何处理	152
5.1.4  多机的Sequence问题与处理	165
5.1.5  应对多机的数据查询	168
5.2  数据访问层的设计与实现	174
5.2.1  如何对外提供数据访问层的功能	174
5.2.2  按照数据层流程的顺序看数据层设计	177
5.2.3  独立部署的数据访问层实现方式	192
5.2.4  读写分离的挑战和应对	194
5.3  总结	200
第6章  消息中间件	203
6.1  消息中间件的价值	203
6.1.1  消息中间件的定义	203
6.1.2  透过示例看消息中间件对应用的解耦	204
6.2  互联网时代的消息中间件	208
6.2.1  如何解决消息发送一致性	209
6.2.2  如何解决消息中间件与使用者的强依赖问题	218
6.2.3  消息模型对消息接收的影响	222
6.2.4  消息订阅者订阅消息的方式	229
6.2.5  保证消息可靠性的做法	230
6.2.6  订阅者视角的消息重复的产生和应对	245
6.2.7  消息投递的其他属性支持	249
6.2.8  保证顺序的消息队列的设计	252
6.2.9  Push和Pull方式的对比	257
第7章  软负载中心与集中配置管理	259
7.1  初识软负载中心	259
7.2  软负载中心的结构	261
7.3  内容聚合功能的设计	263
7.4  解决服务上下线的感知	267
7.5  软负载中心的数据分发的特点和设计	269
7.5.1  数据分发与消息订阅的区别	269
7.5.2  提升数据分发性能需要注意的问题	271
7.6  针对服务化的特性支持	272
7.6.1  软负载数据分组	272
7.6.2  提供自动感知以外的上下线开关	273
7.6.3  维护管理路由规则	273
7.7  从单机到集群	274
7.7.1  数据统一管理方案	275
7.7.2  数据对等管理方案	276
7.8  集中配置管理中心	280
7.8.1  客户端实现和容灾策略	282
7.8.2  服务端实现和容灾策略	284
7.8.3  数据库策略	285
第8章  构建大型网站的其他要素	287
8.1  加速静态内容访问速度的CDN	287
8.2  大型网站的存储支持	291
8.2.1  分布式文件系统	292
8.2.2  NoSQL	294
8.2.3  缓存系统	298
8.3  搜索系统	301
8.3.1  爬虫问题	302
8.3.2  倒排索引	302
8.3.3  查询预处理	304
8.3.4  相关度计算	304
8.4  数据计算支撑	304
8.5  发布系统	307
8.6  应用监控系统	310
8.7  依赖管理系统	312
8.8  多机房问题分析	315
8.9  系统容量规划	317
8.10  内部私有云	319
后记	                                                 321
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型网站系统与Java中间件开发实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hadoop实战
第一部分  Hadoop——一种分布式编程框架
第1 章  Hadoop简介　　2
1.1  为什么写《Hadoop 实战》　　3
1.2  什么是Hadoop 　　3
1.3  了解分布式系统和Hadoop 　　4
1.4  比较SQL 数据库和Hadoop　　5
1.5  理解MapReduce　　6
1.5.1  动手扩展一个简单程序　　7
1.5.2  相同程序在MapReduce中的扩展　　9
1.6  用Hadoop统计单词——运行第一个程序　　11
1.7  Hadoop历史　　15
1.8  小结　　16
1.9  资源　　16
第2 章  初识Hadoop 　　17
2.1  Hadoop 的构造模块　　17
2.1.1  NameNode 　　17
2.1.2  DataNode 　　18
2.1.3  Secondary NameNode 　　19
2.1.4  JobTracker　　19
2.1.5  TaskTracker　　19
2.2  为Hadoop 集群安装SSH　　21
2.2.1  定义一个公共账号　　21
2.2.2  验证SSH安装　　21
2.2.3  生成SSH密钥对　　21
2.2.4  将公钥分布并登录验证　　22
2.3  运行Hadoop 　　22
2.3.1  本地（单机）模式　　23
2.3.2   伪分布模式　　24
2.3.3  全分布模式　　25
2.4  基于Web 的集群用户界面　　28
2.5  小结　　30
第3 章  Hadoop组件　　31
3.1  HDFS 文件操作　　31
3.1.1  基本文件命令　　32
3.1.2  编程读写HDFS　　35
3.2  剖析MapReduce 程序　　37
3.2.1  Hadoop数据类型　　39
3.2.2  Mapper　　40
3.2.3  Reducer　　41
3.2.4  Partitioner：重定向Mapper输出　　41
3.2.5  Combiner：本地reduce 　　43
3.2.6  预定义mapper和Reducer类的单词计数　　43
3.3  读和写　　43
3.3.1  InputFormat 　　44
3.3.2  OutputFormat　　49
3.4  小结　　50
第二部分  实战
第4 章  编写MapReduce基础程序　　52
4.1  获得专利数据集　　52
4.1.1  专利引用数据　　53
4.1.2  专利描述数据　　54
4.2  构建MapReduce 程序的基础模板　　55
4.3  计数　　60
4.4  适应Hadoop API 的改变　　64
4.5  Hadoop 的Streaming 　　 67
4.5.1  通过Unix命令使用Streaming 　　 68
4.5.2  通过脚本使用Streaming　　 69
4.5.3  用Streaming处理键/值对　　 72
4.5.4  通过Aggregate包使用Streaming　　75
4.6  使用combiner 提升性能　　 80
4.7  温故知新　　83
4.8  小结　　84
4.9  更多资源　　84
第5 章  高阶MapReduce 　　 85
5.1  链接MapReduce 作业　　 85
5.1.1  顺序链接MapReduce作业　　 85
5.1.2  具有复杂依赖的MapReduce链接　　86
5.1.3  预处理和后处理阶段的链接　　86
5.2  联结不同来源的数据　　 89
5.2.1  Reduce侧的联结　　 90
5.2.2  基于DistributedCache的复制联结　　 98
5.2.3  半联结：map侧过滤后在reduce侧联结　　101
5.3  创建一个Bloom filter 　　102
5.3.1  Bloom filter做了什么　　102
5.3.2  实现一个Bloom filter 　　104
5.3.3  Hadoop 0.20 以上版本的Bloom filter 　　 110
5.4  温故知新　　　110
5.5  小结　　 111
5.6  更多资源　　 112
第6 章  编程实践　　 113
6.1  开发MapReduce 程序　　 113
6.1.1  本地模式　　 114
6.1.2  伪分布模式　　 118
6.2  生产集群上的监视和调试　　123
6.2.1  计数器　　123
6.2.2  跳过坏记录　　125
6.2.3  用IsolationRunner重新运行出错的任务　　128
6.3  性能调优　　 129
6.3.1  通过combiner来减少网络流量　　129
6.3.2  减少输入数据量　　129
6.3.3  使用压缩　　129
6.3.4  重用JVM 　　132
6.3.5  根据猜测执行来运行　　132
6.3.6  代码重构与算法重写　　133
6.4  小结　　134
第7 章  细则手册　　135
7.1  向任务传递作业定制的参数　　 135
7.2  探查任务特定信息　　137
7.3  划分为多个输出文件　　138
7.4  以数据库作为输入输出　　143
7.5  保持输出的顺序　　145
7.6  小结　　 146
第8 章  管理Hadoop　　147
8.1  为实际应用设置特定参数值　　 147
8.2  系统体检　　149
8.3  权限设置　　151
8.4  配额管理　　151
8.5  启用回收站　　152
8.6  删减DataNode 　　152
8.7  增加DataNode 　　153
8.8  管理NameNode 和SNN　　 153
8.9  恢复失效的NameNode 　　155
8.10  感知网络布局和机架的设计　　156
8.11  多用户作业的调度　　157
8.11.1  多个JobTracker 　　 158
8.11.2  公平调度器　　158
8.12  小结　　 160
第三部分  Hadoop也疯狂
第9 章  在云上运行Hadoop 　　 162
9.1  Amazon Web Services 简介　　162
9.2  安装AWS　　163
9.2.1  获得AWS身份认证凭据　　164
9.2.2  获得命令行工具　　166
9.2.3  准备SSH密钥对　　168
9.3  在EC2 上安装Hadoop　　169
9.3.1  配置安全参数　　169
9.3.2  配置集群类型　　169
9.4  在EC2 上运行MapReduce 程序　　171
9.4.1  将代码转移到Hadoop集群上　　171
9.4.2  访问Hadoop集群上的数据　　172
9.5  清空和关闭EC2 实例　　175
9.6  Amazon Elastic MapReduce 和其他AWS 服务　　176
9.6.1  Amazon Elastic MapReduce 　　176
9.6.2  AWS导入/导出　　177
9.7  小结　　177
第10 章  用Pig编程　　178
10.1  像Pig 一样思考　　178
10.1.1  数据流语言　　179
10.1.2  数据类型　　179
10.1.3  用户定义函数　　179
10.2  安装Pig 　　179
10.3  运行Pig 　　180
10.4  通过Grunt 学习Pig Latin　　182
10.5  谈谈Pig Latin 　　186
10.5.1  数据类型和schema　　186
10.5.2  表达式和函数　　187
10.5.3  关系型运算符　　189
10.5.4  执行优化　　196
10.6  用户定义函数　　196
10.6.1  使用UDF 　　196
10.6.2  编写UDF 　　197
10.7  脚本　　199
10.7.1  注释　　199
10.7.2  参数替换　　200
10.7.3  多查询执行　　201
10.8  Pig 实战——计算相似专利的例子　　201
10.9  小结　　206
第11 章  Hive及Hadoop群　　207
11.1  Hive 　　207
11.1.1  安装与配置Hive 　　208
11.1.2  查询的示例　　210
11.1.3  深入HiveQL 　　213
11.1.4  Hive小结　　221
11.2  其他Hadoop 相关的部分　　221
11.2.1  HBase 　　221
11.2.2  ZooKeeper 　　221
11.2.3  Cascading 　　221
11.2.4  Cloudera 　　222
11.2.5  Katta 　　222
11.2.6  CloudBase 　　222
11.2.7  Aster Data和Greenplum 　　222
11.2.8  Hama和Mahout 　　223
11.2.9  search-hadoop.com 　　223
11.3  小结　　223
第12 章  案例研究　　224
12.1  转换《纽约时报》1100 万个库存图片文档　　224
12.2  挖掘中国移动的数据　　225
12.3  在StumbleUpon 推荐最佳网站　　229
12.3.1  分布式StumbleUpon 的开端　　230
12.3.2  HBase 和StumbleUpon 　　230
12.3.3  StumbleUpon 上的更多Hadoop 应用　　236
12.4  搭建面向企业查询的分析系统——IBM的ES2 项目　　238
12.4.1  ES2 系统结构　　240
12.4.2  ES2 爬虫　　241
12.4.3  ES2 分析　　242
12.4.4  小结　　249
12.4.5  参考文献　　250
附录A  HDFS文件命令　　251
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hadoop实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图说区块链
推荐序一 / V
推荐序二 / XIII
01 起源篇
账本演变：一本账的兴衰发展史 / 004
价值转移：互联网之后还有什么 / 012
信用成本：你能记住多少人的脸 / 018
技术创新：从比特币到区块链 / 026
02 原理篇
讲一个故事，什么是区块链 / 034
讲一下原理，区块链如何运作 / 053
讲几个问题，区块链底层架构 / 105
03 人物篇
永远的背影：中本聪的99 种传说 / 140
当尼克·萨博被自动售货机“砸中” / 147
从华尔街走出的区块链女性领袖人物 / 153
在《纽约时报》撰写专栏的男子 / 156
想投资所有数字资产项目的大亨 / 162
04 应用篇
区块链+ 金融 / 170
区块链+ 互联网管理 / 183
区块链+ 能源 / 190
区块链+ 政府 / 197
区块链+ 医疗 / 208
区块链+ 版权 / 214
区块链+ 物联网 / 220
区块链+ 农业 / 227
区块链+ 慈善 / 234
区块链+ 其他 / 238
05 装备篇
比特币简史：从何处来往何处去 / 246
区块链词条：人手必备拿好不送 / 271
附 录
在区块链创业公司做COO 是一种什么体验？ / 283
区块链公司的“技术大牛”们是不是都怀着改变世界的梦想？ / 286
想要让你看懂抽象化的区块链我可能还差100 个毕加索！ / 290
为了推广没人知道的区块链我们做了哪些疯狂的事？ / 292
致 谢 / 297
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图说区块链
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MongoDB权威指南（第2版）
序　　XV
前言　　XVII
第一部分　MongoDB 介绍
第1章　MongoDB 简介　　3
1.1 　易于使用　　3
1.2 　易于扩展　　4
1.3 　丰富的功能　　4
1.4 　卓越的性能　　5
1.5 　小结　　5
第2章　MongoDB 基础知识　　7
2.1 　文档　　7
2.2 　集合　　8
2.2.1 　动态模式　　8
2.2.2 　命名　　9
2.3 　数据库　　10
2.4 　启动MongoDB　　11
2.5 　MongoDB shell 简介　　12
2.5.1 　运行shell　　12
2.5.2 　MongoDB 客户端　　13
2.5.3 　shell 中的基本操作　　14
2.6 　数据类型　　16
2.6.1 　基本数据类型　　16
2.6.2 　日期　　18
2.6.3 　数组　　18
2.6.4 　内嵌文档　　19
2.6.5 　_id 和ObjectId　　20
2.7 　使用MongoDB shell　　21
2.7.1 　shell 小贴士　　22
2.7.2 　使用shell 执行脚本　　23
2.7.3 　创建.mongorc.js 文件　　25
2.7.4 　定制shell 提示　　26
2.7.5 　编辑复合变量　　26
2.7.6 　集合命名注意事项　　27
第3章　创建、更新和删除文档　　29
3.1 　插入并保存文档　　29
3.1.1 　批量插入　　29
3.1.2 　插入校验　　30
3.2 　删除文档　　31
3.3 　更新文档　　32
3.3.1 　文档替换　　32
3.3.2 　使用修改器　　34
3.3.3 　upsert　　45
3.3.4 　更新多个文档　　47
3.3.5 　返回被更新的文档　　48
3.4 　写入安全机制　　50
第4章　查询　　53
4.1 　find 简介　　53
4.1.1 　指定需要返回的键　　54
4.1.2 　限制　　55
4.2 　查询条件　　55
4.2.1 　查询条件　　55
4.2.2 　OR 查询　　56
4.2.3 　$not　　57
4.2.4 　条件语义　　57
4.3 　特定类型的查询　　58
4.3.1 　null　　58
4.3.2 　正则表达式　　59
4.3.3 　查询数组　　59
4.3.4 　查询内嵌文档　　64
4.4 　$where 查询　　65
4.5 　游标　　67
4.5.1 　limit、skip 和sort　　69
4.5.2 　避免使用skip 略过大量结果　　70
4.5.3 　高级查询选项　　72
4.5.4 　获取一致结果　　73
4.5.5 　游标生命周期　　75
4.6 　数据库命令　　75
第二部分　设计应用
第5章　索引　　81
5.1 　索引简介　　81
5.1.1 　复合索引简介　　84
5.1.2 　使用复合索引　　90
5.1.3 　$ 操作符如何使用索引　　91
5.1.4 　索引对象和数组　　96
5.1.5 　索引基数　　98
5.2 　使用explain() 和hint() 　　98
5.3 　何时不应该使用索引　　103
5.4 　索引类型　　104
5.4.1 　唯一索引　　104
5.4.2 　稀疏索引　　106
5.5 　索引管理　　107
5.5.1 　标识索引　　108
5.5.2 　修改索引　　108
第6章　特殊的索引和集合 　　111
6.1 　固定集合　　 　111
6.1.1 　创建固定集合　　113
6.1.2 　自然排序　　113
6.1.3 　循环游标　　115
6.1.4 　没有_id 索引的集合　　115
6.2 　TTL 索引　　116
6.3 　全文本索引　　116
6.3.1 　搜索语法　　119
6.3.2 　优化全文本搜索　　120
6.3.3 　在其他语言中搜索　　121
6.4 　地理空间索引　　121
6.4.1 　地理空间查询的类型　　122
6.4.2 　复合地理空间索引　　123
6.4.3　　2d 索引　　123
6.5 　使用GridFS 存储文件　　125
6.5.1 　GridFS 入门　　126
6.5.2 　在MongoDB 驱动程序中使用GridFS　　126
6.5.3 　揭开GridFS 的面纱　　127
第7章　聚合　　129
7.1 　聚合框架　　129
7.2 　管道操作符　　131
7.2.1 　$match　　132
7.2.2 　$project　　132
7.2.3 　$group　　137
7.2.4 　$unwind　　140
7.2.5 　$sort　　141
7.2.6 　$limit　　142
7.2.7 　$skip　　142
7.2.8 　使用管道　　142
7.3 　MapReduce　　143
7.3.1 　示例1：找出集合中的所有键　　143
7.3.2 　示例2：网页分类　　145
7.3.3 　MongoDB 和MapReduce　　146
7.4 　聚合命令　　148
7.4.1 　count　　149
7.4.2 　distinct　　149
7.4.3 　group　　150
第8章　应用程序设计　　155
8.1 　范式化与反范式化　　155
8.1.1 　数据表示的例子　　156
8.1.2 　基数　　159
8.1.3 　好友、粉丝，以及其他的麻烦事项　　160
8.2 　优化数据操作　　162
8.2.1 　优化文档增长　　162
8.2.2 　删除旧数据　　164
8.3 　数据库和集合的设计　　164
8.4 　一致性管理　　165
8.5 　模式迁移　　166
8.6 　不适合使用MongoDB 的场景　　167
第三部分　复制
第9章　创建副本集　　171
9.1 　复制简介　　171
9.2 　建立副本集　　172
9.3 　配置副本集　　176
9.3.1 　rs 辅助函数　　178
9.3.2 　网络注意事项　　178
9.4 　修改副本集配置　　178
9.5 　设计副本集　　180
9.6 　成员配置选项　　184
9.6.1 　选举仲裁者　　184
9.6.2 　优先级　　185
9.6.3 　隐藏成员　　186
9.6.4 　延迟备份节点　　187
9.6.5 　创建索引　　187
第10章　副本集的组成　　189
10.1 　同步　　189
10.1.1 　初始化同步　　190
10.1.2 　处理陈旧数据　　193
10.2 　心跳　　193
10.3 　选举　　195
10.4 　回滚　　195
第11章　从应用程序连接副本集　　201
11.1 　客户端到副本集的连接　　201
11.2 　等待写入复制　　202
11.2.1 　可能导致错误的原因　　203
11.2.2 　"w" 的其他值　　204
11.3 　自定义复制保证规则　　204
11.3.1 　保证复制到每个数据中心的一台服务器上　　204
11.3.2 　保证写操作被复制到可见节点中的“大多数”　　206
11.3.3 　创建其他规则　　206
11.4 　将读请求发送到备份节点　　207
11.4.1 　出于一致性考虑　　207
11.4.2 　出于负载的考虑　　208
11.4.3 　何时可以从备份节点读取数据　　208
第12章　管理　　211
12.1 　以单机模式启动成员　　211
12.2 　副本集配置　　212
12.2.1 　创建副本集　　212
12.2.2 　修改副本集成员　　213
12.2.3 　创建比较大的副本集　　213
12.2.4 　强制重新配置　　214
12.3 　修改成员状态　　215
12.3.1 　把主节点变为备份节点　　215
12.3.2 　阻止选举　　215
12.3.3 　使用维护模式　　215
12.4 　监控复制　　216
12.4.1 　获取状态　　216
12.4.2 　复制图谱　　218
12.4.3 　复制循环　　220
12.4.4 　禁用复制链　　220
12.4.5 　计算延迟　　221
12.4.6 　调整oplog 大小　　222
12.4.7 　从延迟备份节点中恢复　　223
12.4.8 　创建索引　　224
12.4.9 　在预算有限的情况下进行复制　　225
12.4.10 　主节点如何跟踪延迟　　226
12.5 　主从模式　　227
12.5.1 　从主从模式切换到副本集模式　　228
12.5.2 　让副本集模仿主从模式的行为　　228
第四部分　分片
第13章　分片　　233
13.1 　分片简介　　233
13.2 　理解集群的组件　　234
13.3 　快速建立一个简单的集群　　235
第14章　配置分片　　243
14.1 　何时分片　　243
14.2 　启动服务器　　244
14.2.1 　配置服务器　　244
14.2.2 　mongos 进程　　245
14.2.3 　将副本集转换为分片　　245
14.2.4 　增加集群容量　　247
14.2.5 　数据分片　　247
14.3 　MongoDB 如何追踪集群数据　　248
14.3.1 　块范围　　249
14.3.2 　拆分块　　250
14.4 　均衡器　　254
第15章　选择片键　　257
15.1 　检查使用情况　　257
15.2 　数据分发　　258
15.2.1 　升序片键　　258
15.2.2 　随机分发的片键　　261
15.2.3 　 基于位置的片键　　262
15.3 　片键策略　　263
15.3.1 　散列片键　　264
15.3.2 　GridFS 的散列片键　　265
15.3.3 　流水策略　　266
15.3.4 　多热点　　267
15.4 　片键规则和指导方针　　270
15.4.1 　片键限制　　270
15.4.2 　片键的势　　270
15.5 　控制数据分发　　270
15.5.1 　对多个数据库和集合使用一个集群　　270
15.5.2 　手动分片　　272
第16章　分片管理　　275
16.1 　检查集群状态　　275
16.1.1 　使用sh.status 查看集群摘要信息　　275
16.1.2 　检查配置信息　　277
16.2 　查看网络连接　　282
16.2.1 　查看连接统计　　283
16.2.2 　限制连接数量　　283
16.3 　服务器管理　　285
16.3.1 　添加服务器　　285
16.3.2 　修改分片的服务器　　285
16.3.3 　删除分片　　286
16.3.4 　修改配置服务器　　288
16.4 　数据均衡　　289
16.4.1 　均衡器　　289
16.4.2 　修改块大小　　290
16.4.3 　移动块　　290
16.4.4 　特大块　　292
16.4.5 　刷新配置　　295
第五部分　应用管理
第17章　了解应用的动态　　299
17.1 　了解正在进行的操作　　299
17.1.1 　寻找有问题的操作　　301
17.1.2 　终止操作的执行　　301
17.1.3 　假象　　302
17.1.4 　避免幽灵操作　　302
17.2 　使用系统分析器　　303
17.3 　计算空间消耗　　305
17.3.1 　文档　　305
17.3.2 　集合　　305
17.3.3 　数据库　　306
17.4 　使用mongotop 和monogostat 　　307
第18章　数据管理　　311
18.1 　配置身份验证　　311
18.1.1 　身份验证基本原理　　312
18.1.2 　配置身份验证　　313
18.1.3 　身份验证的工作原理　　314
18.2 　建立和删除索引　　315
18.2.1 　在独立的服务器上建立索引　　315
18.2.2 　在副本集上建立索引　　315
18.2.3 　在分片集群上建立索引　　316
18.2.4 　删除索引　　316
18.2.5 　注意内存溢出杀手　　316
18.3 　预热数据　　317
18.3.1 　将数据库移至内存　　317
18.3.2 　将集合移至内存　　318
18.3.3 　自定义预热　　318
18.4 　压缩数据　　320
18.5 　移动集合　　321
18.6 　预分配数据文件　　322
第19章　持久性　　323
19.1 　日记系统的用途　　323
19.1.1 　批量提交写入操作　　324
19.1.2 　设定提交时间间隔　　325
19.2 　关闭日记系统　　325
19.2.1 　替换数据文件　　325
19.2.2 　修复数据文件　　326
19.2.3 　关于mongod.lock 文件　　326
19.2.4 　隐蔽的异常退出　　327
19.3 　MongoDB 无法保证的事项　　327
19.4 　检验数据损坏　　327
19.5 　副本集中的持久性　　329
第六部分　服务器管理
第20章　启动和停止MongoDB　　333
20.1 　从命令行启动　　333
20.2 　停止MongoDB　　336
20.3 　安全性　　337
20.3.1 　数据加密　　338
20.3.2 　SSL 安全连接　　338
20.4 　日志　　338
第21章　监控MongoDB　　341
21.1 　监控内存使用状况　　341
21.1.1 　有关电脑内存的介绍　　341
21.1.2 　跟踪监测内存使用状况　　342
21.1.3 　跟踪监测缺页中断　　343
21.1.4 　减少索引树的脱靶次数　　345
21.1.5 　IO 延迟　　345
21.1.6 　跟踪监测后台刷新平均时间　　346
21.2 　计算工作集的大小　　347
21.3 　跟踪监测性能状况　　349
21.4 　监控副本集　　352
第22章　备份　　355
22.1 　对服务器进行备份　　355
22.1.1 　文件系统快照　　355
22.1.2 　复制数据文件　　356
22.1.3 　使用mongodump　　357
22.2 　对副本集进行备份　　359
22.3 　对分片集群进行备份　　360
22.3.1 　备份和恢复整个集群　　360
22.3.2 　备份和恢复单独的分片　　360
22.4 　使用mongooplog 进行增量备份　　361
第23章　部署MongoDB　　363
23.1 　设计系统结构　　363
23.1.1 　选择存储介质　　363
23.1.2 　推荐的RAID 配置　　367
23.1.3 　CPU　　368
23.1.4 　选择操作系统　　368
23.1.5 　交换空间　　369
23.1.6 　文件系统　　369
23.2 　虚拟化　　370
23.2.1 　禁止内存过度分配　　370
23.2.2 　神秘的内存　　370
23.2.3 　处理网络磁盘的IO 问题　　371
23.2.4 　使用非网络磁盘　　372
23.3 　系统配置　　372
23.3.1 　禁用NUMA　　372
23.3.2 　更智能地预读取数据　　375
23.3.3 　禁用大内存页面　　376
23.3.4 　选择一种磁盘调度算法　　377
23.3.5 　不要记录访问时间　　377
23.3.6 　修改限制　　378
23.4 　网络配置　　379
23.5 　系统管理　　381
23.5.1 　时钟同步　　381
23.5.2 　OOM Killer　　381
23.5.3 　关闭定期任务　　382
附录A 　安装MongoDB　　383
附录B 　深入MongoDB　　387
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MongoDB权威指南（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Netty实战
第一部分 Netty的概念及体系结构
第1 章 Netty——异步和事件驱动 3
1.1 Java 网络编程 4
1.1.1 Java NIO 5
1.1.2 选择器 6
1.2 Netty 简介 6
1.2.1 谁在使用Netty 7
1.2.2 异步和事件驱动 8
1.3 Netty 的核心组件 9
1.3.1 Channel 9
1.3.2 回调 9
1.3.3 Future 10
1.3.4 事件和ChannelHandler 11
1.3.5 把它们放在一起 12
1.4 小结 13
第2 章 你的第一款Netty应用程序 14
2.1 设置开发环境 14
2.1.1 获取并安装Java 开发工具包 14
2.1.2 下载并安装IDE 15
2.1.3 下载和安装Apache Maven 15
2.1.4 配置工具集 16
2.2 Netty 客户端/服务器概览 16
2.3 编写Echo 服务器 17
2.3.1 ChannelHandler 和业务逻辑 17
2.3.2 引导服务器 18
2.4 编写Echo 客户端 21
2.4.1 通过ChannelHandler 实现客户端逻辑 21
2.4.2 引导客户端 22
2.5 构建和运行Echo 服务器和客户端 24
2.5.1 运行构建 24
2.5.2 运行Echo 服务器和客户端 27
2.6 小结 29
第3 章 Netty 的组件和设计 30
3.1 Channel、EventLoop 和ChannelFuture 30
3.1.1 Channel 接口 31
3.1.2 EventLoop 接口 31
3.1.3 ChannelFuture 接口 32
3.2 ChannelHandler 和ChannelPipeline 32
3.2.1 ChannelHandler 接口 32
3.2.2 ChannelPipeline 接口 33
3.2.3 更加深入地了解ChannelHandler 34
3.2.4 编码器和解码器 35
3.2.5 抽象类SimpleChannelInboundHandler 35
3.3 引导 36
3.4 小结 37
第4 章 传输 38
4.1 案例研究：传输迁移 38
4.1.1 不通过Netty 使用OIO和NIO 39
4.1.2 通过Netty 使用OIO和NIO 41
4.1.3 非阻塞的Netty 版本 42
4.2 传输API 43
4.3 内置的传输 45
4.3.1 NIO——非阻塞I/O 46
4.3.2 Epoll——用于Linux的本地非阻塞传输 47
4.3.3 OIO——旧的阻塞I/O 48
4.3.4 用于JVM 内部通信的Local 传输 48
4.3.5 Embedded 传输 49
4.4 传输的用例 49
4.5 小结 51
第5 章 ByteBuf 52
5.1 ByteBuf 的API 52
5.2 ByteBuf 类——Netty的数据容器 53
5.2.1 它是如何工作的 53
5.2.2 ByteBuf 的使用模式 53
5.3 字节级操作 57
5.3.1 随机访问索引 57
5.3.2 顺序访问索引 57
5.3.3 可丢弃字节 58
5.3.4 可读字节 58
5.3.5 可写字节 59
5.3.6 索引管理 59
5.3.7 查找操作 60
5.3.8 派生缓冲区 60
5.3.9 读/写操作 62
5.3.10 更多的操作 64
5.4 ByteBufHolder 接口 65
5.5 ByteBuf 分配 65
5.5.1 按需分配：ByteBufAllocator 接口 65
5.5.2 Unpooled 缓冲区 67
5.5.3 ByteBufUtil 类 67
5.6 引用计数 67
5.7 小结 68
第6 章 ChannelHandler 和ChannelPipeline 70
6.1 ChannelHandler 家族 70
6.1.1 Channel 的生命周期 70
6.1.2 ChannelHandler的生命周期 71
6.1.3 ChannelInboundHandler接口 71
6.1.4 ChannelOutboundHandler接口 73
6.1.5 ChannelHandler 适配器 74
6.1.6 资源管理 74
6.2 ChannelPipeline 接口 76
6.2.1 修改ChannelPipeline 78
6.2.2 触发事件 79
6.3 ChannelHandlerContext接口 80
6.3.1 使用ChannelHandlerContext 82
6.3.2 ChannelHandler 和ChannelHandlerContext 的高级用法 84
6.4 异常处理 86
6.4.1 处理入站异常 86
6.4.2 处理出站异常 87
6.5 小结 88
第7 章 EventLoop 和线程模型 89
7.1 线程模型概述 89
7.2 EventLoop 接口 90
7.2.1 Netty 4 中的I/O 和事件处理 92
7.2.2 Netty 3 中的I/O 操作 92
7.3 任务调度 93
7.3.1 JDK 的任务调度API 93
7.3.2 使用EventLoop调度任务 94
7.4 实现细节 95
7.4.1 线程管理 95
7.4.2 EventLoop/线程的分配 96
7.5 小结 98
第8 章 引导 99
8.1 Bootstrap 类 99
8.2 引导客户端和无连接协议 101
8.2.1 引导客户端 102
8.2.2 Channel 和EventLoopGroup 的兼容性 103
8.3 引导服务器 104
8.3.1 ServerBootstrap 类 104
8.3.2 引导服务器 105
8.4 从Channel引导客户端 107
8.5 在引导过程中添加多个ChannelHandler 108
8.6 使用Netty 的ChannelOption 和属性 110
8.7 引导DatagramChannel 111
8.8 关闭 112
8.9 小结 112
第9 章 单元测试 113
9.1 EmbeddedChannel概述 113
9.2 使用EmbeddedChannel测试ChannelHandler 115
9.2.1 测试入站消息 115
9.2.2 测试出站消息 118
9.3 测试异常处理 119
9.4 小结 121
第二部分 编解码器
第10 章 编解码器框架 125
10.1 什么是编解码器 125
10.2 解码器 125
10.2.1 抽象类ByteToMessageDecoder 126
10.2.2 抽象类ReplayingDecoder 127
10.2.3 抽象类MessageToMessageDecoder 128
10.2.4 TooLongFrameException 类 130
10.3 编码器 131
10.3.1 抽象类MessageToByteEncoder 131
10.3.2 抽象类MessageToMessageEncoder 132
10.4 抽象的编解码器类 133
10.4.1 抽象类ByteToMessageCodec 133
10.4.2 抽象类MessageToMessageCodec 134
10.4.3 CombinedChannelDuplexHandler 类 137
10.5 小结 138
第11 章 预置的ChannelHandler和编解码器 139
11.1 通过SSL/TLS 保护Netty 应用程序 139
11.2 构建基于Netty 的HTTP/HTTPS 应用程序 141
11.2.1 HTTP 解码器、编码器和编解码器 141
11.2.2 聚合HTTP 消息 143
11.2.3 HTTP 压缩 144
11.2.4 使用HTTPS 145
11.2.5 WebSocket 146
11.3 空闲的连接和超时 148
11.4 解码基于分隔符的协议和基于长度的协议 150
11.4.1 基于分隔符的协议 150
11.4.2 基于长度的协议 153
11.5 写大型数据 155
11.6 序列化数据 1 57
11.6.1 JDK 序列化 157
11.6.2 使用JBoss Marshalling进行序列化 157
11.6.3 通过Protocol Buffers序列化 159
11.7 小结 160
第三部分 网络协议
第12 章 WebSocket 163
12.1 WebSocket 简介 163
12.2 我们的WebSocket 示例应用程序 164
12.3 添加WebSocket支持 165
12.3.1 处理HTTP 请求 165
12.3.2 处理WebSocket 帧 168
12.3.3 初始化ChannelPipeline 169
12.3.4 引导 171
12.4 测试该应用程序 173
12.5 小结 176
第13章 使用UDP 广播事件 177
13.1 UDP 的基础知识 177
13.2 UDP 广播 178
13.3 UDP 示例应用程序 178
13.4 消息 POJO:LogEvent 179
13.5 编写广播者 180
13.6 编写监视器 185
13.7 运行LogEventBroadcaster 和LogEventMonitor 187
13.8 小结 189
第四部分 案例研究
第14 章 案例研究，第一部分 193
14.1 Droplr—构建移动服务 193
14.1.1 这一切的起因 193
14.1.2 Droplr 是怎样工作的 194
14.1.3 创造一个更加快速的上传体验 194
14.1.4 技术栈 196
14.1.5 性能 199
14.1.6 小结——站在巨人的肩膀上 200
14.2 Firebase—实时的数据同步服务 200
14.2.1 Firebase 的架构 201
14.2.2 长轮询 201
14.2.3 HTTP 1.1 keep-alive和流水线化 204
14.2.4 控制SslHandler 205
14.2.5 Firebase 小结 207
14.3 Urban Airship—构建移动服务 207
14.3.1 移动消息的基础知识 207
14.3.2 第三方递交 208
14.3.3 使用二进制协议的例子 209
14.3.4 直接面向设备的递交 211
14.3.5 Netty 擅长管理大量的并发连接 212
14.3.6 Urban Airship 小结——跨越防火墙边界 213
14.4 小结 214
第15 章 案例研究，第二部分 215
15.1 Netty 在Facebook 的使用：Nifty 和Swift 215
15.1.1 什么是Thrift 215
15.1.2 使用Netty 改善Java Thrift 的现状 216
15.1.3 Nifty 服务器的设计 217
15.1.4 Nifty 异步客户端的设计 220
15.1.5 Swift：一种更快的构建Java Thrift 服务的方式 221
15.1.6 结果 221
15.1.7 Facebook 小结 224
15.2 Netty 在Twitter的使用：Finagle 224
15.2.1 Twitter 成长的烦恼 224
15.2.2 Finagle 的诞生 224
15.2.3 Finagle 是如何工作的 225
15.2.4 Finagle 的抽象 230
15.2.5 故障管理 231
15.2.6 组合服务 232
15.2.7 未来：Netty 232
15.2.8 Twitter 小结 233
15.3 小结 233
附录 Maven 介绍 234
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Netty实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>互联网创业核心技术：构建可伸缩的web应用
1 核心概念  1
什么是伸缩性  2
从单一服务器到全球用户的 Web 架构演化  4
单一服务器  5
使用更强的服务器：垂直伸缩  6
服务分离  10
内容分发网络：静态内容的伸缩性  12
分散访问流量：水平伸缩  13
服务全球用户的伸缩性架构  16
数据中心基础设施架构概览  18
前端  19
Web 应用层  20
Web 服务层  20
附加组件  21
数据持久层  21
数据中心基础架构  22
应用架构概览  23
前端  24
Web 服务  25
支撑技术  29
小结  30
2 软件设计原则  31
简单  31
隐藏复杂与构建抽象  32
避免过度设计  33
尝试测试驱动开发  34
从软件设计的简化范例中学习  35
低耦合  36
促进低耦合  37
避免不必要的耦合  39
低耦合范式  40
不要重复自己（DRY）  41
复制粘贴代码  42
基于约定编程  43
画架构图  46
用例图  49
类图  50
模块图  51
单一职责  52
改善单一职责  52
单一职责的例子  53
开闭原则  53
依赖注入  55
控制反转（IOC）  57
为伸缩而设计  59
增加副本  60
功能分割  62
数据分片  63
自愈设计  65
小结  67
3 构建前端层  69
状态管理  70
管理 HTTP 会话  73
管理文件  77
管理其他类型的状态  80
可伸缩的前端组件  83
DNS  84
负载均衡器  85
Web 服务器  92
缓存  93
自动伸缩  94
部署案例  96
AWS 场景  97
私有数据中心  98
小结  101
4  Web 服务  102
Web 服务设计  102
Web 服务作为一种备用表示层  103
API 优先方式  105
务实的方式  107
Web 服务类型  108
以功能为中心的服务  109
以资源为中心的服务  111
伸缩 REST Web 服务  115
保持服务无状态  115
缓存服务响应  121
功能分割  124
小结  127
5  数据存储层  129
MySQL 伸缩性  130
复制  130
数据分区（分片）  142
NoSQL 伸缩性  157
最终一致性  160
快速恢复增加可用性  164
Cassandra 拓扑结构  166
小结  170
6  缓存  171
缓存命中率  171
基于 HTTP 的缓存  173
HTTP 缓存头  174
HTTP 缓存技术类型  179
伸缩 HTTP 缓存  185
缓存应用对象  188
对象缓存的一般类型  189
伸缩对象缓存  194
缓存的经验法则  198
缓存整个调用栈  198
用户间缓存重用  199
从哪儿开始使用缓存？  201
缓存失效的困难  201
小结  203
7  异步处理  204
核心概念  204
同步处理的例子  205
异步处理的例子  208
购物类比  211
消息队列  213
消息生产者  214
消息代理  215
消息消费者  216
消息协议  220
消息基础设施  221
消息队列的好处  224
实现异步处理  225
更好的伸缩性  226
平衡流量峰值  227
失败隔离和自我修复  228
解耦  229
消息队列相关的挑战  230
消息无序  230
消息重新入队列  233
竞态条件可能性增大  233
复杂度风险  234
消息队列有关的反模式  235
将消息队列当作 TCP 套接字  235
将消息队列当作数据库  235
耦合消息生产者和消费者  235
缺少坏消息处理  236
消息平台快速比较与选择  237
亚马逊简单队列服务  237
RabbitMQ  240
ActiveMQ  242
最后的比较说明  243
事件驱动架构介绍  245
请求/响应交互  246
直接队列交互  247
事件驱动交互  247
小结  250
8  数据搜索  252
索引介绍  252
数据建模  260
NoSQL 数据建模  260
宽列数据存储的例子  264
搜索引擎  271
搜索引擎介绍  272
使用专用搜索引擎  274
小结  275
9  伸缩性的其他维度  277
自动化实现生产力可伸缩  278
测试  278
构建与部署  280
监控与报警  285
日志聚合  289
个人可伸缩  291
加班不是一种伸缩性方案  291
自我管理  293
伸缩敏捷团队  300
增加人手  300
流程与创新  301
团结的文化  302
小结  303
A  推荐阅读  304
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>互联网创业核心技术：构建可伸缩的web应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>KK三部曲
致《失控》中文版的读者们
第一章 人造与天生
1.1 新生物文明
1.2 生物逻辑的胜利
1.3 学会向我们的创造物低头
第二章 蜂群思维
2.1 蜜蜂之道：分布式管理
2.2 群氓的集体智慧
2.3 非匀质的看不见的手
2.4 认知行为的分散记忆
2.5 从量变到质变
2.6 群集的利与弊
2.7 网络是21世纪的图标
第三章 有心智的机器
3.1 取悦有身体的机器
3.2 快速、廉价、失控
3.3 众愚成智
3.4 嵌套层级的优点
3.5 利用现实世界的反馈实现交流
3.6 无躯体则无意识
3.7 心智/ 躯体的黑盲性精神错乱[22]
第四章 组装复杂性
4.1 生物——机器的未来
4.2 用火和软体种子恢复草原
4.3 通往稳定生态系统的随机路线
4.4 如何同时做好一切
4.5 艰巨的“拼蛋壳”[14]任务
第五章 共同进化
5.1 放在镜子上的变色龙是什么颜色的？
5.2 生命之无法理喻之处
5.3.在持久的摇摇欲坠状态中保持平衡
5.4.岩石乃节奏缓慢的生命
5.5.不讲交情或无远见的合作
第六章 自然之流变
6.1 均衡即死亡
6.2 谁先出现，稳定性还是多样性？
6.3 生态系统：超有机体，抑或是身份作坊[14]？
6.4 变化的起源
6.5 生生不息的生命
6.6 负熵
6.7 第四个间断：生成之环
第七章 控制的兴起
7.1 古希腊的第一个人工自我
7.2 机械自我的成熟
7.3 抽水马桶：套套逻辑的原型[15]
7.4 自我能动派
第八章 封闭系统
8.1 密封的瓶装生命
8.2 邮购盖亚
8.3 人与绿藻息息相关
8.4 巨大的生态技术玻璃球
8.5 在持久的混沌中进行的实验
8.6 另外一种合成生态系统
第九章 “冒出”的生态圈
9.1 一亿美元玻璃方舟的副驾驶
9.2 城市野草
9.3 有意的季节调配
9.4 生命科学的回旋加速器
9.5 终极技术
第十章 工业生态学
10.1 全天候、全方位的接入
10.2 看不见的智能
10.3 咬人的房间与不咬人的房间
10.4 规划一个共同体
10.5 闭环制造
10.6 适应的技术
第十一章 网络经济学
11.1 脱离实体
11.2 以联结取代计算
11.3 信息工厂
11.4 与错误打交道
11.5 联通所有的一切
第十二章 电子货币
12.1 密码无政府状态：加密永胜
12.2 传真机效应和收益递增定律
12.3 超级传播
12.4 带电荷的东西就可用于电子货币充值
12.5 点对点金融与超级小钱
12.6 对隐密经济的恐惧
第十三章 上帝的游戏
13.1 电子神格
13.2 有交互界面的理论
13.3 一位造访他用多边形创造出来的天地的神祗
13.4 拟像的传送
13.5 数字之战
13.6 无缝分布的军队
13.7 一个万千碎片的超真实
13.8 两厢情愿的文字超级有机体
13.9 放手则赢
第十四章 在形式的图书馆中
14.1 “大千”图书馆之旅
14.2 一切可能图像之空间
14.3 倘佯在生物形态王国
14.4 御变异体而行
14.5 形式库中也有性
14.6 三步轻松繁育艺术杰作
14.7 穿越随机性
第十五章 人工进化
15.1 汤姆· 雷的电进化机
15.2 你力所不逮的，进化能行
15.3 并行实施的盲目行为
15.4 计算中的军备竞赛
15.5 驾驭野性的进化
15.6 进化聪明分子的愚钝科学家
15.7 死亡是最好的老师
15.8 蚂蚁的算法天赋
15.9 工程霸权的终结
第十六章 控制的未来
16.1 玩具世界的卡通物理学
16.2 合成角色的诞生
16.3 没有实体的机器人
16.4 行为学架构中的代理
16.5 给自由意志强加宿命
16.6 米老鼠重装上阵
16.7 寻求协同控制
第十七章 开放的宇宙
17.1 拓展生存的空间
17.2 生成图像的基元组
17.3 无心插柳柳成荫
17.4 打破规则求生存
17.5 掌握进化工具
17.6 从滑翔意外到生命游戏
17.7 生命的动词
17.8 在超生命的国度中安家落户
第十八章 有组织的变化之架构
18.1 日常进化的革命
18.2 绕开中心法则
18.3 学习和进化之间的区别
18.4 进化的进化
18.5 进化解释一切
第十九章 后达尔文主义
19.1 达尔文进化论不完备之处
19.2 只有自然选择还不够
19.3 生命之树上的连理枝
19.4 非随机突变的前提
19.5 怪亦有道
19.6 化抽象为具象
19.7 物以类聚
19.8 DNA并不能给所有东西编码
19.9 不确定的生物搜索空间密度
19.10 自然选择之数学原理
第二十章 沉睡的蝴蝶
20.1 无序之有序
20.2 反直觉的网络数学
20.3 迭坐，喷涌，自催化
20.4 值得一问的问题
20.5 自调节的活系统
第二十一章 水往高处流
21.1 40亿年的庞氏骗局[1]
21.2 进化的目的是什么
21.3 超进化的7个趋势
21.4 土狼般的自我进化
第二十二章 预言机
22.1 接球的大脑
22.2 混沌的另一面
22.3 具有正面意义的短视
22.4 从可预测性范围里挣大钱
22.5 前瞻：内视行动
22.6 预测的多样性
22.7 以万变求不变
22.8 系统存在的目的就是揭示未来
22.9 全球模型的诸多问题
22.10 舵手是大家
第二十三章 整体，空洞，以及空间
23.1 控制论怎么了？
23.2 科学知识网之缺口
23.3 令人惊讶的琐碎小事
23.4 超文本：权威的终结
23.5 新的思考空间
第二十四章 九律
24.1 如何无中生有
24.2 将宇宙据为己有
附录 人名索引
译后记：“失控”的协作与进化
作者序
第1章 形成 Becoming
第2章 知化 Cognifying
廉价的并行计算
大数据
更好的算法
第3章 流动 Flowing
第4章 屏读 Screening
第5章 使用 Accessing
减物质化（Dematerialization）
平台协同（Platform Synergy）
云端（Clouds）
第6章 共享 Sharing
分享
合作
协作
集体主义
第7章 过滤 Filtering
第8章 重混 Remixing
第9章 互动 Interacting
第10章 追踪 Tracking
第11章 提问 Questioning
第12章 开始 Beginning
致谢
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>KK三部曲
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>HBase权威指南
第1章　简介　1
1.1　海量数据的黎明　1
1.2　关系数据库系统的问题　5
1.3　非关系型数据库系统Not-Only-SQL(简称NoSQL)　7
1.3.1　维度　9
1.3.2　可扩展性　12
1.3.3　数据库的范式化和反范式化　12
1.4　结构　15
1.4.1　背景　15
1.4.2　表、行、列和单元格　16
1.4.3　自动分区　20
1.4.4　存储API　21
1.4.5　实现　22
1.4.6　小结　25
1.5　HBase：Hadoop数据库　25
1.5.1　历史　26
1.5.2　命名　27
1.5.3　小结　27
第2章　安装　28
2.1　快速启动指南　28
2.2　必备条件　31
2.2.1　硬件　31
2.2.2　软件　37
2.3　HBase使用的文件系统　47
2.3.1　本地模式　48
2.3.2　HDFS　49
2.3.3　S3　49
2.3.4　其他文件系统　50
2.4　安装选项　50
2.4.1　Apache二进制发布包　50
2.4.2　编译源码　52
2.5　运行模式　53
2.5.1　单机模式　53
2.5.2　分布式模式　53
2.6　配置　57
2.6.1　hbase-site.xml与hbase-default.xml　58
2.6.2　hbase-env.sh　59
2.6.3　regionserver　59
2.6.4　log4j.properties　59
2.6.5　配置示例　59
2.6.6　客户端配置　61
2.7　部署　61
2.7.1　基于脚本　62
2.7.2　Apache Whirr　63
2.7.3　Puppet与Chef　63
2.8　操作集群　64
2.8.1　确定安装运行　64
2.8.2　Web UI介绍　65
2.8.3　Shell介绍　66
2.8.4　关闭集群　66
第3章　客户端API：基础知识　68
3.1　概述　68
3.2　CRUD操作　69
3.2.1　put方法　69
3.2.2　get方法　87
3.2.3　删除方法　97
3.3　批量处理操作　107
3.4　行锁　110
3.5　扫描　114
3.5.1　介绍　114
3.5.2　ResultScanner类　117
3.5.3　缓存与批量处理　119
3.6　各种特性　125
3.6.1　HTable的实用方法　125
3.6.2　Bytes类　127
第4章　客户端API：高级特性　129
4.1　过滤器　129
4.1.1　过滤器简介　129
4.1.2　比较过滤器　132
4.1.3　专用过滤器　139
4.1.4　附加过滤器　147
4.1.5　FilterList　151
4.1.6　自定义过滤器　153
4.1.7　过滤器总结　159
4.2　计数器　160
4.2.1　计数器简介　160
4.2.2　单计数器　163
4.2.3　多计数器　164
4.3　协处理器　166
4.3.1　协处理器简介　167
4.3.2　Coprocessor类　168
4.3.3　协处理器加载　171
4.3.4　RegionObserver类　174
4.3.5　MasterObserver类　180
4.3.6　endpoint　184
4.4　HTablePool　190
4.5　连接管理　194
第5章　客户端API：管理功能　197
5.1　模式定义　197
5.1.1　表　197
5.1.2　表属性　199
5.1.3　列族　202
5.2　HBaseAdmin　207
5.2.1　基本操作　208
5.2.2　表操作　209
5.2.3　模式操作　217
5.2.4　集群管理　219
5.2.5　集群状态信息　222
第6章　可用客户端　230
6.1　REST、Thrift和Avro的介绍　230
6.2　交互客户端　233
6.2.1　原生Java　233
6.2.2　REST　233
6.2.3　Thrift　240
6.2.4　Avro　244
6.2.5　其他客户端　245
6.3　批处理客户端　246
6.3.1　MapReduce　246
6.3.2　Hive　246
6.3.3　Pig　252
6.3.4　Cascading　256
6.4　Shell　257
6.4.1　基础　257
6.4.2　命令　259
6.4.3　脚本　263
6.5　基于Web的UI　265
6.5.1　master的UI　265
6.5.2　region服务器的UI　270
6.5.3　共享页面　272
第7章　与MapReduce集成　275
7.1　框架　275
7.1.1　MapReduce介绍　275
7.1.2　类　276
7.1.3　支撑类　279
7.1.4　MapReduce的执行地点　279
7.1.5　表拆分　280
7.2　在HBase之上的MapReduce　281
7.2.1　准备　281
7.2.2　数据流向　286
7.2.3　数据源　291
7.2.4　数据源与数据流向　293
7.2.5　自定义处理　296
第8章　架构　299
8.1　数据查找和传输　299
8.1.1　B+树　299
8.1.2　LSM树　300
8.2　存储　302
8.2.1　概览　303
8.2.2　写路径　304
8.2.3　文件　305
8.2.4　HFile格式　313
8.2.5　KeyValue格式　316
8.3　WAL　316
8.3.1　概述　317
8.3.2　HLog类　318
8.3.3　HLogKey类　319
8.3.4　WALEdit类　319
8.3.5　LogSyncer类　319
8.3.6　LogRoller类　320
8.3.7　回放　321
8.3.8　持久性　324
8.4　读路径　325
8.5　region查找　328
8.6　region生命周期　330
8.7　ZooKeeper　330
8.8　复制　333
8.8.1　Log Edit的生命周期　334
8.8.2　内部机制　335
第9章　高级用法　339
9.1　行键设计　339
9.1.1　概念　339
9.1.2　高表与宽表　341
9.1.3　部分键扫描　342
9.1.4　分页　343
9.1.5　时间序列　344
9.1.6　时间顺序关系　348
9.2　高级模式　350
9.3　辅助索引　350
9.4　搜索集成　354
9.5　事务　357
9.6　布隆过滤器　358
9.7　版本管理　361
9.7.1　隐式版本控制　361
9.7.2　自定义版本控制　364
第10章　集群监控　366
10.1　介绍　366
10.2　监控框架　367
10.2.1　上下文、记录和监控指标　367
10.2.2　master监控指标　372
10.2.3　region服务器监控指标　373
10.2.4　RPC监控指标　375
10.2.5　JVM监控指标　376
10.2.6　info监控指标　377
10.3　Ganglia　378
10.3.1　安装　379
10.3.2　用法　383
10.4　JMX　386
10.4.1　JConsole　388
10.4.2　JMX远程API　390
10.5　Nagios　394
第11章　性能优化　395
11.1　垃圾回收优化　395
11.2　本地memstore分配缓冲区　398
11.3　压缩　399
11.3.1　可用的编解码器　400
11.3.2　验证安装　401
11.3.3　启用压缩　403
11.4　优化拆分和合并　404
11.4.1　管理拆分　404
11.4.2　region热点　405
11.4.3　预拆分region　406
11.5　负载均衡　407
11.6　合并region　408
11.7　客户端API：最佳实践　409
11.8　配置　411
11.9　负载测试　414
11.9.1　性能评价　414
11.9.2　YCSB　416
第12章　集群管理　421
12.1　运维任务　421
12.1.1　减少节点　421
12.1.2　滚动重启　423
12.1.3　新增服务器　424
12.2　数据任务　428
12.2.1　导入/导出　428
12.2.2　CopyTable工具　433
12.2.3　批量导入　435
12.2.4　复制　438
12.3　额外的任务　440
12.3.1　集群共存　440
12.3.2　端口要求　442
12.4　改变日志级别　442
12.5　故障处理　443
12.5.1　HBase Fsck　443
12.5.2　日志分析　445
12.5.3　常见问题　447
附录A　HBase配置属性　451
附录B　计划　467
附录C　版本升级　469
附录D　分支　471
附录E　Hush SQL Schema　473
附录F　对比HBase和BigTable　475
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>HBase权威指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hive编程指南
第1章基础知识
1.1Hadoop和MapReduce综述
1.2Hadoop生态系统中的Hive
1.2.1Pig
1.2.2HBase
1.2.3Cascading、Crunch及其他
1.3Java和Hive：词频统计算法
1.4后续事情
第2章基础操作
2.1安装预先配置好的虚拟机
2.2安装详细步骤
2.2.1装Java
2.2.2安装Hadoop
2.2.3本地模式、伪分布式模式和分布式模式
2.2.4测试Hadoop
2.2.5安装Hive
2.3Hive内部是什么
2.4启动Hive
2.5配置Hadoop环境
2.5.1本地模式配置
2.5.2分布式模式和伪分布式模式配置
2.5.3使用JDBC连接元数据
2.6Hive命令
2.7命令行界面
2.7.1CLI选项
2.7.2变量和属性
2.7.3Hive中“一次使用”命令
2.7.4从文件中执行Hive查询
2.7.5hiverc文件
2.7.6使用HiveCLI的更多介绍
2.7.7查看操作命令历史
2.7.8执行shell命令
2.7.9在Hive内使用Hadoop的dfs命令
2.7.10Hive脚本中如何进行注释
2.7.11显示字段名称
第3章数据类型和文件格式
3.1基本数据类型
3.2集合数据类型
3.3文本文件数据编码
3.4读时模式
第4章HiveQL：数据定义
4.1Hive中的数据库
4.2修改数据库
4.3创建表
4.3.1管理表
4.3.2外部表
4.4分区表、管理表
4.4.1外部分区表
4.4.2自定义表的存储格式
4.5删除表
4.6修改表
4.6.1表重命名
4.6.2增加、修改和删除表分区
4.6.3修改列信息
4.6.4增加列
4.6.5删除或者替换列
4.6.6修改表属性
4.6.7修改存储属性
4.6.8众多的修改表语句
第5章HiveQL：数据操作
5.1向管理表中装载数据
5.2通过查询语句向表中插入数据
5.3单个查询语句中创建表并加载数据
5.4导出数据
第6章HiveQL：查询
6.1SELECT…FROM语句
6.1.1使用正则表达式来指定列
6.1.2使用列值进行计算
6.1.3算术运算符
6.1.4使用函数
6.1.5LIMIT语句
6.1.6列别名
6.1.7嵌套SELECT语句
6.1.8CASE…WHEN…THEN句式
6.1.9什么情况下Hive可以避免进行MapReduce
6.2WHERE语句
6.2.1谓词操作符
6.2.2关于浮点数比较
6.2.3LIKE和RLIKE
6.3GROUPBY语句
6.4JOIN语句
6.4.1INNERJOIN
6.4.2JOIN优化
6.4.3LEFTOUTERJOIN
6.4.4OUTERJOIN
6.4.5RIGHTOUTERJOIN
6.4.6FULLOUTERJOIN
6.4.7LEFTSEMI—JOIN
6.4.8笛卡尔积JOIN
6.4.9map—sideJOIN
6.5ORDERBY和SORTBY
6.6含有SORTBY的DISTRIBUTEBY
6.7CLUSTERBY
6.8类型转换
6.9抽样查询
6.9.1数据块抽样
6.9.2分桶表的输入裁剪
6.10UNIONALL
第7章HiveQL：视图
7.1使用视图来降低查询复杂度
7.2使用视图来限制基于条件过滤的数据
7.3动态分区中的视图和map类型
7.4视图零零碎碎相关的事情
第8章HiveQL：索引
8.1创建索引
8.2重建索引
8.3显示索引
8.4删除索引
8.5实现一个定制化的索引处理器
第9章模式设计
9.1按天划分的表
9.2关于分区
9.3唯一键和标准化
9.4同一份数据多种处理
9.5对于每个表的分区
9.6分桶表数据存储
9.7为表增加列
9.8使用列存储表
9.8.1重复数据
9.8.2多列
9.9（几乎）总是使用压缩
第10章调优
10.1使用EXPLAIN
10.2EXPLAINEXTENDED
10.3限制调整
10.4JOIN优化
10.5本地模式
10.6并行执行
10.7严格模式
10.8调整mapper和reducer个数
10.9JVM重用
10.10索引
10.11动态分区调整
10.12推测执行
10.13单个MapReduce中多个GROUPBY
10.14虚拟列
第11章其他文件格式和压缩方法
11.1确定安装编解码器
11.2选择一种压缩编／解码器
11.3开启中间压缩
11.4最终输出结果压缩
11.5sequencefile存储格式
11.6使用压缩实践
11.7存档分区
11.8压缩：包扎
……
第12章开发
第13章函数
第14章Streaming
第15章自定义Hive文件和记录格式
第16章Hive的Thrift服务
第17章存储处理程序和NoSQL
第18章安全
第19章锁
第20章Hive和Oozie整合
第21章Hive和亚马逊网络服务系统（AWS）
第22章HCatalog
第23章案例研究
术语词汇表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hive编程指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Netty权威指南
基础篇  走进Java NIO
第1章  Java的I/O演进之路	2
1.1  I/O基础入门	3
1.1.1  Linux网络I/O模型简介	3
1.1.2  I/O多路复用技术	6
1.2  Java的I/O演进	8
1.3  总结	10
第2章  NIO入门	11
2.1  传统的BIO编程	11
2.1.1  BIO通信模型图	12
2.1.2  同步阻塞式I/O创建的TimeServer源码分析	13
2.1.3  同步阻塞式I/O创建的TimeClient源码分析	16
2.2  伪异步I/O编程	18
2.2.1  伪异步I/O模型图	19
2.2.2  伪异步式I/O创建的TimeServer源码分析	19
2.2.3  伪异步I/O弊端分析	21
2.3  NIO编程	24
2.3.1  NIO类库简介	24
2.3.2  NIO服务端序列图	28
2.3.3  NIO创建的TimeServer源码分析	31
2.3.4  NIO客户端序列图	36
2.3.5  NIO创建的TimeClient源码分析	39
2.4  AIO编程	45
2.4.1  AIO创建的TimeServer源码分析	46
2.4.2  AIO创建的TimeClient源码分析	52
2.4.3  AIO版本时间服务器运行结果	56
2.5  4种I/O的对比	58
2.5.1  概念澄清	58
2.5.2  不同I/O模型对比	60
2.6  选择Netty的理由	60
2.6.1  不选择Java原生NIO编程的原因	61
2.6.2  为什么选择Netty	62
2.7  总结	63
入门篇  Netty NIO开发指南
第3章  Netty入门应用	66
3.1  Netty开发环境的搭建	66
3.1.1  下载Netty的软件包	67
3.1.2  搭建Netty应用工程	67
3.2  Netty服务端开发	68
3.3  Netty客户端开发	73
3.4  运行和调试	76
3.4.1  服务端和客户端的运行	76
3.4.2  打包和部署	77
3.5  总结	78
第4章  TCP粘包/拆包问题的解决之道	79
4.1  TCP粘包/拆包	79
4.1.1  TCP粘包/拆包问题说明	80
4.1.2  TCP粘包/拆包发生的原因	80
4.1.3  粘包问题的解决策略	81
4.2  未考虑TCP粘包导致功能异常案例	82
4.2.1  TimeServer的改造	82
4.2.2  TimeClient的改造	83
4.2.3  运行结果	84
4.3  利用LineBasedFrameDecoder解决TCP粘包问题	88
4.3.1  支持TCP粘包的TimeServer	88
4.3.2  支持TCP粘包的TimeClient	90
4.3.3  运行支持TCP粘包的时间服务器程序	93
4.3.4  LineBasedFrameDecoder和StringDecoder的原理分析	98
4.4  总结	99
第5章  分隔符和定长解码器的应用	100
5.1  DelimiterBasedFrameDecoder应用开发	101
5.1.1  DelimiterBasedFrameDecoder服务端开发	101
5.1.2  DelimiterBasedFrameDecoder客户端开发	104
5.1.3  运行DelimiterBasedFrameDecoder服务端和客户端	106
5.2  FixedLengthFrameDecoder应用开发	108
5.2.1  FixedLengthFrameDecoder服务端开发	108
5.2.2  利用telnet命令行测试EchoServer服务端	110
5.3  总结	111
中级篇  Netty编解码开发指南
第6章  编解码技术	114
6.1  Java序列化的缺点	115
6.1.1  无法跨语言	115
6.1.2  序列化后的码流太大	115
6.1.3  序列化性能太低	118
6.2  业界主流的编解码框架	121
6.2.1  Google的Protobuf介绍	121
6.2.2  Facebook的Thrift介绍	123
6.2.3  JBoss Marshalling介绍	124
6.3  总结	125
第7章  Java序列化	126
7.1  Netty Java序列化服务端开发	126
7.2  Java序列化Netty客户端开发	132
7.3  运行结果	135
7.4  总结	137
第8章  Google Protobuf编解码	138
8.1  Protobuf的入门	139
8.1.1  Protobuf开发环境搭建	139
8.1.2  Protobuf编解码开发	141
8.1.3  运行Protobuf例程	143
8.2  Netty的Protobuf服务端开发	143
8.2.1  Protobuf版本的图书订购服务端开发	144
8.2.2  Protobuf版本的图书订购客户端开发	146
8.2.3  Protobuf版本的图书订购程序功能测试	149
8.3  Protobuf的使用注意事项	152
8.4  总结	153
第9章  JBoss Marshalling编解码	154
9.1  Marshalling开发环境准备	154
9.2  Netty的Marshalling服务端开发	155
9.3  Netty的Marshalling客户端开发	158
9.4  运行Marshalling客户端和服务端例程	160
9.5  总结	162
高级篇  Netty多协议开发和应用
第10章  HTTP协议开发应用	164
10.1  HTTP协议介绍	165
10.1.1  HTTP协议的URL	165
10.1.2  HTTP请求消息（HttpRequest）	165
10.1.3  HTTP响应消息（HttpResponse）	168
10.2  Netty HTTP服务端入门开发	169
10.2.1  HTTP服务端例程场景描述	170
10.2.2  HTTP服务端开发	170
10.2.3  Netty HTTP文件服务器例程运行结果	178
10.3  Netty HTTP+XML协议栈开发	182
10.3.1  开发场景介绍	183
10.3.2  HTTP+XML协议栈设计	186
10.3.3  高效的XML绑定框架JiBx	187
10.3.4  HTTP+XML编解码框架开发	195
10.3.5  HTTP+XML协议栈测试	211
10.3.6  小结	213
10.4  总结	214
第11章  WebSocket协议开发	215
11.1  HTTP协议的弊端	216
11.2  WebSocket入门	216
11.2.1  WebSocket背景	217
11.2.2  WebSocket连接建立	218
11.2.3  WebSocket生命周期	219
11.2.4  WebSocket连接关闭	220
11.3  Netty WebSocket协议开发	221
11.3.1  WebSocket服务端功能介绍	221
11.3.2  WebSocket服务端开发	222
11.3.3  运行WebSocket服务端	230
11.4  总结	231
第12章  UDP协议开发	233
12.1  UDP协议简介	234
12.2  UDP服务端开发	235
12.3  UDP客户端开发	238
12.4  运行UDP例程	240
12.5  总结	241
第13章  文件传输	242
13.1  文件的基础知识	243
13.1.1  文件的概念	243
13.1.2  文件路径	243
13.1.3  文件名称	244
13.1.4  FileChannel简介	244
13.2  Netty文件传输开发	245
13.3  运行Netty文件传输服务例程	248
13.4  总结	250
第14章  私有协议栈开发	251
14.1  私有协议介绍	251
14.2  Netty协议栈功能设计	253
14.2.1  网络拓扑图	253
14.2.2  协议栈功能描述	254
14.2.3  通信模型	254
14.2.4  消息定义	255
14.2.5  Netty协议支持的字段类型	256
14.2.6  Netty协议的编解码规范	257
14.2.7  链路的建立	259
14.2.8  链路的关闭	260
14.2.9  可靠性设计	260
14.2.10  安全性设计	262
14.2.11  可扩展性设计	262
14.3  Netty协议栈开发	263
14.3.1  数据结构定义	263
14.3.2  消息编解码	267
14.3.3  握手和安全认证	271
14.3.4  心跳检测机制	275
14.3.5  断连重连	278
14.3.6  客户端代码	279
14.3.7  服务端代码	281
14.4  运行协议栈	282
14.4.1  正常场景	282
14.4.2  异常场景：服务端宕机重启	283
14.4.3  异常场景：客户端宕机重启	286
14.5  总结	286
源码分析篇  Netty功能介绍和源码分析
第15章  ByteBuf和相关辅助类	290
15.1  ByteBuf功能说明	290
15.1.1  ByteBuf的工作原理	291
15.1.2  ByteBuf的功能介绍	296
15.2  ByteBuf源码分析	310
15.2.1  ByteBuf的主要类继承关系	311
15.2.2  AbstractByteBuf源码分析	312
15.2.3  AbstractReferenceCountedByteBuf源码分析	321
15.2.4  UnpooledHeapByteBuf源码分析	323
15.2.5  PooledByteBuf内存池原理分析	328
15.2.6  PooledDirectByteBuf源码分析	331
15.3  ByteBuf相关的辅助类功能介绍	334
15.3.1  ByteBufHolder	334
15.3.2  ByteBufAllocator	335
15.3.3  CompositeByteBuf	336
15.3.4  ByteBufUtil	338
15.4  总结	339
第16章  Channel和Unsafe	340
16.1  Channel 功能说明	340
16.1.1  Channel的工作原理	341
16.1.2  Channel的功能介绍	342
16.2  Channel源码分析	345
16.2.1  Channel的主要继承关系类图	345
16.2.2  AbstractChannel源码分析	346
16.2.3  AbstractNioChannel源码分析	349
16.2.4  AbstractNioByteChannel源码分析	352
16.2.5  AbstractNioMessageChannel源码分析	356
16.2.6  AbstractNioMessageServerChannel源码分析	357
16.2.7  NioServerSocketChannel源码分析	358
16.2.8  NioSocketChannel源码分析	360
16.3  Unsafe功能说明	366
16.4  Unsafe源码分析	367
16.4.1  Unsafe继承关系类图	367
16.4.2  AbstractUnsafe源码分析	367
16.4.3  AbstractNioUnsafe源码分析	377
16.4.4  NioByteUnsafe源码分析	380
16.5  总结	387
第17章  ChannelPipeline和ChannelHandler	389
17.1  ChannelPipeline功能说明	390
17.1.1  ChannelPipeline的事件处理	390
17.1.2  自定义拦截器	392
17.1.3  构建pipeline	393
17.1.4  ChannelPipeline的主要特性	394
17.2  ChannelPipeline源码分析	394
17.2.1  ChannelPipeline的类继承关系图	394
17.2.2  ChannelPipeline对ChannelHandler的管理	394
17.2.3  ChannelPipeline的inbound事件	397
17.2.4  ChannelPipeline的outbound事件	398
17.3  ChannelHandler功能说明	399
17.3.1  ChannelHandlerAdapter功能说明	400
17.3.2  ByteToMessageDecoder功能说明	400
17.3.3  MessageToMessageDecoder功能说明	401
17.3.4  LengthFieldBasedFrameDecoder功能说明	402
17.3.5  MessageToByteEncoder功能说明	405
17.3.6  MessageToMessageEncoder功能说明	406
17.3.7  LengthFieldPrepender功能说明	406
17.4  ChannelHandler源码分析	407
17.4.1  ChannelHandler的类继承关系图	407
17.4.2  ByteToMessageDecoder源码分析	408
17.4.3  MessageToMessageDecoder源码分析	411
17.4.4  LengthFieldBasedFrameDecoder源码分析	413
17.4.5  MessageToByteEncoder源码分析	417
17.4.6  MessageToMessageEncoder源码分析	418
17.4.7  LengthFieldPrepender源码分析	419
17.5  总结	420
第18章  EventLoop和EventLoopGroup	421
18.1  Netty的线程模型	421
18.1.1  Reactor单线程模型	422
18.1.2  Reactor多线程模型	423
18.1.3  主从Reactor多线程模型	424
18.1.4  Netty的线程模型	425
18.1.5  最佳实践	427
18.2  NioEventLoop源码分析	427
18.2.1  NioEventLoop设计原理	427
18.2.2  NioEventLoop继承关系类图	428
18.2.3  NioEventLoop	429
18.3  总结	440
第19章  Future和Promise	441
19.1  Future功能	441
19.2  ChannelFuture源码分析	446
19.3  Promise功能介绍	448
19.4  Promise源码分析	450
19.4.1  Promise继承关系图	450
19.4.2  DefaultPromise	450
19.5  总结	453
架构和行业应用篇  Netty高级特性
第20章  Java多线程编程在Netty中的应用	456
20.1  Java内存模型与多线程编程	456
20.1.1  硬件的发展和多任务处理	456
20.1.2  Java内存模型	457
20.2  Netty的并发编程实践	459
20.2.1  对共享的可变数据进行正确的同步	459
20.2.2  正确的使用锁	460
20.2.3  volatile的正确使用	462
20.2.4  CAS指令和原子类	465
20.2.5  线程安全类的应用	467
20.2.6  读写锁的应用	470
20.2.7  线程安全性文档说明	472
20.2.8  不要依赖线程优先级	473
20.3  总结	474
第21章  Netty架构剖析	475
21.1  Netty逻辑架构	475
21.1.1  Reactor通信调度层	476
21.1.2  职责链ChannelPipeline	476
21.1.3  业务逻辑编排层（Service ChannelHandler）	477
21.2  关键架构质量属性	477
21.2.1  高性能	477
21.2.2  可靠性	480
21.2.3  可定制性	483
21.2.4  可扩展性	483
21.3  总结	483
第22章  Netty行业应用	484
22.1  Netty在互联网行业的应用	485
22.1.1  传统垂直架构面临的问题	485
22.1.2  阿里分布式服务框架Dubbo	485
22.1.3  Dubbo的架构介绍	487
22.1.4  Netty在Dubbo中的应用	489
22.1.5  Dubbo框架集成Netty源码分析	491
22.2  Netty在大数据领域的应用	496
22.3  Netty在游戏行业的应用	497
22.3.1  游戏服务端架构介绍	498
22.3.2  Netty在游戏服务端的应用	501
22.4  总结	502
第23章  Netty未来展望	503
23.1  应用范围	503
23.2  技术演进	504
23.3  社区活跃度	504
23.4  Road Map	504
23.5  总结	505
附录A  Netty参数配置表	506
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Netty权威指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hadoop技术内幕
前　言
第一部分　环境准备
第1章　源代码环境准备/ 2
1.1　什么是Hadoop / 2
1.1.1　Hadoop简史/ 2
1.1.2　Hadoop的优势/ 3
1.1.3　Hadoop生态系统/ 4
1.2　准备源代码阅读环境/ 8
1.2.1　安装与配置JDK / 8
1.2.2　安装Eclipse / 9
1.2.3　安装辅助工具Ant/ 12
1.2.4　安装类UNIX Shell环境Cygwin / 13
1.3　准备Hadoop源代码/ 15
1.3.1　下载Hadoop / 15
1.3.2　创建Eclipse项目/ 16
1.3.3　Hadoop源代码组织/ 18
1.4　小结/ 19
第二部分　Common的实现
第2章　Hadoop配置信息处理/ 22
2.1　配置文件简介/ 22
2.1.1　Windows操作系统的配置文件/ 22
2.1.2　Java配置文件/ 23
2.2　Hadoop Configuration详解/ 24
2.2.1　Hadoop配置文件的格式/ 24
2.2.2　Configuration的成员变量/ 26
2.2.3　资源加载/ 27
2.2.4　使用get*和set*访问/设置配置项/ 32
2.3　Configurable接口/ 34
2.4　小结/ 35
第3章　序列化与压缩/ 36
3.1　序列化/ 36
3.1.1　Java内建序列化机制/ 36
3.1.2　Hadoop序列化机制/ 38
3.1.3　Hadoop序列化机制的特征/ 39
3.1.4　Hadoop Writable机制/ 39
3.1.5　典型的Writable类详解/ 41
3.1.6　Hadoop序列化框架/ 48
3.2　压缩/ 49
3.2.1　Hadoop压缩简介/ 50
3.2.2　Hadoop压缩API应用实例/ 51
3.2.3　Hadoop压缩框架/ 52
3.2.4　Java本地方法/ 61
3.2.5　支持Snappy压缩/ 65
3.3　小结/ 69
第4章　Hadoop远程过程调用/ 70
4.1　远程过程调用基础知识/ 70
4.1.1　RPC原理/ 70
4.1.2　RPC机制的实现/ 72
4.1.3　Java远程方法调用/ 73
4.2　Java动态代理/ 78
4.2.1　创建代理接口/ 78
4.2.2　调用转发/ 80
4.2.3　动态代理实例/ 81
4.3　Java NIO/ 84
4.3.1　Java基本套接字/ 84
4.3.2　Java NIO基础/ 86
4.3.3　Java NIO实例：回显服务器/ 93
4.4　Hadoop中的远程过程调用/ 96
4.4.1　利用Hadoop IPC构建简单的分布式系统/ 96
4.4.2　Hadoop IPC的代码结构/ 100
4.5　Hadoop IPC连接相关过程/ 104
4.5.1　IPC连接成员变量/ 104
4.5.2　建立IPC连接/ 106
4.5.3　数据分帧和读写/ 111
4.5.4　维护IPC连接/ 114
4.5.5　关闭IPC连接/ 116
4.6　Hadoop IPC方法调用相关过程/ 118
4.6.1　Java接口与接口体/ 119
4.6.2　IPC方法调用成员变量/ 121
4.6.3　客户端方法调用过程/ 123
4.6.4　服务器端方法调用过程/ 126
4.7　Hadoop IPC上的其他辅助过程/ 135
4.7.1　RPC.getProxy()和RPC.stopProxy() / 136
4.7.2　RPC.getServer()和Server的启停/ 138
4.8　小结/ 141
第5章　Hadoop文件系统/ 142
5.1　文件系统/ 142
5.1.1　文件系统的用户界面/ 142
5.1.2　文件系统的实现/ 145
5.1.3　文件系统的保护控制/ 147
5.2　Linux文件系统/ 150
5.2.1　Linux本地文件系统/ 150
5.2.2　虚拟文件系统/ 153
5.2.3　Linux文件保护机制/ 154
5.2.4　Linux文件系统API/ 155
5.3　分布式文件系统/ 159
5.3.1　分布式文件系统的特性/ 159
5.3.2　基本NFS体系结构/ 160
5.3.3　NFS支持的文件操作/ 160
5.4　Java文件系统/ 162
5.4.1　Java文件系统API / 162
5.4.2　URI和URL / 164
5.4.3　Java输入/输出流/ 166
5.4.4　随机存取文件/ 169
5.5　Hadoop抽象文件系统/ 170
5.5.1　Hadoop文件系统API / 170
5.5.2　Hadoop输入/输出流/ 175
5.5.3　Hadoop文件系统中的权限/ 179
5.5.4　抽象文件系统中的静态方法/ 180
5.5.5　Hadoop文件系统中的协议处理器/ 184
5.6　Hadoop具体文件系统/ 188
5.6.1　FileSystem层次结构/ 189
5.6.2　RawLocalFileSystem的实现/ 191
5.6.3　ChecksumFileSystem的实现/ 196
5.6.4　RawInMemoryFileSystem的实现/ 210
5.7　小结/ 213
第三部分　Hadoop分布式文件系统
第6章　HDFS概述/ 216
6.1　初识HDFS / 216
6.1.1　HDFS主要特性/ 216
6.1.2　HDFS体系结构/ 217
6.1.3　HDFS源代码结构/ 221
6.2　基于远程过程调用的接口/ 223
6.2.1　与客户端相关的接口/ 224
6.2.2　HDFS各服务器间的接口/ 236
6.3　非远程过程调用接口/ 244
6.3.1　数据节点上的非IPC接口/ 245
6.3.2　名字节点和第二名字节点上的非IPC接口/ 252
6.4　HDFS主要流程/ 254
6.4.1　客户端到名字节点的文件与目录操作/ 254
6.4.2　客户端读文件/ 256
6.4.3　客户端写文件/ 257
6.4.4　数据节点的启动和心跳/ 258
6.4.5　第二名字节点合并元数据/ 259
6.5　小结/ 261
第7章　数据节点实现/ 263
7.1　数据块存储/ 263
7.1.1　数据节点的磁盘目录文件结构/ 263
7.1.2　数据节点存储的实现/ 266
7.1.3　数据节点升级/ 269
7.1.4　文件系统数据集的工作机制/ 276
7.2　流式接口的实现/ 285
7.2.1　DataXceiverServer和DataXceiver / 286
7.2.2　读数据/ 289
7.2.3　写数据/ 298
7.2.4　数据块替换、数据块拷贝和读数据块检验信息/ 313
7.3　作为整体的数据节点/ 314
7.3.1　数据节点和名字节点的交互/ 314
7.3.2　数据块扫描器/ 319
7.3.3　数据节点的启停/ 321
7.4　小结/ 326
第8章　名字节点实现/ 327
8.1　文件系统的目录树/ 327
8.1.1　从i-node到INode/ 327
8.1.2　命名空间镜像和编辑日志/ 333
8.1.3　第二名字节点/ 351
8.1.4　FSDirectory的实现/ 361
8.2　数据块和数据节点管理/ 365
8.2.1　数据结构/ 366
8.2.2　数据节点管理/ 378
8.2.3　数据块管理/ 392
8.3　远程接口ClientProtocol的实现/ 412
8.3.1　文件和目录相关事务/ 412
8.3.2　读数据使用的方法/ 415
8.3.3　写数据使用的方法/ 419
8.3.4　工具dfsadmin依赖的方法/ 443
8.4　名字节点的启动和停止/ 444
8.4.1　安全模式/ 444
8.4.2　名字节点的启动/ 449
8.4.3　名字节点的停止/ 454
8.5　小结/ 454
第9章　HDFS客户端/ 455
9.1　认识DFSClient / 455
9.1.1　DFSClient的构造和关闭/ 455
9.1.2　文件和目录、系统管理相关事务/ 457
9.1.3　删除HDFS文件/目录的流程/ 459
9.2　输入流/ 461
9.2.1　读数据前的准备：打开文件/ 463
9.2.2　读数据/ 465
9.2.3　关闭输入流/ 475
9.2.4　读取HDFS文件数据的流程/ 475
9.3　输出流/ 478
9.3.1　写数据前的准备：创建文件/ 481
9.3.2　写数据：数据流管道的建立/ 482
9.3.3　写数据：数据包的发送/ 486
9.3.4　写数据：数据流管道出错处理/ 493
9.3.5　写数据：租约更新/ 496
9.3.6　写数据：DFSOutputStream.sync()的作用/ 497
9.3.7　关闭输出流/ 499
9.3.8　向HDFS文件写入数据的流程/ 500
9.4　DistributedFileSystem的实现/ 506
9.5　HDFS常用工具/ 508
9.5.1　FsShell / 508
9.5.2　DFSAdmin / 510
9.6　小结/ 511
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hadoop技术内幕
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>反应式设计模式
第Ⅰ部分  简介
第1章  为什么需要反应式?   3
1.1  剖析反应式应用   5
1.2  应对负载   6
1.3  应对失败   7
1.4  让系统即时响应   9
1.5  避免大泥球   10
1.6  整合非反应式组件   11
1.7  小结   12
第2章  《反应式宣言》概览   13
2.1  对用户作出反应   13
2.1.1  理解传统方法   14
2.1.2  使用共享资源的延迟分析   16
2.1.3  使用队列限制最大延迟   17
2.2  利用并行性   18
2.2.1  通过并行化降低延迟   19
2.2.2  使用可组合的Future改善并行性   21
2.2.3  为序列式执行表象买单   22
2.3  并行执行的限制   24
2.3.1  阿姆达尔定律   24
2.3.2  通用伸缩性法则   25
2.4  对失败作出反应   26
2.4.1  划分与隔离   28
2.4.2  使用断路器   29
2.4.3  监督   30
2.5  放弃强一致性   32
2.5.1  ACID 2.0   33
2.5.2  接受更新   34
2.6  对反应式设计模式的需求   35
2.6.1  管理复杂性   36
2.6.2  使编程模型更贴近真实世界   37
2.7  小结   38
第3章  行业工具   39
3.1  反应式的早期解决方案   39
3.2  函数式编程   41
3.2.1  不可变性   42
3.2.2  引用透明性   44
3.2.3  副作用   45
3.2.4  函数作为一等公民   46
3.3  即时响应用户   47
3.4  对反应式设计的现有支持   49
3.4.1  绿色线程   49
3.4.2  事件循环   50
3.4.3  通信顺序进程   51
3.4.4  Future和Promise   53
3.4.5  反应式扩展工具包   58
3.4.6  Actor模型   59
3.5  小结   64
第Ⅱ部分  微言大义
第4章  消息传递   67
4.1  消息   67
4.2  垂直伸缩   68
4.3 “基于事件”与“基于消息”   69
4.4  “同步”与“异步”   71
4.5  流量控制   73
4.6  送达保证   75
4.7  作为消息的事件   77
4.8  同步消息传递   79
4.9  小结   79
第5章  位置透明性   81
5.1  什么是位置透明性？   81
5.2  透明化远程处理的谬误   82
5.3  基于显式消息传递的纠正方案   83
5.4  优化本地消息传递   84
5.5  消息丢失   85
5.6  水平扩展性   87
5.7  位置透明性使测试更加简单   88
5.8  动态组合   88
5.9  小结   90
第6章  分而治之   91
6.1  分层拆解问题   92
6.2 “依赖”与“子模块”   94
6.3  构建你自己的大公司   96
6.4  规范和测试的优点   97
6.5  水平扩展性和垂直伸缩性   98
6.6  小结   99
第7章  原则性失败处理   101
7.1  所有权意味着承诺   101
7.2  所有权隐含生命周期控制   103
7.3  所有级别上的回弹性   104
7.4  小结   105
第8章  有界一致性   107
8.1  封装模块纠正方案   108
8.2  根据事务边界对数据和行为进行分组   109
8.3  跨事务边界建模工作流   109
8.4  失败单元即一致性单元   110
8.5  分离职责   111
8.6  坚持一致性的隔离范围   113
8.7  小结   114
第9章  按需使用非确定性   115
9.1  逻辑编程和声明式数据流   115
9.2  函数式反应式编程   117
9.3  不共享简化并发   118
9.4  共享状态的并发   119
9.5  如何窘境突围？   119
9.6  小结   121
第10章  消息流   123
10.1  推动数据向前流动   123
10.2  模型化领域流程   125
10.3  认清回弹性的局限性   125
10.4  估计速率和部署规模   126
10.5  为流量控制进行规划   127
10.6  小结   127
第Ⅲ部分  设计模式
第11章  测试反应式应用程序   131
11.1  如何测试   131
11.1.1  单元测试   132
11.1.2  组件测试   133
11.1.3  联动测试   133
11.1.4  集成测试   133
11.1.5  用户验收测试   134
11.1.6  黑盒测试与白盒测试   134
11.2  测试环境   135
11.3  异步测试   136
11.3.1  提供阻塞的消息接收者   137
11.3.2  选择超时时间的难题   139
11.3.3  断言消息的缺失   145
11.3.4  提供同步执行引擎   146
11.3.5  异步断言   148
11.3.6  完全异步的测试   149
11.3.7  断言没有发生异步错误   151
11.4  测试非确定性系统   154
11.4.1  执行计划的麻烦   155
11.4.2  测试分布式组件   155
11.4.3  模拟Actor   156
11.4.4  分布式组件   157
11.5  测试弹性   157
11.6  测试回弹性   158
11.6.1  应用程序回弹性   158
11.6.2  基础设施的回弹性   162
11.7  测试即时响应性   164
11.8  小结   165
第12章  容错及恢复模式   167
12.1  简单组件模式   167
12.1.1  问题设定   168
12.1.2  模式应用   168
12.1.3  模式回顾   170
12.1.4  适用性   171
12.2  错误内核模式   171
12.2.1  问题设定   172
12.2.2  模式应用   172
12.2.3  模式回顾   175
12.2.4  适用性   176
12.3  放任崩溃模式   176
12.3.1  问题设定   177
12.3.2  模式应用   177
12.3.3  模式回顾   178
12.3.4  实现上的考虑   179
12.3.5  推论：心跳模式   180
12.3.6  推论：主动失败信号模式   180
12.4  断路器模式   181
12.4.1  问题设定   182
12.4.2  模式应用   182
12.4.3  模式回顾   186
12.4.4  适用性   187
12.5  小结   187
第13章  复制模式   189
13.1  主动-被动复制模式   190
13.1.1  问题设定   190
13.1.2  模式应用   191
13.1.3  模式回顾   203
13.1.4  适用性   204
13.2  多主复制模式   204
13.2.1  基于共识的复制   205
13.2.2  具有冲突检测与处理方案的复制方式   208
13.2.3  无冲突的可复制数据类型   210
13.3  主动-主动复制模式   217
13.3.1  问题设定   218
13.3.2  模式应用   218
13.3.3  模式回顾   225
13.3.4  与虚拟同步模型的关系   226
13.4  小结   227
第14章  资源管理模式   229
14.1  资源封装模式   229
14.1.1  问题设定   230
14.1.2  模式应用   230
14.1.3  模式回顾   236
14.1.4  适用性   237
14.2  资源借贷模式   237
14.2.1  问题设定   238
14.2.2  模式应用   238
14.2.3  模式回顾   240
14.2.4  适用性   241
14.2.5  实现上的考虑   242
14.2.6  变体：使用资源借贷模式进行局部公开   242
14.3  复杂命令模式   243
14.3.1  问题设定   243
14.3.2  模式应用   244
14.3.3  模式回顾   251
14.3.4  适用性   252
14.4  资源池模式   252
14.4.1  问题设定   253
14.4.2  模式应用   253
14.4.3  模式回顾   255
14.4.4  实现上的考虑   256
14.5  托管阻塞模式   257
14.5.1  问题设定   257
14.5.2  模式应用   258
14.5.3  模式回顾   260
14.5.4  适用性   261
14.6  小结   262
第15章  消息流模式   263
15.1  请求-响应模式   264
15.1.1  问题设定   264
15.1.2  模式应用   265
15.1.3  该模式的常见实例   267
15.1.4  模式回顾   272
15.1.5  适用性   272
15.2  消息自包含模式   273
15.2.1  问题设定   273
15.2.2  模式应用   274
15.2.3  模式回顾   276
15.2.4  适用性   277
15.3  询问模式   277
15.3.1  问题设定   278
15.3.2  模式应用   278
15.3.3  模式回顾   281
15.3.4  适用性   283
15.4  转发流模式   283
15.4.1  问题设定   283
15.4.2  模式应用   284
15.4.3  模式回顾   284
15.4.4  适用性   285
15.5  聚合器模式   285
15.5.1  问题设定   285
15.5.2  模式应用   286
15.5.3  模式回顾   289
15.5.4  适用性   290
15.6  事务序列模式   290
15.6.1  问题设定   291
15.6.2  模式应用   291
15.6.3  模式回顾   293
15.6.4  适用性   294
15.7  业务握手协议(或可靠投递模式)   294
15.7.1  问题设定   295
15.7.2  模式应用   295
15.7.3  模式回顾   300
15.7.4  适用性   301
15.8  小结   301
第16章  流量控制模式   303
16.1  拉取模式   303
16.1.1  问题设定   304
16.1.2  模式应用   304
16.1.3  模式回顾   306
16.1.4  适用性   307
16.2  托管队列模式   307
16.2.1  问题设定   308
16.2.2  模式应用   308
16.2.3  模式回顾   310
16.2.4  适用性   310
16.3  丢弃模式   311
16.3.1  问题设定   311
16.3.2  模式应用   311
16.3.3  模式回顾   313
16.3.4  适用性   316
16.4  限流模式   316
16.4.1  问题设定   316
16.4.2  模式应用   317
16.4.3  模式回顾   320
16.5  小结   320
第17章  状态管理和持久化模式   321
17.1  领域对象模式   321
17.1.1  问题设定   322
17.1.2  模式应用   322
17.1.3  模式回顾   326
17.2  分片模式   326
17.2.1  问题设定   326
17.2.2  模式应用   327
17.2.3  模式回顾   329
17.2.4  重要警告   329
17.3  事件溯源模式   330
17.3.1  问题设定   330
17.3.2  模式应用   330
17.3.3  模式回顾   333
17.3.4  适用性   333
17.4  事件流模式   334
17.4.1  问题设定   334
17.4.2  模式应用   334
17.4.3  模式回顾   336
17.4.4  适用性   337
17.5  小结   337
附录A  反应式系统图示   339
附录B  一个虚构的案例   341
附录C 《反应式宣言》正文   355
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>反应式设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Redis使用手册
前　言
第1章　引言 1
1.1 Redis简介 1
1.2 内容编排 3
1.3 目标读者 4
1.4 预备工作 4
1.5 执行命令 5
1.6 配置服务器 6
1.7 示例代码 7
1.8 版本说明 7
1.9 读者服务网站 8
1.10 启程 8
第一部分　数据结构与应用
第2章　字符串 10
2.1 SET：为字符串键设置值 11
2.1.1 改变覆盖规则 12
2.1.2 其他信息 13
2.2 GET：获取字符串键的值 13
2.3 GETSET：获取旧值并设置新值 14
示例：缓存 14
示例：锁 16
2.4 MSET：一次为多个字符串键设置值 18
2.5 MGET：一次获取多个字符串键的值 19
2.6 MSETNX：只在键不存在的情况下，一次为多个字符串键设置值 20
示例：存储文章信息 20
2.7 STRLEN：获取字符串值的字节长度 25
2.8 字符串值的索引 26
2.9 GETRANGE：获取字符串值指定索引范围上的内容 26
2.10 SETRANGE：对字符串值的指定索引范围进行设置 27
2.10.1 自动扩展被修改的字符串 29
2.10.2 在值里面填充空字节 29
2.10.3 其他信息 30
示例：给文章存储程序加上文章长度计数功能和文章预览功能 31
2.11 APPEND：追加新内容到值的末尾 32
2.11.1 处理不存在的键 33
2.11.2 其他信息 33
示例：存储日志 34
2.12 使用字符串键存储数字值 37
2.13 INCRBY、DECRBY：对整数值执行加法操作和减法操作 37
2.13.1 类型限制 38
2.13.2 处理不存在的键 39
2.13.3 其他信息 40
2.14 INCR、DECR：对整数值执行加1操作和减1操作 40
2.15 INCRBYFLOAT：对数字值执行浮点数加法操作 41
2.15.1 处理不存在的键 41
2.15.2 使用INCRBYFLOAT执行浮点数减法操作 41
2.15.3 INCRBYFLOAT与整数值 42
2.15.4 小数位长度限制 43
2.15.5 其他信息 43
示例：ID生成器 43
示例：计数器 44
示例：限速器 46
2.16 重点回顾 48
第3章　散列 49
3.1 散列简介 50
3.2 HSET：为字段设置值 51
3.2.1 使用新值覆盖旧值 53
3.2.2 其他信息 53
3.3 HSETNX：只在字段不存在的情况下为它设置值 53
3.4 HGET：获取字段的值 54
3.4.1 处理不存在的字段或者不存在的散列 55
3.4.2 其他信息 55
示例：实现短网址生成程序 55
3.5 HINCRBY：对字段存储的整数值执行加法或减法操作 58
3.5.1 执行减法操作 58
3.5.2 处理异常情况 59
3.5.3 其他信息 59
3.6 HINCRBYFLOAT：对字段存储的数字值执行浮点数加法或减法操作 59
3.6.1 增量和字段值的类型限制 60
3.6.2 执行减法操作 60
3.6.3 其他信息 60
示例：使用散列键重新实现计数器 60
3.7 HSTRLEN：获取字段值的字节长度 63
3.8 HEXISTS：检查字段是否存在 63
3.9 HDEL：删除字段 64
3.10 HLEN：获取散列包含的字段数量 65
示例：实现用户登录会话 66
3.11 HMSET：一次为多个字段设置值 69
3.11.1 使用新值覆盖旧值 69
3.11.2 其他信息 70
3.12 HMGET：一次获取多个字段的值 70
3.13 HKEYS、HVALS、HGETALL：获取所有字段、所有值、所有字段和值 71
3.13.1 字段在散列中的排列顺序 72
3.13.2 其他信息 73
示例：存储图数据 73
示例：使用散列键重新实现文章存储程序 77
3.14 散列与字符串 79
3.14.1 散列键的优点 80
3.14.2 字符串键的优点 81
3.14.3 字符串键和散列键的选择 82
3.15 重点回顾 82
第4章　列表 83
4.1 LPUSH：将元素推入列表左端 84
4.1.1 一次推入多个元素 84
4.1.2 其他信息 86
4.2 RPUSH：将元素推入列表右端 86
4.2.1 一次推入多个元素 86
4.2.2 其他信息 88
4.3 LPUSHX、RPUSHX：只对已存在的列表执行推入操作 88
4.3.1 每次只能推入单个元素 89
4.3.2 其他信息 90
4.4 LPOP：弹出列表最左端的元素 90
4.5 RPOP：弹出列表最右端的元素 91
4.6 RPOPLPUSH：将右端弹出的元素推入左端 92
4.6.1 源列表和目标列表相同 93
4.6.2 处理空列表 94
4.6.3 其他信息 95
示例：先进先出队列 95
4.7 LLEN：获取列表的长度 96
4.8 LINDEX：获取指定索引上的元素 97
4.8.1 处理超出范围的索引 98
4.8.2 其他信息 98
4.9 LRANGE：获取指定索引范围上的元素 98
4.9.1 获取列表包含的所有元素 99
4.9.2 处理超出范围的索引 100
4.9.3 其他信息 101
示例：分页 101
4.10 LSET：为指定索引设置新元素 103
4.10.1 处理超出范围的索引 104
4.10.2 其他信息 104
4.11 LINSERT：将元素插入列表 104
4.11.1 处理不存在的元素 105
4.11.2 其他信息 105
4.12 LTRIM：修剪列表 105
4.12.1 处理负数索引 107
4.12.2 其他信息 107
4.13 LREM：从列表中移除指定元素 107
示例：待办事项列表 109
4.14 BLPOP：阻塞式左端弹出操作 112
4.14.1 解除阻塞状态 112
4.14.2 处理空列表 113
4.14.3 列表名的作用 114
4.14.4 阻塞效果的范围 114
4.14.5 其他信息 114
4.15 BRPOP：阻塞式右端弹出操作 114
4.16 BRPOPLPUSH：阻塞式弹出并推入操作 114
4.16.1 处理源列表为空的情况 116
4.16.2 其他信息 116
示例：带有阻塞功能的消息队列 116
4.17 重点回顾 119
第5章　集合 120
5.1 SADD：将元素添加到集合 121
5.1.1 忽略已存在元素 122
5.1.2 其他信息 122
5.2 SREM：从集合中移除元素 122
5.2.1 忽略不存在的元素 122
5.2.2 其他信息 123
5.3 SMOVE：将元素从一个集合移动到另一个集合 123
5.3.1 忽略不存在的元素 124
5.3.2 覆盖已存在的元素 124
5.3.3 其他信息 125
5.4 SMEMBERS：获取集合包含的所有元素 125
5.4.1 元素的无序排列 126
5.4.2 其他信息 126
5.5 SCARD：获取集合包含的元素数量 126
5.6 SISMEMBER：检查给定元素是否存在于集合 127
示例：唯一计数器 128
示例：打标签 129
示例：点赞 131
示例：投票 132
示例：社交关系 135
5.7 SRANDMEMBER：随机获取集合中的元素 137
5.7.1 返回指定数量的元素 138
5.7.2 其他信息 139
5.8 SPOP：随机地从集合中移除指定数量的元素 139
5.8.1 SPOP与SRANDMEMBER的区别 140
5.8.2 其他信息 141
示例：抽奖 141
5.9 SINTER、SINTERSTORE：对集合执行交集计算 142
5.9.1 SINTERSTORE命令 143
5.9.2 其他信息 143
5.10 SUNION、SUNIONSTORE：对集合执行并集计算 143
5.10.1 SUNIONSTORE命令 144
5.10.2 其他信息 144
5.11 SDIFF、SDIFFSTORE：对集合执行差集计算 144
5.11.1 SDIFFSTORE命令 145
5.11.2 其他信息 145
示例：共同关注与推荐关注 146
示例：使用反向索引构建商品筛选器 149
5.12 重点回顾 152
第6章　有序集合 153
6.1 ZADD：添加或更新成员 154
6.1.1 更新已有成员的分值 154
6.1.2 指定要执行的操作 154
6.1.3 返回被修改成员的数量 155
6.1.4 其他信息 156
6.2 ZREM：移除指定的成员 156
6.2.1 忽略不存在的成员 157
6.2.2 其他信息 157
6.3 ZSCORE：获取成员的分值 157
6.4 ZINCRBY：对成员的分值执行自增或自减操作 158
6.4.1 执行自减操作 159
6.4.2 处理不存在的键或者不存在的成员 160
6.4.3 其他信息 160
6.5 ZCARD：获取有序集合的大小 160
6.6 ZRANK、ZREVRANK：获取成员在有序集合中的排名 161
6.6.1 处理不存在的键或者不存在的成员 162
6.6.2 其他信息 162
6.7 ZRANGE、ZREVRANGE：获取指定索引范围内的成员 162
6.7.1 使用负数索引 163
6.7.2 获取成员及其分值 164
6.7.3 处理不存在的有序集合 165
6.7.4 其他信息 165
示例：排行榜 165
6.8 ZRANGEBYSCORE、ZREVRAN-GEBYSCORE：获取指定分值范围内的成员 167
6.8.1 获取成员及其分值 168
6.8.2 限制命令返回的成员数量 168
6.8.3 使用开区间分值范围 169
6.8.4 使用无限值作为范围 170
6.8.5 其他信息 171
6.9 ZCOUNT：统计指定分值范围内的成员数量 171
6.9.1 分值范围的格式 171
6.9.2 其他信息 172
示例：时间线 172
6.10 ZREMRANGEBYRANK：移除指定排名范围内的成员 175
6.10.1 使用负数排名 175
6.10.2 其他信息 175
6.11 ZREMRANGEBYSCORE：移除指定分值范围内的成员 176
6.12 ZUNIONSTORE、ZINTERSTORE：有序集合的并集运算和交集运算 176
6.12.1 指定聚合函数 177
6.12.2 设置权重 179
6.12.3 使用集合作为输入 180
6.12.4 其他信息 181
示例：商品推荐 181
6.13 ZRANGEBYLEX、ZREVRAN-GEBYLEX：返回指定字典序范围内的成员 182
6.13.1 ZREVRANGEBYLEX 184
6.13.2 限制命令返回的成员数量 184
6.13.3 其他信息 185
6.14 ZLEXCOUNT：统计位于字典序指定范围内的成员数量 185
6.15 ZREMRANGEBYLEX：移除位于字典序指定范围内的成员 186
示例：自动补全 187
6.16 ZPOPMAX、ZPOPMIN：弹出分值最高和最低的成员 188
6.17 BZPOPMAX、BZPOPMIN：阻塞式最大/最小元素弹出操作 189
6.18 重点回顾 191
第7章　HyperLogLog 192
7.1 HyperLogLog简介 193
7.2 PFADD：对集合元素进行计数 193
7.3 PFCOUNT：返回集合的近似基数 194
7.3.1 返回并集的近似基数 194
7.3.2 其他信息 195
示例：优化唯一计数器 195
示例：检测重复信息 196
7.4 PFMERGE：计算多个HyperLogLog的并集 198
7.4.1 PFCOUNT与PFMERGE 198
7.4.2 其他信息 199
示例：实现每周/月度/年度计数器 199
7.5 重点回顾 200
第8章　位图 201
8.1 SETBIT：设置二进制位的值 201
8.1.1 位图的扩展 202
8.1.2 偏移量只能为正数 203
8.1.3 其他信息 203
8.2 GETBIT：获取二进制位的值 203
8.2.1 处理范围之外的偏移量 204
8.2.2 其他信息 204
8.3 BITCOUNT：统计被设置的二进制位数量 204
8.3.1 只统计位图指定字节范围内的二进制位 204
8.3.2 使用负数偏移量定义统计范围 206
8.3.3 其他信息 206
示例：用户行为记录器 207
8.4 BITPOS：查找第一个指定的二进制位值 208
8.4.1 只在指定的字节范围内进行查找 209
8.4.2 使用负数偏移量定义查找范围 209
8.4.3 边界情况处理 210
8.4.4 其他信息 211
8.5 BITOP：执行二进制位运算 211
8.5.1 处理不同长度的位图 212
8.5.2 其他信息 212
示例：0-1矩阵 212
8.6 BITFIELD：在位图中存储整数值 214
8.6.1 根据偏移量对区域进行设置 214
8.6.2 根据索引对区域进行设置 216
8.6.3 获取区域存储的值 216
8.6.4 执行加法操作或减法操作 217
8.6.5 处理溢出 218
8.6.6 使用位图存储整数的原因 219
8.6.7 其他信息 219
示例：紧凑计数器 219
8.7 使用字符串命令对位图进行操作 221
8.8 重点回顾 222
第9章　地理坐标 223
9.1 GEOADD：存储坐标 224
9.1.1 更新已有位置的坐标 224
9.1.2 其他信息 224
9.2 GEOPOS：获取指定位置的坐标 224
9.3 GEODIST：计算两个位置之间的直线距离 225
9.3.1 指定距离的单位 225
9.3.2 处理不存在的位置 226
9.3.3 其他信息 226
示例：具有基本功能的用户地理位置程序 226
9.4 GEORADIUS：查找指定坐标半径范围内的其他位置 228
9.4.1 返回被匹配位置与中心点之间的距离 229
9.4.2 返回被匹配位置的坐标 229
9.4.3 排序查找结果 230
9.4.4 限制命令获取的位置数量 231
9.4.5 同时使用多个可选项 231
9.4.6 其他信息 232
9.5 GEORADIUSBYMEMBER：查找指定位置半径范围内的其他位置 232
示例：查找附近用户 233
9.6 GEOHASH：获取指定位置的Geohash值 235
9.6.1 在进行范围查找时获取Geohash值 235
9.6.2 其他信息 236
9.7 使用有序集合命令操作GEO数据 236
9.8 重点回顾 237
第10章　流 238
10.1 XADD：追加新元素到流的末尾 239
10.1.1 流元素的ID 239
10.1.2 不完整的流ID 240
10.1.3 流元素ID的限制 240
10.1.4 自动生成元素ID 241
10.1.5 限制流的长度 242
10.1.6 其他信息 243
10.2 XTRIM：对流进行修剪 243
10.3 XDEL：移除指定元素 244
10.4 XLEN：获取流包含的元素数量 244
10.5 XRANGE、XREVRANGE：访问流中元素 245
10.5.1 获取ID指定的单个元素 245
10.5.2 获取指定ID范围内的多个元素 246
10.5.3 获取所有元素 247
10.5.4 获取指定数量的元素 248
10.5.5 对流进行迭代 249
10.5.6 以逆序访问流中元素 251
10.5.7 其他信息 251
10.6 XREAD：以阻塞或非阻塞方式获取流元素 251
10.6.1 从多个流中获取大于指定ID的元素 251
10.6.2 迭代流 253
10.6.3 阻塞 254
10.6.4 只获取新出现的元素 256
10.6.5 其他信息 258
示例：消息队列 258
10.7 消费者组 260
10.7.1 创建消费者组 261
10.7.2 读取消费者组 262
10.7.3 消费者 262
10.7.4 消息的状态转换 263
10.7.5 实际示例 263
10.8 XGROUP：管理消费者组 264
10.8.1 创建消费者组 264
10.8.2 修改消费者组的最后递送消息ID 265
10.8.3 删除消费者 267
10.8.4 删除消费者组 268
10.9 XREADGROUP：读取消费者组中的消息 268
10.9.1 读取未递送过的新消息 269
10.9.2 其他信息 270
10.10 XPENDING：显示待处理消息的相关信息 270
10.11 XACK：将消息标记为“已处理” 271
10.12 XCLAIM：转移消息的归属权 272
10.12.1 只返回被转移消息的ID 273
10.12.2 其他信息 273
10.13 XINFO：查看流和消费者组的相关信息 273
10.13.1 打印消费者信息 273
10.13.2 打印消费者组信息 274
10.13.3 打印流消息 274
10.13.4 其他信息 275
示例：为消息队列提供消费者组功能 275
10.14 重点回顾 277
第二部分　附加功能
第11章　数据库 280
11.1 SELECT：切换至指定的数据库 281
11.2 KEYS：获取所有与给定匹配符相匹配的键 282
11.2.1 全局匹配符 282
11.2.2 其他信息 283
11.3 SCAN：以渐进方式迭代数据库中的键 283
11.3.1 一次简单的迭代示例 284
11.3.2 SCAN命令的迭代保证 285
11.3.3 游标的使用 285
11.3.4 迭代与给定匹配符相匹配的键 285
11.3.5 指定返回键的期望数量 286
11.3.6 数据结构迭代命令 287
11.3.7 其他信息 289
示例：构建数据库迭代器 289
11.4 RANDOMKEY：随机返回一个键 292
11.5 SORT：对键的值进行排序 292
11.5.1 指定排序方式 293
11.5.2 对字符串值进行排序 294
11.5.3 只获取部分排序结果 294
11.5.4 获取外部键的值作为结果 295
11.5.5 使用外部键的值作为排序权重 298
11.5.6 保存排序结果 299
11.5.7 其他信息 300
11.6 EXISTS：检查给定键是否存在 300
11.6.1 只能接受单个键的EXISTS命令 300
11.6.2 其他信息 300
11.7 DBSIZE：获取数据库包含的键值对数量 301
11.8 TYPE：查看键的类型 301
示例：数据库取样程序 302
11.9 RENAME、RENAMENX：修改键名 304
11.9.1 覆盖已存在的键 305
11.9.2 只在新键名尚未被占用的情况下进行改名 305
11.9.3 其他信息 306
11.10 MOVE：将给定的键移动到另一个数据库 306
11.10.1 不覆盖同名键 306
11.10.2 其他信息 307
11.11 DEL：移除指定的键 307
11.12 UNLINK：以异步方式移除指定的键 307
11.13 FLUSHDB：清空当前数据库 308
11.13.1 async选项 308
11.13.2 其他信息 309
11.14 FLUSHALL：清空所有数据库 309
11.14.1 async选项 309
11.14.2 其他信息 309
11.15 SWAPDB：互换数据库 309
示例：使用SWAPDB命令实行在线替换数据库 310
11.16 重点回顾 312
第12章　自动过期 313
12.1 EXPIRE、PEXPIRE：设置生存时间 313
12.1.1 更新键的生存时间 315
12.1.2 其他信息 315
示例：带有自动移除特性的缓存程序 316
12.2 SET命令的EX选项和PX选项 317
12.2.1 组合命令的安全问题 317
12.2.2 其他信息 318
示例：带有自动释放特性的锁 318
12.3 EXPIREAT、PEXPIREAT：设置过期时间 319
12.3.1 EXPIREAT使用示例 320
12.3.2 PEXPIREAT使用示例 320
12.3.3 更新键的过期时间 321
12.3.4 自动过期特性的不足之处 321
12.3.5 其他信息 322
12.4 TTL、PTTL：获取键的剩余生存时间 322
12.4.1 没有剩余生存时间的键和不存在的键 322
12.4.2 TTL命令的精度问题 322
12.4.3 其他信息 323
示例：自动过期的登录会话 323
示例：自动淘汰冷门数据 326
12.5 重点回顾 328
第13章　流水线与事务 329
13.1 流水线 329
示例：使用流水线优化随机键创建程序 331
13.2 事务 333
13.2.1 MULTI：开启事务 335
13.2.2 EXEC：执行事务 335
13.2.3 DISCARD：放弃事务 336
13.2.4 事务的安全性 337
13.2.5 事务对服务器的影响 337
13.2.6 流水线与事务 337
示例：实现mlpop()函数 338
13.3 带有乐观锁的事务 339
13.3.1 WATCH：对键进行监视 341
13.3.2 UNWATCH：取消对键的监视 342
示例：带有身份验证功能的锁 343
示例：带有身份验证功能的计数信号量 344
13.4 重点回顾 347
第14章　Lua脚本 348
14.1 EVAL：执行脚本 349
14.1.1 使用脚本执行Redis命令 349
14.1.2 值转换 350
14.1.3 全局变量保护 352
14.1.4 在脚本中切换数据库 353
14.1.5 脚本的原子性 353
14.1.6 以命令行方式执行脚本 353
14.1.7 其他信息 354
示例：使用脚本重新实现带有身份验证功能的锁 354
示例：实现LPOPRPUSH命令 355
14.2 SCRIPT LOAD和EVALSHA：缓存并执行脚本 357
14.3 脚本管理 359
14.3.1 SCRIPT EXISTS：检查脚本是否已被缓存 359
14.3.2 SCRIPT FLUSH：移除所有已缓存脚本 359
14.3.3 SCRIPT KILL：强制停止正在运行的脚本 360
14.4 内置函数库 361
14.4.1 redis包 362
14.4.2 bit包 364
14.4.3 struct包 364
14.4.4 cjson包 365
14.4.5 cmsgpack包 365
14.5 脚本调试 366
14.5.1 一个简单的调试示例 366
14.5.2 调试命令 368
14.5.3 断点 369
14.5.4 动态断点 371
14.5.5 输出调试日志 372
14.5.6 执行指定的代码或命令 373
14.5.7 显示调用链 373
14.5.8 重载脚本 375
14.5.9 调试模式 376
14.5.10 终止调试会话 378
14.6 重点回顾 379
第15章　持久化 380
15.1 RDB持久化 380
15.1.1 SAVE：阻塞服务器并创建RDB文件 381
15.1.2 BGSAVE：以非阻塞方式创建RDB文件 382
15.1.3 通过配置选项自动创建RDB文件 382
15.1.4 SAVE命令和BGSAVE命令的选择 384
15.1.5 RDB文件结构 384
15.1.6 载入RDB文件 386
15.1.7 数据丢失 387
15.2 AOF持久化 389
15.2.1 打开AOF持久化功能 390
15.2.2 设置AOF文件的冲洗频率 391
15.2.3 AOF重写 391
15.2.4 AOF持久化的优缺点 394
15.3 RDB-AOF混合持久化 394
15.4 同时使用RDB持久化和AOF持久化 396
15.5 无持久化 397
15.6 SHUTDOWN：关闭服务器 397
15.6.1 通过可选项指示持久化操作 398
15.6.2 其他信息 399
15.7 重点回顾 399
第16章　发布与订阅 400
16.1 PUBLISH：向频道发送消息 402
16.2 SUBSCRIBE：订阅频道 402
16.2.1 接收频道消息 403
16.2.2 其他信息 404
16.3 UNSUBSCRIBE：退订频道 404
16.3.1 UNSUBSCRIBE命令在不同客户端中的应用 404
16.3.2 其他信息 405
16.4 PSUBSCRIBE：订阅模式 405
16.4.1 接收模式消息 406
16.4.2 其他信息 407
16.5 PUNSUBSCRIBE：退订模式 407
16.5.1 PUNSUBSCRIBE命令在不同客户端中的应用 407
16.5.2 其他信息 408
16.6 PUBSUB：查看发布与订阅的相关信息 408
16.6.1 查看被订阅的频道 408
16.6.2 查看频道的订阅者数量 409
16.6.3 查看被订阅模式的总数量 409
16.6.4 其他信息 409
示例：广播系统 409
16.7 重点回顾 411
第17章　模块 412
17.1 模块的管理 413
17.1.1 编译模块 413
17.1.2 载入模块 413
17.1.3 列出已载入的模块 414
17.1.4 卸载模块 415
17.2 ReJSON模块 416
17.2.1 编译和载入 416
17.2.2 使用示例 417
17.2.3 ReJSON路径 418
17.2.4 API简介 420
17.3 RediSQL模块 423
17.3.1 编译模块 423
17.3.2 使用示例 424
17.3.3 API简介 425
17.4 RediSearch模块 428
17.4.1 下载与编译 428
17.4.2 使用示例 429
17.4.3 API简介 430
17.5 重点回顾 442
第三部分　多机功能
第18章　复制 444
18.1 REPLICAOF：将服务器设置为从服务器 446
18.1.1 通过配置选项设置从服务器 447
18.1.2 取消复制 447
18.1.3 其他信息 448
18.2 ROLE：查看服务器的角色 448
18.2.1 主服务器执行ROLE命令 448
18.2.2 从服务器执行ROLE命令 449
18.2.3 其他信息 449
18.3 数据同步 449
18.3.1 完整同步 450
18.3.2 在线更新 450
18.3.3 部分同步 451
18.4 无须硬盘的复制 452
18.5 降低数据不一致情况出现的概率 452
18.6 可写的从服务器 453
示例：使用从服务器处理复杂计算操作 454
18.7 脚本复制 455
18.7.1 脚本传播模式 455
18.7.2 命令传播模式 456
18.7.3 选择性命令传播 457
18.7.4 模式的选择 458
18.8 重点回顾 459
第19章　Sentinel 460
19.1 启动Sentinel 461
19.2 Sentinel网络 464
19.3 Sentinel管理命令 466
19.3.1 SENTINEL masters：获取所有被监视主服务器的信息 467
19.3.2 SENTINEL master：获取指定被监视主服务器的信息 468
19.3.3 SENTINEL slaves：获取被监视主服务器的从服务器信息 469
19.3.4 SENTINEL sentinels：获取其他Sentinel的相关信息 471
19.3.5 SENTINEL get-master-addr-by-name：获取给定主服务器的IP地址和端口号 472
19.3.6 SENTINEL reset：重置主服务器状态 473
19.3.7 SENTINEL failover：强制执行故障转移 473
19.3.8 SENTINEL ckquorum：检查可用Sentinel的数量 474
19.3.9 SENTINEL flushconfig：强制写入配置文件 474
19.4 在线配置Sentinel 475
19.4.1 SENTINEL monitor：监视给定主服务器 475
19.4.2 SENTINEL remove：取消对给定主服务器的监视 476
19.4.3 SENTINEL set：修改Sentinel配置选项的值 477
19.4.4 使用在线配置命令的注意事项 478
示例：使用redis-py管理Sentinel 479
19.5 重点回顾 479
第20章　集群 481
20.1 基本特性 481
20.1.1 复制与高可用 481
20.1.2 分片与重分片 482
20.1.3 高性能 482
20.1.4 简单易用 483
20.2 搭建集群 483
20.2.1 快速搭建集群 483
20.2.2 手动搭建集群 486
示例：使用客户端连接集群 489
20.3 散列标签 491
20.4 打开/关闭从节点的读命令执行权限 492
20.4.1 READONLY：打开读命令执行权限 493
20.4.2 READWRITE：关闭读命令执行权限 493
20.4.3 其他信息 494
20.5 集群管理工具redis-cli 494
20.5.1 创建集群 495
20.5.2 查看集群信息 496
20.5.3 检查集群 497
20.5.4 修复槽错误 498
20.5.5 重分片 499
20.5.6 负载均衡 501
20.5.7 添加节点 502
20.5.8 移除节点 503
20.5.9 执行命令 504
20.5.10 设置超时时间 504
20.5.11 导入数据 505
20.6 集群管理命令 506
20.6.1 CLUSTER MEET：将节点添加至集群 506
20.6.2 CLUSTER NODES：查看集群内所有节点的相关信息 508
20.6.3 CLUSTER MYID：查看当前节点的运行ID 511
20.6.4 CLUSTER INFO：查看集群信息 512
20.6.5 CLUSTER FORGET：从集群中移除节点 513
20.6.6 CLUSTER REPLICATE：将节点变为从节点 514
20.6.7 CLUSTER REPLICAS：查看给定节点的所有从节点 515
20.6.8 CLUSTER FAILOVER：强制执行故障转移 516
20.6.9 CLUSTER RESET：重置节点 517
20.7 槽管理命令 518
20.7.1 CLUSTER SLOTS：查看槽与节点之间的关联信息 519
20.7.2 CLUSTER ADDSLOTS：把槽指派给节点 520
20.7.3 CLUSTER DELSLOTS：撤销对节点的槽指派 521
20.7.4 CLUSTER FLUSHSLOTS：撤销对节点的所有槽指派 522
20.7.5 CLUSTER KEYSLOT：查看键所属的槽 523
20.7.6 CLUSTER COUNTKEYSINSLOT：查看槽包含的键数量 524
20.7.7 CLUSTER GETKEYSINSLOT：获取槽包含的键 524
20.7.8 CLUSTER SETSLOT：改变槽的状态 525
20.8 重点回顾 527
附录A　Redis安装方法 528
附录B　redis-py安装方法 531
附录C　Redis命令索引表 533
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Redis使用手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>事务处理
第一部分  事务处理基础
第一章  概述
第二章  计算机系统基本术语
第二部分  容错基础知识
第三章  容错
第三部分  面向事务的计算
第四章  事务模型
第五章  事务处理监控器：概述
第六章  事务处理监控器
第四部分  并发控制
第七章  隔离性的概念
第八章  锁的实现
第五部分  恢复
第九章  日志管理程序
第十章  事务管理器概念
第十一章  事务管理器结构
第十二章  高级事务管理器主题
第六部分  事务型文件系统：一个资源管理器实例
第十三章  文件和缓冲区管理
第十四章  面向元组的文件系统
第十五章  存取路径
第七部分  系统概览
第十六章  TP系统概览
第八部分  附录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>事务处理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大规模Web服务开发技术
目 录
第1章 大规模Web服务的开发定位——掌握整体	2
第0课 本书的起源——本书讲述的范围	3
从事大规模Web服务开发——面向大学生的Hatena实习	3
本书讲述的内容	3
本书不讲述的内容	5
致今后从事大规模Web服务的人	5
第1课 大规模服务和小规模服务	6
Hatena的服务规模	6
Hatena是大规模，Google、Facebook是超大规模	8
小规模服务和大规模服务的区别	9
应对大规模数据量	11
第2课 持续增长的服务和大规模化的障碍	13
Web服务的困难	13
Hatena的成长经历	13
系统增长战略——最小化开端、预见变化的管理和设计	17
第3课 服务开发现场	18
Hatena的技术团队体制	18
Hatena的沟通方式	19
服务开发的实际状况	19
开发所用的工具	21
总结	23
第2章 大规模数据处理入门
——内存和磁盘、Web应用程序和负载	24
第4课 Hatena Bookmark的数据规模	25
以Hatena Bookmark为例介绍大规模数据	25
Hatena Bookmark的数据规模	25
针对大规模数据的查询——处理大规模数据的感觉	26
第5课 大规模数据处理的难点——内存和磁盘	28
为何处理大规模数据如此困难——因为无法在内存中
计算	28
内存和磁盘的速度差异——内存要快105～106倍	28
为何磁盘这么慢？——内存和磁盘	29
操作系统层的加速处理	31
传输速度和总线的速度差异	31
第6课 可扩展性的要点	37
扩展和可扩展性	37
可扩展性的要点——CPU负载和I/O负载	38
Web应用程序和负载的关系	38
数据库的可扩展性很难保证	39
第7课 处理大规模数据的基础知识	44
面向程序员的大规模数据的基础	44
处理大规模数据的三个重点——写程序的技巧	44
处理大规模数据之前的三大前提知识——程序开发的
底层基础	45
第3章 操作系统的缓存和分布式
——高效处理大规模数据的原理	50
第8课 操作系统的缓存机制	51
在理解操作系统缓存的基础上编写应用程序——页面
缓存	51
虚拟内存机制	52
Linux页面缓存原理	54
VFS	56
Linux以页面为单位缓存磁盘	57
内存空闲时就缓存——通过sar确认	59
增加内存降低I/O负载	60
页面缓存是透明的	61
第9课 降低I/O负载的策略	67
以缓存为前提的降低I/O负载的策略	67
扩展到多台服务器——无法全部缓存的情况	68
单纯增加数量无法保证可扩展性	69
第10课 利用局部性的分布式	74
什么是利用局部性的分布式？	74
Partitioning——考虑局部性的分布式	75
根据访问模式分割成“岛”——考虑局部性的分布式	78
以页面缓存为前提的基本应用规则	79
第4章 数据库的横向扩展策略
——以分布式为基础的MySQL应用	82
第11课 正确应用索引
——分布式MySQL应用的大前提	83
分布式MySQL应用的三大要点	83
灵活应用操作系统缓存	83
索引的重点——B树	86
索引的效果	89
确认索引是否有效的方法——explain命令	92
第12课 MySQL的分布式
——以扩展为前提的系统设计	95
MySQL的replication功能	95
master/slave的特征——对参照系进行扩展，更新类
不扩展	96
第13课 MySQL的横向扩展和Partitioning	99
MySQL的横向扩展策略	99
关于Partitioning（表分割）的补充	99
以Partitioning为前提的设计	99
避免JOIN——利用where…in…	102
Partitioning的代价	103
第2～4章的小结	107
第5章 大规模数据处理“实践”入门
——应用程序开发的重点	108
第14课 特殊用途索引——处理大规模数据	109
索引和系统架构——超过RDBMS的处理能力时	109
特殊用途索引——使用调优后的数据结构	111
第15课 理论联系实践	115
探寻必须的技术条件	115
第2～5章小结	117
第6章 压缩编程
——考虑数据大小和I/O加速之间的关系	118
第16课 ［课题］以紧凑、简洁方式保存整数数据	119
以紧凑方式保存整数数据	119
出题意图——解决该课题有什么好处？	119
课题所用文件的内容	121
第17课 可变字节码和速度的感觉	122
可变字节码——用紧凑格式保存整数数据	122
可变字节码的伪代码	123
用“差”存储已排序整数	126
（补充）压缩的基础	126
（补充）压缩对象是整数的情形——背景理论	127
第18课 课题详解及解答范例	129
课题详解	129
（参考）pack()函数——将Perl内部数据结构以
二进制形式输出	131
（参考）二进制数据的read/write	133
（参考）性能分析	135
解答范例和思路	136
第7章 算法实用化
——从身边的例子来看理论、研究的实践投入	142
第19课 算法和算法评测	143
数据规模和复杂度的差异	143
何谓算法？	144
学习算法的意义——计算机资源有限，工程师的通用
语言	145
算法评测——复杂度记法	146
纸巾能折叠几次？——O(logn)和O(n)的差距	148
算法和数据结构——千丝万缕的联系	149
复杂度和常数项——评测很重要	150
应用算法的实际情况——简单就是美	151
灵活应用第三方实现——CPAN等	153
通过实例加深感受	155
第20课 Hatena Diary的关键字链接	156
什么是关键字链接？	156
最初的实现	156
出问题了！——关键字字典越来越大	157
用模式匹配实现关键字链接的问题	158
从正则表达式到Trie——改变匹配的实现方式	158
Aho-Corasick算法	160
换成Regexp::List	162
关键字链接的实现、变迁和考察	163
第21课 Hatena Bookmark的文章分类	164
什么是文章分类？	164
机器学习和大规模数据	165
大规模数据和Web服务——The Google Way of Science	166
贝叶斯过滤器的原理	167
算法实用化之路——Hatena Bookmark的实例	170
防守姿态和进攻姿态——从文档分类功能说开去	171
第8章 Hatena关键字链接的实现
——理解通向应用之路	176
第22课 ［课题］创建Hatena关键字链接	177
使用Aho-Corasick算法创建Hatena关键字链接	177
编写测试	180
第23课 解答范例和思路	182
解答范例	182
第9章 挑战全文搜索技术
——各种各样的大规模数据处理经验技巧	184
第24课 全文搜索技术的应用范围	185
用Hatena的数据创建搜索引擎	185
Hatena Diray的全文搜索——搜索服务之外的搜索
系统	185
Hatena Bookmark的全文搜索——满足细节要求的系统	187
第25课 搜索系统的架构	190
搜索系统所需的步骤	190
各种各样的搜索引擎	191
全文搜索的种类	193
第26课 搜索引擎的内部结构	198
逆向索引的结构——Dictionary+Postings	198
Dictionary的创建方法——逆向索引的创建方法 200
小结	210
Postings的创建方法——逆向索引的创建方法 211
关于评分的补充	213
参考文献	214
第10章 创建全文搜索引擎
——基本部分、改进、速度和准确度的要求	216
第27课 ［课题］创建Hatena Bookmark全文搜索	217
开发全文搜索引擎	217
课题内容	217
示例数据格式和数据大小	218
字典的组成——Dictionary、Postings	219
界面	220
基础部分+改进	220
以速度和准确度一决胜负	221
第28课 答案范例和思路	223
解答范例	223
indexer.pl的实现	223
searcher.pl的实现	225
可以改善的地方	227
第11章 支持大规模数据处理的服务器/基础设施入门
—— Web服务的后台	230
第29课 企业软件vs. Web服务	231
企业软件vs. Web服务——应用范围上的差异	231
Web服务的基础设施——三个重点	233
第30课 云vs.自行构建基础设施	235
云计算	235
云的优缺点	235
Hatena应用的云服务	236
自行构筑基础设施的优点	237
自行构建基础设施和垂直结合模型	239
Hatena的服务规模	240
Hatena Bookmark的系统架构图	240
第12章 保证可扩展性的必要思路
——规模扩大和系统扩展	242
第31课 层和可扩展性	243
对可扩展性的要求——一台服务器能处理的流量极限	243
各层的可扩展性	244
第32课 掌握负载进行调优	245
掌握负载——可视化的管理界面	245
测量负载的指标——平均负载、内存和CPU相关信息	247
根据用途进行调优——面向用户的服务器和面向爬虫
的服务器	247
应用程序服务器、数据库服务器的调优策略和服务器
数量	249
服务规模和调优	250
保证可扩展性	251
第13章 保证冗余性和系统的稳定化
——实现100%在线率的原理	252
第33课 保证冗余性	253
保证冗余性——应用程序服务器	253
保证冗余性——数据库服务器	254
保证冗余性——存储服务器	257
第34课 系统稳定化	261
保持系统稳定的权衡	261
系统的不稳定因素	262
第35课 系统稳定对策	267
实际的系统稳定对策——维持适当余量，消灭不稳定
因素	267
第14章 提高效率
——提高硬件资源的使用率	270
第36课 虚拟化技术	271
引入虚拟化技术	271
虚拟化技术的效果	272
虚拟服务器的构建策略	273
总结虚拟化的优势	275
虚拟化和运营——通过服务器管理工具在运营上发挥
虚拟化的优势	276
虚拟化的注意点	277
第37课 硬件和提高效率
——实现低成本的关键技术	280
提高处理器性能	280
内存和硬盘成本下降	281
有效利用廉价硬件——以虚拟化为前提的硬件应用	282
SSD	284
第15章 Web服务和网络
——通过网络看服务增长	288
第38课 网络的分界点	289
服务增长和网络的分界点	289
1Gbps的极限——PC路由器的极限	289
500台主机的极限——子网、ARP表的极限	290
网络架构的层次化	291
全球化	292
第39课 挑战更高的极限	295
超越10Gbps的世界	295
Hatena的基础设施——第11～15章的总结	296
第16章 特别篇 当前构建Web服务需要的实践技术
——应对大规模Web服务须知	298
特别篇第1课 作业队列系统TheSchwartz、Gearman	299
Web服务和请求	299
作业队列系统入门	299
Hatena的作业队列系统	300
通过日志进行分析	302
特别篇第2课 存储方式的选择RDBMS还是
key-value存储	303
如何保存不断增加的数据	303
选择存储系统的前提条件	304
存储系统的种类	305
RDBMS	305
分布式key-value存储	308
分布式文件系统	310
其他存储	312
存储系统的选择策略	314
特别篇第3课 缓存系统——Squid、Varnish	315
Web应用程序负载与代理/缓存系统	315
Squid——基本结构	317
Varnish	321
特别篇第4课 计算集群——Hadoop	323
大量日志数据的并行处理	323
MapReduce计算模型	323
Hadoop	325
索引	327
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大规模Web服务开发技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hadoop权威指南（第2版）
第1章 初识Hadoop
数据！数据！
数据存储与分析
与其他系统相比
关系型数据库管理系统
网格计算
志愿计算
1.3.4 Hadoop 发展简史
Apache Hadoop和Hadoop生态圈
第2章 关于MapReduce
一个气象数据集
数据的格式
使用Unix工具进行数据分析
使用Hadoop分析数据
map阶段和reduce阶段
横向扩展
合并函数
运行一个分布式的MapReduce作业
Hadoop的Streaming
Ruby版本
Python版本
Hadoop Pipes
编译运行
第3章 Hadoop分布式文件系统
HDFS的设计
HDFS的概念
数据块
namenode和datanode
命令行接口
基本文件系统操作
Hadoop文件系统
接口
Java接口
从Hadoop URL中读取数据
通过FileSystem API读取数据
写入数据
目录
查询文件系统
删除数据
数据流
文件读取剖析
文件写入剖析
一致模型
通过 distcp并行拷贝
保持 HDFS 集群的均衡
Hadoop的归档文件
使用Hadoop归档文件
不足
第4章 Hadoop I/O
数据完整性
HDFS的数据完整性
LocalFileSystem
ChecksumFileSystem
压缩
codec
压缩和输入切分
在MapReduce中使用压缩
序列化
Writable接口
Writable类
实现定制的Writable类型
序列化框架
Avro
依据文件的数据结构
写入SequenceFile
MapFile
第5章 MapReduce应用开发
配置API
合并多个源文件
可变的扩展
配置开发环境
配置管理
辅助类GenericOptionsParser，Tool和ToolRunner
编写单元测试
mapper
reducer
本地运行测试数据
在本地作业运行器上运行作业
测试驱动程序
在集群上运行
打包
启动作业
MapReduce的Web界面
获取结果
作业调试
使用远程调试器
作业调优
分析任务
MapReduce的工作流
将问题分解成MapReduce作业
运行独立的作业
第6章 MapReduce的工作机制
剖析MapReduce作业运行机制
作业的提交
作业的初始化
任务的分配
任务的执行
进度和状态的更新
作业的完成
失败
任务失败
tasktracker失败
jobtracker失败
作业的调度
Fair Scheduler
Capacity Scheduler
shuffle和排序
map端
reduce端
配置的调优
任务的执行
推测式执行
重用JVM
跳过坏记录
任务执行环境
第7章 MapReduce的类型与格式
MapReduce的类型
默认的MapReduce作业
输入格式
输入分片与记录
文本输入
二进制输入
多种输入
数据库输入（和输出）
输出格式
文本输出
二进制输出
多个输出
延迟输出
数据库输出
第8章 MapReduce的特性
计数器
内置计数器
用户定义的Java计数器
用户定义的Streaming计数器
排序
准备
部分排序
总排序
二次排序
联接
map端联接
reduce端联接
边数据分布
利用JobConf来配置作业
分布式缓存
MapReduce库类
第9章 构建Hadoop集群
集群规范
网络拓扑
集群的构建和安装
安装Java
创建Hadoop用户
安装Hadoop
测试安装
SSH配置
Hadoop配置
配置管理
环境设置
Hadoop守护进程的关键属性
Hadoop守护进程的地址和端口
Hadoop的其他属性
创建用户帐号
安全性
Kerberos和Hadoop
委托令牌
其他安全性改进
利用基准测试程序测试Hadoop集群
Hadoop基准测试程序
用户的作业
云上的Hadoop
Amazon EC2上的Hadoop
第10章 管理Hadoop
HDFS
永久性数据结构
安全模式
日志审计
工具
监控
日志
度量
Java管理扩展（JMX）
维护
日常管理过程
委任节点和解除节点
升级
第11章 Pig简介
安装与运行Pig
执行类型
运行Pig程序
Grunt
Pig Latin编辑器
示例
生成示例
与数据库比较
PigLatin
结构
语句
表达式
1.4.4 类型
模式
函数
用户自定义函数
过滤UDF
计算UDF
加载UDF
数据处理操作
加载和存储数据
过滤数据
分组与连接数据
对数据进行排序
组合和分割数据
Pig实战
并行处理
参数代换
第12章 Hive
1.1 安装Hive
1.1.1 Hive外壳环境
1.2 示例
1.3 运行Hive
1.3.1 配置Hive
1.3.2 Hive服务
1.3.3 Metastore
1.4  和传统数据库进行比较
1.4.1 读时模式（Schema on Read）vs.写时模式（Schema on Write）
1.4.2 更新、事务和索引
1.5 HiveQL
1.5.1 数据类型
1.5.2 操作和函数
1.6 表
1.6.1 托管表（Managed Tables）和外部表（External Tables）
1.6.2 分区（Partitions）和桶（Buckets）
1.6.3 存储格式
1.6.4 导入数据
1.6.5 表的修改
1.6.6 表的丢弃
1.7 查询数据
1.7.1 排序（Sorting）和聚集（Aggregating）
1.7.2 MapReduce脚本
1.7.3 连接
1.7.4 子查询
1.7.5 视图（view）
1.8 用户定义函数（User-Defined Functions）
1.8.1 编写UDF
1.8.2 编写UDAF
第13章 HBase
2.1 HBasics
2.1.1 背景
2.2 概念
2.2.1 数据模型的“旋风之旅”
2.2.2 实现
2.3 安装
2.3.1 测试驱动
2.4 客户机
2.4.1 Java
2.4.2 Avro，REST，以及Thrift
2.5 示例
2.5.1 模式
2.5.2 加载数据
2.5.3 Web查询
2.6 HBase和RDBMS的比较
2.6.1 成功的服务
2.6.2 HBase
2.6.3 实例：HBase在Streamy.com的使用
2.7 Praxis
2.7.1 版本
2.7.2 HDFS
2.7.3 用户接口（UI）
2.7.4 度量（metrics）
2.7.5 模式设计
2.7.6 计数器
2.7.7 批量加载（bulkloading）
第14章 ZooKeeper
安装和运行ZooKeeper
示例
ZooKeeper中的组成员关系
创建组
加入组
列出组成员
ZooKeeper服务
数据模型
操作
实现
一致性
会话
状态
使用ZooKeeper来构建应用
配置服务
具有可恢复性的ZooKeeper应用
锁服务
生产环境中的ZooKeeper
可恢复性和性能
配置
第15章 开源工具Sqoop
获取Sqoop
一个导入的例子
生成代码
其他序列化系统
深入了解数据库导入
导入控制
导入和一致性
直接模式导入
使用导入的数据
导入的数据与Hive
导入大对象
执行导出
深入了解导出
导出与事务
导出和SequenceFile
第16章 实例分析
Hadoop 在Last.fm的应用
Last.fm：社会音乐史上的革命
Hadoop a Last.fm
用Hadoop产生图表
Track Statistics程序
总结
Hadoop和Hive在Facebook的应用
概要介绍
Hadoop a Facebook
假想的使用情况案例
Hive
问题与未来工作计划
Nutch 搜索引擎
背景介绍
数据结构
Nutch系统利用Hadoop进行数据处理的精选实例
总结
Rackspace的日志处理
简史
选择Hadoop
收集和存储
日志的MapReduce模型
关于Cascading
字段、元组和管道
操作
Tap类，Scheme对象和Flow对象
Cascading实战
灵活性
Hadoop和Cascading在ShareThis的应用
总结
在Apache Hadoop上的TB字节数量级排序
使用Pig和Wukong来探索10亿数量级边的 网络图
测量社区
每个人都在和我说话：Twitter回复关系图
（度）degree
对称链接
社区提取
附录A 安装Apache Hadoop
附录B Cloudera’s Distribution for Hadoop
附录C 准备NCDC天气数据
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hadoop权威指南（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hadoop技术内幕
前　言
第一部分　基础篇
第1章　阅读源代码前的准备/ 2
1.1　准备源代码学习环境/ 2
1.1.1　基础软件下载/ 2
1.1.2　如何准备Windows环境/ 3
1.1.3　如何准备Linux环境/ 6
1.2　获取Hadoop源代码/ 7
1.3　搭建Hadoop源代码阅读环境/ 8
1.3.1　创建Hadoop工程/ 8
1.3.2　Hadoop源代码阅读技巧/ 9
1.4　Hadoop源代码组织结构/ 10
1.5　Hadoop初体验/ 13
1.5.1　启动Hadoop/ 13
1.5.2　Hadoop Shell介绍/ 15
1.5.3　Hadoop Eclipse插件介绍/ 15
1.6　编译及调试Hadoop源代码/ 19
1.6.1　编译Hadoop源代码/ 19
1.6.2　调试Hadoop源代码/ 20
1.7　小结/ 23
第2章　MapReduce设计理念与基本架构/ 24
2.1　Hadoop发展史/ 24
2.1.1　Hadoop产生背景/ 24
2.1.2　Apache Hadoop新版本的特性/ 25
2.1.3　Hadoop版本变迁/ 26
2.2　Hadoop MapReduce设计目标/ 28
2.3　MapReduce编程模型概述/ 29
2.3.1　MapReduce编程模型简介/ 29
2.3.2　MapReduce编程实例/ 31
2.4　Hadoop基本架构/ 32
2.4.1　HDFS架构/ 33
2.4.2　Hadoop MapReduce架构/ 34
2.5　Hadoop MapReduce作业的生命周期/ 36
2.6　小结/ 38
第二部分　MapReduce编程模型篇
第3章　MapReduce编程模型/ 40
3.1　MapReduce编程模型概述/ 40
3.1.1　MapReduce编程接口体系结构/ 40
3.1.2　新旧MapReduce API比较/ 41
3.2　MapReduce API基本概念/ 42
3.2.1　序列化/ 42
3.2.2　Reporter参数/ 43
3.2.3　回调机制/ 43
3.3　Java API解析/ 44
3.3.1　作业配置与提交/ 44
3.3.2　InputFormat接口的设计与实现/ 48
3.3.3　OutputFormat接口的设计与实现/ 53
3.3.4　Mapper与Reducer解析/ 55
3.3.5　Partitioner接口的设计与实现/ 59
3.4　非Java API解析/ 61
3.4.1　Hadoop Streaming的实现原理/ 61
3.4.2　Hadoop Pipes的实现原理/ 64
3.5　Hadoop工作流/ 67
3.5.1　JobControl的实现原理/ 67
3.5.2　ChainMapper/ChainReducer的实现原理/ 69
3.5.3　Hadoop工作流引擎/ 71
3.6　小结/ 73
第三部分　MapReduce核心设计篇
第4章　Hadoop RPC框架解析/ 76
4.1　Hadoop RPC框架概述/ 76
4.2　Java基础知识/ 77
4.2.1　Java反射机制与动态代理/ 78
4.2.2　Java网络编程/ 80
4.2.3　Java NIO/ 82
4.3　Hadoop RPC基本框架分析/ 89
4.3.1　RPC基本概念/ 89
4.3.2　Hadoop RPC基本框架/ 91
4.3.3　集成其他开源RPC框架/ 98
4.4　MapReduce通信协议分析/ 100
4.4.1　MapReduce 通信协议概述/ 100
4.4.2　JobSubmissionProtocol通信协议/ 102
4.4.3　InterTrackerProtocol通信协议/ 102
4.4.4　TaskUmbilicalProtocol通信协议/ 103
4.4.5　其他通信协议/ 104
4.5　小结/ 106
第5章　作业提交与初始化过程分析/ 107
5.1　作业提交与初始化概述/ 107
5.2　作业提交过程详解/ 108
5.2.1　执行Shell命令/ 108
5.2.2　作业文件上传/ 109
5.2.3　产生InputSplit文件/ 111
5.2.4　作业提交到JobTracker/ 113
5.3　作业初始化过程详解/ 115
5.4　Hadoop DistributedCache原理分析/ 117
5.4.1　使用方法介绍/ 118
5.4.2　工作原理分析/ 120
5.5　小结/ 122
第6章　JobTracker内部实现剖析/ 123
6.1　JobTracker概述/ 123
6.2　JobTracker启动过程分析/ 125
6.2.1　JobTracker启动过程概述/ 125
6.2.2　重要对象初始化/ 125
6.2.3　各种线程功能/ 128
6.2.4　作业恢复/ 129
6.3　心跳接收与应答/ 129
6.3.1　更新状态/ 131
6.3.2　下达命令/ 131
6.4　Job和Task运行时信息维护/ 134
6.4.1　作业描述模型/ 134
6.4.2　JobInProgress/ 136
6.4.3　TaskInProgress/ 137
6.4.4　作业和任务状态转换图/ 139
6.5　容错机制/ 141
6.5.1　JobTracker容错/ 141
6.5.2　TaskTracker容错/ 142
6.5.3　Job/Task容错/ 145
6.5.4　Record容错/ 147
6.5.5　磁盘容错/ 151
6.6　任务推测执行原理/ 152
6.6.1　计算模型假设/ 153
6.6.2　1.0.0版本的算法/ 153
6.6.3　0.21.0版本的算法/ 154
6.6.4　2.0版本的算法/ 156
6.7　Hadoop资源管理/ 157
6.7.1　任务调度框架分析/ 159
6.7.2　任务选择策略分析/ 162
6.7.3　FIFO调度器分析/ 164
6.7.4　Hadoop资源管理优化/ 165
6.8　小结/ 168
第7章　TaskTracker内部实现剖析/ 169
7.1　TaskTracker概述/ 169
7.2　TaskTracker启动过程分析/ 170
7.2.1　重要变量初始化/ 171
7.2.2　重要对象初始化/ 171
7.2.3　连接JobTracker/ 172
7.3　心跳机制/ 172
7.3.1　单次心跳发送/ 172
7.3.2　状态发送/ 175
7.3.3　命令执行/ 178
7.4　TaskTracker行为分析/ 179
7.4.1　启动新任务/ 179
7.4.2　提交任务/ 179
7.4.3　杀死任务/ 181
7.4.4　杀死作业/ 182
7.4.5　重新初始化/ 184
7.5　作业目录管理/ 184
7.6　启动新任务/ 186
7.6.1　任务启动过程分析/ 186
7.6.2　资源隔离机制/ 193
7.7　小结/ 195
第8章　Task运行过程分析/ 196
8.1　Task运行过程概述/ 196
8.2　基本数据结构和算法/ 197
8.2.1　IFile存储格式/ 197
8.2.2　排序/ 198
8.2.3　Reporter/ 201
8.3　Map Task内部实现/ 204
8.3.1　Map Task整体流程/ 204
8.3.2　Collect过程分析/ 205
8.3.3　Spill过程分析/ 213
8.3.4　Combine过程分析/ 214
8.4　Reduce Task内部实现/ 214
8.4.1　Reduce Task整体流程/ 215
8.4.2　Shuffle和Merge阶段分析/ 215
8.4.3　Sort和Reduce阶段分析/ 218
8.5　Map/Reduce Task优化/ 219
8.5.1　参数调优/ 219
8.5.2　系统优化/ 220
8.6　小结/ 224
第四部分　MapReduce高级篇
第9章　Hadoop性能调优/ 228
9.1　概述/ 228
9.2　从管理员角度进行调优/ 229
9.2.1　硬件选择/ 229
9.2.2　操作系统参数调优/ 229
9.2.3　JVM参数调优/ 230
9.2.4　Hadoop参数调优/ 230
9.3　从用户角度进行调优/ 235
9.3.1　应用程序编写规范/ 235
9.3.2　作业级别参数调优/ 235
9.3.3　任务级别参数调优/ 239
9.4　小结/ 240
第10章　Hadoop多用户作业调度器/ 241
10.1　多用户调度器产生背景/ 241
10.2　HOD/ 242
10.2.1　Torque资源管理器/ 242
10.2.2　HOD作业调度/ 243
10.3　Hadoop队列管理机制/ 245
10.4　Capacity Scheduler实现/ 246
10.4.1　Capacity Scheduler功能介绍/ 247
10.4.2　Capacity Scheduler实现/ 249
10.4.3　多层队列调度/ 254
10.5　Fair Scheduler实现/ 255
10.5.1　Fair Scheduler功能介绍/ 255
10.5.2　Fair Scheduler实现/ 258
10.5.3　Fair Scheduler与Capacity Scheduler对比/ 263
10.6　其他Hadoop调度器介绍/ 264
10.7　小结/ 265
第11章　Hadoop安全机制/ 266
11.1　Hadoop安全机制概述/ 266
11.1.1　Hadoop面临的安全问题/ 266
11.1.2　Hadoop对安全方面的需求/ 267
11.1.3　Hadoop安全设计基本原则/ 267
11.2　基础知识/ 268
11.2.1　安全认证机制/ 268
11.2.2　Kerberos介绍/ 270
11.3　Hadoop安全机制实现/ 273
11.3.1　RPC/ 273
11.3.2　HDFS/ 276
11.3.3　MapReduce/ 278
11.3.4　上层服务/ 280
11.4　应用场景总结/ 281
11.4.1　文件存取/ 281
11.4.2　作业提交与运行/ 282
11.4.3　上层中间件访问Hadoop/ 282
11.5　小结/ 283
第12章　下一代MapReduce框架/ 284
12.1　第一代MapReduce框架的局限性/ 284
12.2　下一代MapReduce框架概述/ 284
12.2.1　基本设计思想/ 284
12.2.2　资源统一管理平台/ 286
12.3　Apache YARN/ 287
12.3.1　Apache YARN基本框架/ 287
12.3.2　Apache YARN工作流程/ 290
12.3.3　Apache YARN设计细节/ 291
12.3.4　MapReduce与YARN结合/ 294
12.4　Facebook Corona / 298
12.4.1　Facebook Corona基本框架/ 298
12.4.2　Facebook Corona工作流程/ 300
12.4.3　YARN与Corona对比/ 303
12.5　Apache Mesos/ 304
12.5.1　Apache Mesos基本框架/ 304
12.5.2　Apache Mesos资源分配/ 305
12.5.3　MapReduce与Mesos结合/ 307
12.6　小结/ 309
附录A　安装Hadoop过程中可能存在的问题及解决方案/ 310
附录B　Hadoop默认HTTP端口号以及HTTP地址/ 312
参考资料/ 313
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hadoop技术内幕
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>版本控制之道
致谢序言    谁适合阅读本书    内容概述    排版约定    在线资源第1篇 欢迎来到分布式世界  第1章 Git的版本控制之道    1.1 版本库    1.2 版本库中存储什么    1.3 工作目录树    1.4 代码修改与文件同步    1.5 跟踪项目、目录和文件    1.6 使用标签跟踪里程碑    1.7 使用分支来跟踪并行演进    1.8 合并    1.9 锁机制    1.10 下一步  第2章 Git安装与设置    2.1 安装Git    2.2 设置Git    2.3 使用Git图形界面(GUI)    2.4 获取Git内置帮助信息  第3章 创建第一个项目    3.1 创建版本库    3.2 代码修改    3.3 在项目中工作    3.4 理解并使用分支    3.5 处理发布    3.6 克隆远程版本库第2篇 Git日常用法  第4章 添加与提交：Git基础    4.1 添加文件到暂存区    4.2 提交修改    4.3 查看修改内容    4.4 管理文件  第5章 理解和使用分支    5.1 什么叫分支    5.2 创建新分支    5.3 合并分支间的修改    5.4 冲突处理    5.5 删除分支    5.6 分支重命名  第6章 查询Git历史记录    6.1 查看Git日志    6.2 指定查找范围    6.3 查看版本之间的差异    6.4 查明该向谁问责    6.5 跟踪内容    6.6 撤销修改    6.7 重新改写历史记录  第7章 与远程版本库协作    7.1 网络协议    7.2 克隆远程版本库    7.3 版本库同步    7.4 推入改动    7.5 添加新的远程版本库  第8章 管理本地版本库    8.1 使用标签标记里程碑    8.2 发布分支的处理    8.3 标签与分支的有效名称    8.4 记录和跟踪多个项目    8.5 使用Git子模块跟踪外部版本库  第9章 高阶功能    9.1 压缩版本库    9.2 导出版本库    9.3 分支变基    9.4 重现隐藏的历史    9.5 二分查找第3篇 系统管理  第10章 迁移到G.1    10.1 与SVN的通信    10.2 确保git-svn是可用的    10.3 导入Subversion版本库    10.4 与Subversion版本库保持同步更新    10.5 将修改推入SVN    10.6 从CVS导入  第11章 使用Gitosis管理Git服务器    11.1 确定Gitosis所依赖的程序已经安装    11.2 安装Gitosis    11.3 创建管理员SSH证书    11.4 配置Gitosis服务器    11.5 初始化Gitosis    11.6 配置Gitosis    11.7 添加新版本库    11.8 设置公共版本库    11.9 结束语第4篇 附录  附录A Git命令快速参考    A.1 安装和初始化    A.2 日常操作    A.3 分支    A.4 历史    A.5 远程版本库    A.6 连接Git和SVN  附录B 其他资源和工具    B.1 Git附带工具    B.2 第三方工具    B.3 Git版本库托管服务    B.4 在线资源  附录C 参考书目索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>版本控制之道
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算
第1章 绪论  1.1 云计算的概念  1.2 云计算发展现状  1.3 云计算实现机制  1.4 网格计算与云计算  参考文献第2章 Google云计算原理第3章 Google应用程序引擎第4章 亚马逊云计算AWS第5章 微软云计算Windows Azure第6章 开源云计算系统第7章 云计算仿真器CloudSim第8章 云计算理论研究热点第9章 总结与展望附录A 云计算实验——Hadoop安装与使用附录B 云计算实验——HDFS使用附录C 云计算实验——HDFS和MapReduce编程附录D 云计算实验——HBase安装使用附录E 云计算实验——CloudSim编程参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hadoop实战（第2版）
目录
前言
第1章　Hadoop简介/1
1.1　什么是Hadoop/2
1.1.1　Hadoop概述/2
1.1.2　Hadoop的历史/2
1.1.3　Hadoop的功能与作用/2
1.1.4　Hadoop的优势/3
1.1.5　Hadoop应用现状和发展趋势/3
1.2　Hadoop项目及其结构/3
1.3　Hadoop体系结构/6
1.4　Hadoop与分布式开发/7
1.5　Hadoop计算模型—MapReduce/10
1.6　Hadoop数据管理/10
1.6.1　HDFS的数据管理/10
1.6.2　HBase的数据管理/12
1.6.3　Hive的数据管理/13
1.7　Hadoop集群安全策略/15
1.8　本章小结/17
第2章　Hadoop的安装与配置/19
2.1　在Linux上安装与配置Hadoop/20
2.1.1　安装JDK 1.6/20
2.1.2　配置SSH免密码登录/21
2.1.3　安装并运行Hadoop/22
2.2　在Mac OSX上安装与配置Hadoop/24
2.2.1　安装Homebrew/24
2.2.2　使用Homebrew安装Hadoop/25
2.2.3　配置SSH和使用Hadoop/25
2.3　在Windows上安装与配置Hadoop/25
2.3.1　安装JDK 1.6或更高版本/25
2.3.2　安装Cygwin/25
2.3.3　配置环境变量/26
2.3.4　安装sshd服务/26
2.3.5　启动sshd服务/26
2.3.6　配置SSH免密码登录/26
2.3.7　安装并运行Hadoop/26
2.4　安装和配置Hadoop集群/27
2.4.1　网络拓扑/27
2.4.2　定义集群拓扑/27
2.4.3　建立和安装Cluster /28
2.5　日志分析及几个小技巧/34
2.6　本章小结/35
第3章　MapReduce计算模型/36
3.1　为什么要用MapReduce/37
3.2　MapReduce计算模型/38
3.2.1　MapReduce Job/38
3.2.2　Hadoop中的Hello World程序/38
3.2.3　MapReduce的数据流和控制流/46
3.3　MapReduce任务的优化/47
3.4　Hadoop流/49
3.4.1　Hadoop流的工作原理/50
3.4.2　Hadoop流的命令/51
3.4.3　两个例子/52
3.5　Hadoop Pipes/54
3.6　本章小结/56
第4章　开发MapReduce应用程序/57
4.1　系统参数的配置/58
4.2　配置开发环境/60
4.3　编写MapReduce程序/60
4.3.1　Map处理/60
4.3.2　Reduce处理/61
4.4　本地测试/62
4.5　运行MapReduce程序/62
4.5.1　打包/64
4.5.2　在本地模式下运行/64
4.5.3　在集群上运行/64
4.6　网络用户界面/65
4.6.1　JobTracker页面/65
4.6.2　工作页面/65
4.6.3　返回结果/66
4.6.4　任务页面/67
4.6.5　任务细节页面/67
4.7　性能调优/68
4.7.1　输入采用大文件/68
4.7.2　压缩文件/68
4.7.3　过滤数据/69
4.7.4　修改作业属性/71
4.8　MapReduce工作流/72
4.8.1　复杂的Map和Reduce函数/72
4.8.2　MapReduce Job中全局共享数据/74
4.8.3　链接MapReduce Job/75
4.9　本章小结/77
第5章　MapReduce应用案例/79
5.1　单词计数/80
5.1.1　实例描述/80
5.1.2　设计思路/80
5.1.3　程序代码/81
5.1.4　代码解读/82
5.1.5　程序执行/83
5.1.6　代码结果/83
5.1.7　代码数据流/84
5.2　数据去重/85
5.2.1　实例描述/85
5.2.2　设计思路/86
5.2.3　程序代码/86
5.3　排序/87
5.3.1　实例描述/87
5.3.2　设计思路/88
5.3.3　程序代码/89
5.4　单表关联/91
5.4.1　实例描述/91
5.4.2　设计思路/92
5.4.3　程序代码/92
5.5　多表关联/95
5.5.1　实例描述/95
5.5.2　设计思路/96
5.5.3　程序代码/96
5.6　本章小结/98
第6章　MapReduce工作机制/99
6.1　MapReduce作业的执行流程/100
6.1.1　MapReduce任务执行总流程/100
6.1.2　提交作业/101
6.1.3　初始化作业/103
6.1.4　分配任务/104
6.1.5　执行任务/106
6.1.6　更新任务执行进度和状态/107
6.1.7　完成作业/108
6.2　错误处理机制 /108
6.2.1　硬件故障/109
6.2.2　任务失败/109
6.3　作业调度机制/110
6.4　Shuffle和排序/111
6.4.1　Map端/111
6.4.2　Reduce端/113
6.4.3　shuffle过程的优化/114
6.5　任务执行/114
6.5.1　推测式执行/114
6.5.2　任务JVM重用/115
6.5.3　跳过坏记录/115
6.5.4　任务执行环境/116
6.6　本章小结/117
第7章　Hadoop I/O操作/118
7.1　I/O操作中的数据检查/119
7.2　数据的压缩 /126
7.2.1　Hadoop对压缩工具的选择/126
7.2.2　压缩分割和输入分割/127
7.2.3　在MapReduce程序中使用压缩/127
7.3　数据的I/O中序列化操作/128
7.3.1　Writable类/128
7.3.2　实现自己的Hadoop数据类型/137
7.4　针对Mapreduce的文件类/139
7.4.1　SequenceFile类/139
7.4.2　MapFile类/144
7.4.3　ArrayFile、SetFile和BloomMapFile/146
7.5　本章小结/148
第8章　下一代MapReduce：YARN/149
8.1　MapReduce V2设计需求/150
8.2　MapReduce V2主要思想和架构/151
8.3　MapReduce V2设计细节/153
8.4　MapReduce V2优势/156
8.5　本章小结/156
第9章　HDFS详解/157
9.1　Hadoop的文件系统/158
9.2　HDFS简介/160
9.3　HDFS体系结构/161
9.3.1　HDFS的相关概念/161
9.3.2　HDFS的体系结构/162
9.4　HDFS的基本操作/164
9.4.1　HDFS的命令行操作/164
9.4.2　HDFS的Web界面/165
9.5　HDFS常用Java API详解/166
9.5.1　使用Hadoop URL读取数据/166
9.5.2　使用FileSystem API读取数据/167
9.5.3　创建目录/169
9.5.4　写数据/169
9.5.5　删除数据/171
9.5.6　文件系统查询/171
9.6　HDFS中的读写数据流/175
9.6.1　文件的读取/175
9.6.2　文件的写入/176
9.6.3　一致性模型/178
9.7　HDFS命令详解/179
9.7.1　通过distcp进行并行复制/179
9.7.2　HDFS的平衡/180
9.7.3　使用Hadoop归档文件/180
9.7.4　其他命令/183
9.8　WebHDFS/186
9.8.1　WebHDFS的配置/186
9.8.2　WebHDFS命令/186
9.9　本章小结/190
第10章　Hadoop的管理/191
10.1　HDFS文件结构/192
10.2　Hadoop的状态监视和管理工具/196
10.2.1　审计日志/196
10.2.2　监控日志/196
10.2.3　Metrics/197
10.2.4　Java管理扩展 /199
10.2.5　Ganglia/200
10.2.6　Hadoop管理命令/202
10.3　Hadoop集群的维护/206
10.3.1　安全模式/206
10.3.2　Hadoop的备份/207
10.3.3　Hadoop的节点管理/208
10.3.4　系统升级/210
10.4　本章小结/212
第11章　Hive详解/213
11.1　Hive简介/214
11.1.1　Hive的数据存储/214
11.1.2　Hive的元数据存储/216
11.2　Hive的基本操作/216
11.2.1　在集群上安装Hive/216
11.2.2　配置MySQL存储Hive元数据/218
11.2.3　配置Hive/220
11.3　Hive QL详解/221
11.3.1　数据定义（DDL）操作/221
11.3.2　数据操作（DML）/231
11.3.3　SQL操作/233
11.3.4　Hive QL使用实例/235
11.4　Hive网络（Web UI）接口/237
11.4.1　Hive网络接口配置/237
11.4.2　Hive网络接口操作实例/238
11.5　Hive的JDBC接口//241
11.5.1　Eclipse环境配置/241
11.5.2　程序实例/241
11.6　Hive的优化/244
11.7　本章小结/246
第12章　HBase详解/247
12.1　HBase简介/248
12.2　HBase的基本操作/249
12.2.1　HBase的安装/249
12.2.2　运行HBase /253
12.2.3　HBase Shell/255
12.2.4　HBase配置/258
12.3　HBase体系结构/260
12.3.1　HRegion/260
12.3.2　HRegion服务器/261
12.3.3　HBase Master服务器/262
12.3.4　ROOT表和META表/262
12.3.5　ZooKeeper/263
12.4　HBase数据模型/263
12.4.1　数据模型/263
12.4.2　概念视图/264
12.4.3　物理视图/264
12.5　HBase与RDBMS/265
12.6　HBase与HDFS/266
12.7　HBase客户端/266
12.8　Java API /267
12.9　HBase编程 /273
12.9.1　使用Eclipse开发HBase应用程序/273
12.9.2　HBase编程/275
12.9.3　HBase与MapReduce/278
12.10　模式设计/280
12.10.1　模式设计应遵循的原则/280
12.10.2　学生表/281
12.10.3　事件表/282
12.11　本章小结/283
第13章　Mahout详解/284
13.1　Mahout简介/285
13.2　Mahout的安装和配置/285
13.3　Mahout API简介/288
13.4　Mahout中的频繁模式挖掘/290
13.4.1　什么是频繁模式挖掘/290
13.4.2　Mahout中的频繁模式挖掘/290
13.5　Mahout中的聚类和分类/292
13.5.1　什么是聚类和分类/292
13.5.2　Mahout中的数据表示/293
13.5.3　将文本转化成向量/294
13.5.4　Mahout中的聚类、分类算法/295
13.5.5　算法应用实例/299
13.6　Mahout应用：建立一个推荐引擎/304
13.6.1　推荐引擎简介/304
13.6.2　使用Taste构建一个简单的推荐引擎/305
13.6.3　简单分布式系统下基于产品的推荐系统简介/307
13.7　本章小结/309
第14章　Pig详解/310
14.1　Pig简介/311
14.2　Pig的安装和配置 /311
14.2.1　Pig的安装条件/311
14.2.2　Pig的下载、安装和配置/312
14.2.3　Pig运行模式/313
14.3　Pig Latin语言/315
14.3.1　Pig Latin语言简介/315
14.3.2　Pig Latin的使用/316
14.3.3　Pig Latin的数据类型/318
14.3.4　Pig Latin关键字/319
14.4　用户定义函数 /323
14.4.1　编写用户定义函数/324
14.4.2　使用用户定义函数/325
14.5　Zebra简介 /326
14.5.1　Zebra的安装/326
14.5.2　Zebra的使用简介/327
14.6　Pig实例 /328
14.6.1　Local模式/328
14.6.2　MapReduce模式/330
14.7　Pig进阶/331
14.7.1　数据实例/331
14.7.2　Pig数据分析/332
14.8　本章小结/336
第15章　ZooKeeper详解/337
15.1　ZooKeeper简介/338
15.1.1　ZooKeeper的设计目标/338
15.1.2　数据模型和层次命名空间/339
15.1.3　ZooKeeper中的节点和临时节点/339
15.1.4　ZooKeeper的应用/340
15.2　ZooKeeper的安装和配置/340
15.2.1　安装ZooKeeper /340
15.2.2　配置ZooKeeper/346
15.2.3　运行ZooKeeper/348
15.3　ZooKeeper的简单操作/350
15.3.1　使用ZooKeeper命令的简单操作步骤/350
15.3.2　ZooKeeper API的简单使用/352
15.4　ZooKeeper的特性/355
15.4.1　ZooKeeper的数据模型/355
15.4.2　ZooKeeper会话及状态/356
15.4.3　ZooKeeper watches/357
15.4.4　ZooKeeper ACL/358
15.4.5　ZooKeeper的一致性保证/359
15.5　使用ZooKeeper进行Leader选举/359
15.6　ZooKeeper锁服务/360
15.6.1　ZooKeeper中的锁机制/360
15.6.2　ZooKeeper提供的一个写锁的实现/361
15.7　使用ZooKeeper创建应用程序 /363
15.7.1　使用Eclipse开发ZooKeeper应用程序/363
15.7.2　应用程序实例/365
15.8　BooKeeper/369
15.9　本章小结/371
第16章　Avro详解/372
16.1　Avro介绍/373
16.1.1　模式声明/374
16.1.2　数据序列化/378
16.1.3　数据排列顺序/380
16.1.4　对象容器文件 /381
16.1.5　协议声明/382
16.1.6　协议传输格式/383
16.1.7　模式解析/386
16.2　Avro的C/C++实现/387
16.3　Avro的Java实现/398
16.4　GenAvro（Avro IDL）语言/402
16.5　Avro SASL概述/406
16.6　本章小结/407
第17章　Chukwa详解/409
17.1　Chukwa简介/410
17.2　Chukwa架构/411
17.2.1　客户端及其数据模型/412
17.2.2　收集器/413
17.2.3　归档器和分离解析器/414
17.2.4　HICC/415
17.3　Chukwa的可靠性/415
17.4　Chukwa集群搭建/416
17.4.1　基本配置要求/416
17.4.2　Chukwa的安装/416
17.4.3　Chukwa的运行/419
17.5　Chukwa数据流的处理/424
17.6　Chukwa与其他监控系统比较/425
17.7　本章小结/426
本章参考资料/426
第18章　Hadoop的常用插件与开发/428
18.1　Hadoop Studio的介绍和使用/429
18.1.1　Hadoop Studio的介绍/429
18.1.2　Hadoop Studio的安装配置/430
18.1.3　Hadoop Studio的使用举例/430
18.2　Hadoop Eclipse的介绍和使用/436
18.2.1　Hadoop Eclipse的介绍/436
18.2.2　Hadoop Eclipse的安装配置/437
18.2.3　Hadoop Eclipse的使用举例/438
18.3　Hadoop Streaming的介绍和使用/440
18.3.1　Hadoop Streaming的介绍/440
18.3.2　Hadoop Streaming的使用举例/444
18.3.3　使用Hadoop Streaming常见的问题/446
18.4　Hadoop Libhdfs的介绍和使用/448
18.4.1　Hadoop Libhdfs的介绍/448
18.4.2　Hadoop Libhdfs的安装配置/448
18.4.3　Hadoop Libhdfs API简介/448
18.4.4　Hadoop Libhdfs的使用举例/449
18.5　本章小结/450
第19章　企业应用实例/452
19.1　Hadoop在Yahoo!的应用/453
19.2　Hadoop在eBay的应用/455
19.3　Hadoop在百度的应用/457
19.4　即刻搜索中的Hadoop/460
19.4.1　即刻搜索简介/460
19.4.2　即刻Hadoop应用架构/460
19.4.3　即刻Hadoop应用分析/463
19.5　Facebook中的Hadoop和HBase/463
19.5.1　Facebook中的任务特点/464
19.5.2　MySQL VS Hadoop+HBase/466
19.5.3　Hadoop和HBase的实现/467
19.6　本章小结/472
本章参考资料/472
附录A　云计算在线检测平台/474
附录B　Hadoop安装、运行与使用说明/484
附录C　使用DistributedCache的MapReduce程序/491
附录D　使用ChainMapper和ChainReducer的MapReduce程序/495
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hadoop实战（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hadoop技术内幕
前　言
第一部分　准备篇
第1章　环境准备 2
1.1　准备学习环境 2
1.1.1　基础软件下载 2
1.1.2　如何准备Linux环境 3
1.2　获取Hadoop源代码 5
1.3　搭建Hadoop源代码阅读环境 5
1.3.1　创建Hadoop工程 5
1.3.2　Hadoop源代码阅读技巧 8
1.4　Hadoop源代码组织结构 10
1.5　Hadoop初体验 12
1.5.1　搭建Hadoop环境 12
1.5.2　Hadoop Shell介绍 15
1.6　编译及调试Hadoop源代码 16
1.6.1　编译Hadoop源代码 17
1.6.2　调试Hadoop源代码 18
1.7　小结 20
第2章　YARN设计理念与基本架构 21
2.1　YARN产生背景 21
2.1.1　MRv1的局限性 21
2.1.2　轻量级弹性计算平台 22
2.2　Hadoop基础知识 23
2.2.1　术语解释 23
2.2.2　Hadoop版本变迁 25
2.3　YARN基本设计思想 29
2.3.1　基本框架对比 29
2.3.2　编程模型对比 30
2.4　YARN 基本架构 31
2.4.1　YARN基本组成结构 32
2.4.2　YARN通信协议 34
2.5　YARN工作流程 35
2.6　多角度理解YARN 36
2.6.1　并行编程 36
2.6.2　资源管理系统 36
2.6.3　云计算 37
2.7　本书涉及内容 38
2.8　小结 38
第二部分　YARN核心设计篇
第3章　YARN基础库 40
3.1　概述 40
3.2　第三方开源库 41
3.2.1　Protocol Buffers 41
3.2.2　Apache Avro 43
3.3　底层通信库 46
3.3.1　RPC通信模型 46
3.3.2　Hadoop RPC的特点概述 48
3.3.3　RPC总体架构 48
3.3.4　Hadoop RPC使用方法 49
3.3.5　Hadoop RPC类详解 51
3.3.6　Hadoop RPC参数调优 57
3.3.7　YARN RPC实现 57
3.3.8　YARN RPC应用实例 61
3.4　服务库与事件库 65
3.4.1　服务库 66
3.4.2　事件库 66
3.4.3　YARN服务库和事件库的使用方法 68
3.4.4　事件驱动带来的变化 70
3.5　状态机库 72
3.5.1　YARN状态转换方式 72
3.5.2　状态机类 73
3.5.3　状态机的使用方法 73
3.5.4　状态机可视化 76
3.6　源代码阅读引导 76
3.7　小结 77
3.8　问题讨论 77
第4章　YARN应用程序设计方法 78
4.1　概述 78
4.2　客户端设计 79
4.2.1　客户端编写流程 80
4.2.2　客户端编程库 84
4.3　ApplicationMaster设计 84
4.3.1　ApplicationMaster编写流程 84
4.3.2　ApplicationMaster编程库 92
4.4　YARN 应用程序实例 95
4.4.1　DistributedShell 95
4.4.2　Unmanaged AM 99
4.5　源代码阅读引导 100
4.6　小结 100
4.7　问题讨论 100
第5章　ResourceManager剖析 102
5.1　概述 102
5.1.1　ResourceManager基本职能 102
5.1.2　ResourceManager内部架构 103
5.1.3　ResourceManager事件与事件处理器 106
5.2　用户交互模块 108
5.2.1　ClientRMService 108
5.2.2　AdminService 109
5.3　ApplicationMaster管理 109
5.4　NodeManager管理 112
5.5　Application管理 113
5.6　状态机管理 114
5.6.1　RMApp状态机 115
5.6.2　RMAppAttempt状态机 119
5.6.3　RMContainer状态机 123
5.6.4　RMNode状态机 127
5.7　几个常见行为分析 129
5.7.1　启动ApplicationMaster  129
5.7.2　申请与分配Container 132
5.7.3　杀死Application 134
5.7.4　Container超时 135
5.7.5　ApplicationMaster超时 138
5.7.6　NodeManager超时 138
5.8　安全管理 139
5.8.1　术语介绍 139
5.8.2　Hadoop认证机制 139
5.8.3　Hadoop授权机制 142
5.9　容错机制 144
5.9.1　Hadoop HA基本框架 145
5.9.2　YARN HA实现  148
5.10　源代码阅读引导 149
5.11　小结 151
5.12　问题讨论 152
第6章　资源调度器 153
6.1　资源调度器背景 153
6.2　HOD调度器 154
6.2.1　Torque资源管理器 154
6.2.2　HOD作业调度 155
6.3　YARN资源调度器的基本架构 157
6.3.1　基本架构 157
6.3.2　资源表示模型 160
6.3.3　资源调度模型 161
6.3.4　资源抢占模型 164
6.4　YARN层级队列管理机制 169
6.4.1　层级队列管理机制 169
6.4.2　队列命名规则 171
6.5　Capacity Scheduler 172
6.5.1　Capacity Scheduler的功能 172
6.5.2　Capacity Scheduler实现 176
6.6　Fair Scheduler 179
6.6.1　Fair Scheduler功能介绍 180
6.6.2　Fair Scheduler实现 182
6.6.3　Fair Scheduler与Capacity Scheduler对比 183
6.7　其他资源调度器介绍 184
6.8　源代码阅读引导 185
6.9　小结 186
6.10　问题讨论 187
第7章　NodeManager剖析 188
7.1　概述 188
7.1.1　NodeManager基本职能 188
7.1.2　NodeManager内部架构 190
7.1.3　NodeManager事件与事件处理器 193
7.2　节点健康状况检测 194
7.2.1　自定义Shell脚本 194
7.2.2　检测磁盘损坏数目 196
7.3　分布式缓存机制 196
7.3.1　资源可见性与分类 198
7.3.2　分布式缓存实现 200
7.4　目录结构管理 203
7.4.1　数据目录管理 203
7.4.2　日志目录管理 203
7.5　状态机管理 206
7.5.1　Application状态机 207
7.5.2　Container状态机 210
7.5.3　LocalizedResource状态机 213
7.6　Container生命周期剖析 214
7.6.1　Container资源本地化 214
7.6.2　Container运行 218
7.6.3　Container资源清理 222
7.7　资源隔离 224
7.7.1　Cgroups介绍 224
7.7.2　内存资源隔离 228
7.7.3　CPU资源隔离 230
7.8　源代码阅读引导 234
7.9　小结 235
7.10　问题讨论 236
第三部分　计算框架篇
第8章　离线计算框架MapReduce 238
8.1　概述 238
8.1.1　基本构成 238
8.1.2　事件与事件处理器 240
8.2　MapReduce客户端 241
8.2.1　ApplicationClientProtocol协议 242
8.2.2　MRClientProtocol协议 243
8.3　MRAppMaster工作流程 243
8.4　MR作业生命周期及相关状态机 246
8.4.1　MR作业生命周期 246
8.4.2　Job状态机 249
8.4.3　Task状态机 253
8.4.4　TaskAttempt状态机 255
8.5　资源申请与再分配 259
8.5.1　资源申请 259
8.5.2　资源再分配 262
8.6　Container启动与释放 263
8.7　推测执行机制 264
8.7.1　算法介绍 265
8.7.2　推测执行相关类 266
8.8　作业恢复 267
8.9　数据处理引擎 269
8.10　历史作业管理器 271
8.11　MRv1与MRv2对比 273
8.11.1　MRv1 On YARN 273
8.11.2　MRv1与MRv2架构比较 274
8.11.3　MRv1与MRv2编程接口兼容性 274
8.12　源代码阅读引导 275
8.13　小结 277
8.14　问题讨论 277
第9章　DAG计算框架Tez 278
9.1　背景 278
9.2　Tez数据处理引擎 281
9.2.1　Tez编程模型 281
9.2.2　Tez数据处理引擎 282
9.3　DAG Master实现 284
9.3.1　DAG编程模型 284
9.3.2　MR到DAG转换 286
9.3.3　DAGAppMaster 288
9.4　优化机制 291
9.4.1　当前YARN框架存在的问题 291
9.4.2　Tez引入的优化技术 292
9.5　Tez应用场景 292
9.6　与其他系统比较 294
9.7　小结 295
第10章　实时/内存计算框架Storm/Spark 296
10.1　Hadoop MapReduce的短板 296
10.2　实时计算框架Storm  296
10.2.1　Storm编程模型 297
10.2.2　Storm基本架构 302
10.2.3　Storm On YARN 304
10.3　内存计算框架Spark 307
10.3.1　Spark编程模型 308
10.3.2　Spark基本架构 312
10.3.3　Spark On YARN 316
10.3.4　Spark/Storm On YARN比较 317
10.4　小结 317
第四部分　高级篇
第11章　Facebook Corona剖析 320
11.1　概述 320
11.1.1　Corona的基本架构 320
11.1.2　Corona的RPC协议与序列化框架 322
11.2　Corona设计特点 323
11.2.1　推式网络通信模型 323
11.2.2　基于Hadoop 0.20版本 324
11.2.3　使用Thrift 324
11.2.4　深度集成Fair Scheduler 324
11.3　工作流程介绍 324
11.3.1　作业提交 325
11.3.2　资源申请与任务启动 326
11.4　主要模块介绍 327
11.4.1　ClusterManager 327
11.4.2　CoronaJobTracker 330
11.4.3　CoronaTaskTracker 333
11.5　小结 335
第12章　Apache Mesos剖析 336
12.1　概述 336
12.2　底层网络通信库 337
12.2.1　libprocess基本架构 338
12.2.2　一个简单示例 338
12.3　Mesos服务 340
12.3.1　SchedulerProcess 341
12.3.2　Mesos Master  342
12.3.3　Mesos Slave  343
12.3.4　ExecutorProcess 343
12.4　Mesos工作流程 344
12.4.1　框架注册过程 344
12.4.2　Framework Executor注册过程 345
12.4.3　资源分配到任务运行过程 345
12.4.4　任务启动过程 347
12.4.5　任务状态更新过程 347
12.5　Mesos资源分配策略 348
12.5.1　Mesos资源分配框架 349
12.5.2　Mesos资源分配算法 349
12.6　Mesos容错机制 350
12.6.1　Mesos Master容错 350
12.6.2　Mesos Slave容错 351
12.7　Mesos应用实例 352
12.7.1　Hadoop On Mesos 352
12.7.2　Storm On Mesos 353
12.8　Mesos与YARN对比 354
12.9　小结 355
第13章　YARN总结与发展趋势 356
13.1　资源管理系统设计动机 356
13.2　资源管理系统架构演化 357
13.2.1　集中式架构 357
13.2.2　双层调度架构 358
13.2.3　共享状态架构 358
13.3　YARN发展趋势  359
13.3.1　YARN自身的完善 359
13.3.2　以YARN为核心的生态系统 361
13.3.3　YARN周边工具的完善 363
13.4　小结 363
附录A　YARN安装指南 364
附录B　YARN配置参数介绍 367
附录C　Hadoop Shell命令介绍 371
附录D　参考资料 374
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hadoop技术内幕
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hadoop实战
前言
第1章 Hadoop简介
第2章 Hadoop的安装与配置
第3章 Hadoop应用案例分析
第4章 MapReduce计算模型
第5章 开发MapReduce应用程序
第6章 MapReduce应用案例
第7章 MapReduce工作机制
第8章 HadoopI/O
第9章 HDFS详解
第10章 Hadoop的管理
第11章 Hive详解
第12章 HBase详解
第13章 Mahout详解
第14章 Pig详解
第15章 ZooKeepet详解
第16章 Avro详解
第17章 Chukwa详解
第18章 Hadoop的常用插件与开发
附录A 云计算在线检测平台
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hadoop实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构与实践
第1部分 基础篇
第1章 单块架构及其面临的挑战  3
1.1 三层应用架构  4
1.1.1 三层应用架构的发展  4
1.1.2 什么是三层架构  5
1.1.3 三层架构的优势  6
1.2 单块架构  6
1.2.1 什么是单块架构  6
1.2.2 单块架构的优势  7
1.2.3 单块架构面临的挑战  8
1.3 小结  12
第2章 微服务架构综述  13
2.1 什么是微服务架构  13
2.1.1 多微才够微  14
2.1.2 单一职责  17
2.1.3 轻量级通信  17
2.1.4 独立性  19
2.1.5 进程隔离  20
2.2 微服务的诞生背景  22
2.2.1 互联网行业的快速发展  23
2.2.2 敏捷、精益方法论的深入人心 23
2.2.3 单块架构系统面临的挑战  23
2.2.4 容器虚拟化技术  23
2.3 微服务架构与 SOA  24
2.3.1 SOA概述  24
2.3.2 微服务与 SOA  25
2.4 微服务的本质  26
2.4.1 服务作为组件  27
2.4.2 围绕业务组织团队  28
2.4.3 关注产品而非项目  29
2.4.4 技术多样性  31
2.4.5 业务数据独立  32
2.4.6 基础设施自动化  33
2.4.7 演进式架构  33
2.5 微服务不是银弹  34
2.5.1 分布式系统的复杂度  35
2.5.2 运维成本  36
2.5.3 部署自动化  36
2.5.4 DevOps与组织架构  37
2.5.5 服务间的依赖测试  37
2.5.6 服务间的依赖管理  37
2.6 小结  38
第2部分 实践篇
第3章 构建第一个服务  41
3.1 场景分析  41
3.2 任务拆分  43
第4章 Hello World API  45
4.1 API实现  45
4.1.1 开发语言 ——Ruby  45
4.1.2 Web框架——Grape  46
4.1.3 API的具体实现  47
4.2 代码测试与静态检查  50
4.2.1 代码测试  50
4.2.2 测试覆盖率统计  53
4.2.3 静态检查  54
4.2.4 代码复杂度检查  57
第5章 构建 Docker映像  61
5.1 定义 Dockerfile  61
5.2 配置 Docker主机  63
5.3 构建 Docker映像  64
5.4 运行 Docker容器  64
5.5 发布 Docker映像  65
5.6 小结  69
第6章 部署 Docker映像  71
6.1基础设施 AWS  71
6.2基础设施自动化  73
6.3 部署 Docker映像  80
6.4自动化部署  81
6.5 小结  84
第7章 持续交付流水线  85
7.1 持续集成环境  85
7.2 提交阶段  87
7.3 验证阶段  91
7.4 构建阶段  91
7.5 发布阶段  94
7.6 小结  96
第8章 日志聚合  97
8.1 日志聚合工具简介  97
8.2 Splunk的核心  99
8.3 安装 Splunk索引器  100
8.4 安装 Splunk转发器  101
8.5 日志查找  102
8.6 告警设置  103
8.7 小结  104
第9章 监控与告警  105
9.1 Nagios简介  105
9.2 Nagios的工作原理  107
9.3 Nagios安装  108
9.4 Nagios的配置  109
9.5 监控 products-service  111
9.6 告警  113
9.7 小结  114
第10章 功能迭代  115
10.1 定义模型  116
10.2 持久化模型  117
10.3 定义表现形式  119
10.4 实现 API  122
10.5 服务描述文件  125
10.6 小结  127
第3部分 进阶篇
第11章 微服务与持续交付  131
11.1 持续交付的核心  132
11.2 微服务架构与持续交付  133
11.2.1 开发  133
11.2.2 测试  137
11.2.3 持续集成  139
11.2.4 构建  139
11.2.5 部署  140
11.2.6 运维  143
11.3 小结  144
第12章 微服务与轻量级通信机制  145
12.1 同步通信与异步通信  145
12.1.1 概述  145
12.1.2 同步通信与异步通信的选择 146
12.2 远程调用 RPC  147
12.2.1 远程过程调用的核心  147
12.2.2 远程方法调用  148
12.2.3 远程过程调用的弊端  148
12.3 REST  149
12.3.1 概述  149
12.3.2 REST的核心  150
12.3.3 REST的优势  152
12.3.4 REST的不足  152
12.3.5 本节小结  155
12.4 HAL  155
12.4.1 概述  155
12.4.2 HAL的核心  156
12.4.3 HAL浏览器  160
12.5 消息队列  161
12.5.1 核心部分  162
12.5.2 访问方式  163
12.5.3 消息队列的优缺点  164
12.6 后台任务处理系统  165
12.6.1 核心部分  165
12.6.2 服务回调  166
12.6.3 一个例子  167
12.6.4 后台任务与微服务  169
12.7 小结  170
第13章 微服务与测试  171
13.1 微服务的结构  171
13.2 微服务的测试策略  173
13.3 微服务的单元测试  175
13.3.1 单元测试综述  175
13.3.2 单元测试的内容  176
13.4 微服务的集成测试  179
13.4.1 集成测试综述  179
13.4.2 集成测试的实施方法  179
13.4.3 集成测试的内容  180
13.5 基于消费者驱动的契约测试  181
13.5.1 集成测试存在的弊端  181
13.5.2 什么是契约  183
13.5.3 什么是契约测试  184
13.5.4 契约测试的方法  185
13.5.5 Pact实现契约测试  187
13.5.6 一个例子  192
13.5.7 本节小结  205
13.6 微服务的组件测试  205
13.6.1 组件测试概述  205
13.6.2 组件测试的方法  206
13.6.3 本节小结  207
13.7 微服务的端到端测试  208
13.7.1 端到端测试概述  208
13.7.2 端到端测试的内容  208
13.7.3 本节小结  209
13.8 小结  210
第14章 使用微服务架构改造遗留系统  211
14.1 背景与挑战  211
14.2 改造策略  212
14.2.1 昀小修改  212
14.2.2 功能剥离  212
14.2.3 数据解耦  213
14.2.4 数据同步  213
14.2.5 迭代替换  214
14.3 快速开发实践  215
14.3.1 快速开发模板  215
14.3.2 代码生成工具  217
14.3.3 持续集成模板  217
14.3.4 一键部署工具  217
14.4 微服务架构下的新系统  218
14.5 小结  220
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Cassandra权威指南
译者序　　XIII
序　　XV
前言　　XVII
第1 章　Cassandra 概况 　　1
1.1　关系型数据库有什么问题　　1
1.2　关系型数据库简单回顾　　5
1.2.1　RDBMS：出类拔萃与表现平平　　6
1.2.2　互联网的规模　　12
1.3　Cassandra 的电梯间演讲　　13
1.3.1　50 个字介绍Cassandra　　　13
1.3.2　分布式与无中心　　　13
1.3.3　弹性可扩展 　　14
1.3.4　高可用与容错　　15
1.3.5　可调节的一致性　　15
1.3.6　Brewer 的CAP 理论　　18
1.3.7　面向行 　　21
1.3.8　无schema 　　22
1.3.9　高性能 　　22
1.4　Cassandra 来自何方　　22
1.5　Cassandra 的应用场景　　23
1.5.1　大规模部署 　　23
1.5.2　写密集、统计和分析型工作　　24
1.5.3　地区分布 　　24
1.5.4　变化的应用 　　24
1.6　谁在使用Cassandra　　24
1.7　小结　　26
第2 章　安装Cassandra　　27
2.1　安装二进制包 　27
2.1.1　解压缩 　　27
2.1.2　里面有什么 　27
2.2　从源码编译　　28
2.2.1　其他编译目标　　30
2.2.2　使用Maven编译　　30
2.3　运行Cassandra 　　30
2.3.1　在Windows平台上运行Cassandra　　　31
2.3.2　在Linux下运行Cassandra　　　31
2.3.3　启动服务器 　　32
2.4　使用命令行界面的客户端　　　33
2.5　基本命令行命令 　　34
2.5.1　帮助　　34
2.5.2　连接服务器 　　35
2.5.3　描述环境 　　35
2.5.4　创建keyspace和列族　　36
2.5.5　读写数据 　　37
2.6　小结　　38
第3章　Cassandra的数据模型　　39
3.1　关系型数据模型 　　39
3.2　简介　　40
3.3　集群　　43
3.4　keyspace　　43
3.5　列族　　44
3.6　列　　46
3.6.1　宽行与窄行 　　48
3.6.2　列的排序 　49
3.7　超级列　　50
3.8　Cassandra与RDBMS的设计差别　　53
3.8.1　没有查询语言　　53
3.8.2　没有引用完整性　　53
3.8.3　第二索引 　53
3.8.4　排序成为一种设计决策　　54
3.8.5　反范式化 　　54
3.9　设计模式　　55
3.9.1　具体化视图 　　56
3.9.2　无值列 　　56
3.9.3　聚合键 　　56
3.10　需要记住的几件事　　57
3.11　小结　　57
第4章　应用实例　　59
4.1　数据模型设计 　　59
4.2　酒店应用的关系型数据库设计　　60
4.3　酒店应用的Cassandra设计　　61
4.4　酒店应用代码 　　62
4.4.1　创建数据库 　　63
4.4.2　数据结构 　64
4.4.3　进行连接 　65
4.4.4　预装填数据库　　66
4.4.5　搜索应用 　　78
4.5　Twissandra　　82
4.6　小结　　82
第5章　Cassandra的架构　　83
5.1　system keyspace 　　83
5.2　对等结构　　　　84
5.3　gossip与故障检测 　　84
5.4　逆熵与读修复 　　86
5.5　memtable、SSTable和commit log　　　87
5.6　提示移交　　　89
5.7　压紧　　89
5.8　Bloom filter　　91
5.9　墓碑　　　91
5.10　分阶段事件驱动架构　　92
5.11　管理器与服务 　　93
5.11.1　Cassandra守护进程　　93
5.11.2　存储服务 　　93
5.11.3　消息服务 　　93
5.11.4　提示移交管理器　　94
5.12　小结　　94
第6章　配置Cassandra　　95
6.1　keyspace　　　95
6.1.1　创建列族 　　98
6.1.2　从0.6迁移到0.7　　99
6.2　副本　　99
6.3　副本放置策略 　　100
6.3.1　简单策略 　　101
6.3.2　旧网络拓扑策略　　102
6.3.3　网络拓扑策略　　103
6.4　副本因子　　103
6.5　分区器　　105
6.5.1　随机分区器　　106
6.5.2　有序分区器　　106
6.5.3　配页有序分区器　　107
6.5.4　字节序分区器　　107
6.6　Snitch　　107
6.6.1　Simple Snitch　　107
6.6.2　PropertyFileSnitch　　　107
6.7　创建集群　　108
6.7.1　修改集群名称　　109
6.7.2　给集群增加节点　　109
6.7.3　多种子节点　　111
6.8　动态加入环 　　113
6.9　安全　　　114
6.9.1　使用SimpleAuthenticator　　114
6.9.2　编程鉴权 　　117
6.9.3　使用MD5加密　　118
6.9.4　提供你自己的鉴权算法　　118
6.10　杂项设置　　119
6.11　附加工具　　120
6.11.1　查看键值　　120
6.11.2　导入之前版本的配置　　120
6.12　小结　　122
第7章　读写数据 　　123
7.1　Cassandra与RDBMS查询的不同　　123
7.1.1　没有Update查询　　123
7.1.2　记录级的写原子性　　123
7.1.3　不支持服务端事务　　123
7.1.4　没有重复键值　　124
7.2　写操作的基本属性　　124
7.3　一致性级别 　　124
7.4　读操作的基本属性　　126
7.5　API　　126
7.6　设置与插入数据 　　128
7.7　使用简单的get 　　133
7.8　数据准备　　135
7.9　切片谓词　　135
7.9.1　使用get_slice读取特定列名　　136
7.9.2　通过切片区间获取一组列　　137
7.9.3　取出一行中的所有列　　138
7.10　get_range_slices 　　138
7.11　multiget_slice 　　140
7.12　删除　　142
7.13　批量变更　　144
7.13.1　批量删除　　144
7.13.2　区间鬼影　　145
7.14　编程定义keyspace和列族　　145
7.15　小结　　146
第8章　客户端　　147
8.1　基本的客户端API　　148
8.2　Thrift　　148
8.2.1　Thrift对Java的支持　　151
8.2.2　异常 　　151
8.2.3　Thrift小结 　　152
8.3　Avro　　152
8.3.1　Avro Ant目标　　154
8.3.2　Avro规范　　155
8.3.3　Avro小结　　156
8.4　Git简介　　156
8.5　连接客户端节点 　157
8.5.1　客户端列表　　157
8.5.2　循环DNS 　　157
8.5.3　负载均衡器　　157
8.6　Cassandra Web控制台　　157
8.7　Hector（Java） 　　161
8.7.1　特性 　　161
8.7.2　Hector API 　　162
8.8　HectorSharp（C#） 　　162
8.9　Chirper　　　　167
8.10　Chiton（Python） 　　167
8.11　Pelops（Java） 　　168
8.12　Kundera（Java ORM）　　　169
8.13　Fauna（Ruby） 　　　169
8.14　小结　　　170
第9章　监控　　　171
9.1　日志　　171
9.1.1　跟踪查看 　　173
9.1.2　通用技巧 　　174
9.2　JMX与MBean概述　　175
9.2.1　MBean 　　177
9.2.2　集成JMX 　　179
9.3　通过JMX与Cassandra交互　　180
9.4　Cassandra的MBean　　181
9.4.1　org.apache.cassandra.concurrent　　185
9.4.2　org.apache.cassandra.db　　185
9.4.3　org.apache.cassandra.gms　　186
9.4.4　org.apache.cassandra.service　　186
9.5　定制Cassandra的MBean　　188
9.6　运行时分析工具 　　190
9.6.1　使用JMX和JHAT进行堆分析　　191
9.6.2　发现线程问题　　194
9.7　健康检查　　195
9.8　小结　　196
第10章　维护　　197
10.1　获取环的信息 　　198
10.1.1　Info 　　198
10.1.2　Ring 　　198
10.2　获取统计信息 　　199
10.2.1　使用cfstats　　199
10.2.2　使用tpstats　　200
10.3　基本维护工作 　　201
10.3.1　修复 　　201
10.3.2　刷写 　　202
10.3.3　清理 　　203
10.4　快照　　203
10.4.1　进行快照　　203
10.4.2　清除快照　　204
10.5　对集群进行负载均衡　　205
10.6　退服节点　　208
10.7　更新节点　　210
10.7.1　删除令牌　　210
10.7.2　压紧阈值　　210
10.7.3　在一个工作的集群中改变列族　　210
10.8　小结　　211
第11章　性能调优 　　213
11.1　数据存储　　213
11.2　回复超时　　215
11.3　commit log 　　215
11.4　memtable　　216
11.5　并发　　216
11.6　缓存　　217
11.7　缓冲区尺寸 　　218
11.8　使用Python压力测试　　218
11.8.1　生成Python Thrift接口　　　218
11.8.2　运行Python压力测试　　　220
11.9　启动和JVM设置　　222
11.10　小结　　　224
第12章　集成Hadoop　　225
12.1　何为Hadoop 　　225
12.2　使用MapReduce 　　226
12.3　运行字数统计例子　　227
12.3.1　将数据输出到Cassandra　　229
12.3.2　Hadoop流　　　229
12.4　MapReduce之上的工具　　229
12.4.1　Pig 　　230
12.4.2　Hive 　　231
12.5　集群配置　　231
12.6　案例　　233
12.6.1　Raptr.com: Keith Thornhill　　　233
12.6.2　Imagini: Dave Gardner　　　233
12.7　小结　　234
附录　非关系型数据库大观　　235
词汇表　　.261
关于作者　　　279
关于封面　　　279
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Cassandra权威指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>WCF全面解析（上下册）
《wcf全面解析：全2册》
上册
第1章 wcf简介（wcf overview）	1
1.1 soa的基本概念和设计思想	2
1.2 wcf是对现有分布式通信技术的整合	3
1.3 构建一个简单的wcf应用	6
第2章 地址（address）	18
2.1 统一资源标识（uri）	19
2.1.1 http/https	19
2.1.2 net.tcp	20
2.1.3 net.pipe	20
2.1.4 net.msmq	21
2.2 endpointaddress	21
2.2.1 服务端终结点地址	22
2.2.2 客户端终结点地址	29
2.2.3 地址报头	32
2.3 端口共享	41
2.3.1 端口共享意义何在	43
2.3.2 http/https端口共享	43
2.3.3 tcp端口共享	44
.2.4 逻辑地址与物理地址	47
2.4.1 服务的角色	47
2.4.2 监听地址与监听模式	48
2.4.3 clientviabehavior行为	52
2.4.4 实例演示：通过tcptrace进行消息的路由（s205，s206）	54
2.5 请求监听与消息分发	60
2.5.1 连接请求的监听	61
2.5.2 消息分发	62
第3章 绑定（binding）	65
3.1 绑定模型	66
3.1.1 信道与信道栈	66
3.1.2 实例演示：直接通过绑定进行消息通信（s301）	68
3.1.3 wcf的绑定模型	71
3.2 信道与信道栈	72
3.2.1 communicationobject	72
3.2.2 defaultcommunicationtimeouts	74
3.2.3 ichannel和channelbase	75
3.2.4 消息交换模式	76
3.2.5 信道形状	77
3.2.6 会话信道	81
3.2.7 实例演示：自定义信道（s302）	83
3.3 信道监听器	87
3.3.1 ichannellistener与channellistenerbase	87
3.3.2 信道栈的创建/使用模式	88
3.3.3 实例演示：自定义信道监听器（s302）	88
3.4 信道工厂	91
3.4.1 ichannelfactory与channelfactorybase	91
3.4.2 实例演示：自定义信道工厂（s302）	92
3.5 绑定元素	93
3.5.1 构成绑定的元素	94
3.5.2 实例演示：自定义绑定元素（s302）	95
3.6 绑定	96
3.6.1 绑定是绑定元素的有序集合	97
3.6.2 实例演示：创建自定义绑定（s302，s303）	99
3.6.3 系统绑定	105
3.6.4 自定义绑定	109
3.6.5 绑定配置	110
第4章 契约（contract）	114
4.1 多角度认识契约	115
4.1.1 抽象、接口与服务契约	115
4.1.2 元数据与服务契约	116
4.1.3 wsdl、xsd与服务契约	116
4.1.4 消息交换与服务契约	117
4.2 定义服务契约	117
4.2.1 servicecontractattribute	117
4.2.2 operationcontractattribute	122
4.2.3 服务契约的继承	128
4.3 契约描述	132
4.3.1 contractdescription	132
4.3.2 operationdescription	133
4.3.3 messagedescription	134
4.4 消息交换模式与服务操作	139
4.4.1 请求-回复模式	139
4.4.2 单向模式	143
4.4.3 双工模式	144
4.4.4 实例演示：通过双工通信实现回调	145
4.5 多线程与异步操作	153
4.5.1 异步服务调用	154
4.5.2 异步服务实现	157
4.6 操作的选择与执行	160
4.6.1 dispatchoperation与clientoperation	160
4.6.2 操作的选择	162
4.6.3 操作的执行	163
第5章 序列化（serialization）	165
5.1 xmlserializer	166
5.1.1 xmlserializer默认的序列化规则	166
5.1.2 通过定制xmlserializer控制xml结构	169
5.1.3 通过定制数据类型控制xml结构	170
5.2 数据契约	171
5.2.1 数据契约的本质	172
5.2.2 datacontractattribute与datamemberattribute	172
5.3 datacontractserializer	174
5.3.1 datacontractserializer的序列化规则	176
5.3.2 如何限定序列化对象的数量	178
5.3.3 如何保持对象现有的引用结构	181
5.4 已知类型	184
5.4.1 未知类型导致序列化失败	184
5.4.2 datacontractserializer的已知类型集合	186
5.4.3 基于接口的序列化	187
5.4.4 knowntypeattribute	188
5.4.5 serviceknowntypeattribute	190
5.5 泛型数据契约与集合数据契约	191
5.5.1 泛型数据契约	191
5.5.2 数据契约集合	195
5.5.3 集合数据契约	199
5.5.4 字典数据契约	203
5.6 等效数据契约	208
5.6.1 数据契约的等效性	208
5.6.2 数据成员的添加	209
5.6.3 数据成员的删除	212
5.6.4 数据契约代理	215
5.7 序列化在wcf框架中的实现	219
5.7.1 消息格式化器	219
5.7.2 采用datacontractserializer还是xmlserializer	221
5.7.3 实例演示：通过自定义消息格式化器压缩消息（s521）	223
第6章 消息（message）	231
6.1 soap与ws-addressing	232
6.1.1 soap	232
6.1.2 ws-addressing	232
6.2 消息	234
6.2.1 消息版本	235
6.2.2 如何创建消息	237
6.2.3 消息的基本操作	244
6.3 消息报头与消息属性	249
6.3.1 messageheaderinfo	249
6.3.2 messageheader	250
6.3.3 messageheader[t]	251
6.3.4 messageheaders	252
6.3.5 消息属性	255
6.3.6 实例演示：通过消息报头和消息属性实现上下文信息的传播（s612）	259
6.4 消息契约	261
6.4.1 messagecontractattribute	262
6.4.2 messageheaderattribute	265
6.4.3 messagebodymemberattribute	265
6.4.4 消息契约与操作	266
6.5 xml编码	268
6.5.1 xmldictionary	268
6.5.2 xmldictionarywriter	270
6.5.3 xmldictionaryreader	278
6.6 消息编码	279
6.6.1 消息编码器	279
6.6.2 消息编码器工厂	280
6.6.3 消息编码绑定元素	281
6.6.4 消息编码与绑定	282
6.6.5 消息编码的实现	285
6.6.6 实例演示：通过自定义消息编码器实现消息压缩（s620）	286
第7章 服务寄宿（hosting）	294
7.1 服务描述	295
7.1.1 servicedescription	295
7.1.2 wcf的四大行为	297
7.2 servicehost	301
7.2.1 服务描述的创建（s701）	301
7.2.2 运行时框架体系的构建	308
7.2.3 服务的批量寄宿（s702）	312
7.2.4 自定义servicehost（s703）	316
7.3 iis与asp.net架构设计	317
7.3.1 iis 5.x与asp.net	318
7.3.2 iis 6.0与asp.net	319
7.3.3 iis 7.0与asp.net	320
7.3.4 asp.net管道	324
7.4 iis寄宿	328
7.4.1 .svc文件	328
7.4.2 实例演示：如何使用自定义servicehost（s704）	330
7.4.3 asp.net并行模式	331
7.4.4 asp.net兼容模式	337
7.4.5 非http协议寄宿	341
7.5 windows服务寄宿（s708）	343
第8章 客户端（client）	350
8.1 一个精简版的wcf框架	351
8.1.1 从透明代理和真实代理说起	351
8.1.2 服务代理的真实代理是什么	352
8.1.3 服务调用的大致流程	353
8.1.4 实例演示：创建一个wcf框架模拟程序（s801）	354
8.2 channelfactory[tchannel]	365
8.2.1 终结点是channelfactory[tchannel]的核心	366
8.2.2 一个特殊的信道工厂	366
8.2.3 channelfactory[tchannel]的开启	367
8.3 服务代理	369
8.3.1 服务代理的创建	369
8.3.2 四个重要的接口	370
8.3.3 服务调用	374
8.4 clientbase[tchannel]	376
8.4.1 clientbase[tchannel]与channelfactory[tchannel]	376
8.4.2 channelfactory[tchannel]缓存机制	378
8.5 服务代理的关闭与中止	380
8.5.1 没有关闭服务代理会带来怎样的后果	380
8.5.2 数据报信道与会话信道	382
8.5.3 服务代理、channelfactory[tchannel]和clientbase[tchannel]的关闭	383
8.5.4 服务代理的中止	385
8.5.5 通过realproxy实现服务代理的自动关闭和中止（s810）	389
8.5.6 通过委托实现服务代理的自动关闭和中止（s811）	391
第9章 实例化与会话（instancing and session）	395
9.1 实例上下文与实例上下文模式	396
9.1.1 实例上下文	396
9.1.2 实例上下文模式	397
9.1.3 实例服务行为	398
9.1.4 实例上下文提供者与实例提供者	399
9.1.5 实例上下文提供机制	400
9.2 单调模式	402
9.2.1 实例演示：单调模式下实例的创建与回收（s901）	402
9.2.2 单调模式实例上下文提供机制	403
9.2.3 实例演示：通过自定义实例上下文提供者实现单调模式（s902）	404
9.2.4 单调模式与可伸缩性	406
9.3 单例模式	407
9.3.1 已知单例和隐式单例	407
9.3.2 实例演示：单例模式下实例的创建与回收（s903）	408
9.3.3 单例模式实例上下文提供机制	409
9.3.4 实例演示：通过自定义实例上下文提供者实现单例模式（s904）	410
9.3.5 单例模式下的并发与同步	412
9.4 会话	413
9.4.1 客户端识别机制	414
9.4.2 会话契约	414
9.4.3 会话绑定	419
9.5 会话模式	421
9.5.1 实例演示：会话模式下实例的创建与回收（s910）	421
9.5.2 会话模式实例上下文提供机制	422
9.5.3 实例演示：通过自定义提供者实现会话模式（s911）	424
9.5.4 会话实例上下文模式与可伸缩性	426
9.6 会话模式、绑定与实例上下文模式	427
9.6.1 单调服务决定于单调实例上下文模式	427
9.6.2 单例服务决定于单例实例上下文模式	429
9.6.3 会话服务决定于会话信道（栈）和会话实例上下文模式	430
第10章 rest服务（rest service）	433
10.1 web、rest和wcf rest	434
10.1.1 web如此简单	434
10.1.2 rest是什么	435
10.1.3 wcf rest	438
10.2 web http编程模型	445
10.2.1 webhttpbinding	445
10.2.2 webgetattribute与webinvokeattribute	449
10.2.3 webhttpbehavior	454
10.2.4 webservicehost与webservicehostfactory	459
10.2.5 weboperationcontext	461
10.2.6 webfaultexception与webfaultexception[t]	463
10.3 uri模板	465
10.3.1 uri模板简介	465
10.3.2 uritemplate	467
10.3.3 uritemplatetable	468
10.3.4 webhttpdispatchoperationselector	469
10.4 消息格式化	473
10.4.1 客户端消息格式化	473
10.4.2 服务端消息格式化	485
10.5 输出缓存与条件获取/更新	487
10.5.1 输出缓存	488
10.5.2 条件获取	492
10.5.3 条件更新	496
第11章 wcf实例研究（wcf in practice）	500
11.1 vm简介	501
11.1.1 基本功能	501
11.1.2 物理部署	504
11.1.3 模块划分	504
11.1.4 层次设计	506
11.1.5 ioc的应用	508
11.1.6 aop的应用	513
11.1.7 身份认证	515
11.1.8 异常处理	520
11.2 模块设计	523
11.2.1 数据库设计	524
11.2.2 products模块	526
11.2.3 orders模块	536
11.2.4 infrastructure模块	540
11.3 asp.net mvc项目	544
11.3.1 ioc集成	545
11.3.2 异常处理	546
11.3.3 accountcontroller	547
11.3.4 productscontroller	549
11.3.5 orderscontroller	551
附录a 实例列表	557
下册
第1章 异常处理（exception handling）	1
1.1 wcf基本异常处理模式	2
1.1.1 当异常从服务端抛出	2
1.1.2 异常细节的传播	5
1.1.3 自定义异常信息	8
1.2 错误消息与faultexception异常	19
1.2.1 从soap fault说起	19
1.2.2 唯一可被传播的异常：faultexception	22
1.2.3 faultexception异常和错误消息之间的转换	26
1.3 wcf异常处理体系剖析	34
1.3.1 faultformatter	35
1.3.2 servicedebugbehavior如何实现对异常细节传播	39
1.4 wcf异常处理扩展	42
1.4.1 处理器（errorhandler）	42
1.4.2 实例演示：通过wcf扩展实现与entlib的集成（s105）	43
第2章 元数据（metadata）	55
2.1 wcf元数据架构体系简介	56
2.1.1 ws-mex	56
2.1.2 metadatasection与metadataset	70
2.1.3 wcf元数据架构模型	73
2.2 元数据的导出	74
2.2.1 metadataexporter和wsdlexporter	74
2.2.2 wsdl导出扩展和策略导出扩展	79
2.3 元数据的发布	81
2.3.1 元数据发布的实现者：servicemetadatabehavior	81
2.3.2 mex 终结点有何不同	83
2.3.3 servicemetadatabehavior是如何实现元数据发布的	85
2.4 元数据的获取和导入	97
2.4.1 自己动手实现元数据的获取	97
2.4.2 metadaimporter与元数据导入	102
第3章 事务（transaction）	108
3.1 wcf需要怎样的事务控制	109
3.1.1 什么是事务	109
3.1.2 事务的显式控制	110
3.1.3 分布式事务应用场景	113
3.2 windows下的事务处理模型	114
3.2.1 事务模型中的三种角色	115
3.2.2 分布式事务是如何实现的	118
3.2.3 system.transactions事务	121
3.3 事务处理协议：oletx和ws-at	135
3.3.1 ws-coordination	136
3.3.2 ws-at	140
3.4 wcf事务编程	142
3.4.1 通过服务契约决定事务流转的策略	142
3.4.2 通过绑定实施事务的流转	144
3.4.3 通过服务（操作）行为控制事务	153
3.4.4 实例演示：创建事务型服务（s301）	156
3.5 wcf事务实现原理	166
3.5.1 transactionflowattribute行为	166
3.5.2 事务绑定	166
3.5.3 事务的自动登记（enlistment）	173
3.5.4 oletx提升（oletx upgrade）机制	174
第4章 并发与限流（concurrency and throttling）	176
4.1 并发与实例上下文模式	177
4.1.1 同一个服务实例上下文同时处理多个服务调用请求	177
4.1.2 并发中的同步	180
4.1.3 并发与实例上下文模式	182
4.2 同步上下文与线程亲和性	196
4.2.1 倘若去除servicebehaviorattribute的usesynchronizationcontext属性	196
4.2.2 什么是同步上下文（synchronizationcontext）	197
4.2.3 wcf中的同步上下文与线程亲和性	199
4.3 流量限制（throttling）	203
4.3.1 如何进行限流控制	203
4.3.2 wcf限流控制是如何实现的	206
第5章 可靠会话（reliable sessions）	210
5.1 可靠消息传输	211
5.1.1 从tcp对报文段的可靠交付机制说起	211
5.1.2 ws-rm简介	213
5.2 编写可靠会话服务	220
5.2.1 实例演示：通过wcf服务传输图片（s501）	220
5.2.2 可靠会话绑定	234
5.3 可靠会话的实现原理	241
5.3.1 从信道层看可靠会话的实现	241
5.3.2 从传输协议的局限性和消息交换模式看可靠会话的实现	251
5.3.3 可靠会话最佳实践	254
第6章 队列服务（queued service）	257
6.1 msmq简介	258
6.1.1 msmq能解决什么问题	258
6.1.2 msmq的安装	259
6.1.3 消息队列	261
6.1.4 msmq编程	263
6.2 从队列服务的终结点谈起	274
6.2.1 地址	274
6.2.2 绑定	276
6.2.3 契约	278
6.3 事务控制	279
6.3.1 msmq事务模型	279
6.3.2 客户端事务	280
6.3.3 服务端事务	282
6.3.4 事务性批量接收	283
6.4 会话	288
6.4.1 客户端会话	288
6.4.2 服务端会话	292
6.5 错误处理	296
6.5.1 接收重试	296
6.5.2 接收错误处理	300
6.5.3 死信消息处理	301
6.5.4 日志（journaling）与跟踪（tracing）	303
第7章 传输安全（transfer security）	305
7.1 传输安全简介	306
7.1.1 分布式应用中的传输安全隐患	306
7.1.2 非对称加密（asymmetric cryptography）	307
7.1.3 transport与message安全模式	312
7.2 认证	318
7.2.1 认证与凭证（user credential）	318
7.2.2 绑定、安全模式与客户端凭证类型	323
7.2.3 服务认证	335
7.2.4 客户端认证	351
7.2.5 servicecredentials v.s. clientcredentials	362
7.3 消息保护（message protection）	366
7.3.1 消息的保护级别	366
7.3.2 签名与加密的实现	374
7.3.3 安全会话（secure sessions）	380
第8章 授权与审核（authorization and auditing）	386
8.1 身份（identity）与安全主体（principal）	387
8.1.1 身份	387
8.1.2 安全主体	391
8.2 windows用户组授权	397
8.2.1 windows用户组授权与认证的关系	397
8.2.2 windows用户组授权编程	398
8.2.3 实例演示：基于windows用户组的声明式授权（s801）	399
8.2.4 身份模拟（impersonation）	402
8.3 asp.net roles授权	409
8.3.1 asp.net roles提供程序	409
8.3.2 asp.net roles授权与认证的无关性	410
8.3.3 asp.net roles授权编程	411
8.3.4 实例演示：不同认证方式下的asp.ent roles授权	413
8.3.5 实例演示：通过wcf扩展实现授权（s805）	418
8.4 自定义授权方式	423
8.4.1 通过自定义authorizationpolicy和serviceauthorizationmanager创建安全主体	423
8.4.2 claim和claimset	426
8.4.3 自定义授权实现原理剖析	427
8.4.4 实例演示：通过自定义authorizationpolicy和serviceauthorizationmanager实现授权（s806）	428
8.5 安全审核（security auditing）	434
8.5.1 servicesecurityauditbehavior服务行为	434
8.5.2 安全审核的实现	435
8.5.3 实例演示：如何实施安全审核	436
第9章 扩展（extension）	442
9.1 服务端架构体系的构建	443
9.1.1 再谈服务描述（service description）	443
9.1.2 终结点分发器选择机制	446
9.1.3 信道分发器（channeldispatcher）	448
9.1.4 终结点分发器（endpointdispatcher）	452
9.1.5 分发运行时（dispatchruntime）	453
9.1.6 分发操作（dispatchoperation）	460
9.2 客户端架构体系的构建	465
9.2.1 创建channelfactory[tchannel]	465
9.2.2 客户端运行时（clientruntime）	467
9.2.3 客户端操作（clientoperation）	470
9.2.4 服务代理与服务调用	471
9.3 通过定义四种行为对wcf的扩展	474
9.3.1 wcf四种类型的行为	474
9.3.2 行为方法的执行	476
9.3.3 实例演示：通过扩展确保语言文化一致性（s901）	477
9.4 servicehost对wcf的扩展	488
9.4.1 自定义servicehost的本质：对服务描述进行定制	488
9.4.2 自定义servicehost的创建者：servicehostfactory	491
9.4.3 实例演示：通过扩展实现基于ioc的服务实例的创建（s903，s904）	493
第10章 wcf 4.0新特性（new features in wcf 4.0）	503
10.1 简化开发体验	504
10.1.1 默认终结点	504
10.1.2 默认绑定配置	509
10.1.3 默认行为配置	510
10.1.4 标准终结点	513
10.1.5 无.svc文件服务激活	514
10.2 路由服务(routing service)	516
10.2.1 路由服务就是一个wcf服务	516
10.2.2 基于消息内容的路由策略	520
10.2.3 实例演示：如何使用路由服务（s1001）	527
10.2.4 其他路由特性	532
10.3 服务发现（service discovery）	534
10.3.1 ws-discovery	534
10.3.2 可被发现的服务（discoverable service）	537
10.3.3 目标服务的探测和解析	544
10.3.4 实例演示：如何利用服务发现机制实现服务的“动态”调用（s1002）	550
10.3.5 dynamicendpoint	553
10.3.6 服务上/下线通知	555
10.3.7 发现代理（discovery proxy）	563
附录a 实例列表	571
参考文献	573
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>WCF全面解析（上下册）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Apache Spark源码剖析
第一部分Spark概述1
第1章初识Spark   3
1.1 大数据和Spark 3
1.1.1 大数据的由来4
1.1.2 大数据的分析4
1.1.3 Hadoop 5
1.1.4 Spark简介6
1.2 与Spark的第一次亲密接触7
1.2.1 环境准备7
1.2.2 下载安装Spark 8
1.2.3 Spark下的WordCount 8
第二部分Spark核心概念13
第2章Spark整体框架 15
2.1 编程模型15
2.1.1 RDD 17
2.1.2 Operation 17
2.2 运行框架18
2.2.1 作业提交18
2.2.2 集群的节点构成18
2.2.3 容错处理19
2.2.4 为什么是Scala 19
2.3 源码阅读环境准备19
2.3.1 源码下载及编译19
2.3.2 源码目录结构21
2.3.3 源码阅读工具21
2.3.4 本章小结22
第3章SparkContext初始化 23
3.1 spark-shell 23
3.2 SparkContext的初始化综述27
3.3 Spark Repl综述30
3.3.1 Scala Repl执行过程31
3.3.2 Spark Repl 32
第4章Spark作业提交 33
4.1 作业提交33
4.2 作业执行38
4.2.1 依赖性分析及Stage划分39
4.2.2 Actor Model和Akka 46
4.2.3 任务的创建和分发47
4.2.4 任务执行53
4.2.5 Checkpoint和Cache 62
4.2.6 WebUI和Metrics 62
4.3 存储机制71
4.3.1 Shuffle结果的写入和读取71
4.3.2 Memory Store 80
4.3.3 存储子模块启动过程分析81
4.3.4 数据写入过程分析82
4.3.5 数据读取过程分析84
4.3.6 TachyonStore 88
第5章部署方式分析 91
5.1 部署模型91
5.2 单机模式local 92
5.3 伪集群部署local-cluster 93
5.4 原生集群Standalone Cluster 95
5.4.1 启动Master 96
5.4.2 启动Worker 97
5.4.3 运行spark-shell 102
5.4.4 容错性分析106
5.5 Spark On YARN 112
5.5.1 YARN的编程模型112
5.5.2 YARN中的作业提交112
5.5.3 Spark On YARN实现详解113
5.5.4 SparkPi on YARN 122
第三部分Spark Lib 129
第6章Spark Streaming  131
6.1 Spark Streaming整体架构131
6.1.1 DStream 132
6.1.2 编程接口133
6.1.3 Streaming WordCount 134
6.2 Spark Streaming执行过程135
6.2.1 StreamingContext初始化过程136
6.2.2 数据接收141
6.2.3 数据处理146
6.2.4 BlockRDD 155
6.3 窗口操作158
6.4 容错性分析159
6.5 Spark Streaming vs. Storm 165
6.5.1 Storm简介165
6.5.2 Storm和Spark Streaming对比168
6.6 应用举例168
6.6.1 搭建Kafka Cluster 168
6.6.2 KafkaWordCount 169
第7章SQL   173
7.1 SQL语句的通用执行过程分析175
7.2 SQL On Spark的实现分析178
7.2.1 SqlParser 178
7.2.2 Analyzer 184
7.2.3 Optimizer 191
7.2.4 SparkPlan 192
7.3 Parquet 文件和JSON数据集196
7.4 Hive简介197
7.4.1 Hive 架构197
7.4.2 HiveQL On MapReduce执行过程分析199
7.5 HiveQL On Spark详解200
7.5.1 Hive On Spark环境搭建206
7.5.2 编译支持Hadoop 2.x的Spark 211
7.5.3 运行Hive On Spark测试用例213
第8章GraphX  215
8.1 GraphX简介215
8.1.1 主要特点216
8.1.2 版本演化216
8.1.3 应用场景217
8.2 分布式图计算处理技术介绍218
8.2.1 属性图218
8.2.2 图数据的存储与分割219
8.3 Pregel计算模型220
8.3.1 BSP 220
8.3.2 像顶点一样思考220
8.4 GraphX图计算框架实现分析223
8.4.1 基本概念223
8.4.2 图的加载与构建226
8.4.3 图数据存储与分割227
8.4.4 操作接口228
8.4.5 Pregel在GraphX中的源码实现230
8.5 PageRank 235
8.5.1 什么是PageRank 235
8.5.2 PageRank核心思想235
第9章MLLib   239
9.1 线性回归239
9.1.1 数据和估计240
9.1.2 线性回归参数求解方法240
9.1.3 正则化245
9.2 线性回归的代码实现246
9.2.1 简单示例246
9.2.2 入口函数train 247
9.2.3 最优化算法optimizer 249
9.2.4 权重更新update 256
9.2.5 结果预测predict 257
9.3 分类算法257
9.3.1 逻辑回归258
9.3.2 支持向量机260
9.4 拟牛顿法261
9.4.1 数学原理261
9.4.2 代码实现265
9.5 MLLib与其他应用模块间的整合268
第四部分附录271
附录A Spark源码调试 273
附录B 源码阅读技巧 283
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Apache Spark源码剖析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ZeroMQ
前言 xix
第1部分 学习如何使用φMQ 来开展工作
第1章 基础知识 3
修复这个世界 3
本书的读者对象 5
获取示例 5
问过就必有收获 5
在字符串上的小注解 10
版本报告 12
获得消息 12
分而治之 16
用φMQ 编程 21
获取正确的上下文 22
执行彻底的退出 22
为什么我们需要φMQ 23
套接字的可扩展性 27
从φMQ v2.2 升级到φMQ v3.2 28
警告：不稳定的典范！ 29
第2章 套接字和模式 31
套接字API 32
把套接字接入网络拓扑 32
使用套接字来传输数据 34
单播传输 35
φMQ 不是一个中性载体 35
I/O 线程 36
消息传递模式 37
高级别消息传递模式 38
处理消息 38
处理多个套接字 41
多部分消息 44
中间层及代理 45
动态发现问题 46
共享队列（DEALER 和ROUTER 套接字） 48
φMQ 的内置代理功能 53
传输桥接 55
处理错误和ETERM 56
处理中断信号 61
检测内存泄漏 63
使用φMQ 编写多线程程序 64
线程间信令（PAIR 套接字） 69
节点协调 71
零拷贝 75
发布- 订阅消息封包 76
高水位标记 78
消息丢失问题的解决方案 80
第3章 高级请求- 应答模式 83
请求- 应答机制 83
简单的应答封包 84
扩展的应答封包 84
这有什么好处呢 87
请求- 应答套接字回顾 88
请求- 应答组合 88
REQ 到REP 组合 89
DEALER 到REP 组合 89
REQ 到ROUTER 组合 90
DEALER 到ROUTER 组合 90
DEALER 到DEALER 组合 90
ROUTER 到ROUTER 组合 90
无效组合 91
探索ROUTER 套接字 91
身份和地址 92
ROUTER 错误处理 .93
负载均衡模式 94
ROUTER 代理和REQ 工人 95
ROUTER 代理及DEALER 工人 97
负载均衡的消息代理 98
用于φMQ 的一个高级别的API 105
高级别API 的特点 107
CZMQ 高级别API 108
异步客户端/ 服务器模式 115
能够工作的示例：跨代理路由 120
建立详情 120
单集群架构 121
扩展到多个集群 122
联盟与对等比较 124
命名规范 126
状态流原型 127
本地流和云端流原型 130
总结 137
第4章 可靠的请求- 应答模式 147
什么是“可靠性” 147
可靠性设计 148
客户端可靠性（懒惰海盗模式） 149
基本可靠队列（简单海盗模式） 154
健壮的可靠队列（偏执海盗模式） 157
信号检测 166
置若罔闻地将它关闭 166
单向信号检测 167
乒乓信号检测 167
针对偏执海盗的信号检测 168
合同和协议 170
面向服务的可靠队列（管家模式） 170
异步管家模式 195
服务发现 201
幂等服务 203
断开连接的可靠性（泰坦尼克模式） 203
高可用性对（双星模式） 216
详细需求 218
避免脑裂症状 220
双星实现 221
双星反应器 228
无代理可靠性（自由职业者模式） 234
模型一：简单的重试和故障转移 235
模型二：粗暴猎枪屠杀 238
模式三：复杂和讨厌的 244
结论 256
第5章 高级发布- 订阅模式 257
发布- 订阅模式的优点和缺点 257
发布- 订阅跟踪（特浓咖啡模式） 259
最后一个值缓存 262
慢速订阅者检测（自杀蜗牛模式） 267
高速订阅者（黑盒模式） 270
可靠的发布- 订阅（克隆模式） 272
集中式与分散式 273
将状态表示为键- 值对 273
得到带外的快照 284
重新发布来自客户端的更新 290
处理子树 295
临时值 298
使用反应器 306
在双星模式中添加可靠性 311
集群的散列映射协议 321
构建一个多线程栈和API 325
第2部分 使用φMQ 的软件工程
第6章 φMQ 社区 341
φMQ 社区的架构 342
如何制作真正的大型架构 343
软件架构的心理学 344
合同 346
过程 348
疯狂，美丽，并且容易 348
陌生人，遇见陌生人 349
无限的财富 349
照管和培育 350
φMQ 过程：C4 351
语言 351
目标 352
热身 354
许可和所有权 355
对补丁程序的要求 356
开发过程 357
建立稳定的版本 361
公共合同的演变 362
一个实际例子 364
Git 分支是有害的 368
简单性与复杂性的对比 369
更改延迟 369
学习曲线 369
出故障的成本 369
前期协调 369
可扩展性 370
惊奇和期望 370
参与的经济学 370
在冲突中的强壮性 370
隔离的保证 370
能见度 371
结论 371
为创新而设计 371
双桥传说 371
φMQ 的路线图是如何失去的 372
垃圾桶化的设计 374
复杂化的设计 376
简约化的设计 377
职业倦怠 379
成功模式 380
懒惰的完美主义者 381
仁慈暴君 381
天和地 381
门户开放 381
大笑的小丑 382
留心的将军 382
社会工程师 382
不朽的园丁 382
滚石 382
海盗帮 383
快闪族 383
加那利看守 383
执行绞刑的刽子手 383
历史学家 383
煽动者 384
神秘人 384
第7章 使用φMQ 的高级架构 385
用于弹性设计的面向消息模式 386
第1步：内部化的语义 387
第2步：描绘一个粗略的架构 387
第3步：决定合同 388
第4步：编写一个最小的端到端解决方案 388
第5步：解决一个问题，然后重复 389
Unprotocol 389
合同是艰难的 390
如何编写Unprotocol 391
为什么使用GPLv3 的公开规范 392
使用ABNF 393
廉价或讨厌的模式 393
序列化数据 395
φMQ 组帧 396
序列化语言 396
序列化库 397
手写的二进制序列化 399
代码生成 400
传输文件 406
状态机 417
使用SASL 认证 424
大型文件发布：FileMQ 426
为什么要制作FileMQ 426
最初的设计切片：API 426
最初的设计切片：协议 427
构建和尝试FileMQ 429
内部架构 430
公共API 431
设计说明 432
配置 433
文件稳定性 434
递交通知 434
符号链接 435
恢复和后期加入者 435
测试用例：曲目工具 437
得到一个官方端口号 439
第8章 分布式计算的框架 441
用于现实世界的设计 442
无线网络的秘密生活 443
为什么网状网络现在还没出现 444
一些物理知识 445
现状是什么 446
结论 448
发现 448
通过原始套接字先发制人的发现 448
使用UDP 广播协同发现 450
一台设备上的多个节点 455
设计API 456
关于UDP 的更多内容 465
分拆一个库项目 466
点对点消息传递 467
UDP 信标帧 467
真正的对等连接（和谐模式） 469
检测失踪 471
群发消息 472
测试与模拟 474
使用断言 474
前期测试 475
Zyre 测试仪 476
测试结果 479
跟踪活动 481
处理阻塞节点 481
分布式日志记录和监视 484
一个合理的最小实现 485
协议断言 488
二进制日志记录协议 489
内容分发 490
编写Unprotocol 493
结论 494
第9章 后记 497
番外篇 497
Rob Gagnon 的故事 497
Tom van Leeuwen 的故事 497
Michael Jakl 的故事 498
Vadim Shalts 的故事 498
本书是如何诞生的 499
消除摩擦 500
许可 502
索引 503
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ZeroMQ
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>响应式架构
目录
第１章　Actor模型和企业级软件概述. ................................... 1
为什么企业级软件难以开发........1
响应式应用程序简介....................4
响应性 ....................................5
韧性 ...6
灵活性 ....................................6
消息驱动 ................................7
企业级应用程序............................8
Actor模型 ..9
Actor模型的起源 ................10
了解 Actor模型 ................... 11
Actor模型的明晰性 .....................20
下章提要.21
第２章　使用Scala语言和Akka框架实现Actor模型............. 22
怎样获取Scala语言和Akka框架 23
使用 Typesafe Activator编辑器 ..............................23
使用 sbt ................................23
使用 Maven ..........................24
使用 Gradle ..........................25
使用Scala语言编写程序 .............26
Scala概要教程 ....................27
使用Akka框架编写程序.............39
Actor系统 ............................40
实现 Actor对象 ...................46
监督 .52
远程处理 ..............................55
集群功能 ..............................68
测试 Actor对象 ...................94
CompletableApp类 .............98
小结.......100
第３章　性能情结. ........................ 101
晶体管...101
时钟频率....................................103
核心和高速缓存........................104
可伸缩性....................................106
多线程技术的难点....................109
Actor模型的作用 ....................... 114
处理伪共享 ........................ 116
设计模式.................................... 117
第４章　通过Actor对象传递消息. . 119
消息通道....................................120
消息.......121
管道和过滤器............................126
消息路由器................................131
消息译码器................................134
消息端点....................................135
小结.......137
第５章　消息通道. ........................ 138
点对点通道................................140
发布—订阅通道........................143
本地事件流 ........................143
分布式发布—订阅通道 ....149
数据类型通道............................157
非法消息通道............................159
死信通道....................................161
确保送达机制............................164
通道适配器................................172
消息桥...174
消息总线....................................180
小结.......189
第６章　消息结构. ........................ 190
命令消息....................................191
文档消息....................................192
管理处理流程和处理过程 194
事件消息....................................195
请求—回复模式........................197
返回地址....................................199
相关标识符................................203
消息序列....................................204
消息有效期................................206
格式标识符................................209
小结.......213
第７章　消息路由. ........................ 214
基于内容的路由器....................215
消息过滤器................................219
动态路由器................................223
接收者列表................................232
分离器...241
聚合器...245
重新定序器................................252
组合消息处理器........................259
分散—聚集路由器....................260
传送名单....................................274
处理过程管理器........................282
消息经纪人路由器....................298
小结.......301
第８章　消息转换. ........................ 302
封装器...303
内容丰富器................................305
不可变的 DoctorVisitCompleted消息...................309
是否应在本地系统中创建 AccountingEnricherDispatcher对象 ..............309
内容过滤器................................310
存放证...313
标准化器....................................321
规范化消息模型........................322
Actor系统需要标准 ..........323
小结.......324
第９章　消息端点. ........................ 325
消息传输网关............................326
消息传输映射............................332
事务型客户端/ Actor对象 .........339
事务型客户端 ....................341
事务型 Actor对象 .............342
轮询消费者................................350
资源轮询 ............................354
由事件驱动的消费者................358
具有竞争性的消费者................359
消息调度器................................361
选择性消费者............................364
持久订阅者................................367
幂等接收者................................370
避免处理消息副本 ............370
使消息具有相同的效果 ....371
使状态切换操作不受收到消息副本的影响 .........372
服务激活剂................................378
小结.......379
第10章　系统管理和基础结构...... 380
控制总线....................................380
改道器...382
窃听器...384
消息元数据/历史记录 ...............385
消息日志/存储器 .......................389
智能代理....................................392
测试消息....................................397
通道净化器................................399
小结.......401
附录A　.NET平台上的Akka工具集：Dotsero. ................... 402
Dotsero的Actor系统 ..................402
通过C#和.NET使用Actor对象 .405
Dotsero实现 ...............................410
小结.......413
参考资料.. 414
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>响应式架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Jakarta Commons Cookbook中文版
前言 1
第1章 扩展J2SE平台 11
1.0 简介 11
1.1 获取Commons Lang 12
1.2 加入Commons-User邮件列表 13
1.3 获取Commons Lang源代码 14
1.4 自动生成toString()内容 15
1.5 自定义toString()内容 17
1.6 自动生成hashCode()和equals() 19
1.7 自动实现compateTo() 21
1.8 输出数组内容 23
1.9 克隆和反转数组 24
1.10 对象数组和基本类型数组的互相转换 27
1.11 在数组中搜索特定项 29
1.12 由多维数组生成Map 30
1.13 格式化日期 32
1.14 舍入Date对象 34
1.15 截取Date对象 36
1.16 创建枚举量 37
1.17 生成唯一的数字标识符 41
1.18 验证方法参数 44
1.19 度量时间 46
第2章 处理文本 49
2.0 简介 49
2.1 获取StringUtils和WordUtils 50
2.2 检查空字符串 50
2.3 缩减字符串 52
2.4 分割字符串 54
2.5 搜寻嵌套字符串 55
2.6 裁减字符串 57
2.7 字符串的chomp处理 58
2.8 创建醒目的标题 59
2.9 反转字符串 59
2.10 单词折回 61
2.11 检测字符串内容 62
2.12 检测字符串出现频率 64
2.13 解析格式化字符串 66
2.14 计算字符串的差别 68
2.15 使用Commons Codec 70
2.16 获取Commons Codec源代码 71
2.17 计算Soundex编码 72
第3章 JavaBeans 74
3.0 简介 74
3.1 以图形方式表示Beans 75
3.2 获取Commons BeanUtils 78
3.3 获取Commons BeanUtils源代码 79
3.4 访问简单的Bean属性 80
3.5 访问嵌套Bean属性 82
3.6 访问带有下标的Bean属性 84
3.7 访问Map型Bean属性内容 85
3.8 访问一个嵌套的带有下标的Map型简单Bean属性 87
3.9 确定Bean属性的类型 88
3.10 比较Beans 90
3.11 复制Bean属性 93
3.12 Bean的克隆 95
3.13 设置Bean属性 95
3.14 检查可否访问属性 97
3.15 通过Predicates验证Beans 98
3.16 创建包含Bean属性的Map 100
3.17 使用Map封装Bean 101
3.18 创建动态Bean 103
3.19 以字符串形式读取和设置属性 105
第4章 函子 107
4.0 简介 107
4.1 获取Commons Collections 108
4.2 获取Commons Collections源代码 109
4.3 Comparator的功能反转 109
4.4 Comparators的链接 112
4.5 对null的比较 114
4.6 以固定顺序比较 116
4.7 使用简单的Predicates 119
4.8 自定义Predicate 124
4.9 创建复合Predicate 126
4.10 对象转换 130
4.11 创建转换链 131
4.12 实现条件转换 133
4.13 编写Closure 135
4.14 链接多个Closure 136
4.15 使用Closures模拟条件语句 137
4.16 使用Closure模拟循环 140
第5章 Collections 142
5.0 简介 142
5.1 获取Commons Collections 142
5.2 使用循环迭代器 143
5.3 遍历ArrayList 145
5.4 使用Predicate筛选Collection 147
5.5 遍历相异的元素 150
5.6 使用Bag 151
5.7 使用Buffer 156
5.8 创建优先队列 158
5.9 使用阻塞式缓冲区 162
5.10 在Map中存储多个值 165
5.11 根据值检索相应的键 167
5.12 使用大小写不敏感的Map 170
5.13 创建特定类型的Collection和Map 172
5.14 限制Map的取值 176
5.15 限制List的内容 179
5.16 转换Collections 180
5.17 创建LRU缓存 183
5.18 使用LazyMap 184
5.19 统计Collection中对象的出现次数 188
5.20 执行集合操作 190
5.21 不经强制转换检索Map的值 192
第6章 XML 194
6.0 简介 194
6.1 获取Jakarta Commons Digester 195
6.2 将XML文档转为对象 196
6.3 带命名空间的解析 200
6.4 创建简单XML命令语言 204
6.5 变量置换和XML解析 207
6.6 获取Jakarta Commons Betwixt 210
6.7 转换Beans为XML文档 211
6.8 定制由对象生成的XML 213
6.9 转换XML文档为Beans 216
第7章 应用程序基础设施 219
7.0 简介 219
7.1 获取Commons CLI 219
7.2 解析简单命令行 220
7.3 解析复杂命令行 222
7.4 显示使用方法信息 223
7.5 获取Commons Configuration 225
7.6 通过属性文件配置应用程序 226
7.7 通过XML配置应用程序 227
7.8 使用复合配置 229
7.9 获取Commons Logging 232
7.10 使用抽象日志接口 233
7.11 指定日志的实现 234
7.12 获取Apache Log4J 235
7.13 根据属性文件配置Log4J 236
7.14 通过XML配置Log4J 238
第8章 Math 240
8.0 简介 240
8.1 使用分数 241
8.2 在数组里寻找最大和最小数 243
8.3 处理数字的范围 244
8.4 生成随机变量 246
8.5 获取Commons Math 247
8.6 计算简单的单变量统计量 248
8.7 解线性方程系统 250
8.8 带复数的算术操作 252
8.9 在变量间建立关联 254
8.10 估计剩余处理时间 256
第9章 模板 261
9.0 简介 261
9.1 获取Commons JEXL 264
9.2 使用表达式语言 265
9.3 在表达式中调用方法 268
9.4 以表达式语言外置逻辑 269
9.5 获取Jakarta Velocity 271
9.6 使用简单模板语言 272
9.7 编写含有条件和循环的模板 274
9.8 在模板引擎中使用宏 277
9.9 在模板中调用方法 280
9.10 获取FreeMarker 284
9.11 使用复杂的脚本引擎 285
9.12 从模板引擎访问XML文档 288
9.13 在Web应用程序中使用Velocity 291
9.14 在Web应用程序中使用FreeMarker 292
9.15 在Eclipse中编写模板 294
第10章 I/O与网络 295
10.0 简介 295
10.1 获取Commons IO 296
10.2 拷贝Stream、byte[]数组、Reader和Writer 297
10.3 关闭Stream、Reader和Writer 298
10.4 输出易于理解的文件大小值 300
10.5 拷贝文件、字符串和URL 302
10.6 递归删除目录 303
10.7 获取目录大小 304
10.8 文件touch操作 304
10.9 筛选文件 305
10.10 测量Stream流量 306
10.11 拆分OutputStream 308
10.12 获取Jakarta ORO 308
10.13 使用glob表达式和Perl5正则表达式列举文件 309
10.14 获取Commons Net 310
10.15 编写FTP客户端 311
10.16 通过SMTP发送邮件 313
10.17 查看POP3邮箱 315
第11章 HTTP和WebDAV 318
11.0 简介 318
11.1 获取Jakarta HttpClient 318
11.2 获取Jakarta HttpClient源代码 320
11.3 执行HTTP GET 321
11.4 在查询字符串中发送参数 323
11.5 通过条件GET检索内容 325
11.6 调试HTTP 328
11.7 执行HTTP POST请求 330
11.8 发送来自文件的POST数据 332
11.9 通过Multipart POST上传文件 333
11.10 Basic型身份验证 335
11.11 NTLM身份验证 338
11.12 处理Cookie 339
11.13 处理重定向 342
11.14 SSL 345
11.15 使用自签发的证书 346
11.16 获取Jakarta Slide 347
11.17 连接WebDAV资源 349
11.18 修改WebDAV资源 351
第12章 搜索和筛选 353
12.0 简介 353
12.1 获取Commons JXPath 354
12.2 通过XPath查询对象图表 354
12.3 搜索一组简单对象 357
12.4 在复杂的对象图表中使用XPath查询 359
12.5 获取Jakarta Lucene 362
12.6 为XML文档创建索引 363
12.7 在文档索引中搜索指定词语 368
12.8 找出索引中词语出现的频率 372
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Jakarta Commons Cookbook中文版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Cassandra实战
前言
第1章认识NoSQL/1
1.1NoSQL的起源和发展现状/2
1.2为什么要使用NoSQL/2
1.3开源NoSQL产品介绍/3
1.3.1Key/Value的NoSQL数据库/3
1.3.2面向文档的NoSQL数据库/4
1.3.3面向列的NoSQL数据库/5
1.3.4面向图的NoSQL数据库/6
1.4本章小结/7
第2章Cassandra快速入门/9
2.1在Windows环境运行单机版Cassandra/10
2.1.1配置JRE/11
2.1.2配置运行Cassandra 0.6.x/11
2.1.3配置运行Cassandra 0.7.x/12
2.2在Linux环境运行单机版Cassandra/14
2.2.1配置JRE/14
2.2.2配置运行Cassandra 0.6.x/15
2.2.3配置运行Cassandra 0.7.x/16
2.3Cassandra的数据模型/18
2.3.1Column/18
2.3.2SuperColumn/18
2.3.3ColumnFamily/19
2.3.4Keyspace/20
2.4Cassandra的数据排序规则/20
2.5配置数据类型/22
2.6使用命令行工具与Cassandra交互/23
2.6.1与Cassandra 0.6.x进行交互/23
2.6.2与Cassandra 0.7.x进行交互/24
2.7本章小结/26
第3章理解Cassandra编程接口/27
3.1多语言服务开发框架Thrift/28
3.2Cassandra的数据类型/28
3.2.1Column/28
3.2.2SuperColumn/29
3.2.3ColumnOrSuperColumn/29
3.2.4ColumnParent/29
3.2.5ColumnPath/30
3.2.6SliceRange/30
3.2.7SlicePredicate/31
3.2.8Deletion/31
3.2.9Mutation/31
3.2.10KeyRange/31
3.2.11KeySlice/32
3.2.12TokenRange/32
3.2.13AuthenticationRequest/32
3.2.14ConsistencyLevel/33
3.2.15NotFoundException/33
3.2.16InvalidRequestException/34
3.2.17UnavailableException/34
3.2.18TimedOutException/34
3.2.19AuthenticationException/34
3.2.20AuthorizationException/35
3.3Cassandra的编程接口/35
3.3.1get/35
3.3.2get_slice/36
3.3.3multiget_slice/36
3.3.4get_count/37
3.3.5get_range_slices/37
3.5.6insert/38
3.3.7remove/38
3.3.8batch_mutate/39
3.3.9describe_keyspaces/39
3.3.10describe_keyspace/39
3.3.11describe_cluster_name/40
3.3.12describe_version/40
3.3.13describe_ring/40
3.4Cassandra 0.7.x版本新增功能/40
3.4.1二级索引/40
3.4.2动态修改Schema/44
3.4.3自动清除过期数据/46
3.5本章小结/47
第4章基于Cassandra的在线交易系统/49
4.1需求分析/50
4.2数据模型设计/50
4.2.1Seller/51
4.2.2Buyer/51
4.2.3Product/52
4.2.4ProductCategory/53
4.2.5Comment/54
4.3编码实现/54
4.3.1修改Keyspace设置/55
4.3.2建立Eclipse项目/56
4.3.3实体对象实现/55
4.3.4Cassandra数据操作接口实现/56
4.4系统功能验证/60
4.4.1BuyerDao功能验证/60
4.4.2SellerDao功能验证/61
4.4.3ProductDao功能验证/62
4.5迁移到Cassandra 0.7.x/65
4.5.1建立Eclipse项目/65
4.5.2修改编译错误代码/65
4.5.3新增Schema在线定义功能/69
4.5.4功能验证/70
4.6本章小结/71
第5章Cassandra的集群机制/73
5.1一致性哈希/74
5.1.1理解一致性哈希/74
5.1.2一致性哈希在Cassandra中的应用/77
5.2Gossip：集群节点之间的通信协议/81
5.2.1FailureDetector/82
5.2.2Gossiper/83
5.3集群的数据备份机制/88
5.3.1EndpointSnitch/88
5.3.2ReplicationStrategy/91
5.4集群状态变化的处理机制/96
5.4.1StorageLoadBalancer/97
5.4.2StorageService/98
5.4.3MigrationManager/99
5.5本章小结/99
第6章Cassandra的内部数据存储结构/101
6.1Cassandra中的数据存放规则/102
6.2Commilog/102
6.3Memtable/103
6.4SSTable/105
6.4.1Filter文件/105
6.4.2Index文件/107
6.4.3Data文件/109
6.4.4Statistics文件/113
6.5系统表空间/113
6.6本章小结/114
第7章Cassandra的数据更新机制/115
7.1数据更新流程/116
7.2集群数据更新策略/116
7.2.1ANY/120
7.2.2ONE/121
7.2.3QUORUM/121
7.2.4LOCAL_QUORUM/121
7.2.5EACH_QUORUM/121
7.2.6ALL/121
7.3二级索引/122
7.3.1为什么需要二级索引/122
7.3.2Cassandra二级索引更新过程/123
7.4本章小结/124
第8章Cassandra的数据读取机制/125
8.1数据读取流程/126
8.1.1弱读取/126
8.1.2强读取/128
8.2集群数据读取策略/131
8.2.1ONE/132
8.2.2QUORUM/132
8.2.3LOCAL_QUORUM/132
8.2.4EACH_QUORUM/132
8.2.5ALL/133
8.3读修复/133
8.4数据缓存/134
8.4.1RowCache/134
8.4.2KeyCache/134
8.5二级索引/135
8.6本章小结/135
第9章Cassandra的数据压缩机制/137
9.1为什么要进行数据压缩/138
9.2如何控制数据压缩/138
9.3数据压缩流程/139
9.4维护Cassandra中的数据/143
9.4.1数据清理压缩/143
9.4.2数据一致性校验压缩/144
9.5本章小结/144
第10章Cassandra的启动流程/145
10.1Cassandra启动脚本/146
10.2Cassandra启动流程/149
10.2.1配置log4j/150
10.2.2读取校验配置文件信息/150
10.2.3加载所有的数据文件/152
10.2.4修复数据/154
10.2.5启动Gossiper服务/155
10.2.6判断是否需要进行Bootstrap操作/156
10.2.7监听Thrift端口，提供Thrift服务/157
10.3本章小结/157
第11章在分布式环境中使用的Cassandra/159
11.1在Linux环境中搭建与使用Cassandra集群/160
11.1.1配置JRE/160
11.1.2部署Cassandra可执行文件/161
11.1.3修改Cassandra配置文件/162
11.1.4启动Cassandra/163
11.2Cassandra运行配置项详解/166
11.3Cassandra集群的运行和维护/175
11.3.1查看集群的运行情况/176
11.3.2添加节点/179
11.3.3删除节点/181
11.3.4移动节点/183
11.3.5数据维护/185
11.4本章小结/187
第12章Cassandra与Hadoop的整合/189
12.1Hadoop快速入门/190
12.1.1Hadoop简介/190
12.1.2HDFS/192
12.1.3Map/Reduce/192
12.1.4配置单机版Hadoop/194
12.1.5编写Map/Reduce程序/195
12.2为什么要整合Cassandra与Hadoop/200
12.3使用Map/Reduce导入数据到Cassandra中/200
12.4将Cassandra中的数据作为Map/Reduce输入/205
12.5本章小结/209
第13章Cassandra最佳实践/211
13.1避免Cassandra自身的限制/212
13.1.1不要盲目使用Super Column/212
13.1.2硬盘的容量大小限制/212
13.1.3注意系统大小限制/212
13.2数据压缩策略/213
13.3使用高级的客户端/213
13.3.1Pycassa/213
13.3.2Hector/215
13.3.3FluentCassandra/218
13.3.4Cassandra/220
13.3.5phpcassa/221
13.4负载均衡/222
13.4.1随机选取/222
13.4.2缓存集群信息/222
13.5谨慎使用二级索引/223
13.6通过JMX监测Cassandra/223
13.7调整JVM启动参数/229
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Cassandra实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Storm实战
第1 章 Storm 基础 1
1.1 Storm 能做什么 ............................................... 2
1.2 Storm 特性 ...................................................... 3
1.3 其他流计算系统 .............................................. 8
1.4 应用模式 ....................................................... 13
第2 章 Storm 初体验 17
2.1 本地环境搭建 ............................................... 18
2.2 Storm 集群 .................................................... 25
第3 章 构建Topology 41
3.1 Storm 基本概念 ............................................. 42
3.2 构建Topology ............................................... 53
3.3 小结 .............................................................. 61
第4 章 Topology 的并行度 62
4.1 并行元素 ....................................................... 63
4.2 配置并行度 ................................................... 65
4.3 一个运行中Topology 的例子 ....................... 68
4.4 如何更新运行中的Topology 的并行度 ........ 71
第5 章 消息的可靠处理 73
5.1 简介 .............................................................. 74
5.2 理解消息被完整处理 .................................... 74
5.3 消息的生命周期 ............................................ 76
5.4 可靠相关的API ............................................ 79
5.5 高效地实现tuple tree .................................... 84
5.6 选择合适的可靠性级别 ................................ 87
5.7 集群的各级容错 ............................................ 89
5.8 小结 .............................................................. 91
第6 章 一致性事务 92
6.1 简单设计一：强顺序流 ................................ 93
6.2 简单设计二：强顺序batch 流 ...................... 95
6.3 CoordinateBolt 的原理 .................................. 96
6.4 Transactional Topology .................................. 98
第7 章 DRPC 105
7.1 Storm DRPC ................................................ 106
7.2 总体概述 ..................................................... 106
7.3 LinearDRPCTopologyBuilder ...................... 108
7.4 本地模式DRPC .......................................... 110
7.5 远程模式DRPC .......................................... 111
7.6 一个复杂的例子 .......................................... 113
7.7 非线性DRPC 拓扑 ..................................... 117
7.8 LinearDRPCTopologyBuilder 工作过程 ...... 117
7.9 高级进阶 ..................................................... 118
第8 章 Trident 的特性 119
8.1 理解Trident ................................................ 120
8.2 结合多个Trident 任务 ................................ 124
8.3 消费和生产Field ........................................ 126
8.4 State（状态保存） ...................................... 128
8.5 Trident Topology 的执行过程 ...................... 136
8.6 总结 ............................................................ 137
第9 章 Storm 实例 138
9.1 一个简单的实例 .......................................... 139
9.2 复杂一点的实例 .......................................... 150
9.3 其他 ............................................................ 161
第10 章 常见应用问题分析 162
10.1 性能问题排查与定位 ................................ 163
10.2 系统中常见的问题与排查 ......................... 167
10.3 业务问题的定位与排查 ............................ 170
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Storm实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解SPARK
前言
准　备　篇
第1章　环境准备 2
1.1　运行环境准备 2
1.1.1　安装JDK 3
1.1.2　安装Scala 3
1.1.3　安装Spark 4
1.2　Spark初体验 4
1.2.1　运行spark-shell 4
1.2.2　执行word count 5
1.2.3　剖析spark-shell 7
1.3　阅读环境准备 11
1.4　Spark源码编译与调试 13
1.5　小结 17
第2章　Spark设计理念与基本架构 18
2.1　初识Spark 18
2.1.1　Hadoop MRv1的局限 18
2.1.2　Spark使用场景 20
2.1.3　Spark的特点 20
2.2　Spark基础知识 20
2.3　Spark基本设计思想 22
2.3.1　Spark模块设计 22
2.3.2　Spark模型设计 24
2.4　Spark基本架构 25
2.5　小结 26
核心设计篇
第3章　SparkContext的初始化 28
3.1　SparkContext概述 28
3.2　创建执行环境SparkEnv 30
3.2.1　安全管理器SecurityManager 31
3.2.2　基于Akka的分布式消息系统ActorSystem 31
3.2.3　map任务输出跟踪器mapOutputTracker 32
3.2.4　实例化ShuffleManager 34
3.2.5　shuffle线程内存管理器ShuffleMemoryManager 34
3.2.6　块传输服务BlockTransferService 35
3.2.7　BlockManagerMaster介绍 35
3.2.8　创建块管理器BlockManager 36
3.2.9　创建广播管理器Broadcast-Manager 36
3.2.10　创建缓存管理器CacheManager 37
3.2.11　HTTP文件服务器HttpFile-Server 37
3.2.12　创建测量系统MetricsSystem 39
3.2.13　创建SparkEnv 40
3.3　创建metadataCleaner 41
3.4　SparkUI详解 42
3.4.1　listenerBus详解 43
3.4.2　构造JobProgressListener 46
3.4.3　SparkUI的创建与初始化 47
3.4.4　Spark UI的页面布局与展示 49
3.4.5　SparkUI的启动 54
3.5　Hadoop相关配置及Executor环境变量 54
3.5.1　Hadoop相关配置信息 54
3.5.2　Executor环境变量 54
3.6　创建任务调度器TaskScheduler 55
3.6.1　创建TaskSchedulerImpl 55
3.6.2　TaskSchedulerImpl的初始化 57
3.7　创建和启动DAGScheduler 57
3.8　TaskScheduler的启动 60
3.8.1　创建LocalActor 60
3.8.2　ExecutorSource的创建与注册 62
3.8.3　ExecutorActor的构建与注册 64
3.8.4　Spark自身ClassLoader的创建 64
3.8.5　启动Executor的心跳线程 66
3.9　启动测量系统MetricsSystem 69
3.9.1　注册Sources 70
3.9.2　注册Sinks 70
3.9.3　给Sinks增加Jetty的Servlet-ContextHandler 71
3.10　创建和启动ExecutorAllocation-Manager 72
3.11　ContextCleaner的创建与启动 73
3.12　Spark环境更新 74
3.13　创建DAGSchedulerSource和BlockManagerSource 76
3.14　将SparkContext标记为激活 77
3.15　小结 78
第4章　存储体系 79
4.1　存储体系概述 79
4.1.1　块管理器BlockManager的实现 79
4.1.2　Spark存储体系架构 81
4.2　shuffle服务与客户端 83
4.2.1　Block的RPC服务 84
4.2.2　构造传输上下文Transpor-tContext 85
4.2.3　RPC客户端工厂Transport-ClientFactory 86
4.2.4　Netty服务器TransportServer 87
4.2.5　获取远程shuffle文件 88
4.2.6　上传shuffle文件 89
4.3　BlockManagerMaster对Block-Manager的管理 90
4.3.1　BlockManagerMasterActor 90
4.3.2　询问Driver并获取回复方法 92
4.3.3　向BlockManagerMaster注册BlockManagerId 93
4.4　磁盘块管理器DiskBlockManager 94
4.4.1　DiskBlockManager的构造过程 94
4.4.2　获取磁盘文件方法getFile 96
4.4.3　创建临时Block方法create-TempShuffleBlock 96
4.5　磁盘存储DiskStore 97
4.5.1　NIO读取方法getBytes 97
4.5.2　NIO写入方法putBytes 98
4.5.3　数组写入方法putArray 98
4.5.4　Iterator写入方法putIterator 98
4.6　内存存储MemoryStore 99
4.6.1　数据存储方法putBytes 101
4.6.2　Iterator写入方法putIterator详解 101
4.6.3　安全展开方法unrollSafely 102
4.6.4　确认空闲内存方法ensureFreeSpace 105
4.6.5　内存写入方法putArray 107
4.6.6　尝试写入内存方法tryToPut 108
4.6.7　获取内存数据方法getBytes 109
4.6.8　获取数据方法getValues 110
4.7　Tachyon存储TachyonStore 110
4.7.1　Tachyon简介 111
4.7.2　TachyonStore的使用 112
4.7.3　写入Tachyon内存的方法putIntoTachyonStore 113
4.7.4　获取序列化数据方法getBytes 113
4.8　块管理器BlockManager 114
4.8.1　移出内存方法dropFrom-Memory 114
4.8.2　状态报告方法reportBlockStatus 116
4.8.3　单对象块写入方法putSingle 117
4.8.4　序列化字节块写入方法putBytes 118
4.8.5　数据写入方法doPut 118
4.8.6　数据块备份方法replicate 121
4.8.7　创建DiskBlockObjectWriter的方法getDiskWriter 125
4.8.8　获取本地Block数据方法getBlockData 125
4.8.9　获取本地shuffle数据方法doGetLocal 126
4.8.10　获取远程Block数据方法doGetRemote 127
4.8.11　获取Block数据方法get 128
4.8.12　数据流序列化方法dataSerializeStream 129
4.9　metadataCleaner和broadcastCleaner 129
4.10　缓存管理器CacheManager 130
4.11　压缩算法 133
4.12　磁盘写入实现DiskBlockObjectWriter 133
4.13　块索引shuffle管理器IndexShuffleBlockManager 135
4.14　shuffle内存管理器ShuffleMemoryManager 137
4.15　小结 138
第5章　任务提交与执行 139
5.1　任务概述 139
5.2　广播Hadoop的配置信息 142
5.3　RDD转换及DAG构建 144
5.3.1　为什么需要RDD 144
5.3.2　RDD实现分析 146
5.4　任务提交 152
5.4.1　任务提交的准备 152
5.4.2　finalStage的创建与Stage的划分 157
5.4.3　创建Job 163
5.4.4　提交Stage 164
5.4.5　提交Task 165
5.5　执行任务 176
5.5.1　状态更新 176
5.5.2　任务还原 177
5.5.3　任务运行 178
5.6　任务执行后续处理 179
5.6.1　计量统计与执行结果序列化 179
5.6.2　内存回收 180
5.6.3　执行结果处理 181
5.7　小结 187
第6章　计算引擎 188
6.1　迭代计算 188
6.2　什么是shuffle 192
6.3　map端计算结果缓存处理 194
6.3.1　map端计算结果缓存聚合 195
6.3.2　map端计算结果简单缓存 200
6.3.3　容量限制 201
6.4　map端计算结果持久化 204
6.4.1　溢出分区文件 205
6.4.2排序与分区分组 207
6.4.3　分区索引文件 209
6.5　reduce端读取中间计算结果 210
6.5.1　获取map任务状态 213
6.5.2　划分本地与远程Block 215
6.5.3　获取远程Block 217
6.5.4　获取本地Block 218
6.6　reduce端计算 219
6.6.1　如何同时处理多个map任务的中间结果 219
6.6.2　reduce端在缓存中对中间计算结果执行聚合和排序 220
6.7　map端与reduce端组合分析 221
6.7.1　在map端溢出分区文件，在reduce端合并组合 221
6.7.2　在map端简单缓存、排序分组，在reduce端合并组合 222
6.7.3　在map端缓存中聚合、排序分组，在reduce端组合 222
6.8　小结 223
第7章　部署模式 224
7.1　local部署模式 225
7.2　local-cluster部署模式 225
7.2.1　LocalSparkCluster的启动 226
7.2.2　CoarseGrainedSchedulerBackend的启动 236
7.2.3　启动AppClient 237
7.2.4　资源调度 242
7.2.5　local-cluster模式的任务执行 253
7.3　Standalone部署模式 255
7.3.1　启动Standalone模式 255
7.3.2　启动Master分析 257
7.3.3　启动Worker分析 259
7.3.4　启动Driver Application分析 261
7.3.5　Standalone模式的任务执行 263
7.3.6　资源回收 263
7.4　容错机制 266
7.4.1　Executor异常退出 266
7.4.2　Worker异常退出 268
7.4.3　Master异常退出 269
7.5　其他部署方案 276
7.5.1　YARN 277
7.5.2　Mesos 280
7.6　小结 282
扩　展　篇
第8章　Spark SQL 284
8.1　Spark SQL总体设计 284
8.1.1　传统关系型数据库SQL运行原理 285
8.1.2　Spark SQL运行架构 286
8.2　字典表Catalog 288
8.3　Tree和TreeNode 289
8.4　词法解析器Parser的设计与实现 293
8.4.1　SQL语句解析的入口 294
8.4.2　建表语句解析器DDLParser 295
8.4.3　SQL语句解析器SqlParser 296
8.4.4　Spark代理解析器SparkSQLParser 299
8.5　Rule和RuleExecutor 300
8.6　Analyzer与Optimizer的设计与实现 302
8.6.1　语法分析器Analyzer 304
8.6.2　优化器Optimizer 305
8.7　生成物理执行计划 306
8.8　执行物理执行计划 308
8.9　Hive 311
8.9.1　Hive SQL语法解析器 311
8.9.2　Hive SQL元数据分析 313
8.9.3　Hive SQL物理执行计划 314
8.10　应用举例：JavaSparkSQL 314
8.11　小结 320
第9章　流式计算 321
9.1　Spark Streaming总体设计 321
9.2　StreamingContext初始化 323
9.3　输入流接收器规范Receiver 324
9.4　数据流抽象DStream 325
9.4.1　Dstream的离散化 326
9.4.2　数据源输入流InputDStream 327
9.4.3　Dstream转换及构建DStream Graph 329
9.5　流式计算执行过程分析 330
9.5.1　流式计算例子CustomReceiver 331
9.5.2　Spark Streaming执行环境构建 335
9.5.3　任务生成过程 347
9.6　窗口操作 355
9.7　应用举例 357
9.7.1　安装mosquitto 358
9.7.2　启动mosquitto 358
9.7.3　MQTTWordCount 359
9.8　小结 361
第10章　图计算 362
10.1　Spark GraphX总体设计 362
10.1.1　图计算模型 363
10.1.2　属性图 365
10.1.3　GraphX的类继承体系 367
10.2　图操作 368
10.2.1　属性操作 368
10.2.2　结构操作 368
10.2.3　连接操作 369
10.2.4　聚合操作 370
10.3　Pregel API 371
10.3.1　Dijkstra算法 373
10.3.2　Dijkstra的实现 376
10.4　Graph的构建 377
10.4.1　从边的列表加载Graph 377
10.4.2　在Graph中创建图的方法 377
10.5　顶点集合抽象VertexRDD 378
10.6　边集合抽象EdgeRDD 379
10.7　图分割 380
10.8　常用算法 382
10.8.1　网页排名 382
10.8.2　Connected Components的应用 386
10.8.3　三角关系统计 388
10.9　应用举例 390
10.10　小结 391
第11章　机器学习 392
11.1机器学习概论 392
11.2　Spark MLlib总体设计 394
11.3　数据类型 394
11.3.1　局部向量 394
11.3.2标记点 395
11.3.3局部矩阵 396
11.3.4分布式矩阵 396
11.4基础统计 398
11.4.1摘要统计 398
11.4.2相关统计 399
11.4.3分层抽样 401
11.4.4假设检验 401
11.4.5随机数生成 402
11.5分类和回归 405
11.5.1数学公式 405
11.5.2线性回归 407
11.5.3分类 407
11.5.4回归 410
11.6决策树 411
11.6.1基本算法 411
11.6.2使用例子 412
11.7随机森林 413
11.7.1基本算法 414
11.7.2使用例子 414
11.8梯度提升决策树 415
11.8.1基本算法 415
11.8.2使用例子 416
11.9朴素贝叶斯 416
11.9.1算法原理 416
11.9.2使用例子 418
11.10保序回归 418
11.10.1算法原理 418
11.10.2使用例子 419
11.11协同过滤 419
11.12聚类 420
11.12.1K-means 420
11.12.2高斯混合 422
11.12.3快速迭代聚类 422
11.12.4latent Dirichlet allocation 422
11.12.5流式K-means 423
11.13维数减缩 424
11.13.1奇异值分解 424
11.13.2主成分分析 425
11.14特征提取与转型 425
11.14.1术语频率反转 425
11.14.2单词向量转换 426
11.14.3标准尺度 427
11.14.4正规化尺度 428
11.14.5卡方特征选择器 428
11.14.6Hadamard积 429
11.15频繁模式挖掘 429
11.16预言模型标记语言 430
11.17管道 431
11.17.1管道工作原理 432
11.17.2管道API介绍 433
11.17.3交叉验证 435
11.18小结 436
附录A　Utils 437
附录B　Akka 446
附录C　Jetty 450
附录D　Metrics 453
附录E　Hadoop word count 456
附录F　CommandUtils 458
附录G　Netty 461
附录H　源码编译错误 465
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解SPARK
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据Spark企业级实战
第1章　Spark编程模型	1
1.1  Spark：一体化、多元化的高速
大数据通用计算平台和库	1
1.1.1  为什么需要使用Spark	5
1.1.2  Spark技术生态系统简介	9
1.2  Spark大数据处理框架	20
1.2.1  Spark速度为何如此之快	20
1.2.2  RDD：分布式函数式编程	24
1.3  Spark子框架解析	28
1.3.1  图计算框架Spark GraphX	28
1.3.2  实时流处理框架（Spark Streaming）	41
1.3.3  交互式SQL处理框架Spark SQL	46
1.3.4  机器学习框架（Spark MLlib）	49
第2章　构建Spark分布式集群	55
2.1  搭建Hadoop单机版本和伪分布式开发环境	55
2.1.1  开发Hadoop需要的基本软件	56
2.1.2  安装每个软件	58
2.1.3  配置Hadoop单机模式并运行Wordcount示例	76
2.1.3  配置Hadoop伪分布模式并运行Wordcount示例	84
2. 2  搭建 Hadoop分布式集群的	92
2.2.1  在VMWare 中准备第二、第三台运行Ubuntu系统的机器	92
2.2.2  按照配置伪分布式模式的方式配置新创建运行Ubuntu系统的机器	93
2.2.3  配置Hadoop分布式集群环境	94
2.2.4  测试Hadoop分布式集群环境	105
2.3  Spark集群的动手搭建	108
2.3.1  Spark集群需要的软件	108
2.3.2  安装每个软件	110
2.3.3  启动并查看集群的状况	116
2.4  构建Hadoop单机版本和伪分布式环境	120
2.4.1  通过Spark的shell测试Spark的工作	121
2.4.2  使用Spark的cache机制观察一下效率的提升	125
第3章　Spark开发环境及其测试	129
3.1  搭建和设置IDEA开发环境	129
3.1.1  构建Spark的IDE开发环境	129
3.1.2  配置Spark的IDE开发环境	132
3.2  测试IDEA环境	146
3.3  实战：在IDEA中开发代码，并运行在Spark集群中	148
第4章　Spark RDD与编程API实战	159
4.1  深度解析Spark RDD	159
4.2  Transformation Operations动手实战	165
4.3  Action Operations动手实战	175
4.4  Spark API综合实战	179
第5章　Spark运行模式深入解析	191
5.1  Spark运行模式概述	192
5.1.1  Spark的运行模式列表	196
5.1.2  Spark的基本工作流程	197
5.2  Standalone模式	201
5.2.1  部署及程序运行	202
5.2.2  内部实现原理	206
5.3  Yarn-Cluster模式	234
5.3.1  部署及程序运行	235
5.3.2  内部实现原理	237
5.4  Yarn-Client模式	243
5.4.1  部署及运行程序	243
5.4.2  内部实现原理	244
第6章　Spark内核解析	247
6.1  Spark内核初探	247
6.1.1  Spark内核核心术语解析	247
6.1.2  Spark集群概览	250
6.1.3  Spark核心组件	251
6.1.4  Spark任务调度系统初见	252
6.2  Spark内核核心源码解读	256
6.2.1  SparkContext核心源码解析初体验	256
6.2.2  TaskSceduler启动源码解析初体验	260
6.2.3  DAGScheduler源码解读初体验	261
6.2.4  Spark的Web监控页面	262
6.3  以RDD的count操作为例触发Job全生命周期源码研究	263
6.4  Akka驱动下的Driver、Master、Worker	276
6.4.1  Driver中的AppClient源码解析	276
6.4.2  AppClient注册Master	279
6.4.3  Worker中Executor启动过程源代码解析	282
第7章　GraphX大规模图计算与图挖掘实战	287
7.1  Spark GraphX概览	288
7.2  Spark GraphX设计实现的核心原理	291
7.3  Table operator和Graph Operator	295
7.4  Vertices、edges、triplets	296
7.5  以最原始的方式构建graph	299
7.6  动手编写第一个Graph代码实例并进行Vertices、edges、triplets操作	299
7.7  在Spark集群上使用文件中的数据加载成为graph并进行操作	310
7.8  在Spark集群上掌握比较重要的图操作	320
7.9  Spark GraphX图算法	342
7.10  淘宝对Spark GraphX的大规模使用	347
第8章　Spark SQL原理与实战	349
8.1  为什么使用Spark SQL	349
8.1.1  Spark SQL的发展历程	349
8.1.2  Spark SQL的性能	351
8.2  Spark SQL运行架构	355
8.2.1  Tree和Rule	357
8.2.2  sqlContext的运行过程	360
8.2.3  hiveContext的运行过程	362
8.2.4  catalyst优化器	365
8.3  解析Spark SQL组件	367
8.3.1  LogicalPlan	367
8.3.2  SqlParser	370
8.3.3  Analyzer	378
8.3.4  Optimizer	381
8.4  深入了解Spark SQL运行的计划	383
8.4.1  hive/console的安装过程和原理	383
8.4.2  常用操作	386
8.4.3  不同数据源的运行计划	388
8.4.4  不同查询的运行计划	391
8.4.5  查询的优化	393
8.5  搭建测试环境	396
8.5.1  搭建虚拟集群（Hadoop1、Hadoop2、Hadoop3）	397
8.5.2  搭建客户端	398
8.5.3  文件数据的准备工作	399
8.5.4  Hive数据的准备工作	399
8.6  Spark SQL之基础应用	400
8.6.1  sqlContext的基础应用	402
8.6.2  hiveContext的基础应用	405
8.6.3  混合使用	408
8.6.4  缓存的使用	409
8.6.5  DSL的使用	410
8.7  ThriftServer和CLI	411
8.7.1  令人惊讶的CLI	411
8.7.2  ThriftServer	414
8.8  Spark SQL之综合应用	418
8.8.1  店铺分类	419
8.8.2  PageRank	421
8.9  Spark SQL之调优	424
8.9.1  并行性	424
8.9.2  高效的数据格式	425
8.9.3  内存的使用	427
8.9.4  合适的Task	428
8.9.5  其他的一些建议	428
第9章　Machine Learning on Spark	431
9.1  Spark MLlib机器学习	431
9.1.1  机器学习快速入门	432
9.1.2  Spark MLlib介绍	442
9.1.3  Spark MLlib架构解析	447
9.1.4  Spark Mllib核心解析	458
9.2  MLlib经典算法解析和案例实战	462
9.2.1  Linear Regression解析和实战	462
9.2.2  K-Means解析和实战	484
9.2.3  协同过滤算法分析和案例实战	502
9.3  MLLib其他常用算法解析和代码实战	552
9.3.1  Basic Statics解析和实战	553
9.3.2  MLlib朴素贝叶斯解析和实战	560
9.3.3  MLlib决策树解析和实战	562
第10章　Tachyon文件系统	565
10.1  Tachyon文件系统概述	565
10.1.1  Tachyon文件系统简介	565
10.1.2  HDFS与Tachyon	566
10.1.3  Tachyon设计原理	568
10.2  Tachyon入门	568
10.2.1  Tachyon部署	568
10.2.2  Tachyon API的使用	570
10.2.3  在MapReduce、Spark上使用Tachyon	572
10.3  Tachyon深度解析	573
10.3.1  Tachyon整体设计概述	573
10.3.2  Tachyon Master启动流程分析	574
10.3.3  Tachyon Worker启动流程分析	577
10.3.4  客户端读写文件源码分析	577
10.4  Tachyon配置参数一览	579
10.5  小结	580
第11章　Spark Streaming原理与实战	581
11.1  Spark Streaming原理	581
11.1.1  原理和运行场景	581
11.1.2  编程模型DStream	584
11.1.3  持久化、容错和优化	588
11.2  Spark Streaming实战	589
11.2.1  源码解析	589
11.2.2  Spark Streaming实战案例	600
第12章　Spark多语言编程	605
12.1  Spark多语言编程的特点	605
12.2  Spark编程模型	609
12.3  深入Spark多语言编程	611
12.4  Spark多语言编程综合实例	622
第13章　R语言的分布式编程之SparkR	627
13.1  R语言快速入门	627
13.1.1  R语言是什么	627
13.1.2  R语言的特点	629
13.1.3  R语言的安装	630
13.1.4  R的核心概念	630
13.1.5  R动手实战	631
13.2  使用SparkR	661
13.2.1  SparkR的安装	661
13.2.2  使用SparkR编写WordCount	662
13.2.3  使用SparkR的更多代码示例	662
第14章　Spark性能调优和最佳实践	665
14.1  Spark性能调优	665
14.1.1  Spark性能优化的12大问题及其解决方法	665
14.1.2  Spark内存优化	669
14.1.3  RDD分区	672
14.1.4  Spark性能优化实例	674
14.2  Spark性能调优细节	675
14.2.1  broadcast和accumulator	675
14.2.2  reduce 和 reduceByKey	676
14.2.3  深入reduceByKey	677
第15章　Spark源码解析	679
15.1  BlockManager源码解析	679
15.2  Cache源码解析	707
15.3  Checkpoint源码解析	725
附录A　动手实战Scala三部曲	733
第一部动手体验Scala	735
第二部　动手实战Scala面向对象编程	746
第三部动手实战Scala函数式编程	761
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据Spark企业级实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>重构大数据统计
第1 章 基本概念 ............................................................. 1
1.1 数据类型 ......................................................................................... 1
1.2 总体和样本 ........................................................................ 2
1.3 参数和统计量 ................................................................................... 2
1.4 分布式计算 ...................................................................... 3
第2 章 单变量基本统计量 .......................................................... 5
2.1 数量统计量 ........................................................................... 5
2.1.1 样本方差为何除以n-1 ......................................................................................... 7
2.1.2 数据分布与标准差的关系 ................................................................................. 10
2.1.3 新的计算公式 ..................................................................................................... 11
2.1.4 代码实现 ............................................................................................................. 16
2.2 频数统计量 ..................................................................... 18
2.3 次序统计量 ......................................................................... 23
2.3.1 通过排序方法计算次序统计量 ......................................................................... 25
2.3.2 不需排序就可计算的次序统计量 ..................................................................... 29
2.3.3 基于频数信息计算次序统计量 ......................................................................... 31
2.3.4 中位数、众数和均值的关系 ............................................................................. 34
第3 章 单变量数据的分布 ................................................ 36
3.1 直方图 ........................................................................... 36
3.1.1 直方图的计算 ..................................................................................................... 39
3.1.2 算法实现 ............................................................................................................. 42
3.1.3 已知数据频数的情况下求直方图 ..................................................................... 49
3.1.4 日期类型直方图 ................................................................................................. 49
3.2 经验分布 ............................................................................... 57
3.3 近似分位数和近似百分位数 .................................................................. 61
3.4 PP、QQ 概率图 ........................................................................ 65
3.5 单变量的基本统计信息 ............................................................ 69
第4 章 多变量的数据特征 ............................................................ 77
4.1 协方差 ................................................................................................ 77
4.2 相关系数 .................................................................................. 79
4.3 协方差和相关系数的计算实现 .................................................................... 80
4.4 数据表的基本统计结果 .................................................................... 84
第5 章 数据探索 ............................................................... 88
5.1 扩展直方图 .................................................................................... 88
5.1.1 计算方法 ............................................................................................................. 90
5.1.2 代码实现 ............................................................................................................. 91
5.2 交叉表 ...................................................................................... 110
第6 章 极限定理 .......................................................................................... 116
6.1 大数定理 ...................................................................................... 116
6.2 中心极限定理 .............................................................................. 117
第7 章 常用的分布函数介绍 ........................................................ 123
7.1 基本定义 ............................................................................... 123
7.2 标准正态分布（Z 分布或U 分布） ............................................................................ 124
7.3  卡方分布（ 分布） ...................................................................... 129
7.4 学生T 分布 .................................................................................. 133
7.5 F 分布 .............................................................................. 139
第8 章 常用分布函数计算 .................................................. 145
8.1 函数定义 ................................................................................ 145
8.2 函数性质及相互间的关系 ....................................................................... 147
8.3 分布函数关系图 ............................................................................. 164
8.4 分布函数的计算 .............................................................................. 166
8.4.1  计算 .................................... 166
8.4.2  计算  .............................. 170
8.4.3  计算  .............................................. 173
8.4.4  计算 和  ............................................................................................. 176
8.4.5 其他函数的计算 ............................................................................................... 178
8.5 生成常用分布的随机数 .......................................................................... 180
第9 章 参数估计 ........................................................................... 187
9.1 点估计与区间估计 .......................................................................... 187
9.2 单个总体的参数估计 .................................................................................. 190
9.2.1 不同情况的参数估计表达式 ........................................................................... 190
9.2.2 单个总体参数估计的实现 ............................................................................... 191
9.3 两个总体的参数估计 .................................................................. 196
9.3.1 不同情况的参数估计表达式 ........................................................................... 196
9.3.2 两个总体参数估计的实现 ............................................................................... 199
第10 章 假设检验 ..................................................................... 207
10.1 基本概念 ............................................................................ 207
10.2 参数检验 ................................................................................... 209
10.3 单个总体参数的检验 ..................................................................... 212
10.3.1 各种情况下的检验方法 ................................................................................. 212
10.3.2 单个总体参数检验方法的实现 ..................................................................... 214
10.3.3 不同检验方法的选择 ..................................................................................... 223
10.4 两个总体参数的检验 ......................................................................... 227
10.4.1 各种情况下的检验方法 ................................................................................. 227
10.4.2 两个总体参数检验方法的实现 ..................................................................... 231
10.4.3 不同检验方法的选择 ..................................................................................... 237
第11 章 非参数检验 ............................................................................. 244
11.1 Pearson拟合优度 检验............................................................ 245
11.2 两个变量的列联表检验 .......................................................... 248
11.3 K-S 检验 ......................................................................................... 250
11.3.1 单样本K-S 检验 ............................................................................................. 251
11.3.2 双样本K-S 检验 ............................................................................................. 256
11.4 符号检验 ............................................................................... 258
11.5 秩统计量和秩检验方法 .................................................................... 260
11.5.1 Wilcoxon 秩和检验 ........................................................................................ 260
11.5.2 Wilcoxon 符号秩和检验 ................................................................................ 266
11.5.3 Kruskal-Wallis 检验 ........................................................................................ 268
11.5.4 Friedman 检验 ................................................................................................. 273
第12 章 方差分析 .................................................................... 277
12.1 单因素方差分析 ............................................................................... 278
12.1.1 计算流程 ......................................................................................................... 278
12.1.2 代码实现 ......................................................................................................... 280
12.1.3 方差分析与T 检验的关系 ............................................................................. 283
12.1.4 方差分析中的多重比较方法 ......................................................................... 285
12.2 双因素方差分析 ...................................................................... 289
12.2.1 无交互作用的双因素方差分析 ..................................................................... 289
12.2.2 有交互作用的双因素方差分析 ..................................................................... 295
第13 章 多元线性回归 ................................................................................. 302
13.1 数学模型 ................................................................................. 302
13.2 显著性检验 ................................................................................ 308
13.3 计算步骤 ............................................................... 309
13.4 代码实现 .......................................................................... 313
13.5 多重共线性 ........................................................................... 320
13.5.1 度量指标 ............................................................................ 320
13.5.2 代码实现 ......................................................................................................... 323
13.5.3 应用示例 ......................................................................................................... 328
13.6 逐步回归 ........................................................................................ 330
第14 章 主成分分析 ........................................................................................ 340
14.1 计算步骤 ............................................................................................ 342
14.2 代码实现 ...................................................................................... 345
14.3 应用举例 ...................................................................................... 350
第15 章 判别分析 ...................................................................... 359
15.1 距离判别 ....................................................................... 359
15.1.1 Mahalanobis 距离 ........................................................................................... 360
15.1.2 模型训练和预测 ............................................................................................. 361
15.2 Fisher 判别 .................................................................................... 364
15.3 Bayes 判别 ................................................................................ 369
15.3.1 朴素Bayes 判别 ............................................................................................. 369
15.3.2 模型训练和预测 ............................................................................................. 370
15.4 判别算法的综合模型 ................................................................ 377
15.5 应用举例 ................................................................................... 378
第16 章 模型评估曲线 ....................................................................... 383
16.1 相关概念 ......................................................................... 383
16.2 定义 ............................................................................................ 384
16.2.1 ROC 曲线 ........................................................................................................ 384
16.2.2 上升图和反馈率—精确率线 ......................................................................... 386
16.3 计算实现 ..................................................................................... 386
参考文献 .................................................................................... 391
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>重构大数据统计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>开源SOA
前言	I
致谢	III
关于本书	V
第一部分  历史和原理	1
第1章  SOA本质	3
1.1  分布式计算简史	4
1.1.1  基于RPC的方案存在的问题	5
1.1.2  理解SOAP的不同消息风格	6
1.1.3  SOA降临	6
1.2  Web服务为实现SOA所做的承诺	8
1.3  理解SOA的核心特征	9
1.3.1  服务接口/契约	10
1.3.2  服务透明性	10
1.3.3  服务的松耦合与无状态性	12
1.3.4  服务组合	13
1.3.5  服务注册和发布	14
1.4  SOA平台所用到的技术	14
1.4.1  业务流程管理	15
1.4.2  企业决策管理	16
1.4.3  企业服务总线	17
1.4.4  事件流处理器	19
1.4.5  Java消息服务	20
1.4.6  注册表	21
1.4.7  服务组件和组合服务	22
1.4.8  Web服务中介	23
1.5  引入SOA成熟度模型	24
1.6  小结	25
第2章  定义开放SOA平台	27
2.1  评估开源产品	28
2.2  选定BPM解决方案	29
2.2.1  BPM产品评估标准	30
2.2.2  开源BPM产品	31
2.2.3  选定BPM解决方案	32
2.2.4  介绍JBoss jBPM	33
2.3  选定企业决策管理解决方案	33
2.3.1  EDM产品评估标准	35
2.3.2  开源EDM产品	35
2.3.3  选定EDM	36
2.3.4  介绍JBoss Rules（Drools）	37
2.4  选定ESB	37
2.4.1  ESB产品评估标准	38
2.4.2  开源ESB产品	39
2.4.3  选定ESB	40
2.4.4  介绍作为轻量ESB的Synapse	41
2.5  选定ESP解决方案	42
2.5.1  什么是事件流处理？	43
2.5.2  介绍Esper	44
2.6  选定注册表	44
2.6.1  注册表评估标准	45
2.6.2  开源注册表产品	46
2.6.3  选定注册表	47
2.6.4  介绍WSO2 Registry	48
2.7  选定服务组件和组合框架	49
2.7.1  详细介绍服务组件架构	49
2.7.2  介绍Apache Tuscany	51
2.8  选定Web服务中介解决方案	51
2.9  小结	53

第二部分  装配组件和服务	55
第3章  使用Apache Tuscany创建服务	57
3.1  服务组件和组合是什么？	58
3.2  SCA装配模型	59
3.2.1  介绍组合定义文件	61
3.2.2  配置组件	65
3.2.3  定义服务	68
3.2.4  使用属性	70
3.2.5  实现选项	74
3.2.6  使用引用进行依赖注入	79
3.2.7  定义可用的绑定	81
3.3  小结	87
第4章  高级SCA	89
4.1  使用组件类型进行配置	89
4.2  SCA交互模型	91
4.2.1  使用对话	91
4.2.2  理解回调	93
4.3  脚本语言支持	98
4.3.1  创建Ruby组件	99
4.3.2  用Ruby方法签名创建Java接口	100
4.3.3  修改服务实现类	100
4.3.4  修改组合装配集	101
4.4  高级Tuscany/SCA	102
4.4.1  产品部署	102
4.4.2  介绍服务数据对象（SDO）	107
4.4.3  高级SDO特性	112
4.5  小结	114
第三部分  业务流程管理	115
第5章  jBPM入门	117
5.1  BPM：SOA的“秘制酱料”	119
5.2  JBoss jBPM的历史和概览	121
5.2.1  jBPM流程的开发生命周期	121
5.2.2  面向图谱的编程和jBPM	127
5.3  理解节点	127
5.3.1  Node节点类型	128
5.3.2  Task-node节点类型	129
5.3.3  State节点类型	129
5.3.4  Mail-node节点类型	130
5.3.5  Decision节点类型	132
5.3.6  Fork和join节点类型	132
5.4  使用转换	133
5.5  通过动作进行扩展	134
5.5.1  实例化动作类的属性	137
5.5.2  使用动作表达式	138
5.6  用事件捕获流程中的生命周期变更	140
5.7  使用变量管理上下文	142
5.8  小结	144
第6章  jBPM任务	145
6.1  什么是任务？	146
6.1.1  使用jBPM Console管理任务	146
6.1.2  task元素配置	148
6.2  任务用户管理	149
6.2.1  Actor和指派	149
6.2.2  理解泳道	151
6.3  使用定时器	152
6.4  任务控制器	155
6.5  使用任务API进行开发	156
6.5.1  找出jBPM实例中的流程	156
6.5.2  找出给定流程正在运行中的流程实例	158
6.5.3  找出流程实例中的开放任务	160
6.5.4  找出指派给某个用户的所有任务	162
6.5.5  找出某actor的所有可选任务	162
6.5.6  完成任务	163
6.6  小结	165
第7章  高级jBPM功能	167
7.1  jBPM重要的企业级特性	168
7.1.1  用于分组的超态	168
7.1.2  使用子流程管理复杂度	169
7.1.3  管理异常	171
7.1.4  用BeanShell编写脚本	173
7.1.5  审计日志	175
7.1.6  理解异步延续	178
7.2  与SCA/SDO集成	180
7.2.1  使用SCA客户端组件实现装配集成	181
7.2.2  服务化jBPM	187
7.2.3  开发ListProcesses服务操作	188
7.2.4  开发CreateProcessInstance服务操作	194
7.3  小结	197
第四部分  事件流处理、集成和中介	199
第8章  用Esper处理复杂事件	201
8.1  企业中的业务事件	202
8.2  理解事件	203
8.2.1  BAM和ESP——区别在哪里？	204
8.2.2  事件驱动架构和SOA	204
8.3  Esper是什么？	205
8.4  Esper起步	207
8.4.1  什么是事件对象？	208
8.4.2  定义并注册查询语句	208
8.4.3  指定监听器或订阅者	209
8.4.4  配置选项	209
8.5  EPL基础	210
8.5.1  查询事件	210
8.5.2  使用变量	214
8.5.3  理解视图	216
8.5.4  用命名窗口创建新的事件流	217
8.6  高级Esper	219
8.6.1  用函数进行扩展	219
8.6.2  应用事件模式	223
8.6.3  使用JDBC进行远程连接	225
8.7  服务化Esper	227
8.7.1  创建框架和组件	228
8.7.2  Esper服务和会话管理器	229
8.7.3  SCA composite文件	230
8.7.4  用soapUI进行测试	231
8.8  小结	232
第9章  企业级集成和ESB	233
9.1  ESB和SOA之间的关系	234
9.2  ESB的历史积淀	234
9.2.1  ESB核心功能	237
9.2.2  ESB适用的场合	243
9.2.3  不适用ESB的场合	245
9.3  Apache Synapse入门	248
9.3.1  协议适配器	249
9.3.2  面向消息的中间件	251
9.3.3  基于XML的消息传递	251
9.3.4  智能路由和分发	251
9.3.5  消息转换	251
9.3.6  任务/定时器	252
9.3.7  服务质量/Web中介	252
9.3.8  监控和管理	252
9.3.9  可扩展的API	252
9.4  基本的Apache Synapse消息和服务中介	253
9.4.1  简单的消息中介示例	253
9.4.2  简单的服务中介示例	258
9.5  小结	260
第10章  用Apache Synapse实现ESB	261
10.1  通过案例研究学习Synapse	262
10.1.1  第一阶段：使用错误处理、路由和传输切换的典型Web服务中介	262
10.1.2  第二阶段：协议/传输桥接和事件通知	262
10.1.3  第三阶段：使用任务、脚本和数据库集成	263
10.1.4  第四阶段：服务质量中介	263
10.2  第一阶段：简单的Web服务中介	264
10.2.1  销售订单发起	265
10.2.2  配置服务中介代理并进行验证	266
10.2.3  配置XSLT中介	268
10.2.4  从HTTP到JMS的传输切换	269
10.2.5  从JMS到HTTP的传输切换	272
10.3  第二阶段：VFS、CSV、电子邮件和消息监听	275
10.3.1  使用VFS传输	276
10.3.2  处理CSV文件	277
10.3.3  异常处理和SMTP传输	279
10.3.4  使用监听消息模式	280
10.4  第三阶段：任务、DB中介和迭代器	284
10.4.1  配置Synapse任务	285
10.4.2  使用迭代器中介拆分消息	287
10.4.3  使用DB中介	288
10.5  第四阶段：用Synapse做QoS	290
10.5.1  实现WS-Security	291
10.5.2  使用Synapse限流中介	293
10.6  小结	296
第五部分  企业决策管理	297
第11章  用JBoss Drools定义业务规则	299
11.1  理解业务规则	300
11.1.1  业务规则方法的好处和背后的驱动力	302
11.1.2  与SOA的关系	303
11.1.3  规则引擎的特征	303
11.1.4  业务规则管理系统	305
11.2  Drools入门	306
11.2.1  Hello World, Drools!	307
11.2.2  运行Hello World, Drools!	310
11.3  Drools规则语言（DRL）概览	312
11.4  Drools头元素	313
11.4.1  package	313
11.4.2  import	313
11.4.3  expander	313
11.4.4  global	313
11.4.5  function	314
11.5  在Drools中定义规则	314
11.5.1  用属性修改规则行为	315
11.5.2  规则陈述的条件段（when部分）	318
11.5.3  规则陈述的后果段（then部分）	325
11.6  在Drools中查询事实	327
11.7  用于规则协同的Drools RuleFlow	328
11.8  使用Drools规则语言之外的选择	330
11.8.1  使用DSL来满足业务用户编写需要	330
11.8.2  用决策表定义规则	333
11.9  小结	334
第12章  实现Drools	335
12.1  案例总览	336
12.1.1  定义DRL规则	338
12.1.2  以嵌入式引擎的方式运行	342
12.1.3  用DSL制作用户友好的规则	348
12.2  使用Drools Guvnor管理规则	349
12.2.1  Guvnor功能概览	350
12.2.2  用Guvnor编写规则	355
12.3  开发决策服务	359
12.3.1  什么是决策服务？	359
12.3.2  设计决策服务	361
12.3.3  用Tuscany和Drools实现决策服务	365
12.3.4  测试	371
12.4  小结	372
参考资源	373
索引	377
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>开源SOA
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>WCF服务编程
目录
Table of Contents
序言 I
前言 III
第1章  WCF基础 1
什么是WCF 1
服务 2
服务的执行边界 3
WCF与位置透明度 4
地址 4
TCP地址 5
HTTP地址 5
IPC地址 6
MSMQ地址 6
服务总线地址 6
契约 6
服务契约 7
托管 11
IIS 5/6 托管 11
自托管 12
WAS WAS托管 17
IIS/WAS里的自定义托管 18
Windows Server AppFabric 19
选择宿主 20
绑定 21
常用绑定 22
选择绑定 24
其他绑定 24
使用绑定 26
终结点 26
以管理方式配置终结点 27
以编程方式配置终结点 31
默认终结点 32
元数据交换 35
基于HTTP-GET的元数据 35
元数据交换终结点 38
元数据浏览器 44
行为配置的更多内容 46
客户端编程 47
生成代理 48
以管理方式配置客户端 52
以编程方式配置客户端 57
WCF提供的测试客户端 58
编程方式配置VS管理方式配置 60
WCF体系结构 61
宿主体系结构 62
使用通道 62
InProcFactory类 64
传输会话层 68
传输会话与绑定 68
传输会话终止 68
可靠性 69
绑定、可靠性和有序消息 70
配置可靠性 71
必备有序传递 72
第2章  服务契约 75
操作重载 75
契约继承 77
客户端契约层级 78
服务契约分解与设计 82
契约分解 82
分解准则 84
契约查询 85
以编程方式处理元数据 86
MetadataHelper类 88
第3章  数据契约 93
序列化 93
.NET序列化 94
序列化的数据契约 98
数据契约特性 99
导入数据契约 102
数据契约与Serializable特性 104
推断数据契约 105
组合数据契约 107
数据契约事件 108
共享数据契约 110
数据契约层级 111
已知类型 112
服务已知类型 114
多个已知类型 115
配置已知类型 116
数据契约解析器 117
Objects与接口 127
数据契约等效性 129
序列化顺序 130
版本控制 132
新增成员 133
缺失成员 133
版本控制往返 137
枚举 139
委托与数据契约 141
泛型 142
集合 145
具体集合类型 146
自定义集合 148
CollectionDataContract特性 148
引用集合 150
字典集合 150
第4章  实例管理 153
行为 153
单调服务 154
单调服务的优势 155
配置单调服务 156
单调服务与传输会话 157
设计单调服务 157
选择单调服务 160
会话服务 160
配置私有会话 160
会话与可靠性 165
会话ID 166
会话终止 167
单例服务 168
初始化单例服务 169
选择单例服务 171
操作分界 172
实例停止 174
配置为ReleaseInstanceMode.None 176
配置为ReleaseInstanceMode.BeforeCall 176
配置为ReleaseInstanceMode.AfterCall 177
配置为ReleaseInstanceMode.BeforeAndAfterCall 177
显式停止 178
使用实例停止 179
持久化服务 179
持久化服务与实例管理模式 180
实例ID与持久化存储区 180
显式实例ID 181
消息头里的实例ID 183
支持实例ID的上下文绑定 185
自动持久化行为 191
限流 196
配置限流 199
第5章  操作 205
请求/应答操作 205
单向操作 205
配置单向操作 206
单向操作与可靠性 207
单向操作与会话服务 207
单向操作和异常 208
回调操作 209
回调契约 210
客户端回调设置 211
服务端的回调调用 214
回调连接管理 217
双向代理与类型安全 219
回调契约层级 224
事件 225
流操作 229
I/O流 229
流操作与绑定 230
流操作与传输 231
第6章  错误 233
错误隔离和解耦 233
错误屏蔽 233
通道故障 234
错误传播 238
错误契约 239
错误调式 243
错误与回调 249
错误处理扩展 252
提供错误 252
处理错误 256
安装错误处理扩展 258
宿主与错误扩展 261
回调与错误扩展 264
第7章  事务 267
恢复的挑战 267
事务 268
事务资源 268
事务属性 269
事务管理 270
资源管理器 273
事务传播 273
事务流与绑定 273
事务流与操作契约 274
单调 276
事务协议与管理器 277
协议与绑定 277
事务管理器 278
事务管理器提升 280
Transaction类 281
环境事务 282
本地事务VS分布式事务 282
服务事务编程 283
设置环境事务 284
事务传播模式 285
投票与提交 292
事务隔离 295
事务超时 297
明确使用事务编程 298
TransactionScope类 299
事务流管理 300
非服务客户端 307
服务状态管理 308
事务边界 309
实例管理与事务 309
单调事务服务 310
会话事务服务 313
事务持久化服务 326
事务行为 328
事务单例服务 333
实例模式与事务 336
回调 337
回调事务模式 338
回调投票 340
使用事务型回调 340
第8章  并发管理 343
实例管理与并发 343
服务并发模式 344
ConcurrencyMode.Single 344
同步访问与事务 345
ConcurrencyMode.Multiple 345
ConcurrencyMode.Reentrant 348
实例与并发访问 350
单调服务 350
会话与单例服务 351
资源与服务 352
访问死锁 352
避免死锁 353
资源同步上下文 354
.NET同步上下文 354
UI同步上下文 357
服务同步上下文 362
托管在UI线程上 363
作为服务 368
UI线程与并发管理 371
自定义服务同步上下文 372
线程池同步化器 373
线程关联性 377
优先级处理 380
回调与客户端安全 383
使用ConcurrencyMode.Single回调 384
使用ConcurrencyMode.Multiple回调 385
使用ConcurrencyMode.Reentrant回调 385
回调与同步上下文 385
回调与UI同步上下文 386
回调自定义上下文 389
异步调用 393
异步机制的需求 393
基于代理的异步调用 394
异步调用 395
轮询或等待完成 398
完成回调 400
单向异步调用 404
异步错误调用 408
异步调用与事务 408
同步和异步调用 409
第9章  队列服务 411
无连接的服务与客户端 411
队列调用 412
队列调用架构 412
队列契约 413
配置与安装 414
事务 420
传递与回放 420
事务配置 422
非事务性队列 425
实例管理 425
单调队列服务 426
会话队列服务 427
单例服务 431
并发管理 432
限流 432
传送失败 433
死信队列 434
生存时间 434
配置死信队列 435
处理死信队列 436
回放失败 440
有害消息 441
MSMQ 4.0里的有害消息处理 441
MSMQ 3.0里的有害消息处理 446
队列调用与连接调用 446
要求队列化 447
应答服务 449
设计应答服务契约 450
客户端编程 453
队列服务端编程 455
应答服务端编程 457
事务 458
HTTP桥 461
设计桥 461
事务配置 462
服务端配置 463
客户端配置 464
第10章  安全 467
验证 467
授权 468
传输安全 468
传输安全模式 469
传输安全模式配置 470
Transport安全和凭据 473
Message安全和凭据 473
身份标识管理 474
整体策略 474
场景驱动方法 475
Intranet应用场景 476
安全Intranet绑定 476
约束消息保护 482
身份验证 484
身份标识 486
安全调用上下文 487
模拟 489
授权 496
身份标识管理 501
回调 502
Internet应用场景 503
安全Internet绑定 503
消息保护 505
验证 509
使用Windows凭据 511
使用ASP.NET provider 512
标识管理 520
B2B应用场景 520
保护B2B绑定 521
验证 521
授权 524
身份标识管理 525
宿主安全配置 525
匿名应用场景 526
确保匿名绑定的安全 526
验证 527
授权 527
标识管理 527
回调 528
无安全场景 528
无安全的绑定 528
验证 528
授权 529
标识管理 529
回调 529
场景总结 529
声明式安全框架 530
SecurityBehaviorAttribute 530
宿主端的声明式安全 538
客户端的声明式安全 539
安全审计 546
配置安全审计 547
声明式安全审计 549
第11章  服务总线 551
什么是中继服务 552
Windows Azure AppFabric服务总线 552
服务总线编程 553
中继服务地址 553
服务总线注册 556
服务总线浏览器 558
服务总线绑定 558
TCP中继绑定 559
WS 2007中继绑定 563
单向中继绑定 563
事件中继绑定 564
使用云作为拦截器 565
服务总线缓存 566
缓存VS队列 567
使用缓存 567
发送和检索消息 573
缓存服务 574
应答服务 582
服务总线验证 586
配置验证 587
共享安全验证 588
无验证 592
在服务总线上的元数据 594
传输安全 596
Transport安全 597
Message安全 597
中继绑定与传输安全 598
WS中继绑定与传输安全 604
单向中继绑定与传输安全 604
绑定与传输模式 605
简化传输安全 605
附录A  面向服务概述 613
软件工程简史 613
面向对象 614
面向组件 615
面向服务 617
面向服务的优势 618
面向服务的应用程序 619
面向对象的宗旨和原则 620
实践原则 620
可选原则 621
下一步是什么 622
面向服务的平台 623
附录B  消息头与上下文 625
消息头 625
客户端消息头交互 626
服务端消息头交互 628
封装消息头 628
简化客户端 631
上下文绑定 633
客户端上下文绑定交互 634
服务端上下文绑定交互 635
简化客户端 636
简化服务 639
创建自定义上下文绑定 640
附录C  服务发现 647
地址发现 647
服务配置 648
客户端步骤 652
域 654
简化服务发现 656
发展中的服务发现 665
通告 667
声明终结点 668
接收声明 669
简化声明 670
服务总线发现 674
解决方案架构 674
可发现的宿主 676
服务发现客户端 681
声明 686
元数据浏览器 693
附录D  发布-订阅服务 695
发布-订阅设计模式 696
订阅者类型 696
发布-订阅框架 697
管理临时订阅 697
管理持久订阅者 701
事件发布 704
管理持久订阅者 708
单例订阅者 710
队列化发布者与订阅者 711
使用服务总线发布-订阅 712
事件中继绑定 712
使用服务发现实现发布-订阅 719
DiscoveryPublishService<T>类 720
发布者 722
订阅者 723
More on DiscoveryPublishService<T> 723
附录E  通用拦截器 727
拦截服务操作 727
泛型调用者 728
安装拦截器 729
拦截客户端调用 732
跟踪拦截器 734
标识堆栈传播 738
保护调用堆栈拦截器 740
附录F  WCF编码规范 743
通用设计规范 743
设计要点 744
服务契约 744
数据契约 745
实例管理 746
操作与调用 746
错误 747
事务 748
并发管理 750
队列服务 750
安全 751
服务总线 752
附录G  ServiceModelEx分类 753
索引 755
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>WCF服务编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>未来架构：从服务化到云原生
第1章  云原生  1
1.1  互联网架构变迁  2
1.1.1  互联网架构的核心问题  2
1.1.2  从集中式架构到分布式架构  5
1.1.3  从分布式架构到云原生架构  10
1.2  什么是云原生  15
1.2.1  概述  15
1.2.2  云原生与十二要素  16
1.2.3  十二要素进阶  23
1.2.4  云原生与CNCF  24
第2章  远程通信  41
2.1  通信方式  41
2.1.1  通信协议  42
2.1.2  I/O模型  51
2.1.3  Java中的I/O  53
2.2  序列化  66
2.2.1  文本序列化  67
2.2.2  二进制Java序列化  68
2.2.3  二进制异构语言序列化  71
2.3  远程调用  78
2.3.1  核心概念  78
2.3.2  Java远程方法调用  79
2.3.3  异构语言RPC框架gRPC  82
第3章  配置  89
3.1  本地配置  89
3.2  配置集中化  90
3.3  配置中心和注册中心  91
3.4  读性能  92
3.5  变更实时性  93
3.6  可用性  94
3.7  数据一致性  96
第4章  服务治理  97
4.1  服务发现  97
4.1.1  服务发现概述  97
4.1.2  ZooKeeper  100
4.1.3  Eureka  109
4.2  负载均衡  112
4.2.1  服务端负载均衡  112
4.2.2  客户端负载均衡  115
4.3  限流  118
4.3.1  限流算法  119
4.3.2  限流实现方案  121
4.3.3  限流的维度与粒度  129
4.4  熔断  131
4.4.1  概述  131
4.4.2  熔断器模式  132
4.4.3  Hystrix  133
第5章  观察分布式服务  135
5.1  层次划分  136
5.2  核心概念  136
5.3  分布式追踪  138
5.3.1  概述  138
5.3.2  常见的开源解决方案  139
5.4  应用性能管理与可观察性平台  140
5.5  Apache SkyWalking  142
5.5.1  项目定位  142
5.5.2  SkyWalking 5核心架构  143
5.5.3  SkyWalking 5公开案例  146
5.5.4  SkyWalking 6可观察性分析平台  147
第6章  侵入式服务治理方案  157
6.1  Dubbo  157
6.1.1  Dubbo概述  158
6.1.2  核心流程  160
6.1.3  注册中心  160
6.1.4  负载均衡  162
6.1.5  远程通信  163
6.1.6  限流  164
6.1.7  治理中心  165
6.1.8  监控中心  165
6.1.9  DubboX的扩展  166
6.2  Spring Cloud  168
6.2.1  概述  168
6.2.2  开发脚手架Spring Boot  172
6.2.3  服务发现  174
6.2.4  负载均衡  176
6.2.5  熔断  178
6.2.6  远程通信  179
第7章  云原生生态的基石Kubernetes  181
7.1  Kubernetes架构  182
7.2  分层设计理念及架构模型  183
7.3  设计哲学  184
7.4  Kubernetes中的原语  185
7.4.1  Kubernetes中的对象  185
7.4.2  对象的期望状态与实际状态  186
7.4.3  描述Kubernetes对象  187
7.4.4  服务发现与负载均衡  188
7.4.5  安全性与权限管理  189
7.4.6  Sidecar设计模式  190
7.5  应用Kubernetes  190
7.6  Kubernetes与云原生生态  192
7.6.1  下一代云计算标准  192
7.6.2  当前存在的问题  192
7.6.3  未来趋势  193
第8章  跨语言服务治理方案Service Mesh  195
8.1  Service Mesh概述  195
8.1.1  Service Mesh的由来  195
8.1.2  Service Mesh的定义  196
8.1.3  Service Mesh详解  197
8.2  Service Mesh演进历程  200
8.2.1  远古时代的案例  200
8.2.2  微服务时代的现状  201
8.2.3  侵入式框架的痛点  202
8.2.4  解决问题的思路  206
8.2.5  Proxy模式的探索  207
8.2.6  Sidecar模式的出现  208
8.2.7  第一代Service Mesh  209
8.2.8  第二代Service Mesh  210
8.3  Service Mesh市场竞争  212
8.3.1  Service Mesh的萌芽期  212
8.3.2  急转直下的Linkerd  212
8.3.3  波澜不惊的Envoy  214
8.3.4  背负使命的Istio  214
8.3.5  背水一战的Buoyant  215
8.3.6  其他参与者  217
8.3.7  Service Mesh的国内发展情况  219
8.4  Istio  220
8.4.1  Istio概述  220
8.4.2  架构和核心组件  222
第9章  云原生数据架构  232
9.1  关系型数据库尚能饭否  232
9.1.1  优势  233
9.1.2  不足  234
9.2  未达预期的NoSQL  235
9.2.1  键值数据库  235
9.2.2  文档数据库  236
9.2.3  列族数据库  236
9.3  冉冉升起的NewSQL  237
9.3.1  新架构  238
9.3.2  透明化分片中间件  238
9.3.3  云数据库  239
9.4  云原生数据库中间件的核心功能  239
9.4.1  数据分片  239
9.4.2  分布式事务  258
9.4.3  数据库治理  265
第10章  分布式数据库中间件生态圈ShardingSphere  267
10.1  缘起  267
10.1.1  内部应用框架  268
10.1.2  开源历程  269
10.2  核心功能  271
10.2.1  数据分片  272
10.2.2  分布式事务  301
10.2.3  数据库治理  307
10.3  Sharding-JDBC  310
10.3.1  概述  310
10.3.2  使用说明  311
10.4  Sharding-Proxy  316
10.4.1  概述  316
10.4.2  使用说明  317
10.5  Database Mesh  317
10.5.1  概述  317
10.5.2  Service Mesh回顾  318
10.5.3  Database Mesh与Service Mesh的异同  319
10.5.4  Sharding-Sidecar  320
10.6  未来规划  321
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>未来架构：从服务化到云原生
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Storm实时数据处理
第1章　搭建开发环境 / 1
1.1　简介 / 1
1.2　搭建开发环境  / 1
1.3　分布式版本控制 / 3
1.4　创建“Hello World”Topology / 6
1.5　创建Storm集群——配置机器 / 12
1.6　创建Storm集群——配置Storm / 18
1.7　获取基本的点击率统计信息 / 23
1.8　对Bolt进行单元测试 / 31
1.9　实现集成测试 / 34
1.10　将产品部署到集群 / 37
第2章　日志流处理 / 38
2.1　简介 / 38
2.2　创建日志代理 / 38
2.3　创建日志Spout / 40
2.4　基于规则的日志流分析 / 45
2.5　索引与持久化日志数据 / 49
2.6　统计与持久化日志统计信息 / 53
2.7　为日志流集群创建集成测试 / 55
2.8　创建日志分析面板 / 59
第3章　使用Trident计算单词重要度 / 71
3.1　简介 / 71
3.2　使用Twitter过滤器创建URL流 / 71
3.3　从文件中获取整洁的词流 / 76
3.4　计算每个单词的相对重要度 / 81
第4章　分布式远程过程调用 / 85
4.1　简介 / 85
4.2　通过DPRC实现所需处理流程 / 85
4.3　对Trident Topology进行集成测试 / 90
4.4　实现滚动窗口Topology / 95
4.5　在集成测试中模拟时间 / 98
第5章　在不同语言中实现Topology / 100
5.1　简介 / 100
5.2　在Qt中实现多语言协议 / 100
5.3　在Qt中实现SplitSentence Bolt / 105
5.4　在Ruby中实现计数 Bolt / 108
5.5　在Clojure中实现单词计数Topology / 109
第6章　Storm与Hadoop集成 / 113
6.1　简介 / 113
6.2　在Hadoop中实现TF-IDF算法 / 115
6.3　持久化来自Storm的文件 / 121
6.4　集成批处理与实时视图 / 122
第7章　实时机器学习 / 127
7.1　简介 / 127
7.2　实现事务性Topology / 129
7.3　在R中创建随机森林分类模型 / 134
7.4　基于随机森林的事务流业务分类 / 143
7.5　在R中创建关联规则模型 / 149
7.6　创建推荐引擎 / 152
7.7　实时在线机器学习 / 157
第8章　持续交付 / 162
8.1　简介 / 162
8.2　搭建CI服务器 / 162
8.3　搭建系统环境 / 164
8.4　定义交付流水线 / 166
8.5　实现自动化验收测试 / 170
第9章　在AWS上部署Storm / 177
9.1　简介 / 177
9.2　使用Pallet在AWS上部署Storm / 177
9.3　 搭建虚拟私有云 / 181
9.4　使用Vagrant在虚拟私有云上部署Storm / 189
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Storm实时数据处理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ELK stack权威指南
第部分 Logstash
第1章入门示例 3
1.1下载安装 3
1.2HellOWbrld 5
1.3配置语法 7
1.3.1语法 8
1.3.2命令行参数 10
1.4插件安装 1l
1.5长期运行方式 12
第2章插件配置 15
2.1输入插件 15
2.1.1标准输入 16
2.1.2文件输入 17
2.1.3 TCP输入 18
2.1.4 syslog输入 19
2.1.5 collectd输入 21
2.2编解码配置 23
2.2.1 JSON编解码 24
2.2.2多行事件编码 -25
2.2.3网络流编码 26
2.3过滤器配置 _28
2.3.1 date时间处理 28
2.3.2 grok正则捕获 30
2.3.3 GeoIP地址查询 33
2.3.4 JSON编解码 34
2.3.5 key-value切分 35
2.3.6 metrics数值统计 36
2.3.7 mutate数据修改 37
2.3.8随心所欲的Ruby处理 42
2.3.9 split拆分事件 _43
2.3.10 elapsed 43
2.4输出插件 44
2.4.1输出到Elasticsearch 44
2.4.2发送email 49
2.4.3调用系统命令执行 ’50
2.4.4保存成文件 50
2.4.5报警发送到Nagios 51
2.4.6 statsd 52
2.4.7标准输出stdout 54
?2.4.8 TCP发送数据 55
2.4.9输出到HDFS 55
第3章场景示例 57
3.1 Nginx访问日志 57
3.1.1 grok处理方式 57
3.1.2 split处理方式 -58
3.1.3 json格式 -6l
3.1.4 syslog方式发送 62
3.2 Nginx错误日志 62
3.3 Postfix日志 63
3.4 0ssec日志 64
3.4.1配置所有Ossec agent采用
syslog输出 -64
3.4.2配置Logstash 65
3.4.3推荐Kibana仪表盘 65
3.5Windows系统日志 67
3.5.1采集端配置 67
3.5.2接收解析端配置 68
3.6 Java日志 69
3.6.1 Log4J配置 70
3.6.2 Logstash配置 70
3.6.3异常堆栈测试验证 70
3.6.4 JSON Event layout 71
3.7 MySQL慢查询日志 -73
3.8 Docker日志 74
3.8.1记录到主机磁盘 75
3.8.2通过logspout收集 75
第4章性能与监控 77
4.1性能测试 77
4.1.1配置示例 77
4.1.2使用方式 78
4.1.3额外的话 79
4.2监控方案 79
4.2.1 logstash-input-heartbeat心跳
检测方式 80
4.2.2 JMX启动参数方式 8l
第5章扩展方案 83
5.1通过Redis队列扩展 84
5.1.1读取Redis数据 84
5.1.2采用list类型扩展Logstash''''85
5.1.3输出到Redis 86
5.2通过Kafka队列扩展 87
5.2.1 Logstashl.4版本插件的安装 88
5.2.2 Input配置 88
5.2.3 0utput配置 90
5.3 logstash-forwarder'''. 91
5.3.1 Indexer端配置 91
5.3.2 Shipper端配置 92
5.3.3 AIX上的logstash-forwarder-
java -‘93
5.4 Rsyslog''''' 95
5.4.1常用模块介绍 95
5.4.2与Logstash合作 96
5.4.3 Mmextemal模块 ’97
5.5 NxlOg ‘99
5.6 Heka 101
5.7 Fluentd 102
5.7.1配置示例 103
5.7.2 Fluentd插件 -104
?5.8 MeSSage::PaSSing 104
第6章Logstash源码解析 --107
6.2.1 Input中的 Codec ll0
6.2.2 0utput中的 Worker 111
第7章插件开发 113
7.1插件格式 113
7.2插件的关键方法 114
7.3插件打包 115
7.4 Filter插件开发示例 116
7.4.1 mmdb数据库的生成方法 116
7.4.2 LogStash::Filters::Mmdb实现117
7.4.3 logstash-filter-mmdb打包 l l 9
7.5 Input插件开发示例 119
7.5.1 FileWatch模块原理 120
7.5.2 LogStash::Inputs::Utmp实现 l21
7.6 0utput插件开发示例 124
第二部分 Elasticsearch
第8章架构原理 129
8.1准实时索引的实现 129
8.1.1动态更新的Lucene索引 129
8.1.2利用磁盘缓存实现的
准实时检索 l30
8.1.3 translog提供的磁盘同步
控制 131
8.2 segmentmerge的影响 132
8.2.1归并线程配置 133
8.2.2归并策略 134
8.2.3 0ptimize接口 134
8.3 routing和replica的读写过程 134
8.3.1路由计算 134
8.3.2副本致性 135
8.4 shard的allocate控制 136
8.4.1 reroute接口 138
8.4.2冷热数据的读写分离 138
8.5 自动发现的配置 139
8.5.1 multicast方式 140
8.5.2 unicast方式 l40
第9章数据接口用例 141
9.1增删改查操作 141
9.2搜索请求 143
9.2.1全文搜索 143
9.2.2聚合请求 145
9.3脚本 147
9.3.1动态提交 147
9.3.2固定文件 l47
9.3.3其他语言 148
9.4重建索引 148
9.4.1 Perl客户端 149
9.4.2用Logstash重建索引 l49
9.5 Spark Streaming交互 150
第10章性能优化 l53
10.1 bulk提交 153
10．1.1bulk大小 154
第11章测试和扩展方案167
第12章映射与模版的订制181
第13章监控方案189
第14章Elasticsearch在运维监控领域的其他应用215
第三部分Kibana
第15章Kibana的产品对比231
第16章Kibana3 235
第17章Kibana3 源码解析297
第18章Kibana4 319
第19章Kibana4源码解析363
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ELK stack权威指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>消息设计与开发
第1章  消息技术概论/1  1.1  TCP/IP简介/1    1.1.1  基本知识/1    1.1.2  TCP与UDP/2    1.1.3  TCP/IP套接口编程基础/4  1.2  什么是消息/12  1.3  最原始的消息设计/14    1.3.1  原始消息的设计与实现/14    1.3.2  原始消息设计方法分析/17  1.4  消息技术的内容/19  1.5  消息技术的分类/21    1.5.1  基于传输协议分类/22    1.5.2  基于消息传输格式分类/24  1.6  关于本书内容的说明/25  1.7  消息体系的组成/26  1.8  本书相关术语定义/27  1.9  本章小结/28第一大类  基于字节流的消息技术/29第2章  消息表示法/30  2.1  消息表示需求分析/30    2.1.1  需求分析/30    2.1.2  消息表示法的内容/32  2.2  消息的总体结构/32    2.2.1  消息组成要素/32    2.2.2  代码层面消息结构/33    2.2.3  传输层面（流化后）消息结构/35  2.3  消息头/36    2.3.1  消息版本号/36    2.3.2  消息序列号/38    2.3.3  消息延续标志/38    2.3.4  消息数据长度/39  2.4  消息类型块/40    2.4.1  消息响应与功能类型/41    2.4.2  回复消息错误/41    2.4.3  消息远程调用操作类型/43    2.4.4  消息处理标志/43    2.4.5  消息体长度/44    2.4.6  消息类型块的组成标准/45  2.5  消息体/46    2.5.1  消息体构成/46    2.5.2  消息体公共接口定义/49    2.5.3  消息描述信息定义/50    2.5.4  消息本体数据/51    2.5.5  消息列表数据/52    2.5.6  消息创成接口/52    2.5.7  消息流化接口/53  2.6  消息表示的面向对象实现/54    2.6.1  消息头/55    2.6.2  消息类型块/56    2.6.3  消息体/58    2.6.4  消息表示法代码结构/75  2.7  本章小结/76第3章  消息的流化/77  3.1  什么是流化/77  3.2  流化表示法综述/78    3.2.1  自定义字节流/78    3.2.2  XDR表示法/79    3.2.3  平台无关/83  3.3  消息流化的基本元素/90    3.3.1  流化的基本元素/90    3.3.2  数值型/91    3.3.3  二进制字节流/94  3.4  流化的面向对象实现/95    3.4.1  消息流化的实现过程/96    3.4.2  XDR方法类/96  3.5  本章小结/102第4章  消息注册/103  4.1  消息注册综述/103    4.1.1  消息注册的目的/103    4.1.2  消息注册的实现/104    4.1.3  消息注册的内容/104  4.2  消息创建接口/105    4.2.1  消息创建接口的用途/105    4.2.2  消息创建接口的面向对象实现/106  4.3  消息操作类型接口/107    4.3.1  消息操作类型接口的用途/107    4.3.2  消息操作类型接口的面向对象实现/108  4.4  回调函数注册/108  4.5  本章小结/109第5章  单消息的发送与接收/111  5.1  单消息发送与接收的内容/111  5.2  消息发送/112    5.2.1  消息发送触发的假设/112    5.2.2  消息发送预处理/113    5.2.3  消息发送过程/116    5.2.4  消息发送的面向对象实现/117  5.3  消息接收/124    5.3.1  消息接收触发的假设/124    5.3.2  消息接收过程/126    5.3.3  消息接收中的消息回复/127    5.3.4  消息接收的面向对象实现/129  5.4  消息加密与解密/143    5.4.1  消息加解密设计/143    5.4.2  套接口层面的接口调用/144    5.4.3  消息加解密的面向对象实现/146    5.4.4  算法库选择/148  5.5  套接口控制/148    5.5.1  套接口控制的内容/149    5.5.2  发送与接收管理/149    5.5.3  缓冲区管理/157    5.5.4  套接口选择器/162  5.6  UDP消息的发送与接收/162  5.7  本章小结/164第6章  单连接上的消息管理/165  6.1  TCP连接与消息管理类/165  6.2  消息发送与接收管理/168    6.2.1  连接管理线程/168    6.2.2  消息发送类型/169    6.2.3  消息发送控制/176    6.2.4  发送与接收协调/180  6.3  消息请求处理管理/182  6.4  消息队列管理/183  6.5  消息生命周期管理/185  6.6  本章小结/187第7章  单连接上的消息请求处理/188  7.1   请求处理的触发/188    7.1.1  原始设计与分析/188    7.1.2  设计改进与请求处理线程/189    7.1.3  TCP连接与请求处理线程/190  7.2  回调函数注册与消息请求管理类/191  7.3  请求处理过程/193    7.3.1  总体流程/193    7.3.2  请求处理中的消息回复/194  7.4  回调函数调用再探/196    7.4.1  原始设计/196    7.4.2  设计改进与用户执行线程/197  7.5  本章小结/198第8章  多连接下的消息体系管理/199  8.1  多连接消息体系管理综述/199    8.1.1  需求分析/199    8.1.2  原始设计与分析/201    8.1.3  多连接管理设计的内容/202  8.2  连接管理线程池/203    8.2.1  连接管理设计/203    8.2.2  连接管理线程池/204    8.2.3  连接管理的面向对象实现/205  8.3  请求处理线程池/210    8.3.1  请求处理管理/210    8.3.2  请求处理线程池/212    8.3.3  请求处理管理的面向对象实现/213    8.3.4  一个特殊问题的讨论/215  8.4  连接清理线程池/216    8.4.1  连接清理管理/216    8.4.2  连接清理线程池/218    8.4.3  连接清理管理的面向对象实现/219  8.5  套接口选择器(TCP连接管理类选择)/222    8.5.1  套接口选择器设计/222    8.5.2  套接口选择器的面向对象实现/225  8.6  KEEPALIVE管理/232    8.6.1  KeepAlive线程/232    8.6.2  KeepAlive的面向对象实现/233  8.7  多连接管理总体控制/237    8.7.1  主管类/237    8.7.2  多连接管理代码结构/240  8.8  本章小结/241第9章  消息体系中的本地化/242  9.1  什么是本地化/242  9.2  本地化方法综述/243  9.3  消息体系中的本地化实现/245    9.3.1  设计思路/245    9.3.2  消息体系的本地化实现/245  9.4  本章小结/250第10章  消息的制造/251  10.1  综述/251  10.2  消息手工制造/252  10.3  消息生成器/253  10.4  消息版本管理/253  10.5  消息克隆(CLONE)/255  10.6  本章小结/257第二大类  基于XML的消息技术/259第11章  XML消息表示法/260  11.1  XML消息表示概述/260    11.1.1  XML消息的特点/260    11.1.2  XML消息表示需求分析/261  11.2  XML消息总体结构/261    11.2.1  XML消息表示总体设计/261    11.2.2  XML消息模板与消息注册/263    11.2.3  XML消息实例/267  11.3  XML消息中的各种数据类型/268    11.3.1  整型、浮点型与字符串型/269    11.3.2  对象/270    11.3.3  数组/271  11.4  二进制数据处理/272  11.5  本章小结/273第12章  XML消息的发送与接收/274  12.1  单连接上的消息发送与接收/274    12.1.1  套接口层的发送与接收/274    12.1.2  消息实例的生成与解析/274  12.2  多连接管理/280  12.3  XML消息的加密、解密/282  12.4  本章小结/283第13章  XML消息的处理/284  13.1  消息处理模板/284    13.1.1  消息处理模板的概念/284    13.1.2  消息处理模板的初始化/285  13.2  XML消息处理过程/288    13.2.1  总体设计/288    13.2.2  接口匹配/288    13.2.3  参数填充/289    13.2.4  动作执行/291    13.2.5  回复生成与返回/291  13.3  XML消息处理路径/292    13.3.1  数据库或函数/293    13.3.2  本地链接库/293    13.3.3  Web Service/295  13.4  本章小结/296第14章  高级功能/297  14.1  消息转发/297  14.2  消息链接/298  14.3  大消息处理/299  14.4  本章小结/299后记/301
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>消息设计与开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 企业设计模式
目录:
第1章 软件模式介绍 1
第2章 UML概述 5
第3章 软件生命周期 24
第4章 事务处理模式 26
第5章 分布式体系结构模式 59
第6章 分布式计算模式 96
第7章 并发模式 228
第8章 时间模式 289
第9章 数据库模式 329
附录A 持久框架 375
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 企业设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高性能嵌入式计算
出版者的话译者序前言本书赞誉第1章 嵌入式计算  1.1 高性能嵌入式计算的前景  1.2 示例应用    1.2.1 无线电和网络    1.2.2 多媒体    1.2.3 车辆控制和操作    1.2.4 传感器网络  1.3 设计目标  1.4 设计方法    1.4.1 基本设计方法    1.4.2 嵌入式系统设计流程    1.4.3 基于标准的设计方法    1.4.4 设计检验和确认    1.4.5 方法论    1.4.6 算法与体系结构联合开发  1.5 计算模型    1.5.1 为什么研究计算模型    1.5.2 有限与无限状态    1.5.3 控制流和数据流模型    1.5.4 并行和通信    1.5.5 并行的来源和使用  1.6 可靠性、安全与防卫    1.6.1 为什么需要可靠的嵌入式系统    1.6.2 可靠系统设计的基础    1.6.3 新式攻击和对策  1.7 电子消费品体系结构    1.7.1 蓝牙    1.7.2 WiFi    1.7.3 联网的电子消费品    1.7.4 高层次服务  1.8 小结  问题  实验练习第2章 CPU  2.1 介绍  2.2 处理器的比较    2.2.1 评价处理器    2.2.2 处理器的分类    2.2.3 嵌入式处理器与通用处理器  2.3 RISC处理器与数字信号处理器    2.3.1 RISC处理器    2.3.2 数字信号处理器  2.4 并行执行机制    2.4.1 超长指令字处理器    2.4.2 超标量处理器    2.4.3 SIMD与向量处理器    2.4.4 线程级并行    2.4.5 处理器资源利用率  2.5 性能可变处理器体系结构    2.5.1 电压和频率的动态调整    2.5.2 “优于最坏情况”设计  2.6 处理器存储层次结构    2.6.1 存储组件模型    2.6.2 寄存器堆    2.6.3 cache    2.6.4 片上SRAM  2.7 附加的CPU技术    2.7.1 编码压缩    2.7.2 代码和数据压缩    2.7.3 低功耗总线编码    2.7.4 安全性  2.8 CPU模拟    2.8.1 基于执行日志的分析    2.8.2 直接执行    2.8.3 微系统结构建模模拟器  2.9 CPU的自动化设计    2.9.1 可配置处理器    2.9.2 指令集综合  2.10 小结  问题  实验练习第3章 编程  3.1 介绍  3.2 代码生成和后端编译    3.2.1 指令模型    3.2.2 寄存器分配    3.2.3 指令选择和调度    3.2.4 代码放置    3.2.5 编程环境  3.3 面向内存的优化    3.3.1 循环变换    3.3.2 全局优化    3.3.3 缓冲区、数据传输和存储管理    3.3.4 面向cache和片上SRAM的优化    3.3.5 面向主存的优化  3.4 程序性能分析    3.4.1 性能模型    3.4.2 路径分析    3.4.3 路径计时  3.5 计算与编程模型    3.5.1 面向中断的语言    3.5.2 数据流语言    3.5.3 面向控制的语言    3.5.4 Java    3.5.5 计算异构模型  3.6 小结  问题  实验练习第4章 进程和操作系统  4.1 介绍  4.2 实时进程调度    4.2.1 预备知识    4.2.2 实时调度算法    4.2.3 动态电压调整的调度    4.2.4 性能估算  4.3 语言和调度  4.4 操作系统的设计    4.4.1 嵌入式操作系统中的内存管理    4.4.2 实时操作系统的结构    4.4.3 操作系统开销    4.4.4 对调度的支持    4.4.5 进程间通信机制    4.4.6 电源管理    4.4.7 嵌入式设备中的文件系统  4.5 验证  4.6 小结  问题  实验练习第5章 多处理器体系结构  5.1 介绍  5.2 为什么需要嵌入式多处理器    5.2.1 嵌入式系统的需求    5.2.2 性能和能耗    5.2.3 专用性和多处理器    5.2.4 可扩展性和效率  5.3 多处理器的设计技巧    5.3.1 多处理器设计方法    5.3.2 多处理器的建模和模拟  5.4 多处理器的结构  5.5 处理单元  5.6 互连网络    5.6.1 模型    5.6.2 网络拓扑    5.6.3 路由和流控制    5.6.4 片上网络  5.7 内存系统    5.7.1 传统的并行内存系统    5.7.2 内存模型    5.7.3 异构内存系统    5.7.4 一致性并行内存系统  5.8 物理分布式系统和网络    5.8.1 时间触发的结构    5.8.2 FlexRay    5.8.3 飞机网络  5.9 多处理器的设计方法和算法  5.10 小结  问题  实验练习第6章 多处理器软件  6.1 简介  6.2 嵌入式多处理器软件的不同之处  6.3 实时多处理器操作系统    6.3.1 操作系统的角色    6.3.2 多处理器调度    6.3.3 动态任务的调度  6.4 嵌入式多处理器系统服务与中间件    6.4.1 基于标准的服务    6.4.2 片上系统服务    6.4.3 服务质量  6.5 设计验证  6.6 小结  问题  实验练习第7章 硬件/软件协同设计  7.1 简介  7.2 设计平台  7.3 性能分析    7.3.1 高层综合    7.3.2 加速器评估  7.4 硬件/软件协同综合算法    7.4.1 程序表示    7.4.2 平台描述    7.4.3 模板驱动的综合算法    7.4.4 通用多处理器的协同综合    7.4.5 多对象优化    7.4.6 控制和I/O综合    7.4.7 内存系统    7.4.8 可重构系统的协同综合  7.5 硬件/软件协同模拟  7.6 小结  问题  实验练习术语表参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高性能嵌入式计算
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Learning Hbase中文版
第 1 章	了解 HBase 生态系统	1
基于 Hadoop 的 HBase 架构	2
RDBMS 和 HBase 的架构对比	3
HBase 的特征	3
HBase 在 Hadoop 生态系统中的位置	4
HBase 中的数据表示	5
Hadoop	6
HBase 与关系型数据库的功能对比	8
行存储数据库的逻辑展现	9
列存储数据库的逻辑展现	9
HBase 的内部存储架构	11
开始使用 HBase	11
HBase 是何时出现的	11
HBase 的组件和功能	14
ZooKeeper	14
谁在用 HBase？为什么要用？	19
什么时候考虑使用 HBase？	20
什么时候不使用 HBase？	21
了解一些开源的 HBase 工具	21
Hadoop 和 HBase 版本兼容性对照表	22
HBase 的应用	23
HBase 的优点和缺点	24
小结	25
第 2 章	开启 HBase 之旅	26
深入理解 HBase 的组件	27
HFile	27
Region	27
可扩展性——理解纵向扩展和横向扩展的过程	29
读写周期	32
Write-Ahead Logs	33
MemStore	33
HBase 内部管理	34
合并	34
Region 分裂	35
Region 分配	36
Region 合并	37
RegionServer 故障转移	37
HBase 的删除请求	37
读写周期	37
可用的 HBase 发行版本列表	38
HBase 的必备条件和容量规划	39
DNS 正向解析	39
DNS 反向解析	40
SSH	41
小结	45
第 3 章	搭建 HBase	46
在 Ubuntu 上下载 Java	46
主机配置	52
基于主机文件	52
基于命令	52
基于文件	52
基于 DNS	54
安装和配置 SSH	54
在 Ubuntu/Red Hat/CentOS 上安装 SSH	55
配置 SSH	55
安装和配置 NTP	56
容量规划	57
安装和配置 Hadoop	58
core-site.xml	63
hdfs-site.xml	63
yarn-site.xml	65
mapred-site.xml	66
hadoop-env.sh	67
yarn-env.sh	67
Hadoop 的启动步骤	67
配置 Apache HBase	69
在单机模式中配置 HBase	69
在分布式模式中配置 HBase	70
安装和配置ZooKeeper	74
安装 Cloudera 版本的Hadoop 和 HBase	76
下载 RPM 包	76
简易安装 Cloudera	77
安装 Hadoop 和 MapReduce 包	77
在 Windows 上安装 Hadoop	78
小结	81
第 4 章	优化 HBase/Hadoop 集群	82
Hadoop/HBase 集群的类型	82
CDH 集群的推荐配置	84
容量规划	85
优化 Hadoop	86
通用优化技巧	86
优化 Java GC	86
优化 Linux 操作系统	87
优化 Hadoop 参数	87
优化 MapReduce	88
优化 HBase	91
Hadoop	91
内存	93
Java	93
操作系统	94
HBase	94
优化 ZooKeeper	96
Hadoop 中的重要配置文件	96
HBase 中的重要配置文件	97
小结	98
第 5 章	HBase 的存储、框架以及数据类型	99
HBase 的数据类型	100
HBase中的数据存储——逻辑视图 vs. 真实物理视图	101
命名空间	102
HBase 服务	103
行键（Row key）	104
列族（Column family）	104
列（Column）	104
单元格（Cell）	104
版本（Version）	104
时间戳（Timestamp）	105
数据模型的操作	105
读（Get）	105
写（Put）	106
扫描（Scan）	106
删除（Delete）	106
版本和原因	107
决定版本数量	108
版本的下界	108
版本的上界	108
模式设计	109
表类型的设计	113
短宽和高瘦设计模式的好处	114
复合键设计	115
在 HBase 中计算存储的数据大小	118
小结	119
第 6 章	HBase 集群运维与故障处理	120
Hadoop shell 命令	121
Hadoop shell 命令的类型	121
HBase shell 命令	140
HBase 管理工具	149
hbck —— HBase 检查	149
HBase 健康检查脚本	151
写 HBase shell 脚本	151
使用 Hadoop 工具或者 JAR	151
用 Hive 连接 HBase	153
HBase region 管理	155
压缩	155
合并	155
HBase 节点管理	155
服役	155
退役	156
实现安全性	157
安全访问	157
Kerberos KDC	157
客户端的安全配置	158
服务器端的安全配置	159
简单的安全	160
客户端配置	161
标签的安全特性	162
HBase 的访问控制	163
使用标签的单元格访问	168
配置 ZooKeeper 安全	169
HBase 常见错误的故障排查和相关说明	170
集群失败的可能情况	171
监控 HBase 的健康状况	172
小结	175
第 7 章	HBase 脚本编程	176
HBase 中的备份与恢复技术	176
离线备份/full-shutdown 备份	177
在线备份	178
Windows 上的 HBase	185
在 HBase 中进行脚本编程	185
.irbrc 文件	187
获取时间戳	188
开启调试	189
在 HBase 中开启 SQL	189
参与 HBase	190
小结	190
第 8 章	HBase Java 编程	191
准备开发环境	192
构建 Java 客户端程序	192
数据类型	196
数据模型的 Java 操作	196
读操作	196
写操作	204
修改操作	206
HBase 过滤器	208
过滤器类型	209
客户端 API	214
小结	215
第 9 章	HBase Java 高级编程	216
接口、类和异常	216
管理任务编程	218
数据操作代码	224
MapReduce 和 HBase	226
RESTful 和 Thrift 服务接口	231
RESTful 服务接口	231
Thrift 服务接口	232
HDFS 编程	233
高级主题简介	237
协处理器	237
布隆过滤器	238
Lily 项目	238
小结	239
第 10 章	HBase 使用案例	240
HBase 在当今行业中的作用	240
HBase 和关系型数据库的未来的对比	241
一些现实世界中的工程使用案例	241
HBase 在 Facebook	241
HBase 在 Pinterest	243
HBase 在 Groupon	244
HBase 在 LongTail Video	246
HBase 在 Aadhaar（UIDAI）	247
有用的链接和参考	248
小结	249
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Learning Hbase中文版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构大数据——大数据技术及算法解析
第1章 大数据技术概述	1
1.1 大数据的概念	1
1.2 大数据的行业价值	4
1.3 大数据问题的爆发	9
1.4 大数据处理流程	12
1.5 大数据技术	13
1.5.1 基础架构支持	14
1.5.2 数据采集	14
1.5.3 数据存储	15
1.5.4 数据计算	16
1.5.5 展现与交互	18
1.6 练习题	19
参考文献	19
第2章 大数据基础支撑——数据中心及云计算	20
2.1 数据中心概述	20
2.1.1 云计算时代数据中心面临的问题	21
2.1.2 新一代数据中心关键技术	22
2.1.3 业界发展动态	24
2.1.4 小结	25
2.2 云计算简介	25
2.2.1 云计算定义	26
2.2.2 云计算主要特征	27
2.2.3 Web服务、网格和云计算	28
2.2.4 云计算应用分类	29
2.2.5 小结	31
2.3 大数据与云计算的关系	32
2.3.1 大数据是信息技术发展的必然阶段	33
2.3.2 云计算等新兴信息技术正在真正地落地和实施	34
2.3.3 云计算等新兴技术是解决大数据问题的核心关键	34
2.4 云资源调度与管理	35
2.4.1 云资源管理	36
2.4.2 云资源调度策略	38
2.4.3 云计算数据中心负载均衡调度	40
2.5 开源云管理平台OpenStack	44
2.5.1 OpenStack的构成	45
2.5.2 OpenStack各组件之间的关系	46
2.5.3 OpenStack的逻辑架构	47
2.5.4 小结	49
2.6 软件定义网络	49
2.6.1 起源与发展	50
2.6.2 OpenFlow标准和规范	50
2.6.3 OpenFlow的应用	53
2.7 虚拟机与容器	55
2.7.1 VM虚拟化与Container虚拟化	55
2.7.2 Docker	55
2.8 练习题	57
参考文献	57
第3章 云计算先行者——Google的三驾马车	59
3.1 Google的三驾马车	59
3.1.1 GFS——一个可扩展的分布式文件系统	59
3.1.2 MapReduce——一种并行计算的编程模型	64
3.1.3 BigTable——一个分布式数据存储系统	69
3.2 Google新“三驾马车”	77
3.2.1 Caffeine——基于Percolator的搜索索引系统	77
3.2.2 Pregel——高效的分布式图计算的计算框架	80
3.2.3 Dremel——大规模数据的交互式数据分析系统	85
3.3 练习题	89
参考文献	89
第4章 云存储系统	91
4.1 云存储的基本概念	91
4.1.1 云存储结构模型	91
4.1.2 云存储与传统存储系统的区别	94
4.2 云存储关键技术	95
4.2.1 存储虚拟化技术	95
4.2.2 分布式存储技术	97
4.3 云存储系统分类	98
4.3.1 分布式文件存储	99
4.3.2 分布式块存储	105
4.3.3 分布式对象存储	109
4.3.4 统一存储	117
4.4 其他相关技术	124
4.5 练习题	127
参考文献	127
第5章 数据采集系统	129
5.1 Flume	130
5.1.1 Flume架构	130
5.1.2 Flume核心组件	133
5.1.3 Flume环境搭建与部署	134
5.2 Scribe	139
5.2.1 Scribe架构	139
5.2.2 Scribe中的Store	140
5.2.3 Scribe环境搭建与部署	141
5.3 Chukwa	144
5.3.1 Chukwa的设计目标	144
5.3.2 Chukwa架构	145
5.3.3 Chukwa 环境搭建与部署	147
5.4 Kafka	150
5.4.1 Kafka架构	150
5.4.2 Kafka存储	152
5.4.3 Kafka的特点	152
5.4.4 Kafka环境搭建与部署	154
5.5 练习题	155
参考文献	155
第6章 Hadoop与MapReduce	156
6.1 Hadoop平台	156
6.1.1 Hadoop概述	156
6.1.2 Hadoop的发展简史	157
6.1.3 Hadoop的功能和作用	158
6.1.4 HDFS	159
6.1.5 HBase	162
6.2 MapReduce	171
6.2.1 第一代MapReduce（MRv1）	172
6.2.2 MapReduce 2.0——Yarn	180
6.3 Hadoop相关生态系统	184
6.3.1 交互式数据查询分析	184
6.3.2 数据收集、转换工具	187
6.3.3 机器学习工具	188
6.3.4 集群管理与监控	188
6.3.5 其他工具	189
6.4 Hadoop应用案例	191
6.5 练习题	192
参考文献	192
第7章 Spark——大数据统一计算平台	193
7.1 Spark简介	193
7.1.1 Spark	193
7.1.2 BDAS	195
7.2 RDD	197
7.2.1 RDD基本概念	197
7.2.2 RDD示例	199
7.2.3 RDD与分布式共享内存	200
7.3 Spark SQL	201
7.4 MLlib	203
7.5 GraphX	206
7.6 Spark Streaming	206
7.6.1 基本概念	207
7.6.2 编程模型	208
7.7 Spark的安装	210
7.7.1 单机运行Spark	210
7.7.2 使用Spark Shell与Spark交互	213
7.8 Shark、Impala、Hive对比	214
7.9 练习题	216
参考文献	216
第8章 Storm流计算系统	218
8.1 流计算系统	218
8.1.1 流计算系统的特点	218
8.1.2 流计算处理基本流程	219
8.2 Storm流计算框架	220
8.2.1 Storm简介	220
8.2.2 Storm关键术语	221
8.2.3 Storm架构设计	223
8.3 Storm编程实例	225
8.4 Storm应用	228
8.4.1 Storm应用场景	228
8.4.2 Storm应用实例	228
8.5 其他流计算框架	229
8.6 练习题	231
参考文献	231
第9章 SQL、NoSQL与NewSQL	232
9.1 传统SQL数据库	232
9.1.1 关系模型	232
9.1.2 关系型数据库的优点	233
9.1.3 关系型数据库面临的问题	234
9.2 NoSQL	234
9.2.1 NoSQL与大数据	235
9.2.2 NoSQL理论基础	235
9.2.3 分布式模型	238
9.2.4 NoSQL数据库分类	241
9.3 NewSQL	255
9.3.1 系统分类	255
9.3.2 Google Spanner	256
9.3.3 MemSQL	258
9.3.4 VoltDB	260
9.4 练习题	263
参考文献	263
第10章 大数据与数据挖掘	264
10.1 数据挖掘的主要功能和常用算法	264
10.1.1 数据挖掘的主要功能	264
10.1.2 常用算法	265
10.2 大数据时代的数据挖掘	280
10.2.1 传统数据挖掘解决方案	280
10.2.2 分布式数据挖掘解决方案	280
10.3 数据挖掘相关工具	282
10.3.1 Mahout	282
10.3.2 语言工具——Python	288
10.4 数据挖掘与R语言	289
10.4.1 R语言简介	289
10.4.2 R语言在数据挖掘上的应用	290
10.5 练习题	294
参考文献	294
第11章 深度学习	298
11.1 深度学习介绍	299
11.1.1 深度学习的概念	299
11.1.2 深度学习的结构	299
11.1.3 从机器学习到深度学习	301
11.2 深度学习基本方法	302
11.2.1 自动编码器	302
11.2.2 稀疏编码	304
11.3 深度学习模型	305
11.3.1 深度置信网络	306
11.3.2 卷积神经网络	308
11.4 深度学习的训练加速	310
11.4.1 GPU加速	310
11.4.2 数据并行	311
11.4.3 模型并行	312
11.4.4 计算集群	313
11.5 深度学习应用	313
11.5.1 Google	314
11.5.2 百度	314
11.5.3 腾讯Mariana	315
11.6 练习题	316
参考文献	316
第12章 电子商务与社会化网络大数据分析	318
12.1 推荐系统简介	318
12.1.1 推荐系统的评判标准	319
12.1.2 推荐系统的分类	319
12.1.3 在线推荐系统常用算法介绍	320
12.1.4 相关算法知识	323
12.2 计算广告	327
12.2.1 计算广告简介	327
12.2.2 计算广告发展阶段	327
12.2.3 计算广告相关算法	330
12.2.4 计算广告与大数据	332
12.2.5 大数据在计算广告中的应用案例	333
12.3 社交网络	333
12.3.1 社交网络中大数据挖掘的应用场景	334
12.3.2 社交网络大数据挖掘核心算法模型	334
12.3.3 图计算框架	335
12.3.4 大数据在社交网络中的应用案例	337
12.4 练习题	338
第13章 大数据展示与交互技术	339
13.1 数据可视化分类	339
13.1.1 按照展示内容进行划分	340
13.1.2 按照数据类型进行划分	341
13.2 可视化技术分类	351
13.2.1 2D展示技术	351
13.2.2 3D渲染技术	356
13.2.3 体感互动技术	360
13.2.4 虚拟现实技术	362
13.2.5 增强现实技术	364
13.2.6 可穿戴技术	365
13.2.7 可植入设备	368
13.3 练习题	369
参考文献	369
第14章 大数据安全与隐私	372
14.1 云计算时代安全与隐私问题凸显	372
14.2 云计算与大数据时代的安全挑战	374
14.2.1 大数据时代的安全需求	374
14.2.2 信息安全的发展历程	375
14.2.3 新兴信息技术带来的安全挑战	376
14.3 如何解决安全问题	380
14.3.1 云计算安全防护框架	381
14.3.2 基础云安全防护关键技术	384
14.3.3 创立本质安全的新型IT体系	387
14.4 隐私问题	389
14.4.1 防不胜防的隐私泄露	389
14.4.2 隐私保护的政策法规	390
14.4.3 隐私保护技术	391
14.5 练习题	393
参考文献	393
第15章 大数据技术发展趋势	394
15.1 实时化	394
15.2 内存计算	396
15.2.1 机遇与挑战	396
15.2.2 研究进展	397
15.2.3 发展展望	399
15.3 泛在化	399
15.3.1 发展现状	400
15.3.2 发展趋势	401
15.4 智能化	406
15.4.1 传统人工智能	406
15.4.2 基于大数据的人工智能	407
15.5 练习题	410
参考文献	410
第16章 知名企业大数据架构简介	411
16.1 腾讯	411
16.1.1 背景介绍	411
16.1.2 整体架构	412
16.2 淘宝	416
16.2.1 背景介绍	416
16.2.2 整体架构	416
16.3 Facebook	417
16.3.1 背景介绍	417
16.3.2 整体架构	418
16.3.3 技术架构展望	420
16.4 Twitter	420
16.4.1 背景介绍	420
16.4.2 整体架构	420
16.4.3 技术架构展望	422
16.5 Netflix	422
16.5.1 背景介绍	422
16.5.2 整体架构	423
16.5.3 Netflix个性化和推荐系统架构	426
16.6 练习题	430
参考文献	430
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构大数据——大数据技术及算法解析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向服务的企业应用架构
第1章 面向服务的企业应用架构概要
1.1 面向服务架构的必然性
1.1.1 阿凡提的兔子汤
1.1.2 秦始皇的度量“衡”
1.1.3 达尔文的“适变”理论
1.1.4 高尔的成功系统定律
1.2 软件工程与SOA成熟度
1.3 什么是面向服务的架构
1.3.1 SOA的架构定义
1.3.2 SOA架构师的技能
1.4 面向服务的全方位架构域
1.4.1 架构域的划分及关联
1.4.2 企业架构
1.4.3 业务架构
1.4.4 应用架构
1.5 面向服务的框架模式
1.5.1 参考方案架构模式
1.5.2 SOA设计模式
1.5.3 应用框架
1.5.4 行业框架
1.6 SOA的服务形式
1.6.1 SOA服务定义
1.6.2 服务分层调用
1.6.3 服务粒度定义
1.6.4 服务暴露形式
1.6.5 服务接口契约
第2章 面向服务企业应用整合的架构特色
2.1 面向服务的架构关注点
2.1.1 面向服务的应用整合框架
2.1.2 面向服务架构的关注点
2.1.3 SOA关注点的架构核心
2.2 界面交互
2.2.1 门户服务
2.2.2 界面应用服务
2.3 业务流程管理
2.3.1 流程类型
2.3.2 业务流与工作流
2.3.3 BPM的协同形式
2.3.4 流程的服务化
2.3.5 流程的事务性
2.3.6 流程的动态性
2.3.7 人员角色关联
2.4 信息集成
2.5 中介转换
2.5.1 报文标准
2.5.2 消息流模式
2.5.3 中介功能模块
2.5.4 中介转换
2.6 通用应用服务
2.6.1 标准接口调用架构
2.6.2 上层中间件——SOA的延伸形态
第3章 面向服务的全息架构视角
3.1 SOA的服务建模实现过程
3.2 架构视角与视图
3.2.1 架构视角
3.2.2 架构视图
3.3 SOA全息视角架构建模方法（SOA-HV）
3.3.1 架构视角模板
3.3.2 架构阶段及视图关联
3.3.3 架构视图的选择裁剪过程
3.4 SOA-HV——企业架构
3.4.1 差距分析视图
3.4.2 企业规划视图
3.4.3 组织结构视图
3.4.4 架构原则视图
3.4.5 应用框架视图
3.4.6 术语词汇视图
3.5 SOA-HV——业务架构
3.5.1 业务环境视图
3.5.2 业务模型视图
3.5.3 服务目录视图
3.5.4 业务分解视图
3.6 SOA-HV——架构需求
3.6.1 现有环境视图
3.6.2 企业痛点视图
3.6.3 功能需求视图
3.6.4 业务用例视图
3.6.5 服务质量视图
3.6.6 衡量指标视图
3.6.7 项目规划视图
3.7 SOA-HV——应用架构
3.7.1 典型场景视图
3.7.2 需求映射视图
3.7.3 架构总览视图
3.7.4 资产规范视图
3.7.5 架构抉择视图
3.7.6 服务组件视图
3.7.7 界面概要视图
3.7.8 门户服务视图
3.7.9 流程服务视图
3.7.10 信息服务视图
3.7.11 中介服务视图
3.8 SOA-HV——接口规约
3.8.1 门户规约视图
3.8.2 流程规约视图
3.8.3 中介规约视图
3.8.4 信息规约视图
3.8.5 重用规约视图
3.9 SOA-HV——架构实现
3.9.1 实现方式视图
3.9.2 服务部署视图
3.9.3 物理部署视图
3.9.4 服务管控视图
3.10 SOA-HV——架构校验
3.10.1 测试计划视图
3.10.2 变更管理视图
3.10.3 资源估算视图
3.10.4 项目报告视图
3.11 SOA-HV——架构视图走场
第4章 端到端企业应用整合架构案例
4.1 企业业务
4.2 项目需求
4.3 应用架构
4.3.1 典型场景
4.3.2 需求映射
4.3.3 系统总览
4.4 架构抉择
4.5 服务组件
4.6 界面概要
4.7 门户服务
4.8 流程服务
4.8.1 流程架构服务
4.8.2 流程应用服务
4.9 信息服务
4.10 中介服务
4.11 接口规约
4.12 服务实现
4.12.1 实现方式
4.12.2 服务部署
4.12.3 物理部署
4.12.4 服务管控
4.13 项目小结
第5章 面向服务架构与其他架构形式
5.1 传统应用架构
5.2 企业资源计划系统（ERP）架构
5.3 模型驱动架构
5.4 敏捷架构
5.5 云计算
附录A SOA建模方法及标记
A.1 SOA设计模型类型及建模方法
A.2 架构视图标记
参考文献
免责声明
致谢
结束语
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向服务的企业应用架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Ceph源码分析
序言
前言
第1章　Ceph整体架构	1
1.1　Ceph的发展历程	1
1.2　Ceph的设计目标	2
1.3　Ceph基本架构图	2
1.4　Ceph客户端接口	3
1.4.1　RBD	4
1.4.2　CephFS	4
1.4.3　RadosGW	4
1.5　RADOS	6
1.5.1　Monitor	6
1.5.2　对象存储	7
1.5.3　pool和PG的概念	7
1.5.4　对象寻址过程	8
1.5.5　数据读写过程	9
1.5.6　数据均衡	10
1.5.7　Peering	11
1.5.8　Recovery和Backfill	11
1.5.9　纠删码	11
1.5.10　快照和克隆	12
1.5.11　Cache Tier	12
1.5.12　Scrub	13
1.6　本章小结	13
第2章　Ceph通用模块	14
2.1　Object	14
2.2　Buffer	16
2.2.1　buffer::raw	16
2.2.2　buffer::ptr	17
2.2.3　buffer::list	17
2.3　线程池	19
2.3.1　线程池的启动	20
2.3.2　工作队列	20
2.3.3　线程池的执行函数	21
2.3.4　超时检查	22
2.3.5　ShardedThreadPool	22
2.4　Finisher	23
2.5　Throttle	23
2.6　SafeTimer	24
2.7　本章小结	25
第3章　Ceph网络通信	26
3.1　Ceph网络通信框架	26
3.1.1　Message	27
3.1.2　Connection	29
3.1.3　Dispatcher 29
3.1.4　Messenger	29
3.1.5　网络连接的策略	30
3.1.6　网络模块的使用	30
3.2　Simple实现	32
3.2.1　SimpleMessager	33
3.2.2　Accepter	33
3.2.3　DispatchQueue	33
3.2.4　Pipe	34
3.2.5　消息的发送	35
3.2.6　消息的接收	36
3.2.7　错误处理	37
3.3　本章小结	38
第4章　CRUSH数据分布算法	39
4.1　数据分布算法的挑战	39
4.2　CRUSH算法的原理	40
4.2.1　层级化的Cluster Map	40
4.2.2　Placement Rules	42
4.2.3　Bucket随机选择算法	46
4.3　代码实现分析	49
4.3.1　相关的数据结构	49
4.3.2　代码实现	50
4.4　对CRUSH算法的评价	52
4.5　本章小结	52
第5章　Ceph客户端	53
5.1　Librados	53
5.1.1　RadosClient	54
5.1.2　IoCtxImpl	56
5.2　OSDC	56
5.2.1　ObjectOperation	56
5.2.2　op_target	57
5.2.3　Op	57
5.2.4　Striper	58
5.2.5　ObjectCacher	59
5.3　客户写操作分析	59
5.3.1　写操作消息封装	60
5.3.2　发送数据op_submit	61
5.3.3　对象寻址_calc_target	61
5.4　Cls	62
5.4.1　模块以及方法的注册	62
5.4.2　模块的方法执行	63
5.4.3　举例说明	64
5.5　Librbd	65
5.5.1　RBD的相关的对象	65
5.5.2　RBD元数据操作	66
5.5.3　RBD数据操作	67
5.5.4　RBD的快照和克隆	69
5.6　本章小结	71
第6章　Ceph的数据读写	72
6.1　OSD模块静态类图	72
6.2　相关数据结构	73
6.2.1　Pool	74
6.2.2　PG	75
6.2.3　OSDMap	75
6.2.4　OSDOp	77
6.2.5　Object_info_t	77
6.2.6　ObjectState	78
6.2.7　SnapSetContext	79
6.2.8　ObjectContext	79
6.2.9　Session	80
6.3　读写操作的序列图	81
6.4　读写流程代码分析	83
6.4.1　阶段1：接收请求	83
6.4.2　阶段2：OSD的op_wq处理	85
6.4.3　阶段3：PGBackend的处理	95
6.4.4　从副本的处理	95
6.4.5　主副本接收到从副本的应答	95
6.5　本章小结	96
第7章　本地对象存储	97
7.1　基本概念介绍	98
7.1.1　对象的元数据	98
7.1.2　事务和日志的基本概念	98
7.1.3　事务的封装	99
7.2　ObjectStore对象存储接口	100
7.2.1　对外接口说明	101
7.2.2　ObjectStore代码示例	101
7.3　日志的实现	102
7.3.1　Jouanal对外接口	102
7.3.2　FileJournal	103
7.4　FileStore的实现	109
7.4.1　日志的三种类型	110
7.4.2　JournalingObjectStore	111
7.4.3　Filestore的更新操作	112
7.4.4　日志的应用	115
7.4.5　日志的同步	115
7.5　omap的实现	116
7.5.1　omap存储	117
7.5.2　omap的克隆	118
7.5.3　部分代码实现分析	119
7.6　CollectionIndex	120
7.6.1　CollectIndex接口	122
7.6.2　HashIndex	123
7.6.3　LFNIndex	124
7.7　本章小结	124
第8章　Ceph纠删码	125
8.1　EC的基本原理	125
8.2　EC的不同插件	126
8.2.1　RS编码	126
8.2.2　LRC编码	126
8.2.3　SHEC编码	128
8.2.4　EC和副本的比较	129
8.3　Ceph中EC的实现	129
8.3.1　Ceph中EC的基本概念	129
8.3.2　EC支持的写操作	130
8.3.3　EC的回滚机制	131
8.4　EC的源代码分析	132
8.4.1　EC的写操作	132
8.4.2　EC的write_full	133
8.4.3　ECBackend	133
8.5　本章小结	133
第9章　Ceph快照和克隆	134
9.1　基本概念	134
9.1.1　快照和克隆	134
9.1.2　RDB的快照和克隆比较	135
9.2　快照实现的核心数据结构	137
9.3　快照的工作原理	139
9.3.1　快照的创建	139
9.3.2　快照的写操作	139
9.3.3　快照的读操作	140
9.3.4　快照的回滚	141
9.3.5　快照的删除	141
9.4　快照读写操作源代码分析	141
9.4.1　快照的写操作	141
9.4.2　make_writeable函数	142
9.4.3　快照的读操作	145
9.5　本章小结	146
第10章　Ceph Peering机制	147
10.1　statechart状态机	147
10.1.1　状态	147
10.1.2　事件 148
10.1.3　状态响应事件	148
10.1.4　状态机的定义	149
10.1.5　context函数	150
10.1.6　事件的特殊处理	150
10.2　PG状态机	151
10.3　PG的创建过程	151
10.3.1　PG在主OSD上的创建	151
10.3.2　PG在从OSD上的创建	153
10.3.3　PG的加载	154
10.4　PG创建后状态机的状态转换	154
10.5　Ceph的Peering过程分析	156
10.5.1　基本概念	156
10.5.2　PG日志	159
10.5.3　Peering的状态转换图	166
10.5.4　pg_info数据结构	167
10.5.5　GetInfo	169
10.5.6　GetLog	176
10.5.7　GetMissing	181
10.5.8　Active操作	183
10.5.9　副本端的状态转移	187
10.5.10　状态机异常处理	188
10.6　本章小结	188
第11章　Ceph数据修复	189
11.1　资源预约	190
11.2　数据修复状态转换图	191
11.3　Recovery过程	193
11.3.1　触发修复	193
11.3.2　ReplicatedPG	195
11.3.3　pgbackend	199
11.4　Backfill过程	205
11.4.1　相关数据结构	205
11.4.2　Backfill的具体实现	205
11.5　本章小结	210
第12章　Ceph一致性检查	211
12.1　端到端的数据校验	211
12.2　Scrub概念介绍	213
12.3　Scrub的调度	213
12.3.1　相关数据结构	214
12.3.2　Scrub的调度实现	214
12.4　Scrub的执行	217
12.4.1　相关数据结构 217
12.4.2　Scrub的控制流程	219
12.4.3　构建ScrubMap	221
12.4.4　从副本处理	224
12.4.5　副本对比	225
12.4.6　结束Scrub过程	228
12.5　本章小结	228
第13章　Ceph自动分层存储	230
13.1　自动分层存储技术	230
13.2　Ceph分层存储架构和原理	231
13.3　Cache Tier的模式	231
13.4　Cache Tier的源码分析	234
13.4.1　pool中的Cache Tier数据结构	234
13.4.2　HitSet	236
13.4.3　Cache Tier的初始化	237
13.4.4　读写路径上的Cache Tier处理	238
13.4.5　cache的flush和evict操作	245
13.5　本章小结	250
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Ceph源码分析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算应用开发实践
出版说明
前言
第1章在云上架构你的应用
11Java 宠物商店简介
111环境准备
112部署Java宠物商店
113宠物商店架构介绍
12测试
121宠物商店访问速度测试
122其他的测试
13针对测试结果改进应用
131提高访问速度
132主机管理
14难道这就是云计算？
141什么是云计算
142云计算架构简介
143云计算的起源与发展
15小结
第2章IaaS技术介绍
21虚拟化技术
211虚拟化技术中的重要名词及技术解释
212全虚拟化技术
213半虚拟化技术
22PXE
221PXE简介
222PXE系统的组成及配置
23负载均衡
231Tomcat负载均衡
232DNS负载均衡
24构建企业IaaS环境
241需求分析
242系统架构
243概要设计
244动手搭建IaaS环境
25小结
第3章并行计算技术介绍
31Hadoop
311Hadoop简介
312初探Hadoop
313Hadoop的架构
314多机环境配置Hadoop
315分布式环境下运行Hadoop
316使用Eclipse Hadoop集成开发环境
317使用Hadoop MapReduce 编写程序
32Platform Symphony
321Platform Symphony简介
322初探Symphony DE
323Platform Symphony架构
324多机环境配置Symphony DE
325使用Symphony DE编写程序
33云数据库
331HBase
332初探HBase
333HBase概念
334再探HBase
34小结
第4章公共云计算介绍
41因特网数据中心IDC
411IDC所提供的服务
412使用IDC提供的主机服务
413IDC虚拟主机业务实现分析
414传统IDC所面临的机遇与挑战
42Google App Engine
421注册Google App Engine账户
422安装Google App Engine SDK
423使用Eclipse 集成开发环境
424基于Google App Engine SDK开发应用
425将应用部署到Google App Engine 中
43Amazon AWS
431注册AWS 账户
432使用Amazon EC2
433使用Eclipse 集成开发环境
434基于AWS SDK开发应用程序
435将应用程序部署到AWS 中
44其他公共云计算平台
441Microsoft Azure
442Sina App Engine
45小结
第5章在云上开发你的应用
51为应用选择合适的架构与技术
511以计算为中心的应用架构选择
512以数据为中心的应用架构选择
513需要兼顾数据与计算的应用架构选择
514MapReduce框架并不能解决所有问题
52现有云计算技术存在的问题
521NoSQL数据库API不兼容
522使用JPA访问NoSQL数据库
523各公共服务提供商所提供的服务不同
53基于云计算平台的文件共享系统需求分析
54基于云计算平台的文件共享系统设计
541系统架构
542平台及技术选择
543系统功能
544非功能性需求
55基于云计算的文件共享平台实现
551用户管理模块实现
552文件管理模块实现
553文件浏览及管理页面实现
56使用GAE与AWS S3部署
561配置GAE数据库
562使用Applet编写文件管理界面
563实现AWS S3 文件管理类
57小结
第6章云计算在数据挖掘中的应用
61从宠物商店引出的商业智能
62Apriori算法
621Apriori算法的实现原理
622利用Apriori小试牛刀
63商品推荐功能在宠物商店中的程序实现
631宠物商店JPetStore基础环境配置
632Apriori算法在商品推荐功能中的程序实现
633宠物商店商品销售记录测试数据准备
634单机版测试效果及问题
64使用云数据库进行计算
641将MySQL中的数据复制到HBase中
642使用MapReduce计算频繁项集L［1］
643得到最终结果
65小结
第7章云计算在金融计算中的应用
71金融计算简介
72蒙特卡罗模拟算法
721一个简单的蒙特卡罗模拟例子
722编程实现蒙特卡罗计算圆周率
73使用蒙特卡罗模拟解决问题
731蒙特卡罗模拟投资分析基本编码实现
732测试
74云端金融应用需求分析
741需求分析
742技术可行性分析
75云端金融应用概要设计
751系统功能
752系统软硬件架构
76云端金融应用系统实现
77管理软硬件资源
78小结
第8章提升办公效率——Excel与云计算集成
81Excel简介
811认识Excel宏
812Excel VBA简介
813Excel VBA编程环境
814Excel VBA编程
82使用Excel进行蒙特卡罗模拟
821需求分析
822VBA编码实现
83将Excel与云计算环境集成
831Symphony DE COM组件简介
832Excel与Symphony DE集成
833Excel蒙特卡罗模拟投资分析客户端编码实现
834测试
84小结
第9章专业工具软件与云计算集成
91MATLAB简介
911安装 MATLAB
912MATLAB基本使用
913Parallel Computing Toolbox 简介
914MATLAB PCT架构
915配置Parallel Computing Toolbox
92使用Parallel Computing Toolbox提高计算速度
921使用MATLAB Job Manager
922与Symphony DE集成
923MATLAB与Java运行环境集成
93将更多的工具运行在云计算环境中
931通用集成架构探索
932集成接口探索
94小结
第10章管理云计算服务平台
101一个建立云计算服务平台的机会
102IT服务标准
1021ITIL简介
1022ITSM 简介
1023IT管理中的基本概念
103实践IT服务标准
1031OTRS简介
1032安装OTRS
1033创建服务台
1034票单管理
1035服务级别管理
1036变更管理
1037配置管理
1038其他管理
104小结
附录
附录A搭建Java运行环境
附录B安装Tomcat应用服务器
附录C安装JMeter测试工具
附录D安装 MySQL 数据库
致谢
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算应用开发实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ZeroC Ice权威指南
第1章  分布式系统的那些事儿	1
1.1  分布式计算的三要素	1
1.2  分布式架构昔日的王者	4
1.3  作为架构师你需要懂更多	8
1.4  一切从重新认识RPC开始	11
1.5  反叛之冰——Ice	15
第2章  Ice启程	16
2.1  Ice平台介绍	16
2.2  Ice的概念和原理	20
2.2.1  Ice Object	20
2.2.2  Ice Proxy	21
2.2.3  Location Service	23
2.2.4  总结	24
2.3  搭建Ice环境	25
2.4  掌握Slice	29
2.5  Hello World	34
2.6  多语言支持的魅力	40
第3章  Ice探险之旅	45
3.1  Ice RPC调用详解	45
3.2  使用IceBox	55
3.3  Ice Registry	67
3.4  IceGrid Node	71
3.5  IceGrid实战	74
3.6  IceGrid部署和运维工具	82
第4章  玩转Ice	85
4.1  从改造Ice日志开始	85
4.2  封装Ice客户端	91
4.3  集成Ice与Spring框架	95
4.4  实现Ice服务质量监控	98
4.5  用Maven标准化Ice项目	103
第5章  99%的人所不懂的Ice技能	107
5.1  深入解析Ice异步调用	107
5.2  Ice负载均衡机制研究	113
5.3  Ice SSL实践	119
5.4  PHP优化建议	132
5.5  Ice性能调优	134
5.6  Ice部署方案	136
第6章  互联网应用开发实战	139
6.1  Ice For JavaScript	139
6.2  Ice对移动设备的支持	141
6.3  在线订票系统（上）	146
6.4  在线订票系统（中）	156
6.5  在线订票系统（下）	162
第7章  互联网架构师深造之路	176
7.1  成功转型互联网架构师	176
7.2  J2EE的体系架构	177
7.3  重新认识分布式系统的中间件	179
7.3.1  Apache ZooKeeper	180
7.3.2  Apache Kafka	182
7.3.3  Facebook Thrift	183
7.3.4  Apache Storm、Spark Streaming、Samza	184
7.3.5  LevelDB	188
7.3.6  MyCat	189
7.4  不要只局限于一门编程语言	191
……
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ZeroC Ice权威指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>多核应用架构关键技术
译者序
序
前言
第一部分 管道理论
第1章 并行计算与商业应用 2
1.1 机械式解决方案：操作系统级
1.1 的并行计算方式 3
1.1.1 对称多处理 3
1.1.2 集群 3
1.2 自动化网络路由：预定逻辑下的
1.1 并行计算 3
1.3 网格计算：分布式并行计算 4
1.4 商业应用的并行计算 4
1.5 解决方案：软件管道 5
1.6 流体动力学 6
1.7 软件管道示例 7
1.8 小结 10
第2章 管道定律 11
2.1 CPU资源浪费问题 11
2.2 流体动力学 11
.2.3 管道定律：基本法则 12
2.4 推论1：流量限制 12
2.5 推论2：输出流的约束 13
2.6 软件管道规则 14
2.7 规则1 14
2.8 规则2 15
2.9 规则3 17
2.10 小结 20
第3章 管道示例 21
3.1 银行ATM系统（单层分布） 21
3.1.1 管道 21
3.1.2 管道分配器 22
3.2 银行ATM系统（多层分布） 23
3.2.1 下层管道层 24
3.2.2 上层管道层 27
3.3 小结 28
第4章 管道模式 30
4.1 服务调用模式 31
4.1.1 推模式 31
4.1.2 拉模式 31
4.2 消息交换模式 32
4.2.1 一路交换模式 32
4.2.2 请求—应答模式 33
4.3 管道路由模式 34
4.3.1 轮循路由模式 34
4.3.2 基于内容的路由模式 35
4.3.3 定制路由模式 36
4.3.4 加入模式 36
4.4 分配器模式 37
4.4.1 单一分配器模式 37
4.4.2 多层分配器模式 38
4.4.3 客户端分配器模式 39
4.4.4 数据库分片分配器模式 40
4.5 分配器连接器模式 40
4.5.1 本地方法调用模式 41
4.5.2 Socket调用模式 41
4.5.3 Web服务调用模式 41
4.5.4 其他模式 42
4.6 小结 42
第5章 管道：公司的影响 43
5.1 战略评估 43
5.2 预算影响 44
5.3 公司职位与责任 46
5.3.1 管道架构师 46
5.3.2 业务部门领导骨干 47
5.3.3 IT部门管理人员 48
5.3.4 应用开发人员 49
5.3.5 应用项目管理者 50
5.3.6 质量保证管理者 50
5.3.7 IT运营部 51
5.4 小结 51
第二部分 管道方法学
第6章 软件管道优化周期：概述 54
6.1 另一种软件方法学 54
6.2 SPOC概述 54
第7章 SPOC的5个步骤 56
7.1 软件管道优化周期文档 56
7.2 小结 57
第8章 管道示例：管道银行公司
第8章 介绍 58
8.1 SPOC报告模板 60
8.2 小结 61
第9章 SPOC第一步：管道目标 62
9.1 步骤1.1：确定业务目标/需求 63
9.2 步骤1.2：确定输入处理率 66
9.3 步骤1.3：检测未来潜在的输入
9.3 处理速率 67
9.4 步骤1.4：当前处理能力
9.3 的测定 69
9.5 步骤1.5：计算性能差距 70
9.6 步骤1.6：定义管道目标 71
9.7 小结 72
第10章 SPOC步骤2：管道分析 73
10.1 步骤2.1：映射目前处理流程 74
10.2 步骤2.2：确定现有的组件 76
10.3 步骤2.3：测定现有组件的
10.3 处理速率 77
10.4 步骤2.4：计算整个流程的
10.3 处理速率 79
10.5 步骤2.5：确定约束点 80
10.6 小结 81
第11章 SPOC步骤3：管道设计 82
11.1 步骤3.1：定义服务流程
11.1 设计 83
11.2 步骤3.2：确定新的组件 86
11.3 步骤3.3：确定管道化时机 87
11.4 步骤3.4：确定管道方案 89
11.5 步骤3.5：确定分配器
10.3 处理速率 93
11.6 步骤3.6：物理部署环境
10.3 的设计 94
11.7 步骤3.7：确定/优化管道
11.7 设计 95
11.8 小结 104
第12章 SPOC步骤4：管道实现 105
12.1 步骤4.1：构建软件管道框架 106
12.2 步骤4.2：修改现有的组件 107
12.3 步骤4.3：开始新的组件 109
12.4 步骤4.4：编排服务流程 110
12.5 步骤4.5：仪表化服务流程 112
12.6 步骤4.6：开发/修改管道
10.3 套件 112
12.7 步骤4.7：测试并优化
10.3 管道实现 119
12.8 小结 120
第13章 SPOC步骤5：管道部署 121
13.1 步骤5.1：规划管道部署 122
13.2 步骤5.2：部署到产品
10.3 环境中 122
13.3 步骤5.3：检测产品环境 123
13.4 步骤5.4：评估结果，规划下
10.3 一次SPOC迭代过程 124
13.5 小结 124
第三部分 管道示例
第14章 Hello软件管道 126
14.1 定义消息 126
14.2 构建服务 127
14.3 配置分配器 129
14.4 创建客户端 130
14.5 运行服务 133
14.6 小结 133
第15章 扩展Hello软件管道 134
15.1 扩展服务 134
15.2 开发可扩展的测试客户端 135
15.3 运行服务 138
15.4 小结 142
第16章 增加的管道路由器配置 143
16.1 基于内容的路由器 143
16.2 定制管道路由器 152
16.3 小结 163
第17章 从Hello软件管道
第22章 获得应答 164
17.1 请求——响应消息传递 164
17.2 在Hello软件管道中使用
10.3 请求——响应 167
17.3 小结 177
第18章 增添的分配器连接器模式 178
18.1 定义并配置连接器 178
18.2 Socket连接器 180
18.3 Web服务连接器 181
18.4 小结 183
第19章 使用多层分配器 184
19.1 配置多层分配器 184
19.2 创建客户端 188
19.3 运行服务 190
19.4 小结 191
第20章 数据库分片分配器 192
20.1 数据库分片示例 193
20.2 创建数据库分片 194
20.3 构建服务 194
20.4 配置分配器 197
20.5 配置分片驱动 198
20.6 创建客户端 199
20.7 执行服务 201
20.8 小结 202
第21章 管道框架概要 203
21.1 接口概要 203
21.2 管道工具 205
21.3 小结 211
第22章 管道银行公司（PBCOR）
第22章 示例 212
22.1 账户交易事务 213
22.2 管道配置信息 215
22.3 Spring框架 218
22.4 数据库访问 219
22.5 连接服务 225
22.6 运行测试 229
22.7 小结 230
第四部分 软件管道的未来
第23章 软件管道的未来 232
23.1 最后的建议 232
23.2 未来的一些想法 233
附录 管道参考架构Javadoc 235
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>多核应用架构关键技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java P2P技术内幕
第一部分  P2P简介
第1章  P2P的基本概念　3
1.1  P2P发展简史　3
1.2  P2P应用程序的用武之地　5
1.3  采用P2P的目的　5
1.3.1  分散化　6
1.3.2  费用和有效的资源分配　7
1.3.3  普及应用的计算和边缘服务　7
1.4  商业和实现方面的考虑　7
1.5  P2P体系结构　8
1.5

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java P2P技术内幕
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>WCF 4高级编程
目    录
第1章  设计原理与设计模式	1
1.1  SOA简介	1
1.2  SOA架构的4条原则	3
1.2.1  边界显式定义	3
1.2.2  服务自动化	3
1.2.3  服务共享的是模式和契约，
而不是类	3
1.2.4  基于策略的服务兼容性	4
1.3  服务的内部结构	4
1.4  组织业务流程中的服务	7
1.5  SOA的底层技术	7
1.5.1  SOAP	8
1.5.2  WS -* Protocols	8
1.5.3  WSDL	8
1.6  契约优先原则	9
1.7  WCF和.NET服务如何
实现SOA模式	10
1.7.1  模式	10
1.7.2  解耦契约：接口与实现	10
1.7.3  代理模式	11
1.7.4  OperationContext模式	11
1.7.5  并发契约	11
1.7.6  数据保密性	12
1.7.7  Web服务原子事务	12
1.7.8  会话外观	12
1.7.9  异常保护	12
1.8  通信与集成模式	13
1.8.1  集成模式	14
1.8.2  消息交换模式	16
1.8.3  消息模式	22
1.9  业务流程模式	26
1.9.1  流程管理器	26
1.9.2  在工作流声明中的模式	28
第2章  服务契约与数据契约	31
2.1  服务契约	32
2.2  数据契约	32
2.3  消息契约	32
2.4  契约与代码	32
2.5  汽车租赁服务——实现示例	33
2.5.1  步骤1：定义服务契约	33
2.5.2  步骤2：提取服务元数据	34
2.3.3  步骤3：服务的实现	38
2.5.4  步骤4：生成客户端代码	39
2.5.5  [ServiceContract]和
[OperationContract]特性	40
2.6  数据契约	42
2.6.1  数据契约详解	47
2.6.2  KnownTypes特性	49
2.7  服务契约与数据契约的
版本控制	52
2.7.1  数据契约的版本控制	52
2.7.2  双向版本控制	54
2.7.3  服务契约版本控制的
最佳实践	56
2.7.4  数据契约版本控制的
最佳实践	56
2.8  消息契约	57
第3章  绑定	63
3.1  绑定的工作原理	64
3.2  地址	66
3.3  行为	67
3.3.1  服务行为	67
3.3.2  操作行为	70
3.3.3  终结点行为	71
3.3.4  契约行为	74
3.4  绑定	75
3.4.1  basicHttpBinding和
wsHttpBinding	76
3.4.2  netTcpBinding	77
3.4.3  netMsmqBinding	77
3.4.4  基于上下文的绑定	77
3.4.5  如何选择要使用的绑定	78
3.5  配置绑定	79
3.5.1  基址	80
3.5.2  默认配置	82
3.5.3  设置多绑定	85
3.6  修改绑定	86
3.6.1  绑定的属性	86
3.6.2  创建自定义绑定	88
3.6.3  重用自定义绑定	90
3.7  持久双工服务	93
3.8  PollingDuplexHttpBinding绑定：
HTTP轮询	95
第4章  客户端	97
4.1  Basic Profile 1.1标准	98
4.2  .NET客户端	98
4.2.1  共享WSDL-契约	98
4.2.2  共享WSDL契约和数据
契约-DLL	101
4.2.3  共享接口和数据
契约-DLL	102
4.3  REST	104
4.3.1  REST与WCF	106
4.3.2  使用REST客户端	112
4.3.3  使用REST Starter Kit
工具	113
4.4  AJAX与WCF的关系	114
4.5  WCF 4与Silverlight	118
第5章  实例化	121
5.1  实例上下文模式	122
5.1.1  PerlCall模式	122
5.1.2  Single模式	125
5.1.3  PerSession模式	127
5.2  服务的生命周期	131
5.3  性能	137
5.3.1  限流	137
5.3.2  最佳做法	144
5.3.3  负载均衡	144
第6章  工作流服务	147
6.1  剖析工作流服务	148
6.2  声明式服务	149
6.3  接收与发送活动	152
6.3.1  接收活动	152
6.3.2  发送活动	155
6.3.3  SendAndReceiveReply和
ReceiveAndSendReply
活动	157
6.4  实现工作流服务的第一个
示例	157
6.5  配置工作流服务	161
6.6  实现消息的关联	164
6.7  托管工作流服务	174
第7章  理解WCF安全	177
7.1  Web服务安全的历史演变	177
7.2  Web服务安全的基本原则	178
7.2.1  验证	178
7.2.2  授权	179
7.2.3  消息的完整性	179
7.2.4  消息的机密性	179
7.3  传输安全与消息安全	180
7.3.1  传输安全	180
7.3.2  消息安全	180
7.4  WCF安全概述	182
第8章  WCF安全实战	195
8.1  验证的起步	195
8.2  基于声明的身份验证模型	196
8.3  验证实战	199
8.3.1  建立在消息安全之上的
用户验证	199
8.3.2  建立在传输安全之上的
用户名验证	209
8.3.3  利用消息安全实现X509
证书的相互验证	213
8.3.4  建立在消息安全之上的
Kerberos验证	221
8.4  声明转换与安全上下文的
初始化	226
8.5  服务授权	228
8.5.1  基于角色的授权	228
8.5.2  基于声明的验证和验证
上下文	232
8.5.3  授权管理器	233
第9章  WCF联合验证	237
9.1  联合验证	237
9.1.1  STS服务简介	238
9.1.2  多域之间的联合验证	238
9.1.3  SAML语言	239
9.2  WIF架构	241
第10章  Windows Azure Platform
AppFabric	255
10.1  服务总线和访问控制简介	256
10.2  使用服务总线	259
10.3  中继服务	264
10.4  WCF中继绑定	265
10.4.1  netOneWayRelayBinding
绑定	266
10.4.2  netEventRelayBinding
绑定	268
10.4.3  netTcpRealyBinding
绑定	270
10.4.4  HTTP中继绑定	272
10.5  使用访问控制服务(ACS)	274
10.5.1  服务名称空间	275
10.5.2  作用域	276
10.5.3  发送者	276
10.5.4  规则	276
10.5.5  把第一个服务集成到
访问控制中	277
第11章  创建一个SOA案例	285
11.1  需求分析	285
11.2  建立解决方案	286
11.3  创建接口	288
11.3.1  创建CarManagement
接口	291
11.3.2  创建Customer接口	292
11.3.3  创建Rental接口	293
11.3.4  创建External接口	294
11.4  创建服务	296
11.5  创建宿主程序	298
11.6  创建数据库	306
11.7  实现服务	306
11.7.1  为CustomerService和
RentalService服务创建
数据库访问	307
11.7.2  创建CarManagement
服务	308
11.8  公开元数据	310
11.9  创建CarManagement
客户端	313
11.10  创建RentalApplication
应用程序	320
11.11  添加错误处理功能	325
11.12  模拟客户端	328
11.13  扩展CarManagement接口
以接受汽车子类	328
11.14  实现ExternalInterface-
Facade	330
11.14.1  调用ExternalInterface-
Facade	331
11.14.2  给参与事务的方法设置
事务支持	333
11.14.3  为servicehost配置
额外的终结点	333
第12章  创建通信和集成案例	335
12.1  需求分析	335
12.2  建立解决方案	337
12.3  创建HQOrderEntryService-
Interface接口项目	338
12.4  创建HelperLib类库	340
12.5  创建HQOrderEntry-
Implementation项目	341
12.6  创建HQOrderEntryServiceHost
项目	342
12.7  创建OrderEntryApplication
项目	343
12.8  创建LocalOrderEntryInterface
接口项目	345
12.9  继续HQOrderEntry-
Implementation项目	346
12.10  创建HQProductServiceASMX
项目	348
12.10.1  创建Web服务	348
12.10.2  把HQProductService-
ASMX作为服务引用
添加到OrderEntryService-
Implementation项目中	349
12.10.3  为CheckIfOrderIsValid
方法编写代码	350
12.10.4  为TranslateProduct-
Description方法编写
代码	351
12.10.5  为ConvertOrderEntry-
Schema方法编写
代码	351
12.11  创建HQLocalizationService
服务	352
12.12  为RouteOrderEntry方法
编写代码	354
12.13  创建RealTimeOrderTracking-
Application应用程序	355
12.13.1  为RealTimeOrder-
TrackingApplication
方法编写代码	355
12.13.2  添加IsubscribeToOrder-
TrackingInfo 接口	356
12.13.3  实现SubscribeService
方法	356
12.13.4  在订单处理时调用
订阅服务	357
12.13.5  打开SubscribeService
服务	358
12.13.6  订阅来自RealTimeOrder-
TrackingApplication的
事件	359
12.13.7  配置HQOrderEntry-
ServiceHost宿主	359
12.14  创建路由	360
12.15  配置HQOrderEntry-
ServiceHost宿主	362
第13章  创建业务流程	365
13.1  需求分析	365
13.2  建立解决方案	366
13.3  创建数据契约	367
13.4  创建CalculateReferenceID-
Service服务	369
13.5  创建ReceiveApprovedHoliday-
RequestsService项目	370
13.6  给HolidayRequestActivity-
Library项目添加服务引用	373
13.6.1  添加CalculateReferenceID-
Service项目	373
13.6.2  添加对ReceiveApproved-
HolidayRequestsService
服务的引用	374
13.6.3  开发HolidayRequestProcess
项目	375
13.6.4  添加工作流	375
13.6.5  创建变量	376
13.6.6  配置Receive活动	378
13.6.7  配置Send活动	379
13.6.8  配置ApproveRequest操作
的ReceiveAndSendReply
活动	383
13.7  开发HolidayRequest-
ProcessHost项目	388
13.8  测试这个服务宿主能否正确
公开元数据	389
13.9  开发ManagersHoliday-
RequestApprovalApplication
项目	391
13.10  创建SqlWorkflowInstance-
Store项目	391
第14章  托管服务	393
14.1  自托管	394
14.1.1  ServiceHost和ServiceHost-
Base	394
14.1.2  实现一个自定义的
ServiceHost	397
14.2  IIS托管	399
14.2.1  ServiceHostFactory与
ServiceHostFactoryBase	401
14.2.2  使用CustomService-
HostFactory类	401
14.2.3  不通过svc文件承载
服务	402
14.2.4  Windows激活服务	403
14.3  用Windows AppFabric管理
和跟踪终结点	406
14.3.1  建立Windows Server
AppFabric	407
14.3.2  使用AppFabric监视
服务	409
14.3.3  启动事件查看器	412
14.4  路由服务	413
14.4.1  基于内容的路由	413
14.4.2  协议和安全桥接	417
14.4.3  错误处理	418
14.5  云托管	419
14.5.1  在Windows Azure中
托管WCF服务	420
14.5.2  Windows Azure Platform
AppFabric服务总线	420
14.5.3  通过云中继服务	421
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>WCF 4高级编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件定义存储
作者简介
序1
序2
序3
序4
序5
序6
前言
第1章软件定义存储之介绍1
1.1什么是软件定义2
1.2什么是软件定义存储3
1.2.1VMware眼里的SDS3
1.2.2EMC眼里的SDS5
1.2.3IBM眼里的SDS6
1.2.4华为眼里的SDS8
1.2.5Gartner眼里的SDS10
1.2.6IDC眼里的SDS11
1.2.7SNIA眼里的SDS12
1.2.8本书对SDS的定义15
1.3为什么出现软件定义存储16
1.3.1背景16
1.3.2数据迅猛增长16
1.3.3硬盘的发展异常缓慢19
1.3.4深刻改变存储架构的新技术19
1.4本章小结23
第2章软件定义存储之发展25
2.1SDS之抽象篇25
2.2SDS之池化篇28
2.2.1SNIA对存储虚拟化的解释28
2.2.2SNIA之存储标准化建议：SMI—S29
2.2.3存储虚拟化实例剖析31
2.2.4存储标准化之互操作性32
2.3SDS之自动化篇34
2.3.1DCOS—OpenStackCinder39
2.3.2Hypervisor—VMware41
2.4本章小结42
第3章软件定义存储之分类43
3.1ServerSAN43
3.2HCI45
3.3SDS的分类46
3.3.1IDC对SDS的分类46
3.3.2VMwareSDS的分类47
3.3.3EMCSDS的分类48
3.4本书对SDS的分类48
3.4.1控制平面49
3.4.2数据平面50
3.5本章小结54
第4章软件定义存储之未来55
4.1第三方机构对SDS市场的预测55
4.1.1Gartner55
4.1.2IDC56
4.1.3Wikibon56
4.1.4Marketsandmarkets58
4.1.5总结58
4.2SDS未来发展的预测和解释59
4.2.1谁会在未来SDS名列前茅59
4.2.2存储、服务器、云计算厂商的并购将加速61
4.2.3未来SDS可能的发展61
4.2.4与SDS相关的技术62
第5章VMwareSPBM和VirtualVolumes63
5.1存储策略出现的历史回顾63
5.2VMwareSPBM64
5.3VirtualVolumes65
5.3.1什么是VirtualVolumes65
5.3.2VirtualVolumes的优势66
5.3.3VirtualVolumes的组成部分66
5.4VirtualVolumes各家阵列之实现72
5.4.1DELLEqualLogic72
5.4.2IBMXIV73
5.4.3华为OceanStor5000系列（v3）74
5.4.4EMCVNXe74
5.4.5HP3PAR76
5.4.6NimbleStorage77
5.5如何动手实验VVol78
5.6本章小结79
第6章OpenStackCinder80
6.1Cinder前世今生80
6.1.1OpenStack的由来80
6.1.2IaaS云计算的能力81
6.1.3OpenStack的发展81
6.1.4Cinder能做什么86
6.1.5Cinder支持的存储产品86
6.1.6Cinder提供的功能87
6.1.7Cinder的诞生88
6.1.8Cinder的生命力89
6.1.9Cinder、Swift、Ceph的区别93
6.2Cinder初体验93
6.2.1创建Volume操作93
6.2.2挂载Volume94
6.2.3扩展Volume大小94
6.2.4创建Snapshot96
6.3Cinder全景96
6.3.1Cinder的核心概念96
6.3.2Cinder的核心架构97
6.3.3创建Volume的流程98
6.3.4挂载Volume的流程98
6.3.5Cinder和Nova之间的调用100
6.3.6Cinder服务如何扩展101
6.3.7Cinder如何对接后端存储101
6.3.8Cinder的VolumeType101
6.3.9Cinder的QoS设置102
6.3.10如何添加新的Driver103
6.4存储厂商与Cinder104
6.4.1国外存储厂商104
6.4.2国内存储厂商105
6.5Cinder的部署106
6.5.1Cinder服务的高可用106
6.5.2Cinder与商业存储对接107
6.5.3Cinder的自动化部署109
6.6Cinder的未来110
6.7本章小结110
第7章EMCViPR111
7.1ViPRController简介111
7.1.1ViPRController介绍111
7.1.2ViPRController历史111
7.2ViPRController深入剖析112
7.2.1架构剖析112
7.2.2技术原理113
7.2.3功能特性120
7.2.4技术现状与未来123
7.3应用场景123
7.3.1存储自动化123
7.3.2存储即服务123
7.4本章小结124
第8章先智数据FederatorSDS125
8.1FederatorSDS简介125
8.1.1先智数据公司介绍125
8.1.2FederatorSDS是什么125
8.2FederatorSDS深入剖析127
8.2.1架构概述127
8.2.2技术原理133
8.2.3功能特性134
8.2.4技术现状与未来136
8.3应用场景136
8.4案例介绍137
8.4.1台中荣民总医院医疗云一体机137
8.4.2东芝亚太数据中心容灾139
8.5本章小结141
第9章飞康软件FreeStor142
9.1FreeStor简介142
9.2FreeStor深入剖析143
9.2.1IntelligentAbstraction143
9.2.2FreeStor的拓扑结构146
9.2.3FreeStor的智能分析149
9.3应用场景151
9.3.1FreeStor的异构存储整合151
9.3.2利用FreeStor的缓存技术为存储加速，替换高端阵列151
9.3.3FreeStor的异构容灾154
9.4本章小结162
第10章VMwareVSAN163
10.1VSAN简介163
10.1.1VSAN是什么163
10.1.2VSAN的能力165
10.1.3VSAN的市场166
10.2VSAN深入剖析166
10.2.1架构剖析166
10.2.2技术细节174
10.2.3功能特性185
10.2.4未来技术195
10.3应用场景197
10.4案例介绍198
10.4.1上海公安高等专科学校198
10.4.2山东新华书店199
10.5本章小结201
第11章EMCScaleIO202
11.1ScaleIO简介202
11.1.1ScaleIO介绍202
11.1.2ScaleIO历史202
11.2ScaleIO深入剖析203
11.2.1架构剖析203
11.2.2技术原理209
11.2.3功能特性210
11.2.4技术现状与未来213
11.3应用场景214
11.3.1数据库214
11.3.2服务器虚拟化215
11.3.3虚拟桌面215
11.3.4开发测试215
11.4案例介绍215
11.4.1瑞士电信215
11.4.2国内某运营商216
11.5本章小结217
第12章Ceph218
12.1Ceph简介218
12.1.1开源生态体系218
12.1.2技术平台219
12.1.3持续创新环境220
12.1.4广泛的用户基础221
12.2Ceph深入剖析222
12.2.1核心组件222
12.2.2统一存储222
12.2.3RADOS数据分布计算226
12.2.4RADOS数据管理228
12.2.5副本和ErasueCode230
12.2.6缓存分层存储230
12.2.7备份与容灾231
12.3未来展望232
12.3.1CephFS与容器232
12.3.2存储引擎233
12.3.3IO栈重构234
12.3.4多站点多活方案234
12.4应用场景235
12.4.1OpenStack与Ceph235
12.4.2对象存储提供238
12.5本章小结239
第13章HPEStoreVirtualVSA240
13.1HPEStoreVirtualVSA简介240
13.1.1HPEStoreVirtualVSA的历史240
13.1.2市场现状240
13.1.3设计思路241
13.2HPEStoreVirtualVSA深入剖析241
13.2.1架构剖析241
13.2.2功能特性248
13.2.3技术细节250
13.2.4技术现状与未来254
13.3应用场景254
13.3.1独立外置块存储设备254
13.3.2超融合架构系统255
13.4本章小结256
第14章达沃时代257
14.1达沃存储简介257
14.1.1研制背景257
14.1.2市场现状260
14.2达沃存储深入剖析264
14.2.1架构剖析264
14.2.2技术原理与功能特性266
14.2.3技术现状与未来271
14.3应用场景272
14.3.1硬件基础272
14.3.2部署形式272
14.3.3三种接口273
14.3.4广域存储274
14.4案例介绍274
14.4.1以数据为中心的超融合274
14.4.2统一的分布式存储276
14.4.3集中控制、分布部署的广域存储276
14.5本章小结278
第15章LenovoThinkCloudAIO279
15.1AIO简介280
15.1.1设计思路和原则280
15.1.2AIO产品定义280
15.1.3AIO架构模式281
15.1.4AIO优势分析284
15.2AIO深入剖析285
15.2.1架构剖析286
15.2.2技术原理291
15.2.3功能特性295
15.2.4产品序列298
15.2.5技术现状与未来298
15.3应用场景299
15.3.1企业级应用部署299
15.3.2企业IT云化实现302
15.4案例介绍303
15.4.1某出版社云平台建设303
15.4.2联想集团IT云化建设304
15.5本章小结305
第16章华云网际FusionStor306
16.1背景306
16.2FusionStor解决方案308
16.2.1主要特点308
16.2.2产品特性310
16.2.3技术参数310
16.2.4架构原理311
16.2.5关键技术原理313
16.3应用场景321
16.3.1云资源池场景321
16.3.2数据库场景（高IOPS、高带宽场景）321
16.4本章小结322
第17章天玑数据323
17.1天玑数据融合架构简介323
17.2天玑数据PBData数据库云平台深入剖析324
17.2.1架构介绍324
17.2.2功能特性及技术原理329
17.3应用场景341
17.3.1x86架构取代“小型机＋高端存储”传统架构341
17.3.2加速传统OLTP／OLAP业务341
17.3.3数据仓库、大数据分析平台和商业智能342
17.3.4OLTP、OLAP业务类型混合负载342
17.3.5异构数据库整合342
17.3.6中小型规模、成长型企业核心业务342
17.3.7数据库容灾系统343
17.3.8MPP型数据库平台部署343
17.4案例介绍343
17.4.1运营商行业典型业务系统解决方案343
17.4.2交通行业ACC系统解决方案346
17.4.3物流行业TOS系统解决方案347
17.5本章小结349
第18章云和恩墨350
18.1zData数据库存储平台简介350
18.1.1zData的性能351
18.1.2zData的高可用性353
18.1.3zData的扩展性353
18.1.4zData的其他功能353
18.2zData架构解析354
18.2.1存储节点和计算节点354
18.2.2zData存储的分布式355
18.3zData应用场景357
18.4本章小结358
第19章青云HCI359
19.1青云HCI简介360
19.2青云HCI架构深入剖析363
19.3青云HCI存储部分架构剖析367
19.3.1青云HCI对象存储367
19.3.2青云HCI对象存储架构369
19.3.3青云HCI对象存储的特点371
19.3.4青云HCI对象存储功能介绍374
19.4应用场景380
19.5案例介绍380
19.5.1青云公有云380
19.5.2某大型商业银行总行新一代开发测试云381
19.5.3某大型国有银行IT资源交付平台382
19.6本章小结383
第20章Zadara云阵384
20.1ZadaraVPSA简介384
20.1.1ZadaraVPSA是什么384
20.1.2ZadaraVPSA的能力386
20.1.3Zadara云阵的市场389
20.2ZadaraVPSA深入剖析390
20.2.1架构剖析390
20.2.2技术原理391
20.2.3功能特性394
20.2.4技术现状与未来395
20.3应用场景397
20.3.1企业级数据库397
20.3.2服务器虚拟化397
20.3.3VDI虚拟桌面397
20.3.4公有云／私有云397
20.3.5HPC／科学研究／开发测试398
20.3.6Zadara不适用场景398
20.4云阵存储性能398
20.4.1测试环境398
20.4.2一个VPSA性能测试400
20.4.3四个VPSA性能测试404
20.4.4总结406
20.5案例介绍406
20.5.1国家广电总局VDI案例406
20.5.2三甲医院数字化医疗存储系统408
20.6本章小结414
第21章SDS的备份415
21.1SDS备份的基本原理和技术选择416
21.1.1备份的基本原理和基础概念416
21.1.2SDS技术带给备份设计的挑战与机会418
21.1.3SDS备份中常见技术手段简介420
21.2SDS各种备份技术运用实例422
21.2.1备份整体架构设计423
21.2.2备份服务器配置和部署实例424
21.2.3通过Off—Host设计实现数据抽取的实例426
21.2.4与私有云管理平台集成的智能备份实例429
21.2.5SDS备份技术运用小结430
21.3SDS未来备份技术的趋势431
21.3.1备份会逐渐成为数据中心所提供的一个基础功能431
21.3.2备份数据将逐渐发挥更大的业务价值432
21.4本章小结434
第22章闪存存储与SDS436
22.1闪存存储简介436
22.1.1闪存存储特性437
22.1.2磨损平衡439
22.1.3垃圾回收441
22.2面向企业级应用的闪存存储设计442
22.2.1闪存存储接口技术442
22.2.2企业级PCIe闪存存储架构设计443
22.2.3企业级闪存存储可靠性和稳定性设计445
22.3闪存存储在SDS中的实践447
22.3.1闪存存储在SDS中的使用方式447
22.3.2闪存存储在SDS中的应用实例448
22.4新一代非易失性存储以及技术的分析和展望450
22.5本章小结451
第23章网络与SDS453
23.1InfiniBand技术简介454
23.1.1InfiniBand定义454
23.1.2InfiniBand架构454
23.1.3InfiniBand在行业中应用现状456
23.2高速网络通信协议RDMA458
23.2.1RDMA技术简介458
23.2.2RDMA的技术核心459
23.2.3实现RDMA的几种方式460
23.2.4如何使用RDMA465
23.2.5支持RDMA的存储协议468
23.3高速网络加速软件定义存储471
23.3.1Ceph471
23.3.2VSAN475
23.4本章小结476
第24章SAS与SDS477
24.1SAS协议和SAS协议的现状478
24.2服务器存储和计算物理解耦合479
24.3ServerSAN的数据读写通过SAS网络传输484
24.4数据写入硬盘从软件到硬件487
24.5云计算和软件定义存储490
24.6最后的一些话494
第25章内存虚拟化与SDS及DELLFluidCache495
25.1DELLSDS计划495
25.1.1“演化性”方法496
25.1.2“革命性”方法496
25.2DELLFluidCache简介497
25.2.1背景介绍497
25.2.2FluidCache简介497
25.3DELLFluidCache深入剖析499
25.3.1FluidCache的体系结构499
25.3.2FluidCache的功能特性500
25.4DELLFluidCache的应用场景502
25.5DELLFluidCache的未来展望503
25.6本章小结504
第26章容器与SDS505
26.1容器技术简介505
26.1.1容器技术的发展背景505
26.1.2容器技术应用的现状506
26.2容器技术深入剖析507
26.2.1容器的核心技术508
26.2.2Docker容器管理工具509
26.2.3容器的特性511
26.3容器的应用场景511
26.3.1云原生应用和微服务架构的载体511
26.3.2开发运维一体化512
26.3.3混合云512
26.4容器技术对SDS的影响512
26.4.1容器应用的存储需求512
26.4.2容器的存储架构513
26.4.3Docker的容器卷插件514
26.4.4Kubernetes的数据卷514
26.4.5Flocker515
26.4.6Portworx和OpenStorage516
26.4.7光子平台和VirtualSAN518
26.5本章小结519
赞誉521
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件定义存储
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ODL技术内幕：架构设计与实现原理
前言
第一部分　基础环境篇
第1章　阅读源代码前的准备  2
1.1　ODL项目介绍  2
1.1.1　ODL框架之争  3
1.1.2　SAL的演进  3
1.1.3　ODL的子项目及分类  4
1.1.4　ODL项目的管理  6
1.2　搭建ODL编译构建环境  6
1.2.1　安装JDK  6
1.2.2　安装及配置Maven  8
1.3　阅读和调试ODL源代码  9
1.3.1　ODL项目源码下载  9
1.3.2　IntelliJ IDEA安装  10
1.3.3　IntelliJ IDEA调试ODL的项目源码  11
1.4　ODL设计目标  12
1.5　ODL总体架构  13
1.6　本章小结  15
第2章　ODL项目管理设计详解  16
2.1　问题的提出  16
2.2　解决思路  17
2.3　实现详解  20
2.3.1　基础parent设计  20
2.3.2　模块构建  23
2.3.3　feature组织  24
2.3.4　版本打包  25
2.4　项目模板  26
2.4.1　项目目录布局设计  26
2.4.2　ODL模板项目  27
2.5　本章小结  28
第二部分　核心原理篇
第3章　ODL基本对象的设计与实现  30
3.1　QName  30
3.1.1　QName定义  30
3.1.2　QName对象比较  36
3.1.3　QName对象创建  37
3.2　YangInstanceIdentifier  38
3.2.1　Path接口定义  38
3.2.2　YangInstanceIdentifier的类定义  39
3.2.3　YangInstanceIdentifier的比较42
3.2.4　InstanceIdentifier类  44
3.3　NomalizedNode  44
3.3.1　NormalizedNode类的定义  45
3.3.2　NormalizedNode实例的创建48
3.4　本章小结  49
第4章　数据树的设计与实现  50
4.1　基本概念  50
4.1.1　配置树与状态树  51
4.1.2　标识与定位  51
4.1.3　快照与MVCC  52
4.2　数据树的设计与实现  52
4.2.1　Tree结构的设计  52
4.2.2　DataTree相关接口定义  55
4.2.3　DataTree的创建  57
4.3　数据树的读写过程  59
4.3.1　快照实现原理  61
4.3.2　数据校验的实现  61
4.4　MVCC机制与实现  63
4.4.1　版本号变更规则  63
4.4.2　并发控制  65
4.5　本章小结  67
第5章　MD-SAL DataStore接口设计  68
5.1　基本概念  69
5.1.1　事务和事务链  70
5.1.2　数据分片  70
5.1.3　三阶段提交  71
5.2　DataStore SPI设计  72
5.2.1　DOMStore  73
5.2.2　DOMStoreThreePhase-CommitCohort  75
5.2.3　DOMStoreTreePublisher  76
5.3　DataStore DOM API设计  77
5.3.1　DOMDataBroker  77
5.3.2　DOMDataTreeSharding-Service  78
5.3.3　DOMDataTreeChange-Service  80
5.4　DataStore Binding API设计  82
5.4.1　Binding基本对象接口  82
5.4.2　DataBroker  84
5.4.3　DataTreeChangeService  87
5.5　本章小结  87
第6章　MD-SAL DataStore的实现原理  88
6.1　概述  89
6.1.1　背景知识  89
6.1.2　实现原理  91
6.2　Raft算法及其实现  92
6.2.1　Raft算法介绍  93
6.2.2　RaftActor设计与实现  98
6.3　DataStore后端实现详解  106
6.3.1　Shard的实现  106
6.3.2　ShardManager  110
6.3.3　ShardStrategy及实现  112
6.4　DataStore前端实现详解  113
6.4.1　DOMStore的实现  113
6.4.2　DOMDataBroker的实现  121
6.4.3　事务链实现  124
6.5　Binding DataBroker的实现  125
6.5.1　Adapter设计  125
6.5.2　BindingDOMDataBroker-Adapter的初始化  126
6.6　本章小结  130
第7章　MD-SAL RPC的设计与实现  131
7.1　一个实例  131
7.1.1　RPC的YANG模型定义  131
7.1.2　RPC的生成接口  133
7.1.3　RPC的实现与调用  135
7.2　RPC机制的总体设计  136
7.2.1　Binding接口设计  136
7.2.2　DOM接口设计  137
7.2.3　总体实现流程  139
7.3　RPC机制实现详解  141
7.3.1　DOMBroker实现详解  141
7.3.2　BindingBroker实现详解  144
7.4　Remote RPC实现详解  149
7.4.1　Gossip协议的实现  150
7.4.2　远程RPC注册及调用  152
7.4.3　Actor设计实现总结  154
7.5　本章小结  155
第8章　MD-SAL Notification的设计与实现  156
8.1　一个实例  156
8.1.1　YANG模型定义  156
8.1.2　生成的接口  157
8.1.3　消息发布  157
8.1.4　消息订阅  158
8.2　MD-SAL Notification接口设计  158
8.2.1　DOM接口  159
8.2.2　Binding接口  160
8.3　MD-SAL Notification实现剖析  161
8.3.1　DOM层实现详解  161
8.3.2　Binding适配实现  169
8.4　本章小结  171
第9章　MD-SAL Mount机制与NETCONF  172
9.1　Mount服务接口设计  172
9.1.1　DOM接口  173
9.1.2　Binding接口  174
9.2　Mount机制的实现  175
9.2.1　DOM接口实现  176
9.2.2　NETCONF南向插件的实现  178
9.3　本章小结  186
第10章　MD-SAL Cluster Service  187
10.1　EntityOwnershipService  187
10.1.1　基本概念  187
10.1.2　接口设计  188
10.1.3　实现说明  192
10.2　ClusterSingletonService  195
10.2.1　接口设计  195
10.2.2　实现说明  196
10.3　本章小结  198
第三部分　公共组件篇
第11章　AAA  200
11.1　Shiro框架介绍  201
11.1.1　Shiro是什么  201
11.1.2　Shiro的架构  202
11.1.3　Shiro核心处理流程  204
11.2　AAA实现原理  210
11.2.1　Shiro配置优化  210
11.2.2　Realm的8个实现  212
11.2.3　Filter的实现  214
11.2.4　加解密服务  216
11.2.5　数字证书管理  218
11.3　本章小结  219
第12章　RESTCONF  220
12.1　RFC 8040解读  220
12.1.1　操作  221
12.1.2　消息  222
12.1.3　资源  223
12.2　RESTCONF的实现  226
12.2.1　Jersey框架简介  226
12.2.2　RESTCONF资源接口定义  228
12.2.3　Wrapper设计模式  231
12.2.4　初始化过程  233
12.2.5　客户端访问  235
12.3　本章小结  236
第13章　Blueprint及其扩展  237
13.1　Blueprint  238
13.1.1　基础知识  238
13.1.2　运行原理  240
13.1.3　命名空间扩展  241
13.2　Blueprint的使用  244
13.3　本章小结  247
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ODL技术内幕：架构设计与实现原理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MapReduce 2.0源码分析与编程实战
第1章　大象也会跳舞
1.1　大数据时代
1.2　大数据分析时代
1.3　简单、粗暴、有效这就是Hadoop
1.4　MapReduce与Hadoop
1.5　看，大象也会跳舞
本章小结
第2章　大象的肚子HDFS文件系统详解
2.1　HDFS基础详解
2.1.1　HDFS设计思路
2.1.2　HDFS架构与基本存储单元
2.2　HDFS数据存取流程分析
2.2.1　HDFS数据存储位置与复制详解
2.2.2　HDFS 输入流程分析
2.2.3　HDFS输出流程分析
2.3　HDFS命令行操作详解
2.3.1　HDFS中4个通用的命令行操作
2.3.2　HDFS文件18个基本命令行的操作
2.3.3　HDFS文件访问权限详解
2.4　通过Web浏览HDFS文件
2.5　HDFS接口使用详解
2.5.1　使用FileSystem API操作HDFS中的内容
2.5.2　使用FileSystem API读取数据详解
2.5.3　使用FileSystem API写入数据详解
2.6　HDFS文件同步与并发访问
本章小结
第3章　“吃下去吐出来”Hadoop文件I/O系统详解
3.1　Hadoop的压缩类型介绍
3.2　Hadoop的压缩类库
3.2.1　从一个简单的例子开始
3.2.2　CompressionCodec接口
3.2.3　CompressionCodecFactory类详解
3.2.4　压缩池
3.2.5　在Hadoop中使用压缩
3.3　I/O中序列化类型详解
3.3.1　Text类详解
3.3.2　IntWritable类详解
3.3.3　ObjectWritable类详解
3.3.4　NullWritable类详解
3.3.5　ByteWritable类详解
3.4　实现自定义的Writable类型
3.4.1　Writable接口
3.4.2　WritableComparable接口与RawComparator接口
3.4.3　自定义的Writable类
3.4.4　为了更快的比较
3.5　Hadoop中小文件处理详解
3.5.1　SequenceFile详解
3.5.2　MapFile详解
本章小结
第4章　“大象的大脑”MapReduce框架结构与源码分析
4.1　MapReduce框架结构与源码分析
4.1.1　MapReduce框架分析与执行过程详解
4.1.2　MapReduce输入输出与源码分析
4.1.3　MapReduce中Job类详解
4.2　编程实战：经典的MapReduce单词计数程序
4.2.1　准备工作
4.2.2　 MapReduce过程分析
4.2.3　计数程序的MapReduce实现
4.2.4　计数程序的main方法
4.2.5　注意事项
4.2.6　运行结果
4.2.7　Mapper中的Combiner详解
本章小结
第5章　深入！MapReduce配置与测试
5.1　MapReduce环境变量配置详解
5.1.1　使用XML配置新的配置文件
5.1.2　修改已有的配置文件
5.1.3　辅助类ToolRunner、Configured详解
5.2　使用MRUnit对MapReduce进行测试
5.2.1　MRUnit简介与使用
5.2.2　使用MRUnit完成Mapper单元测试
5.2.3　使用MRUnit完成Reduce单元测试
5.2.4 使用MRUnit完成MapReduce单元测试
5.3　在本地磁盘上进行MapReduce测试
5.3.1　伪环境欺骗
5.3.2　在Eclipse中配置Hadoop插件
5.3.3　编写本地测试代码
5.4　MapReduce计数器
5.4.1　使用计数器的MapReduce程序设计
5.4.2　通过Web接口进行任务分析
5.4.3　通过Web接口查看计数器
本章小结
第6章　大象的思考流程MapReduce运行流程详解
6.1　经典MapReduce任务的工作流程
6.1.1　ClientNode执行任务的初始化
6.1.2　消息传递
6.1.3　MapReduce任务的执行
6.1.4　任务的完成与状态更新
6.2　经典MapReduce任务异常处理详解
6.2.1　MapReduce任务异常的处理方式
6.2.2　MapReduce任务失败的处理方式
6.3　经典MapReduce任务的数据处理过程
6.3.1　Map端的输入数据处理过程
6.3.2　Reduce端的输入数据处理过程
6.3.3　Java虚拟机重用
6.4　MapReduce 2.0(YARN)工作流程详解
6.4.1　YARN概述
6.4.2　YARN任务过程分析
6.4.3　YARN的异常处理
本章小结
第7章　更强的大象MapReduce高级程序设计续
7.1　MapReduce程序设计默认格式类型详解
7.1.1　map与reduce方法的默认输入输出类型
7.1.2　自定义输入输出类型设置
7.1.3　自定义全局类型变量设置要求
7.1.4　默认的MapReduce程序设置
7.2　InputFormat输入格式详解
7.2.1　输入记录与分区
7.2.2　InputFormat源码及执行过程分析
7.2.3　实现自己的RecordReader类
7.2.4　自定义的FileInputFormat类
7.2.5　一些常用的InputFormat类详解
7.3　OutputFormat输出格式详解
7.3.1　OutputFormat默认输出格式
7.3.2　自定义OutputFormat输出格式
7.3.3　对Reduce任务数进行设置
7.3.4　OutputFormat分区类Partitioner详解
7.4　多种输入与输出使用介绍
7.4.1　MultipleInputs多种输入方式详解
7.4.2　MultipleOutputs多种输出方式详解
本章小结
第8章　MapReduce相关特性详解
8.1　MapReduce计数器
8.1.1　Hadoop框架内置的计数器
8.1.2　自定义计数器
8.1.3　动态计数器
8.1.4　获取计数器值
8.2　排序与查找
8.2.1　普通排序规则与查找
8.2.2　使用MapFile进行排序与查找
8.3　对输出结果的值分组排序
8.3.1　准备工作
8.3.2　对结果进行分组处理
8.3.3　对键的二次排序
8.3.4　自定义输出分组
8.4　编程实战：使用二次排序自动查找最小值
8.4.1　思路分析
8.4.2　验证输入输出结果
8.4.3　对结果进行二次排序
8.4.4　对结果进行分组
8.4.5　分片处理排序与分组
8.4.6　验证结果
本章小结
第9章　啤酒与尿布MapReduce连接与数据挖掘初步
9.1　对于同样格式数据进行MapReduce连接
9.2　对于不同格式数据进行MapReduce连接
9.3　不能说的秘密啤酒与尿布
9.3.1　销售清单的秘密
9.3.2　设计程序
9.3.3　程序执行结果
9.4　数据挖掘初步
本章小结
第10章　MapReduce实战编程及深度分析
10.1　编程实战：自定义数据库中读取数据
10.1.1　准备工作
10.1.2　程序分析
10.1.3　自定义SQLInputFormat
10.1.4　使用自定义程序从数据库中读取数据
10.1.5　程序运行及数据分析
10.1.6　使用合并记录进行性能调优
10.2　编程实战：串联寻找共同转载微博
10.2.1　应用分析
10.2.2　第一步表转换
10.2.3　建立关注连接
10.2.4　自定义的OutputFormat
10.2.5　串联解决共同转载微博
10.2.6　性能调优及后续处理
10.3　编程实战：云存储模型
10.3.1　应用分析
10.3.2　Tomcat简介
10.3.3　配置Tomcat服务器
10.3.4　测试Tomcat服务器
10.3.5　在Eclipse中配置Tomcat
10.3.6　创建云存储目录
10.3.7　获取云存储列表
10.3.8　将文件上传至数据云存储中
10.3.9　删除文件
10.3.10　下载云端存储文件
10.3.11　程序执行与性能调优
10.4　编程实战：多文档相似关键字检索
10.4.1　应用分析
10.4.2　自定义任务处理类
10.4.3　程序执行及后续分析
10.5　编程实战：学生成绩整理与分组
10.5.1　应用分析
10.5.2　自定义的ScoreWritable
10.5.3　自定义的MapReduce
10.5.4　自定义的分组
10.5.5　程序运行结果
10.5.6　采用更多分组类型
本章小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MapReduce 2.0源码分析与编程实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据算法
目录
前　　言
第1章　绪论1
1.1　大数据概述1
1.1.1　什么是大数据1
1.1.2　无处不在的大数据1
1.1.3　大数据的特点3
1.1.4　大数据的应用4
1.2　大数据算法5
1.2.1　大数据上求解问题的过程6
1.2.2　大数据算法的定义7
1.2.3　大数据的特点与大数据算法9
1.2.4　大数据算法的难度9
1.2.5　大数据算法的应用10
1.3　大数据算法设计与分析11
1.3.1　大数据算法设计技术11
1.3.2　大数据算法分析技术12
1.4　本书的内容13
习题13
第2章　时间亚线性算法14
2.1　时间亚线性算法概述14
2.1.1　平面图直径问题的亚线性算法14
2.1.2　排序链表搜索的亚线性算法16
2.1.3　两个多边形交集问题的多项式时间算法17
2.2　最小生成树代价估计18
2.2.1　连通分量个数估计算法18
2.2.2　最小生成树代价估计算法20
2.3　时间亚线性判定算法概述23
2.4　数组有序的判定算法25
2.5　串相等判定算法27
习题28
第3章　空间亚线性算法29
3.1　空间亚线性算法概述29
3.2　水库抽样31
3.3　寻找频繁元素的非随机算法32
3.3.1　频繁元素的精确解33
3.3.2　频繁元素的Misra-Gries算法33
3.4　估算不同元素的数量35
3.4.1　基本算法35
3.4.2　改进算法38
3.5　寻找频繁元素的随机算法42
3.5.1　略图法42
3.5.2　计数最小略图45
3.6　估计频率矩47
3.6.1　频率矩的AMS估计算法47
3.6.2　基于拔河略图的频率矩估计51
3.6.3　使用稳定分布估计范数53
习题57
第4章　外存算法概述60
4.1　外存存储结构与外存算法概述60
4.2　外存算法示例：外存排序算法64
4.2.1　外存归并排序算法64
4.2.2　外存多路快速排序算法68
4.2.3　外存计算的下界74
4.3　外存数据结构示例：外存搜索树77
习题78
第5章　外存查找结构80
5.1　B树80
5.2　加权平衡B树87
5.3　持久B树90
5.4　缓存树94
5.5　KDB树98
5.6　O树103
习题107
第6章　外存图数据算法109
6.1　线性表排名及其应用109
6.1.1　线性表排名问题109
6.1.2　欧拉回路114
6.1.3　父子关系判定115
6.1.4　前序计数116
6.1.5　计算子树大小117
6.2　时间前向处理方法117
6.2.1　DAG形式逻辑表达式计算问题118
6.2.2　最大独立集合算法121
6.3　缩图法124
6.3.1　基于缩图法的图连通分量计算半外存算法124
6.3.2　基于缩图法的图连通分量计算全外存算法126
6.3.3　最小生成树算法128
6.4　广度优先搜索和深度优先搜索128
6.4.1　有向图的BFS和DFS129
6.4.2　无向图的BFS134
6.4.3　无向图更高效的BFS算法136
6.5　单源最短路径139
6.5.1　竞赛树140
6.5.2　Dijkstra算法的I/O高效版本145
习题149
第7章　MapReduce算法概述150
7.1　MapReduce基础150
7.1.1　MapReduce的基本模型151
7.1.2　mapper和reducer152
7.1.3　partitioner与combiner155
7.2　MapReduce算法设计方法157
7.2.1　局部聚合158
7.2.2　两种重要的算法设计模式——词对法和条块法163
7.2.3　二次排序168
7.2.4　MapReduce算法设计与算法实现技巧168
习题170
第8章　MapReduce算法例析171
8.1　连接算法171
8.1.1　普通连接算法171
8.1.2　相似连接算法184
8.2　图算法192
8.2.1　基于广度优先搜索的MapReduce图处理算法193
8.2.2　PageRank的MapReduce算法197
8.2.3　最小生成树的MapReduce算法200
8.2.4　使用图算法的注意事项202
习题203
第9章　超越MapReduce的并行大数据处理204
9.1　基于迭代处理平台的并行算法204
9.2　基于图处理平台的并行算法212
9.2.1　并行结点计算213
9.2.2　并行结点计算的平台215
9.2.3　基于并行结点计算的单源最短路径算法的设计与实现219
9.2.4　计算子图同构221
习题223
第10章　众包算法224
10.1　众包的定义224
10.2　众包的实例225
10.3　众包的要素和关键技术228
10.3.1　众包的流程228
10.3.2　众包的报酬230
10.3.3　众包中的关键技术230
10.4　众包算法例析232
习题237
参考文献238
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据算法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Akka入门与实践
第 1 章 初识 Actor：Akka 工具集以及 Actor 模型的介绍。
第 2 章 Actor 与并发：响应式编程。Actor 与 Future 的使用。
第 3 章 传递消息：消息传递模式。
第 4 章 Actor 的生命周期—处理状态与错误：Actor 生命周期、监督机制、Stash/
Unstash、Become/Unbecome 以及有限自动机。
第 5 章 纵向扩展：并发编程、Router Group/Pool、Dispatcher、阻塞 I/O 的处理以
及 API。
第 6 章 横向扩展—集群化：集群、CAP 理论以及 Akka Cluster。
第 7 章 处理邮箱问题：加大邮箱负载、不同邮箱的选择、熔断机制。
第 8 章 测试与设计：行为说明、领域驱动设计以及 Akka Testkit。
第 9 章 尾声：其他 Akka 特性。下一步需要学习的知识。
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Akka入门与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spark大数据分析实战
前 言
第1章 Spark简介 1
1.1 初识Spark 1
1.2 Spark生态系统BDAS 3
1.3 Spark架构与运行逻辑 4
1.4 弹性分布式数据集 6
1.4.1 RDD简介 6
1.4.2 RDD算子分类 8
1.5 本章小结 17
第2章 Spark开发与环境配置 18
2.1 Spark应用开发环境配置 18
2.1.1 使用Intellij开发Spark程序 18
2.1.2 使用SparkShell进行交互式数据分析 23
2.2 远程调试Spark程序 24
2.3 Spark编译 26
2.4 配置Spark源码阅读环境 29
2.5 本章小结 29
第3章 BDAS简介 30
3.1 SQL on Spark 30
3.1.1 为什么使用Spark SQL 31
3.1.2 Spark SQL架构分析 32
3.2 Spark Streaming 35
3.2.1 Spark Streaming简介 35
3.2.2 Spark Streaming架构 38
3.2.3 Spark Streaming原理剖析 38
3.3 GraphX 45
3.3.1 GraphX简介 45
3.3.2 GraphX的使用简介 45
3.3.3 GraphX体系结构 48
3.4 MLlib 50
3.4.1 MLlib简介 50
3.4.2 MLlib中的聚类和分类 52
3.5 本章小结 57
第4章 Lamda架构日志分析流水线 58
4.1 日志分析概述 58
4.2 日志分析指标 61
4.3 Lamda架构 62
4.4 构建日志分析数据流水线 64
4.4.1 用Flume进行日志采集 64
4.4.2 用Kafka将日志汇总 68
4.4.3 用Spark Streaming进行实时日志分析 70
4.4.4 Spark SQL离线日志分析 75
4.4.5 用Flask将日志KPI可视化 78
4.5 本章小结 81
第5章 基于云平台和用户日志的推荐系统 82
5.1 Azure云平台简介 82
5.1.1 Azure网站模型 83
5.1.2 Azure数据存储 84
5.1.3 Azure Queue消息传递 84
5.2 系统架构 85
5.3 构建Node.js应用 86
5.3.1 创建Azure Web应用 87
5.3.2 构建本地Node.js网站 90
5.3.3 发布应用到云平台 90
5.4 数据收集与预处理 91
5.4.1 通过JS收集用户行为日志 92
5.4.2 用户实时行为回传到Azure Queue 94
5.5 Spark Streaming实时分析用户日志 96
5.5.1 构建Azure Queue的Spark Streaming Receiver 96
5.5.2 Spark Streaming实时处理Azure Queue日志 97
5.5.3 Spark Streaming数据存储于Azure Table 98
5.6 MLlib离线训练模型 99
5.6.1 加载训练数据 99
5.6.2 使用rating RDD训练ALS模型 100
5.6.3 使用ALS模型进行电影推荐 101
5.6.4 评估模型的均方差 101
5.7 本章小结 102
第6章 Twitter情感分析 103
6.1 系统架构 103
6.2 Twitter数据收集 104
6.2.1 设置 104
6.2.2 Spark Streaming接收并输出Tweet 109
6.3 数据预处理与Cassandra存储 111
6.3.1 添加SBT依赖 111
6.3.2 创建Cassandra Schema 112
6.3.3 数据存储于Cassandra 112
6.4 Spark Streaming热点Twitter分析 113
6.5 Spark Streaming在线情感分析 115
6.6 Spark SQL进行Twitter分析 118
6.6.1 读取Cassandra数据 118
6.6.2 查看JSON数据模式 118
6.6.3 Spark SQL分析Twitter 119
6.7 Twitter可视化 123
6.8 本章小结 125
第7章 热点新闻分析系统 126
7.1 新闻数据分析 126
7.2 系统架构 126
7.3 爬虫抓取网络信息 127
7.3.1 Scrapy简介 127
7.3.2 创建基于Scrapy的新闻爬虫 128
7.3.3 爬虫分布式化 133
7.4 新闻文本数据预处理 134
7.5 新闻聚类 135
7.5.1 数据转换为向量（向量空间模型VSM） 135
7.5.2 新闻聚类 136
7.5.3 词向量同义词查询 138
7.5.4 实时热点新闻分析 138
7.6 Spark Elastic Search构建全文检索引擎 139
7.6.1 部署Elastic Search 139
7.6.2 用Elastic Search索引MongoDB数据 141
7.6.3 通过Elastic Search检索数据 143
7.7 本章小结 145
第8章 构建分布式的协同过滤推荐系统 146
8.1 推荐系统简介 146
8.2 协同过滤介绍 147
8.2.1 基于用户的协同过滤算法User-based CF 148
8.2.2 基于项目的协同过滤算法Item-based CF 149
8.2.3 基于模型的协同过滤推荐Model-based CF 150
8.3 基于Spark的矩阵运算实现协同过滤算法 152
8.3.1 Spark中的矩阵类型 152
8.3.2 Spark中的矩阵运算 153
8.3.3 实现User-based协同过滤的示例 153
8.3.4 实现Item-based协同过滤的示例 154
8.3.5 基于奇异值分解实现Model-based协同过滤的示例 155
8.4 基于Spark的MLlib实现协同过滤算法 155
8.4.1 MLlib的推荐算法工具 155
8.4.2 MLlib协同过滤推荐示例 156
8.5 案例：使用MLlib协同过滤实现电影推荐 157
8.5.1 MovieLens数据集 157
8.5.2 确定ZUI佳的协同过滤模型参数 158
8.5.3 利用ZUI佳模型进行电影推荐 160
8.6 本章小结 161
第9章 基于Spark的社交网络分析 162
9.1 社交网络介绍 162
9.1.1 社交网络的类型 162
9.1.2 社交网络的相关概念 163
9.2 社交网络中社团挖掘算法 164
9.2.1 聚类分析和K均值算法简介 165
9.2.2 社团挖掘的衡量指标 165
9.2.3 基于谱聚类的社团挖掘算法 166
9.3 Spark中的K均值算法 168
9.3.1 Spark中与K均值有关的对象和方法 168
9.3.2 Spark下K均值算法示例 168
9.4 案例：基于Spark的Facebook社团挖掘 169
9.4.1 SNAP社交网络数据集介绍 169
9.4.2 基于Spark的社团挖掘实现 170
9.5 社交网络中的链路预测算法 172
9.5.1 分类学习简介 172
9.5.2 分类器的评价指标 173
9.5.3 基于Logistic回归的链路预测算法 174
9.6 Spark MLlib中的Logistic回归 174
9.6.1 分类器相关对象 174
9.6.2 模型验证对象 175
9.6.3 基于Spark的Logistic回归示例 175
9.7 案例：基于Spark的链路预测算法 177
9.7.1 SNAP符号社交网络Epinions数据集 177
9.7.2 基于Spark的链路预测算法 177
9.8 本章小结 179
第10章 基于Spark的大规模新闻主题分析 180
10.1 主题模型简介 180
10.2 主题模型LDA 181
10.2.1 LDA模型介绍 181
10.2.2 LDA的训练算法 183
10.3 Spark中的LDA模型 185
10.3.1 MLlib对LDA的支持 185
10.3.2 Spark中LDA模型训练示例 186
10.4 案例：Newsgroups新闻的主题分析 189
10.4.1 Newsgroups数据集介绍 190
10.4.2 交叉验证估计新闻的主题个数 190
10.4.3 基于主题模型的文本聚类算法 193
10.4.4 基于主题模型的文本分类算法 195
10.5 本章小结 196
第11章 构建分布式的搜索引擎 197
11.1 搜索引擎简介 197
11.2 搜索排序概述 198
11.3 查询无关模型PageRank 199
11.4 基于Spark的分布式PageRank实现 200
11.4.1 PageRank的MapReduce实现 200
11.4.2 Spark的分布式图模型GraphX 203
11.4.3 基于GraphX的PageRank实现 203
11.5 案例：GoogleWeb Graph的PageRank计算 204
11.6 查询相关模型Ranking SVM 206
11.7 Spark中支持向量机的实现 208
11.7.1 Spark中的支持向量机模型 208
11.7.2 使用Spark测试数据演示支持向量机的训练 209
11.8 案例：基于MSLR数据集的查询排序 211
11.8.1 Microsoft Learning to Rank数据集介绍 211
11.8.2 基于Spark的Ranking SVM实现 212
11.9 本章小结 213
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spark大数据分析实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Windows Azure从入门到精通
第1章 云计算基础
1.1 云计算的方式
1.1.1 基础结构即服务
1.1.2 软件即服务
1.1.3 平台即服务
1.1.4 定义云服务
1.2 长期展望
1.3 Windows Azure作为PaaS方案
1.3.1 小公司的大好机遇
1.3.2 大公司的大好机遇
1.4 Windows Azure和云计算
1.5 小结
第2章 Windows Azure平台基础
2.1 操作系统
2.2 服务创建
2.3 Windows Azure存储
2.4 工作者角色
2.5 虚拟机角色
2.6 Windows Azure AppFabric
2.6.1 服务总线
2.6.2 访问控制
2.6.3 缓存服务
2.6.4 集成服务
2.6.5 复合应用程序
2.7 SQL Azure
2.8 小结
第3章 创建Web角色项目
3.1 SDK
3.2 Windows Azure Tools for Visual Studio
3.3 WebRole项目模板
3.4 云项目
3.5 部署到Windows Azure
3.6 配置和升级
3.7 服务定义文件
3.8 角色属性
3.9 小结
3.10 快速参考
第4章 Windows Azure存储
4.1 本地存储
4.2 Windows Azure存储帐户
4.3 Windows Azure Management Tool
4.4 Bolb API
4.5 小结
4.6 快速参考
第5章 表、队列和工作者角色
5.1 表服务
5.2 队列服务
5.3 小结
5.4 快速参考
第6章 Windows Azure操作系统
6.1 Live ID、订阅和记帐
6.2 地缘组
6.3 内容交付网络(CDN)
6.4 证书
6.5 诊断
6.6 小结
6.7 快速参考
第7章 构建AppFabric解决方案
7.1 Windows Azure AppFabric组件
7.2 服务总线
7.3 直接连接
7.4 绑定
7.5 HTTP for Management URI
7.6 小结
7.7 快速参考
第8章 WCF数据服务和OData
8.1 Astoria项目
8.2 WCF数据服务
8.3 基本构建单元
8.4 WCF数据服务
8.5 查询和关系
8.6 筛选、排序和分页
8.7 WCF数据服务客户端
8.8 .NET Framework客户端
8.9 安全性简介
8.10 小结
8.11 快速参考
第9章 使用SQL Azure
9.1 SQL Azure功能
9.2 SQL Azure数据库访问
9.3 在云端创建数据库服务器
9.4 SQL Azure访问
9.5 SQL Azure关系引擎功能
9.6 现有数据库的迁移
9.7 SQL Azure迁移向导
9.8 小结
9.9 快速参考
第10章 从任何地方访问Azure服务
10.1 创建存储帐户项目
10.2 从PHP访问存储帐户
10.3 使用HTTP和REST
10.4 小结
10.5 快速参考
第11章 应用程序构架
11.1 多层解决方案的特征
11.2 数据访问层
11.3 服务代理
11.4 小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Windows Azure从入门到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>互联网计算的原理与实践
序
前言
第一篇 基础篇
第一章 互联网计算概述
1．1 引言
1．2 互联网发展梗概
1．3 互联网计算和互联网分布式系统
1．3．1 互联网计算和互联网分布式系统的概念
1．3．2 互联网分布式系统的核心要素
1．3．3 互联网分布式系统的分类
1．4 典型互联网分布式系统
1．4．1 网格计算系统
1．4．2 面向服务的EAI系统
1．4．3 云计算系统
1．4．4 社会计算系统
1．4．5 互联网内容服务系统
1．4．6 分析和比较
1．5 互联网分布式系统的主要特征
1．5．1 支持资源的跨域共享与集成
1．5．2 满足大规模多样化的用户需求
.1．5．3 以面向服务为基本范型
1．5．4 采用软件即服务的部署、运营和使用模式
1．5．5 支持开放环境下的可伸缩性
1．5．6 支持开放环境下的可用性与可靠性
1．5．7 可在线演化与动态优化
1．6 互联网分布式系统的发展路线
1．7 本章小结
第二章 互联网计算相关基础
2．1 引言
2．2 软件工程与互联网计算
2．2．1 软件编程范型
2．2．2 软件生命周期
2．2．3 软件体系结构
2．3 分布式系统与互联网计算
2．3．1 分布式系统体系结构
2．3．2 远程对象和远程调用
2．3．3 资源命名
2．3．4 消息和通信
2．3．5 同步和分布式事务
2．3．6 复制和一致性
2．3．7 安全
2．4 应用集成与互联网计算
2．4．1 数据集成、流程集成与界面集成
2．4．2 服务集成及面向服务体系结构(SOA)基础
2．4．3 应用集成中间件
2．5 万维网工程与互联网计算
2．5．1 万维网的起源
2．5．2 万维网基本原理
2．5．3 Web 2．0：利用群体智能的万维网
2．5．4 语义网：智能化的万维网
2．6 本章小结
第二篇 原理篇
第三章 互联网分布式系统的体系结构
3．1 引言
3．2 网格和云计算系统的体系结构分析
3．3 社会基础设施对分布式系统体系结构演化的影响
3．4 分布式系统体系结构的演化趋势
3．5 互联网分布式系统的CSI参考体系结构
3．6 CSI典型实例分析
3．6．1 Google AppEngine：Google的云计算平台
3．6．2 Eucalyptus：开源的云计算平台
3．6．3 Windows Azure：微软的云计算平台
3．7 本章小结
第四章 互联网分布式系统的数据资源存储与管理
4．1 引言
4．2 分布式key／value数据存储与管理系统
4．2．1 基础数据结构及数据访问
4．2．2 数据划分
4．2．3 复制和一致性保障
4．2．4 可用性保障
4．3 支持多租户的数据库
4．3．1 数据共享的三种方式
4．3．2 共享表方式下的多租户数据模型
4．3．3 几种数据模型的比较
4．4 基于MapReducc并行编程的海量数据处理
4．4．1 计算模型
4．4．2 实现原理
4．5 典型实例分析
4．5．1 Dynamo：高可用的分布式key／value数据存储与管理系统
4．5．2 Cassandra：开源的高可伸缩分布式key／value数据存储与管理系统
4．5．3 Force：支持多租户的数据库系统
4．5．4 Hadoop：MapReduce的开源实现
4．6 本章小结
第五章 服务资源的建模、虚拟化、组合、管理及监控
5．1 引言
5．2 服务和服务计算
5．3 服务模型
5．3．1 基本概念
5．3．2 汀服务模型
5．3．3 业务服务模型
5．3．4 REST服务
5．3．5 REST服务和SOAP服务应用实例
5．4 服务虚拟化
5．4．1 服务虚拟化的目标与原理
5．4．2 需求分析与业务服务建模
5．4．3 IT服务建模
5．4．4 聚合过程
5．5 服务组合
5．5．1 基于服务组合的互联网应用
5．5．2 服务组合编程范型
5．5．3 IT人员主导的服务组合
5．5．4 最终用户主导的服务组合
5．6 服务管理和监控
5．6．1 服务元数据管理
5．6．2 服务监控
5．6．3 服务质量保障
5．7 本章小结
第六章 XaaS模式的第三方运营与优化
6．1 引言
6．2 基本概念
6．2．1 XaaS模式下应用软件的运营模式分类
6．2．2 XaaS模式概念模型和软件生命周期
6．2．3 XaaS模式下应用软件的体系结构
6．3 XaaS模式第三方运营与优化的基本特征
6．3．1 多租户
6．3．2 多租户的资源共享和优化
6．3．3 可伸缩性
6．3．4 可用性与可靠性
6．3．5 可配置能力
6．4 典型实例分析
6．4．1 AppEngine基本原理
6．4．2 AppEngine应用程序的开发环境和部署过程
6．4．3 AppEngine的实现
6．5 本章小结
第七章 互联网分布式系统的安全和信任
7．1 引言
7．2 概述
7．3 XaaS模式下的用户认证与授权机制
7．4 云计算环境中的私有数据保护
7．5 本章小结
第八章 VINCA互联网服务集成方法
8．1 引言
8．2 VINCA体系结构和基本原理
8．3 业务级服务抽象与管控
8．3．1 VINCA业务服务
8．3．2 领域相关的服务社区定制
8．3．3 基于服务协作网络的服务监控
8．4 最终用户服务编程
8．4．1 探索式服务组合
8．4．2 基于业务服务的业务流程建模
8．4．3 基于嵌套表格的Mash叩应用构造
8．5 基于多引擎架构的应用托管与运行优化
8．6 本章小结
第九章 VINCA软件及应用
9．1 引言
9．2 VINCA服务社区管理器
9．3 VINCA服务编程工具
9．4 VINCA托管运行环境
9．5 VINCA应用示例
9．5．1 区域医疗信息化及区域医疗信息共享与协作
9．5．2 基于VINCA的区域医疗信息共享及协作
9．5．3 区域医疗信息共享与协作平台搭建及应用实现
9．6 本章小结
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>互联网计算的原理与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>PostgreSQL实战
Contents  目录
序言
前言
基　础　篇
第1章　安装与配置基础2
1.1　初识PostgreSQL2
1.1.1　PostgreSQL的特点3
1.1.2　许可3
1.1.3　邮件列表和讨论区3
1.2　安装PostgreSQL3
1.2.1　通过yum源安装4
1.2.2　通过源码编译安装5
1.2.3　设置一个软链接7
1.3　客户端程序和服务器程序8
1.3.1　客户端程序8
1.3.2　服务器程序11
1.4　创建数据库实例11
1.4.1　创建操作系统用户11
1.4.2　创建数据目录12
1.4.3　初始化数据目录13
1.5　启动和停止数据库服务器14
1.5.1　使用service方式15
1.5.2　使用pg_ctl进行管理15
1.5.3　其他启动和关闭数据库服务器的方式16
1.5.4　配置开机启动16
1.6　数据库配置基础17
1.6.1　配置文件的位置17
1.6.2　pg_hba.conf17
1.6.3　postgresql.conf19
1.6.4　允许远程访问数据库20
1.7　本章小结22
第2章　客户端工具23
2.1　pgAdmin 4简介23
2.1.1　pgAdmin 4 安装23
2.1.2　pgAdmin 4 使用23
2.2　psql功能及应用26
2.2.1　使用psql连接数据库26
2.2.2　psql元命令介绍28
2.2.3　psql导入、导出表数据31
2.2.4　psql的语法和选项介绍34
2.2.5　psql执行sql脚本36
2.2.6　psql如何传递变量到SQL37
2.2.7　使用psql定制日常维护脚本38
2.2.8　psql亮点功能39
2.3　本章小结43
第3章　数据类型44
3.1　数字类型44
3.1.1　数字类型列表44
3.1.2　数字类型操作符和数学函数46
3.2　字符类型47
3.2.1　字符类型列表47
3.2.2　字符类型函数48
3.3　时间/日期类型49
3.3.1　时间/日期类型列表49
3.3.2　时间/日期类型操作符50
3.3.3　时间/日期类型常用函数51
3.4　布尔类型52
3.5　网络地址类型53
3.5.1　网络地址类型列表54
3.5.2　网络地址操作符55
3.5.3　网络地址函数56
3.6　数组类型56
3.6.1　数组类型定义56
3.6.2　数组类型值输入56
3.6.3　查询数组元素57
3.6.4　数组元素的追加、删除、更新58
3.6.5　数组操作符58
3.6.6　数组函数59
3.7　范围类型60
3.7.1　范围类型列表60
3.7.2　范围类型边界61
3.7.3　范围类型操作符62
3.7.4　范围类型函数62
3.7.5　给范围类型创建索引63
3.8　json/jsonb类型63
3.8.1　json类型简介63
3.8.2　查询json数据64
3.8.3　jsonb与json差异64
3.8.4　jsonb与json操作符65
3.8.5　jsonb与json函数66
3.8.6　jsonb键/值的追加、删除、更新66
3.9　数据类型转换68
3.9.1　通过格式化函数进行转换68
3.9.2　通过CAST函数进行转换68
3.9.3　通过::操作符进行转换69
3.10　本章小结70
第4章　SQL高级特性71
4.1　WITH查询71
4.1.1　复杂查询使用CTE71
4.1.2　递归查询使用CTE72
4.2　批量插入74
4.2.1　方式一：INSERT INTO...SELECT...74
4.2.2　方式二：INSERT INTO VALUES (),(),...()75
4.2.3　方式三：COPY或\COPY元命令75
4.3　RETURNING返回修改的数据76
4.3.1　RETURNING返回插入的数据76
4.3.2　RETURNING返回更新后数据77
4.3.3　RETURNING返回删除的数据77
4.4　UPSERT78
4.4.1　UPSERT场景演示78
4.4.2　UPSERT语法79
4.5　数据抽样80
4.5.1　SYSTEM抽样方式81
4.5.2　BERNOULLI抽样方式82
4.6　聚合函数84
4.6.1　string_agg函数84
4.6.2　array_agg函数85
4.7　窗口函数86
4.7.1　窗口函数语法86
4.7.2　avg() OVER()87
4.7.3　row_number()88
4.7.4　rank()89
4.7.5　dense_rank ()89
4.7.6　lag()90
4.7.7　first_value ()91
4.7.8　last_value ()91
4.7.9　nth_value ()92
4.7.10　窗口函数别名的使用92
4.8　本章小结93
核　心　篇
第5章　体系结构96
5.1　逻辑和物理存储结构96
5.1.1　逻辑存储结构96
5.1.2　物理存储结构97
5.2　进程结构105
5.2.1　守护进程与服务进程105
5.2.2　辅助进程105
5.3　内存结构106
5.3.1　本地内存106
5.3.2　共享内存107
5.4　本章小结107
第6章　并行查询109
6.1　并行查询相关配置参数109
6.2　并行扫描111
6.2.1　并行顺序扫描111
6.2.2　并行索引扫描112
6.2.3　并行index-only扫描114
6.2.4　并行bitmap heap扫描115
6.3　并行聚合117
6.4　多表关联119
6.4.1　Nested loop多表关联120
6.4.2　Merge join多表关联121
6.4.3　Hash join多表关联122
6.5　本章小结124
第7章　事务与并发控制125
7.1　事务和并发控制的概念125
7.1.1　事务的基本概念和性质125
7.1.2　并发引发的现象126
7.1.3　ANSI SQL标准的事务隔离级别129
7.2　PostgreSQL的事务隔离级别130
7.2.1　查看和设置数据库的事务隔离级别131
7.2.2　修改全局的事务隔离级别132
7.2.3　查看当前会话的事务隔离级别132
7.2.4　设置当前会话的事务隔离级别132
7.2.5　设置当前事务的事务隔离级别133
7.3　PostgreSQL的并发控制133
7.3.1　基于锁的并发控制134
7.3.2　基于多版本的并发控制134
7.3.3　通过pageinspect观察MVCC137
7.3.4　使用pg_repack解决表膨胀问题140
7.3.5　支持事务的DDL140
7.4　本章小结141
第8章　分区表142
8.1　分区表的意义142
8.2　传统分区表143
8.2.1　继承表143
8.2.2　创建分区表145
8.2.3　使用分区表146
8.2.4　查询父表还是子表147
8.2.5　constraint_exclusion参数148
8.2.6　添加分区150
8.2.7　删除分区150
8.2.8　分区表相关查询151
8.2.9　性能测试152
8.2.10　传统分区表注意事项155
8.3　内置分区表155
8.3.1　创建分区表155
8.3.2　使用分区表157
8.3.3　内置分区表原理探索157
8.3.4　添加分区158
8.3.5　删除分区158
8.3.6　性能测试159
8.3.7　constraint_exclusion参数161
8.3.8　更新分区数据162
8.3.9　内置分区表注意事项162
8.4　本章小结163
第9章　PostgreSQL的NoSQL特性164
9.1　为jsonb类型创建索引164
9.2　json、jsonb读写性能测试165
9.2.1　创建json、jsonb测试表165
9.2.2　json、jsonb表写性能测试166
9.2.3　json、jsonb表读性能测试166
9.3　全文检索对json和jsonb数据类型的支持169
9.3.1　PostgreSQL全文检索简介170
9.3.2　json、jsonb全文检索实践173
9.4　本章小结176
进　阶　篇
第10章　性能优化180
10.1　服务器硬件180
10.2　操作系统优化181
10.2.1　常用Linux性能工具181
10.2.2　Linux系统的I/O调度算法189
10.2.3　预读参数调整190
10.2.4　内存的优化190
10.3　数据库调优193
10.3.1　全局参数调整193
10.3.2　统计信息和查询计划194
10.3.3　索引管理与维护201
10.4　本章小结203
第11章　基准测试与pgbench204
11.1　关于基准测试204
11.1.1　基准测试的常见使用场景205
11.1.2　基准测试衡量指标205
11.1.3　基准测试的原则205
11.2　使用pgbench进行测试206
11.2.1　pgbench的测试结果报告206
11.2.2　通过内置脚本进行测试207
11.2.3　使用自定义脚本进行测试210
11.2.4　其他选项212
11.3　本章小结214
第12章　物理复制和逻辑复制215
12.1　异步流复制216
12.1.1　以拷贝数据文件方式部署流复制216
12.1.2　以pg_basebackup方式部署流复制222
12.1.3　查看流复制同步方式223
12.2　同步流复制224
12.2.1　synchronous_commit参数详解224
12.2.2　配置同步流复制225
12.2.3　同步流复制的典型“陷阱”226
12.3　单实例、异步流复制、同步流复制性能测试227
12.3.1　读性能测试228
12.3.2　写性能测试230
12.4　流复制监控231
12.4.1　pg_stat_replication231
12.4.2　监控主备延迟233
12.4.3　pg_stat_wal_receiver234
12.4.4　相关系统函数235
12.5　流复制主备切换236
12.5.1　判断主备角色的五种方法236
12.5.2　主备切换之文件触发方式238
12.5.3　主备切换之pg_ctl promote方式240
12.5.4　pg_rewind241
12.6　延迟备库244
12.6.1　延迟备库的意义244
12.6.2　延迟备库部署244
12.6.3　recovery_min_apply_delay参数对同步复制的影响246
12.7　同步复制优选提交247
12.7.1　synchronous_standby_names参数详解248
12.7.2　基于优先级的同步备库249
12.7.3　基于Quorum的同步备库250
12.8　级联复制251
12.8.1　级联复制物理架构252
12.8.2　级联复制部署253
12.9　流复制维护生产案例255
12.9.1　案例一：主库上创建表空间时备库宕机255
12.9.2　案例二：备库查询被中止257
12.9.3　案例三：主库上的WAL被覆盖导致备库不可用259
12.10　逻辑复制265
12.10.1　逻辑解析265
12.10.2　逻辑复制架构267
12.10.3　逻辑复制部署268
12.10.4　逻辑复制DML数据验证273
12.10.5　逻辑复制添加表、删除表274
12.10.6　逻辑复制启动、停止276
12.10.7　逻辑复制配置注意事项和限制277
12.10.8　逻辑复制延迟测试278
12.11　本章小结280
第13章　备份与恢复281
13.1　备份与恢复概述281
13.2　增量备份283
13.2.1　开启WAL归档284
13.2.2　创建基础备份285
13.3　指定时间和还原点的恢复288
13.3.1　恢复到最近时间点289
13.3.2　恢复到指定时间点291
13.3.3　恢复到指定还原点292
13.3.4　恢复到指定事务294
13.3.5　恢复到指定时间线296
13.4　SQL转储和文件系统级别的备份298
13.4.1　SQL转储298
13.4.2　文件系统级别的备份301
13.5　本章小结301
第14章　高可用302
14.1　Pgpool-II+异步流复制实现高可用303
14.1.1　pgpool部署架构图304
14.1.2　pgpool部署305
14.1.3　PCP管理接口配置312
14.1.4　pgpool方案高可用测试313
14.1.5　pgpool方案常见错误处理318
14.2　基于Keepalived+异步流复制实现高可用321
14.2.1　Keepalived+异步流复制部署架构图321
14.2.2　Keepalived+异步流复制高可用方案部署322
14.2.3　Keepalived配置324
14.2.4　Keepalived方案高可用测试329
14.3　本章小结333
第15章　版本升级334
15.1　版本介绍334
15.2　小版本升级335
15.3　大版本升级336
15.3.1　通过pg_dumpall进行大版本升级336
15.3.2　通过pg_upgrade进行大版本升级339
15.3.3　使用pglogical升级大版本346
15.4　本章小结350
第16章　扩展模块351
16.1　CREATE EXTENSION351
16.2　pg_stat_statements353
16.3　auto_explain356
16.4　pg_prewarm357
16.5　file_fdw359
16.5.1　SQL/MED简介359
16.5.2　file_fdw部署360
16.5.3　使用file_fdw分析数据库日志362
16.6　postgres_fdw364
16.6.1　postgres_fdw部署364
16.6.2　postgres_fdw外部表支持写操作366
16.6.3　postgres_fdw支持聚合函数下推367
16.7　Citus369
16.7.1　Citus特性370
16.7.2　Citus安装370
16.7.3　Citus管理372
16.7.4　创建分布表373
16.7.5　Citus参数配置373
16.7.6　Citus常用功能374
16.8　本章小结377
第17章　Oracle数据库迁移PostgreSQL实践378
17.1　项目准备378
17.2　数据库对象迁移379
17.3　应用代码改造380
17.4　数据迁移测试384
17.5　功能测试和性能测试388
17.6　生产割接389
17.7　oracle_fdw部署过程中的常见错误389
17.8　本章小结391
第18章　PostGIS392
18.1　安装与配置392
18.2　创建GIS数据库393
18.3　几何对象393
18.3.1　几何对象的输入394
18.3.2　几何对象的存储394
18.3.3　几何对象的输出395
18.3.4　几何对象的运算395
18.4　应用场景：圈人与地理围栏397
18.4.1　空间索引398
18.4.2　地理围栏399
18.5　本章小结399
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>PostgreSQL实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud 微服务架构开发实战
内容简介
前言
第1章 微服务概述
1.1 传统软件行业面临的挑战
1.2 常见分布式系统架构
1.3 单块架构如何进化为微服务架构
1.4 微服务架构的设计原则
1.5 如何来设计微服务系统
第2章 微服务的基石——Spring Boot
2.1 Spring Boot 简介
2.2 开启第一个 Spring Boot 项目
2.3 Hello World
2.4 如何搭建开发环境
2.5 Gradle 与 Maven 的抉择
第3章 Spring Boot 的高级主题
3.1 构建 RESTful 服务
3.2 Spring Boot 的配置详解
3.3 内嵌 Servlet 容器
3.4 实现安全机制
3.5 允许跨域访问
3.6 消息通信
3.7 数据持久化
3.8 实现热插拔（hot swapping）
第4章 微服务的测试
4.1 测试概述
4.2 测试的类型和范围
4.3 如何进行微服务的测试
第5章 微服务的协调者——Spring Cloud
5.1 Spring Cloud 简介
5.2 Spring Cloud 入门配置
5.3 Spring Cloud 的子项目介绍
第6章 服务拆分与业务建模
6.1 从一个天气预报系统讲起
6.2 使用Redis提升应用的并发访问能力
6.3 实现天气数据的同步
6.4 给天气预报一个“面子”
6.5 如何进行微服务的拆分
6.6 领域驱动设计与业务建模
第7章 天气预报系统的微服务架构设计与实现
7.1 天气预报系统的架构设计
7.2 天气数据采集微服务的实现
7.3 天气数据API微服务的实现
7.4 天气预报微服务的实现
7.5 城市数据API微服务的实现
第8章 微服务的注册与发现
8.1 服务发现的意义
8.2 如何集成 Eureka Server
8.3 如何集成 Eureka Client
8.4 实现服务的注册与发现
第9章 微服务的消费
9.1 微服务的消费模式
9.2 常见微服务的消费者
9.3 使用 Feign 实现服务的消费者
9.4 实现服务的负载均衡及高可用
第10章 API 网关
10.1 API 网关的意义
10.2 常见 API 网关的实现方式
10.3 如何集成Zuul
10.4 实现 API 网关
第11章 微服务的部署与发布
11.1 部署微服务将面临的挑战
11.2 持续交付与持续部署微服务
11.3 基于容器的部署与发布微服务
11.4 使用 Docker 来构建、运行、发布微服务
第12章 微服务的日志与监控
12.1 微服务日志管理将面临的挑战
12.2 日志集中化的意义
12.3 常见日志集中化的实现方式
12.4 Elastic Stack 实现日志集中化
第13章 微服务的集中化配置
13.1 为什么需要集中化配置
13.2 使用 Config 实现的配置中心
第14章 微服务的高级主题——自动扩展
14.1 什么是自动扩展
14.2 自动扩展的意义
14.3 自动扩展的常见模式
14.4 如何实现微服务的自动扩展
第15章 微服务的高级主题——熔断机制
15.1 什么是服务的熔断机制
15.2 熔断的意义
15.3 熔断与降级的区别
15.4 如何集成 Hystrix
15.5 实现微服务的熔断机制
第16章 微服务的高级主题——分布式消息总线
16.1 什么是消息总线
16.2 Spring Cloud Bus 设计原理
16.3 如何集成 Bus
16.4 实现配置信息的自动更新
附录A：本书所涉及到的技术及相关版本
参考资料
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud 微服务架构开发实战
