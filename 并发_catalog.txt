>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>亿级流量网站架构核心技术
第1部分 概述 / 1
1 交易型系统设计的一些原则 / 2
1.1 高并发原则 / 3
1.1.1 无状态 / 3
1.1.2 拆分 / 3
1.1.3 服务化 / 4
1.1.4 消息队列 / 4
1.1.5 数据异构 / 6
1.1.6 缓存银弹 / 7
1.1.7 并发化 / 9
1.2 高可用原则 / 10
1.2.1 降级 / 10
1.2.2 限流 / 11
1.2.3 切流量 / 12
1.2.4 可回滚 / 12
1.3 业务设计原则 / 12
1.3.1 防重设计 / 13
1.3.2 幂等设计 / 13
1.3.3 流程可定义 / 13
1.3.4 状态与状态机 / 13
1.3.5 后台系统操作可反馈 / 14
1.3.6 后台系统审批化 / 14
1.3.7 文档和注释 / 14
1.3.8 备份 / 14
1.4 总结 / 14
第2部分 高可用 / 17
2 负载均衡与反向代理 / 18
2.1 upstream配置 / 20
2.2 负载均衡算法 / 21
2.3 失败重试 / 23
2.4 健康检查 / 24
2.4.1 TCP心跳检查 / 24
2.4.2 HTTP心跳检查 / 25
2.5 其他配置 / 25
2.5.1 域名上游服务器 / 25
2.5.2 备份上游服务器 / 26
2.5.3 不可用上游服务器 / 26
2.6 长连接 / 26
2.7 HTTP反向代理示例 / 29
2.8 HTTP动态负载均衡 / 30
2.8.1 Consul+Consul-template / 31
2.8.2 Consul+OpenResty / 35
2.9 Nginx四层负载均衡 / 39
2.9.1 静态负载均衡 / 39
2.9.2 动态负载均衡 / 41
参考资料 / 42
3 隔离术 / 43
3.1 线程隔离 / 43
3.2 进程隔离 / 45
3.3 集群隔离 / 45
3.4 机房隔离 / 46
3.5 读写隔离 / 47
3.6 动静隔离 / 48
3.7 爬虫隔离 / 49
3.8 热点隔离 / 50
3.9 资源隔离 / 50
3.10 使用Hystrix实现隔离 / 51
3.10.1 Hystrix简介 / 51
3.10.2 隔离示例 / 52
3.11 基于Servlet 3实现请求隔离 / 56
3.11.1 请求解析和业务处理线程池分离 / 57
3.11.2 业务线程池隔离 / 58
3.11.3 业务线程池监控/运维/降级 / 58
3.11.4 如何使用Servlet 3异步化 / 59
3.11.5 一些Servlet 3异步化压测数据 / 64
4 限流详解 / 66
4.1 限流算法 / 67
4.1.1 令牌桶算法 / 67
4.1.2 漏桶算法 / 68
4.2 应用级限流 / 69
4.2.1 限流总并发/连接/请求数 / 69
4.2.2 限流总资源数 / 70
4.2.3 限流某个接口的总并发/请求数 / 70
4.2.4 限流某个接口的时间窗请求数 / 70
4.2.5 平滑限流某个接口的请求数 / 71
4.3 分布式限流 / 75
4.3.1 Redis+Lua实现 / 76
4.3.2 Nginx+Lua实现 / 77
4.4 接入层限流 / 78
4.4.1 ngx_http_limit_conn_module / 78
4.4.2 ngx_http_limit_req_module / 80
4.4.3 lua-resty-limit-traffic / 88
4.5 节流 / 90
4.5.1 throttleFirst/throttleLast / 90
4.5.2 throttleWithTimeout / 91
参考资料 / 92
5 降级特技 / 93
5.1 降级预案 / 93
5.2 自动开关降级 / 95
5.2.1 超时降级 / 95
5.2.2 统计失败次数降级 / 95
5.2.3 故障降级 / 95
5.2.4 限流降级 / 95
5.3 人工开关降级 / 96
5.4 读服务降级 / 96
5.5 写服务降级 / 97
5.6 多级降级 / 98
5.7 配置中心 / 100
5.7.1 应用层API封装 / 100
5.7.2 配置文件实现开关配置 / 101
5.7.3 配置中心实现开关配置 / 102
5.8 使用Hystrix实现降级 / 106
5.9 使用Hystrix实现熔断 / 108
5.9.1 熔断机制实现 / 108
5.9.2 配置示例 / 112
5.9.3 采样统计 / 113
6 超时与重试机制 / 117
6.1 简介 / 117
6.2 代理层超时与重试 / 119
6.2.1 Nginx / 119
6.2.2 Twemproxy / 126
6.3 Web容器超时 / 127
6.4 中间件客户端超时与重试 / 127
6.5 数据库客户端超时 / 131
6.6 NoSQL客户端超时 / 134
6.7 业务超时 / 135
6.8 前端Ajax超时 / 135
6.9 总结 / 136
6.10 参考资料 / 137
7 回滚机制 / 139
7.1 事务回滚 / 139
7.2 代码库回滚 / 140
7.3 部署版本回滚 / 141
7.4 数据版本回滚 / 142
7.5 静态资源版本回滚 / 143
8 压测与预案 / 145
8.1 系统压测 / 145
8.1.1 线下压测 / 146
8.1.2 线上压测 / 146
8.2 系统优化和容灾 / 147
8.3 应急预案 / 148
第3部分 高并发 / 153
9 应用级缓存 / 154
9.1 缓存简介 / 154
9.2 缓存命中率 / 155
9.3 缓存回收策略 / 155
9.3.1 基于空间 / 155
9.3.2 基于容量 / 155
9.3.3 基于时间 / 155
9.3.4 基于Java对象引用 / 156
9.3.5 回收算法 / 156
9.4 Java缓存类型 / 156
9.4.1 堆缓存 / 158
9.4.2 堆外缓存 / 162
9.4.3 磁盘缓存 / 162
9.4.4 分布式缓存 / 164
9.4.5 多级缓存 / 166
9.5 应用级缓存示例 / 167
9.5.1 多级缓存API封装 / 167
9.5.2 NULL Cache / 170
9.5.3 强制获取最新数据 / 170
9.5.4 失败统计 / 171
9.5.5 延迟报警 / 171
9.6 缓存使用模式实践 / 172
9.6.1 Cache-Aside / 173
9.6.2 Cache-As-SoR / 174
9.6.3 Read-Through / 174
9.6.4 Write-Through / 176
9.6.5 Write-Behind / 177
9.6.6 Copy Pattern / 181
9.7 性能测试 / 181
9.8 参考资料 / 182
10 HTTP缓存 / 183
10.1 简介 / 183
10.2 HTTP缓存 / 184
10.2.1 Last-Modified / 184
10.2.2 ETag / 190
10.2.3 总结 / 192
10.3 HttpClient客户端缓存 / 192
10.3.1 主流程 / 195
10.3.2 清除无效缓存 / 195
10.3.3 查找缓存 / 196
10.3.4 缓存未命中 / 198
10.3.5 缓存命中 / 198
10.3.6 缓存内容陈旧需重新验证 / 202
10.3.7 缓存内容无效需重新执行请求 / 205
10.3.8 缓存响应 / 206
10.3.9 缓存头总结 / 207
10.4 Nginx HTTP缓存设置 / 208
10.4.1 expires / 208
10.4.2 if-modified-since / 209
10.4.3 nginx proxy_pass / 209
10.5 Nginx代理层缓存 / 212
10.5.1 Nginx代理层缓存配置 / 212
10.5.2 清理缓存 / 215
10.6 一些经验 / 216
参考资料 / 217
11 多级缓存 / 218
11.1 多级缓存介绍 / 218
11.2 如何缓存数据 / 220
11.2.1 过期与不过期 / 220
11.2.2 维度化缓存与增量缓存 / 221
11.2.3 大Value缓存 / 221
11.2.4 热点缓存 / 221
11.3 分布式缓存与应用负载均衡 / 222
11.3.1 缓存分布式 / 222
11.3.2 应用负载均衡 / 222
11.4 热点数据与更新缓存 / 223
11.4.1 单机全量缓存+主从 / 223
11.4.2 分布式缓存+应用本地热点 / 224
11.5 更新缓存与原子性 / 225
11.6 缓存崩溃与快速修复 / 226
11.6.1 取模 / 226
11.6.2 一致性哈希 / 226
11.6.3 快速恢复 / 226
12 连接池线程池详解 / 227
12.1 数据库连接池 / 227
12.1.1 DBCP连接池配置 / 228
12.1.2 DBCP配置建议 / 233
12.1.3 数据库驱动超时实现 / 234
12.1.4 连接池使用的一些建议 / 235
12.2 HttpClient连接池 / 236
12.2.1 HttpClient 4.5.2配置 / 236
12.2.2 HttpClient连接池源码分析 / 240
12.2.3 HttpClient 4.2.3配置 / 241
12.2.4 问题示例 / 243
12.3 线程池 / 244
12.3.1 Java线程池 / 245
12.3.2 Tomcat线程池配置 / 248
13 异步并发实战 / 250
13.1 同步阻塞调用 / 251
13.2 异步Future / 252
13.3 异步Callback / 253
13.4 异步编排CompletableFuture / 254
13.5 异步Web服务实现 / 257
13.6 请求缓存 / 259
13.7 请求合并 / 261
14 如何扩容 / 266
14.1 单体应用垂直扩容 / 267
14.2 单体应用水平扩容 / 267
14.3 应用拆分 / 268
14.4 数据库拆分 / 271
14.5 数据库分库分表示例 / 275
14.5.1 应用层还是中间件层 / 275
14.5.2 分库分表策略 / 277
14.5.3 使用sharding-jdbc分库分表 / 279
14.5.4 sharding-jdbc分库分表配置 / 279
14.5.5 使用sharding-jdbc读写分离 / 283
14.6 数据异构 / 284
14.6.1 查询维度异构 / 284
14.6.2 聚合数据异构 / 285
14.7 任务系统扩容 / 285
14.7.1 简单任务 / 285
14.7.2 分布式任务 / 287
14.7.3 Elastic-Job简介 / 287
14.7.4 Elastic-Job-Lite功能与架构 / 287
14.7.5 Elastic-Job-Lite示例 / 288
15 队列术 / 295
15.1 应用场景 / 295
15.2 缓冲队列 / 296
15.3 任务队列 / 297
15.4 消息队列 / 297
15.5 请求队列 / 299
15.6 数据总线队列 / 300
15.7 混合队列 / 301
15.8 其他队列 / 302
15.9 Disruptor+Redis队列 / 303
15.10 下单系统水平可扩展架构 / 311
第4部分 案例 / 323
16 构建需求响应式亿级商品详情页 / 324
16.1 商品详情页是什么 / 324
16.2 商品详情页前端结构 / 325
16.3 我们的性能数据 / 327
16.4 单品页流量特点 / 327
16.5 单品页技术架构发展 / 327
16.5.1 架构1.0 / 328
16.5.2 架构2.0 / 328
16.5.3 架构3.0 / 330
16.6 详情页架构设计原则 / 332
16.7 遇到的一些坑和问题 / 339
16.8 其他 / 347
17 京东商品详情页服务闭环实践 / 348
17.1 为什么需要统一服务 / 348
17.2 整体架构 / 349
17.3 一些架构思路和总结 / 350
17.4 引入Nginx接入层 / 354
17.5 前端业务逻辑后置 / 356
17.6 前端接口服务端聚合 / 357
17.7 服务隔离 / 359
18 使用OpenResty开发高性能Web应用 / 360
18.1 OpenResty简介 / 361
18.1.1 Nginx优点 / 361
18.1.2 Lua的优点 / 361
18.1.3 什么是ngx_lua / 361
18.1.4 开发环境 / 362
18.1.5 OpenResty生态 / 362
18.1.6 场景 / 362
18.2 基于OpenResty的常用架构模式 / 363
18.3 如何使用OpenResty开发Web应用 / 371
18.4 基于OpenResty的常用功能总结 / 375
18.5 一些问题 / 376
19 应用数据静态化架构高性能单页Web应用 / 377
19.1 整体架构 / 378
19.2 数据和模板动态化 / 381
19.3 多版本机制 / 381
19.4 异常问题 / 382
20 使用OpenResty开发Web服务 / 383
20.1 架构 / 383
20.2 单DB架构 / 384
20.3 实现 / 387
21 使用OpenResty开发商品详情页 / 405
21.1 技术选型 / 407
21.2 核心流程 / 408
21.3 项目搭建 / 408
21.4 数据存储实现 / 410
21.5 动态服务实现 / 422
21.6 前端展示实现 / 430
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>亿级流量网站架构核心技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java并发编程实战
对本书的赞誉
译者序
前　言
第1章　简介1
1.1　并发简史1
1.2　线程的优势2
1.2.1　发挥多处理器的强大能力2
1.2.2　建模的简单性3
1.2.3　异步事件的简化处理3
1.2.4　响应更灵敏的用户界面4
1.3　线程带来的风险4
1.3.1　安全性问题5
1.3.2　活跃性问题7
1.3.3　性能问题7
1.4　线程无处不在7
第一部分　基础知识
第2章　线程安全性11
2.1　什么是线程安全性13
2.2　原子性14
2.2.1　竞态条件15
2.2.2　示例：延迟初始化中的竞态条件16
2.2.3　复合操作17
2.3　加锁机制18
2.3.1　内置锁20
2.3.2　重入21
2.4　用锁来保护状态22
2.5　活跃性与性能23
第3章　对象的共享27
3.1　可见性27
3.1.1　失效数据28
3.1.2　非原子的64位操作29
3.1.3　加锁与可见性30
3.1.4　Volatile变量 30
3.2　发布与逸出32
3.3　线程封闭35
3.3.1　Ad-hoc线程封闭35
3.3.2　栈封闭36
3.3.3　ThreadLocal类37
3.4　不变性38
3.4.1　Final域39
3.4.2　示例：使用Volatile类型来发布不可变对象40
3.5　安全发布41
3.5.1　不正确的发布：正确的对象被破坏42
3.5.2 　不可变对象与初始化安全性42
3.5.3　安全发布的常用模式43
3.5.4　事实不可变对象44
3.5.5　可变对象44
3.5.6　安全地共享对象44
第4章　对象的组合46
4.1　设计线程安全的类46
4.1.1　收集同步需求47
4.1.2　依赖状态的操作48
4.1.3　状态的所有权48
4.2　实例封闭49
4.2.1　Java监视器模式51
4.2.2　示例：车辆追踪51
4.3　线程安全性的委托53
4.3.1　示例：基于委托的车辆追踪器54
4.3.2　独立的状态变量55
4.3.3　当委托失效时56
4.3.4　发布底层的状态变量57
4.3.5　示例：发布状态的车辆追踪器58
4.4　在现有的线程安全类中添加功能59
4.4.1　客户端加锁机制60
4.4.2　组合62
4.5　将同步策略文档化62
第5章　基础构建模块66
5.1　同步容器类66
5.1.1　同步容器类的问题66
5.1.2　迭代器与Concurrent-ModificationException68
5.1.3　隐藏迭代器69
5.2　并发容器70
5.2.1　ConcurrentHashMap71
5.2.2　额外的原子Map操作72
5.2.3　CopyOnWriteArrayList72
5.3　阻塞队列和生产者-消费者模式73
5.3.1　示例：桌面搜索75
5.3.2　串行线程封闭76
5.3.3　双端队列与工作密取77
5.4　阻塞方法与中断方法77
5.5　同步工具类78
5.5.1　闭锁79
5.5.2　FutureTask80
5.5.3　信号量82
5.5.4　栅栏83
5.6　构建高效且可伸缩的结果缓存85
第二部分　结构化并发应用程序
第6章　任务执行93
6.1　在线程中执行任务93
6.1.1　串行地执行任务94
6.1.2　显式地为任务创建线程94
6.1.3　无限制创建线程的不足95
6.2　Executor框架96
6.2.1　示例：基于Executor的Web服务器97
6.2.2　执行策略98
6.2.3　线程池98
6.2.4　Executor的生命周期99
6.2.5　延迟任务与周期任务101
6.3　找出可利用的并行性102
6.3.1　示例：串行的页面渲染器102
6.3.2　携带结果的任务Callable与Future103
6.3.3　示例：使用Future实现页面渲染器104
6.3.4　在异构任务并行化中存在的局限106
6.3.5　CompletionService:Executor与BlockingQueue106
6.3.6　示例：使用CompletionService实现页面渲染器107
6.3.7　为任务设置时限108
6.3.8　示例：旅行预定门户网站109
第7章　取消与关闭111
7.1　任务取消111
7.1.1　中断113
7.1.2　中断策略116
7.1.3　响应中断117
7.1.4　示例：计时运行118
7.1.5　通过Future来实现取消120
7.1.6　处理不可中断的阻塞121
7.1.7　采用newTaskFor来封装非标准的取消122
7.2　停止基于线程的服务124
7.2.1　示例：日志服务124
7.2.2　关闭ExecutorService127
7.2.3　“毒丸”对象128
7.2.4　示例：只执行一次的服务129
7.2.5　shutdownNow的局限性130
7.3　处理非正常的线程终止132
7.4　JVM关闭135
7.4.1　关闭钩子135
7.4.2　守护线程136
7.4.3　终结器136
第8章　线程池的使用138
8.1　在任务与执行策略之间的隐性耦合138
8.1.1　线程饥饿死锁139
8.1.2　运行时间较长的任务140
8.2　设置线程池的大小140
8.3　配置ThreadPoolExecutor141
8.3.1　线程的创建与销毁142
8.3.2　管理队列任务142
8.3.3　饱和策略144
8.3.4　线程工厂146
8.3.5　在调用构造函数后再定制ThreadPoolExecutor147
8.4　扩展 ThreadPoolExecutor148
8.5　递归算法的并行化149
第9章　图形用户界面应用程序156
9.1　为什么GUI是单线程的156
9.1.1　串行事件处理157
9.1.2　Swing中的线程封闭机制158
9.2　短时间的GUI任务160
9.3　长时间的GUI任务161
9.3.1　取消162
9.3.2　进度标识和完成标识163
9.3.3　SwingWorker165
9.4　共享数据模型165
9.4.1　线程安全的数据模型166
9.4.2　分解数据模型166
9.5　其他形式的单线程子系统167
第三部分　活跃性、性能与测试
第10章　避免活跃性危险169
10.1　死锁169
10.1.1　锁顺序死锁170
10.1.2　动态的锁顺序死锁171
10.1.3　在协作对象之间发生的死锁174
10.1.4　开放调用175
10.1.5　资源死锁177
10.2　死锁的避免与诊断178
10.2.1　支持定时的锁178
10.2.2　通过线程转储信息来分析死锁178
10.3　其他活跃性危险180
10.3.1　饥饿180
10.3.2　糟糕的响应性181
10.3.3　活锁181
第11章　性能与可伸缩性183
11.1　对性能的思考183
11.1.1　性能与可伸缩性184
11.1.2　评估各种性能权衡因素185
11.2　Amdahl定律186
11.2.1　示例：在各种框架中隐藏的串行部分188
11.2.2　Amdahl定律的应用189
11.3　线程引入的开销189
11.3.1　上下文切换190
11.3.2　内存同步190
11.3.3　阻塞192
11.4　减少锁的竞争192
11.4.1　缩小锁的范围（“快进快出”）193
11.4.2　减小锁的粒度195
11.4.3　锁分段196
11.4.4　避免热点域197
11.4.5　一些替代独占锁的方法198
11.4.6　监测CPU的利用率199
11.4.7　向对象池说“不”200
11.5　示例：比较Map的性能200
11.6　减少上下文切换的开销201
第12章　并发程序的测试204
12.1　正确性测试205
12.1.1　基本的单元测试206
12.1.2　对阻塞操作的测试207
12.1.3　安全性测试208
12.1.4　资源管理的测试212
12.1.5　使用回调213
12.1.6　产生更多的交替操作214
12.2　性能测试215
12.2.1　在PutTakeTest中增加计时功能215
12.2.2　多种算法的比较217
12.2.3　响应性衡量218
12.3　避免性能测试的陷阱220
12.3.1　垃圾回收220
12.3.2　动态编译220
12.3.3　对代码路径的不真实采样222
12.3.4　不真实的竞争程度222
12.3.5　无用代码的消除223
12.4　其他的测试方法224
12.4.1　代码审查224
12.4.2　静态分析工具224
12.4.3　面向方面的测试技术226
12.4.4　分析与监测工具226
第四部分　高级主题
第13章　显式锁227
13.1　Lock与 ReentrantLock227
13.1.1　轮询锁与定时锁228
13.1.2　可中断的锁获取操作230
13.1.3　非块结构的加锁231
13.2　性能考虑因素231
13.3　公平性232
13.4　在synchronized和ReentrantLock之间进行选择234
13.5　读-写锁235
第14章　构建自定义的同步工具238
14.1　状态依赖性的管理238
14.1.1　示例：将前提条件的失败传递给调用者240
14.1.2　示例：通过轮询与休眠来实现简单的阻塞241
14.1.3　条件队列243
14.2　使用条件队列244
14.2.1　条件谓词244
14.2.2　过早唤醒245
14.2.3　丢失的信号246
14.2.4　通知247
14.2.5　示例：阀门类248
14.2.6　子类的安全问题249
14.2.7　封装条件队列250
14.2.8　入口协议与出口协议250
14.3　显式的Condition对象251
14.4　Synchronizer剖析253
14.5　AbstractQueuedSynchronizer254
14.6　java.util.concurrent同步器类中的 AQS257
14.6.1　ReentrantLock257
14.6.2　Semaphore与CountDownLatch258
14.6.3　FutureTask259
14.6.4　ReentrantReadWriteLock259
第15章　原子变量与非阻塞同步机制261
15.1　锁的劣势261
15.2　硬件对并发的支持262
15.2.1　比较并交换263
15.2.2　非阻塞的计数器264
15.2.3　JVM对CAS的支持265
15.3　原子变量类265
15.3.1　原子变量是一种“更好的volatile”266
15.3.2　性能比较：锁与原子变量267
15.4　非阻塞算法270
15.4.1　非阻塞的栈270
15.4.2　非阻塞的链表272
15.4.3　原子的域更新器274
15.4.4　ABA问题275
第16章　Java内存模型277
16.1　什么是内存模型，为什么需要它277
16.1.1　平台的内存模型278
16.1.2　重排序278
16.1.3　Java内存模型简介280
16.1.4　借助同步281
16.2　发布283
16.2.1　不安全的发布283
16.2.2　安全的发布284
16.2.3　安全初始化模式284
16.2.4　双重检查加锁286
16.3　初始化过程中的安全性287
附录A　并发性标注289
参考文献291
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java并发编程实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA并发编程实践
目录
代码清单
序
第1章 介绍
1.1 并发的（非常）简短历史
1.2 线程的优点
1.3 线程的风险
1.4 线程无处不在
第1部分 基础
第2章 线程安全
2.1 什么是线程安全性
2.2 原子性
2.3 锁
2.4 用锁来保护状态
2.5 活跃度与性能
第3章 共享对象
3.1 可见性
3.2 发布和逸出
3.3 线程封闭
3.4 不可变性
3.5 安全发布
第4章 组合对象
4.1 设计线程安全的类
4.2 实例限制
4.3 委托线程安全
4.4 向已有的线程安全类添加功能
4.5 同步策略的文档化
第5章 构建块
5.1 同步容器
5.2 发容器
5.3 阻塞队列和生产者一消费者模式
5.4 阻塞和可中断的方法
5.5 Synchronizer
5.6 为计算结果建立高效、可伸缩的高速缓存
第2部分 构建并发应用程序
第6章 任务执行
6.1 在线程中执行任务
6.2 Executor 框架
6.3 寻找可强化的并行性
第7章 取消和关闭
7.1 任务取消
7.2 停止基于线程的服务
7.3 处理反常的线程终止
7.4 JVM关闭
第8章 应用线程池
8.1 任务与执行策略问的隐性耦合
8.2 定制线程池的大小
8.3 配置ThreadPoolExecutor
8.4 扩展ThreadPoolExecutor
8.5 并行递归算法
第9章 GUI应用程序
9.1 为什么GUI是单线程化的
9.2 短期的GUI任务
9.3 耗时GUI任务
9.4 共享数据模型
9.5 其他形式的单线程子系统
第3部分 活跃度，性能和测试
第10章 避免活跃度危险
第11章 性能和可伸缩性
第12章 测试并发程序
第4部分 高级主题
第13章 显示锁
第14章 构建自定义的同步工具
第15章 原子变量与非阻塞同步机制
第16章 Java存储模型
附录A 同步Annotation
参考文献
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA并发编程实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实战Java高并发程序设计
第1章　走入并行世界	1
1.1　何去何从的并行计算 	1
1.1.1　忘掉那该死的并行	2
1.1.2　可怕的现实：摩尔定律的失效	4
1.1.3　柳暗花明：不断地前进	5
1.1.4　光明或是黑暗	6
1.2　你必须知道的几个概念	6
1.2.1　同步（Synchronous）和异步（Asynchronous）	7
1.2.2　并发（Concurrency）和并行（Parallelism）	8
1.2.3　临界区	9
1.2.4　阻塞（Blocking）和非阻塞（Non-Blocking）	9
1.2.5　死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）	9
1.3　并发级别	11
1.3.1　阻塞（Blocking）	11
1.3.2　无饥饿（Starvation-Free）	11
1.3.3　无障碍（Obstruction-Free）	12
1.3.4　无锁（Lock-Free）	12
1.3.5　无等待（Wait-Free）	13
1.4　有关并行的两个重要定律	13
1.4.1　Amdahl定律	13
1.4.2　Gustafson定律	16
1.4.3　Amdahl定律和Gustafson定律是否相互矛盾	16
1.5　回到Java：JMM	17
1.5.1　原子性（Atomicity）	18
1.5.2　可见性（Visibility）	20
1.5.3　有序性（Ordering）	22
1.5.4　哪些指令不能重排：Happen-Before规则	27
1.6　参考文献	27
第2章　Java并行程序基础	29
2.1　有关线程你必须知道的事	29
2.2　初始线程：线程的基本操作	32
2.2.1　新建线程	32
2.2.2　终止线程	34
2.2.3　线程中断	38
2.2.4　等待（wait）和通知（notify）	41
2.2.5　挂起（suspend）和继续执行（resume）线程	44
2.2.6　等待线程结束（join）和谦让（yield）	48
2.3　volatile与Java内存模型（JMM）	50
2.4　分门别类的管理：线程组	52
2.5　驻守后台：守护线程（Daemon）	54
2.6　先干重要的事：线程优先级	55
2.7　线程安全的概念与synchronized	57
2.8　程序中的幽灵：隐蔽的错误	61
2.8.1　无提示的错误案例	61
2.8.2　并发下的ArrayList	62
2.8.3　并发下诡异的HashMap	63
2.8.4　初学者常见问题：错误的加锁	66
2.9　参考文献	68
第3章　JDK并发包	70
3.1　多线程的团队协作：同步控制	70
3.1.1　synchronized的功能扩展：重入锁	71
3.1.2　重入锁的好搭档：Condition条件	80
3.1.3　允许多个线程同时访问：信号量（Semaphore）	83
3.1.4　ReadWriteLock读写锁	85
3.1.5　倒计时器：CountDownLatch	87
3.1.6　循环栅栏：CyclicBarrier	89
3.1.7　线程阻塞工具类：LockSupport	92
3.2　线程复用：线程池	95
3.2.1　什么是线程池	96
3.2.2　不要重复发明轮子：JDK对线程池的支持	97
3.2.3　刨根究底：核心线程池的内部实现	102
3.2.4　超负载了怎么办：拒绝策略	106
3.2.5　自定义线程创建：ThreadFactory	109
3.2.6　我的应用我做主：扩展线程池	110
3.2.7　合理的选择：优化线程池线程数量	112
3.2.8　堆栈去哪里了：在线程池中寻找堆栈	113
3.2.9　分而治之：Fork/Join框架	117
3.3　不要重复发明轮子：JDK的并发容器	121
3.3.1　超好用的工具类：并发集合简介	121
3.3.2　线程安全的HashMap	122
3.3.3　有关List的线程安全	123
3.3.4　高效读写的队列：深度剖析ConcurrentLinkedQueue	123
3.3.5　高效读取：不变模式下的CopyOnWriteArrayList	129
3.3.6　数据共享通道：BlockingQueue	130
3.3.7　随机数据结构：跳表（SkipList）	134
3.4　参考资料	136
第4章　锁的优化及注意事项	138
4.1　有助于提高“锁”性能的几点建议	139
4.1.1　减小锁持有时间	139
4.1.2　减小锁粒度	140
4.1.3　读写分离锁来替换独占锁	142
4.1.4　锁分离	142
4.1.5　锁粗化	144
4.2　Java虚拟机对锁优化所做的努力	146
4.2.1　锁偏向	146
4.2.2　轻量级锁	146
4.2.3　自旋锁	146
4.2.4　锁消除	146
4.3　人手一支笔：ThreadLocal	147
4.3.1　ThreadLocal的简单使用	148
4.3.2　ThreadLocal的实现原理	149
4.3.3　对性能有何帮助	155
4.4　无锁	157
4.4.1　与众不同的并发策略：比较交换（CAS）	158
4.4.2　无锁的线程安全整数：AtomicInteger	159
4.4.3　Java中的指针：Unsafe类	161
4.4.4　无锁的对象引用：AtomicReference	162
4.4.5　带有时间戳的对象引用：AtomicStampedReference	165
4.4.6　数组也能无锁：AtomicIntegerArray	168
4.4.7　让普通变量也享受原子操作：AtomicIntegerFieldUpdater	169
4.4.8　挑战无锁算法：无锁的Vector实现	171
4.4.9　让线程之间互相帮助：细看SynchronousQueue的实现	176
4.5　有关死锁的问题	179
4.6　参考文献	183
第5章　并行模式与算法	184
5.1　探讨单例模式	184
5.2　不变模式	187
5.3　生产者-消费者模式	190
5.4　高性能的生产者-消费者：无锁的实现	194
5.4.1　无锁的缓存框架：Disruptor	195
5.4.2　用Disruptor实现生产者-消费者案例	196
5.4.3　提高消费者的响应时间：选择合适的策略	199
5.4.4　CPU Cache的优化：解决伪共享问题	200
5.5　Future模式	204
5.5.1　Future模式的主要角色	206
5.5.2　Future模式的简单实现	207
5.5.3　JDK中的Future模式	210
5.6　并行流水线	212
5.7　并行搜索	216
5.8　并行排序	218
5.8.1　分离数据相关性：奇偶交换排序	218
5.8.2　改进的插入排序：希尔排序	221
5.9　并行算法：矩阵乘法	226
5.10　准备好了再通知我：网络NIO	230
5.10.1　基于Socket的服务端的多线程模式	230
5.10.2　使用NIO进行网络编程	235
5.10.3　使用NIO来实现客户端	243
5.11　读完了再通知我：AIO	245
5.11.1　AIO EchoServer的实现	245
5.11.2　AIO Echo客户端实现	248
5.12　参考文献	249
第6章　Java 8与并发	251
6.1　Java 8的函数式编程简介	251
6.1.1　函数作为一等公民	252
6.1.2　无副作用	252
6.1.3　申明式的（Declarative）	253
6.1.4　不变的对象	254
6.1.5　易于并行	254
6.1.6　更少的代码	254
6.2　函数式编程基础	255
6.2.1　FunctionalInterface注释	255
6.2.2　接口默认方法	256
6.2.3　lambda表达式	259
6.2.4　方法引用	260
6.3　一步一步走入函数式编程	263
6.4　并行流与并行排序	267
6.4.1　使用并行流过滤数据	267
6.4.2　从集合得到并行流	268
6.4.3　并行排序	268
6.5　增强的Future：CompletableFuture	269
6.5.1　完成了就通知我	269
6.5.2　异步执行任务	270
6.5.3　流式调用	272
6.5.4　CompletableFuture中的异常处理	272
6.5.5　组合多个CompletableFuture	273
6.6　读写锁的改进：StampedLock	274
6.6.1　StampedLock使用示例	275
6.6.2　StampedLock的小陷阱	276
6.6.3　有关StampedLock的实现思想	278
6.7　原子类的增强	281
6.7.1　更快的原子类：LongAdder	281
6.7.2　LongAdder的功能增强版：LongAccumulator	287
6.8　参考文献	288
第7章　使用Akka构建高并发程序	289
7.1　新并发模型：Actor	290
7.2　Akka之Hello World	290
7.3　有关消息投递的一些说明	293
7.4　Actor的生命周期	295
7.5　监督策略	298
7.6　选择Actor	303
7.7　消息收件箱（Inbox）	303
7.8　消息路由	305
7.9　Actor的内置状态转换	308
7.10　询问模式：Actor中的Future	311
7.11　多个Actor同时修改数据：Agent	313
7.12　像数据库一样操作内存数据：软件事务内存	316
7.13　一个有趣的例子：并发粒子群的实现	319
7.13.1　什么是粒子群算法	320
7.13.2　粒子群算法的计算过程	320
7.13.3　粒子群算法能做什么	322
7.13.4　使用Akka实现粒子群	323
7.14　参考文献	330
第8章　并行程序调试	331
8.1　准备实验样本	331
8.2　正式起航	332
8.3　挂起整个虚拟机	334
8.4　调试进入ArrayList内部	336
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实战Java高并发程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java并发编程的艺术
前　言
第1章　并发编程的挑战 1
1.1　上下文切换 1
1.1.1　多线程一定快吗 1
1.1.2　测试上下文切换次数和时长 3
1.1.3　如何减少上下文切换 3
1.1.4　减少上下文切换实战 4
1.2　死锁 5
1.3　资源限制的挑战 6
1.4　本章小结 7
第2章　Java并发机制的底层实现原理 8
2.1　volatile的应用 8
2.2　synchronized的实现原理与应用 11
2.2.1　Java对象头 12
2.2.2　锁的升级与对比 13
2.3　原子操作的实现原理 16
2.4　本章小结 20
第3章　Java内存模型 21
3.1　Java内存模型的基础 21
3.1.1　并发编程模型的两个关键问题 21
3.1.2　Java内存模型的抽象结构 22
3.1.3　从源代码到指令序列的重排序 23
3.1.4　并发编程模型的分类 24
3.1.5　happens-before简介 26
3.2　重排序 27
3.2.1　数据依赖性 28
3.2.2　as-if-serial语义 28
3.2.3　程序顺序规则 29
3.2.4　重排序对多线程的影响 29
3.3　顺序一致性 31
3.3.1　数据竞争与顺序一致性 31
3.3.2　顺序一致性内存模型 32
3.3.3　同步程序的顺序一致性效果 34
3.3.4　未同步程序的执行特性 35
3.4　volatile的内存语义 38
3.4.1　volatile的特性 38
3.4.2　volatile写-读建立的happens-before关系 39
3.4.3　volatile写-读的内存语义 40
3.4.4　volatile内存语义的实现 42
3.4.5　JSR-133为什么要增强volatile的内存语义 46
3.5　锁的内存语义 47
3.5.1　锁的释放-获取建立的
happens-before关系 47
3.5.2　锁的释放和获取的内存语义 48
3.5.3　锁内存语义的实现 50
3.5.4　concurrent包的实现 54
3.6　final域的内存语义 55
3.6.1　final域的重排序规则 55
3.6.2　写final域的重排序规则 56
3.6.3　读final域的重排序规则 57
3.6.4　final域为引用类型 58
3.6.5　为什么final引用不能从构造函数内“溢出” 59
3.6.6　final语义在处理器中的实现 61
3.6.7　JSR-133为什么要增强f?inal的语义 62
3.7　happens-before 62
3.7.1　JMM的设计 62
3.7.2　happens-before的定义 64
3.7.3　happens-before规则 65
3.8　双重检查锁定与延迟初始化 67
3.8.1　双重检查锁定的由来 67
3.8.2　问题的根源 69
3.8.3　基于volatile的解决方案 71
3.8.4　基于类初始化的解决方案 72
3.9　Java内存模型综述 78
3.9.1　处理器的内存模型 78
3.9.2　各种内存模型之间的关系 80
3.9.3　JMM的内存可见性保证 80
3.9.4　JSR-133对旧内存模型的修补 81
3.10　本章小结 82
第4章　Java并发编程基础 83
4.1　线程简介 83
4.1.1　什么是线程 83
4.1.2　为什么要使用多线程 84
4.1.3　线程优先级 85
4.1.4　线程的状态 87
4.1.5　Daemon线程 90
4.2　启动和终止线程 91
4.2.1　构造线程 91
4.2.2　启动线程 92
4.2.3　理解中断 92
4.2.4　过期的suspend()、resume()和stop() 93
4.2.5　安全地终止线程 95
4.3　线程间通信 96
4.3.1　volatile和synchronized关键字 96
4.3.2　等待/通知机制 98
4.3.3　等待/通知的经典范式 101
4.3.4　管道输入/输出流 102
4.3.5　Thread.join()的使用 103
4.3.6　ThreadLocal的使用 105
4.4　线程应用实例 106
4.4.1　等待超时模式 106
4.4.2　一个简单的数据库连接池示例 106
4.4.3　线程池技术及其示例 110
4.4.4　一个基于线程池技术的简单Web服务器 114
4.5　本章小结 118
第5章　Java中的锁 119
5.1　Lock接口 119
5.2　队列同步器 121
5.2.1　队列同步器的接口与示例 121
5.2.2　队列同步器的实现分析 124
5.3　重入锁 136
5.4　读写锁 140
5.4.1　读写锁的接口与示例 141
5.4.2　读写锁的实现分析 142
5.5　LockSupport工具 146
5.6　Condition接口 147
5.6.1　Condition接口与示例 148
5.6.2　Condition的实现分析 150
5.7　本章小结 154
第6章　Java并发容器和框架 155
6.1　ConcurrentHashMap的实现原理与使用 155
6.1.1　为什么要使用ConcurrentHashMap 155
6.1.2　ConcurrentHashMap的结构 156
6.1.3　ConcurrentHashMap的初始化 157
6.1.4　定位Segment 159
6.1.5　ConcurrentHashMap的操作 160
6.2　ConcurrentLinkedQueue 161
6.2.1　ConcurrentLinkedQueue的结构 162
6.2.2　入队列 162
6.2.3　出队列 165
6.3　Java中的阻塞队列 167
6.3.1　什么是阻塞队列 167
6.3.2　Java里的阻塞队列 168
6.3.3　阻塞队列的实现原理 172
6.4　Fork/Join框架 175
6.4.1　什么是Fork/Join框架 175
6.4.2　工作窃取算法 176
6.4.3　Fork/Join框架的设计 177
6.4.4　使用Fork/Join框架 177
6.4.5　Fork/Join框架的异常处理 179
6.4.6　Fork/Join框架的实现原理 179
6.5　本章小结 181
第7章　Java中的13个原子操作类 182
7.1　原子更新基本类型类 182
7.2　原子更新数组 184
7.3　原子更新引用类型 185
7.4　原子更新字段类 187
7.5　本章小结 188
第8章　Java中的并发工具类 189
8.1　等待多线程完成的CountDownLatch 189
8.2　同步屏障CyclicBarrier 191
8.2.1　CyclicBarrier简介 191
8.2.2　CyclicBarrier的应用场景 193
8.2.3　CyclicBarrier和CountDownLatch的区别 195
8.3　控制并发线程数的Semaphore 196
8.4　线程间交换数据的Exchanger 198
8.5　本章小结 199
第9章　Java中的线程池 200
9.1　线程池的实现原理 200
9.2　线程池的使用 203
9.2.1　线程池的创建 203
9.2.2　向线程池提交任务 205
9.2.3　关闭线程池 205
9.2.4　合理地配置线程池 206
9.2.5　线程池的监控 206
9.3　本章小结 207
第10章　Executor框架 208
10.1　Executor框架简介 208
10.1.1　Executor框架的两级调度模型 208
10.1.2　Executor框架的结构与成员 208
10.2　ThreadPoolExecutor详解 213
10.2.1　FixedThreadPool详解 213
10.2.2　SingleThreadExecutor详解 214
10.2.3　CachedThreadPool详解 215
10.3　ScheduledThreadPoolExecutor详解 217
10.3.1　ScheduledThreadPoolExecutor的运行机制 217
10.3.2　ScheduledThreadPoolExecutor的实现 218
10.4　FutureTask详解 221
10.4.1　FutureTask简介 222
10.4.2　FutureTask的使用 222
10.4.3　FutureTask的实现 224
10.5　本章小结 227
第11章　Java并发编程实践 228
11.1　生产者和消费者模式 228
11.1.1　生产者消费者模式实战 229
11.1.2　多生产者和多消费者场景 231
11.1.3　线程池与生产消费者模式 234
11.2　线上问题定位 234
11.3　性能测试 236
11.4　异步任务池 238
11.5　本章小结 240
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java并发编程的艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>七周七并发模型
译者序
推荐序
致谢
前言
第1章 概述
1.1 并发？还是并行？
1.2 并行架构
1.3 并发：不只是多核
1.4 七个模型
第2章 线程与锁
2.1 简单粗暴
2.2 第一天 互斥和内存模型
2.3 第二天 超越内置锁
2.4 第三天 站在巨人的肩膀上
2.5 复习
第3章 函数式编程
3.1 若不爽，就另辟蹊径
3.2 第一天 抛弃可变状态
3.3 第二天 函数式并行
3.4 第三天 函数式并发
3.5 复习
第4章 Clojure之道——分离标识与状态
4.1 混搭的力量
4.2 第一天 原子变量与持久数据结构
4.3 第二天 代理和软件事务内存
4.4 第三天 深入学习
4.5 复习
第5章 Actor
5.1 更加面向对象
5.2 第一天 消息和信箱
5.3 第二天 错误处理和容错性
5.4 第三天 分布式
5.5 复习
第6章 通信顺序进程
6.1 万物皆通信
6.2 第一天 channel和go块
6.3 第二天 多个channel与IO
6.4 第三天 客户端CSP
6.5 复习
第7章 数据并行
7.1 隐藏在笔记本电脑中的超级计算机
7.2 第一天 GPGPU编程
7.3 第二天 多维空间与工作组
7.4 第三天 OpenCL和OpenGL——全部在GPU上运行
7.5 复习
第8章 Lambda架构
8.1 并行计算搞定大数据
8.2 第一天 MapReduce
8.3 第二天 批处理层
8.4 第三天 加速层
8.5 复习
第9章 圆满结束
9.1 君欲何往
9.2 未尽之路
9.3 越过山丘
参考书目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>七周七并发模型
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++并发编程实战
目录
第1章 你好，C++并发世界 1
1.1 什么是并发 2
1.1.1 计算机系统中的并发 2
1.1.2 并发的途径 3
1.2 为什么使用并发 5
1.2.1 为了划分关注点而使用并发 5
1.2.2 为了性能而使用并发 6
1.2.3 什么时候不使用并发 7
1.3 在C++中使用并发和多线程 8
1.3.1 C++多线程历程 8
1.3.2 新标准中的并发支持 9
1.3.3 C++线程库的效率 9
1.3.4 平台相关的工具 10
1.4 开始入门 11
1.5 小结 12
第2章 管理线程 13
2.1 基本线程管理 13
2.1.1 启动线程 14
2.1.2 等待线程完成 16
2.1.3 在异常环境下的等待 17
2.1.4 在后台运行线程 19
2.2 传递参数给线程函数 20
2.3 转移线程的所有权 23
2.4 在运行时选择线程数量 26
2.5 标识线程 28
2.6 小结 29
第3章 在线程间共享数据 31
3.1 线程之间共享数据的问题 32
3.1.1 竞争条件 33
3.1.2 避免有问题的竞争条件 34
3.2 用互斥元保护共享数据 35
3.2.1 使用C++中的互斥元 35
3.2.2 为保护共享数据精心组织代码 36
3.2.3 发现接口中固有的竞争条件 38
3.2.4 死锁：问题和解决方案 44
3.2.5 避免死锁的进一步指南 46
3.2.6 用std::unique_lock灵活锁定 51
3.2.7 在作用域之间转移锁的所有权 52
3.2.8 锁定在恰当的粒度 54
3.3 用于共享数据保护的替代工具 56
3.3.1 在初始化时保护共享数据 56
3.3.2 保护很少更新的数据结构 59
3.3.3 递归锁 61
3.4 小结 62
第4章 同步并发操作 63
4.1 等待事件或其他条件 63
4.1.1 用条件变量等待条件 65
4.1.2 使用条件变量建立一个线程安全队列 67
4.2 使用future等待一次性事件 71
4.2.1 从后台任务中返回值 72
4.2.2 将任务与future相关联 74
4.2.3 生成(std::)promise 77
4.2.4 为future保存异常 79
4.2.5 等待自多个线程 80
4.3 有时间限制的等待 82
4.3.1 时钟 83
4.3.2 时间段 84
4.3.3 时间点 85
4.3.4 接受超时的函数 86
4.4 使用操作同步来简化代码 88
4.4.1 带有future的函数式编程 88
4.4.2 具有消息传递的同步操作 92
4.5 小结 96
第5章 C++内存模型和原子类型上操作 97
5.1 内存模型基础 98
5.1.1 对象和内存位置 98
5.1.2 对象、内存位置以及并发 99
5.1.3 修改顺序 100
5.2 C++中的原子操作及类型 100
5.2.1 标准原子类型 101
5.2.2 std::atomic_flag上的操作 103
5.2.3 基于std::atomicbool的操作 105
5.2.4 std::atomicT*上的操作：指针算术运算 107
5.2.5 标准原子整型的操作 108
5.2.6 std::atomic初级类模板 109
5.2.7 原子操作的自由函数 111
5.3 同步操作和强制顺序 112
5.3.1 synchronizes-with关系 114
5.3.2 happens-before关系 114
5.3.3 原子操作的内存顺序 116
5.3.4 释放序列和synchronizes-with 133
5.3.5 屏障 135
5.3.6 用原子操作排序非原子操作 137
5.4 小结 138
第6章 设计基于锁的并发数据结构 140
6.1 为并发设计的含义是什么 141
6.2 基于锁的并发数据结构 142
6.2.1 使用锁的线程安全栈 142
6.2.2 使用锁和条件变量的线程安全队列 145
6.2.3 使用细粒度锁和条件变量的线程安全队列 149
6.3 设计更复杂的基于锁的数据结构 160
6.3.1 编写一个使用锁的线程安全查找表 160
6.3.2 编写一个使用锁的线程安全链表 165
6.4 小结 169
第7章 设计无锁的并发数据结构 170
7.1 定义和结果 171
7.1.1 非阻塞数据结构的类型 171
7.1.2 无锁数据结构 172
7.1.3 无等待的数据结构 172
7.1.4 无锁数据结构的优点与缺点 172
7.2 无锁数据结构的例子 173
7.2.1 编写不用锁的线程安全栈 174
7.2.2 停止恼人的泄漏：在无锁数据结构中管理内存 178
7.2.3 用风险指针检测不能被回收的结点 182
7.2.4 使用引用计数检测结点 189
7.2.5 将内存模型应用至无锁栈 194
7.2.6 编写不用锁的线程安全队列 198
7.3 编写无锁数据结构的准则 209
7.3.1 准则：使用std::memory_order_seq_cst作为原型 210
7.3.2 准则：使用无锁内存回收模式 210
7.3.3 准则：当心ABA问题 210
7.3.4 准则：识别忙于等待的循环以及辅助其他线程 211
7.4 小结 211
第8章 设计并发代码 213
8.1 在线程间划分工作的技术 214
8.1.1 处理开始前在线程间划分数据 214
8.1.2 递归地划分数据 215
8.1.3 以任务类型划分工作 219
8.2 影响并发代码性能的因素 222
8.2.1 有多少个处理器 222
8.2.2 数据竞争和乒乓缓存 223
8.2.3 假共享 225
8.2.4 数据应该多紧密 225
8.2.5 过度订阅和过多的任务切换 226
8.3 为多线程性能设计数据结构 226
8.3.1 为复杂操作划分数组元素 227
8.3.2 其他数据结构中的数据访问方式 228
8.4 为并发设计时的额外考虑 230
8.4.1 并行算法中的异常安全 230
8.4.2 可扩展性和阿姆达尔定律 237
8.4.3 用多线程隐藏延迟 238
8.4.4 用并发提高响应性 239
8.5 在实践中设计并发代码 241
8.5.1 std::for_each的并行实现 241
8.5.2 std::find的并行实现 243
8.5.3 std::partial_sum的并行实现 248
8.6 总结 256
第9章 高级线程管理 258
9.1 线程池 259
9.1.1 最简单的线程池 259
9.1.2 等待提交给线程池的任务 261
9.1.3 等待其他任务的任务 265
9.1.4 避免工作队列上的竞争 267
9.1.5 工作窃取 269
9.2 中断线程 273
9.2.1 启动和中断另一个线程 274
9.2.2 检测一个线程是否被中断 275
9.2.3 中断等待条件变量 276
9.2.4 中断在std::condition_variable_ any上的等待 279
9.2.5 中断其他阻塞调用 281
9.2.6 处理中断 281
9.2.7 在应用退出时中断后台任务 282
9.3 总结 284
第10章 多线程应用的测试与调试 285
10.1 并发相关错误的类型 285
10.1.1 不必要的阻塞 286
10.1.2 竞争条件 286
10.2 定位并发相关的错误的技巧 288
10.2.1 审阅代码以定位潜在的错误 288
10.2.2 通过测试定位并发相关的错误 290
10.2.3 可测试性设计 291
10.2.4 多线程测试技术 292
10.2.5 构建多线程的测试代码 295
10.2.6 测试多线程代码的性能 297
10.3 总结 298
附录A 附录A C++11部分
语言特性简明
参考 299
附录B 并发类库
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++并发编程实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Netty、Redis、Zookeeper高并发实战
前言
第1章 高并发时代的必备技能 1
1.1 Netty为何这么火 1
1.1.1 Netty火热的程度 1
1.1.2 Netty是面试的必杀器 2
1.2 高并发利器Redis 2
1.2.1 什么是Redis 2
1.2.2 Redis成为缓存事实标准的原因 3
1.3 分布式利器ZooKeeper 3
1.3.1 什么是ZooKeeper 3
1.3.2 ZooKeeper的优势 4
1.4 高并发IM的综合实践 4
1.4.1 高并发IM的学习价值 4
1.4.2 庞大的应用场景 5
1.5 Netty、Redis、ZooKeeper实践计划 5
1.5.1 第1天：Java NIO实践 5
1.5.2 第2天：Reactor反应器模式实践 6
1.5.3 第3天：异步回调模式实践 7
1.5.4 第4天：Netty基础实践 8
1.5.5 第5天：解码器（Decoder）与编码器（Encoder）实践 9
1.5.6 第6天：JSON和ProtoBuf序列化实践 11
1.5.7 第7~10天：基于Netty的单聊实战 12
1.5.8 第11天：ZooKeeper实践计划 14
1.5.9 第12天：Redis实践计划 14
1.6 本章小结 16
第2章 高并发IO的底层原理 17
2.1 IO读写的基础原理 17
2.1.1 内核缓冲区与进程缓冲区 18
2.1.2 详解典型的系统调用流程 18
2.2 四种主要的IO模型 19
2.2.1 同步阻塞IO（Blocking IO） 20
2.2.2 同步非阻塞NIO（None Blocking IO） 21
2.2.3 IO多路复用模型（IO Multiplexing） 22
2.2.4 异步IO模型（Asynchronous IO） 23
2.3 通过合理配置来支持百万级并发连接 24
2.4 本章小结 26
第3章 Java NIO通信基础详解 27
3.1 Java NIO简介 27
3.1.1 NIO和OIO的对比 28
3.1.2 通道（Channel） 28
3.1.3 Selector 选择器 28
3.1.4 缓冲区（Buffer） 29
3.2 详解NIO Buffer类及其属性 29
3.2.1 Buffer类 29
3.2.2 Buffer类的重要属性 29
3.2.3 4个属性的小结 31
3.3 详解NIO Buffer类的重要方法 31
3.3.1 allocate()创建缓冲区 31
3.3.2 put()写入到缓冲区 32
3.3.3 flip()翻转 33
3.3.4 get()从缓冲区读取 34
3.3.5 rewind()倒带 35
3.3.6 mark( )和reset( ) 37
3.3.7 clear( )清空缓冲区 38
3.3.8 使用Buffer类的基本步骤 38
3.4 详解NIO Channel（通道）类 38
3.4.1 Channel（通道）的主要类型 39
3.4.2 FileChannel文件通道 39
3.4.3 使用FileChannel完成文件复制的实践案例 41
3.4.4 SocketChannel套接字通道 42
3.4.5 使用SocketChannel发送文件的实践案例 44
3.4.6 DatagramChannel数据报通道 46
3.4.7 使用DatagramChannel数据包通道发送数据的实践案例 47
3.5 详解NIO Selector选择器 49
3.5.1 选择器以及注册 49
3.5.2 SelectableChannel可选择通道 50
3.5.3 SelectionKey选择键 50
3.5.4 选择器使用流程 50
3.5.5 使用NIO实现Discard服务器的实践案例 52
3.5.6 使用SocketChannel在服务器端接收文件的实践案例 54
3.6 本章小结 57
第4章 鼎鼎大名的Reactor反应器模式 59
4.1 Reactor反应器模式为何如此重要 59
4.1.1 为什么首先学习Reactor反应器模式 59
4.1.2 Reactor反应器模式简介 60
4.1.3 多线程OIO的致命缺陷 60
4.2 单线程Reactor反应器模式 62
4.2.1 什么是单线程Reactor反应器 62
4.2.2 单线程Reactor反应器的参考代码 63
4.2.3 一个Reactor反应器版本的EchoServer实践案例 65
4.2.4 单线程Reactor反应器模式的缺点 67
4.3 多线程的Reactor反应器模式 68
4.3.1 多线程池Reactor反应器演进 68
4.3.2 多线程Reactor 反应器的实践案例 68
4.3.3 多线程Handler处理器的实践案例 70
4.4 Reactor反应器模式小结 72
4.5 本章小结 73
第5章 并发基础中的Future异步回调模式 74
5.1 从泡茶的案例说起 74
5.2 join异步阻塞 75
5.2.1 线程的join合并流程 75
5.2.2 使用join实现异步泡茶喝的实践案例 75
5.2.3 详解join合并方法 77
5.3 FutureTask异步回调之重武器 77
5.3.1 Callable接口 77
5.3.2 初探FutureTask类 78
5.3.3 Future接口 79
5.3.4 再探FutureTask类 79
5.3.5 使用FutureTask类实现异步泡茶喝的实践案例 80
5.4 Guava的异步回调 82
5.4.1 详解FutureCallback 82
5.4.2 详解ListenableFuture 83
5.4.3 ListenableFuture异步任务 84
5.4.4 使用Guava实现泡茶喝的实践案例 84
5.5 Netty的异步回调模式 87
5.5.1 详解GenericFutureListener接口 87
5.5.2 详解Netty的Future接口 88
5.5.3 ChannelFuture的使用 88
5.5.4 Netty的出站和入站异步回调 89
5.6 本章小结 90
第6章 Netty原理与基础 91
6.1 第一个Netty的实践案例DiscardServer 91
6.1.1 创建第一个Netty项目 91
6.1.2 第一个Netty服务器端程序 92
6.1.3 业务处理器NettyDiscardHandler 93
6.1.4 运行NettyDiscardServer 94
6.2 解密Netty中的Reactor反应器模式 95
6.2.1 回顾Reactor反应器模式中IO事件的处理流程 95
6.2.2 Netty中的Channel通道组件 96
6.2.3 Netty中的Reactor 反应器 96
6.2.4 Netty中的Handler处理器 97
6.2.5 Netty的流水线（Pipeline） 98
6.3 详解Bootstrap启动器类 100
6.3.1 父子通道 100
6.3.2 EventLoopGroup线程组 101
6.3.3 Bootstrap的启动流程 101
6.3.4 ChannelOption通道选项 104
6.4 详解Channel通道 105
6.4.1 Channel通道的主要成员和方法 105
6.4.2 EmbeddedChannel嵌入式通道 107
6.5 详解Handler业务处理器 108
6.5.1 ChannelInboundHandler通道入站处理器 109
6.5.2 ChannelOutboundHandler通道出站处理器 110
6.5.3 ChannelInitializer通道初始化处理器 111
6.5.4 ChannelInboundHandler的生命周期的实践案例 112
6.6 详解Pipeline流水线 115
6.6.1 Pipeline入站处理流程 115
6.6.2 Pipeline出站处理流程 116
6.6.3 ChannelHandlerContext上下文 118
6.6.4 截断流水线的处理 118
6.6.5 Handler业务处理器的热拔插 120
6.7 详解ByteBuf缓冲区 122
6.7.1 ByteBuf的优势 122
6.7.2 ByteBuf的逻辑部分 123
6.7.3 ByteBuf的重要属性 123
6.7.4 ByteBuf的三组方法 124
6.7.5 ByteBuf基本使用的实践案例 125
6.7.6 ByteBuf的引用计数 127
6.7.7 ByteBuf的Allocator分配器 128
6.7.8 ByteBuf缓冲区的类型 130
6.7.9 三类ByteBuf使用的实践案例 131
6.7.10 ByteBuf的自动释放 133
6.8 ByteBuf浅层复制的高级使用方式 136
6.8.1 slice切片浅层复制 136
6.8.2 duplicate整体浅层复制 137
6.8.3 浅层复制的问题 138
6.9 EchoServer回显服务器的实践案例 138
6.9.1 NettyEchoServer回显服务器的服务器端 138
6.9.2 共享NettyEchoServerHandler处理器 139
6.9.3 NettyEchoClient客户端代码 140
6.9.4 NettyEchoClientHandler处理器 142
6.10 本章小结 143
第7章 Decoder与Encoder重要组件 144
7.1 Decoder原理与实践 144
7.1.1 ByteToMessageDecoder解码器 145
7.1.2 自定义Byte2IntegerDecoder整数解码器的实践案例 146
7.1.3 ReplayingDecoder解码器 148
7.1.4 整数的分包解码器的实践案例 149
7.1.5 字符串的分包解码器的实践案例 152
7.1.6 MessageToMessageDecoder解码器 156
7.2 开箱即用的Netty内置Decoder 157
7.2.1 LineBasedFrameDecoder解码器 157
7.2.2 DelimiterBasedFrameDecoder解码器 158
7.2.3 LengthFieldBasedFrameDecoder解码器 159
7.2.4 多字段Head-Content协议数据帧解析的实践案例 162
7.3 Encoder原理与实践 164
7.3.1 MessageToByteEncoder编码器 165
7.3.2 MessageToMessageEncoder编码器 166
7.4 解码器和编码器的结合 167
7.4.1 ByteToMessageCodec编解码器 168
7.4.2 CombinedChannelDuplexHandler组合器 169
7.5 本章小结 169
第8章 JSON和ProtoBuf序列化 171
8.1 详解粘包和拆包 172
8.1.1 半包问题的实践案例 172
8.1.2 什么是半包问题 174
8.1.3 半包现象的原理 174
8.2 JSON协议通信 175
8.2.1 JSON序列化的通用类 175
8.2.2 JSON序列化与反序列化的实践案例 176
8.2.3 JSON传输的编码器和解码器之原理 178
8.2.4 JSON传输之服务器端的实践案例 179
8.2.5 JSON传输之客户端的实践案例 180
8.3 Protobuf协议通信 182
8.3.1 一个简单的proto文件的实践案例 182
8.3.2 控制台命令生成POJO和Builder 183
8.3.3 Maven插件生成POJO和Builder 183
8.3.4 消息POJO和Builder的使用之实践案例 184
8.4 Protobuf编解码的实践案例 187
8.4.1 Protobuf编码器和解码器的原理 187
8.4.2 Protobuf传输之服务器端的实践案例 188
8.4.3 Protobuf传输之客户端的实践案例 189
8.5 详解Protobuf协议语法 191
8.5.1 proto的头部声明 191
8.5.2 消息结构体与消息字段 192
8.5.3 字段的数据类型 193
8.5.4 其他的语法规范 194
8.6 本章小结 195
第9章 基于Netty的单体IM系统的开发实践 196
9.1 自定义ProtoBuf编解码器 196
9.1.1 自定义Protobuf编码器 197
9.1.2 自定义Protobuf解码器 198
9.1.3 IM系统中Protobuf消息格式的设计 199
9.2 概述IM的登录流程 202
9.2.1 图解登录/响应流程的9个环节 203
9.2.2 客户端涉及的主要模块 203
9.2.3 服务器端涉及的主要模块 204
9.3 客户端的登录处理的实践案例 204
9.3.1 LoginConsoleCommand和User POJO 205
9.3.2 LoginSender发送器 207
9.3.3 ClientSession客户端会话 209
9.3.4 LoginResponceHandler登录响应处理器 211
9.3.5 客户端流水线的装配 212
9.4 服务器端的登录响应的实践案例 213
9.4.1 服务器流水线的装配 214
9.4.2 LoginRequestHandler登录请求处理器 215
9.4.3 LoginProcesser用户验证逻辑 216
9.4.4 EventLoop线程和业务线程相互隔离 217
9.5 详解ServerSession服务器会话 218
9.5.1 通道的容器属性 219
9.5.2 ServerSession服务器端会话类 220
9.5.3 SessionMap会话管理器 222
9.6 点对点单聊的实践案例 223
9.6.1 简述单聊的端到端流程 223
9.6.2 客户端的ChatConsoleCommand收集聊天内容 224
9.6.3 客户端的CommandController发送POJO 224
9.6.4 服务器端的ChatRedirectHandler消息转发 225
9.6.5 服务器端的ChatRedirectProcesser异步处理 226
9.6.6 客户端的ChatMsgHandler接收POJO 227
9.7 详解心跳检测 228
9.7.1 网络连接的假死现象 228
9.7.2 服务器端的空闲检测 229
9.7.3 客户端的心跳报文 230
9.8 本章小结 232
第10章 ZooKeeper分布式协调 233
10.1 ZooKeeper伪集群安装和配置 233
10.1.1 创建数据目录和日志目录： 234
10.1.2 创建myid文件 234
10.1.3 创建和修改配置文件 235
10.1.4 配置文件示例 237
10.1.5 启动ZooKeeper伪集群 238
10.2 使用ZooKeeper进行分布式存储 239
10.2.1 详解ZooKeeper存储模型 239
10.2.2 zkCli客户端命令清单 240
10.3 ZooKeeper应用开发的实践 241
10.3.1 ZkClient开源客户端介绍 242
10.3.2 Curator开源客户端介绍 242
10.3.3 Curator开发的环境准备 243
10.3.4 Curator客户端实例的创建 244
10.3.5 通过Curator创建ZNode节点 245
10.3.6 在Curator中读取节点 247
10.3.7 在Curator中更新节点 248
10.3.8 在Curator中删除节点 249
10.4 分布式命名服务的实践 251
10.4.1 ID生成器 252
10.4.2 ZooKeeper分布式ID生成器的实践案例 253
10.4.3 集群节点的命名服务之实践案例 254
10.4.4 使用ZK实现SnowFlakeID算法的实践案例 256
10.5 分布式事件监听的重点 261
10.5.1 Watcher标准的事件处理器 261
10.5.2 NodeCache节点缓存的监听 265
10.5.3 PathChildrenCache子节点监听 267
10.5.4 Tree Cache节点树缓存 272
10.6 分布式锁的原理与实践 276
10.6.1 公平锁和可重入锁的原理 276
10.6.2 ZooKeeper分布式锁的原理 277
10.6.3 分布式锁的基本流程 279
10.6.4 加锁的实现 280
10.6.5 释放锁的实现 285
10.6.6 分布式锁的使用 287
10.6.7 Curator的InterProcessMutex可重入锁 288
10.7 本章小结 289
第11章 分布式缓存Redis 290
11.1 Redis入门 290
11.1.1 Redis安装和配置 290
11.1.2 Redis客户端命令 292
11.1.3 Redis Key的命名规范 294
11.2 Redis数据类型 295
11.2.1 String字符串 295
11.2.2 List列表 296
11.2.3 Hash哈希表 297
11.2.4 Set集合 298
11.2.5 Zset有序集合 299
11.3 Jedis基础编程的实践案例 300
11.3.1 Jedis操作String字符串 301
11.3.2 Jedis操作List列表 303
11.3.3 Jedis操作Hash哈希表 304
11.3.4 Jedis操作Set集合 305
11.3.5 Jedis操作Zset有序集合 306
11.4 JedisPool连接池的实践案例 308
11.4.1 JedisPool的配置 308
11.4.2 JedisPool创建和预热 310
11.4.3 JedisPool的使用 312
11.5 使用spring-data-redis完成 CRUD的实践案例 313
11.5.1 CRUD中应用缓存的场景 313
11.5.2 配置spring-redis.xml 315
11.5.3 使用RedisTemplate模板API 316
11.5.4 使用RedisTemplate模板API完成CRUD的实践案例 321
11.5.5 使用RedisCallback回调完成CRUD的实践案例 323
11.6 Spring的Redis缓存注解 325
11.6.1 使用Spring缓存注解完成CRUD的实践案例 325
11.6.2 spring-redis.xml中配置的调整 327
11.6.3 详解@CachePut和 @Cacheable注解 328
11.6.4 详解@CacheEvict注解 329
11.6.5 详解@Caching组合注解 330
11.7 详解SpringEL（SpEL） 331
11.7.1 SpEL运算符 332
11.7.2 缓存注解中的SpringEL表达式 334
11.8 本章小结 336
第12章 亿级高并发IM架构的开发实践 337
12.1 如何支撑亿级流量的高并发IM架构的理论基础 337
12.1.1 亿级流量的系统架构的开发实践 338
12.1.2 高并发架构的技术选型 338
12.1.3 详解IM消息的序列化协议选型 339
12.1.4 详解长连接和短连接 339
12.2 分布式IM的命名服务的实践案例 340
12.2.1 IM节点的POJO类 341
12.2.2 IM节点的ImWorker类 342
12.3 Worker集群的负载均衡之实践案例 345
12.3.1 ImLoadBalance负载均衡器 346
12.3.2 与WebGate的整合 348
12.4 即时通信消息的路由和转发的实践案例 349
12.4.1 IM路由器WorkerRouter 349
12.4.2 IM转发器WorkerReSender 352
12.5 Feign短连接RESTful调用 354
12.5.1 短连接API的接口准备 355
12.5.2 声明远程接口的本地代理 355
12.5.3 远程API的本地调用 356
12.6 分布式的在线用户统计的实践案例 358
12.6.1 Curator的分布式计数器 358
12.6.2 用户上线和下线的统计 360
12.7 本章小结 361
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Netty、Redis、Zookeeper高并发实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向模式的软件架构. 第2卷
目　录

第1章　并发与联网对象　　1
1.1 　驱动因素　　1
1.2 　并发与联网软件面临的挑战　　4
1.2.1 　挑战1：服务访问与配置　　6
1.2.2 　挑战2：事件处理　　9
1.2.3 　挑战3：并发　　11
1.2.4 　挑战4：同步　　13
1.2.5 　联网软件的其他挑战　　14
1.3 　案例研究：设计一个并发的Web服务器程序　　16
1.3.1 　JAWS框架概况　　17
1.3.2 　使用模式解决JAWS中常见的设计挑战　　18
1.3.3 　封装底层的操作系统API　　19
1.3.4 　将事件分离与连接管理同协议处理分离　　20
1.3.5 　通过多线程按比例提升服务器程序的性能　　21
1.3.6 　实现同步请求队列　　23
1.3.7 　最小化服务器程序的线程开销　　24
1.3.8 　有效利用异步I/O　　25
1.3.9 　增强服务器程序的可配置性　　27
1.3.10 　其他用于实现JAWS的模式　　28
1.4 　小结　　29
第2章　服务访问和配置模式　　31
2.1 　Wrapper Facade　　32
2.2 　Component Configurator　　51
2.3 　Interceptor　　73
2.4 　Extension Interface　　95
第3章　事件处理模式　　119
3.1 　Reactor　　120
3.2 　Proactor　　146
3.3 　Asynchronous Completion Token　　178
3.4 　Acceptor-Connector　　195
第4章　同步模式　　223
4.1 　Scoped Locking　　224
4.2 　Strategized Locking　　230
4.3 　Thread-Safe Interface　　238
4.4 　Double-Checked Locking Optimization　　244
第5章　并发模式　　253
5.1 　Active Object模式　　254
5.2 　Monitor Object模式　　275
5.3 　Half-Sync/Half-Async模式　　292
5.4 　Leader/Followers模式　　306
5.5 　Thread-Specific Storage模式　　324
第6章　模式的综合运用　　345
6.1 　从单个模式到模式语言　　345
6.1.1 　没有模式是一座孤岛　　345
6.1.2 　模式语言的形成　　347
6.2 　面向中间件和应用程序的模式语言　　348
6.2.1 　模式语言的细节　　348
6.2.2 　模式语言之我见　　355
6.3 　并发与联网之余　　356
6.3.1 　图形用户接口　　356
6.3.2 　组件　　357
6.3.3 　通用编程　　357
6.4 　模式语言与模式系统　　358
第7章　模式的过去、现在及未来　　361
7.1 　过去四年中模式的发展　　361
7.1.1 　模式　　361
7.1.2 　模式系统和模式语言　　362
7.1.3 　方法和工具　　363
7.1.4 　算法和数据结构　　363
7.1.5 　模式的形式化　　363
7.2 　模式的发展现状　　364
7.3 　模式的未来发展趋势　　365
7.3.1 　模式　　365
7.3.2 　模式语言　　367
7.3.3 　经验报告、方法与工具　　368
7.3.4 　模式文档　　368
7.3.5 　模式与模式语言的形式化　　369
7.3.6 　软件开发流程与组织　　369
7.3.7 　教育　　369
7.3.8 　我们的长期愿景　　370
7.4 　关于预测未来的最后一点想法　　370
第8章　结束语　　372
8.1 　术语表　　373
8.2 　符号　　385
8.2.1 　类－职责－协作者卡片　　385
8.2.2 　UML类图　　385
8.2.3 　UML时序图　　386
8.2.4 　UML 状态图　　388
参考文献　　390
索引　　414

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向模式的软件架构. 第2卷
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高明的心理助人者
第一部分 奠定基础
第一章 助人活动概论
第二章 助人模式概观
第三章 体现在行动中的价值观
第二部分 治疗性对话
第四章 沟通的基础：面向当事人调整姿态与主动倾听的技能
第五章 传达神入：努力理解当事人
第六章 探究与总结的艺术
第七章 协助当事人挑战他们自己
第八章 挑战技能与用好这些技能所需要的智慧
第九章 协助难弄的当事人前进：勉强、抗拒与坚韧性
第三部分 助人模式的阶段和任务
第十章 阶段一：协助当事人讲出他们的情况
第十一章 进入阶段二和阶段三：决定、目标和计划
第十二章 阶段二：协助当事人确立切实可行的目标
第十三章 阶段三：协助当事人形成实现目标的策略和计划
第四部分 行动箭头：我如何落实计划，让目标成为现实
第十四章 实现目标：协助当事人实现他们的转变方案——“我如何落实计划，让目标成为现实”
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高明的心理助人者
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Python编程实战
译者序
序
前言
第1章　python的创建型设计模式 1
1.1　抽象工厂模式 1
1.1.1　经典的抽象工厂模式 2
1.1.2　python风格的抽象工厂模式 4
1.2　建造者模式 6
1.3　工厂方法模式 12
1.4　原型模式 18
1.5　单例模式 19
第2章　python的结构型设计模式 21
2.1　适配器模式 21
2.2　桥接模式 26
2.3　组合模式 31
2.3.1　常规的“组合体/非组合体”式层级 32
2.3.2　只用一个类来表示组合体与非组合体 35
2.4　修饰器模式 37
2.4.1　函数修饰器与方法修饰器 38
2.4.2　类修饰器 42
2.5　外观模式 47
2.6　享元模式 52
2.7　代理模式 54
第3章　python的行为型设计模式 58
3.1　责任链模式 58
3.1.1　用常规方式实现责任链 59
3.1.2　基于协程的责任链 60
3.2　命令模式 63
3.3　解释器模式 66
3.3.1　用eval()函数求表达式的值 67
3.3.2　用exec()函数执行代码 70
3.3.3　用子进程执行代码 73
3.4　迭代器模式 76
3.4.1　通过序列协议实现迭代器 77
3.4.2　通过双参数iter()函数实现迭代器 77
3.4.3　通过迭代器协议实现迭代器 79
3.5　中介者模式 81
3.5.1　用常规方式实现中介者 82
3.5.2　基于协程的中介者 85
3.6　备忘录模式 87
3.7　观察者模式 87
3.8　状态模式 91
3.8.1　用同一套方法来处理不同的状态 93
3.8.2　用不同的方法来处理不同的状态 94
3.9　策略模式 95
3.10　模板方法模式 98
3.11　访问者模式 101
3.12　案例研究：图像处理程序包 102
3.12.1　通用的图像处理模块 103
3.12.2　xpm模块概述 111
3.12.3　png包装器模块 113
第4章　python的高级并发技术 116
4.1　计算密集型并发 119
4.1.1　用队列及多进程实现并发 121
4.1.2　用future及多进程实现并发 126
4.2　i/o密集型并发 128
4.2.1　用队列及线程实现并发 129
4.2.2　用future及线程实现并发 134
4.3　案例研究：并发式gui应用程序 136
4.3.1　创建gui 138
4.3.2　编写与工作线程配套的imagescale模块 144
4.3.3　在gui中显示图像处理进度 146
4.3.4　处理gui程序终止时的相关事宜 148
第5章　扩充python 150
5.1　用ctypes访问c程序库 151
5.2　cython的用法 159
5.2.1　用cython访问c程序库 159
5.2.2　编写cython模块以进一步提升程序执行速度 164
5.3　案例研究：用cython优化图像处理程序包 169
第6章　python高级网络编程 173
6.1　编写xml-rpc应用程序 174
6.1.1　数据包装器 174
6.1.2　编写xml-rpc服务器 178
6.1.3　编写xml-rpc客户端 180
6.2　编写rpyc应用程序 188
6.2.1　线程安全的数据包装器 188
6.2.2　编写rpyc服务器 193
6.2.3　编写rpyc客户端 195
第7章　用tkinter开发图形用户界面 199
7.1　tkinter简介 201
7.2　用tkinter创建对话框 203
7.2.1　创建对话框式应用程序 205
7.2.2　创建应用程序中的对话框 212
7.3　用tkinter创建主窗口式应用程序 220
7.3.1　创建主窗口 222
7.3.2　创建菜单 224
7.3.3　创建带计分器的状态栏 226
第8章　用opengl绘制3d图形 229
8.1　用透视投影法创建场景 230
8.1.1　用pyopengl编写cylinder程序 231
8.1.2　用pyglet编写cylinder程序 235
8.2　用正交投影法制作游戏 238
8.2.1　绘制游戏场景 240
8.2.2　判断用户是否选中了场景里的物体 242
8.2.3　处理用户操作 244
附录a　结束语 248
附录b　参考书目摘录 250
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Python编程实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实战Java高并发程序设计（第2版）
第1章  走入并行世界  1
1.1  何去何从的并行计算  1
1.1.1  忘掉那该死的并行  2
1.1.2  可怕的现实：摩尔定律的失效  4
1.1.3  柳暗花明：不断地前进  5
1.1.4  光明或是黑暗  6
1.2  你必须知道的几个概念  7
1.2.1  同步（Synchronous）和异步（Asynchronous）  7
1.2.2  并发（Concurrency）和并行（Parallelism）  8
1.2.3  临界区  9
1.2.4  阻塞（Blocking）和非阻塞（Non-Blocking）  9
1.2.5  死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）  10
1.3  并发级别  11
1.3.1  阻塞  11
1.3.2  无饥饿（Starvation-Free）  11
1.3.3  无障碍（Obstruction-Free）  12
1.3.4  无锁（Lock-Free）  13
1.3.5  无等待（Wait-Free）  13
1.4  有关并行的两个重要定律  14
1.4.1  Amdahl定律  14
1.4.2  Gustafson定律  16
1.4.3  是否相互矛盾  17
1.5  回到Java：JMM  18
1.5.1  原子性（Atomicity）  18
1.5.2  可见性（Visibility）  20
1.5.3  有序性（Ordering）  22
1.5.4  哪些指令不能重排：Happen-Before规则  27
第2章  Java并行程序基础  29
2.1  有关线程你必须知道的事  29
2.2  初始线程：线程的基本操作  32
2.2.1  新建线程  32
2.2.2  终止线程  34
2.2.3  线程中断  38
2.2.4  等待（wait）和通知（notify）  41
2.2.5  挂起（suspend）和继续执行（resume）线程  45
2.2.6  等待线程结束（join）和谦让（yeild）  49
2.3  volatile与Java内存模型（JMM）  50
2.4  分门别类的管理：线程组  53
2.5  驻守后台：守护线程（Daemon）  54
2.6  先做重要的事：线程优先级  56
2.7  线程安全的概念与关键字synchronized  57
2.8  程序中的幽灵：隐蔽的错误  61
2.8.1  无提示的错误案例  62
2.8.2  并发下的ArrayList  63
2.8.3  并发下诡异的HashMap  64
2.8.4  初学者常见的问题：错误的加锁  67
第3章  JDK并发包  71
3.1  多线程的团队协作：同步控制  71
3.1.1  关键字synchronized的功能扩展：重入锁  72
3.1.2  重入锁的好搭档：Condition  81
3.1.3  允许多个线程同时访问：信号量（Semaphore）  85
3.1.4  ReadWriteLock读写锁  86
3.1.5  倒计数器：CountDownLatch  89
3.1.6  循环栅栏：CyclicBarrier  91
3.1.7  线程阻塞工具类：LockSupport  94
3.1.8  Guava和RateLimiter限流  98
3.2  线程复用：线程池  101
3.2.1  什么是线程池  102
3.2.2  不要重复发明轮子：JDK对线程池的支持  102
3.2.3  刨根究底：核心线程池的内部实现  108
3.2.4  超负载了怎么办：拒绝策略  112
3.2.5  自定义线程创建：ThreadFactory  115
3.2.6  我的应用我做主：扩展线程池  116
3.2.7  合理的选择：优化线程池线程数量  119
3.2.8  堆栈去哪里了：在线程池中寻找堆栈  120
3.2.9  分而治之：Fork/Join框架  124
3.2.10  Guava中对线程池的扩展  128
3.3  不要重复发明轮子：JDK的并发容器  130
3.3.1  超好用的工具类：并发集合简介  130
3.3.2  线程安全的HashMap  131
3.3.3  有关List的线程安全  132
3.3.4  高效读写的队列：深度剖析ConcurrentLinkedQueue类  132
3.3.5  高效读取：不变模式下的CopyOnWriteArrayList类  138
3.3.6  数据共享通道：BlockingQueue  139
3.3.7  随机数据结构：跳表（SkipList）  144
3.4  使用JMH进行性能测试  146
3.4.1  什么是JMH  147
3.4.2  Hello JMH  147
3.4.3  JMH的基本概念和配置  150
3.4.4  理解JMH中的Mode  151
3.4.5  理解JMH中的State  153
3.4.6  有关性能的一些思考  154
3.4.7  CopyOnWriteArrayList类与ConcurrentLinkedQueue类  157
第4章  锁的优化及注意事项  161
4.1  有助于提高锁性能的几点建议  162
4.1.1  减少锁持有时间  162
4.1.2  减小锁粒度  163
4.1.3  用读写分离锁来替换独占锁  165
4.1.4  锁分离  165
4.1.5  锁粗化  168
4.2  Java虚拟机对锁优化所做的努力  169
4.2.1  锁偏向  169
4.2.2  轻量级锁  169
4.2.3  自旋锁  170
4.2.4  锁消除  170
4.3  人手一支笔：ThreadLocal  171
4.3.1  ThreadLocal的简单使用  171
4.3.2  ThreadLocal的实现原理  173
4.3.3  对性能有何帮助  179
4.4  无锁  182
4.4.1  与众不同的并发策略：比较交换  182
4.4.2  无锁的线程安全整数：AtomicInteger  183
4.4.3  Java中的指针：Unsafe类  185
4.4.4  无锁的对象引用：AtomicReference  187
4.4.5  带有时间戳的对象引用：AtomicStampedReference  190
4.4.6  数组也能无锁：AtomicIntegerArray  193
4.4.7  让普通变量也享受原子操作：AtomicIntegerFieldUpdater  194
4.4.8  挑战无锁算法：无锁的Vector实现  196
4.4.9  让线程之间互相帮助：细看SynchronousQueue的实现  201
4.5  有关死锁的问题  205
第5章  并行模式与算法  209
5.1  探讨单例模式  209
5.2  不变模式  213
5.3  生产者-消费者模式  215
5.4  高性能的生产者-消费者模式：无锁的实现  220
5.4.1  无锁的缓存框架：Disruptor  221
5.4.2  用Disruptor框架实现生产者-消费者模式的案例  222
5.4.3  提高消费者的响应时间：选择合适的策略  225
5.4.4  CPU Cache的优化：解决伪共享问题  226
5.5  Future模式  230
5.5.1  Future模式的主要角色  232
5.5.2  Future模式的简单实现  233
5.5.3  JDK中的Future模式  236
5.5.4  Guava对Future模式的支持  238
5.6  并行流水线  240
5.7  并行搜索  244
5.8  并行排序  246
5.8.1  分离数据相关性：奇偶交换排序  246
5.8.2  改进的插入排序：希尔排序  250
5.9  并行算法：矩阵乘法  254
5.10  准备好了再通知我：网络NIO  258
5.10.1  基于Socket的服务端多线程模式  259
5.10.2  使用NIO进行网络编程  264
5.10.3  使用NIO来实现客户端  272
5.11  读完了再通知我：AIO  274
5.11.1  AIO EchoServer的实现  275
5.11.2  AIO Echo客户端的实现  277
第6章  Java 8/9/10与并发  281
6.1  Java 8的函数式编程简介  281
6.1.1  函数作为一等公民  282
6.1.2  无副作用  283
6.1.3  声明式的（Declarative）  283
6.1.4  不变的对象  284
6.1.5  易于并行  284
6.1.6  更少的代码  284
6.2  函数式编程基础  285
6.2.1  FunctionalInterface注释  285
6.2.2  接口默认方法  286
6.2.3  lambda表达式  290
6.2.4  方法引用  291
6.3  一步一步走入函数式编程  293
6.4  并行流与并行排序  298
6.4.1  使用并行流过滤数据  298
6.4.2  从集合得到并行流  299
6.4.3  并行排序  299
6.5  增强的Future：CompletableFuture  300
6.5.1  完成了就通知我  300
6.5.2  异步执行任务  301
6.5.3  流式调用  303
6.5.4  CompletableFuture中的异常处理  303
6.5.5  组合多个CompletableFuture  304
6.5.6  支持timeout的 CompletableFuture  306
6.6  读写锁的改进：StampedLock  306
6.6.1  StampedLock使用示例  307
6.6.2  StampedLock的小陷阱  308
6.6.3  有关StampedLock的实现思想  310
6.7  原子类的增强  313
6.7.1  更快的原子类：LongAdder  314
6.7.2  LongAdder功能的增强版：LongAccumulator  320
6.8  ConcurrentHashMap的增强  321
6.8.1  foreach操作  321
6.8.2  reduce操作  321
6.8.3  条件插入  322
6.8.4  search操作  323
6.8.5  其他新方法  324
6.9  发布和订阅模式  324
6.9.1  简单的发布订阅例子  326
6.9.2  数据处理链  328
第7章  使用Akka构建高并发程序  331
7.1  新并发模型：Actor  332
7.2  Akka之Hello World  332
7.3  有关消息投递的一些说明  336
7.4  Actor的生命周期  337
7.5  监督策略  341
7.6  选择Actor  346
7.7  消息收件箱（Inbox）  346
7.8  消息路由  348
7.9  Actor的内置状态转换  351
7.10  询问模式：Actor中的Future  354
7.11  多个Actor同时修改数据：Agent  356
7.12  像数据库一样操作内存数据：软件事务内存  359
7.13  一个有趣的例子：并发粒子群的实现  363
7.13.1  什么是粒子群算法  364
7.13.2  粒子群算法的计算过程  364
7.13.3  粒子群算法能做什么  366
7.13.4  使用Akka实现粒子群  367
第8章  并行程序调试  375
8.1  准备实验样本  375
8.2  正式起航  376
8.3  挂起整个虚拟机  379
8.4  调试进入ArrayList内部  380
第9章  多线程优化示例—Jetty核心代码分析  385
9.1  Jetty简介与架构  385
9.2  Jetty服务器初始化  387
9.2.1  初始化线程池  387
9.2.2  初始化ScheduledExecutorScheduler  389
9.2.3  初始化ByteBufferPool  390
9.2.4  维护ConnectionFactory  393
9.2.5  计算ServerConnector的线程数量  394
9.3  启动Jetty服务器  394
9.3.1  设置启动状态  394
9.3.2  注册ShutdownMonitor  395
9.3.3  计算系统的线程数量  395
9.3.4  启动QueuedThreadPool  396
9.3.5  启动Connector  396
9.4  处理HTTP请求  399
9.4.1  Accept成功  399
9.4.2  请求处理  401
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实战Java高并发程序设计（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>并发的艺术
译者序
前言
第1章 并行让程序运行得更快
1.1 你可能会想到的一些问题
1.2 采用线程化方法的4个步骤
1.3 并行算法的背景知识
1.4 共享内存编程与分布式内存编程的比较
1.5 本书采用的并发编程方法
第2章 是否采用并发
2.1 并发算法的设计模型
2.2 哪些算法不能并行
第3章 算法正确性证明与性能衡量
3.1 并行算法的验证
3.2 示例：临界区问题
3.3 性能测试（程序的执行情况如何）
3.4 硬件并行性的发展历史
第4章 多线程程序设计中的8条简单原则
4.1 规则1：找出真正独立的运算
4.2 规则2：在尽可能高的层次上实现并发
4.3 规则3：尽早考虑通过增加处理器核的数量来获得可伸缩性
4.4 规则4：尽可能使用线程安全的库
4.5 规则5：使用正确的多线程模型
4.6 规则6：永远不要假设程序会按照某种特定的顺序执行
4.7 规则7：尽可能使用线程局部存储或者与特定数据相关的锁
4.8 规则8：要敢于对代码进行修改以获得更好的并发性
第5章 线程化库
5.1 隐式线程化
5.2 显式线程化
5.3 还剩下哪些内容没有介绍
5.4 特定领域的库
第6章 并行求和与前缀求和
6.1 并行求和
6.2 前缀求和
6.3 选择
6.4 最后的思考
第7章 映射归约
7.1 并发映射运算
7.2 并发归约运算
7.3 映射归约的应用
7.4 将映射归约作为一般性并发
第8章 排序
8.1 冒泡排序
8.2 奇偶换位排序
8.3 希尔排序
8.4 快速排序
8.5 基数排序
第9章 搜索
9.1 未排序的数据序列
9.2 二分搜索
第10章 图算法
10.1 深度优先搜索
10.2 最短路径问题
10.3 最小生成树
第11章 线程化工具
11.1 调试器
11.2 性能工具
11.3 还剩下什么内容没有介绍
11.4 再接再厉
术语表
封面说明
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>并发的艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go并发编程实战（第2版）
第1章　初识Go语言　　1
1.1　语言特性　　1
1.2　安装和设置　　2
1.3　工程结构　　3
1.3.1　工作区　　3
1.3.2　GOPATH　　4
1.3.3　源码文件　　5
1.3.4　代码包　　8
1.4　标准命令简述　　11
1.5　问候程序　　13
1.6　小结　　14
第2章　语法概览　　15
2.1　基本构成要素　　15
2.1.1　标识符　　15
2.1.2　关键字　　16
2.1.3　字面量　　17
2.1.4　操作符　　17
2.1.5　表达式　　19
2.2　基本类型　　20
2.3　高级类型　　22
2.3.1　数组　　23
2.3.2　切片　　23
2.3.3　字典　　24
2.3.4　函数和方法　　25
2.3.5　接口　　28
2.3.6　结构体　　29
2.4　流程控制　　30
2.4.1　代码块和作用域　　30
2.4.2　if语句　　32
2.4.3　switch语句　　32
2.4.4　for语句　　34
2.4.5　defer语句　　36
2.4.6　panic和recover　　38
2.5　聊天机器人　　40
2.6　小结　　44
第3章　并发编程综述　　45
3.1　并发编程基础　　45
3.1.1　串行程序与并发程序　　46
3.1.2　并发程序与并行程序　　46
3.1.3　并发程序与并发系统　　47
3.1.4　并发程序的不确定性　　47
3.1.5　并发程序内部的交互　　47
3.2　多进程编程　　48
3.2.1　进程　　48
3.2.2　关于同步　　55
3.2.3　管道　　60
3.2.4　信号　　65
3.2.5　socket　　74
3.3　多线程编程　　97
3.3.1　线程　　98
3.3.2　线程的同步　　107
3.4　多线程与多进程　　125
3.5　多核时代的并发编程　　126
3.6　小结　　130
第4章　Go的并发机制　　131
4.1　原理探究　　131
4.1.1　线程实现模型　　132
4.1.2　调度器　　142
4.1.3　更多细节　　158
4.2　goroutine　　160
4.2.1　go语句与goroutine　　160
4.2.2　主goroutine的运作　　166
4.2.3　runtime包与goroutine　　166
4.3　channel　　169
4.3.1　channel的基本概念　　169
4.3.2　单向channel　　180
4.3.3　for语句与channel　　184
4.3.4　select语句　　185
4.3.5　非缓冲的channel　　190
4.3.6　time包与channel　　192
4.4　实战演练：载荷发生器　　198
4.4.1　参数和结果　　199
4.4.2　基本结构　　201
4.4.3　初始化　　206
4.4.4　启动和停止　　212
4.4.5　调用器和功能测试　　221
4.5　小结　　231
第5章　同　　步　　232
5.1　锁的使用　　232
5.1.1　互斥锁　　232
5.1.2　读写锁　　236
5.1.3　锁的完整示例　　238
5.2　条件变量　　244
5.3　原子操作　　247
5.3.1　增或减　　247
5.3.2　比较并交换　　249
5.3.3　载入　　250
5.3.4　存储　　251
5.3.5　交换　　251
5.3.6　原子值　　252
5.3.7　应用于实际　　256
5.4　只会执行一次　　257
5.5　WaitGroup　　258
5.6　临时对象池　　262
5.7　实战演练——Concurrent Map　　265
5.8　小结　　280
第6章　网络爬虫框架设计和实现　　281
6.1　网络爬虫与框架　　281
6.2　功能需求和分析　　283
6.3　总体设计　　284
6.4　详细设计　　286
6.4.1　基本数据结构　　286
6.4.2　接口的设计　　293
6.5　工具的实现　　309
6.5.1　缓冲器　　309
6.5.2　缓冲池　　311
6.5.3　多重读取器　　317
6.6　组件的实现　　318
6.6.1　内部基础接口　　319
6.6.2　组件注册器　　321
6.6.3　下载器　　323
6.6.4　分析器　　325
6.6.5　条目处理管道　　328
6.7　调度器的实现　　329
6.7.1　基本结构　　329
6.7.2　初始化　　331
6.7.3　启动　　333
6.7.4　停止　　343
6.7.5　其他方法　　344
6.7.6　总结　　345
6.8　一个简单的图片爬虫　　346
6.8.1　概述　　346
6.8.2　命令参数　　346
6.8.3　初始化调度器　　348
6.8.4　监控调度器　　354
6.8.5　启动调度器　　364
6.9　扩展与思路　　365
6.10　本章小结　　368
附录A　Go语言的学习资源　　369
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go并发编程实战（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机并发编程
译者序
前言
第1章 并发的威力与风险 1
1.1 线程：程序的执行流程 1
1.2 并发的威力 1
1.3 并发的风险 4
1.4 小结 9
第一部分 并发策略
第2章 分工原则 11
2.1 从顺序到并发 11
2.2 在IO密集型应用程序中使用并发技术 13
2.3 并发方法对IO密集型应用程序的加速效果 19
2.4 在计算密集型应用程序中使用并发技术 20
2.5 并发方法对于计算密集型应用程序的加速效果 25
2.6 有效的并发策略 26
2.7 小结 27
第3章 设计方法 28
3.1 处理状态 28
3.2 探寻设计选项 29
3.3 共享可变性设计 29
3.4 隔离可变性设计 30
3.5 纯粹不可变性设计 30
3.6 持久的/不可变的数据结构 31
3.7 选择一种设计方法 34
3.8 小结 34
第二部分 现代Java/JDK并发模型
第4章 可扩展性和线程安全 37
4.1 用ExecutorService管理线程 37
4.2 使线程协作 38
4.3 数据交换 47
4.4 Java 7 Fork-Join API 49
4.5 可扩展集合类 51
4.6 Lock和Synchronized 54
4.7 小结 58
第5章 驯服共享可变性 59
5.1 共享可变性 != Public 59
5.2 定位并发问题 59
5.3 保持不变式 61
5.4 管理好资源 62
5.5 保证可见性 64
5.6 增强并发性 65
5.7 保证原子性 67
5.8 小结 70
第三部分 软件事务内存
第6章 软件事务内存导论 71
6.1 同步与并发水火不容 71
6.2 对象模型的缺陷 72
6.3 将实体与状态分离 73
6.4 软件事务内存 74
6.5 STM中的事务 77
6.6 用STM实现并发 77
6.7 用Akka/Multiverse STM实现并发 82
6.8 创建事务 84
6.9 创建嵌套事务 90
6.10 配置Akka事务 97
6.11 阻塞事务—有意识地等待 100
6.12 提交和回滚事件 103
6.13 集合与事务 106
6.14 处理写偏斜异常 110
6.15 STM的局限性 112
6.16 小结 116
第7章 在Clojure、Groovy、Java、JRuby和Scala中使用STM 117
7.1 Clojure STM 117
7.2 Groovy集成 118
7.3 Java集成 122
7.4 JRuby集成 124
7.5 Scala中的可选方案 130
7.6 小结 133
第四部分 基于角色的并发模型
第8章 讨喜的隔离可变性 135
8.1 用角色实现隔离可变性 136
8.2 角色的特性 137
8.3 创建角色 138
8.4 收发消息 144
8.5 同时使用多个角色 148
8.6 多角色协作 152
8.7 使用类型化角色 159
8.8 类型化角色和murmurs 163
8.9 混合使用角色和STM 169
8.10 使用transactor 169
8.11 调和类型化角色 176
8.12 远程角色 182
8.13 基于角色模型的局限性 184
8.14 小结 184
第9章 在Groovy、Java、JRuby和Scala中使用角色 186
9.1 在Groovy中使用GPars提供的角色实现 186
9.2 在Java中使用Akka提供的角色实现 199
9.3 在JRuby中使用Akka提供的Actor实现 199
9.4 在Scala中使用角色 202
9.5 小结 202
第五部分 后记
第10章 并发编程之禅 205
10.1 慎重选择 205
10.2 并发：程序员指南 206
10.3 并发：架构师指南 207
10.4 明智地进行选择 208
附录1 Clojure agent 210
附录2 一些网络资源 214
参考文献 216
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机并发编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java并发编程之美
第一部分  Java 并发编程基础篇
第1 章  并发编程线程基础  2
1.1  什么是线程  2
1.2  线程创建与运行  3
1.3  线程通知与等待  6
1.4  等待线程执行终止的join 方法  16
1.5  让线程睡眠的sleep 方法  19
1.6  让出CPU 执行权的yield 方法  23
1.7  线程中断  24
1.8  理解线程上下文切换  30
1.9  线程死锁  30
1.9.1  什么是线程死锁  30
1.9.2  如何避免线程死锁  33
1.10  守护线程与用户线程  35
1.11  ThreadLocal  39
1.11.1  ThreadLocal 使用示例  40
1.11.2  ThreadLocal 的实现原理  42
1.11.3  ThreadLocal 不支持继承性  45
1.11.4  InheritableThreadLocal 类  46
第2 章  并发编程的其他基础知识  50
2.1  什么是多线程并发编程  50
2.2  为什么要进行多线程并发编程  51
2.3  Java 中的线程安全问题  51
2.4  Java 中共享变量的内存可见性问题  52
2.5  Java 中的synchronized 关键字  54
2.5.1  synchronized 关键字介绍  54
2.5.2  synchronized 的内存语义  55
2.6  Java 中的volatile 关键字  55
2.7  Java 中的原子性操作  57
2.8  Java 中的CAS 操作  59
2.9  Unsafe 类  59
2.9.1  Unsafe 类中的重要方法  59
2.9.2  如何使用Unsafe 类  61
2.10  Java 指令重排序  65
2.11  伪共享  67
2.11.1  什么是伪共享  67
2.11.2  为何会出现伪共享  68
2.11.3  如何避免伪共享  70
2.11.4  小结  72
2.12  锁的概述  72
2.12.1  乐观锁与悲观锁  72
2.12.2  公平锁与非公平锁  75
2.12.3  独占锁与共享锁  75
2.12.4  什么是可重入锁  76
2.12.5  自旋锁  77
2.13  总结  77
第二部分  Java 并发编程高级篇
第3 章  Java 并发包中ThreadLocalRandom 类原理剖析  80
3.1  Random 类及其局限性  80
3.2  ThreadLocalRandom  82
3.3  源码分析  84
3.4  总结  87
第4 章  Java 并发包中原子操作类原理剖析  88
4.1  原子变量操作类  88
4.2  JDK 8 新增的原子操作类LongAdder  93
4.2.1  LongAdder 简单介绍  93
4.2.2  LongAdder 代码分析  95
4.2.3  小结  101
4.3  LongAccumulator 类原理探究  102
4.4  总结  104
第5 章  Java 并发包中并发List 源码剖析  105
5.1  介绍  105
5.2  主要方法源码解析  106
5.2.1  初始化  106
5.2.2  添加元素  106
5.2.3  获取指定位置元素  108
5.2.4  修改指定元素  109
5.2.5  删除元素  110
5.2.6  弱一致性的迭代器  111
5.3  总结  114
第6 章  Java 并发包中锁原理剖析  115
6.1  LockSupport 工具类  115
6.2  抽象同步队列AQS 概述  122
6.2.1  AQS——锁的底层支持  122
6.2.2  AQS——条件变量的支持  128
6.2.3  基于AQS 实现自定义同步器  131
6.3  独占锁ReentrantLock 的原理  136
6.3.1  类图结构  136
6.3.2  获取锁  137
6.3.3  释放锁  142
6.3.4  案例介绍  143
6.3.5  小结  145
6.4  读写锁ReentrantReadWriteLock 的原理  145
6.4.1  类图结构  145
6.4.2  写锁的获取与释放  147
6.4.3  读锁的获取与释放  151
6.4.4  案例介绍  156
6.4.5  小结  158
6.5  JDK 8 中新增的StampedLock 锁探究  158
6.5.1  概述  158
6.5.2  案例介绍  160
6.5.3  小结  164
第7 章  Java 并发包中并发队列原理剖析  165
7.1  ConcurrentLinkedQueue 原理探究  165
7.1.1  类图结构  165
7.1.2  ConcurrentLinkedQueue 原理介绍  166
7.1.3  小结  181
7.2  LinkedBlockingQueue 原理探究  182
7.2.1  类图结构  182
7.2.2  LinkedBlockingQueue 原理介绍  185
7.2.3  小结  194
7.3  ArrayBlockingQueue 原理探究  195
7.3.1  类图结构  195
7.3.2  ArrayBlockingQueue 原理介绍  197
7.3.3  小结  202
7.4  PriorityBlockingQueue 原理探究  203
7.4.1  介绍  203
7.4.2  PriorityBlockingQueue 类图结构  203
7.4.3  原理介绍  205
7.4.4  案例介绍  214
7.4.5  小结  216
7.5  DelayQueue 原理探究  217
7.5.1  DelayQueue 类图结构  217
7.5.2  主要函数原理讲解  219
7.5.3  案例介绍  222
7.5.4  小结  224
第8 章  Java 并发包中线程池ThreadPoolExecutor 原理探究  225
8.1  介绍  225
8.2  类图介绍  225
8.3  源码分析  230
8.3.1  public void execute(Runnable command)  230
8.3.2  工作线程Worker 的执行  235
8.3.3  shutdown 操作  238
8.3.4  shutdownNow 操作  240
8.3.5  awaitTermination 操作  241
8.4  总结  242
第9 章  Java 并发包中ScheduledThreadPoolExecutor 原理探究  243
9.1  介绍  243
9.2  类图介绍  243
9.3  原理剖析  245
9.3.1  schedule(Runnable command, long delay,TimeUnit unit) 方法  246
9.3.2  scheduleWithFixedDelay(Runnable command,long initialDelay, long delay,TimeUnit unit) 方法  252
9.3.3  scheduleAtFixedRate(Runnable command,long initialDelay,long period,TimeUnit unit) 方法  254
9.4  总结  255
第10 章  Java 并发包中线程同步器原理剖析  256
10.1  CountDownLatch 原理剖析  256
10.1.1  案例介绍  256
10.1.2  实现原理探究  259
10.1.3  小结  263
10.2  回环屏障CyclicBarrier 原理探究  264
10.2.1  案例介绍  264
10.2.2  实现原理探究  268
10.2.3  小结  272
10.3  信号量Semaphore 原理探究  272
10.3.1  案例介绍  272
10.3.2  实现原理探究  276
10.3.3  小结  281
10.4  总结  281
第三部分  Java 并发编程实践篇
第11 章  并发编程实践  284
11.1  ArrayBlockingQueue 的使用  284
11.1.1  异步日志打印模型概述  284
11.1.2  异步日志与具体实现  285
11.1.3  小结  293
11.2  Tomcat 的NioEndPoint 中ConcurrentLinkedQueue 的使用  293
11.2.1  生产者——Acceptor 线程  294
11.2.2  消费者——Poller 线程  298
11.2.3  小结  300
11.3  并发组件ConcurrentHashMap 使用注意事项  300
11.4  SimpleDateFormat 是线程不安全的  304
11.4.1  问题复现  304
11.4.2  问题分析  305
11.4.3  小结  309
11.5  使用Timer 时需要注意的事情  309
11.5.1  问题的产生  309
11.5.2  Timer 实现原理分析  310
11.5.3  小结  313
11.6  对需要复用但是会被下游修改的参数要进行深复制  314
11.6.1  问题的产生  314
11.6.2  问题分析  316
11.6.3  小结  318
11.7  创建线程和线程池时要指定与业务相关的名称  319
11.7.1  创建线程需要有线程名  319
11.7.2  创建线程池时也需要指定线程池的名称  321
11.7.3  小结  325
11.8  使用线程池的情况下当程序结束时记得调用shutdown 关闭线程池  325
11.8.1  问题复现  325
11.8.2  问题分析  327
11.8.3  小结  329
11.9  线程池使用FutureTask 时需要注意的事情  329
11.9.1  问题复现  329
11.9.2  问题分析  332
11.9.3  小结  335
11.10  使用ThreadLocal 不当可能会导致内存泄漏  336
11.10.1  为何会出现内存泄漏  336
11.10.2  在线程池中使用ThreadLocal 导致的内存泄漏  339
11.10.3  在Tomcat 的Servlet 中使用ThreadLocal 导致内存泄漏  341
11.10.4  小结  344
11.11  总结  344
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java并发编程之美
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 7并发编程实战手册
第1章 线程管理 1
1.1 简介 1
1.2 线程的创建和运行 2
1.3 线程信息的获取和设置 5
1.4 线程的中断 9
1.5 线程中断的控制 11
1.6 线程的休眠和恢复 15
1.7 等待线程的终止 17
1.8 守护线程的创建和运行 20
1.9 线程中不可控异常的处理 24
1.10 线程局部变量的使用 26
1.11 线程的分组 30
1.12 线程组中不可控异常的处理 34
1.13 使用工厂类创建线程 37
第2章 线程同步基础 41
2.1 简介 41
2.2 使用synchronized实现同步方法 42
2.3 使用非依赖属性实现同步 47
2.4 在同步代码中使用条件 53
2.5 使用锁实现同步 57
2.6 使用读写锁实现同步数据访问 61
2.7 修改锁的公平性 65
2.8 在锁中使用多条件(Multiple Condition) 69
第3章 线程同步辅助类 77
3.1 简介 77
3.2 资源的并发访问控制 78
3.3 资源的多副本的并发访问控制 83
3.4 等待多个并发事件的完成 87
3.5 在集合点的同步 91
3.6 并发阶段任务的运行 100
3.7 并发阶段任务中的阶段切换 109
3.8 并发任务间的数据交换 115
第4章 线程执行器 120
4.1 简介 120
4.2 创建线程执行器 121
4.3 创建固定大小的线程执行器 126
4.4 在执行器中执行任务并返回结果 129
4.5 运行多个任务并处理第一个结果 134
4.6 运行多个任务并处理所有结果 139
4.7 在执行器中延时执行任务 144
4.8 在执行器中周期性执行任务 147
4.9 在执行器中取消任务 151
4.10 在执行器中控制任务的完成 154
4.11 在执行器中分离任务的启动与结果的处理 158
4.12 处理在执行器中被拒绝的任务 164
第5章 Fork/Join框架 168
5.1 简介 168
5.2 创建Fork/Join线程池 170
5.3 合并任务的结果 178
5.4 异步运行任务 187
5.5 在任务中抛出异常 194
5.6 取消任务 199
第6章 并发集合 206
6.1 简介 206
6.2 使用非阻塞式线程安全列表 207
6.3 使用阻塞式线程安全列表 212
6.4 使用按优先级排序的阻塞式线程安全列表 215
6.5 使用带有延迟元素的线程安全列表 221
6.6 使用线程安全可遍历映射 226
6.7 生成并发随机数 231
6.8 使用原子变量 233
6.9 使用原子数组 237
第7章 定制并发类 242
7.1 简介 242
7.2 定制ThreadPoolExecutor类 243
7.3 实现基于优先级的Executor类 248
7.4 实现ThreadFactory接口生成定制线程 252
7.5 在Executor对象中使用ThreadFactory 257
7.6 定制运行在定时线程池中的任务 259
7.7 通过实现ThreadFactory接口为Fork/Join框架生成定制线程 267
7.8 定制运行在Fork/Join框架中的任务 273
7.9 实现定制Lock类 278
7.10 实现基于优先级的传输队列 284
7.11 实现自己的原子对象 294
第8章 测试并发应用程序 300
8.1 简介 300
8.2 监控Lock接口 301
8.3 监控Phaser类 305
8.4 监控执行器框架 309
8.5 监控Fork/Join池 312
8.6 输出高效的日志信息 317
8.7 使用FindBugs分析并发代码 323
8.8 配置Eclipse调试并发代码 327
8.9 配置NetBeans调试并发代码 330
8.10 使用MultithreadedTC测试并发代码 335
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 7并发编程实战手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#并发编程经典实例
译者序　　IX
前言　　XI
第1 章　并发编程概述　　1
1.1　并发编程简介　　1
1.2　异步编程简介　　3
1.3　并行编程简介　　7
1.4　响应式编程简介　　9
1.5　数据流简介　　11
1.6　多线程编程简介　　13
1.7　并发编程的集合　　13
1.8　现代设计　　14
1.9　技术要点总结　　14
第2 章　异步编程基础　　17
2.1　暂停一段时间　　18
2.2　返回完成的任务　　19
2.3　报告进度　　21
2.4　等待一组任务完成　　22
2.5　等待任意一个任务完成　　25
2.6　任务完成时的处理　　26
2.7　避免上下文延续　　29
2.8　处理async Task 方法的异常　　30
2.9　处理async void 方法的异常　　32
第3 章　并行开发的基础　　35
3.1　数据的并行处理　　35
3.2　并行聚合　　37
3.3　并行调用　　38
3.4　动态并行　　40
3.5　并行LINQ　　41
第4 章　数据流基础　　43
4.1　链接数据流块　　44
4.2　传递出错信息　　45
4.3　断开链接　　47
4.4　限制流量　　48
4.5　数据流块的并行处理　　48
4.6　创建自定义数据流块　　49
第5 章　Rx 基础　　51
5.1　转换.NET 事件　　52
5.2　发通知给上下文　　54
5.3　用窗口和缓冲对事件分组　　56
5.4　用限流和抽样抑制事件流　　58
5.5　超时　　..60
第6 章　测试技巧　　63
6.1　async 方法的单元测试　　64
6.2　预计失败的async 方法的单元测试　　65
6.3　async void 方法的单元测试　　67
6.4　数据流网格的单元测试　　68
6.5　Rx Observable 对象的单元测试　　70
6.6　用虚拟时间测试Rx Observable 对象　　72
第7 章　互操作　　75
7.1　用async 代码封装Async 方法与Completed 事件　　75
7.2　用async 代码封装Begin/End 方法　　77
7.3　用async 代码封装所有异步操作　　78
7.4　用async 代码封装并行代码　　80
7.5　用async 代码封装Rx Observable 对象　　80
7.6　用Rx Observable 对象封装async 代码　　82
7.7　Rx Observable 对象和数据流网格　　83
第8 章　集合　　85
8.1　不可变栈和队列　　87
8.2　不可变列表　　89
8.3　不可变Set 集合　　91
8.4　不可变字典　　93
8.5　线程安全字典　　94
8.6　阻塞队列　　96
8.7　阻塞栈和包　　99
8.8　异步队列　　100
8.9　异步栈和包　　102
8.10　阻塞/ 异步队列　　104
第9 章　取消　　109
9.1　发出取消请求　　110
9.2　通过轮询响应取消请求　　112
9.3　超时后取消　　114
9.4　取消async 代码　　115
9.5　取消并行代码　　116
9.6　取消响应式代码　　117
9.7　取消数据流网格　　119
9.8　注入取消请求　　120
9.9　与其他取消体系的互操作　　122
第10 章　函数式OOP　　125
10.1　异步接口和继承　　125
10.2　异步构造：工厂　　127
10.3　异步构造：异步初始化模式　　129
10.4　异步属性　　132
10.5　异步事件　　134
10.6　异步销毁　　137
第11 章　同步　　143
11.1　阻塞锁　　148
11.2　异步锁　　149
11.3　阻塞信号　　151
11.4　异步信号　　152
11.5　限流　　154
第12 章　调度　　157
12.1　调度到线程池　　157
12.2　任务调度器　　159
12.3　调度并行代码　　161
12.4　用调度器实现数据流的同步　　161
第13 章　实用技巧　　163
13.1　初始化共享资源　　163
13.2　Rx 延迟求值　　165
13.3　异步数据绑定　　166
13.4　隐式状态　　168
封面介绍　　170
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#并发编程经典实例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>亿级流量Java高并发与网络编程实战
目录
第1章 高并发概述
第2章 系统分析与大型互联网架构设计
第3章 高并发相关JVM与JDK新特性案例讲解
第4章 实战解析多线程并发包
第5章 分布式网络编程核心技术—远程调用
第6章 NIO案例解析与高性能聊天室实战
第7章 高性能NIO框架Netty实例详解
第8章 主流RPC框架解析与跨语言调用案例
第9章 实战解析高并发框架Disruptor
第10章 手把手开发微服务构建框架Spring Boot
第11章 Spring全家桶—使用Spring Boot整合常见Web组件
第12章 微服务治理框架Spring Cloud理论与案例解析
第13章 通过案例讲解分布式服务框架Dubbo
第14章 MySQL性能调优案例实战
第15章 基于海量数据的高性能高可用数据库方案的设计与实现
第16章 使用Redis实现持久化与高速缓存功能
第17章 分布式计算框架MapReduce入门详解
第18章 通过典型案例剖析MapReduce内部机制
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>亿级流量Java高并发与网络编程实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java并发实现原理：JDK源码剖析
第1章  多线程基础  / 1
1.1  线程的优雅关闭  / 1
1.1.1  stop与destory函数  / 1
1.1.2  守护线程  / 1
1.1.3  设置关闭的标志位  / 2
1.2  InterruptedException与interrupt()函数  / 3
1.2.1  什么情况下会抛出Interrupted异常  / 3
1.2.2  轻量级阻塞与重量级阻塞  / 4
1.2.3  t.isInterrupted()与Thread.interrupted()的区别  / 5
1.3  synchronized关键字  / 5
1.3.1  锁的对象是什么  / 5
1.3.2  锁的本质是什么  / 6
1.3.3  synchronized实现原理  / 7
1.4  wait与notify  / 7
1.4.1  生产者−消费者模型  / 7
1.4.2  为什么必须和synchronized一起使用  / 8
1.4.3  为什么wait()的时候必须释放锁  / 9
1.4.4  wait()与notify()的问题  / 10
1.5  volatile关键字  / 11
1.5.1  64位写入的原子性（Half Write）  / 11
1.5.2  内存可见性  / 11
1.5.3  重排序：DCL问题  / 12
1.6  JMM与happen-before  / 13
1.6.1  为什么会存在“内存可见性”问题  / 13
1.6.2  重排序与内存可见性的关系  / 15
1.6.3  as-if-serial语义  / 16
1.6.4  happen-before是什么  / 17
1.6.5  happen-before的传递性  / 18
1.6.6  C++中的volatile关键字  / 19
1.6.7  JSR-133对volatile语义的增强  / 20
1.7  内存屏障  / 20
1.7.1  Linux中的内存屏障  / 21
1.7.2  JDK中的内存屏障  / 23
1.7.3  volatile实现原理  / 24
1.8  final关键字  / 25
1.8.1  构造函数溢出问题  / 25
1.8.2  final的happen-before语义  / 26
1.8.3  happen-before规则总结  / 26
1.9  综合应用：无锁编程  / 27
1.9.1  一写一读的无锁队列：内存屏障  / 27
1.9.2  一写多读的无锁队列：volatile关键字  / 27
1.9.3  多写多读的无锁队列：CAS  / 28
1.9.4  无锁栈  / 28
1.9.5  无锁链表  / 28
第2章  Atomic类  / 29
2.1  AtomicInteger和AtomicLong  / 29
2.1.1  悲观锁与乐观锁  / 31
2.1.2  Unsafe 的CAS详解  / 31
2.1.3  自旋与阻塞  / 32
2.2  AtomicBoolean和AtomicReference  / 33
2.2.1  为什么需要AtomicBoolean  / 33
2.2.2  如何支持boolean和double类型  / 33
2.3  AtomicStampedReference和AtomicMarkable Reference  / 34
2.3.1  ABA问题与解决办法  / 34
2.3.2  为什么没有AtomicStampedInteger或AtomictStampedLong  / 35
2.3.3  AtomicMarkableReference  / 36
2.4  AtomicIntegerFieldUpdater、AtomicLongFieldUpdater和AtomicReferenceField Updater  / 37
2.4.1  为什么需要AtomicXXXFieldUpdater  / 37
2.4.2  限制条件  / 38
2.5  AtomicIntegerArray、AtomicLongArray和AtomicReferenceArray  / 38
2.5.1  使用方式  / 38
2.5.2  实现原理  / 39
2.6  Striped64与LongAdder  / 40
2.6.1  LongAdder原理  / 40
2.6.2  最终一致性  / 41
2.6.3  伪共享与缓存行填充  / 42
2.6.4  LongAdder核心实现  / 43
2.6.5  LongAccumulator  / 47
2.6.6  DoubleAdder与DoubleAccumulator  / 47
第3章  Lock与Condition  / 49
3.1  互斥锁  / 49
3.1.1  锁的可重入性  / 49
3.1.2  类继承层次  / 49
3.1.3  锁的公平性vs.非公平性  / 51
3.1.4  锁实现的基本原理  / 51
3.1.5  公平与非公平的lock()实现差异  / 53
3.1.6  阻塞队列与唤醒机制  / 55
3.1.7  unlock()实现分析  / 58
3.1.8  lockInterruptibly()实现分析  / 59
3.1.9  tryLock()实现分析  / 60
3.2  读写锁  / 60
3.2.1  类继承层次  / 60
3.2.2  读写锁实现的基本原理  / 61
3.2.3  AQS的两对模板方法  / 62
3.2.4  WriteLock公平vs.非公平实现  / 65
3.2.5  ReadLock公平vs.非公平实现  / 67
3.3  Condition  / 68
3.3.1  Condition与Lock的关系  / 68
3.3.2  Condition的使用场景  / 69
3.3.3  Condition实现原理  / 71
3.3.4  await()实现分析  / 72
3.3.5  awaitUninterruptibly()实现分析  / 73
3.3.6  notify()实现分析  / 74
3.4  StampedLock  / 75
3.4.1  为什么引入StampedLock  / 75
3.4.2  使用场景  / 75
3.4.3  “乐观读”的实现原理  / 77
3.4.4  悲观读/写：“阻塞”与“自旋”策略实现差异  / 78
第4章  同步工具类  / 83
4.1  Semaphore  / 83
4.2  CountDownLatch  / 84
4.2.1  CountDownLatch使用场景  / 84
4.2.2  await()实现分析  / 85
4.2.3  countDown()实现分析  / 85
4.3  CyclicBarrier  / 86
4.3.1  CyclicBarrier使用场景  / 86
4.3.2  CyclicBarrier实现原理  / 87
4.4  Exchanger  / 90
4.4.1  Exchanger使用场景  / 90
4.4.2  Exchanger 实现原理  / 91
4.4.3  exchange(V x)实现分析  / 92
4.5  Phaser  / 94
4.5.1  用Phaser替代CyclicBarrier和CountDownLatch  / 94
4.5.2  Phaser新特性  / 95
4.5.3  state变量解析  / 96
4.5.4  阻塞与唤醒（Treiber Stack）  / 98
4.5.5  arrive()函数分析  / 99
4.5.6  awaitAdvance()函数分析  / 101
第5章  并发容器  / 104
5.1  BlockingQueue  / 104
5.1.1  ArrayBlockingQueue  / 105
5.1.2  LinkedBlockingQueue  / 106
5.1.3  PriorityBlockingQueue  / 109
5.1.4  DelayQueue  / 111
5.1.5  SynchronousQueue  / 113
5.2  BlockingDeque  / 121
5.3  CopyOnWrite  / 123
5.3.1  CopyOnWriteArrayList  / 123
5.3.2  CopyOnWriteArraySet  / 124
5.4  ConcurrentLinkedQueue/ Deque  / 125
5.5  ConcurrentHashMap  / 130
5.5.1  JDK 7中的实现方式  / 130
5.5.2  JDK 8中的实现方式  / 138
5.6  ConcurrentSkipListMap/Set  / 152
5.6.1  ConcurrentSkipListMap  / 153
5.6.2  ConcurrentSkipListSet  / 162
第6章  线程池与Future  / 163
6.1  线程池的实现原理  / 163
6.2  线程池的类继承体系  / 164
6.3  ThreadPoolExecutor  / 165
6.3.1  核心数据结构  / 165
6.3.2  核心配置参数解释  / 165
6.3.3  线程池的优雅关闭  / 167
6.3.4  任务的提交过程分析  / 172
6.3.5  任务的执行过程分析  / 174
6.3.6  线程池的4种拒绝策略  / 179
6.4  Callable与Future  / 180
6.5  ScheduledThreadPool Executor  / 183
6.5.1  延迟执行和周期性执行的原理  / 184
6.5.2  延迟执行  / 184
6.5.3  周期性执行  / 185
6.6  Executors工具类  / 188
第7章  ForkJoinPool  / 190
7.1  ForkJoinPool用法  / 190
7.2  核心数据结构  / 193
7.3  工作窃取队列  / 195
7.4  ForkJoinPool状态控制  / 198
7.4.1  状态变量ctl解析  / 198
7.4.2  阻塞栈Treiber Stack  / 200
7.4.3  ctl变量的初始值  / 201
7.4.4  ForkJoinWorkerThread状态与个数分析  / 201
7.5  Worker线程的阻塞-唤醒机制  / 202
7.5.1  阻塞–入栈  / 202
7.5.2  唤醒–出栈  / 204
7.6  任务的提交过程分析  / 205
7.6.1  内部提交任务pushTask  / 206
7.6.2  外部提交任务addSubmission  / 206
7.7  工作窃取算法：任务的执行过程分析  / 207
7.7.1  顺序锁 SeqLock  / 209
7.7.2  scanGuard解析  / 210
7.8  ForkJoinTask的fork/join  / 212
7.8.1  fork  / 213
7.8.2  join的层层嵌套  / 213
7.9  ForkJoinPool的优雅关闭  / 222
7.9.1  关键的terminate变量  / 222
7.9.2  shutdown()与shutdownNow()的区别  / 223
第8章  CompletableFuture  / 226
8.1  CompletableFuture用法  / 226
8.1.1  最简单的用法  / 226
8.1.2  提交任务：runAsync与supplyAsync  / 226
8.1.3  链式的CompletableFuture：thenRun、thenAccept和thenApply  / 227
8.1.4  CompletableFuture的组合：thenCompose与thenCombine  / 229
8.1.5  任意个CompletableFuture的组合  / 231
8.2  四种任务原型  / 233
8.3  CompletionStage接口  / 233
8.4  CompletableFuture内部原理  / 234
8.4.1  CompletableFuture的构造：ForkJoinPool  / 234
8.4.2  任务类型的适配  / 235
8.4.3  任务的链式执行过程分析  / 237
8.4.4  thenApply与thenApplyAsync的区别  / 241
8.5  任务的网状执行：有向无环图  / 242
8.6  allOf内部的计算图分析  / 244
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java并发实现原理：JDK源码剖析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>NIO与Socket编程技术指南NIO，Socket，网络编程，并发编程，高并发
目录
前言
第1章 缓冲区的使用 1
1.1 NIO概述 5
1.2 缓冲区介绍 6
1.3 Buffer类的使用 7
1.3.1 包装数据与获得容量 7
1.3.2 限制获取与设置 10
1.3.3 位置获取与设置 12
1.3.4 剩余空间大小获取 13
1.3.5 使用Buffer mark()方法处理标记 14
1.3.6 知识点细化测试 15
1.3.7 判断只读 22
1.3.8 直接缓冲区 22
1.3.9 还原缓冲区的状态 23
1.3.10 对缓冲区进行反转 24
1.3.11 判断是否有底层实现的数组 28
1.3.12 判断当前位置与限制之间是否有剩余元素 29
1.3.13 重绕缓冲区 30
1.3.14 获得偏移量 32
1.3.15 使用List.toArray(T[])转成数组类型 33
1.4 ByteBuffer类的使用 34
1.4.1 创建堆缓冲区与直接缓冲区 35
1.4.2 直接缓冲区与非直接缓冲区的运行效率比较 37
1.4.3 包装wrap数据的处理 39
1.4.4 put(byte b)和get()方法的使用与position自增特性 40
1.4.5 put(byte[] src, int offset, int length)和get(byte[] dst, int offset, int length)方法的使用 41
1.4.6 put(byte[] src)和get(byte[] dst)方法的使用 46
1.4.7 put(int index, byte b)和get(int index)方法的使用与position不变 49
1.4.8 put(ByteBuffer src)方法的使用 50
1.4.9 putType()和getType()方法的使用 51
1.4.10 slice()方法的使用与arrayOffSet()为非0的测试 53
1.4.11 转换为CharBuffer字符缓冲区及中文的处理 54
1.4.12 转换为其他类型的缓冲区 58
1.4.13 设置与获得字节顺序 63
1.4.14 创建只读缓冲区 65
1.4.15 压缩缓冲区 65
1.4.16 比较缓冲区的内容 66
1.4.17 复制缓冲区 70
1.4.18 对缓冲区进行扩容 72
1.5 CharBuffer类的API使用 73
1.5.1 重载append(char)/append(Char-Sequence)/append(CharSequence, start, end)方法的使用 73
1.5.2 读取相对于当前位置的给定索引处的字符 74
1.5.3 put(String src)、int read(CharBuffer target)和subSequence(int start, int end)方法的使用 74
1.5.4 static CharBuffer wrap(Char-Sequence csq, int start, int end)方法的使用 76
1.5.5 获得字符缓冲区的长度 76
1.6 小结 77
第2章 通道和FileChannel类的使用 78
2.1 通道概述 78
2.2 通道接口的层次结构 80
2.2.1 AsynchronousChannel接口的介绍 82
2.2.2 AsynchronousByteChannel接口的介绍 84
2.2.3 ReadableByteChannel接口的介绍 84
2.2.4 ScatteringByteChannel接口的介绍 85
2.2.5 WritableByteChannel接口的介绍 86
2.2.6 GatheringByteChannel接口的介绍 87
2.2.7 ByteChannel接口的介绍 88
2.2.8 SeekableByteChannel接口的介绍 89
2.2.9 NetworkChannel接口的介绍 90
2.2.10 MulticastChannel接口的介绍 91
2.2.11 InterruptibleChannel接口的介绍 92
2.3 AbstractInterruptibleChannel类的介绍 93
2.4 FileChannel类的使用 95
2.4.1 写操作与位置的使用 97
2.4.2 读操作 100
2.4.3 批量写操作 106
2.4.4 批量读操作 109
2.4.5 部分批量写操作 117
2.4.6 部分批量读操作 120
2.4.7 向通道的指定position位置写入数据 128
2.4.8 读取通道指定位置的数据 130
2.4.9 设置位置与获得大小 135
2.4.10 截断缓冲区 136
2.4.11 将数据传输到其他可写入字节通道 138
2.4.12 将字节从给定可读取字节通道传输到此通道的文件中 141
2.4.13 执行锁定操作 145
2.4.14 FileLock lock()方法的使用 160
2.4.15 获取通道文件给定区域的锁定 160
2.4.16 FileLock tryLock()方法的使用 162
2.4.17 FileLock类的使用 162
2.4.18 强制将所有对通道文件的更新写入包含文件的存储设备 165
2.4.19 将通道文件区域直接映射到内存 167
2.4.20 打开一个文件 174
2.4.21 判断当前通道是否打开 181
2.5 小结 182
第3章 获取网络设备信息 183
3.1 NetworkInterface类的常用方法 184
3.1.1 获得网络接口的基本信息 186
3.1.2 获取MTU大小 189
3.1.3 子接口的处理 190
3.1.4 获得硬件地址 192
3.1.5 获得IP地址 194
3.1.6 InterfaceAddress类的使用 200
3.1.7 判断是否为点对点设备 202
3.1.8 是否支持多播 202
3.2 NetworkInterface类的静态方法 204
3.2.1 根据索引获得NetworkInterface对象 204
3.2.2 根据网络接口名称获得NetworkInterface对象 204
3.2.3 根据IP地址获得NetworkInterface对象 205
3.3 小结 205
第4章 实现Socket通信 206
4.1 基于TCP的Socket通信 206
4.1.1 验证ServerSocket类的accept()方法具有阻塞特性 207
4.1.2 验证Socket中InputStream类的read()方法也具有阻塞特性 210
4.1.3 客户端向服务端传递字符串 212
4.1.4 服务端向客户端传递字符串 213
4.1.5 允许多次调用write()方法进行写入操作 215
4.1.6 实现服务端与客户端多次的往来通信 216
4.1.7 调用Stream的close()方法造成Socket关闭 219
4.1.8 使用Socket传递PNG图片文件 221
4.1.9 TCP连接的3次“握手”过程 222
4.1.10 标志位SYN与ACK值的自增特性 225
4.1.11 TCP断开连接的4次“挥手”过程 226
4.1.12 “握手”的时机与立即传数据的特性 227
4.1.13 结合多线程Thread实现通信 228
4.1.14 服务端与客户端互传对象以及I/O流顺序问题 231
4.2 ServerSocket类的使用 233
4.2.1 接受accept与超时Timeout 233
4.2.2 构造方法的backlog参数含义 235
4.2.3 参数backlog的默认值 237
4.2.4 构造方法ServerSocket (int port, int backlog, InetAddress bindAddr)的使用 238
4.2.5 绑定到指定的Socket地址 240
4.2.6 绑定到指定的Socket地址并设置backlog数量 242
4.2.7 获取本地SocketAdress对象以及本地端口 243
4.2.8 InetSocketAddress类的使用 244
4.2.9 关闭与获取关闭状态 247
4.2.10 判断Socket绑定状态 248
4.2.11 获得IP地址信息 249
4.2.12 Socket选项ReuseAddress 249
4.2.13 Socket选项ReceiveBufferSize 257
4.3 Socket类的使用 259
4.3.1 绑定bind与connect以及端口生成的时机 259
4.3.2 连接与超时 261
4.3.3 获得远程端口与本地端口 262
4.3.4 获得本地InetAddress地址与本地SocketAddress地址 263
4.3.5 获得远程InetAddress与远程SocketAddress()地址 264
4.3.6 套接字状态的判断 265
4.3.7 开启半读与半写状态 266
4.3.8 判断半读半写状态 268
4.3.9 Socket选项TcpNoDelay 270
4.3.10 Socket选项SendBufferSize 274
4.3.11 Socket选项Linger 276
4.3.12 Socket选项Timeout 287
4.3.13 Socket选项OOBInline 288
4.3.14 Socket选项KeepAlive 291
4.3.15 Socket选项TrafficClass 293
4.4 基于UDP的Socket通信 294
4.4.1 使用UDP实现Socket通信 295
4.4.2 测试发送超大数据量的包导致数据截断的情况 297
4.4.3 Datagram Packet类中常用API的使用 299
4.4.4 使用UDP实现单播 300
4.4.5 使用UDP实现广播 301
4.4.6 使用UDP实现组播 303
4.5 小结 305
第5章 选择器的使用 306
5.1 选择器与I/O多路复用 306
5.2 核心类Selector、SelectionKey和SelectableChannel的关系 307
5.3 通道类AbstractInterruptibleChannel与接口InterruptibleChannel的介绍 310
5.4 通道类SelectableChannel的介绍 311
5.5 通道类AbstractSelectableChannel的介绍 313
5.6 通道类ServerSocketChannel与接口NetworkChannel的介绍 313
5.7 ServerSocketChannel类、Selector和SelectionKey的使用 315
5.7.1 获得ServerSocketChannel与ServerSocket socket对象 316
5.7.2 执行绑定操作 317
5.7.3 执行绑定操作与设置backlog 317
5.7.4 阻塞与非阻塞以及accept()方法的使用效果 318
5.7.5 获得Selector对象 320
5.7.6 执行注册操作与获得SelectionKey对象 321
5.7.7 判断注册的状态 322
5.7.8 将通道设置成非阻塞模式再注册到选择器 323
5.7.9 使用configureBlocking (false)方法解决异常 323
5.7.10 判断打开的状态 324
5.7.11 获得阻塞锁对象 325
5.7.12 获得支持的SocketOption列表 325
5.7.13 获得与设置SocketOption 327
5.7.14 获得SocketAddress对象 327
5.7.15 阻塞模式的判断 328
5.7.16 根据Selector找到对应的SelectionKey 328
5.7.17 获得SelectorProvider对象 329
5.7.18 通道注册与选择器 330
5.7.19 返回此通道所支持的操作 332
5.7.20 执行Connect连接操作 333
5.7.21 判断此通道上是否正在进行连接操作 336
5.7.22 完成套接字通道的连接过程 338
5.7.23 类FileChannel中的long tran-sferTo (position, count, Writable-ByteChannel)方法的使用 340
5.7.24 方法public static SocketChannel open (SocketAddress remote)与SocketOption的执行顺序 342
5.7.25 传输大文件 344
5.7.26 验证read和write方法是非阻塞的 346
5.8 Selector类的使用 348
5.8.1 验证public abstract int select()方法具有阻塞性 350
5.8.2 select()方法不阻塞的原因和解决办法 351
5.8.3 出现重复消费的情况 353
5.8.4 使用remove()方法解决重复消费问题 355
5.8.5 验证产生的set1和set2关联的各自对象一直是同一个 356
5.8.6 int selector.select()方法返回值的含义 360
5.8.7 从已就绪的键集中获得通道中的数据 362
5.8.8 对相同的通道注册不同的相关事件返回同一个SelectionKey 363
5.8.9 判断选择器是否为打开状态 365
5.8.10 获得SelectorProvider provider对象 365
5.8.11 返回此选择器的键集 366
5.8.12 public abstract int select(long timeout)方法的使用 367
5.8.13 public abstract int selectNow()方法的使用 368
5.8.14 唤醒操作 369
5.8.15 测试若干细节 370
5.9 SelectionKey类的使用 380
5.9.1 判断是否允许连接SelectableChannel对象 381
5.9.2 判断是否已准备好进行读取 383
5.9.3 判断是否已准备好进行写入 384
5.9.4 返回SelectionKey关联的选择器 386
5.9.5 在注册操作时传入attachment附件 387
5.9.6 设置attachment附件 389
5.9.7 获取与设置此键的interest集合 390
5.9.8 判断此键是否有效 392
5.9.9 获取此键的ready操作集合 392
5.9.10 取消操作 395
5.10 DatagramChannel类的使用 396
5.1 0.1 使用DatagramChannel类实现UDP通信 398
5.1 0.2 连接操作 399
5.1 0.3 断开连接 400
5.1 0.4 将通道加入组播地址 400
5.1 0.5 将通道加入组播地址且接收指定客户端数据 402
5.11 Pipe.SinkChannel和Pipe.SourceChannel类的使用 403
5.12 SelectorProvider类的使用 406
5.13 小结 407
第6章 AIO的使用 408
6.1 AsynchronousFileChannel类的使用 408
6.1.1 获取此通道文件的独占锁 409
6.1.2 获取通道文件给定区域的锁 410
6.1.3 实现重叠锁定 412
6.1.4 返回此通道文件当前大小与通道打开状态 413
6.1.5 CompletionHandler接口的使用 413
6.1.6 public void failed (Throwable exc, A attachment)方法调用时机 414
6.1.7 执行指定范围的锁定与传入附件及整合接口 415
6.1.8 执行锁定与传入附件及整合接口CompletionHandler 416
6.1.9 lock (position, size, shared, attachment,CompletionHandler)方法的特点 418
6.1.10 读取数据方式1 420
6.1.11 读取数据方式2 420
6.1.12 写入数据方式1 421
6.1.13 写入数据方式2 422
6.2 AsynchronousServerSocketChannel和AsynchronousSocketChannel类的使用 422
6.2.1 接受方式1 425
6.2.2 接受方式2 427
6.2.3 重复读与重复写出现异常 428
6.2.4 读数据 429
6.2.5 写数据 433
6.3 同步、异步、阻塞与非阻塞之间的关系 436
6.4 小结 437
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>NIO与Socket编程技术指南NIO，Socket，网络编程，并发编程，高并发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OpenResty完全开发指南
第0章  导读  1
0.1  关于本书  1
0.2  读者对象  1
0.3  读者要求  3
0.4  运行环境  3
0.5  本书的结构  3
0.6  如何阅读本书  5
0.7  本书的源码  5
第1章  总论  7
1.1  简介  7
1.2  历史  8
1.3  组成  9
1.4  版本  11
1.5  安装  12
1.5.1  直接安装  12
1.5.2  源码安装  13
1.5.3  定制安装  13
1.6  目录结构  14
1.7  启停服务  15
1.8  组件管理工具  15
1.9  命令行工具  16
1.10  参考手册  18
1.11  性能对比  18
1.12  应用架构  21
1.13  总结  22
第2章  Nginx平台  23
2.1  简介  23
2.2  进程模型  24
2.3  配置文件  25
2.4  变量  26
2.5  HTTP服务  27
2.5.1  server配置  28
2.5.2  location配置  28
2.6  TCP/UDP服务  29
2.7  反向代理  29
2.7.1  上游集群  30
2.7.2  代理转发  31
2.8  运行日志  31
2.8.1  访问日志  32
2.8.2  错误日志  32
2.9  总结  32
第3章  Lua语言  35
3.1  简介  35
3.2  注释  36
3.3  数据类型  36
3.4  字符串  37
3.5  变量  38
3.6  运算  39
3.6.1  算术运算  39
3.6.2  关系运算  39
3.6.3  逻辑运算  40
3.6.4  字符串运算  40
3.6.5  注意事项  41
3.7  控制语句  41
3.7.1  语句块  41
3.7.2  赋值语句  41
3.7.3  分支语句  42
3.7.4  循环语句  43
3.8  函数  44
3.8.1  定义函数  44
3.8.2  参数和返回值  45
3.9  表  46
3.9.1  定义表  46
3.9.2  操作表  46
3.9.3  范围循环  47
3.9.4  作为函数的参数  48
3.10  模块  48
3.11  面向对象  49
3.11.1  基本特性  49
3.11.2  原型模式  50
3.11.3  self参数  51
3.12  标准库  51
3.12.1  base库  52
3.12.2  package库  52
3.12.3  string库  53
3.12.4  table库  54
3.12.5  math库  55
3.12.6  io库  56
3.12.7  os库  57
3.12.8  debug库  57
3.12.9  使用技巧  57
3.13  高级特性  58
3.13.1  闭包  58
3.13.2  保护调用  58
3.13.3  可变参数  59
3.14  总结  59
第4章  LuaJIT环境  61
4.1  简介  61
4.2  goto语句  62
4.3  jit库  62
4.4  table库  63
4.5  bit库  63
4.6  ffi库  65
4.7  编译为字节码  67
4.8  编译为机器码  68
4.9  总结  68
第5章  开发概述  71
5.1  应用示例  71
5.1.1  编码实现  71
5.1.2  测试验证  73
5.2  运行命令  74
5.3  目录结构  75
5.4  配置指令  76
5.5  运行机制  77
5.5.1  处理阶段  77
5.5.2  执行程序  79
5.5.3  定时任务  81
5.5.4  流程图  81
5.6  功能接口  83
5.7  核心库  83
5.8  应用开发流程  84
5.9  总结  85
第6章  基础功能  87
6.1  系统信息  87
6.2  运行日志  88
6.3  时间日期  89
6.3.1  当前时间  90
6.3.2  时间戳  90
6.3.3  格式化时间戳  90
6.3.4  更新时间  91
6.3.5  睡眠  91
6.4  数据编码  92
6.4.1  Base64  92
6.4.2  JSON  92
6.4.3  MessagePack  94
6.5  正则表达式  95
6.5.1  配置指令  95
6.5.2  匹配选项  96
6.5.3  匹配  96
6.5.4  查找  98
6.5.5  替换  99
6.5.6  切分  100
6.6  高速缓存  101
6.6.1  创建缓存  101
6.6.2  使用缓存  102
6.7  总结  103
第7章  HTTP服务  105
7.1  简介  105
7.2  配置指令  106
7.3  常量  107
7.3.1  状态码  107
7.3.2  请求方法  108
7.4  变量  108
7.4.1  读变量  108
7.4.2  写变量  109
7.5  基本信息  110
7.5.1  请求来源  110
7.5.2  起始时间  110
7.5.3  请求头  110
7.5.4  暂存数据  111
7.6  请求行  111
7.6.1  版本  112
7.6.2  方法  112
7.6.3  地址  112
7.6.4  参数  113
7.7  请求头  114
7.7.1  读取数据  114
7.7.2  改写数据  115
7.8  请求体  115
7.8.1  丢弃数据  115
7.8.2  读取数据  115
7.8.3  改写数据  116
7.9  响应头  117
7.9.1  改写数据  117
7.9.2  发送数据  118
7.9.3  过滤数据  118
7.10  响应体  118
7.10.1  发送数据  118
7.10.2  过滤数据  119
7.11  手动收发数据  120
7.12  流程控制  121
7.12.1  重定向请求  121
7.12.2  终止请求  121
7.13  检测断连  122
7.14  综合示例  123
7.15  总结  126
第8章  访问后端  127
8.1  简介  127
8.2  子请求  128
8.2.1  接口说明  128
8.2.2  应用示例  129
8.2.3  使用建议  130
8.3  协程套接字  131
8.3.1  配置指令  131
8.3.2  创建对象  132
8.3.3  超时设置  133
8.3.4  建立连接  133
8.3.5  复用连接  134
8.3.6  关闭连接  134
8.3.7  发送数据  135
8.3.8  接收数据  135
8.3.9  应用示例  136
8.4  DNS客户端  137
8.4.1  创建对象  138
8.4.2  查询地址  138
8.4.3  缓存地址  139
8.5  HTTP客户端  140
8.5.1  创建对象  140
8.5.2  发送请求  140
8.6  WebSocket客户端  142
8.6.1  创建对象  142
8.6.2  建立连接  143
8.6.3  关闭连接  143
8.6.4  复用连接  143
8.6.5  发送数据  144
8.6.6  接收数据  144
8.7  Redis客户端  145
8.7.1  创建对象  145
8.7.2  建立连接  145
8.7.3  关闭连接  146
8.7.4  复用连接  146
8.7.5  执行命令  146
8.7.6  管道  147
8.7.7  脚本  148
8.8  MySQL客户端  148
8.8.1  创建对象  149
8.8.2  建立连接  149
8.8.3  服务器版本号  150
8.8.4  关闭连接  150
8.8.5  复用连接  150
8.8.6  简单查询  150
8.8.7  高级查询  152
8.8.8  防止SQL注入  152
8.9  总结  153
第9章  反向代理  155
9.1  简介  155
9.2  上游集群  156
9.2.1  静态服务器信息  157
9.2.2  动态服务器信息  158
9.2.3  服务器下线  159
9.2.4  当前上游集群  159
9.3  负载均衡  160
9.3.1  使用方式  160
9.3.2  功能接口  161
9.4  总结  162
第10章  高级功能  163
10.1  共享内存  163
10.1.1  配置指令  163
10.1.2  写操作  164
10.1.3  读操作  165
10.1.4  删除操作  166
10.1.5  计数操作  166
10.1.6  队列操作  166
10.1.7  过期操作  167
10.1.8  其他操作  168
10.2  定时器  168
10.2.1  配置指令  168
10.2.2  单次任务  169
10.2.3  周期任务  170
10.3  进程管理  171
10.3.1  进程类型  171
10.3.2  工作进程  172
10.3.3  监控进程  173
10.3.4  特权进程  173
10.4  轻量级线程  174
10.4.1  启动线程  175
10.4.2  等待线程  175
10.4.3  挂起线程  176
10.4.4  停止线程  177
10.4.5  信号量  178
10.5  总结  179
第11章  HTTPS服务  181
11.1  简介  181
11.1.1  密码学  181
11.1.2  网络协议  182
11.2  服务配置  184
11.3  应用开发  185
11.4  基本信息  185
11.4.1  协议版本号  185
11.4.2  主机名  186
11.4.3  地址  186
11.5  加载证书  187
11.5.1  清除证书  187
11.5.2  设置证书  187
11.5.3  设置私钥  188
11.5.4  测试验证  189
11.6  查验证书  189
11.6.1  发送查询  189
11.6.2  通知客户端  191
11.7  会话复用  191
11.7.1  Session ID  191
11.7.2  Session Tickets  193
11.8  总结  193
第12章  HTTP2服务  195
12.1  简介  195
12.2  服务配置  196
12.3  应用开发  197
12.4  测试验证  197
12.5  总结  198
第13章  Websocket服务  199
13.1  简介  199
13.2  服务配置  200
13.3  应用开发  200
13.4  总结  202
第14章  TCP/UDP服务  203
14.1  简介  203
14.2  配置指令  204
14.3  运行机制  205
14.3.1  处理阶段  205
14.3.2  执行程序  206
14.3.3  流程图  206
14.4  功能接口  208
14.5  应用示例  208
14.6  总结  210
第15章  结束语  211
附录A  推荐书目  215
附录B  定制OpenResty  217
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OpenResty完全开发指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java高并发编程详解
推荐序一
推荐序二
推荐序三
推荐序四
前言
第一部分 多线程基础
第1章 快速认识线程 3
1.1 线程的介绍 3
1.2 快速创建并启动一个线程 3
1.2.1 尝试并行运行 4
1.2.2 并发运行交替输出 5
1.2.3 使用Jconsole观察线程 6
1.3 线程的生命周期详解 7
1.3.1 线程的NEW状态 8
1.3.2 线程的RUNNABLE状态 8
1.3.3 线程的 RUNNING状态 8
1.3.4 线程的BLOCKED状态 8
1.3.5 线程的TERMINATED状态 9
1.4 线程的start方法剖析：模板设计模式在Thread中的应用 9
1.4.1 Thread start方法源码分析以及注意事项 9
1.4.2 模板设计模式在Thread中的应用 11
1.4.3 Thread模拟营业大厅叫号机程序 13
1.5 Runnable接口的引入以及策略模式在Thread中的使用 16
1.5.1 Runnable的职责 16
1.5.2 策略模式在Thread中的应用 16
1.5.3 模拟营业大厅叫号机程序 18
1.6 本章总结 19
第2章 深入理解Thread构造函数 20
2.1 线程的命名 20
2.1.1 线程的默认命名 21
2.1.2 命名线程 21
2.1.3 修改线程的名字 22
2.2 线程的父子关系 22
2.3 Thread与ThreadGroup 23
2.4 Thread与Runnable 24
2.5 Thread与JVM虚拟机栈 25
2.5.1 Thread与Stacksize 25
2.5.2 JVM内存结构 27
2.5.3 Thread与虚拟机栈 30
2.6 守护线程 33
2.6.1 什么是守护线程 33
2.6.2 守护线程的作用 34
2.7 本章总结 34
第3章 Thread API的详细介绍 35
3.1 线程sleep 35
3.1.1 sleep方法介绍 35
3.1.2 使用TimeUnit替代Thread.sleep 36
3.2 线程yield 37
3.2.1 yield方法介绍 37
3.2.2 yield和sleep 37
3.3 设置线程的优先级 38
3.3.1 线程优先级介绍 38
3.3.2 线程优先级源码分析 39
3.3.3 关于优先级的一些总结 40
3.4 获取线程ID 40
3.5 获取当前线程 41
3.6 设置线程上下文类加载器 41
3.7 线程interrupt 42
3.7.1 interrupt 42
3.7.2 isInterrupted 43
3.7.3 interrupted 45
3.7.4 interrupt注意事项 46
3.8 线程join 47
3.8.1 线程join方法详解 48
3.8.2 join方法结合实战 50
3.9 如何关闭一个线程 53
3.9.1 正常关闭 54
3.9.2 异常退出 56
3.9.3 进程假死 56
3.10 本章总结 58
第4章 线程安全与数据同步 59
4.1 数据同步 59
4.1.1 数据不一致问题的引入 59
4.1.2 数据不一致问题原因分析 61
4.2 初识 synchronized关键字 62
4.2.1 什么是synchronized 63
4.2.2 synchronized关键字的用法 63
4.3 深入synchronized关键字 65
4.3.1 线程堆栈分析 65
4.3.2 JVM指令分析 67
4.3.3 使用synchronized需要注意的问题 70
4.4 This Monitor和Class Monitor的详细介绍 72
4.4.1 this monitor 72
4.4.2 class monitor 74
4.5 程序死锁的原因以及如何诊断 77
4.5.1 程序死锁 77
4.5.2 程序死锁举例 77
4.5.3 死锁诊断 80
4.6 本章总结 81
第5章 线程间通信 82
5.1 同步阻塞与异步非阻塞 82
5.1.1 同步阻塞消息处理 82
5.1.2 异步非阻塞消息处理 83
5.2 单线程间通信 84
5.2.1 初识wait和notify 84
5.2.2 wait和notify方法详解 87
5.2.3 关于wait和notify的注意事项 89
5.2.4 wait和sleep 90
5.3 多线程间通信 90
5.3.1 生产者消费者 90
5.3.2 线程休息室wait set 93
5.4 自定义显式锁BooleanLock 94
5.4.1 synchronized关键字的缺陷 94
5.4.2 显式锁BooleanLock 95
5.5 本章总结 104
第6章 ThreadGroup详细讲解 105
6.1 ThreadGroup与Thread 105
6.2 创建ThreadGroup 105
6.3 复制Thread数组和ThreadGroup数组 106
6.3.1 复制Thread数组 106
6.3.2 复制ThreadGroup数组 109
6.4 ThreadGroup操作 109
6.4.1 ThreadGroup的基本操作 110
6.4.2 ThreadGroup的interrupt 113
6.4.3 ThreadGroup的destroy 114
6.4.4 守护ThreadGroup 115
6.5 本章总结 116
第7章 Hook线程以及捕获线程执行异常 117
7.1 获取线程运行时异常 117
7.1.1 UncaughtExceptionHandler的介绍 117
7.1.2 UncaughtExceptionHandler实例 118
7.1.3 UncaughtExceptionHandler源码分析 119
7.2 注入钩子线程 121
7.2.1 Hook线程介绍 121
7.2.2 Hook线程实战 122
7.2.3 Hook线程应用场景以及注意事项 124
7.3 本章总结 124
第8章 线程池原理以及自定义线程池 125
8.1 线程池原理 125
8.2 线程池实现 126
8.2.1 线程池接口定义 127
8.2.2 线程池详细实现 131
8.3 线程池的应用 139
8.4 本章总结 142
第二部分 Java ClassLoader
第9章 类的加载过程 144
9.1 类的加载过程简介 144
9.2 类的主动使用和被动使用 145
9.3 类的加载过程详解 148
9.3.1 类的加载阶段 148
9.3.2 类的连接阶段 149
9.3.3 类的初始化阶段 154
9.4 本章总结 156
第10章 JVM类加载器 158
10.1 JVM内置三大类加载器 158
10.1.1 根类加载器介绍 159
10.1.2 扩展类加载器介绍 159
10.1.3 系统类加载器介绍 160
10.2 自定义类加载器 161
10.2.1 自定义类加载器，问候世界 161
10.2.2 双亲委托机制详细介绍 165
10.2.3 破坏双亲委托机制 167
10.2.4 类加载器命名空间、运行时包、类的卸载等 170
10.3 本章总结 175
第11章 线程上下文类加载器 177
11.1 为什么需要线程上下文类加载器 177
11.2 数据库驱动的初始化源码分析 178
11.3 本章总结 180
第三部分 深入理解volatile关键字
第12章 volatile关键字的介绍 182
12.1 初识volatile关键字 182
12.2 机器硬件CPU 184
12.2.1 CPU Cache模型 184
12.2.2 CPU缓存一致性问题 186
12.3 Java内存模型 187
12.4 本章总结 188
第13章 深入volatile关键字 189
13.1 并发编程的三个重要特性 189
13.1.1 原子性 189
13.1.2 可见性 190
13.1.3 有序性 190
13.2 JMM如何保证三大特性 191
13.2.1 JMM与原子性 192
13.2.2 JMM与可见性 193
13.2.3 JMM与有序性 194
13.3 volatile关键字深入解析 195
13.3.1 volatile关键字的语义 195
13.3.2 volatile的原理和实现机制 197
13.3.3 volatile的使用场景 198
13.3.4 volatile和synchronized 199
13.4 本章总结 200
第14章 7种单例设计模式的设计 201
14.1 饿汉式 201
14.2 懒汉式 202
14.3 懒汉式+同步方法 203
14.4 Double-Check 204
14.5 Volatile+Double-Check 206
14.6 Holder方式 206
14.7 枚举方式 207
14.8 本章总结 208
第四部分 多线程设计架构模式
第15章 监控任务的生命周期 212
15.1 场景描述 212
15.2 当观察者模式遇到Thread 212
15.2.1 接口定义 212
15.2.2 ObservableThread实现 215
15.3 本章总结 217
15.3.1 测试运行 217
15.3.2 关键点总结 219
第16章 Single Thread Execution设计模式 220
16.1 机场过安检 220
16.1.1 非线程安全 221
16.1.2 问题分析 223
16.1.3 线程安全 225
16.2 吃面问题 225
16.2.1 吃面引起的死锁 226
16.2.2 解决吃面引起的死锁问题 228
16.2.3 哲学家吃面 229
16.3 本章总结 230
第17章 读写锁分离设计模式 231
17.1 场景描述 231
17.2 读写分离程序设计 232
17.2.1 接口定义 232
17.2.2 程序实现 234
17.3 读写锁的使用 239
17.4 本章总结 242
第18章 不可变对象设计模式 244
18.1 线程安全性 244
18.2 不可变对象的设计 244
18.2.1 非线程安全的累加器 245
18.2.2 方法同步增加线程安全性 247
18.2.3 不可变的累加器对象设计 248
18.3 本章总结 249
第19章 Future设计模式 251
19.1 先给你一张凭据 251
19.2 Future设计模式实现 251
19.2.1 接口定义 252
19.2.2 程序实现 253
19.3 Future的使用以及技巧总结 256
19.4 增强FutureService使其支持回调 257
19.5 本章总结 258
第20章 Guarded Suspension设计模式 259
20.1 什么是Guarded Suspension设计模式 259
20.2 Guarded Suspension的示例 259
20.3 本章总结 261
第21章 线程上下文设计模式 262
21.1 什么是上下文 262
21.2 线程上下文设计 263
21.3 ThreadLocal详解 264
21.3.1 ThreadLocal的使用场景及注意事项 265
21.3.2 ThreadLocal的方法详解及源码分析 265
21.3.3 ThreadLocal的内存泄漏问题分析 270
21.4 使用ThreadLocal设计线程上下文 274
21.5 本章总结 276
第22章 Balking设计模式 277
22.1 什么是Balking设计 277
22.2 Balking模式之文档编辑 278
22.2.1 Document 278
22.2.2 AutoSaveThread 280
22.2.3 DocumentEditThread 281
22.3 本章总结 283
第23章 Latch设计模式 284
23.1 什么是Latch 284
23.2 CountDownLatch程序实现 285
23.2.1 无限等待的Latch 285
23.2.2 有超时设置的Latch 289
23.3 本章总结 291
第24章 Thread-Per-Message设计模式 293
24.1 什么是Thread-Per-Message模式 293
24.2 每个任务一个线程 293
24.3 多用户的网络聊天 296
24.3.1 服务端程序 296
24.3.2 响应客户端连接的Handler 297
24.3.3 聊天程序测试 299
24.4 本章总结 300
第25章 Two Phase Termination设计模式 301
25.1 什么是Two Phase Termination模式 301
25.2 Two Phase Termination的示例 302
25.2.1 线程停止的Two Phase Termination 302
25.2.2 进程关闭的Two Phase Termination 303
25.3 知识扩展 304
25.3.1 Strong Reference及LRUCache 304
25.3.2 Soft Reference及SoftLRUCache 308
25.3.3 Weak Reference 311
25.3.4 Phantom Reference 312
25.4 本章总结 314
第26章 Worker-Thread设计模式 315
26.1 什么是Worker-Thread模式 315
26.2 Worker-Thread模式实现 315
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java高并发编程详解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Erlang/OTP并发编程实战
目　　录

第一部分　Erlang起步：OTP基础
第1章　Erlang/OTP平台	2
1.1　基于进程的并发编程	3
1.1.1　理解并发	3
1.1.2　Erlang的进程模型	4
1.1.3　4种进程通信范式	5
1.1.4　用Erlang进程编程	8
1.2　Erlang的容错架构	10
1.2.1　进程链接如何工作	10
1.2.2　监督与退出信号捕捉	10
1.2.3　进程的分层容错	12
1.3　分布式Erlang	13
1.4　Erlang运行时系统和虚拟机	13
1.4.1　调度器	14
1.4.2　I/O与调度	15
1.4.3　进程隔离与垃圾回收器	15
1.5　函数式编程：Erlang的处世之道	16
1.6　小结	16
第2章　Erlang语言精要	18
2.1　Erlang shell	19
2.1.1　启动shell	19
2.1.2　输入表达式	20
2.1.3　shell函数	21
2.1.4　退出shell	21
2.1.5　任务控制基础	22
2.2　Erlang的数据类型	23
2.2.1　数值与算术运算	24
2.2.2　二进制串与位串	25
2.2.3　原子	26
2.2.4　元组	27
2.2.5　列表	27
2.2.6　字符串	28
2.2.7　pid、端口和引用	29
2.2.8　将函数视作数据：fun函数	30
2.2.9　项式的比较	30
2.2.10　解读列表	31
2.3　模块和函数	33
2.3.1　调用其他模块中的函数（远程调用）	33
2.3.2　不同元数的函数	34
2.3.3　内置函数和标准库模块	34
2.3.4　创建模块	35
2.3.5　模块的编译和加载	36
2.3.6　独立编译器erlc	37
2.3.7　已编译模块与在shell中求值	37
2.4　变量与模式匹配	38
2.4.1　变量的语法	39
2.4.2　单次赋值	39
2.4.3　模式匹配：加强版的赋值	41
2.4.4　解读模式	42
2.5　函数与子句	44
2.5.1　带副作用的函数：文本打印	44
2.5.2　用模式匹配在多个子句中进行选择	45
2.5.3　保护式	46
2.5.4　模式、子句和变量作用域	47
2.6　Case和if表达式	48
2.6.1　Erlang的布尔型if-then-else
分支选择	48
2.6.2　If表达式	49
2.7　fun函数	49
2.7.1　作为现有函数别名的fun函数	49
2.7.2　匿名fun函数	50
2.8　异常与try/catch	52
2.8.1　抛出（触发）异常	52
2.8.2　运用try...catch	53
2.8.3　try...of...catch	53
2.8.4　after	54
2.8.5　获取栈轨迹	54
2.8.6　重抛异常	55
2.8.7　传统的catch	55
2.9　列表速构	56
2.9.1　列表速构记法	56
2.9.2　映射、过滤和模式匹配	56
2.10　比特位语法与位串速构	57
2.10.1　构造位串	57
2.10.2　比特位语法中的模式匹配	58
2.10.3　位串速构	59
2.11　记录语法	59
2.11.1　记录声明	60
2.11.2　创建记录	60
2.11.3　记录的字段以及模式匹配	60
2.11.4　更新记录字段	60
2.11.5　记录声明应该放在哪儿	61
2.12　预处理与文件包含	61
2.12.1　宏的定义和使用	61
2.12.2　文件包含	62
2.12.3　条件编译	63
2.13　进程	64
2.13.1　操纵进程	64
2.13.2　消息接收与选择性接收	65
2.13.3　注册进程	66
2.13.4　消息投递与信号	67
2.13.5　进程字典	67
2.14　ETS表	68
2.14.1　为何ETS表被设计成这样	68
2.14.2　ETS表的基本用法	68
2.15　以递归代替循环	69
2.15.1　从迭代到递归	69
2.15.2　理解尾递归	71
2.15.3　累加器参数	72
2.15.4　谈谈效率	72
2.15.5　编写递归函数的窍门	73
2.16　Erlang编程资源	78
2.16.1　图书	78
2.16.2　在线资料	79
2.17　小结	79
第3章　开发基于TCP的RPC服务	80
3.1　你所创建的是什么	81
3.1.1　基础知识提醒	82
3.1.2　行为模式基础	82
3.2　实现RPC服务器	85
3.2.1　行为模式实现模块的典型布局	85
3.2.2　模块首部	85
3.2.3　API段	88
3.2.4　回调函数段	92
3.3　运行RPC服务器	98
3.4　浅谈测试	99
3.5　小结	100
第4章　OTP应用与监督机制	101
4.1　OTP应用	101
4.1.1　OTP应用的组织形式	102
4.1.2　为应用添加元数据	103
4.1.3　应用行为模式	104
4.1.4　应用结构小结	105
4.2　用监督者实现容错	105
4.2.1　实现监督者	106
4.2.2　监督者重启策略	107
4.2.3　编写子进程规范	108
4.3　启动应用	109
4.4　生成EDoc文档	110
4.5　小结	110
第5章　主要图形化监测工具的使用	112
5.1　Appmon	112
5.1.1　Appmon GUI	112
5.1.2　WebTool版Appmon	115
5.2　Pman	116
5.3　调试器	118
5.4　表查看器TV	121
5.5　工具栏	123
5.6　小结	123
第二部分　构建生产系统
第6章　打造一套缓存系统	126
6.1　故事背景	126
6.2　缓存的设计	127
6.3　创建OTP应用的基本骨架	130
6.3.1　应用目录结构的布局	130
6.3.2　创建应用元数据	130
6.3.3　实现应用行为模式	131
6.3.4　实现监督者	131
6.4　从应用骨架到五脏俱全的缓存	133
6.4.1　编写sc_element进程	134
6.4.2　实现sc_store模块	138
6.4.3　打造应用层API模块	142
6.5　小结	144
第7章　Erlang/OTP中的日志与事件
处理	145
7.1　Erlang/OTP中的日志	146
7.1.1　日志概述	146
7.1.2　Erlang/OTP内置的日志设施	147
7.1.3　标准日志函数	147
7.1.4　SASL与崩溃报告	149
7.2　用gen_event编写自定义事件
处理器	153
7.2.1　gen_event行为模式简介	153
7.2.2　事件处理器示例	154
7.2.3　处理错误事件	155
7.3　为Simple Cache添加自定义事件流	157
7.3.1　事件流API	157
7.3.2　将处理器整合进Simple Cache	159
7.3.3　订阅自定义事件流	161
7.4　小结	162
第8章　分布式Erlang/OTP简介	163
8.1　Erlang分布式基础	163
8.1.1　复制式进程间通信	164
8.1.2　位置透明性	165
8.2　节点与集群	166
8.2.1　节点的启动	166
8.2.2　节点的互联	167
8.2.3　Erlang节点如何定位其他节点并与之建立通信	169
8.2.4　magic cookie安全系统	170
8.2.5　互联节点间的消息传递	171
8.2.6　使用远程shell	173
8.3　资源探测攻略	175
8.3.1　术语	175
8.3.2　算法	176
8.3.3　实现资源探测应用	177
8.4　小结	182
第9章　用Mnesia为cache增加分布
式支持	183
9.1　分布式缓存	184
9.1.1　选取通信策略	184
9.1.2　同步缓存和异步缓存	186
9.1.3　分布式表	188
9.2　用Mnesia实现分布式数据存储	189
9.2.1　建立项目数据库	189
9.2.2　初始化数据库	191
9.2.3　建表	192
9.2.4　向表中录入数据	195
9.2.5　执行基本查询	197
9.3　基于Mnesia的分布式缓存	199
9.3.1　用Mnesia取代ETS	199
9.3.2　让缓存识别出其他节点	202
9.3.3　用资源探测定位其他缓存
实例	205
9.3.4　动态复制Mnesia表	206
9.4　小结	209
第10章　打包、服务和部署	210
10.1　从系统的角度看应用	210
10.1.1　结构	211
10.1.2　元数据	211
10.1.3　系统如何管理运行中的
应用	212
10.2　制作发布镜像	213
10.2.1　发布镜像	213
10.2.2　准备发布代码	214
10.2.3　发布镜像的元数据文件	214
10.2.4　脚本与启动文件	216
10.2.5　系统配置	217
10.2.6　启动目标系统	218
10.3　发布镜像打包	219
10.3.1　创建发布镜像包	219
10.3.2　发布镜像包的内容	220
10.3.3　定制发布镜像包	222
10.4　安装发布镜像	223
10.5　小结	223
第三部分　集成与完善
第11章　为缓存添加HTTP接口	226
11.1　实现TCP服务器	226
11.1.1　高效TCP服务器的设计
模式	227
11.1.2　搭建tcp_interface应用的
骨架	228
11.1.3　填充TCP服务器的实现
逻辑	228
11.1.4　简单文本协议	231
11.1.5　文本接口实现	232
11.2　打造一套全新的Web接口	234
11.2.1　HTTP简介	234
11.2.2　实现一套通用的Web服务
器行为模式	237
11.2.3　初识REST	248
11.2.4　用gen_web_server实现
REST式协议	249
11.3　小结	252
第12章　用端口和NIF集成外围代码	253
12.1　端口和NIF	254
12.1.1　普通端口	255
12.1.2　链入式端口驱动	256
12.1.3　原生函数（NIF）	257
12.2　用端口来集成解析器	257
12.2.1　Erlang方面的端口	257
12.2.2　C方面的端口	260
12.2.3　编译运行	271
12.3　开发链入式驱动	272
12.3.1　初识链入式驱动	273
12.3.2　驱动的C语言部分	274
12.3.3　编译驱动代码	278
12.3.4　驱动的Erlang部分	279
12.4　将解析器实现为NIF	280
12.4.1　NIF的Erlang部分	280
12.4.2　NIF的C代码部分	281
12.4.3　编译与运行代码	287
12.5　小结	288
第13章　用Jinterface实现Erlang和
Java间的通信	289
13.1　利用Jinterface在Erlang中集成
Java	290
13.1.1　OtpNode类	290
13.1.2　OtpMbox类	291
13.1.3　Erlang数据结构的Java
映射	291
13.1.4　示例：Java中的消息处理	292
13.1.5　在Erlang中与Java节点
通信	294
13.2　安装和配置HBase	296
13.2.1　下载和安装	296
13.2.2　配置HBase	296
13.3　为Simple Cache和HBase牵线
搭桥	297
13.3.1　Erlang方面：sc_hbase.erl	298
13.3.2　HBaseConnector类	299
13.3.3　Java中的消息处理	301
13.3.4　HBaseTask类	304
13.4　在Simple Cache中整合HBase	306
13.4.1　查询	306
13.4.2　插入	307
13.4.3　删除	307
13.5　运行集成系统	308
13.6　小结	310
第14章　优化与性能	311
14.1　如何进行性能调优	312
14.1.1　设定性能目标	312
14.1.2　设定基线	313
14.1.3　系统性能分析	313
14.1.4　确定需要解决的问题	313
14.1.5　测定优化成果	313
14.2　Erlang代码性能分析	314
14.2.1　用cprof计算调用次数	314
14.2.2　用fprof测定执行时间	316
14.3　Erlang编程语言的缺陷	320
14.3.1　基本数据类型的性能特点	321
14.3.2　内置函数和运算符的性能	324
14.3.3　函数	325
14.3.4　进程	327
14.4　小结	329
附录A　安装Erlang	330
附录B　列表与引用透明性	332

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Erlang/OTP并发编程实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Windows并发编程指南
对本书的赞誉
译着序
序
前言
致谢
作者简介
第一部分 概念
第1章 概述
1.1 为什么需要并发
1.2 程序架构与并发
1.3 并行的层次
1.4 为什么不需要并发
1.5 小结
延伸阅读
第2章 同步与时间
2.1 程序状态的管理
2.1.1 共享状态与私有状态的区分
2.1.2 状态机与时间
2.1.3 独立性
2.1.4 不变性
2.2 同步：种类与实现技术
2.2.1 数据同步
2.2.2 协作与控制同步
2.3 小结
延伸阅读
第二部分 机制
第3章 线程
3.1 从高层面上来看线程
3.1.1 Windows线程是什么
3.1.2 CLR线程是什么
3.1.3 显式线程操作及其替代方法
3.2 线程的诞生与消亡
3.2.1 线程的创建
3.2.2 线程终止
3.2.3 DllMain
3.2.4 线程局部存储
3.3 小结
延伸阅读
第4章 线程的高级内容
4.1 线程的状态
4.1.1 用户态线程栈
4.1.2 内部数据结构（KTHREAD、ETHREAD和TEB）
4.1.3 上下文
4.2 线程的创建过程与终止过程
4.2.1 线程创建的具体流程
4.2.2 线程终止的具体流程
4.3 线程调度
4.3.1 线程的状态
4.3.2 优先级
4.3.3 时间片
4.3.4 优先级与时间片调整
4.3.5 睡眠与退让
4.3.6 挂起
4.3.7 关联性：优先在某个CPU上运行
4.4 小结
延伸阅读
第5章 Windows内核同步机制
5.1 基础知识：触发和等待
5.1.1 为什么要使用内核对象
5.1.2 在非托管代码中执行等待操作
5.1.3 托管代码
5.1.4 异步过程调用
5.2 内核对象的使用
5.2.1 互斥体
5.2.2 信号量
5.2.3 互斥体/信号量使用示例：阻塞/有界的队列
5.2.4 自动重置事件和手动重置事件
5.2.5 等待定时器
5.2.6 触发对象与自动等待
5.2.7 内核对象的调试
5.3 小结
延伸阅读
第6章 数据同步与控制同步
6.1 互斥
6.1.1 Win32临界区
6.1.2 CLR锁
6.2 读/写锁（RWL）
6.2.1 WindowsVista中的轻量级读/写锁
6.2.2.NEI框架中的轻量级读/写锁
6.2.3.NET框架中原来的读/写锁
6.3 条件变量
6.3.1 WindowsVista条件变量
6.3.2.NET框架的Monitor
6.3.3 被守护区域
6.4 小结
延伸阅读
第7章 线程池
7.1 线程池的基本知识
7.1.1 三种方式：WindowsVista、Windows遗留代码以及CLR
7.1.2 通用功能
7.2 Windows线程池
7.2.1 WindowsVista线程池
7.2.2 遗留的Win32线程池
7.3 CLR线程池
7.3.1 工作项
7.3.2 I/O完成端口
7.3.3 定时器
7.3.4 注册等待
7.3.5 记住（再次提醒）：你并不拥有这些线程
7.3.6 线程池的线程管理
7.3.7 调试
7.3.8 案例分析：优先级分层以及在线程池之上的隔离性
7.4 在使用线程池时的性能
7.5 小结
延伸阅读
第8章 异步编程模型
8.1 异步编程模型（APM）
8.1.1 汇集：四种方式
8.1.2 实现IAsyncResult
8.1.3 在.NET框架的哪些地方使用了APM
8.1.4 ASP.NET异步页
8.2 基于事件的异步模式
8.2.1 基础知识
8.2.2 支持取消
8.2.3 支持进度报告以及增量结果
8.2.4 在.NET框架的哪些地方将使用EAP
8.3 小结
延伸阅读
第9章 纤程
9.1 纤程简介优点与缺点
9.2 纤程的使用
9.2.1 创建新的纤程
9.2.2 将线程转换为纤程
9.2.3 判断线程是否为纤程
9.2.4 纤程间的切换
9.2.5 删除纤程
9.2.6 切换当前线程的示例
9.3 与纤程相关的其他主题
9.3.1 纤程局部存储
9.3.2 线程关联性
9.3.3 案例分析：纤程与CLR
9.4 构建用户态的调度器
9.4.1 实现
9.4.2 关于栈阻塞与无栈阻塞
9.5 小结
延伸阅读
第三部分 技术
第10章 内存模型与无锁编程
10.1 内存加载与存储等操作的重新排序
10.1.1 实际运行的顺序并非总是编写的顺序
10.1.2 将临界域作为栅栏
10.1.3 数据依赖性及其对重排的影响
10.2 硬件原子性
10.2.1 普通加载指令和存储指令的原子性
10.2.2 互锁操作
10.3 内存一致性模型
10.3.1 硬件内存模型
10.3.2 内存栅栏
10.3.3.NET内存模型
10.3.4 无锁编程
10.4 低锁代码的示例
10.4.1 延迟初始化与双重检查锁定
10.4.2 无阻塞栈和ABA问题
10.4.3 重新回顾Dekker的算法
10.5 小结
延伸阅读
第11章 并发的危害
11.1 正确性危害
11.1.1 数据竞争
11.1.2 递归与重入
11.1.3 锁与进程关闭
11.2 活跃性危害
11.2.1 死锁
11.2.2 遗失的唤醒
11.2.3 活锁
11.2.4 锁护送效应
11.2.5 “蜂拥”现象
11.2.6 两步舞
11.2.7 优先级反转与饥饿
11.3 小结
延伸阅读
第12章 并行容器
12.1 细粒度锁定
12.1.1 数组
12.1.2 FIFO队列
12.1.3 链表
12.1.4 字典（散列表）
12.2 无锁
12.2.1 无锁FIFO队列
12.2.2 工作密迁队列
12.3 协作式容器
12.3.1 生产者/消费者数据结构
12.3.2 通过栅栏来分阶段计算
12.4 小结
延伸阅读
第13章 数据并行与任务并行
13.1 数据并行
13.2 任务并行
13.2.1 分支/合并算法
13.2.2 数据流并行（Future抽象与Promise抽象）
13.2.3 递归
13.2.4 流水线
13.2.5 查找
13.3 基于消息的并行
13.4 一些共同问题
13.4.1 并发的异常
13.4.2 取消
13.5 小结
延伸阅读
第14章 性能与可伸缩性
14.1 并行硬件架构
14.1.1 SMP、CMP与HT
14.1.2 超标量执行
14.1.3 内存的层次结构
14.1.4 Visual Studio中的性能分析工具
14.2 加速比：并行代码与串行代码
14.2.1 决定“采用并行”
14.2.2 测量并行带来的性能提升
14.2.3 Amdahl定律
12.2.4 关键路径以及负载不均衡
14.2.5 垃圾收集与可伸缩性
14.3 自旋等待
14.3.1 如何在Windows上正确地自旋
14.3.2 纯自旋锁
14.3.3 Mellor-Crummey-Scott（MCS）锁
14.4 小结
延伸阅读
第四部分 系统
第15章 输入与输出
15.1 重叠I/O
15.1.1 重叠对象
15.1.2 Win32异步：I/O
15.1.3 .NET框架的异步I/O
15.2 I/O取消
15.2.1 当前线程的异步I/O取消
15.2.2 其他线程上的同步I/O取消
15.2.3 任意线程的异步I/O取消
15.3 小结
延伸阅读
第16章 图形用户界面
16.1 GUI线程模型
16.1.1 单线程套间（STA）
16.1.2 响应度：它是什么
16.2.NET异步GUI功能
16.2.1.NET的GUI框架
16.2.2 同步上下文
16.2.3 异步操作
16.2.4 一个方便的类：BackgroundWorker
16.3 小结
延伸阅读
第五部分 附录
附录A 为.NET并发程序设计可重用的库
附录B .NET的并行扩展
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Windows并发编程指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解并行编程
第1章  如何使用本书	1
1.1  路线图	1
1.2  小问题	2
1.3　除本书之外的选择	3
1.4  示例源代码	4
1.5  这本书属于谁	4
第2章  简介	6
2.1  导致并行编程困难的历史原因	6
2.2  并行编程的目标	7
2.2.1  性能	8
2.2.2  生产率	9
2.2.3  通用性	9
2.3  并行编程的替代方案	11
2.3.1  串行应用的多个实例	11
2.3.2  使用现有的并行软件	11
2.3.3  性能优化	12
2.4  是什么使并行编程变得复杂	12
2.4.1  分割任务	13
2.4.2  并行访问控制	13
2.4.3  资源分割和复制	14
2.4.4  与硬件的交互	14
2.4.5  组合使用	14
2.4.6  语言和环境如何支持这些任务	14
2.5  本章的讨论	15
第3章  硬件和它的习惯	16
3.1  概述	16
3.1.1  流水线CPU	16
3.1.2  内存引用	17
3.1.3  原子操作	18
3.1.4  内存屏障	19
3.1.5  高速缓存未命中	19
3.1.6  I/O操作	19
3.2  开销	20
3.2.1  硬件体系结构	20
3.2.2  操作的开销	21
3.3  硬件的免费午餐	23
3.3.1  3D集成	23
3.3.2  新材料和新工艺	24
3.3.3  是光，不是电子	24
3.3.4  专用加速器	24
3.3.5  现有的并行软件	25
3.4  对软件设计的启示	25
第4章  办事的家伙	27
4.1  脚本语言	27
4.2  POSIX多进程	28
4.2.1  POSIX进程创建和销毁	28
4.2.2  POSIX线程创建和销毁	30
4.2.3  POSIX锁	31
4.2.4  POSIX读/写锁	34
4.3  原子操作	37
4.4  Linux内核中类似POSIX的操作	38
4.5  如何选择趁手的工具	39
第5章  计数	40
5.1  为什么并发计数不可小看	41
5.2  统计计数器	42
5.2.1  设计	43
5.2.2  基于数组的实现	43
5.2.3  最终结果一致的实现	44
5.2.4  基于每线程变量的实现	46
5.2.5  本节讨论	48
5.3  近似上限计数器	48
5.3.1  设计	48
5.3.2  简单的上限计数实现	50
5.3.3  关于简单上限计数的讨论	55
5.3.4  近似上限计数器的实现	55
5.3.5  关于近似上限计数器的讨论	55
5.4  精确上限计数	56
5.4.1  原子上限计数的实现	56
5.4.2  关于原子上限计数的讨论	62
5.4.3  Signal-Theft上限计数的设计	62
5.4.4  Signal-Theft上限计数的实现	63
5.4.5  关于Signal-Theft上限计数的讨论	68
5.5  特殊场合的并行计数	68
5.6  关于并行计数的讨论	69
5.6.1  并行计数的性能	70
5.6.2  并行计数的专门化	71
5.6.3  从并行计数中学到什么	71
第6章  对分割和同步的设计	73
6.1  分割练习	73
6.1.1  哲学家就餐问题	73
6.1.2  双端队列	75
6.1.3  关于分割问题示例的讨论	81
6.2  设计准则	82
6.3  同步粒度	83
6.3.1  串行程序	84
6.3.2  代码锁	85
6.3.3  数据锁	86
6.3.4  数据所有权	88
6.3.5  锁粒度与性能	88
6.4  并行快速路径	90
6.4.1  读/写锁	91
6.4.2  层次锁	91
6.4.3  资源分配器缓存	92
6.5  分割之外	97
6.5.1  使用工作队列的迷宫问题并行解法	97
6.5.2  另一种迷宫问题的并行解法	100
6.5.3  性能比较I	102
6.5.4  另一种迷宫问题的串行解法	104
6.5.5  性能比较II	104
6.5.6  未来展望与本节总结	105
6.6  分割、并行化与优化	106
第7章  锁	107
7.1  努力活着	108
7.1.1  死锁	108
7.1.2  活锁与饥饿	114
7.1.3  不公平的锁	116
7.1.4  低效率的锁	117
7.2  锁的类型	117
7.2.1  互斥锁	117
7.2.2  读/写锁	118
7.2.3  读/写锁之外	118
7.2.4  范围锁	119
7.3  锁在实现中的问题	121
7.3.1  基于原子交换的互斥锁实现示例	121
7.3.2  互斥锁的其他实现	122
7.4  基于锁的存在保证	124
7.5  锁：是英雄还是恶棍	125
7.5.1  应用程序中的锁：英雄	125
7.5.2  并行库中的锁：只是一个工具	126
7.5.3  并行化串行库时的锁：恶棍	128
7.6  总结	130
第8章  数据所有权	131
8.1  多进程	131
8.2  部分数据所有权和pthread线程库	132
8.3  函数输送	132
8.4  指派线程	132
8.5  私有化	133
8.6  数据所有权的其他用途	133
第9章  延后处理	134
9.1  引用计数	134
9.1.1  各种引用计数的实现	135
9.1.2  危险指针	140
9.1.3  支持引用计数的Linux原语	141
9.1.4  计数优化	142
9.2  顺序锁	142
9.3  读-复制-修改（RCU）	145
9.3.1  RCU介绍	145
9.3.2  RCU基础	147
9.3.3  RCU用法	155
9.3.4  Linux内核中的RCU API	166
9.3.5  “玩具式”的RCU实现	171
9.3.6  RCU练习	188
9.4  如何选择？	188
9.5  更新端怎么办	190
第10章  数据结构	191
10.1  从例子入手	191
10.2  可分割的数据结构	192
10.2.1  哈希表的设计	192
10.2.2  哈希表的实现	192
10.2.3  哈希表的性能	195
10.3  读侧重的数据结构	197
10.3.1  受RCU保护的哈希表的实现	197
10.3.2  受RCU保护的哈希表的性能	199
10.3.3  对受RCU保护的哈希表的讨论	201
10.4  不可分割的数据结构	201
10.4.1  可扩展哈希表的设计	202
10.4.2  可扩展哈希表的实现	203
10.4.3  可扩展哈希表的讨论	210
10.4.4  其他可扩展的哈希表	211
10.5  其他数据结构	214
10.6  微优化	214
10.6.1  实例化	215
10.6.2  比特与字节	215
10.6.3  硬件层面的考虑	216
10.7  总结	217
第11章  验证	218
11.1  简介	218
11.1.1  BUG来自于何处	218
11.1.2  所需的心态	220
11.1.3  应该何时开始验证	221
11.1.4  开源之路	221
11.2  跟踪	222
11.3  断言	223
11.4  静态分析	224
11.5  代码走查	224
11.5.1  审查	224
11.5.2  走查	225
11.5.3  自查	225
11.6  几率及海森堡BUG	227
11.6.1  离散测试统计	228
11.6.2  滥用离散测试统计	229
11.6.3  持续测试统计	229
11.6.4  定位海森堡BUG	232
11.7  性能评估	235
11.7.1  性能基准	236
11.7.2  剖析	236
11.7.3  差分分析	237
11.7.4  微基准	237
11.7.5  隔离	237
11.7.6  检测干扰	238
11.8  总结	242
第12章  形式验证	244
12.1  通用目的的状态空间搜索	244
12.1.1  Promela和Spin	244
12.1.2  如何使用 Promela	249
12.1.3  Promela 示例: 锁	251
12.1.4  Promela 示例: QRCU	254
12.1.5  Promela初试牛刀：dynticks和可抢占RCU	260
12.1.6  验证可抢占RCU和dynticks	264
12.2  特定目的的状态空间搜索	288
12.2.1  解析Litmus测试	289
12.2.2  Litmus测试意味着什么	290
12.2.3  运行Litmus测试	291
12.2.4  PPCMEM讨论	292
12.3  公理方法	293
12.4  SAT求解器	294
12.5  总结	295
第13章  综合应用	296
13.1  计数难题	296
13.1.1  对更新进行计数	296
13.1.2  对查找进行计数	296
13.2  使用RCU拯救并行软件性能	297
13.2.1  RCU和基于每CPU变量的统计计数	297
13.2.2  RCU及可插拔I/O设备的计数器	300
13.2.3  数组及长度	300
13.2.4  相关联的字段	301
13.3  散列难题	302
13.3.1  相关联的数据元素	302
13.3.2  更新友好的哈希表遍历	303
第14章  高级同步	304
14.1  避免锁	304
14.2  内存屏障	304
14.2.1  内存序及内存屏障	305
14.2.2  如果B在A后面，并且C在B后面，为什么C不在A后面	306
14.2.3  变量可以拥有多个值	307
14.2.4  能信任什么东西	308
14.2.5  锁实现回顾	312
14.2.6  一些简单的规则	313
14.2.7  抽象内存访问模型	314
14.2.8  设备操作	315
14.2.9  保证	315
14.2.10  什么是内存屏障	316
14.2.11  锁约束	325
14.2.12  内存屏障示例	326
14.2.13  CPU缓存的影响	328
14.2.14  哪里需要内存屏障	329
14.3  非阻塞同步	329
14.3.1  简单NBS	330
14.3.2  NBS讨论	331
第15章  并行实时计算	332
15.1  什么是实时计算	332
15.1.1  软实时	332
15.1.2  硬实时	333
15.1.3  现实世界的实时	334
15.2  谁需要实时计算	336
15.3  谁需要并行实时计算	337
15.4  实现并行实时系统	337
15.4.1  实现并行实时操作系统	339
15.4.2  实现并行实时应用	349
15.5  实时VS.快速：如何选择	351
第16章  易于使用	353
16.1  简单是什么	353
16.2  API设计的Rusty准则	353
16.3  修整Mandelbrot集合	354
第17章  未来的冲突	357
17.1  曾经的CPU技术不代表未来	357
17.1.1  单处理器Uber Alles	358
17.1.2  多线程Mania	359
17.1.3  更多类似的场景	359
17.1.4  撞上内存墙	359
17.2  事务内存	360
17.2.1  外部世界	361
17.2.2  进程修改	364
17.2.3  同步	367
17.2.4  讨论	370
17.3  硬件事务内存	371
17.3.1  HTM与锁相比的优势	372
17.3.2  HTM与锁相比的劣势	373
17.3.3  HTM与增强后的锁机制相比的劣势	379
17.3.4  HTM最适合的场合	380
17.3.5  潜在的搅局者	380
17.3.6  结论	382
17.4  并行函数式编程	383
附录A  重要问题	385
A.1 “After”的含义是什么	385
A.2 “并发”和“并行”之间的差异是什么	388
A.3  现在是什么时间	389
附录B  同步原语	391
B.1  组织和初始化	391
B.1.1  smp_init()	391
B.2  线程创建、销毁及控制	392
B.2.1  create_thread()	392
B.2.2  smp_thread_id()	392
B.2.3  for_each_thread()	392
B.2.4  for_each_running_thread()	392
B.2.5  wait_thread()	393
B.2.6  wait_all_threads()	393
B.2.7  用法示例	393
B.3  锁	394
B.3.1  spin_lock_init()	394
B.3.2  spin_lock()	394
B.3.3  spin_trylock()	394
B.3.4  spin_unlock()	394
B.3.5  用法示例	395
B.4  每线程变量	395
B.4.1  DEFINE_PER_THREAD()	395
B.4.2  DECLARE_PER_THREAD()	395
B.4.3  per_thread()	395
B.4.4  __get_thread_var()	396
B.4.5  init_per_thread()	396
B.4.6  用法示例	396
B.5  性能	396
附录C  为什么需要内存屏障	397
C.1  缓存结构	397
C.2  缓存一致性协议	399
C.2.1  MESI状态	399
C.2.2  MESI协议消息	400
C.2.3  MESI状态图	400
C.2.4  MESI协议示例	401
C.3  存储导致不必要的停顿	402
C.3.1  存储缓冲	403
C.3.2  存储转发	403
C.3.3  存储缓冲区及内存屏障	404
C.4  存储序列导致不必要的停顿	406
C.4.1  使无效队列	406
C.4.2  使无效队列及使无效应答	407
C.4.3  使无效队列及内存屏障	407
C.5  读和写内存屏障	409
C.6  内存屏障示例	410
C.6.1  乱序体系结构	410
C.6.2  示例1	411
C.6.3  示例2	412
C.6.4  示例3	412
C.7  特定的内存屏障指令	413
C.7.1  Alpha	414
C.7.2  AMD64	417
C.7.3  ARMv7-A/R	417
C.7.4  IA64	418
C.7.5  PA-RISC	418
C.7.6  POWER / Power PC	418
C.7.7  SPARC RMO、PSO及TSO	419
C.7.8  x86	420
C.7.9  zSeries	421
C.8  内存屏障是永恒的吗	421
C.9  对硬件设计者的建议	422
附录D  问题答案	423
D.1  如何使用本书	423
D.2  简介	424
D.3  硬件和它的习惯	427
D.4  办事的家伙	429
D.5  计数	433
D.6  对分割和同步的设计	445
D.7  锁	449
D.8  数据所有权	455
D.9  延迟处理	456
D.10  数据结构	471
D.11  验证	473
D.12  形式验证	478
D.13  综合应用	481
D.14  高级同步	483
D.15  并行实时计算	486
D.16  易于使用	487
D.17  未来的冲突	487
D.18  重要问题	490
D.19  同步原语	491
D.20  为什么需要内存屏障	491
附录E  术语	495
附录F  感谢	502
F.1  评审者	502
F.2  硬件提供者	502
F.3  原始出处	503
F.4  图表作者	503
F.5  其他帮助	505
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解并行编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据库事务处理的艺术
目录
推荐序一
推荐序二
推荐序三
推荐序四
推荐序五
推荐序六
前言
第一篇　事务管理与并发控制基础理论
第1章　数据库管理系统的事务原理 2
1.1　事务模型要解决的问题 2
1.1.1　为什么需要事务处理机制 2
1.1.2　事务机制要处理的问题——事务故障、系统故障、介质故障 4
1.1.3　并发带来的问题椚 常见的读数据异常现象 4
1.1.4　并发带来的问题——写并发操作引发的数据异常现象 8
1.1.5　语义约束引发的数据异常现象 9
1.1.6　其他的异常 11
1.1.7　深入探讨三种读数据异常现象 13
1.2　事务处理技术的原理 17
1.2.1　什么是事务 17
1.2.2　事务的属性 20
1.2.3　ACID的实现技术 24
1.3　事务的模型 26
1.4　并发控制技术 27
1.4.1　并发控制技术的实现策略 27
1.4.2　并发控制技术的实现技术 28
1.5　日志技术与恢复子系统31
1.6　本章小结 32
第2章　深入理解事务管理和并发控制技术 33
2.1　在正确性和效率之间平衡 33
2.1.1　隔离级别 34
2.1.2　快照隔离 36
2.1.3　理解可见性 39
2.2　并发控制 40
2.2.1　基于锁的并发控制方法 42
2.2.2　基于时间戳的并发控制方法 47
2.2.3　基于有效性检查的并发控制方法 52
2.2.4　基于MVCC的并发控制方法 53
2.2.5　基于MVCC的可串行化快照隔离并发控制方法 56
2.2.6　再深入探讨三种读数据异常现象 60
2.3　并发控制技术的比较 62
2.3.1　并发控制技术整体比较 62
2.3.2　S2PL和SS2PL的比较 64
2.3.3　事务属性与并发控制技术的关系 65
2.3.4　SCO和SS2PL的比较 66
2.3.5　TO和SS2PL的比较 67
2.4　深入探讨隔离级别 68
2.4.1　隔离级别与基于锁的并发控制方法 68
2.4.2　隔离级别与各种并发控制技术 69
2.5　事务的管理 70
2.5.1　事务的开始 71
2.5.2　事务的提交 71
2.5.3　事务的中止与回滚 72
2.5.4　子事务与SAVEPOINT 72
2.5.5　长事务的管理 73
2.5.6　XA 74
2.6　事务相关的实战问题讨论 75
2.7　本章小结 76
第二篇　事务管理与并发控制应用实例研究
第3章　Informix事务管理与并发控制 78
3.1　Informix的事务操作 78
3.1.1　开始事务 78
3.1.2　提交事务 79
3.1.3　回滚事务 80
3.1.4　XA事务 80
3.1.5　事务模型 82
3.2 Informix的封锁技术 83
3.2.1 锁的级别 83
3.2.2　锁的粒度 84
3.3　隔离级别与数据异常 85
3.3.1　Informix支持的隔离级别 85
3.3.2　隔离级别与日志的模式 86
3.3.3　写偏序异常 87
3.4　本章小结 88
第4章　PostgreSQL事务管理与并发控制 89
4.1　PostgreSQL事务操作 89
4.1.1　开始事务 90
4.1.2　提交事务 90
4.1.3　回滚事务 90
4.1.4　XA事务 91
4.1.5　自动控制事务 91
4.2　SQL操作与锁 92
4.2.1　锁的研究准备 92
4.2.2　INSERT操作触发的锁 94
4.2.3　SELECT操作触发的锁 94
4.2.4　SELECT FOR UPDATE操作触发的锁 97
4.2.5　UPDATE操作触发的锁 100
4.2.6　DELETE操作触发的锁 103
4.2.7　ANALYZE操作触发的锁 106
4.2.8　CREATE INDEX操作触发的锁 106
4.2.9　CREATE TRIGGER操作触发的锁 107
4.2.10　锁的相关参数 108
4.3　隔离级别与数据异常 108
4.3.1　SQL标准定义的三种读异常 108
4.3.2　写偏序异常 115
4.4　本章小结 118
第5章　InnoDB事务管理与并发控制 119
5.1　InnoDB的事务模型 119
5.1.1　开始事务 120
5.1.2　提交事务与回滚事务 121
5.1.3　MySQL的XA 122
5.2　InnoDB基于锁的并发控制 123
5.2.1　基于封锁技术实现基本的并发控制 123
5.2.2　锁的种类 124
5.2.3　锁的施加规则 127
5.2.4　获取InnoDB行锁争用情况 129
5.2.5　死锁 129
5.3　InnoDB基于MVCC的并发控制 130
5.4　隔离级别与数据异常 131
5.4.1　SQL标准定义的三种读异常 131
5.4.2　写偏序异常 134
5.5　本章小结 138
第6章　Oracle事务管理与并发控制 139
6.1　Oracle的事务操作 139
6.1.1　事务管理 139
6.1.2　事务属性和隔离级别 140
6.1.3　XA事务 141
6.2　Oracle的封锁技术 142
6.2.1　元数据锁的级别 142
6.2.2　用户数据锁的级别 143
6.3　MVCC技术 145
6.3.1　MVCC的历史 145
6.3.2　深入理解MVCC 147
6.3.3　Oracle的MVCC 149
6.4　隔离级别与数据异常 157
6.4.1　Oracle支持的隔离级别 157
6.4.2　写偏序异常 158
6.5　本章小结 160
第三篇　PostgreSQL事务管理与并发控制源码分析
第7章　PostgreSQL事务系统的实现 162
7.1　架构概述 162
7.1.1　事务和并发控制相关的文件 162
7.1.2　事务相关的整体架构 164
7.2　事务管理的基础 166
7.2.1　事务状态 166
7.2.2　事务体 171
7.2.3　事务运行的简略过程 172
7.3　事务操作 173
7.3.1　开始事务 173
7.3.2　事务提交 177
7.3.3　日志落盘 179
7.3.4　事务回滚 180
7.3.5　clog 185
7.4　子事务的管理 186
7.4.1　子事务与父事务的区别 186
7.4.2　保存点 187
7.5　本章小结 188
第8章　PostgreSQL并发控制系统的实现—封锁 189
8.1　锁的概述 189
8.1.1　锁操作的本质 189
8.1.2　与锁相关的文件 190
8.1.3　与锁相关的内存初始化 191
8.2　系统锁 192
8.2.1　SpinLock 192
8.2.2　LWLock 198
8.2.3　SpinLock与LWLock比较 213
8.3　事务锁 214
8.3.1　锁的基本信息 214
8.3.2　ReguarLock 221
8.3.3　行级锁 232
8.3.4　Advisory lock（劝告锁） 237
8.4　事务锁的管理 239
8.4.1　获取锁 239
8.4.2　锁查找或创建 242
8.4.3　释放锁 243
8.4.4　锁冲突检测 244
8.5　死锁检测 247
8.5.1　数据结构 247
8.5.2　等待获取锁与死锁处理 248
8.5.3　死锁检测 251
8.5.4　进程唤醒 252
8.6　从锁的角度看用法 254
8.6.1　AccessShareLock 254
8.6.2　RowShareLock 256
8.6.3　RowExclusiveLock 257
8.6.4　ExclusiveLock 258
8.6.5　其他的锁 260
8.7　本章小结 262
第9章　PostgreSQL并发控制系统的实现—MVCC 263
9.1　快照 264
9.1.1　相关文件 264
9.1.2　数据结构 265
9.1.3　快照的类型 268
9.1.4　快照的管理 268
9.1.5　可串行化隔离级别的快照 271
9.2　可见性判断与多版本 273
9.2.1　可见性判断 273
9.2.2　多版本实现 282
9.3　可串行化快照原理 285
9.3.1　理论基础 285
9.3.2　算法实现 287
9.4　PostgreSQL可串行化快照的实现 289
9.4.1　PostgreSQL的状况 289
9.4.2　PostgreSQL实现SSI的理论基础 289
9.4.3　谓词锁数据结构 297
9.4.4　谓词锁操作 306
9.4.5　冲突检测 321
9.5　隔离级别 336
9.5.1　隔离级别 336
9.5.2　各种隔离级别的实现 337
9.6　本章小结 340
第四篇　InnoDB事务管理与并发控制源码分析
第10章　InnoDB事务系统的实现 342
10.1　架构概述 342
10.1.1　事务和并发控制相关的文件 342
10.1.2　事务相关的整体架构 344
10.2　事务管理的基础 346
10.2.1　事务状态 346
10.2.2　表示事务的数据结构 348
10.2.3　UNDO日志与回滚 349
10.2.4　REDO日志 350
10.2.5　内部事务的处理 352
10.2.6　Mini-Transaction 352
10.3　事务操作 353
10.3.1　InnoDB的初始化 354
10.3.2　开始事务 354
10.3.3　提交事务 359
10.3.4　日志落盘 364
10.3.5　回滚事务 367
10.3.6　Mini-Transaction的提交 371
10.3.7　Mini-Transaction的回滚 373
10.3.8　SAVEPOINT 373
10.3.9　XA 375
10.3.10　事务的其他内容 375
10.4　InnoDB事务模型 378
10.5　本章小结 382
第11章　InnoDB并发控制系统的实现—两阶段锁 383
11.1　锁的概述 383
11.1.1　锁操作的本质 383
11.1.2　全局锁表 384
11.1.3　封锁系统的架构 384
11.2　系统锁 386
11.2.1　读写锁 386
11.2.2　Mutex锁 394
11.2.3　其他锁 401
11.3　事务锁之记录锁 401
11.3.1　记录锁的基本数据结构 402
11.3.2　记录锁 408
11.3.3　记录锁与隔离级别 423
11.4　事务锁之元数据锁 433
11.4.1　元数据锁的数据结构 433
11.4.2　元数据锁的管理与使用 450
11.4.3　死锁处理 468
11.5　SQL语义定义锁 476
11.5.1　锁的粒度 476
11.5.2　重要的数据结构 478
11.5.3　InnoDB对接MySQL Server 480
11.6　其他类型的锁 493
11.6.1　Mini-Transaction加锁 493
11.6.2　事务锁之谓词锁 494
11.7　事务与锁 499
11.8　本章小结 500
第12章　InnoDB并发控制系统的实现—MVCC 502
12.1　数据结构 503
12.1.1　MVCC 503
12.1.2　Read View快照 504
12.1.3　事务与快照 505
12.2　可见性判断 506
12.2.1　可见性原则 506
12.2.2　二级索引的可见性 509
12.3　多版本的实现 509
12.3.1　多版本结构 509
12.3.2　多版本生成 510
12.3.3　多版本查找 510
12.3.4　多版本清理 511
12.4　一致性读和半一致性读 511
12.4.1　一致性读 512
12.4.2　半一致性读 512
12.5　本章小结 513
附录　TDSQL简介 514
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据库事务处理的艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程核心技术
前 言
第1章 Java多线程技能，
1.1 进程和多线程的概念及线程的优点
1.2 使用多线程
1.2.1 继承Thread类
1.2.2 实现Runnable接口
1.2.3 实例变量与线程安全
1.2.4 留意i——与System.out.println（）的异常
1.3 currentThread（）方法
1.4 isAlive（）方法
1.5 sleep（）方法
1.6 getId（）方法
1.7 停止线程
1.7.1 停止不了的线程
1.7.2 判断线程是否是停止状态
1.7.3 能停止的线程——异常法
1.7.4 在沉睡中停止
1.7.5 能停止的线程——暴力停止
1.7.6 方法stop（）与java.lang.ThreadDeath异常
1.7.7 释放锁的不良后果
1.7.8 使用return停止线程
1.8 暂停线程
1.8.1 suspend与resume方法的使用
1.8.2 suspend与resume方法的缺点——独占
1.8.3 suspend与resume方法的缺点——不同步
1.9 yield方法
1.10 线程的优先级
1.10.1 线程优先级的继承特性
1.10.2 优先级具有规则性
1.10.3 优先级具有随机性
1.10.4 看谁运行得快
1.11 守护线程
1.12 本章小结
第2章 对象及变量的并发访问
2.1 synchronized同步方法
2.1.1 方法内的变量为线程安全
2.1.2 实例变量非线程安全
2.1.3 多个对象多个锁
2.1.4 synchronized方法与锁对象
2.1.5 脏读
2.1.6 synchronized锁重入
2.1.7 出现异常，锁自动释放
2.1.8 同步不具有继承性
2.2 synchronized同步语句块
2.2.1 synchronized方法的弊端
2.2.2 synchronized同步代码块的使用
2.2.3 用同步代码块解决同步方法的弊端
2.2.4 一半异步，一半同步
2.2.5 synchronized代码块间的同步性
2.2.6 验证同步synchronized（this）代码块是锁定当前对象的
2.2.7 将任意对象作为对象监视器
2.2.8 细化验证3个结论
2.2.9 静态同步synchronized方法与synchronized（class）代码块
2.2.10 数据类型String的常量池特性
2.2.11 同步synchronized方法无限等待与解决
2.2.12 多线程的死锁
2.2.13 内置类与静态内置类
2.2.14 内置类与同步：实验1
2.2.15 内置类与同步：实验2
2.2.16 锁对象的改变
2.3 volatile关键字
2.3.1 关键字volatile与死循环
2.3.2 解决同步死循环
2.3.3 解决异步死循环
2.3.4 volatile非原子的特性
2.3.5 使用原子类进行i++操作
2.3.6 原子类也并不完全安全
2.3.7 synchronized代码块有volatile同步的功能
2.4 本章总结
第3章 线程间通信
3.1 等待/通知机制
3.1.1 不使用等待/通知机制实现线程间通信
3.1.2 什么是等待/通知机制
3.1.3 等待/通知机制的实现
3.1.4 方法wait（）锁释放与notify（）锁不释放
3.1.5 当interrupt方法遇到wait方法
3.1.6 只通知一个线程
3.1.7 唤醒所有线程
3.1.8 方法wait（long）的使用
3.1.9 通知过早
3.1.10 等待wait的条件发生变化
3.1.11 生产者/消费者模式实现
3.1.12 通过管道进行线程间通信：字节流
3.1.13 通过管道进行线程间通信：字符流
3.1.14 实战：等待/通知之交叉备份
3.2 方法join的使用
3.2.1 学习方法join前的铺垫
3.2.2 用join（）方法来解决
3.2.3 方法join与异常
3.2.4 方法join（long）的使用
3.2.5 方法join（long）与sleep（long）的区别
3.2.6 方法join（）后面的代码提前运行：出现意外
3.2.7 方法join（）后面的代码提前运行：解释意外
3.3 类ThreadLocal的使用
3.3.1 方法get（）与null
3.3.2 验证线程变量的隔离性
3.3.3 解决get（）返回null问题
3.3.4 再次验证线程变量的隔离性
3.4 类InheritableThreadLocal的使用
3.4.1 值继承
3.4.2 值继承再修改
3.5 本章总结
第4章 Lock的使用
4.1 使用ReentrantLock类
4.1.1 使用ReentrantLock实现同步：测试1
4.1.2 使用ReentrantLock实现同步：测试2
4.1.3 使用Condition实现等待/通知错误用法与解决
4.1.4 正确使用Condition实现等待/通知
4.1.5 使用多个Condition实现通知部分线程：错误用法
4.1.6 使用多个Condition实现通知部分线程：正确用法
4.1.7 实现生产者/消费者模式：一对一交替打印
4.1.8 实现生产者/消费者模式：多对多交替打印
4.1.9 公平锁与非公平锁
4.1.10 方法getHoldCount（）、getQueueLength（）和getWaitQueueLength（）的测试
4.1.11 方法hasQueuedThread（）、hasQueuedThreads（）和hasWaiters（）的测试
4.1.12 方法isFair（）、isHeldByCurrentThread（）和isLocked（）的测试
4.1.13 方法lockInterruptibly（）、tryLock（）和tryLock（long timeout，TimeUnit unit）的测试
4.1.14 方法awaitUninterruptibly（）的使用
4.1.15 方法awaitUntil（）的使用
4.1.16 使用Condition实现顺序执行
4.2 使用ReentrantReadWriteLock类
4.2.1 类ReentrantReadWriteLock的使用：读读共享
4.2.2 类ReentrantReadWriteLock的使用：写写互斥
4.2.3 类ReentrantReadWriteLock的使用：读写互斥
4.2.4 类ReentrantReadWriteLock的使用：写读互斥
4.3 本章总结
第5章 定时器Timer
5.1 定时器Timer的使用
5.1.1 方法schedule（TimerTask task， Date time）的测试
5.1.2 方法schedule（TimerTask task， Date firstTime， long period）的测试
5.1.3 方法schedule（TimerTask task， long delay）的测试
5.1.4 方法schedule（TimerTask task， long delay， long period）的测试
5.1.5 方法scheduleAtFixedRate（TimerTask task， Date firstTime， long period）的测试
5.2 本章总结
第6章 单例模式与多线程
6.1 立即加载/"饿汉模式"
6.2 延迟加载/"懒汉模式"
6.3 使用静态内置类实现单例模式
6.4 序列化与反序列化的单例模式实现
6.5 使用static代码块实现单例模式
6.6 使用enum枚举数据类型实现单例模式
6.7 完善使用enum枚举实现单例模式
6.8 本章总结
第7章 拾遗增补
7.1 线程的状态
7.1.1 验证NEW、RUNNABLE和TERMINATED
7.1.2 验证TIMED_WAITING
7.1.3 验证BLOCKED
7.1.4 验证WAITING
7.2 线程组
7.2.1 线程对象关联线程组：1级关联
7.2.2 线程对象关联线程组：多级关联
7.2.3 线程组自动归属特性
7.2.4 获取根线程组
7.2.5 线程组里加线程组
7.2.6 组内的线程批量停止
7.2.7 递归与非递归取得组内对象
7.3 使线程具有有序性
7.4 SimpleDateFormat非线程安全
7.4.1 出现异常
7.4.2 解决异常方法1
7.4.3 解决异常方法2
7.5 线程中出现异常的处理
7.6 线程组内处理异常
7.7 线程异常处理的传递
7.8 本章总结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程核心技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图解Java多线程设计模式
序章1　Java线程　　1
I1.1　Java线程　　2
I1.2　何谓线程　　2
明为跟踪处理流程，实为跟踪线程　　2
单线程程序　　3
多线程程序　　4
Thread类的run方法和start方法　　5
I1.3　线程的启动　　9
线程的启动（1）——利用Thread类的子类　　9
线程的启动（2）——利用Runnable接口　　10
I1.4　线程的暂停　　12
I1.5　线程的互斥处理　　13
synchronized方法　　14
synchronized代码块　　17
I1.6　线程的协作　　18
等待队列——线程休息室　　19
wait方法——将线程放入等待队列　　19
notify方法——从等待队列中取出线程　　21
notifyAll方法——从等待队列中取出所有线程　　23
wait、notify、notifyAll是Object类的方法　　24
I1.7　线程的状态迁移　　24
I1.8　线程相关的其他话题　　26
I1.9　本章所学知识　　26
I1.10　　练习题　　26
序章2　多线程程序的评价标准　　31
I2.1　多线程程序的评价标准　　32
安全性——不损坏对象　　32
生存性——必要的处理能够被执行　　32
可复用性——类可重复利用　　33
性能——能快速、大批量地执行处理　　33
评价标准总结　　33
I2.2　本章所学知识　　34
I2.3　练习题　　34
第1章　　Single Threaded Execution模式——能通过这座桥的只有一个人　　35
1.1　Single Threaded Execution模式　　36
1.2　示例程序1：不使用Single Threaded Execution模式的程序　　36
Main类　　37
非线程安全的Gate类　　37
UserThread类　　38
执行起来看看……出错了　　39
为什么会出错呢　　40
1.3　示例程序2：使用Single Threaded Execution模式的程序　　41
线程安全的Gate类　　41
synchronized的作用　　42
1.4　Single Threaded Execution模式中的登场角色　　43
1.5　拓展思路的要点　　44
何时使用（可使用Single Threaded Execution模式的情况）　　44
生存性与死锁　　45
可复用性和继承反常　　46
临界区的大小和性能　　46
1.6　相关的设计模式　　47
Guarded Suspension模式　　47
Read-Write Lock模式　　47
Immutable模式　　47
Thread-Specific Storage模式　　48
1.7　延伸阅读1：关于synchronized　　48
synchronized语法与Before/After模式　　48
synchronized在保护着什么　　49
该以什么单位来保护呢　　50
使用哪个锁保护　　50
原子操作　　51
long与double的操作不是原子的　　51
1.8　延伸阅读2：java.util.concurrent包和计数信号量　　52
计数信号量和Semaphore类　　52
使用Semaphore类的示例程序　　52
1.9　本章所学知识　　55
1.10　　练习题　　55
第2章　　Immutable模式——想破坏也破坏不了　　61
2.1　Immutable模式　　62
2.2　示例程序　　62
使用Immutable模式的Person类　　62
Main类　　63
PrintPersonThread类　　63
2.3　Immutable模式中的登场角色　　65
2.4　拓展思路的要点　　66
何时使用（可使用Immutable模式的情况）　　66
考虑成对的mutable类和immutable类 [性能]　　66
为了确保不可变性 [可复用性]　　67
标准类库中用到的Immutable模式　　67
2.5　相关的设计模式　　69
Single Threaded Execution模式　　69
Read-Write Lock模式　　69
Flyweight模式　　69
2.6　延伸阅读1：final　　69
final的含义　　69
2.7　延伸阅读2：集合类与多线程　　71
示例1：非线程安全的java.util.ArrayList类　　71
示例2：利用Collections.synchronizedList方法所进行的同步　　74
示例3：使用copy-on-write的java.util.concurrent.CopyOnWriteArrayList类　　75
2.8　本章所学知识　　76
2.9　练习题　　77
第3章　　Guarded Suspension模式——等我准备好哦　　81
3.1　Guarded Suspension模式　　82
3.2　示例程序　　82
Request类　　83
RequestQueue类　　84
ClientThread类　　85
ServerThread类　　85
Main类　　86
java.util.Queue与java.util.LinkedList的操作　　87
getRequest详解　　87
putRequest详解　　89
synchronized的含义　　89
wait与锁　　89
3.3　Guarded Suspension模式中的登场角色　　90
3.4　拓展思路的要点　　91
附加条件的synchronized　　91
多线程版本的if　　91
忘记改变状态与生存性　　91
wait与notify/notifyAll的责任 [可复用性]　　91
各种称呼　　91
使用java.util.concurrent.LinkedBlockingQueue的示例程序　　93
3.5　相关的设计模式　　94
Single Threaded Execution模式　　94
Balking模式　　94
Producer-Consumer模式　　94
Future模式　　94
3.6　本章所学知识　　95
3.7　练习题　　95
第4章　　Balking模式——不需要就算了　　99
4.1　Balking模式　　100
4.2　示例程序　　100
Data类　　100
SaverThread类　　102
ChangerThread类　　102
Main类　　103
4.3　Balking模式中的登场角色　　105
4.4　拓展思路的要点　　106
何时使用（可使用Balking模式的情况）　　106
balk结果的表示方式　　107
4.5　相关的设计模式　　107
Guarded Suspension模式　　107
Observer模式　　107
4.6　延伸阅读：超时　　108
Balking模式和Guarded Suspension模式之间　　108
wait何时终止呢　　108
guarded timed的实现（使用wait）　　109
synchronized中没有超时，也不能中断　　110
java.util.concurrent中的超时　　111
4.7　本章所学知识　　111
4.8　练习题　　112
第5章　　Producer-Consumer模式——我来做，你来用　　115
5.1　Producer-Consumer模式　　116
5.2　示例程序　　116
Main类　　116
MakerThread类　　117
EaterThread类　　118
Table类　　118
解读put方法　　120
解读take方法　　121
5.3　Producer-Consumer模式中的登场角色　　122
5.4　拓展思路的要点　　123
守护安全性的Channel角色（可复用性）　　123
不可以直接传递吗　　124
Channel角色的剩余空间所导致的问题　　124
以什么顺序传递Data角色呢　　125
“存在中间角色”的意义　　125
Consumer角色只有一个时会怎么样呢　　126
5.5　相关的设计模式　　126
Mediator模式　　126
Worker Thread模式　　126
Command模式　　126
Strategy模式　　127
5.6　延伸阅读1：理解InterruptedException异常　　127
可能会花费时间，但可以取消　　127
加了throws InterruptedException的方法　　127
sleep方法和interrupt方法　　128
wait方法和interrupt方法　　128
join方法和interrupt方法　　129
interrupt方法只是改变中断状态　　129
isInterrupted方法——检查中断状态　　130
Thread.interrupted方法——检查并清除中断状态　　130
不可以使用Thread类的stop方法　　130
5.7　延伸阅读2：java.util.concurrent包和Producer-Consumer模式　　131
java.util.concurrent包中的队列　　131
使用java.util.concurrent.ArrayBlockingQueue的示例程序　　132
使用java.util.concurrent.Exchanger类交换缓冲区　　133
5.8　本章所学知识　　136
5.9　练习题　　137
第6章　　Read-Write Lock模式——大家一起读没问题，但读的时候不要写哦　　141
6.1　Read-Write Lock模式　　142
6.2　示例程序　　142
Main类　　143
Data类　　143
WriterThread类　　146
ReaderThread类　　146
ReadWriteLock类　　147
执行起来看看　　149
守护条件的确认　　150
6.3　Read-Write Lock模式中的登场角色　　151
6.4　拓展思路的要点　　153
利用“读取”操作的线程之间不会冲突的特性来提高程序性能　　153
适合读取操作繁重时　　153
适合读取频率比写入频率高时　　153
锁的含义　　153
6.5　相关的设计模式　　154
Immutable模式　　154
Single Threaded Execution模式　　154
Guarded Suspension模式　　154
Before/After模式　　154
Strategized Locking模式　　154
6.6　延伸阅读：java.util.concurrent.locks包和Read-Write Lock模式　　154
java.util.concurrent.locks包　　154
使用java.util.concurrent.locks的示例程序　　155
6.7　本章所学知识　　156
6.8　练习题　　157
第7章　　Thread-Per-Message模式——这项工作就交给你了　　163
7.1　Thread-Per-Message模式　　164
7.2　示例程序　　164
Main类　　164
Host类　　165
Helper类　　166
7.3　Thread-Per-Message模式中的登场角色　　168
7.4　拓展思路的要点　　169
提高响应性，缩短延迟时间　　169
适用于操作顺序没有要求时　　169
适用于不需要返回值时　　169
应用于服务器　　169
调用方法＋启动线程→发送消息　　170
7.5　相关的设计模式　　170
Future模式　　170
Worker Thread模式　　170
7.6　延伸阅读1：进程与线程　　171
7.7　延伸阅读2：java.util.concurrent包和Thread-Per-Message模式　　171
java.lang.Thread类　　171
java.lang.Runnable接口　　172
java.util.concurrent.ThreadFactory接口　　173
java.util.concurrent.Executors类获取的ThreadFactory　　174
java.util.concurrent.Executor接口　　175
java.util.concurrent.ExecutorService接口　　176
java.util.concurrent.ScheduledExecutorService类　　177
总结　　178
7.8　本章所学知识　　180
7.9　练习题　　180
第8章　　Worker Thread模式——工作没来就一直等，工作来了就干活　　187
8.1　Worker Thread模式　　188
8.2　示例程序　　188
Main类　　189
ClientThread类　　190
Request类　　190
Channel类　　191
WorkerThread类　　192
8.3　Worker Thread模式中的登场角色　　193
8.4　拓展思路的要点　　195
提高吞吐量　　195
容量控制　　195
调用与执行的分离　　196
Runnable接口的意义　　197
多态的Request角色　　198
独自一人的Worker角色　　199
8.5　相关的设计模式　　199
Producer-Consumer模式　　199
Thread-Per-Message模式　　199
Command模式　　199
Future模式　　199
Flyweight模式　　199
Thread-Specific Storage模式　　200
Active Ojbect模式　　200
8.6　延伸阅读1：Swing事件分发线程　　200
什么是事件分发线程　　200
事件分发线程只有一个　　200
事件分发线程调用监听器　　201
注册监听器的意义　　201
事件分发线程也负责绘制界面　　201
javax.swing.SwingUtilities类　　202
Swing的单线程规则　　203
8.7　延伸阅读2：java.util.concurrent包和Worker Thread模式　　204
ThreadPoolExecutor类　　204
通过java.util.concurrent包创建线程池　　205
8.8　本章所学知识　　207
8.9　练习题　　208
第9章　　Future模式——先给您提货单　　211
9.1　Future模式　　212
9.2　示例程序　　212
Main类　　214
Host类　　214
Data接口　　215
FutureData类　　216
RealData类　　217
9.3　Future模式中的登场角色　　218
9.4　拓展思路的要点　　219
吞吐量会提高吗　　219
异步方法调用的“返回值”　　220
“准备返回值”和“使用返回值”的分离　　220
变种——不让主线程久等的Future角色　　220
变种——会发生变化的Future角色　　221
谁会在意多线程呢？“可复用性”　　221
回调与Future模式　　221
9.5　相关的设计模式　　222
Thread-Per-Message模式　　222
Builder模式　　222
Proxy模式　　222
Guarded Suspension模式　　222
Balking模式　　222
9.6　延伸阅读：java.util.concurrent包与Future模式　　222
java.util.concurrent包　　222
使用了java.util.concurrent包的示例程序　　223
9.7　本章所学知识　　226
9.8　练习题　　226
第10章　　Two-Phase Termination模式——先收拾房间再睡觉　　231
10.1　Two-Phase Termination模式　　232
10.2　示例程序　　233
CountupThread类　　234
Main类　　236
10.3　Two-Phase Termination模式中的登场角色　　237
10.4　拓展思路的要点　　238
不能使用Thread类的stop方法　　238
仅仅检查标志是不够的　　239
仅仅检查中断状态是不够的　　239
在长时间处理前检查终止请求　　239
join方法和isAlive方法　　240
java.util.concurrent.ExecutorService接口与Two-Phase Termination模式　　240
要捕获程序整体的终止时　　241
优雅地终止线程　　243
10.5　相关的设计模式　　243
Before/After模式　　243
Multiphase Cancellation模式　　243
Multi-Phase Startup模式　　244
Balking模式　　244
10.6　延伸阅读1：中断状态与InterruptedException异常的相互转换　　244
中断状态→InterruptedException异常的转换　　244
InterruptedException异常→中断状态的转换　　245
InterruptedException异常→InterruptedException异常的转换　　245
10.7　延伸阅读2：java.util.concurrent包与线程同步　　246
java.util.concurrent.CountDownLatch类　　246
java.util.concurrent.CyclicBarrier类　　249
10.8　本章所学知识　　253
10.9　练习题　　253
第11章　　Thread-Specific Storage模式——一个线程一个储物柜　　263
11.1　Thread-Specific Storage模式　　264
11.2　关于java.lang.ThreadLocal类　　264
java.lang.ThreadLocal就是储物间　　264
java.lang.ThreadLocal与泛型　　265
11.3　示例程序1：不使用Thread-Specific Storage模式的示例　　265
Log类　　266
Main类　　266
11.4　示例程序2：使用了Thread-Specific Storage模式的示例　　267
线程特有的TSLog类　　268
Log类　　269
ClientThread类　　270
Main类　　271
11.5　Thread-Specific Storage模式中的登场角色　　272
11.6　拓展思路的要点　　274
局部变量与java.lang.ThreadLocal类　　274
保存线程特有的信息的位置　　275
不必担心其他线程访问　　275
吞吐量的提高很大程序上取决于实现方式　　276
上下文的危险性　　276
11.7　相关的设计模式　　277
Singleton模式　　277
Worker Thread模式　　277
Single Threaded Execution模式　　277
Proxy模式　　277
11.8　延伸阅读：基于角色与基于任务　　277
主体与客体　　277
基于角色的考虑方式　　278
基于任务的考虑方式　　278
实际上两种方式是综合在一起的　　279
11.9　本章所学知识　　279
11.10　　练习题　　280
第12章　　Active Object模式——接收异步消息的主动对象　　283
12.1　Active Object模式　　284
12.2　示例程序1　284
调用方：Main类　　287
调用方：MakerClientThread类　　288
调用方：DisplayClientThread类　　289
主动对象方：ActiveObject接口　　289
主动对象方：ActiveObjectFactory类　　290
主动对象方：Proxy类　　290
主动对象方：SchedulerThread类　　291
主动对象方：ActivationQueue类　　292
主动对象方：MethodRequest类　　293
主动对象方：MakeStringRequest类　　294
主动对象方：DisplayStringRequest类　　295
主动对象方：Result类　　295
主动对象方：FutureResult类　　296
主动对象方：RealResult类　　296
主动对象方：Servant类　　297
示例程序1的运行　　297
12.3　ActiveObject模式中的登场角色　　298
12.4　拓展思路的要点　　304
到底做了些什么事情　　304
运用模式时需要考虑问题的粒度　　304
关于并发性　　304
增加方法　　305
Scheduler角色的作用　　305
主动对象之间的交互　　306
通往分布式——从跨越线程界线变为跨越计算机界线　　306
12.5　相关的设计模式　　306
Producer-Consumer模式　　306
Future模式　　307
Worker Thread模式　　307
Thread-Specific Storage模式　　307
12.6　延伸阅读：java.util.concurrent包与Active Object模式　　307
类与接口　　307
调用方：Main类　　309
调用方：MakerClientThread类　　309
调用方：DisplayClientThread类　　310
主动对象方：ActiveObject接口　　311
主动对象方：ActiveObjectFactory类　　311
主动对象：ActiveObjectImpl类　　312
示例程序2的运行　　313
12.7　本章所学知识　　314
12.8　练习题　　315
第13章　　总结——多线程编程的模式语言　　321
13.1　多线程编程的模式语言　　322
模式与模式语言　　322
13.2　Single Threaded Execution模式
——能通过这座桥的只有一个人　　323
13.3　Immutable模式
——想破坏也破坏不了　　324
13.4　Guarded Suspension模式
——等我准备好哦　　325
13.5　Balking模式
——不需要就算了　　326
13.6　Producer-Consumer模式
——我来做，你来用　　327
13.7　Read-Write Lock模式
——大家一起读没问题，但读的时候不要写哦　　328
13.8　Thread-Per-Message模式
——这项工作就交给你了　　329
13.9　Worker Thread模式
——工作没来就一直等，工作来了就干活　　330
13.10　　Future模式
——先给您提货单　　330
13.11　Two-Phase Termination模式
——先收拾房间再睡觉　　331
13.12　Thread-Specific Storage模式
——一个线程一个储物柜　　332
13.13　Active Object模式
——接收异步消息的主动对象　　333
13.14　写在最后　　335
附录　　337
附录A　习题解答　　338
附录B　Java内存模型　　447
附录C　Java线程的优先级　　467
附录D　线程相关的主要API　　469
附录E　java.util.concurrent包　　475
附录F　示例程序的运行步骤　　483
附录G　参考文献　　485
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图解Java多线程设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala并发编程
前言 ............................................................................................ XVII
1 简介 ........................................................................................................... 1
并发程序设计 .......................................................................................................... 1
传统并发编程技术概述 ............................................................................. 2
现代并发范式 .......................................................................................................... 3
Scala 的优点 ....................................................................... 4
预备知识 ....................................................................................... 5
执行Scala 程序 ......................................................................... 5
Scala 基础知识 ................................................................................................ 6
小结 ...................................................................................................... 11
练习 ........................................................................................ 11
2 JVM 和Java 内存模型中的并发处理方式 ................................................ 13
进程和线程 ...................................................................... 14
创建和启动线程 ....................................................16
原子执行方式 .......................................................21
调整次序 ..................................................................................................25
监控器和同步 ............................................................................................... 27
死锁 .....................................................................................................29
保卫锁 ..........................................................................................................32
中断线程和正常关闭 ...............................................................................................36
Volatile 变量 .................................................................................................. 37
Java 内存模型.............................................................................................. 39
不可变对象和final 字段 .......................................................41
小结 ............................................................. 43
练习 ....................................................................................... 43
3 构建并发程序的传统材料 ............................................. 47
Executor 和ExecutionContext 对象 ................... 48
原子型基元 ...................................................... 52
原子变量 ............................................................................52
无锁编程 ..........................................................55
以明确方式实现锁 ...................................................................57
ABA 问题 .....................................................................59
惰性值 .............................................................................. 61
并发集合 ..................................................................... 66
并发队列 ...............................................................................68
并发集和映射 .....................................................71
并发遍历 .............................................................77
创建和处理进程 ...................................................... 79
小结 ................................................................. 81
练习 ................................................................... 81
4 使用Future 和Promise 对象编写异步程序 .............................................. 85
Future 类 ................................................................................. 86
执行Future 计算....................................................................88
Future 对象的回调函数 ..................................................89
Future 计算和异常 ...............................................92
使用Try 类型 .......................................93
致命异常 ............................................95
Future 对象中的函数组合 ............................................................95
Promise 类 .................................................. 103
转换基于回调函数的API ........................................................... 106
扩展Future API .................................................. 108
取消异步计算操作 ..................................................................................... 109
Future 对象和阻塞操作 ................................................................... 112
等待Future 对象..................................................................................... 112
在异步计算内部执行阻塞操作 ................................................................................... 113
Scala Async 库 ...................................................................... 114
可选的Future 框架 .......................................................................................... 117
小结 ........................................................................................................... 118
练习 ....................................................................................................................... 119
5 数据并行集合 ......................................................................................... 121
Scala 集合概述 ................................................................................................ 122
并行集合的用法 ......................................................................................... 123
并行集合类的层次结构 ....................................................................................... 126
配置并行等级 ...................................................................................................... 128
在JVM 中度量性能 ............................................................................. 129
使用并行集合的注意事项 ................................................................................. 131
非可并行化集合 .................................................................... 131
非可并行化操作 .............................................................................................. 132
并行操作的副作用 .................................................................................................... 134
不确定的并行操作 .................................. 135
可交换和可结合操作符 .............................................................. 137
组合使用并行集合和并发集合 .................................................................... 139
弱一致性迭代器 ........................................................ 140
实现自定义的并行集合 ............................................................................... 141
分离器 ................................................................................................ 142
组合器 ..................................................................................................... 145
可选的数据并行框架 ................................................................. 148
ScalaBlitz 框架中的集合层次结构 .............................................................. 149
小结 ....................................................................................................... 150
练习 ............................................................................................. 151
6 使用Reactive Extensions 编写并发程序 ............................................... 153
创建Observable 对象 ............................................................... 154
Observable 对象和异常 ................................................................ 157
Observable 协定 ................................................................................ 158
实现自定义Observable 对象 ...................................................................................... 160
通过Future 对象创建Observable 对象 ............................................................ 161
Subscription 对象 ............................................................................................ 162
组合Observable 对象 ...................................................................................... 165
嵌套的Observable 对象 ....................................................................................... 166
处理完善Observable 对象失败的情况 .................................................................. 171
Rx 调度器 ............................................................................... 174
使用自定义调度器编写UI 应用程序 .................................................................. 176
Subject 特征和自顶向下的响应式编程 .................................................. 181
小结 ............................................................................................ 186
练习 ..................................................................................... 186
7 基于软件的事务内存 .............................................................................. 189
原子变量带来的麻烦 ...................................................................... 190
使用基于软件的事务内存 .............................................. 194
事务引用 ......................................................... 196
使用atomic 语句 ................................................................ 197
组合事务 .............................................................. 198
事务与副作用 ................................................................. 199
单操作事务 ................................................................. 203
嵌套事务 ........................................................... 205
事务和异常 ...................................................... 208
重新尝试执行事务 ........................................ 212
通过超时设置重新尝试执行事务 ......................................... 216
事务集合 ..................................................................................... 217
事务局部变量 ................................................................. 218
事务数组 ......................................................... 219
事务映射 .............................................................................. 221
小结 ............................................................................................. 222
练习 ............................................................................. 223
8 Actor ...................................................................................................... 227
使用Actor 模型 ............................................................................... 228
创建Actor 系统和Actor 实例 ..................................................................... 230
管理无法正常处理的消息 .................................................................................. 233
Actor 实例的行为和状态 ........................................................................................ 234
Akka 框架中的Actor 层次结构.................................................................................. 239
识别Actor 对象 ............................................................................................... 242
Actor 对象的生命周期 ................................................................................... 245
Actor 对象之间的通信 ...................................................... 249
请求模式 ........................................................ 251
转发模式 ..................................................................... 254
停止Actor 对象 ......................................................................... 255
Actor 监督 .......................................................................... 257
远程Actor 对象 ............................................................. 263
小结 .............................................................................................. 266
练习 ................................................................................................... 267
9 实用并发技术 ......................................................................................... 269
工欲善其事，必先利其器 ....................................................... 269
组合使用多种框架——编写远程文件管理器 ............................................ 273
创建文件系统模型 ........................................................ 274
服务器接口 ......................................................................... 278
客户端导航API.................................................................................. 280
客户端的用户界面 ............................................................................. 284
实现客户端程序的逻辑 .................................................................................. 288
改进远程文件管理器 ........................................................................................ 293
调试并发程序 ................................................................................................................... 294
死锁和暂停处理过程 ............................................................... 295
调试运行结果不正确的程序 ................................................................ 299
性能调试 ............................................................................... 304
小结 .............................................................................................................................. 310
练习 .................................................................................................................................. 311
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala并发编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go语言并发之道
前言 1
第1章 并发概述 9
摩尔定律，Web Scale和我们所陷入的混乱 10
为什么并发很难？ 12
竞争条件 13
原子性 15
内存访问同步 17
死锁、活锁和饥饿 20
确定并发安全 28
面对复杂性的简单性 31
第2章 对你的代码建模：通信顺序进程 33
并发与并行的区别 33
什么是CSP 37
如何帮助你 40
Go语言的并发哲学 43
第3章 Go语言并发组件 47
goroutine 47
sync包 58
WaitGroup 58
互斥锁和读写锁 60
cond 64
once 69
池 71
channel 76
select 语句 92
GOMAXPROCS控制 97
小结 98
第4章 Go语言的并发模式 99
约束 99
for-select循环103
防止goroutine泄漏 104
or-channel 109
错误处理112
pipeline 116
构建pipeline的最佳实践 120
一些便利的生成器 126
扇入，扇出 132
or-done-channel 137
tee-channel 139
桥接channel模式 140
队列排队143
context包 151
小结 168
第5章 大规模并发 169
异常传递169
超时和取消 178
心跳 184
复制请求197
速率限制199
治愈异常的goroutine 215
小结 222
第6章 goroutine和Go语言运行时 223
工作窃取223
窃取任务还是续体 231
向开发人员展示所有这些信息 240
尾声 240
附录A 241
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go语言并发之道
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程实战指南（设计模式篇）
1章  Java多线程编程实战基础	1
1.1  无处不在的线程	1
1.2  线程的创建与运行	2
1.3  线程的状态与上下文切换	5
1.4  线程的监视	7
1.5  原子性、内存可见性和重排序——重新认识synchronized和volatile	10
1.6  线程的优势和风险	11
1.7  多线程编程常用术语	13
第2章  设计模式简介	17
2.1  设计模式及其作用	17
2.2  多线程设计模式简介	20
2.3  设计模式的描述	21
第3章  Immutable Object（不可变对象）模式	23
3.1  Immutable Object模式简介	23
3.2  Immutable Object模式的架构	25
3.3  Immutable Object模式实战案例	27
3.4  Immutable Object模式的评价与实现考量	31
3.5  Immutable Object模式的可复用实现代码	32
3.6  Java标准库实例	32
3.7  相关模式	34
3.7.1  Thread Specific Storage模式（第10章）	34
3.7.2  Serial Thread Confinement模式（第11章）	34
3.8  参考资源	34
第4章  Guarded Suspension（保护性暂挂）模式	35
4.1  Guarded Suspension模式简介	35
4.2  Guarded Suspension模式的架构	35
4.3  Guarded Suspension模式实战案例解析	39
4.4  Guarded Suspension模式的评价与实现考量	45
4.4.1  内存可见性和锁泄漏（Lock Leak）	46
4.4.2  线程过早被唤醒	46
4.4.3  嵌套监视器锁死	47
4.5  Guarded Suspension模式的可复用实现代码	50
4.6  Java标准库实例	50
4.7  相关模式	51
4.7.1  Promise模式（第6章）	51
4.7.2  Producer-Consumer模式（第7章）	51
4.8  参考资源	51
第5章  Two-phase Termination（两阶段终止）模式	52
5.1  Two-phase Termination模式简介	52
5.2  Two-phase Termination模式的架构	53
5.3  Two-phase Termination模式实战案例	56
5.4  Two-phase Termination模式的评价与实现考量	63
5.4.1  线程停止标志	63
5.4.2  生产者-消费者问题中的线程停止	64
5.4.3  隐藏而非暴露可停止的线程	65
5.5  Two-phase Termination模式的可复用实现代码	65
5.6  Java标准库实例	66
5.7  相关模式	66
5.7.1  Producer-Consumer模式（第7章）	66
5.7.2  Master-Slave模式（第12章）	66
5.8  参考资源	66
第6章  Promise（承诺）模式	67
6.1  Promise模式简介	67
6.2  Promise模式的架构	68
6.3  Promise模式实战案例解析	70
6.4  Promise模式的评价与实现考量	74
6.4.1  异步方法的异常处理	75
6.4.2  轮询（Polling）	75
6.4.3  异步任务的执行	75
6.5  Promise模式的可复用实现代码	77
6.6  Java标准库实例	77
6.7  相关模式	78
6.7.1  Guarded Suspension模式（第4章）	78
6.7.2  Active Object模式（第8章）	78
6.7.3  Master-Slave模式（第12章）	78
6.7.4  Factory Method模式	78
6.8  参考资源	79
第7章  Producer-Consumer（生产者/消费者）模式	80
7.1  Producer-Consumer模式简介	80
7.2  Producer-Consumer模式的架构	80
7.3  Producer-Consumer模式实战案例解析	83
7.4  Producer-Consumer模式的评价与实现考量	87
7.4.1  通道积压	87
7.4.2  工作窃取算法	88
7.4.3  线程的停止	92
7.4.4  高性能高可靠性的Producer-Consumer模式实现	92
7.5  Producer-Consumer模式的可复用实现代码	92
7.6  Java标准库实例	93
7.7  相关模式	93
7.7.1  Guarded Suspension模式（第4章）	93
7.7.2  Thread Pool模式（第9章）	93
7.8  参考资源	93
第8章  Active Object（主动对象）模式	94
8.1  Active Object模式简介	94
8.2  Active Object模式的架构	95
8.3  Active Object模式实战案例解析	98
8.4  Active Object模式的评价与实现考量	105
8.4.1  错误隔离	107
8.4.2  缓冲区监控	108
8.4.3  缓冲区饱和处理策略	108
8.4.4  Scheduler空闲工作者线程清理	109
8.5  Active Object模式的可复用实现代码	109
8.6  Java标准库实例	111
8.7  相关模式	112
8.7.1  Promise模式（第6章）	112
8.7.2  Producer-Consumer模式（第7章）	112
8.8  参考资源	112
第9章  Thread Pool（线程池）模式	113
9.1  Thread Pool模式简介	113
9.2  Thread Pool模式的架构	114
9.3  Thread Pool模式实战案例解析	116
9.4  Thread Pool模式的评价与实现考量	117
9.4.1  工作队列的选择	118
9.4.2  线程池大小调校	119
9.4.3  线程池监控	121
9.4.4  线程泄漏	122
9.4.5  可靠性与线程池饱和处理策略	122
9.4.6  死锁	125
9.4.7  线程池空闲线程清理	126
9.5  Thread Pool模式的可复用实现代码	127
9.6  Java标准库实例	127
9.7  相关模式	127
9.7.1  Two-phase Termination模式（第5章）	127
9.7.2  Promise模式（第6章）	127
9.7.3  Producer-Consumer模式（第7章）	127
9.8  参考资源	128
第10章  Thread Specific Storage（线程特有存储）模式	129
10.1  Thread Specific Storage模式简介	129
10.2  Thread Specific Storage模式的架构	131
10.3  Thread Specific Storage模式实战案例解析	133
10.4  Thread Specific Storage模式的评价与实现考量	135
10.4.1  线程池环境下使用Thread Specific Storage模式	138
10.4.2  内存泄漏与伪内存泄漏	139
10.5  Thread Specific Storage模式的可复用实现代码	145
10.6  Java标准库实例	146
10.7  相关模式	146
10.7.1  Immutable Object模式（第3章）	146
10.7.2  Proxy（代理）模式	146
10.7.3  Singleton（单例）模式	146
10.8  参考资源	147
第11章  Serial Thread Confinement（串行线程封闭）模式	148
11.1  Serial Thread Confinement模式简介	148
11.2  Serial Thread Confinement模式的架构	148
11.3  Serial Thread Confinement模式实战案例解析	151
11.4  Serial Thread Confinement模式的评价与实现考量	155
11.4.1  任务的处理结果	155
11.5  Serial Thread Confinement模式的可复用实现代码	156
11.6  Java标准库实例	160
11.7  相关模式	160
11.7.1  Immutable Object模式（第3章）	160
11.7.2  Promise模式（第6章）	160
11.7.3  Producer-Consumer模式（第7章）	160
11.7.4  Thread Specific Storage（线程特有存储）模式 （第10章）	161
11.8  参考资源	161
第12章  Master-Slave（主仆）模式	162
12.1  Master-Slave模式简介	162
12.2  Master-Slave模式的架构	162
12.3  Master-Slave模式实战案例解析	164
12.4  Master-Slave模式的评价与实现考量	171
12.4.1  子任务的处理结果的收集	172
12.4.2  Slave参与者实例的负载均衡与工作窃取	173
12.4.3  可靠性与异常处理	173
12.4.4  Slave线程的停止	174
12.5  Master-Slave模式的可复用实现代码	174
12.6  Java标准库实例	186
12.7  相关模式	186
12.7.1  Two-phase Termination模式（第5章）	186
12.7.2  Promise模式（第6章）	186
12.7.3  Strategy（策略）模式	186
12.7.4  Template（模板）模式	186
12.7.5  Factory Method（工厂方法）模式	186
12.8  参考资源	187
第13章  Pipeline（流水线）模式	188
13.1  Pipeline模式简介	188
13.2  Pipeline模式的架构	189
13.3  Pipeline模式实战案例解析	194
13.4  Pipeline模式的评价与实现考量	208
13.4.1  Pipeline的深度	209
13.4.2  基于线程池的Pipe	209
13.4.3  错误处理	212
13.4.4  可配置的Pipeline	212
13.5  Pipeline模式的可复用实现代码	212
13.6  Java标准库实例	222
13.7  相关模式	222
13.7.1  Serial Thread Confinement模式（第11章）	222
13.7.2  Master-Slave模式（第12章）	222
13.7.3  Composite模式	223
13.8  参考资源	223
第14章  Half-sync/Half-async（半同步/半异步）模式	224
14.1  Half-sync/Half-async模式简介	224
14.2  Half-sync/Half-async模式的架构	224
14.3  Half-sync/Half-async模式实战案例解析	226
14.4  Half-sync/Half-async模式的评价与实现考量	234
14.4.1  队列积压	235
14.4.2  避免同步层处理过慢	235
14.5  Half-sync/Half-async模式的可复用实现代码	236
14.6  Java标准库实例	240
14.7  相关模式	240
14.7.1  Two-phase Termination模式（第5章）	240
14.7.2  Producer-Consumer模式（第7章）	241
14.7.3  Active Object模式（第8章）	241
14.7.4  Thread Pool模式（第9章）	241
14.8  参考资源	241
第15章  模式语言	242
15.1  模式与模式间的联系	242
15.2  mmutable Object（不可变对象）模式	244
15.3  Guarded Suspension（保护性暂挂）模式	244
15.4  Two-phase Termination（两阶段终止）模式	245
15.5  Promise（承诺）模式	246
15.6  Producer-Consumer（生产者/消费者）模式	247
15.7  Active Object（主动对象）模式	248
15.8  Thread Pool（线程池）模式	249
15.9  Thread Specific Storage（线程特有存储）模式	250
15.10  Serial Thread Confinement（串行线程封闭）模式	251
15.11  Master-Slave（主仆）模式	252
15.12  Pipeline（流水线）模式	253
15.13  Half-sync/Half-async（半同步/半异步）模式	254
附录  本书常用UML图指南	255
A.1  UML简介	255
A.2  类图（Class Diagram）	256
A.1.1  类的属性、方法和立体型（Stereotype）	256
A.1.2  类与类之间的关系	258
A.3  序列图（Sequence Diagram）	261
参考文献	263
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程实战指南（设计模式篇）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高并发Oracle数据库系统的架构与设计
目　　录
推荐序一
推荐序二
前言
第一部分　内政篇
第1章　大道至简  2
1.1　初见高并发  2
1.1.1　从一次谈话说起  3
1.1.2　问题就在那里  4
1.1.3　你不是一个人在战斗  6
1.2　说句时髦话  8
1.2.1　谈谈去IOE  8
1.2.2　开源的作用域  9
1.3　在Oracle的世界里  10
1.3.1　数据库森林体系  10
1.3.2　大道至简  12
1.4　本章小结  13
第2章　高效B树索引  14
2.1　索引扫描识别  14
2.1.1　B树索引  15
2.1.2　全表扫描  16
2.1.3　ROWID扫描  17
2.1.4　索引唯一扫描  18
2.1.5　索引范围扫描  20
2.1.6　索引全扫描  21
2.1.7　索引快速全扫描  22
2.1.8　索引跳跃扫描  24
2.1.9　索引组合扫描  25
2.1.10　索引联立扫描  27
2.2　索引与排序  28
2.2.1　B树索引内部结构  28
2.2.2　输出排序  29
2.2.3　降序索引  34
2.2.4　聚合查询min()与max()  37
2.3　索引设计优化  40
2.3.1　索引选择度  40
2.3.2　数据分布的影响  41
2.3.3　索引聚簇因子  45
2.3.4　数据存储的影响  47
2.3.5　复合索引  50
2.3.6　索引被无视  54
2.4　索引分裂  58
2.4.1　分裂原理  59
2.4.2　实例分析  61
2.5　索引维护  70
2.5.1　为何重建索引  71
2.5.2　何时重建索引  73
2.5.3　如何重建索引  76
2.5.4　废旧索引清理  77
2.6　本章小结  78
第3章　高效表设计  79
3.1　数据生命周期管理  80
3.1.1　什么是数据生命周期管理  80
3.1.2　架构模型设计  81
3.1.3　数据分层存储  86
3.2　常用字段类型选择  87
3.2.1　VARCHAR2与CHAR  87
3.2.2　NUMBER与VARCHAR2  88
3.2.3　主键字段的选择  90
3.2.4　LOB字段  91
3.3　字段顺序  95
3.3.1　热字段靠前排  95
3.3.2　行宽需要控制  97
3.4　行链接与行迁移  99
3.4.1　行链接原理  99
3.4.2　行迁移原理  101
3.4.3　发现问题  101
3.4.4　解决问题  104
3.5　分区表的使用  105
3.5.1　何时使用分区表  105
3.5.2　分区表设计思路  106
3.5.3　分区表特性  106
3.6　适当的冗余  110
3.6.1　反范式建模  110
3.6.2　物化视图  113
3.6.3　结果集缓存  117
3.6.4　直接路径插入  120
3.7　碎片分析与整理  122
3.7.1　碎片的产生  123
3.7.2　DBMS_SPACE包  125
3.7.3　碎片的整理  130
3.8　本章小结  138
第4章　查询优化器  139
4.1　优化器概述  140
4.1.1　优化器简介  140
4.1.2　参数配置  143
4.2　像优化器一样思考  147
4.2.1　成本计算机制  147
4.2.2　成本计算公式推导  150
4.3　统计信息管理  155
4.3.1　统计信息分类  156
4.3.2　制定收集策略  158
4.3.3　管理收集方式  164
4.3.4　制定备份策略  168
4.3.5　收集直方图  174
4.4　执行计划管理  175
4.4.1　获取执行计划  175
4.4.2　固化执行计划  176
4.5　性能影响分析  183
4.6　数据库重放  188
4.6.1　普通数据库重放特性  188
4.6.2　强化数据库重放特性  193
4.7　本章小结  195
第5章　常见高并发案例  196
5.1　锁相关问题  196
5.1.1　Lock、Latch、Pin、Mutex  196
5.1.2　游标争用问题解决  198
5.1.3　索引争用问题解决  203
5.1.4　LOB争用问题解决  207
5.1.5　全表锁问题解决  213
5.2　REDO相关问题  214
5.2.1　REDO块的大小  214
5.2.2　DIO与AIO  218
5.2.3　进程优先级  219
5.2.4　log file sync分析  221
5.3　本章小结  222
第二部分　纵横篇
第6章　TimesTen内存数据库  224
6.1　TimesTen概述  225
6.1.1　TimesTen历史与定位  225
6.1.2　TimesTen应用场景  226
6.1.3　TimesTen技术架构  228
6.2　开始使用  233
6.2.1　TimesTen安装  233
6.2.2　参数配置  237
6.2.3　创建独立实例  239
6.2.4　创建缓存实例  241
6.3　缓存集合管理  242
6.3.1　只读缓存集合  244
6.3.2　AWT缓存集合  248
6.3.3　SWT缓存集合  251
6.3.4　自定义缓存集合  254
6.3.5　多表缓存集合  258
6.3.6　缓存老化  259
6.3.7　缓存过滤器  261
6.3.8　动态缓存集合  261
6.3.9　PassThrough属性  263
6.4　高可用复制架构  263
6.4.1　复制原理  264
6.4.2　ASP架构  266
6.5　高可用网格架构  273
6.5.1　无网格双活架构  274
6.5.2　网格双活架构  274
6.5.3　ASP网格双活架构  280
6.6　分库分表  283
6.6.1　只读缓存集合的分库分表  283
6.6.2　AWT缓存集合的分库分表  285
6.7　TimesTen设计与管理  286
6.7.1　表设计与管理  286
6.7.2　索引管理  291
6.7.3　统计信息与执行计划  294
6.8　TimesTen性能监控  299
6.8.1　关键指标  299
6.8.2　SQL监控  300
6.8.3　监控报告  302
6.8.4　复制监控  305
6.8.5　自动刷新监控  307
6.9　TimesTen备份与恢复  309
6.9.1　数据库备份  309
6.9.2　数据库恢复  311
6.9.3　数据迁移  313
6.10　TimesTen高并发场景  315
6.10.1　场景选择  316
6.10.2　并发场景测试  317
6.11　本章小结  318
第7章　GoldenGate构建数据库群  319
7.1　GoldenGate概述  319
7.1.1　小核心，大外围  320
7.1.2　GoldenGate应用场景  321
7.1.3　GoldenGate技术架构  323
7.1.4　数据库群的制约因素  328
7.2　开始使用  329
7.2.1　GoldenGate安装  329
7.2.2　GoldenGate配置  331
7.2.3　基本链路的搭建  334
7.2.4　GoldenGate的监控  339
7.3　高级应用  343
7.3.1　DDL功能支持  343
7.3.2　用户级复制  345
7.4　异构数据库群  347
7.4.1　异构字符集数据库间复制  347
7.4.2　异构数据库间复制  351
7.5　本章小结  353
第8章　Data Guard的妙用  354
8.1　“T-1”交易数据库  354
8.1.1　实现原理与应用场景  355
8.1.2　“T-1”备库简介  356
8.1.3　“T-1”库闪回简介  357
8.1.4　“T-1”数据库搭建  358
8.2　ADG实现读写分离  361
8.2.1　ADG架构简介  361
8.2.2　ADG数据库搭建  362
8.3　本章小结  365
第9章　最佳实践  366
9.1　术  366
9.1.1　技术回顾  367
9.1.2　规矩方圆  369
9.1.3　穿越之眼  370
9.2　道  370
9.2.1　数据库架构师  370
9.2.2　沟通之道  371
9.3　势  374
9.4　本章小结  375
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高并发Oracle数据库系统的架构与设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>并发与实时系统软件设计
第I部分 概念
第1章 总述

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>并发与实时系统软件设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机规范（Java SE 8版）
译者序
前　言
第1章　引言1
1.1　简史1
1.2　Java虚拟机2
1.3　各章节摘要2
1.4　说明3
1.5　反馈3
第2章　Java虚拟机结构4
2.1　class文件格式4
2.2　数据类型5
2.3　原始类型与值5
2.3.1　整数类型与整型值6
2.3.2　浮点类型、取值集合及浮点值6
2.3.3　returnAddress类型和值8
2.3.4　boolean类型8
2.4　引用类型与值9
2.5　运行时数据区9
2.5.1　pc寄存器9
2.5.2　Java虚拟机栈10
2.5.3　Java堆10
2.5.4　方法区11
2.5.5　运行时常量池11
2.5.6　本地方法栈12
2.6　栈帧12
2.6.1　局部变量表13
2.6.2　操作数栈14
2.6.3　动态链接14
2.6.4　方法调用正常完成15
2.6.5　方法调用异常完成15
2.7　对象的表示15
2.8　浮点算法15
2.8.1　Java虚拟机和IEEE 754中的浮点算法15
2.8.2　浮点模式16
2.8.3　数值集合转换17
2.9　特殊方法18
2.10　异常19
2.11　字节码指令集简介20
2.11.1　数据类型与Java虚拟机21
2.11.2　加载和存储指令23
2.11.3　算术指令24
2.11.4　类型转换指令25
2.11.5　对象的创建与操作27
2.11.6　操作数栈管理指令27
2.11.7　控制转移指令27
2.11.8　方法调用和返回指令28
2.11.9　抛出异常28
2.11.10　同步28
2.12　类库29
2.13　公有设计、私有实现30
第3章　Java虚拟机编译器31
3.1　示例的格式说明31
3.2　常量、局部变量和控制结构的使用32
3.3　算术运算36
3.4　访问运行时常量池36
3.5　与控制结构有关的更多示例37
3.6　接收参数40
3.7　方法调用41
3.8　使用类实例43
3.9　数组44
3.10　编译switch语句46
3.11　使用操作数栈48
3.12　抛出异常和处理异常48
3.13　编译finally语句块51
3.14　同步54
3.15　注解55
第4章　class文件格式56
4.1　ClassFile结构57
4.2　各种名称的内部表示形式61
4.2.1　类和接口的二进制名称61
4.2.2　非限定名61
4.3　描述符62
4.3.1　语法符号62
4.3.2　字段描述符62
4.3.3　方法描述符63
4.4　常量池64
4.4.1　CONSTANT_Class_info结构65
4.4.2　CONSTANT_Fieldref_info、CONSTANT_Methodref_info和CONSTANT_InterfaceMethodref_info结构66
4.4.3　CONSTANT_String_info结构67
4.4.4　CONSTANT_Integer_info和CONSTANT_Float_info结构67
4.4.5　CONSTANT_Long_info和CONSTANT_Double_info结构68
4.4.6　CONSTANT_NameAnd-Type_info结构69
4.4.7　CONSTANT_Utf8_info结构70
4.4.8　CONSTANT_MethodHandle_info结构72
4.4.9　CONSTANT_MethodType_info结构73
4.4.10　CONSTANT_Invoke-Dynamic_info结构74
4.5　字段74
4.6　方法76
4.7　属性78
4.7.1　自定义和命名新的属性82
4.7.2　ConstantValue属性82
4.7.3　Code属性83
4.7.4　StackMapTable属性86
4.7.5　Exceptions属性92
4.7.6　InnerClasses属性93
4.7.7　EnclosingMethod属性95
4.7.8　Synthetic属性96
4.7.9　Signature属性96
4.7.10　SourceFile属性100
4.7.11　SourceDebugExtension属性101
4.7.12　LineNumberTable属性102
4.7.13　LocalVariableTable属性103
4.7.14　LocalVariableTypeTable属性104
4.7.15　Deprecated属性106
4.7.16　RuntimeVisibleAnnota-tions属性106
4.7.17　RuntimeInvisible-Annotations属性110
4.7.18　RuntimeVisibleParameterAnnotations属性111
4.7.19　RuntimeInvisiblePara-meterAnnotations属性112
4.7.20　RuntimeVisibleTypeAnnotations属性114
4.7.21　RuntimeInvisibleType-Annotations属性124
4.7.22　AnnotationDefault属性125
4.7.23　BootstrapMethods属性126
4.7.24　MethodParameters属性127
4.8　格式检查129
4.9　Java虚拟机代码约束129
4.9.1　静态约束130
4.9.2　结构化约束132
4.10　class文件校验135
4.10.1　类型检查验证136
4.10.2　类型推导验证200
4.11　Java虚拟机限制206
第5章　加载、链接与初始化208
5.1　运行时常量池208
5.2　虚拟机启动210
5.3　创建和加载211
5.3.1　使用引导类加载器来加载类型212
5.3.2　使用用户自定义类加载器来加载类型212
5.3.3　创建数组类213
5.3.4　加载限制214
5.3.5　从class文件表示得到类214
5.4　链接215
5.4.1　验证216
5.4.2　准备216
5.4.3　解析217
5.4.4　访问控制225
5.4.5　方法覆盖225
5.5　初始化226
5.6　绑定本地方法实现228
5.7　Java虚拟机退出228
第6章　Java虚拟机指令集229
6.1　设定：“必须”的含义229
6.2　保留操作码229
6.3　虚拟机错误230
6.4　指令描述格式230
6.5　指令集描述232
第7章　操作码助记符320
附录A　Limited License Grant327
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机规范（Java SE 8版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>糖尿病并发症饮食疗法
第1章  糖尿病的一般知识  糖尿病是一种什么亲的疾病？  什么是血糖？正常值是多少？  血粮的来源有哪些？  正常人的血粮有哪些去路？  血液中的葡萄糖有什么用途？  胰岛素的分泌与糖尿病的发生有什么关系？  胰岛素在体内起什么作用？  糖尿病有几种类型？  什么叫原发性糖尿病？  什么叫继发性糖尿病？  1 型糖尿病的特点是什么？  2 型糖尿病的特点是什么？  糖尿病发病原因有哪些？  糖尿病的诱发因素有哪些？  怎样早期诊断糖尿病？  为什么有的糖尿病患者没有自觉症状？  糖尿病的主要症状有哪些？……第2章  糖尿病饮食治疗基础第3章  各类食物营养素与糖尿病第4章  糖尿病发并症概述第5章  糖尿病性脑血管病第6章  糖尿病性高血压第7章  糖尿病性高脂血症第8章  糖尿病性心脏病第9章  糖尿病性神经病变第10章  糖尿病性癫阐第11章  糖尿病与失眠症第12章  糖尿病性肾病第13章  糖尿病与泌尿系感染第14章  糖尿病与外阴炎第15章  糖尿病性阳萎第16章  糖尿病与性冷淡第17章  糖尿病与胃病第18章  糖尿病性肠病第19章  糖尿病与肝病第20章  糖尿病足第21章  糖尿病并发感冒第22章  糖尿病并发气管炎第23章  糖尿病并发肺炎第24章  糖尿病并发肺结核第25章  糖尿病并发眼病第26章  糖尿病并发口腔疾病第27章  糖尿病并发皮肤病第28章  糖尿病性骨病第29章  糖尿病并发甲亢
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>糖尿病并发症饮食疗法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>糖尿病并发症的防与治
前言
译者的话
第一章  得了糖尿病我该怎么办？
1、我是否应向我的上司和同事诉说我患有糖尿病？
2、我是否会从别人身上传染上糖尿病？
3、我们离治愈糖尿病还有多远？
4、糖尿病是否会对发育中的甲状腺产生危险？
5、通过看医生，我怎样才能了解更多的情况？
6、为保持健康我应安排多长时间去就医？
7、我的

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>糖尿病并发症的防与治
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>如何防治糖尿病并发症
戴序
谢序
自序
第一篇 关于糖尿病
第二篇 急性并发症――低血糖
第三篇 急性并发症――酮症酸中毒
第四篇 急性并发症――高渗性非酮症糖尿病昏迷
第五篇 急性并发症――乳酸性酸中毒
第六篇 大血管并发症――脑中风
……
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>如何防治糖尿病并发症
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>肿瘤并发症的诊断与治疗
第1章 肿瘤治疗概论
第一节 肿瘤外科治疗原则及其并发症防治
一、手术医源性播散的预防
二、原发灶的切除
三、淋巴结清扫
四、肿瘤外科的综合治疗
第二节 肿瘤外科手术治疗
一、预防性手术
二、诊断性手术
三、治愈性手术
四、姑息性手术
五、肿瘤减量手术
六、复发瘤手术
七、转移瘤的手术
第三节 肿瘤的放射治疗
一、放射治疗的原则和实施计划
二、放射治疗的适应证和禁忌证
三、放射治疗的照野以及剂量
四、放射治疗方式
五、放射综合治疗的临床应用
六、放射治疗在肿瘤并发症治疗中的应用
七、放射治疗的时间一剂量因素
第四节 肿瘤的化学治疗
一、肿瘤化疗概述
二、肿瘤化疗基础
三、临床化疗原则
四、常用抗肿瘤药物的不良反应和注意事项
五、抗肿瘤药物安全应用
第五节 肿瘤的介入治疗
一、介入放射学概述
二、介入放射学的学科分类
三、介入放射学技术
四、肿瘤介入放射学
第六节 肿瘤的传统中医药治疗
一、肿瘤的中医命名
二、中医对肿瘤病因病机的认识
三、中医肿瘤的病机
四、肿瘤中医治则
第七节 肿瘤的中医药疗法及其并发症
一、针灸
二、其他中医治疗
三、中药内外治法
第八节 原发部位不明的转移癌的诊治
一、概述
二、肿瘤转移的一般规律
三、临床检查手段的作用与局限性
四、浅表部位的MCU0
五、内脏器官的MCU0
第九节 肿瘤并发症的分类
一、按照发病机制分类
二、按照肿瘤并发症所累及的系统分类
三、按照肿瘤并发症产生的时间分类
四、按并发症的主要临床表现分类
第2章 常用抗肿瘤药物的不良反应
和并发症
第一节 杭肿瘤药物的分类
一、抗肿瘤药物的传统分类
二、新的药物分类
第二节 抗肿瘤药物的不良反应
第三节 抗肿瘤药物的特殊不良反应及注意事项
一、烷化剂
二、抗代谢药物
三、抗肿瘤抗生素
四、抗肿瘤植物类药
五、重金属及其他杂类
六、激素类
七、抗肿瘤相关药物
第3章 肿瘤疼痛综合征
第一节 概述
第二节 肿瘤疼痛的生理与心理机制
一、痛觉的外周机制
二、中枢神经系统对疼痛的调制
三、有关痛觉学说
四、疼痛的心理机制
第三节 肿瘤性疼痛的病因与临床表现
一、肿瘤直接引起的疼痛
(一)骨骼的浸润和转移
(二)神经系统受累
(三)内脏器官受累
二、肿瘤诊断引起的疼痛
三、肿瘤治疗引起的疼痛
(一)术后疼痛综合征
(二)化疗后疼痛综合征
(三)放疗后疼痛综合征
(四)其他治疗引起的疼痛
四、与肿瘤间接有关的疼痛
五、与肿瘤无关的伴发症
六、精神与心理因素
第四节 疼痛的诊断与鉴别诊断
一、病史、体检和辅助检查
二、诊断
第五节 肿瘤疼痛的放疗和化学治疗
一、放射治疗
二、同位素治疗
三、化学治疗
第六节 肿瘤疼痛的内分泌治疗
一、乳腺癌的内分泌治疗
二、前列腺癌的内分泌治疗
三、子宫内膜癌
四、卵巢癌的内分泌治疗
五、甲状腺癌
六、肾癌
七、恶性黑色素瘤
第七节 肿瘤三阶梯止痛药物治疗
一、非甾体类消炎止痛药(NSAID)
二、麻醉性止痛药
三、使用止痛药的原则
四、止痛治疗中注意事项
五、辅助性止痛药
六、癌痛治疗的常见误区
七、老年人用药的注意事项
八、儿童病人的镇痛治疗原则
第八节 肿瘤疼痛的中医中药治疗
一、中药止痛
二、针刺止痛
第九节 肿瘤疼痛的神经电刺激和消融治疗
一、经皮神经电刺激止痛
二、神经阻滞治疗
三、手术止痛
(一)神经外科手术
(二)骨科手术
第十节 肿瘤疼痛的心理行为治疗
一、心理咨询
二、认知－行为治疗
第4章 肿瘤食欲缺乏－恶病质综合征和营养支持治疗
第一节 CACS发病机制
一、肿瘤及抗肿瘤治疗影响食物的摄入与吸收
二、肿瘤消耗宿主的营养
三、肿瘤及宿主的生物活性物质对食欲、代谢的干扰
四、心理因素与习得性厌食
第二节 CACS临床表现
一、营养不良的分类
二、营养不良的程度
三、营养不良的特殊体征
第三节 CACS诊断与鉴别诊断
一、诊断
二、鉴别诊断
第四节 CACS治疗
一、一般处理
二、药物治疗
第五节 肿瘤病人的胃肠外营养支持治疗
一、胃肠外用的营养物质
二、营养液配方
三、胃肠外营养适应证与禁忌证
四、静脉营养途径
五、胃肠外营养监测
第六节 全胃肠外营养支持治疗的并发症和处理
一、与导管有关的并发症
二、感染并发症
三、代谢并发症
(一)糖代谢紊乱
(二)必需脂肪酸缺乏症
(三)与输注氨基酸液有关的代谢异常
(四)电解质及酸碱平衡紊乱
(五)微量元素缺乏症
(六)维生素缺乏症
(七)丁PN的其他并发症
第七节 肿瘤病人的肠内营养
一、肠道的营养吸收
二、肠内营养支持
三、肠内营养素的成分
四、肠内营养配方的选择
五、肠内营养的适应证
六、肠内营养的输入途径
七、肠内营养的投给方式
八、肠内营养的并发症及其防治
九、肠内营养的监测
十、肠内营养的护理
第5章 异位激素综合征与内分泌代谢性紊乱
第一节 高钙血症
一、发病机制
二、临床表现
三、诊断与鉴别诊断
四、治疗
(一)高钙血症的治疗原則
(二)药物性降钙的治疗原則
(三)高钙血症的具体治疗措施
第二节 异位促肾上腺皮质激素综合征与低钾血症
一、病因以及发病机制
二、临床表现
三、诊断
四、鉴别诊断
五、治疗
第三节 抗利尿激素分泌异常综合征与低钠血症
一、病因以及发病机制
二、临床表现与特点
三、诊断
四、鉴别诊断
五、治疗
第四节 低血糖症
一、发病机制
二、临床表现
三、诊断与鉴别诊断
四、治疗
第五节 嗜铬细胞瘤危象
一、病因及病理
二、临床表现
三、诊断
四、治疗
第六节 肾上腺危象
一、病因
二、诱发因素
三、临床表现
四、实验室检查
五、治疗
第七节 类癌综合征
一，病理
二、临床表现
三、诊断与鉴别诊断
四、治疗
第八节 低镁血症
一、病因
二、临床表现
三、治疗
第九节 高尿酸血症
一、病因及发病机制
二、临床表现
三、诊断与鉴别诊断
四、治疗
第十节 肿瘤溶解综合征
一、病因
二、病理生理
三、临床表现
四、诊断
五、治疗
第十一节 乳酸中毒症
一、病因及发病机制
二、临床表现
三、诊断
四、治疗
第6章 肿瘤的血液系统并发症
第一节 红细胞增多症
一、发病概述
二、发病机制
三、诊断
四、治疗
第二节 贫血
一、概述
二、发病机制与分类
三、临床表现与诊断
四、治疗
第三节 肿瘤性白细胞增多症
一、白细胞增多的原因与分类
二、诊断与鉴别诊断
三、治疗
第四节 白细胞减少症与粒细胞缺乏症
一、病因
二、临床表现
三、治疗
第五节 发热性中性粒细胞减少症
一、发热性中性粒细胞减少症的病因学
二、发热性中性粒细胞减少症的评估
三、发热性中性粒细胞减少症的治疗
第六节 肿瘤性血小板增多症
一、病因
二、临床表现
三、治疗
第七节 肿瘤性血小板减少症
一、病因以及发病机制
二、临床表现与诊断
三、治疗
第八节 血栓形成以及栓塞性事件
……
第7章 神经系统并发症
第8章 心血管系统并发症
第9章 呼吸系统并发症
第10章 消化系统并发症
第11章 泌尿系统并发症
第12章 骨及骨关节肿瘤并发症
第13章 肿瘤的皮肤肌肉并发症以及风湿症候群
第14章 肿瘤放射治疗并发症
第15章 肿瘤生物治疗的并发症
第16章 化学治疗的远期并发症
第17章 肿瘤介入治疗并发症
第18章 肿瘤诊疗新技术的临床
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>肿瘤并发症的诊断与治疗
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>骨科治疗方法选择与并发症防治
第一章  总论
第一节 骨科疾病的诊断与鉴别诊断
第二节 骨折与脱位的治疗方案选择原则
第三节 骨科非创伤性疾病治疗方案的选择
第四节 骨肿瘤治疗方案的选择原则
第五节 骨科疾病常见并发症的防治
第六节 骨科疾病的抗生素选择应用
第二章  颈肩部损伤与疾病
第一节 颈部损伤与疾病
第二节 肩部损伤与疾病
第

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>骨科治疗方法选择与并发症防治
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>糖尿病并发症防治学
目 录
上篇 糖尿病并发症
总 论
一、概况
二、糖尿病并发症的病因与病机
三、糖尿病并发症的分类
四、糖尿病并发症的防治
五、糖尿病并发症的预后
各 论
第一章 神经系统糖尿病并发症
第一节 糖尿病脑血栓
第二节 糖尿病脑动脉硬化症
第三节 糖尿病脑出血
第四节 糖尿病帕金森病综合征
第五节 糖尿病短暂脑缺血发作
第六节 糖尿病多发性末梢神经炎
第七节 糖尿病性耳聋
第八节 糖尿病自主神经功能障碍
第九节 糖尿病脑水肿
第二章 心血管系统糖尿病并发症
第一节 糖尿病冠心病
第二节 糖尿病心肌梗死
第三节 糖尿病心肌病
第四节 糖尿病心脏骤停
第五节 糖尿病高血压
第三章 消化系统糖尿病并发症
第一节 糖尿病胃肠病
第二节 糖尿病脂肪肝
第三节 糖尿病胆石症与胆系感染
第四章 血液系统糖尿病并发症
第一节 糖尿病性贫血
第二节 糖尿病血小板异常
第三节 糖尿病白细胞功能低下
第五章 泌尿系统糖尿病并发症
第一节 糖尿病尿路系统感染
第二节 糖尿病肾病
第三节 糖尿病尿路结石
第四节 糖尿病肾功能衰竭
第五节 糖尿病膀胱功能障碍
第六章 内分泌代谢系统糖尿病并发症
第一节 糖尿病酮症酸中毒
第二节 糖尿病高渗性非酮症性昏迷
第三节 糖尿病乳酸酸中毒
第四节 糖尿病低钠血症
第五节 糖尿病高钠血症
第六节 糖尿病低钾血症
第七节 糖尿病高钾血症
第八节 糖尿病低钙血症
第九节 糖尿病高钙血症
第十节 糖尿病低磷血症
第十一节 糖尿病高磷血症
第十二节 糖尿病低镁血症
第十三节 糖尿病低钒血症
第十四节 糖尿病高铁血症与血色病综合征
第十五节 糖尿病甲亢联合病
第十六节 糖尿病低血糖昏迷
第十七节 糖尿病多系统多器官衰竭综合征
第七章 呼吸系统糖尿病并发症
第一节 糠尿病睡眠呼吸停顿综合征
第二节 糖尿病支气管炎
第三节 糖尿病肺结核
第八章 运动系统糖尿病并发症
第一节 糖尿病骨病
第二节 糖尿病骨关节病
第三节 糖尿病肢端坏疽
第四节 糖尿病肌病
第九章 皮肤粘膜系统糖尿病并发症
第一节 糖尿病水疱病
第二节 糖尿病皮肤色素沉着症
第三节 糖尿病皮肤瘙痒症
第四节 糖尿病会阴瘙痒症
第五节 糖尿病类脂质渐进性坏死
第六节 糖尿病环状肉芽肿
第七节 糖尿病硬皮病
第八节 糖尿病黄瘤病
第九节 糖尿病疖肿
第十节 糖尿病痛
第十一节 糖尿病皮肤蜂窝织炎
第十二节 糖尿病皮肤粘膜白色念球菌感染
第十三节 糖尿病手足癣
第十四节 糖尿病甲癣
第十五节 糖尿病黑棘皮病
第十章 生殖系统糖尿病并发症
第一节 糖尿病性功能低下
第二节 糖尿病阳痿
第三节 糖尿病月经失调
第四节 糖尿病不孕症
第十一章 视觉系统糖尿病并发症
第一节 眼睑病变
第二节 结膜病变
第三节 角膜病变
第四节 虹膜睫状体病变
第五节 糖尿病与眼压
第六节 晶状体病变
第七节 玻璃体病变
第八节 视网膜病变
第九节 视神经病变
第十节 眼肌病变
第十一节 屈光不正
第十二节 糖尿病性眼综合征
第十二章 口腔系统糖尿病并发症
第一节 糖尿病牙槽骨骨质疏松
第二节 糖尿病牙周感染
第三节 糖尿病牙齿松动
第十三章 糖尿病并发症的预测预报
第一节 糖尿病并发症的预测预报
第二节 糖尿病并发症监测
第三节 糖尿病并发症预测目的和效益
下篇 糖 尿 病
第一章 糖尿病发生学
第一节 糖尿病的遗传学
第二节 糖尿病的自身免疫学
第三节 糖尿病与病毒感染
第二章 糖尿病的病理生理
第一节 胰岛的病理生理
第二节 “三高现象”连锁反应
第三节 静脉回流功能障碍
第四节 细胞膜功能异常
第五节 血流动力学与微循环的变化
第六节 血氧分压的降低
第三章 糖尿病的症状学
第一节 糖尿病的分类与分型
第二节 糖尿病不同类型的临床特点
第三节 糖尿病的症状
第四章 糖尿病实验室检查
第一节 尿液检查
第二节 血液检查
第五章 糖尿病诊断学
第一节 诊断的依据和标准
第二节 糖尿病的鉴别诊断
第六章 糖尿病的治疗
第一节 糖尿病治疗原理
第二节 糖尿病治疗的方式与步骤
第三节 糖尿病药物治疗
第四节 糖尿病用药的选择与评价
第五节 糖尿病胰岛素治疗
第六节 饮食控制疗法
第七节 运动疗法
第七章 糖尿病的护理
第一节 基础护理
第二节 生活护理
第三节 精神心理护理
第四节 饮食护理
第五节 运动护理
第六节 危重病人护理
第八章 糖尿病的预防
第一节 预防原理
第二节 预防措施
第三节 糖尿病预防的评价与未来
第九章 糖尿病的预后
第一节 糖尿病预后与各种因素的关系
第二节 中医对糖尿病预后评述
第三节 糖尿病预后分析
第四节 糖尿病预后展望
第十章 糖尿病与妊娠
第一节 妊娠期生理学相关特点
第二节 糖尿病对妊妇和胎儿的影响
第三节 妊娠对糖尿病患者的影响
第四节 糖尿病妊娠的调理与治疗
第十一章 糖尿病与肥胖症
第一节 肥胖的基本概念
第二节 肥胖的原因
第三节 脂肪分布与肥胖类型
第四节 糖尿病与肥胖症的关系
第五节 肥胖症的防治
第十二章 糖尿病与控制论
第一节 黑箱理论与糖尿病
第二节 信息论与糖尿病
第三节 同构论与糖尿病
附录
一 食物成分表
二、食品交换份营养成分表
三、激素的放射免疫分析
英中对照

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>糖尿病并发症防治学
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>恶性肿瘤并发症
目录
第一章 心血管系统
第一节 心包填塞
第二节 上腔静脉综合征
第二章 血液系统
第一节 贫血
第二节 红细胞增多症
第三节 白细胞和粒细胞减少症
第四节 白细胞增多症
第五节 血液肿瘤的特殊并发症
第六节 血小板减少症
第七节 血小板增多症
第八节 血栓性静脉炎
第九节 弥漫性血管内凝血
第十节 血液肿瘤的其他并发症
第三章 呼吸系统
第一节 肺部机会性感染
第二节 肺部白细胞淤积征
第三节 癌性淋巴管炎
第四节 大咯血
第五节 气道阻塞
第六节 恶性胸腔积液
第四章 消化系统
第一节 中性粒细胞减少性小肠结肠炎
第二节 白血病并发阑尾炎
第三节 肠梗阻
第四节 肿瘤转移性胆道梗阻
第五节 胃肠道出血及穿孔
第六节 恶性腹水
第五章 泌尿系统
第一节 对泌尿系统的直接影响
第二节 对泌尿系统的间接影响
第六章 骨骼系统
第一节 癌的骨转移
第二节 骨畸形和骨矿物质代谢异常
第七章 神经系统
第一节 颅内转移癌
第二节 脊柱转移癌
第三节 癌性疼痛
第八章 内分泌系统
第一节 癌外综合征
第二节 异位激素分泌综合征
第九章 代谢系统
第一节 高钙血症
第二节 肿瘤溶解综合征
第三节 高尿酸血症及尿酸性肾病
第四节 低血糖症
第五节 乳酸中毒症
第十章 癌症病人的营养性并发症
第一节 癌症病人的营养不良
第二节 治疗期间的营养性并发症
第三节 营养的估价
第四节 营养支持治疗
第十一章 恶性肿瘤的特殊感染和肿瘤性发热
第一节 内脏的细菌和真菌感染
第二节 病毒和囊虫感染
第三节 肿瘤性发热
第十二章 癌的其他并发症
第一节 癌的皮肤表现及皮肤并发症
第二节 肥大性肺性骨关节病
第三节 神经肌肉病变
第四节 眼的并发症与继发症
第十三章 化疗的急性并发症
第一节 化疗对造血系统的毒性
第二节 变态性反应
第三节 药物外渗
第四节 腹腔内化疗的并发症
第五节 动脉灌注化疗的并发症
第六节 化疗药物对主要脏器的毒性表现
第十四章 化疗的远期并发症
第一节 内分泌腺的并发症
第二节 其它系统并发症
第三节 化疗后第二肿瘤发生
第十五章 放射治疗的并发症
第一节 神经系统并发症
第二节 心肺并发症
第三节 消化道并发症
第四节 泌尿生殖道并发症
第五节 内分泌腺并发症
第六节 其它并发症
第十六章 生物反应调节剂的毒副作用
第一节 细胞因子的毒副作用
第二节 细胞转输技术的并发症
第三节 单克隆抗体及其它生物制剂的并发症
第十七章 输血及器官移植的并发症
第一节 输血与癌症复发
第二节 骨髓移植的并发症
第三节 器官移植与癌发生
附录一 卡劳夫斯基（Karnofsky）病人一般状况评价表
附录二 抗癌药急性及亚急性毒性反应分度标准（WHO标准）

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>恶性肿瘤并发症
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>耳鼻咽喉手术并发症及知情同意要点
第一章  耳科手术部分／1  第一节  外耳手术／2    一、外耳手术／2    二、外耳手术并发症／2    三、减少或避免手术并发症的注意要点／6    四、手术知情同意要点／7  第二节  鼓膜切开置管术／7    一、鼓膜切开置管术并发症／8    二、减少或避免手术并发症的注意要点／17    三、手术知情同意要点／18  第三节  鼓膜成形术(鼓膜修补术)／22    一、鼓膜成形术并发症／22    二、减少或避免手术并发症的注意要点／29    三、手术知情同意要点／30  第四节  鼓室成形术／32    一、鼓室成形术并发症／32    二、减少或避免手术并发症的注意要点／46    三、手术知情同意要点／48  第五节  乳突手术／51    一、乳突手术并发症／51    二、减少或避免手术并发症的注意要点／95    三、手术知情同意要点／96第二章  鼻科手术部分／105  第一节  上颌窦穿刺术／106    一、上颌窦穿刺术并发症／106    二、减少或避免手术并发症的注意要点／115    三、手术知情同意要点／116  第二节  鼻腔填塞／117    一、关于鼻腔填充材料／118    二、鼻腔填塞并发症／119    三、减少或避免鼻腔填塞并发症的注意要点／132    四、手术知情同意要点／132  第三节  下鼻甲手术／136    一、治疗慢性鼻炎的方法及其并发症／136    二、下鼻甲手术并发症／142    三、减少或避免手术并发症的注意要点／150    四、手术知情同意要点／151  第四节  鼻中隔出血凝固术／154    一、鼻中隔出血凝固术并发症／154    二、减少或避免手术并发症的注意要点／156    三、手术知情同意要点／156  第五节  隆鼻术／157    一、关于隆鼻术的填塞材料／157    二、液态硅胶注射手术并发症／160    三、固体硅橡胶隆鼻术并发症／162    四、减少或避免手术并发症的注意要点／172    五、手术知情同意要点／174  第六节  鼻中隔手术／176    一、有关鼻内镜下鼻中隔手术／176    二、鼻中隔手术并发症／179    三、减少或避免手术并发症的注意要点／190    四、手术知情同意要点／191  第七节  上颌窦根治术／194    一、对上颌窦根治术的认识／194    二、上颌窦根治术并发症／199    三、减少或避免手术并发症的注意要点／226    四、手术知情同意要点／227  第八节  鼻内镜鼻窦手术／232    一、与鼻内镜鼻窦手术并发症相关的因素／233    二、鼻内镜鼻窦手术并发症／234    三、减少或避免手术并发症的注意要点／256    四、手术知情同意要点／257第三章  咽腔手术部分／265  第一节  扁桃体切除术／266    一、扁桃体切除术并发症／266    二、减少或避免手术并发症的注意要点／295    三、手术知情同意要点／296  第二节  腺样体切除术／301    一、腺样体切除术并发症／302    二、鼻内镜下吸切器切除腺样体的优缺点／302    三、鼻内镜下吸切器或传统方法腺样体切除术并发症／306    四、减少或避免手术并发症的注意要点／310    五、手术知情同意要点／310  第三节  腭咽成形术／313    一、腭咽成形术并发症／314    二、减少或避免手术并发症的注意要点／331    三、手术知情同意要点／332  第四节  茎突截短术／335    一、与茎突截短术并发症相关的问题／335    二、颈外入路茎突截短术并发症／338    三、口内入路茎突截短术并发症／339    四、减少或避免手术并发症的注意要点／342    五、手术知情同意要点／343第四章  喉及颈部手术部分／347  第一节  支撑喉镜声带手术／348    一、不同声带病变切除手术方法及其并发症／348    二、支撑喉镜声带手术并发症／351    三、减少或避免手术并发症的注意要点／366    四、手术知情同意要点／367  第二节  会厌囊肿切除术／370    一、会厌囊肿切除术并发症／371    二、减少或避免手术并发症的注意要点／374    三、手术知情同意要点／374  第三节  甲状舌管囊肿切除术／375    一、甲状舌管囊肿切除术并发症／376    二、减少或避免手术并发症的注意要点／396    三、手术知情同意要点／397  第四节  气管切开术／400    一、关于经皮扩张气管切开术并发症／401    二、气管切开手术并发症／402    三、减少或避免手术并发症的注意要点／429    四、手术知情同意要点／430后序／435
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>耳鼻咽喉手术并发症及知情同意要点
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>妇科腹腔镜手术并发症防治
第一章  妇科腹腔镜手术的发展进程  第一节  腹腔镜计算机处理系统建立  第二节  妇科腹腔镜手术应用的进展  第三节  妇科腹腔镜手术的基础研究进展第二章  妇科腹腔镜手术器械的基本配套与选择  第一节  腹腔镜的选择  第二节  全自动气腹机  第三节  冲吸系统  第四节  腹腔镜手术操作器械配件第三章  妇科腹腔镜手术能源的选择与应用技巧  第一节  电外科器械临床的应用与技巧  第二节  超声刀  第三节  结扎速血管闭合系统第四章  腹腔镜下女性盆腹腔解剖  第一节  腹壁的镜下解剖  第二节  腹膜的镜下解剖  第三节  女性内生殖器官的镜下解剖第五章  腹腔镜术前准备与术后监护  第一节  腹腔镜手术前准备  第二节  腹腔镜手术后监护第六章  CO2气腹的病理生理  第一节  腹腔镜气腹的发展史  第二节  CO2的生理特性  第三节  CO2气腹对人体功能的影响第七章  腹膜外气肿与气体栓塞的防治  第一节  腹膜外气肿的预防与治疗  第二节  空气栓塞的预防与治疗第八章  腹腔镜手术泌尿系统损伤与防治  第一节  概述  第二节  腹腔镜下泌尿系统的解剖  第三节  膀胱损伤的防治  第四节  输尿管损伤的防治第九章  腹腔镜手术消化道损伤与防治  第一节  概述  第二节  消化系统的镜下解剖  第三节  胃损伤的防治  第四节  小肠损伤的防治  第五节  大肠损伤的防治第十章  腹腔镜手术血管损伤与出血的防治  第一节  概述  第二节  盆腹腔血管系统的镜下解剖  第三节  盆腹腔淋巴系统的镜下解剖  第四节  腹壁血管损伤与出血的防治  第五节  盆腔血管损伤与出血的防治  第六节  腹膜后血管损伤的防治第十一章  腹腔镜手术神经系统的损伤与防治  第一节  简述  第二节  腰丛神经损伤  第三节  骶丛神经损伤  第四节  臂丛神经损伤  第五节  盆丛神经损伤  第六节  腹腔镜术后疼痛第十二章  腹腔镜手术异物遗留的处理与防治  第一节  简述  第二节  器械遗留  第三节  缝针遗留  第四节  节育环遗留腹腔  第五节  组织物遗留腹腔第十三章  腹腔镜手术感染的防治  第一节  简述  第二节  腹腔镜手术伤口感染  第三节  阴道残端感染  第四节  下肢血栓性静脉炎第十四章  腹腔镜手术卵巢损伤的防治  第一节  卵巢的生理解剖与功能  第二节  手术对卵巢功能的影响  第三节  卵巢功能损伤的原因  第四节  卵巢功能损伤的临床表现  第五节  卵巢功能损伤的治疗  第六节  卵巢功能损伤的预防第十五章  腹腔镜手术其他并发症的处理与防治  第一节  皮肤损伤的处理与防治  第二节  皮下出血的处理与防治  第三节  阴道壁撕裂伤的处理与防治  第四节  术后腹水的处理与防治  第五节  恶性肿瘤漏诊的处理与防治第十六章  妇科腹腔镜手术医师的技能培训  第一节  妇科腹腔镜医师培训的必要性  第二节  妇科腹腔镜技术培训的基本要求  第三节  妇科腹腔镜医师培训的方式与内容第十七章  腹腔镜手术并发症与医患沟通  第一节  腹腔镜手术与医患沟通的意义  第二节  医患关系紧张的原因  第三节  医患沟通技巧  第四节  腹腔镜手术并发症与医疗纠纷防范后语
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>妇科腹腔镜手术并发症防治
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实用肿瘤并发症诊断治疗学
第一章 概述
第二章 癌症疼痛综合征
第三章 化疗引起的恶心与呕吐
第四章 肿瘤食欲不振-恶病质综合征
第五章 异位激素综合征与代谢紊乱
第六章 肿瘤的血液系统并发症
第七章 神经系统并发症
第八章 心血管并发症
第九章 呼吸系统并发症
第十章 消化系统并发症
第十一章 泌尿系统并发症
第十二章 肿瘤骨转移与脊髓压迫症
第十三章 肿瘤的眼部并发症
第十四章 肿瘤的皮肤并发症及风湿症候群
第十五章 肿瘤病人的发热
第十六章 原发部位不明的转移癌
第十七章 放射治疗并发症
第十八章 肿瘤生物治疗的并发症
第十九章 化学治疗的远期并发症
第二十章 肿瘤病人的心理及精神病学问题
……
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实用肿瘤并发症诊断治疗学
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>糖尿病并发症防治
一、糖尿病并发症的一般知识
什么是糖尿病并发症？
为什么说糖尿病本身并不可怕，可怕的是其并发症？
我国糖尿病并发症的发病情况如何？
糖尿病并发症都有哪些？
糖尿病并发症有哪些危险因素？
糖尿病急性并发症有哪些？
糖尿病慢性并发症有哪些？
何谓糖尿病性大血管病变？
何谓糖尿病性微血管病变？
患了糖尿病心跳快是怎么回事？
站起来时头晕是怎么回事？
手脚发麻提示什么？
我的脚痛手麻，吃了药也不管用，该怎么办呀？
为何糖尿病患者易出汗？
糖尿病患者为何易便秘？
为什么有时便秘有时腹泻？
糖尿病病人为什么会视力下降？
糖尿病病人为什么容易生疖长疮？
糖尿病并发症的预防到底从何时开始？要怎样做？
中医如何认识和治疗糖尿病并发症？
糖尿病慢性并发症的防治原则是什么？
如何避免并发症？
如何用药酒防治并发症？
糖尿病并发症能不能治愈？
谁来当你健康的“铁道部长”？
有并发症的糖尿病患者在运动时应注意什么？
血糖控制好了就不会得糖尿病的并发症吗？
二、糖尿病急性并发症的防治
（一）糖尿病酮症酸中毒的防治?
什么是酮体？糖尿病酮症是怎么回事？
尿中出现酮体是糖尿病酮症吗？
什么是酮症酸中毒？
糖尿病酮症酸中毒的诱因有哪些？
如何预防糖尿病酮症酸中毒？
为什么糖尿病酮症酸中毒时血糖容易升高？
（二）非酮症高渗性糖尿病昏迷的防治
何谓糖尿病高渗性昏迷？
糖尿病高渗性昏迷的诱发因素有哪些？
糖尿病高渗性昏迷是怎么发生的？
糖尿病高渗性昏迷有何特征？
糖尿病高渗性昏迷的治疗原则是什么？
怎样预防糖尿病高渗性昏迷？
糖尿病高渗性昏迷的预后如何？
（三）糖尿病乳酸性酸中毒的防治?
何谓糖尿病乳酸性酸中毒？
引起糖尿病乳酸性酸中毒的原因是什么？
为什么老年糖尿病患者易发生乳酸性酸中毒？
为什么双胍类口服降糖药物易引起糖尿病乳酸性酸中毒？
（四）糖尿病性低血糖的防治?
什么叫低血糖症？引起糖尿病性低血糖的原因是什么？
为什么有的患者清晨血糖高还会出现低血糖反应？
为什么老年糖尿病患者易发生低血糖？
为什么低血糖时患者有心慌、手抖、多汗现象？
低血糖对糖尿病患者易造成哪些危害？
为什么糖尿病性低血糖的危害远远超过高血糖？
在什么情况下糖尿病患者易出现低血糖昏迷？
为什么低血糖昏迷者6小时后就会死亡？
何谓相对性低血糖？
何谓不自觉低血糖现象？
糖尿病性低血糖应与哪些疾病鉴别？
糖尿病性低血糖的治疗原则是什么？
如何防治糖尿病性低血糖昏迷？
三、糖尿病慢性并发症的防治
（一）糖尿病肾病的防治?
什么是糖尿病肾病？
为什么有的糖尿病患者小便中总是有很多泡沫？
如何诊断糖尿病肾病？
为什么要定期检测肾功能？
治疗糖尿病肾病的原则是什么？
糖尿病肾病病人的饮食应怎样安排？
如何饮食调理糖尿病肾病？
糖尿病肾病时不宜用哪些药物？
糖尿病肾衰竭的透析指征是什么？
糖尿病肾病患者透析时饮食上应注意什么？
为什么患糖尿病肾病时尿糖较前减少？此时治疗中应注意什么？
为什么患糖尿病肾病时糖尿病的临床表现较前减轻？
糖尿病肾病的发生与糖尿病病程有什么关系？
糖尿病肾病患者需要补肾吗？“肾虚”就是肾功能减退吗？
尿中有微量白蛋白能用二甲双胍吗？
腰痛与糖尿病肾病有关吗？
“肾虚”是糖尿病肾病吗？
刚诊断的糖尿病患者会并发糖尿病肾病吗？
糖尿病并发肾病护理要点是什么？
糖尿病病人夜尿多怎么治疗？
糖尿病肾病的预后如何？
（二）糖尿病眼病的防治?
糖尿病眼病有哪些？
刚诊断的糖尿病患者有必要检查眼底吗？
为什么要定期进行眼底检查？
糖尿病眼底荧光血管造影有何临床价值？
治疗糖尿病视网膜病变的原则是什么？
糖尿病视网膜病变患者如何调节情绪？
如何预防和治疗糖尿病视网膜病变？
眼底出血的患者不能用活血化瘀药吗？
糖尿病视网膜病变患者在日常生活中应如何自我保健？
糖尿病视网膜病变患者在饮食上应注意什么？
如何饮食调理糖尿病眼部并发症？
（三）糖尿病神经病变的防治?
何谓糖尿病神经病变？
糖尿病神经病变如何分类？
糖尿病神经病变最常见的类型是什么？
糖尿病神经病变所致的疼痛有何特点？
糖尿病周围神经病变的临床表现是什么？
糖尿病病人腿脚麻木、疼痛怎么办？
什么是糖尿病自主神经病变？
为什么糖尿病会出现自主神经病变呢？
心血管系统自主神经功能障碍都有哪些临床表现？
糖尿病自主神经病变有哪些消化系统的症状呢？
糖尿病自主神经病变在泌尿生殖系统有哪些表现呢？
糖尿病自主神经病变会有哪些泌汗障碍？
糖尿病自主神经病变为什么会出现未觉察的低血糖？
对于糖尿病性胃麻痹应该如何治疗？
对于糖尿病性肠紊乱如何治疗？
糖尿病性心脏自主神经病变如何治疗？
对于糖尿病神经源性膀胱如何治疗？
中医如何治疗糖尿病患者多汗？
中医如何治疗糖尿病便秘？
非药物治疗便秘有何方法？
中医药如何治疗末梢神经病变？
中医药如何治疗糖尿病患者皮肤鱼鳞样改变？
皮肤瘙痒、外阴瘙痒如何治疗？
为何糖尿病患者会失眠呢？
中医如何治疗失眠？
糖尿病病人神经病变护理要点是什么？
（四）糖尿病并发心脏病的防治?
什么是糖尿病并发心脏病变？
我经常犯“心绞痛”，可服了硝酸甘油不管用，做冠状动脉造影检查也没事，我到底是不是得了冠心病？
为什么糖尿病患者易并发冠心病？
糖尿病并发冠心病的临床特点是什么？
糖尿病并发冠心病与无糖尿病的冠心病有何不同？
为什么大多数糖尿病患者出现心率增快？
为什么糖尿病患者会出现无痛性心肌梗死？
如何防治糖尿病并发心脏病变？
糖尿病并发心血管病变护理要点是什么？
如何饮食调理糖尿病冠心病？
（五）糖尿病并发高血压的防治?
糖尿病并发高血压有什么危害性？
糖尿病并发高血压分几类？
有糖尿病肾病的高血压是怎么发生的？
无糖尿病肾病的高血压是怎么发生的？
为什么有的糖尿病患者易出现立位性低血压及卧位性高血压？
糖尿病并发高血压的诊断要点是什么？
非药物疗法能控制糖尿病并发的高血压吗？
糖尿病并发高血压为什么要慎用噻嗪类利尿药？
如何饮食调理糖尿病并发高血压？
（六）糖尿病并发脑血管病的防治?
什么是糖尿病并发脑血管病变？
糖尿病并发的脑血管病包括哪些疾病？
糖尿病并发脑血管病的诱发因素是什么？
糖尿病并发脑血管病时有哪些先兆迹象？
如何防治糖尿病并发脑血管病变？
如何饮食调理糖尿病并发脑血管病？
（七）糖尿病下肢血管病变的防治
何谓糖尿病下肢血管病变？
什么是糖尿病足？
糖尿病足是怎样发生的？
为什么说下肢神经病变是糖尿病足的主要原因之一？
下肢神经病变是怎样发生的？
糖尿病足神经病变有何特点？
糖尿病足缺血性病变有何特点？
如何预防和治疗糖尿病足？
怎样运用外治法治疗糖尿病下肢血管病变？
糖尿病足如何护理？
（八）糖尿病性骨病的防治
何谓糖尿病性骨病？
糖尿病并发骨质疏松症有何特点？
糖尿病并发骨质疏松症的治疗原则是什么？
如何饮食调理糖尿病并发骨质疏松症？
（九）糖尿病其他并发症的防治?
糖尿病与感染的关系如何？
糖尿病病人容易发生哪些感染？
糖尿病并发痈肿疮疥如何治疗？
中医如何治疗急慢性感染呢？
糖尿病水疱如何护理？
糖尿病皮肤溃疡、坏疽如何护理？
糖尿病对男性生殖系统功能有什么影响？
对于糖尿病性阳痿如何治疗？
如何饮食调理糖尿病性阳痿？
糖尿病患者易并发哪些口腔疾病？有何表现？
糖尿病并发口腔疾病的治疗方法有哪些？
糖尿病患者如何拔牙？
对糖尿病并发口腔疾病进行治疗时应注意哪些问题？
糖尿病并发肺结核的发病情况怎样？
肺结核与糖尿病之间有何影响？
糖尿病并发肺结核的临床特征是什么？
糖尿病并发肺结核的预后如何？
如何预防糖尿病并发肺结核？
何谓糖尿病性高脂血症？
糖尿病性高脂血症与胰岛素的多与少有关系吗？
何谓糖尿病性脂肪肝？糖尿病性脂肪肝的发病情况怎样？
糖尿病性高脂血症的治疗原则是什么？
血脂调节剂从哪些途径发挥作用？
如何饮食调理糖尿病性高脂血症？
何谓糖尿病性潮红？
何谓糖尿病性硬化性水肿？
何谓糖尿病性黄色瘤？
何谓糖尿病性无汗症？
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>糖尿病并发症防治
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>美容整形手术并发症
目录
第一章 人体各部位美容整形手术并发症
第一节 重睑术并发症
一、血肿
二、感染
三、消肿慢
四、切口疤痕
五、重睑皱褶过宽
六、重睑皱褶过窄
七、重睑皱褶过长
八、重睑皱褶过短
九、三眼皮
十、三角眼
十一、睁眼乏力
十二、外形不美
十三、皮下结节
十四、重睑消失
十五、眼睑皮肤破损
十六、眼睑凹陷
第二节 内眦赘皮矫正术并发症
一、疤痕增生
二、皮瓣坏死
三、矫正不满意
第三节 眼袋去除术并发症
一、感染
二、血肿及皮下瘀血
三、睑外翻
四、眼袋部分存留
五、下睑凹陷
六、眼袋内硬结
七、睫毛脱失
八、切口部疤痕
九、术后不对称
十、切口缘靠下
第四节 上睑下垂矫正术并发症
一、感染
二、矫正不足
三、矫正过度
四、睑裂闭合不全
五、眼睑内翻与倒睫
六、睑外翻
七、暴露性角膜炎
八、睑缘弧度不理想
九、眶上神经痛
十、睑停滞现象
第五节 眉整形术并发症
一、移植头皮片坏死
二、植眉后毛发稀疏
三、植眉后两侧不对称
四、眉形不美
五、眉畸形矫正不彻底
第六节 水平斜视矫正术并发症
一、术后近期矫正效果减退
二、矫正不足与过度矫正
三、术后局部反应
四、术后眼眶蜂窝织炎
五、顽固性复视
六、巩膜损伤
七、睑裂缩小
八、泪阜退缩
九、球结膜疤痕
十、心眼反射现象
第七节 纹眉、纹眼线、纹唇术并发症
一、眉形不美
二、眼线形状不美
三、唇形不美
四、局部肿胀或瘀血、感染
五、颜色变蓝
六、颜色脱失
七、湮色
第八节 硅橡胶隆鼻术并发症
一、血肿
二、感染
三、穿孔
四、皮肤溃烂
五、排异反应
六、鼻歪斜
七、鼻孔变形、大小不等
八、鼻外形不美
九、额鼻部缺乏弧度
十、鼻尖过于尖向下方
十一、假体轮廓阴影
第九节 鼻再造术并发症
一、皮瓣局部缺血与坏死
二、鼻道通气障碍
三、鼻外形不美
第十节 颞部填充术并发症
一、血肿
二、神经损伤
三、瘢痕及头发脱落
四、硅胶片体表投影
第十一节 招风耳矫正术并发症
一、血肿
二、感染
三、皮肤坏死
四、矫正外形不理想
五、矫正程度不够
六、术后复发
第十二节 穿耳孔术并发症
一、耳孔部感染
二、过敏反应
三、位置不对称或偏歪
四、耳垂疤痕增生
第十三节 耳再造术并发症
一、皮肤坏死
二、术后感染
三、外形不美
第十四节 厚唇与重唇整形术并发症
一、切口感染
二、肿胀
三、切口缘不整齐
四、闭口时牙外露
第十五节 唇裂修复术并发症
一、伤口感染
二、伤口裂开
三、疤痕增生
四、上唇过松
五、上唇过紧
六、上唇过长
七、唇红畸形
八、唇弓不显
九、人中不显
十、鼻孔过大
十一、鼻孔过小
十二、鼻翼基底过低
十三、鼻尖不正伴鼻翼塌陷
十四、鼻柱歪斜
十五、鼻柱过短、鼻尖过低
第十六节 酒窝再造术并发症
一、感染
二、酒窝消失
三、位置不美
四、损伤腮腺导管或面神经分支
第十七节 半侧颜面萎缩矫正术并发症
一、外形不规则
二、皮脂腺样囊肿
三、硬化
四、坏死
五、感染
六、排异反应
第十八节 下颌后缩颏部充填术并发症
一、感染
二、血肿
三、植入物位置不当
四、植入物排出
五、植入骨的吸收
六、下唇麻木
第十九节 颏部截骨矫正术并发症
一、截骨不准确
二、疤痕明显
三、感染
四、神经损伤
五、出血
六、截骨部位愈合不佳
七、牙髓损伤、牙齿脱落
第二十节 除皱术并发症
一、感染
二、血肿及瘀斑
三、皮肤坏死
四、切口疤痕、切口裂开
五、秃发
六、神经损伤
七、感觉异常
八、腮腺导管受压
第二十一节 体表小肿物切除术并发症
一、切口疤痕
二、肿物复发
三、遗留死腔
四、器官外形移位
第二十二节 腋臭切除术并发症
一、皮下血肿
二、切口感染
三、臭味残留
四、瘢痕挛缩
五、血管神经损伤
第二十三节 隆乳术并发症
一、血肿
二、感染
三、纤维囊挛缩乳房变硬
四、假体偏移
第二十四节 巨乳缩小整形术并发症
一、缝合创口延期愈合
二、创缘皮肤坏死
三、血肿
四、感染
五、切口疤痕增生
六、乳头乳晕坏死
七、新乳头乳晕位置过高
八、术后两侧乳房大小不对称
第二十五节 乳头内陷矫正术并发症
一、乳头内陷复发
二、乳头坏死
三、乳晕变小
第二十六节 腹部去脂术并发症
一、血肿及血清肿
二、脂肪液化
三、皮瓣局部坏死
四、创口裂开
五、感染
六、切口疤痕
七、脐坏死
八、脐周疤痕
九、腹壁外形不对称
十、脐孔错位
十一、栓塞性静脉炎和肺栓塞
十二、神经损伤
十三、局部感觉改变
第二十七节 脂肪抽吸手术并发症
一、外形不规则
二、血清肿、血肿形成
三、皮肤皱褶
四、瘀斑
五、感觉减退
六、持续肿胀
七、皮肤坏死
八、血液丢失
九、感染
十、血管、神经损伤
十一、静脉栓塞
第二十八节 先天性并指矫正术并发症
一、血运障碍、手指坏死
二、手指感觉障碍
三、感染
四、植皮坏死
五、瘢痕挛缩
六、手指遗留部分并连
第二章 各类美容整形手术并发症
第一节 皮片移植术并发症
一、皮片不成活
二、皮片收缩
三、皮片颜色变暗
四、植皮后瘢痕
五、感觉减退
六、毛发生长
七、供区创口裂开
八、供区感染不愈合
九、供区增生性疤痕
第二节 取皮术并发症
一、皮片太厚与太薄
二、皮片边缘不齐
三、脱胶
第三节 皮瓣移植术并发症
一、皮瓣血运障碍皮瓣坏死
二、皮瓣下血肿
三、皮瓣（或皮管）撕脱
四、皮瓣（或皮管）感染
五、皮瓣臃肿
六、蒂部皮肤皱折
七、关节僵直
第四节 胸三角皮瓣手术并发症
一、皮瓣坏死
二、皮瓣脱落
三、术后感染
第五节 额瓣手术并发症
一、皮瓣坏死
二、术后感染
第六节 显微外科手术并发症
一、局部出血
二、局部水肿
三、血管危象
第七节 肋骨切取术并发症
一、胸膜穿破造成气胸
二、肋骨折断
三、损伤肋间神经及血管
第八节 髂骨切取术并发症
一、盆腔脏器损伤
二、术后出血及血肿
第九节 截骨美容术并发症
一、出血和血肿
二、感染及脓肿
三、骨坏死
四、伤口愈合不良
五、硬脑膜裂伤
六、脑神经损伤
七、其它周围组织损伤
第十节 皮肤磨削术并发症
一、色素沉着
二、粟丘疹
三、疤痕增生
四、感染
五、磨削过浅
六、病变复发
七、面部色泽反差大
第十一节 冷冻美容术并发症
一、水疱或血疱
二、色素沉着
三、疼痛
四、面部潮红
五、疤痕与色素脱失
六、病变存留
七、病变处出现花斑
第十二节 化学脱皮术并发症
一、色素沉着
二、炎症后红斑
三、粟丘疹
四、单纯疱疹感染
五、对肾、肝、心脏的毒性
第十三节 注射美容整形术并发症
一、皮下组织萎缩
二、皮肤坏死
三、石蜡瘤及周期性发热
四、胶原注射反应
第十四节 激光美容术并发症
一、疤痕形成
二、色素沉着
三、皮肤花斑
四、局部感染
第十五节 放射治疗血管瘤并发症
一、局部肿胀、渗液
二、皮肤萎缩、角化
三、色素减退
四、放射性溃疡
五、局部发育障碍
六、癌变
第十六节 美容整形手术麻醉并发症
一、局部麻醉药中毒
二、局部神经损伤
三、呼吸循环抑制
四、幻觉、躁动、恶心、呕吐
五、呼吸道梗阻
六、呼吸抑制或呼吸停止
第十七节 输液并发症
一、静脉炎
二、机械性故障
三、发热、局部发红
四、药液外渗
五、水中毒
六、肺水肿和心力衰竭
第十八节 输血并发症
一、发热反应
二、过敏反应
三、溶血反应
四、输血性肝炎
第十九节 皮肤软组织扩张术并发症
一、血肿
二、感染
三、囊外露
四、渗露
五、局部疼痛与水肿
第三章 美容整形受术者的心理障碍
一、心理学与美容整形外科的关系
二、美容整形受术者对手术的心理表现
三、不同年龄美容整形受术者的心理特征
四、美容整形受术者术前心理及对策
五、美容整形受术者术中心理及对策
六、美容整形受术者术后心理及对策
七、不宜做美容整形手术的受术者
八、暂不宜做手术的几种情况
第四章 预防美容整形手术并发症的整体措施
一、问诊中应注意的事项
二、术前谈话、签字及照相
三、美容整形手术术前检查与准备
四、美容整形手术的设计
五、美容整形手术的铺巾、麻醉及器材选用
六、美容整形手术的操作特点
七、美容整形手术术后的一般处理
八、美容整形手术术后不适的处理
九、影响伤口愈合的因素及防治措施
十、美容整形手术感染的预防
十一、对住院病人的管理
十二、对门诊病人的医嘱
十三、美容整形医务工作者应具有的素质
十四、美容整形外科医院的环境及设施要求
第五章 与并发症防治有关的几个问题
一、有关组织修复的问题
二、有关伤口感染的问题
三、感染伤口的换药
四、瘢痕的防治
五、人工植入材料的应用
六、医用硅橡胶的应用
七、人工装戴体的应用
八、面部美学观察标准
主要参考书目

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>美容整形手术并发症
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>专家解答糖尿病并发症
糖尿病并发症基本知识我国糖尿病流行的形势非常严峻吗／1我国糖尿病防治面临的问题是什么／2为什么说糖尿病并不可怕／3为什么说糖尿病并发症才是应该关注的焦点／4糖尿病为什么会引起多种并发症／5糖尿病的危害主要来自并发症吗／6糖尿病究竟有多少并发症／7糖尿病有哪些急性并发症／9糖尿病有哪些慢性并发症／9糖尿病的并发症非常可怕吗／12糖尿病并发症已成为“杀手”了吗／13为何要重视糖尿病并发症／13为什么说预防和控制糖尿病并发症是重要的手段／15为何糖尿病病人须预防并发症／16预防并发症是治疗糖尿病的关键吗／17糖尿病：应重点保护哪4个器官／18如何对糖尿病并发症说“不”／19怎样避免糖尿病并发症／20怎样预防糖尿病的并发症／21控制多种危险因素能预防和延缓糖尿病并发症吗／22为什么防止和延缓并发症必须降糖与降压并举／23中医药可防止和延缓糖尿病并发症吗／24糖尿病急性并发症的防治……糖尿病心脑血管病的防治……糖尿病肾病的防治……糖尿病神经病变的防治……糖尿病性消化道疾病的防治……糖尿病呼吸道疾病的防治……糖尿病性泌尿系感染的防治……糖尿病眼病的防治……糖尿病足的防治……糖尿病性皮肤病变的防治……糖尿病其他并发症的防治……
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>专家解答糖尿病并发症
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>女性节育及并发症的防治
第一章 女性生殖器解剖及生理
第二章 女性的生殖生理
第三章 妊娠生理
第四章 妊娠诊断及鉴别诊断
第五章 女性节育临床检查法
第六章 女性节育手术的麻醉
第七章 清洁、消毒与无菌技术
第八章 节育原理
第九章 宫内节育器避孕方法 
第十章 女性药物避孕法
第十一章 其它避孕法
第十二章 人工流产
第十三章 女性绝育术
第十四章 女性节育手术并发症的诊断与防治
第十五章 节育领域中严重并发症的防治
第十六章 输卵管复通术
第十七章 女性不孕症
第十八章 女性节育有关药物
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>女性节育及并发症的防治
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>肿瘤并发症鉴别诊断与治疗
第一章 呼吸系统肿瘤并发症
第一节 恶性胸腔积液
第二节 呼吸道梗阻
第三节 呼吸衰竭
第四节 肿瘤肺转移
第五节 抗肿瘤药物的肺毒性
第二章 消化系统恶性肿瘤并发症
第一节 反流性食管炎
第二节 食管及胃肠吻合口狭窄
第三节 倾倒综合征
第四节 盲襻综合征
第五节 残胃癌
第六节 癌性腹水
第七节 肿瘤肝转移
第八节 化疗药物引起的肝损伤
第九节 便秘
第十节 呃逆
第三章 心血管肿瘤并发症
第一节 恶性心包积液
第二节 上腔静脉综合征
第三节 抗恶性肿瘤药物的心脏毒性
第四节 药物性静脉炎及其他血管并发症
第五节 肿瘤相关的高血压症
第四章 泌尿系统肿瘤并发症
第一节 肾脏并发症
第二节 膀胱并发症
第三节 抗肿瘤药物的泌尿毒性
第五章 血液系统肿瘤并发症
第一节 贫血
第二节 红细胞增多症
第三节 粒细胞减少症与粒细胞缺乏症
第四节 血小板减少症
第五节 血小板增多症
第六节 血栓形成
第七节 弥散性血管内凝血
第六章 神经系统肿瘤并发症
第一节 肿瘤脑转移
第二节 肿瘤脑（脊）膜转移
第三节 神经系统的肿瘤副综合征
第四节 肿瘤并发脑血管病
第五节 医源性神经系统损伤
第七章 妇科肿瘤常见并发症
第一节 贫血
第二节 膀胱并发症
第三节 不孕
第四节 癌性腹水
第五节 肿瘤脑转移
第六节 急性盆腔结缔组织炎
第七节 慢性盆腔结缔组织炎
第八节 盆腔淋巴囊肿
第九节 泌尿道损伤
第十节 肠梗阻
第十一节 肠管损伤
第十二节 放射性膀胱炎
第十三节 放射性直肠炎
第四节 放射性性腺功能损伤
第五节 化疗药物对性腺功能的影响
第十六节 浅表部位原发灶不明的转移癌
第十七节 高钙血症
第十八节 促性腺激素分泌不当
第八章 肿瘤眼部并发症
第九章 肿瘤放射治疗并发症
第一节 神经系统的放射性损伤
第二节 放射性内分泌腺损伤
第三节 放射性皮肤损伤
第四节 头颈部的放射性损伤
第五节 放射性心脏并发症
第六节 放射性肺损害
第七节 消化系统的放射性损伤
第八节 造血系统的反应
第九节 泌尿系统放射性损伤
第十节 女性生殖道的放射损伤
第十一节 放射性骨、关节损伤
第十二节 放射治疗的全身反应
第十三节 放疗后继发癌症
第十章 肿瘤病人发热的治疗
第十一章 癌痛的治疗
第十二章 肿瘤病人的心理及精神治疗
附录
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>肿瘤并发症鉴别诊断与治疗
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>糖尿病饮食调养一本就够
目录
Part 1 不可不知的糖尿病常识
糖尿病的主要表现 2
遏制糖尿病，须从“糖尿病前期”着手 3
糖尿病“偏爱”的几类人 4
最常被忽略的糖尿病非典型症状 5
糖尿病不可怕，可怕的是并发症 6
哪些人可将控制血糖的标准放宽 7
哪些人必须严格降糖 8
平稳控糖，从一日三餐做起 9
血糖波动大，慎吃三类食物 1
Part 2 糖尿病患者要把握的饮食总原则
每天吃多少：用手比划一下吧 12
碳水化合物占总热量的55%～60% 14
蛋白质占总热量的15%～20% 15
脂肪占总热量的20%～30% 16
膳食纤维摄入30～40克／日 17
多吃中低GI和GL食物 18
食用油控制在20～25克／日，多用植物油 19
盐不超过5克／日 20
胆固醇不超过300毫克／日 21
低嘌呤，预防糖尿病合并高尿酸血症 22
多饮水，预防糖尿病并发症 23
一日三餐换成5～6餐吃，让血糖更平稳 24
专题 利于降糖不可或缺的维生素和矿物质 25
Part 3 一日三餐巧安排，配出营养食谱
算算一天吃多少 28
计算每天所需总热量 28
确定三餐的热量分配比例 30
科学安排三餐的主食量 31
加餐后，正餐主食量应减少 32
以“90千卡”为一份 33
早晨血糖最难控，吃“全”助控全天血糖 34
主食+蔬果+鸡蛋，这样搭配更均衡 34
牛奶或原味豆浆，有助稳定血糖 35
蔬菜以富含粗纤维的为主，既降糖又通便 36
肉包烧饼米浆，味美却升糖 37
西式早餐含糖多，全麦面包较健康 38
用奶酪和三文鱼代替火腿和培根 39
10:00左右水果加餐 40
下午四五点血糖有高峰，吃“杂”更控糖 41
全谷杂粮占一半，降餐后血糖 41
吃适量的鱼肉、禽肉和瘦肉，饿得慢 42
豆制品是肉类的最佳替代品 43
多吃深绿色带叶蔬菜，有助控糖 44
搭配菌菇类，帮助降脂降压 45
15:00左右，低糖蔬菜／坚果加餐 46
晚上给胰岛细胞减负，吃“少”更健康 47
晚餐过饱，加重胰岛细胞负担 47
晚餐偏素防并发症 48
主食混入少量粗粮，改善糖耐量 49
蔬菜选富含低纤维的更助眠 50
21:00左右，豆腐干／鸡蛋加餐 51
全天不同热量食谱推荐 52
1200～1300?千卡全天带量食谱 52
1400～1500?千卡全天带量食谱 54
1600～1700?千卡全天带量食谱 56
1800～1900?千卡全天带量食谱 58
2000～2100?千卡全天带量食谱 60
食物交换份法，配出个性化食谱 62
学会应用食物交换份 62
根据总热量变换每日食谱 65
专题 饱腹指数(SI)——让糖尿病患者吃饱吃好 68
Part 4 糖尿病并发症必知的三餐调养方案
合并高血压 70
以20～25千卡/千克摄入热量 70
减少膳食脂肪，补充适量优质蛋白质 70
每日摄入富含纤维素和钾的蔬果 71
适当多食含钙量较多的食物 71
严格限盐，建议3～5克/日 71
三餐带量食谱举例 72
合并冠心病 74
长期吃素不可取 74
摄入脂肪要限量提质 74
每周吃2～3次海产品 74
每天吃50～100克豆制品 75
适当多吃些活血化瘀的食物 75
不要将饮用水软化 75
少饮或不饮浓茶、咖啡 75
三餐带量食谱举例 76
合并高血脂 78
每天至少250克米饭 78
每天75克富含蛋白质的食物 78
膳食纤维量每天应大于35 克 79
每日摄取的胆固醇不超过200毫克 79
适当选用茶籽油或橄榄油 79
三餐带量食谱举例 80
合并肾病 82
以30～35千卡/千克体重摄入热量，肥胖者可略少 82
选择糖类主食把握两个原则 82
多用动物蛋白代替植物蛋白 83
限制蛋白质，需分期对待 83
钾的摄入量低于1500毫克/日 83
肾功能不全者，盐降至2克/日 83
三餐带量食谱举例 84
合并痛风 86
急性发作期，嘌呤摄入量应低于150毫克/日 86
缓解期，适当摄入中嘌呤食物 86
每日喝水2000～3000毫升，促进尿酸排出 87
补充蛋白质以奶蛋类为主 87
多吃富含钾的食物，减少尿酸沉淀 87
酒精可抑制尿酸排出，应限酒 87
三餐带量食谱举例 88
专题 糖尿病合理用药指导
Part 5 糖尿病特殊人群最佳调养方案
儿童糖尿病 94
每天摄入总热量的计算 94
蛋白质以优质蛋白为主 94
脂肪以不饱和脂肪酸为主 94
碳水化合物以谷类粗粮为主 95
少量多餐，餐间可加2次点心 95
三餐带量食谱举例 96
妊娠糖尿病 100
妊娠糖尿病的血糖控制目标 100
每日热量的摄入以不引起饥饿为好 100
孕中期以后每周热量增加3%～8% 101
保证充足的蛋白质 101
注意钙及维生素D的补充 101
每天保证足够的铁 102
水果不要每餐都吃 102
多吃富含膳食纤维的粗杂粮和蔬菜 103
适量进食一些坚果，增加供给脂肪 103
三餐带量食谱举例 104
专题 糖尿病专家问答 108
Part 6 三餐食物这么吃，平稳降血糖
谷薯类这么吃 112
每天至少3餐，每餐主食不超100克 112
每天吃够3种全谷类食物 112
可以代替主食的薯类 113
主食做得干，血糖上升慢 113
制作混合主食，降餐后血糖 113
荞麦 富含降血糖的铬和矾 114
荞麦菜卷 115
糙米 防止血糖骤然升降 116
薏米红豆糙米饭 117
玉米 调节胰岛素分泌 118
小窝窝头 119
空心菜炝玉米 119
燕麦 餐后血糖上升过快的克星 120
燕麦米饭 121
薏米 保护胰岛B细胞膜 122
薏米山药粥 123
草莓薏米酸奶汁 123
黑米 提高胰岛素的利用率 124
黑米茶 125 黑米面馒头 125
小米 参与糖类和脂肪的代谢 126
杂粮馒头 127
小米大枣粥 127
绿豆 降低空腹、餐后血糖 128
玉米绿豆饭 129
苦瓜绿豆汤 129
红小豆 提高胰岛素的敏感性 130
红豆饭 131
莲藕紫菜红豆汤 131
黑豆 代谢胆固醇，保护血管 132
凉拌黑豆 133
莲藕黑豆汤 133
土豆 保护心血管的粮食 134
土豆烧牛肉 135
蔬果类这么吃 136
蔬菜摄入量保持500克/日左右 136
深绿色蔬菜要占到一半 136
吃蔬菜遵循彩虹效应 136
估算吃了多少蔬菜 136
蔬菜烹调淡一点儿 137
低热量、水分多的蔬菜可充饥 138
低碳水化合物蔬菜餐前吃 139
高碳水化合物蔬菜可替换主食 139
水果可以吃，但应减少主食 140
加餐最好选低糖水果 141
黄瓜 抑制糖类转变成脂肪 142
小炒黄瓜片 143
黄瓜拌木耳 143
苦瓜 辅助降血糖 144
双耳炝苦瓜 145
凉拌苦瓜 145
冬瓜 减肥降糖两不误 146
冬瓜海带汤 147
番茄 提高胰岛素质量 148
番茄炒蛋 149
番茄炒丝瓜 149
生菜 消除多余脂肪 150
凉拌生菜 151
莴笋 改善糖的代谢功能 152
凉拌笋丁 153
木耳炒莴笋 153
芹菜 降压降脂防并发症 154
什锦芹菜 155
西芹菠菜汁 155
大白菜 减缓餐后血糖升高 156
白菜心拌海蜇 157
油菜 促进糖的分解代谢 158
香菇油菜 159
芦笋 促进人体胰岛素分泌 160
鲜虾芦笋 161
芦笋鸡片 161
韭菜 食后不会引起血糖波动 162
韭菜炒西葫芦 163
韭菜炒绿豆芽 163
菠菜 预防糖尿病视网膜病变 164
菠菜拌绿豆芽 165
蒜蓉菠菜 165
空心菜 降低胰岛素需要量 166
玉米粒炒空心菜梗 167
茄子 防止糖尿病并发心血管病变 168
肉末蒸茄子 169
蒜泥茄子 169
洋葱 降糖降压降脂 170
洋葱炒肉 171
洋葱炒鸡蛋 171
白萝卜 降低餐后血糖 172
海蜇拌萝卜丝 173
海带萝卜汤 173
胡萝卜 防治慢性心血管并发症 174
肉炒胡萝卜丝 175
菠菜拌胡萝卜 175
山药 避免胰岛素分泌过剩 176
番茄炒山药 177
家常炒山药 177
藕 适用于消瘦型糖尿病 178
凉拌藕片 179
莲藕排骨汤 179
青苹果 稳定胰岛素水平 180
西瓜 消口渴，降血压 181
梨 减少胆固醇的吸收 182
柚子 改善胰岛素敏感性 183
柠檬 预防糖尿病并发症 184
草莓 改善血液循环 185
肉蛋类这么吃 186
肉类：优选白肉，适量红瘦肉 186
蛋类：每次吃多少 187
鸡肉 降低血糖浓度 188
怪味鸡 189
竹笋炒鸡丝 189
鳝鱼 可显著降低血糖 190
炒鳝鱼丝 191
韭菜炒鳝鱼丝 191
虾 适用于糖尿病性阳痿 192
盐水虾 193
虾仁烩冬瓜 193
鲫鱼 对糖尿病患者很滋补 194
鲫鱼炖豆腐 195
清炖鲫鱼 195
带鱼 补充糖尿病患者体内缺少的硒 196
醋烹带鱼 197
带鱼扒白菜 197
猪瘦肉 补充消耗的B族维生素 198
鱼香肉丝 199
芦笋炒里脊肉 199
牛瘦肉 提高机体对葡萄糖的利用 200
农家粉蒸牛肉 201
葱爆牛肉 201
鸡蛋 补充慢性病消耗的营养 202
鲜虾蒸蛋 203
鹌鹑蛋 补五脏的“动物人参” 204
香菇鹌鹑蛋 205
油脂类食物这么吃 206
多用植物脂肪代替动物饱和脂肪 206
优选含较多不饱和脂肪酸的油类 206
坚果类：可以外带的零食 207
橄榄油 对控制血脂有益 208
玉米油 降低患心血管疾病的风险 209
亚麻籽油 降低餐后血糖水平 210
核桃 保护心脑血管 211
榛子 防糖尿病并发症 212
花生 增进心脏健康 213
专题 糖尿病运动调养方案 214
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>糖尿病饮食调养一本就够
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>肾综合征出血热及并发症防治
第一章  肾综合征出血热
一、流行病学
(一)传染源和宿主动物
(二)传播途径
(三)人群易感性
(四)流行特征
二、发病机制
(一)对肾综合征出血热病毒感染直接作用的研究
(二)神经体液因素
(三)弥散性血管内凝血
(四)对免疫学发病机制的研究
三、肾综合征出血热对全身各部位的影响
(一)体表及体腔的变化
(二)心血管系统的变化
(三)泌尿系统的变化
(四)内分泌系统的改变
(五)消化系统的改变
(六)呼吸系统的改变
(七)神经系统的改变
(八)脾、胸腺及淋巴腺的改变
(九)血细胞及造血系统的改变
四、临床表现
(一)病程经过
(二)各期的临床表现
(三)特殊类型的肾综合征出血热
(四)小儿肾综合征出血热
(五)妊娠合并肾综合征出血热
五、辅助检查
(一)血常规及出凝血检查
(二)尿常规检查
(三)生物化学检查
(四)免疫功能检查
(五)其他活性因子检测
(六)心电图检查
(七)胸部x线检查
(八)甲皱微循环显微镜检查
(九)其他检查
六、诊断和鉴别诊断
(一)诊断
(二)早期诊断与早期定度
(三)临床分型
(四)鉴别诊断
七、预防
(一)监测
(二)灭鼠防鼠
(三)灭螨防螨
(四)食品卫生及管理
(五)加强消毒工作
(六)个人防护
(七)疫苗预防
八、治疗
(一)发热期治疗
(二)低血压休克期治疗
(三)少尿期治疗
(四)多尿期治疗
(五)恢复期治疗
(六)中医治疗
九、营养支持疗法
(一)调整胃肠功能
(二)热量及氮质平衡
(三)蛋白同化激素和能量合剂的应用
(四)纠正失水与补充白蛋白
(五)其他
十、护理
(一)一般护理与重点护理
(二)分期护理
第二章  肾综合征出血热并发症
——、出血
(一)发病机制
(二)临床表现
(三)诊断
(四)治疗
二、弥散性血管内凝血与继发性纤溶
(一)发病机制
(二)弥散性血管内凝血临床表现
(三)继发性纤溶临床表现
(四)治疗
三、休克
(一)发病机制
(二)临床表现
(三)休克的抢救
四、水与电解质平衡紊乱
(一)水平衡紊乱
(二)电解质平衡紊乱
五、酸碱平衡紊乱
(一)代谢性酸中毒
(二)代谢性碱中毒
(三)呼吸性酸中毒
(四)呼吸性碱中毒
(五)混合型酸碱紊乱
六、高血容量综合征
(一)病因
(二)临床表现
(三)实验室检查
(四)预防
(五)治疗
七、急性肾衰竭
(一)发病机制
(二)临床表现
(三)治疗
八、继发感染
(一)主要原因
(二)常见病原体及药物的选择
(三)肾功能减退患者抗感染药物的应用
(四)肝功能减退患者抗感染药物的应用
(五)肺部感染的治疗
(六)腹腔感染的治疗
(七)肠道感染的治疗
(八)尿道感染的治疗
九、呼吸系统损害
(一)急性肺水肿
(二)成人呼吸窘迫综合征
十、心脏损害
(一)发病机制与临床表现
(二)治疗
十一、消化系统损害
(一)肝脏损害
(二)急性胰腺炎
十二、神经系统损害
(一)发病机制
(二)临床表现
(三)治疗
十三、自发性肾破裂
(一)发病机制
(二)临床表现
(三)治疗
十四、高渗性非酮症糖尿病昏迷
(一)病因及临床表现
(二)治疗
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>肾综合征出血热及并发症防治
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>糖尿病并发症饮食疗法
第一章 糖尿病的一般知识
第二章 糖尿病饮食治疗基础
第三章 各类食物营养素与糖尿病
第四章 糖尿病并发症
第五章 糖尿病并发脑血管病
第六章 糖尿病并发高血压
第七章 糖尿病并发高脂血症
第八章 糖尿病并发心脏病
第九章 糖尿病并发神经病变
第十章 糖尿病并发癫
第十一章 糖尿病与失眠症

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>糖尿病并发症饮食疗法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>糖尿病并发症防治400问
一、糖尿病并发症的一般知识
二、糖尿病性低血糖症
三、糖尿病酮症及酮症酸中毒
四、糖尿病高渗性昏迷
五、糖尿病乳酸性酸中毒
六、糖尿病并发感染
七、糖尿病性高血压
八、糖尿病性心脏病
九、糖尿病性脑血管病
十、糖尿病下肢血管病变
十一、糖尿病性肾病
十二、糖尿病性视网膜病变
十三、糖尿病性神经病变
十四、糖尿病性高脂血症
十五、糖尿病其它并发症
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>糖尿病并发症防治400问
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>手术并发症学
目 录
第一篇 相关因素
第一章 患者因素
第一节 解剖异常
第二节 个体差异
第三节 病情轻重
第二章 医生因素
第一节 术考粗疏
第二节 技术生疏
第三节 诊断失误
第三章 护理因素
第一节 护理管理
第二节 护理操作
第四章 社会因素
第一节 人群对手术的认识
第二节 卫生资源的配备
第二篇 术后感染
第一节 切口感染
第二节 切口裂开
第三节 败血症
第三篇 麻醉并发症
第五章 椎管内麻醉
第一节 脊麻
第二节 硬外麻
第六章 吸入麻醉
第一节 呕叶与反流
第二节 肺不张
第三节 肺水肿
第四节 肺栓塞
第五节 气胸
第六节 支气管痉挛
第七节 急性心肌梗塞
第八节 恶性高热
第九节 苏醒延迟
第七章 局部麻醉
第一节 急性药物中毒
第二节 副损伤
第四篇 系统并发症
第八章 呼吸系统
第一节 肺炎
第二节 肺不张
第三节 肺水肿
第四节 肺栓塞
第五节 呼吸衰竭
第九章 循环系统
第一节 出血
第二节 休克
第三节 输血反应
第四节 下肢深静脉血栓形成
第五节 心脏骤停
第六节 心律失常
第七节 心力衰竭
第十章 消化系统
第一节 急性胃扩张
第二节 应激性溃疡
第三节 肠梗阻
第四节 吻合口梗阻
第五节 吻合口瘘
第六节 黄疸
第七节 急性肝功能衰竭
第十一章 泌尿系统
第一节 尿潴留
第二节 泌尿系感染
第三节 急性肾功能衰竭
第十二章 神经精神系统
第一节 脑血管病
第二节 精神障碍
第三节 糖尿病昏迷
第五篇 各科并发症
第十三章 普通外科
第一节 乳腺癌手术
第二节 阑尾切除术
第三节 腹外疝修补术
第四节 肠梗阻手术
第五节 胃大部切除术
第六节 胆囊切除术
第七节 肝切除术
第八节 脾切除术
第十四章 神经外科
第一节 锥颅穿刺脑内血肿清吸术
第二节 颅内肿瘤切除术
第三节 椎管内肿瘤切除术
第十五章 胸外科
第一节 肺手术
第二节 气管及支气管手术
第三节 食管及贲门癌手术
第四节 纵隔肿瘤手术
第十六章 心外科
第一节 动脉导管未闭手术
第二节 房间隔缺损修补术
第三节 室间隔缺损修补术
第四节 二尖瓣置换术
第五节 法洛氏四联症根治术
第十七章 泌尿外科
第一节 输精管结扎术
第二节 输尿管切开取石术
第三节 肾切除术
第四节 肾移植术
第十八章 骨外科
第一节 四肢骨折内固定术
第二节 人工关节置换术
第三节 脊柱结核病灶清除术
第四节 带锁髓内钉骨折固定术
第十九章 耳鼻咽喉外科
第一节 乳突手术
第二节 筛窦手术
第三节 上领窦根治术
第四节 扁桃体摘除术
第五节 气管切开术
第六节 全喉切除术
第七节 支气管镜检查及呼吸道异物取除术
第八节 食管镜检查及食管异物取除术
第二十章 眼外科
第一节 白内障摘出术
第二节 抗青光眼手术
第三节 穿透性角膜移植术
第四节 视网膜脱离手术
第五节 眼球摘除术
第二十一章 口腔外科
第一节 牙拔除术
第二节 唇裂整复术
第三节 腭裂整复术
第四节 颌下腺切除术
第五节 腮腺切除术
第二十二章 妇产外科
第一节 经腹输卵管结扎术
第二节 人工流产术
第三节 子宫切除术
第二十三章 头颈外科
第一节 甲状腺切除术
第二节 颈动脉切除术
第二十四章 整形外科
第一节 皮瓣移植术
第二节 皮片移植术
第三节 皮肤软组织扩张术
第六篇 内窥镜及介入放射并发症
第二十五章 内窥镜手术
第一节 腹腔镜胆囊切除术
第二节 鼻内窥镜手术
第二十六章 介入放射术
第一节 穿刺插管术
第二节 数字减影血管造影和血管栓塞术
第三节 胸部介入放射术
第四节 腹部介入放射术

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>手术并发症学
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>糖尿病慢性并发症
目录
第一章 总 论
一 糖尿病慢性并发症的定义和分类
（一）糖尿病慢性并发症的定义
（二）糖尿病慢性并发症的分类
二 糖尿病慢性并发症的危害性及误解
（一）危害性
（二）误解
三 糖尿病慢性并发症发病学说
（一）糖尿病血管病变发病学说
（二）蛋白质的非酶性糖基化学说
（三）肌醇储备耗竭与多元醇通道活性增加学说
（四）代谢遗传发病学说
第二章 糖尿病心脏病
一 概说
（一）流行病学研究
（二）临床表现
（三）病因学研究概况
（四）中医对该病的认识
二 诊断与治疗
（一）诊断标准与疗效标准
（二）治疗
（三）目前的治疗水平
第三章 糖尿病性脑备管病
一 概说
（一）流行病学研究
（二）临床表现
（三）病因学研究概况
（四）中医对该病的认识
二 诊断与治疗
（一）诊断标准与疗效标准
（二）治疗
（三）目前的治疗水平
第四章 糖尿病下肢血管病变
一 概说
（一）流行病学研究
（二）临床表现
（三）病因学研究概况
（四）中医对该病的认识
二 诊断与治疗
（一）诊断标准与疗效标准
（二）治疗
（三）目前的治疗水平
第五章 糖尿病高血压
一 概说
（一）流行病学研究
（二）临床表现
（三）病因学研究概况
（四）中医对该病的认识
二 诊断与治疗
（一）诊断标准与疗效标准
（二）治疗
（三）目前的治疗水平
第六章 糖尿病肾病
一 概说
（一）流行病学研究
（二）临床表现
（三）病因学研究概况
（四）中医对该病的认识
二 诊断与治疗
（一）诊断标准与疗效标准
（二）治疗
（三）目前的治疗水平
第七章 糖尿病性视网膜病变
一 概说
（一）流行病学研究
（二）临床表现
（三）病因学研究概况
（四）中医对该病的认识
二 诊断与治疗
（一）诊断标准与分期
（二）治疗
（三）目前的治疗水平
第八章糖尿病性神经病变
一 概说
（一）流行病学研究
（二）临床表现
（三）病因学研究概况
（四）中医对该病的认识
二 诊断与治疗
（一）诊断标准
（二）治疗
（三）目前的治疗水平
第九章 糖尿病性高脂血症与脂肪肝
一 概说
（一）流行病学研究
（二）糖尿病血脂蛋白的代谢过程
（三）临床表现
（四）病因学研究概况
（五）中医对该病的认识
二 诊断与治疗
（一）诊断标准与疗效标准
（二）治疗
（三）目前的治疗水平
第十章 糖尿病慢性并发症自我调养与监护
一 心理调整
（一）糖尿病与心身疾病
（二）糖尿病与心身疗法
二 合理的生活调养
（一）运动疗法
（二）饮食疗法
（三）针灸疗法
（四）推拿按摩
三 自我监护
（一）自我监测
（二）自我调护
四 择医择药的原则
五 目前患者及社会不合理的经济负担
（一）患者重视程度不够
（二）宣传媒体的误导
（三）不健康的心态
（四）不必要的检查
（五）不正当竞争营销
（六） 某些医院因利益驱使
参考文献

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>糖尿病慢性并发症
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>糖尿病并发症防治400问
一 糖尿病并发症的一般知识
二 糖尿病性低血糖症
三 糖尿病酮症及酮症酸中毒
四 糖尿病高渗性昏迷
五 糖尿病乳酸性酸中毒
六 糖尿病并发感染
七 糖尿病性高血压
八 糖尿病性心脏病
九 糖尿病性脑血管病
十 糖尿病下肢血管病变
十一 糖尿病性肾病
十二 糖尿病性视网膜病变
十三 糖尿病性神经病变
十四 糖尿病性高脂血症
十五 糖尿病其它并发症
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>糖尿病并发症防治400问
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>痛风及其并发症的防治
一、基础知识
1、什么是痛风？痛风分哪几种类型？
2、中医对痛风是如何认识的？
3、痛风是一种世界性疾病吗？
4、痛风发生的机制是什么？
5、哪些人易患痛风？
6、痛风的发生与性别有什么关系？
7、痛风主要见于中老年人，而年轻人不容易患痛风吗？
8、痛风遗传吗？
9、痛风是一种终生性疾病吗？
10、

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>痛风及其并发症的防治
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>恶性肿瘤并发症实用疗法
目 录
第一节 恶性肿瘤并发症的发生及中药预防
第二节 肿瘤浸润与转移的临床规律
第三节 肿瘤放、化疗的病理改变及其浸润转移机理
第四节 恶性肿瘤几种常见综合征的诊治
第五节 肿瘤患者酸中毒的防治
第六节 水中毒的发生与防治
第七节 低钾血症的发生与防治
第八节 黄疸的发生与防治
第九节 恶性体腔积液及其治疗
第十节 癌痛的药物治疗
第十一节 感染
第十二节 骨转移癌的处治及骨膦治疗
第十三节 皮肤恶性肿瘤的分类及处治原则
第十四节 乳腺癌及其并发症的处治
第十五节 支气管肺癌及其并发症的处治
第十六节 肝癌的无水酒精注射及介入治疗的并发
症处理
第十七节 肿瘤的免疫治疗与中医中药
第十八节 静脉注射化疗药所致局部损伤的处治
第十九节 放射治疗毒副反应的防治
第二十节 抗肿瘤药物毒副作用的防治
第二十一节 晚期恶性肿瘤的化疗动态
第二十二节 化疗药所致体温升高的治疗
第二十三节 中医舌诊与肿瘤临床
第二十四节 扶正抗癌治则的研究及中成药的应用
第二十五节 放疗化疗中的饮食保健
第二十六节 肿瘤患者的营养疗法
第二十七节 肿瘤病人的心理调节
附1实体瘤的疗效标准
附2病人机能状况（karnofsky氏指数）机能状况
标准（Ps）
附3疼痛标准
附4肿瘤标记物
附5用化学药物可治愈的肿瘤
附6常见抗肿瘤药物的细胞周期
附7抗肿瘤药物名称、略语、剂量与用法
附8人体体表面积查阅表
附9抗癌药物副反应的分度标准（W11o）
附10联合化疗方案名称略语
附11影响放疗效果的因素
附12正常组织放射反应的几个阶段
附13解毒抗癌中草药
附14活血化瘀抗癌中草药
附15化痰抗癌中草药
附16扶正培本抗癌中草药
附17软坚散结抗癌中草药
附18恶性肿瘤常用中草药选择表
附19与遗传有关的体内恶性肿瘤在皮肤上的
可能标志
附20与内部肿瘤先后出现的皮肤病
附21肿瘤临床常见综合征
附22壶腹周围癌、胰头癌及总胆管结石的鉴别
附23上消化道出血程度的分级
附24血容量是否补足的临床观察

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>恶性肿瘤并发症实用疗法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>糖尿病并发症的防治
一 糖尿病并发症的概述
1 糖尿病是21世纪的主要疾病
……
二 糖尿病并发症的早期信号
1 为什么有的糖尿病患者不能得到早期诊断
……
三 正确认识和预防糖尿病并发症
1 糖尿病能根治吗
……
四 堵住源头，防止糖尿病并发症
1 治疗糖尿病的“五套马牛”原则
……
五 糖尿病并发症的预防和处理
1 糖尿病患者谨防昏迷
……
六 糖尿病伴随疾病的防治
1 糖尿病、高血压――“哥俩好”
……
附录・中国居民平衡膳食宝塔
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>糖尿病并发症的防治
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>胸外科并发症学
第一章 胸外科发展简史
第二章 胸外科解剖
第三章 胸外科术前常规检查
第四章 水、电解质酸碱平衡
第五章 围手术期营养
第六章 输血
第七章 感染
第八章 休克
第九章 胸外科术前常规准备
第十章 胸外科病人手术麻醉
第十一章 胸外科病人的术后常规处理
第十二章 高血压和心脏病患者围手术期处理
第十三章 糖尿病病人的围手术期

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>胸外科并发症学
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>普通外科诊疗术后并发症及处理
第一部分 普外基础
第二部分 普外科诊疗技术
第三部分 颈部疾病
第四部分 乳房疾病
第五部分 腹部疾病
第六部分 周围血管疾病
第七部分 淋巴疾病
第八部分 异物遗留

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>普通外科诊疗术后并发症及处理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>常用美容手术及并发症修复
1　美容手术学基础
1.1　正确的审美观及美容手术的医学基础
1.2　美容手术医师的基本素质要求
1.3　美容手术操作的基本原则及基本技术
1.4　美容手术前的美学设计、心理咨询、资料收集与管理
2　头面部美容手术及并发症修复
2.1　秃发的美容手术治疗与毛发移植术
2.2　眼眉部的美容手术及并发症修复
2.3　鼻部的美容手术
2.4　唇部的美容手术
2.5　耳部的美容手术
2.6　面部皮肤瘢痕、色素闱及肿瘤切除的美容手术
3　面部除皱术
3.1　除皱手术的历史与现状
3.2　皮肤老化的病理改变
3.3　面部的相关解剖学基础
3.4　除皱术的适应证
3.5　除皱术安全分离平面
3.6　切口选择和麻醉
3.7　不同部位除皱术的操作技术要点
3.8　内镜辅助下除皱术
3.9　面部小切口缝线悬吊除皱术
3.10　除皱术主要并发症及其修复
4　面部轮廓整表美容术
4.1　面型的解剖结构
4.2　面型的分类
4.3　诊断技术
4.4　面部轮廓整表美容的治疗原则及要求
4.5　颧骨整形美容
4.6　上、下颌骨畸形
4.7　碟面畸形矫正术
4.8　颏部畸形矫正术
4.9　下颌角肥大美容术
4.10　颞部充填术
5　乳房美容手术
5.1　隆乳术
5.2　乳房缩小成形术
5.3　乳房悬吊术
5.4　乳房再造术
5.5　乳头、乳晕再造要主
5.6　乳头畸形矫正术
5.7　男性乳房发育切除修整术
6　去脂减肥美容术
6.1　负压吸脂术
6.2　超声吸脂术
6.3　振动吸脂术
6.4　吸脂术常见并发症及修复
6.5　皮肤脂肪切除去脂术
7　全****的美容手术
7.1　处女膜修初术
7.2　阴道枪弛缩紧术
7.3　阴以大整复术
7.4　小服唇肥大缩小术
7.5　处女膜闭锁的手术治疗
7.6　****过长与包茎修复术
7.7　****过短的治疗
7.8　勃起功能障碍的治疗
7.9　两性畸形或变性手术外生殖器的修复重建
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>常用美容手术及并发症修复
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>器官移植并发症
第一篇 总论
第一章 与免疫抑制剂有关的并发症
第二章 器官移植后感染并发症
第三章 器官移植后肿瘤并发症
第四章 器官移植后多器官衰竭
第五章 器官移植后神经系统并发症
第二篇 各论
第六章 脑与神经组织移植并发症
第七章 角膜移植并发症
第八章 肺移植并发症
第九章 心脏移植并发症
第十章 肝脏移植并发症
第十一章 胰腺移植并发症
第十二章 胰一肾联合移植并发症
第十三章 胰岛移植并发症
第十四章 肾移植并发症
……
主要参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>器官移植并发症
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>糖尿病并发症饮食疗法
第一章  糖尿病的一般知识
糖尿病是一种什么亲的疾病？
什么是血糖？正常值是多少？
血粮的来源有哪些？
正常人的血粮有哪些去路？
血液中的葡萄糖有什么用途？
胰岛素的分泌与糖尿病的发生有什么关系？
胰岛素在体内起什么作用？
糖尿病有几种类型？
什么叫原发性糖尿病？
什么叫继发性糖尿病？
1

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>糖尿病并发症饮食疗法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>2型糖尿病及其并发症中西医结合诊疗与预防
第一章 糖尿病的现状与流行趋势    一、全球糖尿病的现状与流行趋势    二、我国糖尿病的现状与流行趋势    三、中国居民糖尿病患病率的各种差异特征    四、我国糖尿病患者死亡情况调查    五、我国糖尿病患者诊疗情况第二章 中医对糖尿病的认识    一、病因    二、病机    三、治疗第三章 糖尿病诊断及鉴别诊断    一、诊断标准    二、鉴别诊断第四章 糖尿病基础治疗  第一节 糖尿病饮食治疗    一、糖尿病饮食治疗的目的、对象和原则    二、饮食分配    三、各类常用食物的热能含量及营养价值    四、膳食举例    五、饮食治疗的注意事项    六、降低食物“血糖生成指数”的方法    七、糖尿病食谱    八、糖尿病饮食治疗的误区    九、糖尿病食物交换  第二节 糖尿病运动治疗    一、运动治疗的益处    二、运动疗法的基本作用原理    三、运动疗法的适应证和禁忌证    四、有关运动医学的名词解释    五、运动疗法的实施  第三节 糖尿病教育与心理治疗    一、糖尿病教育的目的    二、糖尿病教育的意义    三、糖尿病教育的对象    四、糖尿病教育的内容    五、糖尿病教育方式    六、糖尿病教育效果评价    七、糖尿病病人心理治疗第五章 2型糖尿病的中西医治疗及预防    一、概述    二、病因病理    三、诊断    四、治疗    五、预防    六、中医药治疗糖尿病的研究进展第六章 糖尿病急性并发症的中西医治疗及预防  第一节 糖尿病酮症酸中毒    一、病因病理    二、诊断    三、治疗    四、预防    五、最新进展  第二节 糖尿病非酮症高渗性昏迷    一、病因病理    二、诊断    三、治疗    四、预防  第三节 低血糖症    一、病因病理    二、诊断    三、治疗    四、预防第七章 糖尿病慢性并发症的中西医治疗及预防  第一节 糖尿病合并高血压    一、病因病理    二、诊断    三、治疗    四、预防    五、最新进展  第二节 糖尿病合并冠心病    一、病因病理    二、诊断    三、治疗    四、预防    五、最新进展  第三节 糖尿病合并脑血管病    一、病因病理    二、诊断    三、治疗    四、预防    五、最新进展  第四节 糖尿病视网膜病变    一、病因病理    二、诊断    三、治疗    四、预防    五、最新进展  第五节 糖尿病肾病    一、病因病理    二、诊断    三、治疗    四、预防    五、最新进展  第六节 糖尿病合并脂代谢紊乱    一、病因病理    二、诊断    三、治疗    四、预防    五、最新进展  第七节 糖尿病周围神经病变    一、病因病理    二、诊断    三、治疗    四、预防    五、最新进展  第八节 糖尿病足    一、病因病理    二、诊断    三、治疗    四、预防    五、最新进展  第九节 糖尿病勃起功能障碍    一、病因病理    二、诊断    三、治疗    四、预防    五、最新研究  第十节 糖尿病自主神经病变    一、糖尿病心脏自主神经病变    二、糖尿病性胃轻瘫    三、糖尿病腹泻    四、糖尿病便秘    五、糖尿病泌汗异常    六、糖尿病神经源性膀胱  第十一节 糖尿病与皮肤病变    一、糖尿病合并皮肤瘙痒症    二、糖尿病合并皮肤细菌感染    三、糖尿病合并手足癣    四、糖尿病性大疱病  第十二节 糖尿病性代谢性骨病    一、糖尿病与骨关节病    二、糖尿病与骨质疏松第八章 代谢综合证(MS)    一、病因病理    二、诊断    三、治疗    四、预防第九章 名老中医治疗糖尿病经验    一、施今墨诊治经验    二、祝谌予诊治经验    三、吕仁和诊治经验    四、林兰诊治经验    五、仝小林诊治经验    六、任继学诊治经验    七、程益春诊治经验附录  附录一：诊断标准  附录二：治疗糖尿病及其并发症的常用药品  附录三：胃转流手术治疗2型糖尿病的研究进展  附录四：糖尿病足的外科治疗
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>2型糖尿病及其并发症中西医结合诊疗与预防
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>糖尿病并发症防与治
1 认识糖尿病并发症2 科学养生防治糖尿病并发症3 饮食防治糖尿病并发症4 合理运动防治糖尿病并发症5 西医防治糖尿病并发症6 中医防治糖尿病并发症
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>糖尿病并发症防与治
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>糖尿病并发症防治手册
第一章 可怕的慢性并发症  糖尿病慢性并发症知多少  我国糖友对并发症的认识远远不够第二章 预防并发症的关键点  从源头抓起——早期抹去高血糖印记    1型糖尿病的“代谢记忆”    2型糖尿病的“代谢记忆”    精细降糖，平稳达标    追求降糖和血管获益的最佳平衡  从塑身开始——减去多余脂肪    看看自己胖不胖    肥胖的危害    瘦身路上的艰辛    瘦身成功的获益  从养性做起——保持良好心态    负性情绪，并发症的加速器    谨遵六字方针，让并发症急刹车  从起居调整——重塑生活方式    糖尿病是吃出来的    不光要管住嘴，还要迈开腿  从治疗理念改变——重新审视低血糖    旗鼓相当，低血糖VS高血糖    洞察秋毫，你对低血糖“敏感”吗    谨小慎微，预防低血糖    低血糖的合理治疗第三章 并发症的防与治  让高血压低头——糖尿病合并高血压的防与治    糖尿病和高血压是一对“孪生兄弟”    降压和降糖，哪个更重要    改变生活方式，既降压又降糖    合理降压，选药是关键    细说各类降压药    自我按摩，辅助调糖降压    具有辅助降压降糖作用的果蔬    如何选择降压中成药  掐断心脑血管病的导火索——降脂    糖尿病与血脂异常常常“结伴而行”    为什么糖尿病患者易发生血脂异常    如何防治糖尿病血脂异常    糖尿病血脂异常的血脂控制目标    防治血脂异常必须管住嘴    糖尿病血脂异常的饮食偏方    降脂不能闷头跑，定期监测不可少    治疗糖尿病血脂异常的常用中成药  让心脏充满活力——糖尿病冠心病的防与治    冠心病对糖尿病患者“青睐有加”    糖尿病合并冠心病不同于普通的冠心病    如何应对心血管危机    得了冠心病一定要“介入”治疗吗    治疗糖尿病冠心病的常用中成药  让心灵之窗永放光彩——糖尿病眼病的防与治    视网膜病变是糖尿病患者失明的重要原因    糖尿病患者应谨防“失明”    多长时间查一次眼底    糖尿病视网膜病变的防与治    激光治疗要选好时机    糖尿病视网膜病变的常用中成药    糖尿病患者易发白内障    糖尿病患者如何防治白内障  让泌尿系统畅通无阻——糖尿病肾病的防与治    糖尿病的哪些因素对肾脏不利    只有早期肾病可以逆转    糖尿病患者如何保护肾脏    糖尿病肾病患者要选用“优质低蛋白”饮食    糖尿病肾病患者的饮食安排    得了肾病就是“肾虚”了吗    治疗糖尿病肾病的常用中成药  让你健步如飞——糖尿病足的防与治    糖尿病足都有哪些表现    糖尿病足是怎样发生的    间歇性跛行问题出在哪里    怎样防治间歇性跛行    脚被扎了，怎么会不知道    糖尿病患者，请保护好你的脚    如何早期发现糖尿病足    糖尿病足自我检查“四部曲”    怎样避免“断足截肢”的悲剧发生    糖友护脚秘籍    什么样的鞋袜适合糖尿病患者    治疗糖尿病足的常用中成药  让你重振雄风——糖尿病阳痿的防与治    糖尿病与阳痿密切相关    重视防治工作，重振雄风    壮阳药别乱试    治疗糖尿病阳痿的常用中成药  让大脑指挥有方——糖尿病中枢神经病变的防与治    及时发现指挥中心故障    糖尿病中枢神经病变产生的原因    糖尿病中枢神经病变的防与治    良好的饮食习惯也能益智    健脑自我保健按摩    治疗糖尿病中枢神经病变的常用中成药  让神经四通八达——糖尿病周围神经病变的防与治    五花八门的糖尿病周围神经病变    多管齐下，应对糖尿病周围神经病变    得了糖尿病，为啥爱出汗    得了糖尿病，为什么排不出尿    早期预防糖尿病周围神经病变    治疗糖尿病周围神经病变的常用中成药    胃为什么罢工了    糖尿病胃轻瘫如何治疗    治疗糖尿病胃轻瘫的常用中成药    糖尿病腹泻和糖尿病便秘是怎么回事    糖尿病腹泻、便秘的治疗    糖尿病腹泻、便秘的简易按摩  让你永远快乐、充满激情——糖尿病抑郁症的防与治    糖尿病怎么能和抑郁症扯上关系    你抑郁了吗    抑郁是糖尿病恶化的加速器    如何摆脱抑郁    抑郁的自我按摩    果蔬茶酒，食疗驱郁  让皮肤永葆青春——糖尿病皮肤病的防与治    糖尿病皮肤病知多少    怎样摆脱皮肤瘙痒    药浴防治糖尿病皮肤病    药浴的注意事项    糖尿病患者谨防烫伤    烫伤的治疗方法  让你神清语利、步伐矫健——糖尿病脑血管病的防与治    不可不知的数据    糖尿病与脑血管病关系密切    糖尿病脑血管病如何预防    糖尿病脑血管病的自我调护  让你的肝脏不受损伤——糖尿病肝损伤的防与治    糖尿病与脂肪肝有何关系    糖尿病伴脂肪肝危害大    如何防治糖尿病脂肪肝    糖尿病脂肪肝患者的饮食调整  与“炎症”说拜拜——糖尿病感染的防与治    糖尿病与感染“狼狈为奸”    糖尿病患者容易出现哪些感染    糖尿病患者感染的常见原因    如何防治糖尿病感染  让你的结构坚强牢固——糖尿病骨质疏松的防与治    糖尿病患者为什么易患骨质疏松    糖尿病骨质疏松的危害    糖尿病骨质疏松的防与治    选对时问补对钙    补钙不要陷入误区  让你口腔清爽、牙口健康——糖尿病口腔疾病的防与治    牙齿掉得快，糖尿病在作怪    为什么糖尿病会影响到口腔    糖尿病患者易患哪些口腔疾病    糖尿病口腔疾病的防与治附：本书涉及穴位图
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>糖尿病并发症防治手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>造口并发症的防治
" 目  录
第一篇  基础理论
第一章造口概论
第一节造口的相关解剖及生理
一、造口的定义
二、造口相关部位的解剖
三、造口的生理
第二节造口的分类
一、泌尿系统造口
二、消化系统造口
三、呼吸系统造口
第二章 造口相关疾病
第一节 炎性肠病
一、炎性肠病的定义
二、炎性肠病的病因
三、炎性肠病的症状
四、炎性肠病的治疗
第二节 结直肠恶性肿瘤
一、结直肠恶性肿瘤的病因
二、结直肠恶性肿瘤症状
三、结直肠恶性肿瘤治疗
第三节 肠梗阻
一、肠梗阻的定义
二、肠梗阻的病因
三、肠梗阻症状
四、肠梗阻的治疗
第四节 大肠穿孔
一、肠穿孔的定义
二、肠穿孔的病因
三、肠穿孔的症状
四、肠穿孔的治疗
第五节 食管癌
一、食道癌的定义
二、食道癌的病因
三、食管癌的症状
四、食道癌的治疗
第六节 胃 癌
一、胃癌的定义
二、胃癌的病因
三、胃癌的症状
四、胃癌的治疗
第七节 家族性腺瘤性息肉病
一、家族性腺瘤性息肉病的定义
二、家族性腺瘤性息肉病的病因
三、家族性腺瘤性息肉病的症状
四、家族性腺瘤性息肉病的治疗
第八节 膀胱癌
一、膀胱癌的定义
二、膀胱癌的病因
三、膀胱癌的症状
四、膀胱癌的预防
五、膀胱癌的治疗
第九节 喉癌
一、喉癌的定义
二、喉癌的病因
三、喉癌的症状
四、喉癌的治疗
第十节 胰腺癌
一、胰腺癌的定义
二、胰腺癌的病因
三、胰腺癌的症状
四、胰腺癌的治疗
第三章 各类造口手术
第一节 回肠造口术
第二节 胃造口术
一、传统手术
二、经皮内镜下胃造口术及经皮内镜下空肠造口术
第三节 泌尿系统造口术
一、输尿管皮肤造口术
二、回肠代膀胱术
第四节 胆囊造口术
第五节 气管切开术
一、气管的解剖
二、适应证
三、禁忌证
四、术前准备
五、手术步骤
六、手术并发症
第二篇造口护理及并发症的发生原因
第四章 造口护理
第一节 肠造口护理
一、肠造口手术前的护理
二、肠造口手术后护理
三、肠造口患者的心理护理
四、出院指导及护理
第二节 胃造口护理
一、护理评估
二、护理措施
三、健康教育
第三节 泌尿系统造口护理
一、护理评估
二、护理要点
第四节 胆囊造口护理
一、护理评估
二、护理措施
三、健康教育
第五节 气管造口护理
一、护理措施
二、并发症发生的原因及危害
三、并发症的预防及护理
四、康复护理
五、饮食指导
六、定期复查
第六节 造口患者的健康教育
第七节 造口患者的饮食指导
一、造口术后早期饮食指导
二、出院后饮食指导
第五章 造口并发症的发生原因
第一节 肠造口并发症
一、肠造口缺血坏死
二、肠造口出血
三、造口皮肤黏膜分离
四、肠造口回缩
五、肠造口狭窄
六、肠造口水肿
七、造口黏膜肉芽肿
八、肠造口脱垂
九、造口旁疝
十、造口穿孔
十一、肠造口周围皮肤并发症
第二节 其他造口并发症
一、造口周围线结反应
二、造口周围脓肿
三、造口旁皮肤癌细胞蔓延
四、肠造口与腹部切口形成瘘管
第三篇造口并发症的预防及治疗
第六章 造口并发症的治疗
第一节 造口的评估
一、一般评估
二、造口周围皮肤评估
三、造口排泄状况评估
第二节 造口并发症的换药技术
一、护理目标
二、操作步骤
三、注意事项
第三节 造口用品及其在并发症中的应用
一、造口用品简介
二、造口用品在并发症中的应用
第七章 造口并发症的护理
第一节 肠造口并发症的护理
一、肠造口缺血坏死的护理
二、肠造口出血的护理
三、造口皮肤黏膜分离的护理
四、肠造口回缩的护理
五、肠造口狭窄的护理
六、肠造口水肿的护理
七、造口黏膜肉芽肿的护理
八、肠造口脱垂的护理
九、造口旁疝的护理
十、肠造口周围皮肤并发症
第二节 其他造口并发症的护理
一、造口周围线结反应的护理
二、造口旁溃疡的护理
三、造口周围脓肿的护理
四、肠造口皮肤黏膜分离毗邻输尿管皮肤造口的护理
第八章 肠造口并发症的预防
一、肠造口缺血坏死的预防
二、肠造口出血的预防
三、肠造口回缩的预防
四、肠造口狭窄的预防
五、造口皮肤黏膜分离的预防
六、造口旁疝的预防
七、肠造口脱垂的预防
八、肠造口周围皮肤并发症的预防
参考文献    "
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>造口并发症的防治
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>血糖这样降最有效
Part1 了解糖尿病
血糖，您了解多少
什么是糖尿病
这些人要警惕糖尿病
难道我患了糖尿病
糖尿病的黄金饮食原则
做好糖尿病的预防工作
当心并发症悄悄接近你
糖尿病的治疗原则
Part2 糖尿病并发症的饮食调理
糖尿病并发足病怎么吃
糖尿病并发脑病怎么吃
糖尿病并发心脏病怎么吃
糖尿病并发肾功能衰竭怎么吃
糖尿病并发尿毒症怎么吃
糖尿病并发高血压怎么吃
糖尿病并发血脂异常怎么吃
糖尿病并发脂肪肝怎么吃
糖尿病并发便秘怎么吃
糖尿病并发痛风怎么吃
糖尿病并发视力模糊怎么吃
糖尿病并发白内障怎么吃
糖尿病并发视网膜病变怎么吃
糖尿病并发口腔病变怎么吃
糖尿病并发皮肤病怎么吃
糖尿病并发性病怎么吃
糖尿病并发神经病变怎么吃
Part3 怎样吃出平稳血糖
儿童糖尿病患者怎么吃
妊娠糖尿病患者怎么吃
老年糖尿病患者怎么吃
消瘦型糖尿病患者怎么吃
肥胖型糖尿病患者怎么吃
Part4 揭开营养素的降糖秘密
蛋 白 质 构成生命的物质基础
膳食纤维 有效改善胰岛素的水平
糖类代谢 生命活动的调节者
脂肪代谢 人体能量的源泉
钙 元 素 骨代谢的重要使者
维生素 C 增强胰岛素作用，调节糖代谢
锌 元 素 改善胰岛素活性，有效调节血糖
铬 元 素 改善葡萄糖耐量，降低血糖
Part5 让血糖不再飙升的活力法则
减轻体重关键靠运动
运动对控制血糖有益处
五大方法令运动持之以恒
运动降糖心情愉悦很重要
降糖的黄金时刻：餐后2小时
准备活动，开启“降糖路”
散步是最简易的运动疗法
有氧运动or无氧运动
选择适合自己的有氧运动
运动降糖，抓住零散时间
儿童糖尿病患者的运动计划
老年人运动，治病又养生
Part6 多种多样的中医降糖法
中医调养法
拔罐降糖法
刮痧降糖法
艾灸降糖法
按摩降糖法
饮茶降糖法
Part7 优质生活从健康心态开始
正确看待糖尿病的遗传特质
关爱是战胜疾病的关键
必不可少的身体清洁
长寿不是奢望
融入社会是健康第一步
杜绝坏情绪，保持乐观心态
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>血糖这样降最有效
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>手外科手术并发症及其对策
第一章 手部开放陛损伤早期手术的并发症
第一节 手外伤急救处理的并发症
一、止血方法不当
二、伤肢未固定
三、断肢(指)处理不当
第二节 清创术
一、清创时机不当
二、清创方法不当
第三节 开放性骨折与脱位
一、未立即复位
二、固定方法不当
三、早期骨缺损
第四节 神经与肌腱损伤
一、神经与肌腱损伤的遗漏
二、神经与肌腱的错误缝接
三、缝合的肌腱发生断裂
第五节 手或手指血液循环状况的判断
第六节 创口闭合
一、直接缝合与皮纹垂直的创口
二、直接司合伤口张力过大
三、皮肤血液循环状况的判断不当
第七节 指端损伤处理的并发症
一、甲根残留和甲床损伤
二、皮肤张力过大
三、残端组织处理不当
第八节 拇指、手指皮肤脱套伤处理的并发症
一、手指保留长度不当
二、皮瓣选择不当
三、术后皮瓣血供不良
四、术后功能不良
第二章 断肢(指)再植的并发症
第一节 断肢再植的并发症
一、血容量不足和失血性休克
二、急性肾功能损害
三、深静脉血栓形成及肺栓塞
四、骨筋膜室综合征
五、血管危象
六、术后伤口感染及大出血
七、再植肢体坏死
八、皮肤部分坏死
九、骨延迟愈合或不愈合
十、肌腱粘连与肌腱断裂
十一、关节僵硬
十二、神经功能恢复不良
十三、再植肢体外观改变
第二节 断指再植的并发症
一、适应证选择不当
二、血管缺损
三、神经缺损
四、肌腱缺损
五、内固定方法不当
六、血管危象
七、肌腱断裂与肌腱粘连
八、术后功能不良
九、再植失败
第三章 手部皮肤损伤修复的并发症
第一节 皮肤移植的并发症
一、皮片选择不当
二、皮肤移植方法不当
三、皮肤移植术后处理不当
第二节 随意皮瓣移植的并发症
一、皮瓣血运障碍
二、皮瓣坏死后处理
第三节 带血管蒂皮瓣移植的并发症
一、皮瓣远端坏死的常见原因
二、皮瓣坏死后处理
第四节 吻合血管的皮瓣移植的并发症
一、皮瓣手术时机选择不当
二、供受区血管处理不当
三、皮瓣的血管变异
四、皮瓣血供障碍
第五节 皮瓣移植的特别注意事项
第四章 手部血管损伤修复的并发症
第一节 血管吻合术的并发症
一、血管清创不彻底
二、血管吻合张力过大
三、血曾壁内翻
四、缝针穿过血管后壁
五、血管端侧吻合的并发症
六、吻合口出血
七、血管扭曲和受压
第二节 血管移植术的并发症
一、移植血管选择不当
二、移植血管长度不当
三、移植静脉方向错误
第三节 血管栓塞
第四节 血管痉挛
第五章 周围神经损伤修复的并发症
第一节 神经损伤的诊断
一、神经损伤的遗端
二、神经损伤性质判断错误
第二节 于术时机选择不当
第三节 神经缝合术的并发症
一、神经残端瘢痕切除不彻底
二、神经缝合张力过大
三、神经断端对合不良
四、缝合的神经断裂
第四节 神经松解术的并发症
一、神经干及其分支损伤
二、神经束损伤
第五节 神经移植术的并发症
一、移植神经取材不当
二、神经移植方法不当
第六节 臂从神经损伤修复术的并发症
一、臂丛神经损伤的性质和部位判断错误
二、臂丛神经损伤治疗方法选择不当
第七节 止中神经损伤r术的J{：发疵
第八节 桡神经损伤丁术的肝发疵
第九节 Jt神经损伤r术的"发症
第六章 手部肌腱手术的并发症
第一节 再肌腱手术时机选择不当
第二节 游离肌腱移枇术的并发症
一、手术时机选择不当
二、切取掌长肌腱时伤及正中神经
三、指浅屈肌腱残端处理不当
四、弓弦状畸形
五、移植肌腱张力不当
六、移植肌腱断裂
七、移植肌腱粘连
第三节 肌腱粘连松解术的并发症
一、肌睫粘连松解不彻底
二、止血不完善
三、术后功能锻炼不当
第四节 肌腱移位术的并发症
一、动力肌选择不当
二、移位肌腱的方向不当
三、肌腱移位求的原则
第七章 手部骨与关节损伤早期并发症
第一节 指骨骨折手术的并发症
一、固定方法不当
二、固定位置不当
三、骨折复位不良
四、肌腱损伤与肌腱粘连
五、关节功能障碍
第二节 冉掌骨骨折手术的并发症
一、固定方法不当
二、固定位置不当
三、关节功能障碍
第三节 腕舟骨骨折的并发症
一、腕舟骨骨折的诊断延误
二、外固定方法不当
三、内固定方法不当
四、舟骨骨折不愈合
第四节 靠桡骨远端骨折下术的并发症
一、治疗方法选择不当
二、固定方法不当
三、术后处理不当
四、交感神经反射性骨萎缩
第五节 指问关节侧副韧带损伤手术的并发症
一、诊断遗漏
二、治疗方法不当
第六节 第1腕掌关节骨折脱位手术的并发症
一、复位不准确
二、固定方法选择不当
第七节 月骨脱位手术的并发症
一、手术方法选择不当
二、月骨无菌性坏死
第八节 月骨无菌性坏死手术的并发症
一、诊断错误与遗漏
二、治疗方法选择不当
第九节 经舟骨月骨周围脱位的并发症
一、诊断错误与遗漏
二、治疗方法选择不当
第十节 远侧桡尺关节损伤的并发症
一、诊断错误与遗漏
二、治疗方法选择不当
第八章 手部骨与关节损伤的晚期并发
第一节 骨缺损
第二节 骨折延迟愈合和不愈合
第三节 骨折畸形愈合
第四节 关节假硬和强直
第五节 创伤性关节炎
第九章 手指再造手术的并发症
第一节 皮瓣植骨再造拇指的并发症
一、皮瓣选择不当
二、感觉功能障碍
三、皮瓣血供不佳
四、植骨吸收
第二节 足趾移植再造拇指的并发症
一、足趾选择不当
二、足趾血管变异
三、移植趾外形不佳
四、移植趾血液循环障碍
五、足趾移植失败
第三节 足趾移植再造手指的并发症
一、功能性手指再造的并发症
二、修饰性手指再造的并发症
三、血管危象
第四节 四趾甲皮瓣移植的并发症
一、四趾甲皮瓣移植的并发症
二、趾甲皮瓣移植的并发症
第十章 掌腱膜挛缩症手术的并发症
第一节 丁术时机选择小
第二节 手术的并发症
一、皮瓣坏死
二、血肿形成
三、指神经、血管损伤
四、肌腱粘连
五、术后病变复发
第十一章 骨筋膜室综合征的并发症
第一节 诊断延误
第二节 手术时机不当
一、骨筋膜室切开减压时机不当
二、肌腱和骨关节手术时机不当
第三节 手术方法不当
一、骨筋膜室切开减压不完全
二、挛缩松解不完全
第四节 功能障碍
第十二章 手部感染性疾病手术的并发症
第一节 甲沟炎手术的并发症
一、感染扩散，病程迁延
二、手术方法不当
第二节 脓性指头炎手术的并发症
一、手术时机不当
二、手术方法不当
三、手指末梢感觉功能障碍
第三节 化脓性腱鞘炎手术的并发症
一、诊断延误
二、指固有动脉和神经损伤
三、手术方法不当
第四节 化脓rl滑囊炎手术的并发症
第五节 指蹼问隙感染丁术的并发症
第六节 掌深『HJ隙感染r术的并发症
第七节 化脓性骨髓炎丁术的并发症
第八节 化脓性关节炎于术的并发症
第九节 非她删分枝杆蔺感染手术的并发症
第十节 腕戈竹结核手术的并发赫
第十一节 腱滑膜结核r术的并发症
一、肌姥姥损+肌腱牯连
二、病程迁延，窦道形成
第十三章 周围神经卡压综合征手术的并发症
第一节 胸廓出u综合征r术的并发症
一、诊断锚误或漏谚
二、手术时机不当
三、手术方法选择不当
四、手术并发症
第二节 肩胛上二神经卡压于术的J{：发症
一、诊断错误
二、手术时机不当
三、手术方法选择不当
四、手术并发症
第三节 腋神经扣压——四边扎综合征
手术的并发痱
一、诊断错误
二、手术并发症
第四节 肘管综合扯}术的并发症
一、诊断错误
二、手术并发症
第五节 腕部尺神经卡』矗——Qym管
综合艇手术的，F发症
一、诊断错误
二、手术并发症
第八节 腕管综合ilF F术的并发症
一、腕横韧带切开不完全
二、正中神经返支损伤
三、正中神经掌度支损伤
四、痛性瘢痕
五、症状复发
第七节 旋前圆肌综合征手术的并发疵
、诊断错误
二、手术并发症
第八节 Iii『骨问神经k址综合征于术的
并发症
一、诊断错误
二、手术并发症
笫九节 匕臂桡神经卡爪于术的并发症
一。诊断错误
二、手术并发症
第十节 竹间后神经¨k r术的并发症
一、诊断错误’
二、手术并发症
第十一节 肯桡神经感觉支卡压综合nl：r术的
并发症
一、诊断错误
二、手术并发症
第十二节 梨状肌综合征乎术的并发赫．．
一、诊断错误
二、手术并发症
第十三节 i协股外侧皮神经卡压综合征r术的
并发症
一、诊断错误
二、手术并发症
第十四节 腓总神经k压综合征手术的
j}发症
一、诊断错误
二、手术并发症
第十四章 狭窄性腱鞘炎手术的并发症
第一节 指埘肌腱狭窄’陀腱鞘炎手术的井发症
一、激素局部注射的并发症
二、指冲经损伤
三、蜒鞘松解不彻底或切开过度
四、切口感裟
第二节 桡骨苇突狭窄性腱鞘炎手术的并发赫
一、激素局部注射的并发往
二、手术并发症
第十五章 手部先天性畸形手术的并发症
第一节 多指手术的并发籼．
一、切除指选择不当
二、骨骺残留
三、掌骨头未修整
四、残留畸形
五、BilllaIl卜cl【lllquet术的并发症
笫二节 并指手术的并发症
一、手术时机不当
二、瘢痕挛缩
三、并指复发
第三节 分裂F手术的并发症
第四节 巨指畸形手术的并发痛
第五节 先天性朋；状缩窄带综合征r术的 并发症
第六节 马德隆畸形手术的并发症
第七节 先天性桡骨缺如手术的并发症
第十六章 手部肿瘤手术的并发症
第一节 腱鞘囊肿手术的并发症
一、手术时机不当
二、肿瘤复发
第二节 表皮样囊肿手术的并发；
一、感染
二、肿瘤复发
第三节 【IiL管瘤手术的并发症
一、出血
二、病变切除不彻底
三、肿瘤复发
第四节 淋巴管瘤手术的并发症淋巴漏
第五节 JIIL管球痛手术的并发症
一、诊断错误
二、手术未找到肿值
三、肿瘤复发
第六节 腱鞘厅细胞瘤手术的并发症肿瘤复发
第七节 神经鞘痫l|术的外发如
一、切除神经干
二、神经损伤
笫八节 动静脉瘘手术的并发症
一、手指血供不良
二、肿瘤复发
第九节 黏液囊肿手术的并发症肿瘤复发
第十节 内生软骨瘤手术的并发症
一、肿瘤组织残留
二、肿瘤复发
第十一节 骨巨细胞瘤手术的并发疵
第十二节 骨样骨瘤手术的并发症
一、误诊和漏诊
二、肿瘤复发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>手外科手术并发症及其对策
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>UNIX系统编程: 通信、并发与线程
第一部分  基础知识
第1章    技术对程序的影响  3
1.1  术语的变化  3
1.2  时间和速度  5
1.3  多道程序设计和分时  6
1.4  应用层的并发  8
1.4.1  中断  8
1.4.2  信号  9
1.4.3  输入和输出  10
1.4.4  进程、线程和资源共享  10
1.4.5  具有共享内存的多个处理器  11
1.4.6  网络作为计算机  11
1.5  安全和容错  12
1.6  非法入侵造成的缓冲区溢出  13
1.6.1  缓冲区溢出的后果  14
1.6.2  缓冲区溢出和安全  16
1.7  UNIX标准  17
1.8  延伸阅读  19
第2章    程序、线程和进程  21
2.1  程序是如何成为进程的  21
2.2  线程和执行线程  22
2.3  程序映象的布局  23
2.4  库函数调用  26
2.5  函数返回值和错误  29
2.6  参数数组  31
2.6.1  用makeargv函数创建一个数组  32
2.6.2  makeargv函数的实现  34
2.7  线程安全函数  38
2.8  静态变量的使用  40
2.9  静态对象的结构  42
2.10  进程环境  48
2.11  进程终止  51
2.12  练习：一个env实用程序  54
2.13  练习：消息日志  55
2.14  延伸阅读  57
第3章    UNIX中的进程  58
3.1  进程标识符  58
3.2  进程状态  60
3.3  UNIX 进程创建和fork函数  63
3.4  wait函数  70
状态值  76
3.5  exec函数  77
3.6  后台进程和守护进程  83
3.7  临界区  86
3.8  练习：进程链  87
3.9  练习：进程扇  88
3.10  延伸阅读  89
第4章    UNIX I/O  90
4.1  设备术语  90
4.2  读/写  91
4.3  打开和关闭文件  102
4.4  select函数  107
4.5  poll函数  116
4.6  文件表示  119
4.6.1  文件描述符  119
4.6.2  文件指针和缓冲  122
4.6.3  文件描述符的继承  124
4.7  过滤器和重定向  128
4.8  文件控制  132
4.9  练习：原子日志  135
原子日志库  139
4.10  练习：cat实用程序  141
4.11  延伸阅读  143
第5章    文件和目录  144
5.1  UNIX文件系统导航  144
5.1.1  当前工作目录  145
5.1.2  搜索路径  150
5.2  目录访问  151
5.2.1  访问文件状态信息  153
5.2.2  确定文件的类型  156
5.3  UNIX文件系统实现  157
5.3.1  UNIX文件实现  158
5.3.2  目录实现  161
5.4  硬链接和符号链接  161
5.4.1  创建或删除一个链接  162
5.4.2  创建和删除符号链接  167
5.5  练习：which命令  172
5.6  练习：邮件通知程序  173
5.7  练习：新闻通知程序  176
5.8  练习：遍历目录  177
5.9  延伸阅读  179
第6章    UNIX特殊文件  180
6.1  管道  180
6.2  流水线  184
6.3  FIFO  189
6.4  管道与客户机-服务器模型  193
6.5  终端控制  200
规范和非规范的输入处理  208
6.6  音频设备  212
6.7  练习：音频  218
6.8  练习：屏障  220
6.9  练习：stty命令  221
6.10  练习：重提客户机-服务器  222
6.11  延伸阅读  222
第7章    项目：令牌环  224
7.1  环形拓扑  224
7.2  环的形成  226
7.3  环的探讨  232
7.4  简单通信  234
7.5  用令牌环实现互斥  235
7.6  用投票实现互斥  237
7.7  匿名环中的领导者选举  238
7.8  用于通信的令牌环  240
7.9  流水线预处理机  242
7.10  并行环算法  244
7.10.1  图像过滤  244
7.10.2  矩阵乘法  247
7.11  弹性环  248
7.12  延伸阅读  249
第二部分  异步事件
第8章    信号  253
8.1  信号的基本概念  253
8.2  信号的产生  254
8.3  对信号掩码和信号集进行操作  259
8.4  捕获和忽略信号—sigaction  266
8.5  等待信号—pause、sigsuspend和sigwait  272
8.5.1  pause函数  272
8.5.2  sigsuspend函数  274
8.5.3  sigwait函数  282
8.6  处理信号：错误和异步信号安全  283
8.7  用siglongjmp和sigsetjmp进行程序控制  286
8.8  使用异步I/O编程  288
8.9  练习：转储统计  300
8.10  练习：同时处理慢速设备  301
8.11  延伸阅读  301
第9章    时间和定时器  303
9.1  POSIX时间  303
9.1.1  用从Epoch开始的秒数表示时间  304
9.1.2  显示日期和时间  305
9.1.3  使用struct timeval表示时间  308
9.1.4  使用实时时钟  311
9.1.5  耗时和处理器时间的对比  313
9.2  睡眠函数  316
9.3  POSIX:XSI间隔定时器  319
9.4  实时信号  323
9.5  POSIX:TMR间隔定时器  328
9.6  定时器漂移、溢出和绝对时间  333
9.7  延伸阅读  344
第10章    项目：虚拟定时器  345
10.1  项目概述  345
10.2  简单的定时器  348
10.3  对5个定时器中的一个进行设置  351
10.3.1  virtualtimers对象  351
10.3.2  hardwaretimer对象  353
10.3.3  主程序实现  354
10.3.4  用show谱写定时器代码  355
10.4  使用多个定时器  361
10.4.1  设置多个定时器  364
10.4.2  用多个定时器进行测试  365
10.5  多定时器的健壮实现  369
10.6  POSIX:TMR定时器的实现  371
10.7  一个小型的cron工具mycron  372
10.8  延伸阅读  372
第11章    项目：破解shell  373
11.1  构建一个简单的shell  373
11.2  重定向  378
11.3  流水线  382
11.4  前台的信号处理  385
11.5  进程组、会话和控制终端  391
11.5.1  进程组  391
11.5.2  会话  393
11.6  ush中的后台进程  396
11.7  作业控制  403
11.8  ush的作业控制  407
11.8.1  一个作业列表对象  407
11.8.2  ush中的作业列表  409
11.8.3  ush中的作业控制  409
11.8.4  等待流水线时的进程行为  410
11.9  延伸阅读  411
第三部分  并  发
第12章    POSIX线程  415
12.1  监视文件描述符的方法  415
12.2  使用线程监视多个文件描述符  417
12.3  线程管理  420
12.3.1  用ID引用线程  421
12.3.2  创建一个线程  422
12.3.3  分离和连接  423
12.3.4  退出和取消  426
12.3.5  向线程传递参数并返回值  429
12.4  线程安全  438
12.5  用户级线程 VS 内核级线程  439
12.6  线程属性  442
12.6.1  线程状态  443
12.6.2  线程栈  444
12.6.3  线程调度  446
12.7  练习：并行文件复制  450
12.8  延伸阅读  451
第13章  线程同步  452
13.1  POSIX同步函数  452
13.2  互斥锁  453
13.2.1  创建并初始化一个互斥量  454
13.2.2  销毁一个互斥量  455
13.2.3  锁定和解锁互斥量  456
13.2.4  保护不安全的库函数  458
13.2.5  同步标志和全局值  459
13.2.6  让数据结构成为线程安全的  465
13.3  最多一次和至少一次的执行  467
13.4  条件变量  471
13.4.1  条件变量的创建和销毁  473
13.4.2  等待并通知条件变量  475
13.5  信号处理和线程  478
13.5.1  将信号定向到一个特定的线程中  479
13.5.2  为线程屏蔽信号  480
13.5.3  信号处理的专用线程  480
13.6  读者和写者  484
13.7  strerror_r实现  489
13.8  死锁和其他讨厌的问题  491
13.9  练习：多个屏障  492
13.10  延伸阅读  492
第14章  临界区和信号量  493
14.1  临界区的处理  493
14.2  信号量  496
14.3  POSIX:SEM匿名信号量  499
14.4  POSIX:SEM信号量操作  501
14.5  POSIX:SEM命名信号量  508
14.5.1  创建并打开命名信号量  509
14.5.2  关闭信号量并删除其链接  512
14.6  练习：许可管理器  514
14.6.1  license对象  515
14.6.2  runsim主程序  515
14.6.3  对许可管理器的扩展  516
14.7  延伸阅读  516
第15章  POSIX IPC  517
15.1  POSIX:XSI进程间通信  517
15.1.1  标识并访问IPC对象  518
15.1.2  在shell中访问POSIX:XSI IPC资源  519
15.2  POSIX:XSI信号量集  520
15.2.1  信号量的创建  521
15.2.2  信号量的控制  523
15.2.3  POSIX信号量集操作  525
15.3  POSIX:XSI共享内存  532
15.3.1  访问共享内存段  532
15.3.2  共享内存段的连接和分离  533
15.3.3  控制共享内存  534
15.3.4  共享内存示例  535
15.4  POSIX:XSI消息队列  541
访问消息队列  542
15.5  练习：POSIX匿名信号量  549
15.6  练习：POSIX命名信号量  550
15.7  练习：用共享内存实现管道  551
15.8  练习：用消息队列实现管道  554
15.9  延伸阅读  554
第16章  项目：生产者-消费者同步  555
16.1  生产者-消费者问题  555
16.2  受互斥锁保护的有界缓冲区  557
16.3  使用信号量的缓冲区实现  560
16.4  一个简单的生产者-消费者问题简介  566
16.5  使用条件变量的有界缓冲区  570
16.6  带有完成条件的缓冲区  571
16.7  并行文件复制  580
16.7.1  并行文件复制的生产者  580
16.7.2  并行文件复制的消费者  581
16.7.3  并行文件复制的main程序  582
16.7.4  并行文件复制的增强  582
16.8  线程化打印服务器  583
16.8.1  请求缓冲区  584
16.8.2  生产者线程  585
16.8.3  消费者线程  586
16.8.4  打印服务器  586
16.8.5  其他增强功能  586
16.9  延伸阅读  587
第17章  项目：非完全并行虚拟机  588
17.1  PVM的历史、术语和结构  588
17.2  非完全并行虚拟机  591
17.3  NTPVM项目概述  593
17.3.1  NEWTASK分组  596
17.3.2  DATA分组  596
17.3.3  DONE分组  597
17.4  调度程序的I/O和测试  598
17.4.1  用多个窗口测试  604
17.4.2  用远程日志测试  605
17.5  没有输入的单任务  607
17.6  顺序任务  608
17.6.1  输入线程  609
17.6.2  输出线程  610
17.7  并发任务  611
17.8  分组通信、广播和屏障  611
17.9  终止和信号  612
17.10  有序的消息传递  613
17.11  延伸阅读  613
第四部分  通  信
第18章  面向连接的通信  617
18.1  客户机-服务器模型  617
18.2  通信信道  618
18.3  面向连接的服务器策略  622
18.4  通用因特网通信接口（UICI）  625
18.4.1  处理错误  627
18.4.2  读和写  627
18.5  不同服务器策略的UICI实现  628
18.6  UICI客户机  631
18.7  UICI的套接字实现  637
18.7.1  socket函数  638
18.7.2  bind函数  639
18.7.3  listen函数  641
18.7.4  u_open函数的实现  642
18.7.5  accept函数  643
18.7.6  u_accept函数的实现  645
18.7.7  connect函数  646
18.7.8  u_connect函数的实现  647
18.8  主机名和IP地址  649
18.9  线程安全的UICI  658
18.10  练习：ping服务器  661
18.11  练习：音频的传输  662
18.12  延伸阅读  664
第19章  项目：WWW重定向  665
19.1  万维网  665
19.2  统一资源定位符（URL）   666
19.3  HTTP入门  668
19.3.1  客户端请求  669
19.3.2  服务器响应  669
19.3.3  HTTP消息交换  670
19.4  Web通信模式  673
19.4.1  隧道  673
19.4.2  代理  674
19.4.3  高速缓存和透明性  676
19.4.4  网关  678
19.5  单连接的通过型监控  679
19.6  隧道服务器的实现  682
19.7  用于测试的服务器驱动程序  682
19.8  HTTP头解析  684
19.9  简单的代理服务器  686
19.10  代理监视器  688
19.11  代理高速缓存  691
19.12  门户网站的网关  692
19.13  用于负载平衡的网关  692
19.14  事后的调查分析  693
19.14.1  线程和计时错误  693
19.14.2  未捕获的错误和错误的退出  694
19.14.3  书写风格和表示  695
19.14.4  糟糕的测试和结果表示  696
19.14.5  编程错误和不好的风格  697
19.15  延伸阅读  698
第20章  无连接通信和多播  699
20.1  无连接通信简介  699
20.2  无连接通信的简化接口  701
20.2.1  主机名和u_buf_t结构  703
20.2.2  UICI UDP的返回错误  703
20.2.3  UDP缓冲区大小和UICI UDP  703
20.3  简单-请求协议  704
20.4  请求-应答协议  710
20.5  有超时和重试的请求-应答  716
20.6  请求-应答-确认协议  722
20.7  UICI UDP的实现  723
20.7.1  u_openudp函数的实现  723
20.7.2  sendto函数  725
20.7.3  u_sendto和 u_sendtohost函数的实现  726
20.7.4  recvfrom函数  727
20.7.5  u_recvfrom和u_recvfromtimed函数的实现  728
20.7.6  主机名和u_buf_t  730
20.8  UDP和TCP的比较  732
20.9  多播  733
20.9.1  多播寻址  733
20.9.2  u_join函数的实现  735
20.9.3  u_leave函数的实现  736
20.10  练习：UDP端口服务器  737
20.11  练习：无状态文件服务器  738
远程文件服务  739
20.12  延伸阅读  740
第21章  项目：互联网广播  741
21.1  项目概述  741
21.2  音频设备模拟  744
21.3  具有一个节目和一个接收者的UDP实现  744
21.3.1  简单实现  744
21.3.2  接收者的终止  747
21.3.3  接收者缓冲来处理网络延迟  748
21.3.4  接收者缓冲来处理乱序传递  751
21.4  具有多个节目和接收者的UDP实现  754
21.4.1  多个节目和单个接收者  754
21.4.2  多个节目和多个接收者  755
21.5  音频广播的UDP实现  756
21.6  无线电广播的多播实现  758
21.7  TCP实现的差异  758
21.7.1  单个节目和单个接收者的TCP实现  759
21.7.2  多个节目和单个接收者的TCP实现  760
21.7.3  无线电广播的TCP实现  761
21.8  通过浏览器接收流式音频  764
21.8.1  使用浏览器助手应用程序  764
21.8.2  在你的Web服务器中设置一种新的mime类型  765
21.8.3  设置你的浏览器来处理新的mime类型  766
21.8.4  创建Web页面  766
21.8.5  使用预定义的mime类型  767
21.9  延伸阅读  767
第22章  项目：服务器性能  769
22.1  服务器性能成本  769
22.2  服务器架构  770
22.3  项目概述  774
22.4  单客户端驱动程序  775
22.4.1  处理一个连接  775
22.4.2  对响应进行编程  776
22.4.3  收集统计信息  777
22.4.4  测试客户端  777
22.5  多客户端驱动程序  778
另一种多客户端设计  781
22.6  实现每个请求一个线程和每个请求一个进程  781
22.7  线程工作者池策略  782
22.8  使用有界缓冲区的多线程工作者池  782
22.9  进程工作者池  783
22.10  磁盘I/O的影响  783
22.11  性能研究  787
22.11.1  基线测量  787
22.11.2  波动性的根源  788
22.11.3  测量错误  789
22.11.4  同步  792
22.11.5  普通的错误  793
22.11.6  要测量什么  794
22.11.7  数据分析和表示  796
22.12  报告撰写  797
22.12.1  引言  797
22.12.2  设计、实现和测试  798
22.12.3  实验  798
22.12.4  结果和分析  799
22.12.5  结论  799
22.12.6  参考文献  799
22.13  延伸阅读  800
附录A  UNIX基础  801
附录B  重启库  819
附录C  UICI实现  829
附录D  日志函数  846
附录E  POSIX扩展  864
参考文献  867
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>UNIX系统编程: 通信、并发与线程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker高并发微服务架构设计实施
第一部分架 构 篇
1 微服务架构与 Spring Cloud  2
1.1 微服务概念的由来  2
1.2 微服务的定义  3
1.3 微服务架构与整体式架构的区别  5
1.4 微服务架构与SOA 的比较  8
1.5 为什么要使用微服务架构  9
1.6 为实施微服务架构做好准备  10
1.6.1 思想观念的转变  10
1.6.2 团队管理方式的改变  11
1.6.3 自动化基础设施的建设  11
1.7 为什么要使用Spring Cloud  12
1.8 Spring Cloud 组件介绍  13
1.9 Spring Cloud 的版本说明  15
1.10 小结  17
2 微服务架构最佳设计  18
2.1 合理划分微服务  19
2.2 微服务治理  19
2.3 Rest API 微服务设计  21
2.3.1 使用数据库集群  22
2.3.2 读写分离设计  22
2.3.3 使用缓存  22
2.3.4 保证Rest API 微服务的独立性  23
2.4 Web UI 微服务设计  23
2.4.1 使用FeignClient 实现负载均衡调用  23
2.4.2 使用Hystrix 实现容错设计  23
2.4.3 使用非阻塞的异步编程技术实现高并发调用  24
2.4.4 使用分布式文件系统  24
2.5 微服务之间调用规则设计  24
2.6 数据最终一致性设计  25
2.7 分布式集群架构设计  26
2.8 微服务运行环境安全设计  27
2.9 小结  27
3 电商平台微服务设计实例  29
3.1 电商平台总体设计  29
3.1.1 总体业务流程设计  29
3.1.2 总体业务功能设计  31
3.2 电商平台业务模型设计  32
3.2.1 移动商城业务模型  32
3.2.2 商家管理后台业务模型  33
3.2.3 平台管理后台业务模型  33
3.3 创建Rest API 微服务  34
3.4 创建Web UI 微服务  36
3.4.1 移动商城Web UI 微服务  36
3.4.2 商家管理后台的Web UI 微服务  37
3.4.3 平台管理后台Web UI 微服务  37
3.5 电商平台微服务体系结构  38
3.6 小结  39
第二部分 开 发 篇
4 开发工具选用及 Spring Boot 基础  41
4.1 开发工具选择  42
4.2 开发环境配置  42
4.3 创建Spring Boot 工程  43
4.4 使用JPA  47
4.4.1 数据源配置  48
4.4.2 JPA 配置  48
4.4.3 数据实体设计  49
4.4.4 存储库接口设计  49
4.4.5 单元测试  50
4.5 使用Thymeleaf  51
4.5.1 控制器设计  51
4.5.2 视图设计  52
4.6 运行与部署  52
4.7 小结  54
5 电商平台微服务工程设计  55
5.1 微服务工程结构  55
5.2 电商平台微服务工程组建  57
5.3 数据库选型  57
5.4 微服务工程创建步骤  58
5.5 项目基本配置  60
5.6 创建模块  64
5.7 小结  66
6 微服务治理基础服务开发  67
6.1 注册管理中心  68
6.1.1 创建注册管理中心  68
6.1.2 运行注册管理中心  70
6.1.3 微服务怎样使用注册管理中心  70
6.1.4 构建高可用的注册管理中心  72
6.2 配置管理中心  73
6.2.1 创建配置管理中心  73
6.2.2 微服务如何使用配置管理中心  76
6.2.3 在线更新配置信息  77
6.3 微服务监控中心  78
6.3.1 使用断路器仪表盘实现监控  79
6.3.2 聚合服务监控管理中心  81
6.4 服务跟踪分析中心  86
6.4.1 创建服务跟踪分析中心  86
6.4.2 在微服务中启用服务跟踪功能  90
6.5 日志分析平台  93
6.5.1 创建日志分析平台  93
6.5.2 使用日志分析平台  93
6.6 小结  94
7 Rest API 微服务开发  96
7.1 领域业务开发  96
7.1.1 使用Druid 数据源  98
7.1.2 JPA 及其配置  100
7.1.3 数据实体建模  101
7.1.4 查询对象设计  104
7.1.5 实体持久化设计  106
7.1.6 持久化测试  107
7.1.7 领域服务开发  109
7.1.8 领域服务的单元测试  111
7.1.9 使用Redis 实现缓存设计  112
7.2 Rest API 应用开发  117
7.2.1 Rest API 应用配置  117
7.2.2 启动程序设计  119
7.2.3 接口开发  119
7.3 使用消息处理事件  123
7.3.1 消息生产者设计  124
7.3.2 消息消费者设计  125
7.3.3 使用消息测试  128
7.4 小结  129
8 Web UI 微服务开发  131
8.1 高并发接口调用分层设计  131
8.2 通过FeignClient 调用Rest API  132
8.3 使用Hystrix 断路器  134
8.4 使用非阻塞异步编程方法  136
8.4.1 CompletableFuture 介绍  137
8.4.2 性能比较测试  140
8.5 Web 应用开发  145
8.5.1 项目引用配置  145
8.5.2 应用程序配置  146
8.5.3 业务功能开发  148
8.6 开发环境的热部署设置  154
8.7 使用分布式文件系统  157
8.7.1 分布式文件系统客户端开发  157
8.7.2 商品图片上传设计  159
8.7.3 富文本编辑器上传文件设计  160
8.7.4 建立本地文件信息库  163
8.8 小结  166
9 电商平台移动商城开发  167
9.1 移动商城首页设计  168
9.2 使用负载均衡的导航设计  174
9.3 按分类查询设计  176
9.4 商品详情页设计  179
9.5 购买下单实现  181
9.6 用户登录与账户切换设计  184
9.6.1 用户登录设计  184
9.6.2 切换账号设计  186
9.7 订单查询设计  188
9.8 集成测试  191
9.9 小结  192
10 商家管理后台与 SSO 设计  193
10.1 商家权限管理体系设计及开发  194
10.1.1 商家权限体系建模  195
10.1.2 商家权限体系的持久化设计  199
10.1.3 商家权限体系的领域服务开发  201
10.2 商家管理微服务开发  204
10.2.1 商家领域服务层单元测试  204
10.2.2 商家服务的接口开发  208
10.3 SSO 设计  213
10.3.1 SSO 基本配置  213
10.3.2 在SSO 中使用商家的权限体系  214
10.3.3 用户登录设计  216
10.3.4 有关验证码的说明  218
10.3.5 SSO 的主页设计  220
10.3.6 OAuth2 服务端设计  222
10.4 SSO 客户端设计  224
10.4.1 客户端的项目管理配置  224
10.4.2 客户端的安全管理配置  225
10.4.3 权限验证实现原理  226
10.4.4 如何在应用中接入SSO  228
10.4.5 有关跨站请求伪造防御的相关设置  230
10.4.6 根据用户权限自动分配菜单  230
10.5 小结  232
11 平台管理后台开发  233
11.1 平台管理后台领域设计  233
11.1.1 领域实体建模  233
11.1.2 实体的行为设计  236
11.1.3 领域服务开发  236
11.1.4 领域服务单元测试  239
11.2 平台管理后台访问控制设计  240
11.2.1 使用平台管理的用户体系  240
11.2.2 权限管理设计  242
11.3 商家的注册设计  245
11.4 商家菜单体系管理开发  248
11.4.1 分类菜单管理开发  248
11.4.2 模块菜单管理开发  249
11.4.3 访问资源管理开发  252
11.5 商家角色管理开发  255
11.6 小结  257
第三部分运 维 篇
12 服务器架构设计与 Docker 使用  259
12.1 服务器组建  259
12.2 安全的服务器架构设计  260
12.2.1 防火墙安装及配置  260
12.2.2 建立安全的局域网环境  264
12.3 服务器资源分配  266
12.4 CentOS 安装  269
12.4.1 IP 地址设置  270
12.4.2 安全设置  270
12.4.3 语言配置  270
12.4.4 时间同步配置  271
12.5 Docker 和docker-compose 安装  271
12.5.1 Docker 安装及使用  272
12.5.2 docker-compose 安装及使用  275
12.6 使用Docker 搭建微服务治理环境  279
12.6.1 服务器1 的部署配置  279
12.6.2 服务器2 的部署配置  281
12.7 使用Docker 部署日志分析平台  283
12.8 使用Docker 部署微服务应用  286
12.9 小结  286
13 数据库集群设计与高可用读写分离实施  288
13.1 MySQL 安装  289
13.2 主从同步设置  291
13.3 主主同步设置  294
13.4 数据库代理中间件选择  296
13.5 使用OneProxy 实现读写分离设计  297
13.5.1 OneProxy 安装  297
13.5.2 高可用读写分离配置  298
13.6 OneProxy 分库分区设计  302
13.6.1 按范围分库分表  303
13.6.2 按值分库分表  303
13.6.3 按哈希算法分库分表  304
13.7 双机热备设计  306
13.8 小结  307
14 分布式文件系统等基础设施安装与配置  308
14.1 高可用的分布式文件系统构建  308
14.1.1 FastDFS 安装  310
14.1.2 跟踪服务器配置  310
14.1.3 存储节点配置  311
14.1.4 上传文件测试  312
14.1.5 Nginx 安装及负载均衡配置  313
14.1.6 开机启动设置  317
14.2 GitLab 安装  322
14.3 Redis 安装  324
14.4 RabbitMQ 安装  326
14.5 小结  327
15 使用自动化构建工具 Jenkins 实现CI/CD  328
15.1 持续交付工作流程  330
15.2 Jenkins 安装  331
15.3 Jenkins 基本配置  333
15.4 Jenkins 自动部署实例  335
15.4.1 创建任务  336
15.4.2 任务配置  337
15.4.3 执行任务  340
15.5 小结  343
后记  345
参考文献  346
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker高并发微服务架构设计实施
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Java并发编程（第2版）
第1章　第一步：并发设计原理　　1
1.1　基本的并发概念　　1
1.1.1　并发与并行　　1
1.1.2　同步　　2
1.1.3　不可变对象　　2
1.1.4　原子操作和原子变量　　3
1.1.5　共享内存与消息传递　　3
1.2　并发应用程序中可能出现的问题　　3
1.2.1　数据竞争　　3
1.2.2　死锁　　4
1.2.3　活锁　　4
1.2.4　资源不足　　4
1.2.5　优先权反转　　5
1.3　设计并发算法的方法论　　5
1.3.1　起点：算法的一个串行版本　　5
1.3.2　第1步：分析　　5
1.3.3　第2步：设计　　5
1.3.4　第3步：实现　　6
1.3.5　第4步：测试　　6
1.3.6　第5步：调整　　6
1.3.7　结论　　7
1.4　Java 并发API　　8
1.4.1　基本并发类　　8
1.4.2　同步机制　　8
1.4.3　执行器　　9
1.4.4　Fork/Join 框架　　9
1.4.5　并行流　　9
1.4.6　并发数据结构　　9
1.5　并发设计模式　　10
1.5.1　信号模式　　10
1.5.2　会合模式　　11
1.5.3　互斥模式　　11
1.5.4　多元复用模式　　12
1.5.5　栅栏模式　　12
1.5.6　双重检查锁定模式　　12
1.5.7　读?写锁模式　　13
1.5.8　线程池模式　　14
1.5.9　线程局部存储模式　　14
1.6　设计并发算法的提示和技巧　　14
1.6.1　正确识别独立任务　　14
1.6.2　在尽可能高的层面上实施并发处理　　15
1.6.3　考虑伸缩性　　15
1.6.4　使用线程安全API　　15
1.6.5　绝不要假定执行顺序　　16
1.6.6　在静态和共享场合尽可能使用局部线程变量　　16
1.6.7　寻找更易于并行处理的算法版本　　17
1.6.8　尽可能使用不可变对象　　17
1.6.9　通过对锁排序来避免死锁　　17
1.6.10 使用原子变量代替同步　　18
1.6.11 占有锁的时间尽可能短　　19
1.6.12 谨慎使用延迟初始化　　19
1.6.13 避免在临界段中使用阻塞操作　　19
1.7　小结　　20
第2章　使用基本元素：Thread 和Runnable　　21
2.1　Java 中的线程　　21
2.1.1　Java 中的线程：特征和状态　　22
2.1.2　Thread 类和Runnable 接口　　23
2.2　第一个例子：矩阵乘法　　24
2.2.1　公共类　　24
2.2.2　串行版本　　25
2.2.3　并行版本　　25
2.3　第二个例子：文件搜索　　32
2.3.1　公共类　　32
2.3.2　串行版本　　32
2.3.3　并发版本　　33
2.3.4　对比解决方案　　37
2.4　小结　　38
第3章　管理大量线程：执行器　　39
3.1　执行器简介　　39
3.1.1　执行器的基本特征　　39
3.1.2　执行器框架的基本组件　　40
3.2　第一个例子：k-最近邻算法　　40
3.2.1　k-最近邻算法：串行版本　　41
3.2.2　k-最近邻算法：细粒度并发版本　　42
3.2.3　k-最近邻算法：粗粒度并发版本　　45
3.2.4　对比解决方案　　46
3.3　第二个例子：客户端/服务器环境下的并发处理　　48
3.3.1　客户端/服务器：串行版　　48
3.3.2　客户端/服务器：并行版本　　51
3.3.3　额外的并发服务器组件　　54
3.3.4　对比两种解决方案　　59
3.3.5　其他重要方法　　61
3.4　小结　　62
第4章　充分利用执行器　　63
4.1　执行器的高级特性　　63
4.1.1　任务的撤销　　63
4.1.2　任务执行调度　　64
4.1.3　重载执行器方法　　64
4.1.4　更改一些初始化参数　　64
4.2　第一个例子：高级服务器应用程序　　65
4.2.1　ServerExecutor 类　　65
4.2.2　命令类　　70
4.2.3　服务器部件　　72
4.2.4　客户端部件　　78
4.3　第二个例子：执行周期性任务　　79
4.3.1　公共部件　　79
4.3.2　基础阅读器　　81
4.3.3　高级阅读器　　84
4.4　有关执行器的其他信息　　87
4.5　小结　　87
第5章　从任务获取数据：Callable接口与Future 接口　　88
5.1　Callable 接口和Future 接口简介　　88
5.1.1　Callable 接口　　88
5.1.2　Future 接口　　89
5.2　第一个例子：单词最佳匹配算法　　89
5.2.1　公共类　　90
5.2.2　最佳匹配算法：串行版本　　91
5.2.3　最佳匹配算法：第一个并发版本　　92
5.2.4　最佳匹配算法：第二个并发版本　　95
5.2.5　单词存在算法：串行版本　　96
5.2.6　单词存在算法：并行版本　　98
5.2.7　对比解决方案　　100
5.3　第二个例子：为文档集创建倒排索引　　102
5.3.1　公共类　　103
5.3.2　串行版本　　104
5.3.3　第一个并发版本：每个文档一个任务　　105
5.3.4　第二个并发版本：每个任务多个文档　　109
5.3.5　对比解决方案　　112
5.3.6　其他相关方法　　113
5.4　小结　　113
第6章　运行分为多阶段的任务：Phaser 类　　115
6.1　Phaser 类简介　　115
6.1.1　参与者的注册与注销　　116
6.1.2　同步阶段变更　　116
6.1.3　其他功能　　116
6.2　第一个例子：关键字抽取算法　　117
6.2.1　公共类　　118
6.2.2　串行版本　　121
6.2.3　并发版本　　123
6.2.4　对比两种解决方案　　128
6.3　第二个例子：遗传算法　　129
6.3.1　公共类　　130
6.3.2　串行版本　　132
6.3.3　并发版本　　134
6.3.4　对比两种解决方案　　139
6.4　小结　　141
第7章　优化分治解决方案： Fork/Join 框架　　142
7.1　Fork/Join 框架简介　　142
7.1.1　Fork/Join 框架的基本特征　　143
7.1.2　Fork/Join 框架的局限性　　143
7.1.3　Fork/Join 框架的组件　　144
7.2　第一个例子：k-means 聚类算法　　144
7.2.1　公共类　　145
7.2.2　串行版本　　149
7.2.3　并发版本　　151
7.2.4　对比解决方案　　155
7.3　第二个例子：数据筛选算法　　157
7.3.1　公共特性　　157
7.3.2　串行版　　157
7.3.3　并发版本　　159
7.3.4　对比两个版本　　165
7.4　第三个例子：归并排序算法　　166
7.4.1　共享类　　166
7.4.2　串行版本　　167
7.4.3　并发版本　　169
7.4.4　对比两个版本　　172
7.5　Fork/Join 框架的其他方法　　172
7.6　小结　　173
第8章　使用并行流处理大规模数据集：MapReduce 模型　　174
8.1　流的简介　　174
8.1.1　流的基本特征　　174
8.1.2　流的组成部分　　175
8.1.3　MapReduce 与MapCollect　　177
8.2　第一个例子：数值综合分析应用程序　　178
8.2.1　并发版本　　178
8.2.2　串行版本　　185
8.2.3　对比两个版本　　186
8.3　第二个例子：信息检索工具　　186
8.3.1　约简操作简介　　187
8.3.2　第一种方式：全文档查询　　188
8.3.3　第二种方式：约简的文档查询　　191
8.3.4　第三种方式：生成一个含有结果的HTML 文件　　191
8.3.5　第四种方式：预先载入倒排索引　　194
8.3.6　第五种方式：使用我们的执行器　　195
8.3.7　从倒排索引获取数据：ConcurrentData 类　　196
8.3.8　获取文件中的单词数　　196
8.3.9　获取文件的平均tfxidf 值　　196
8.3.10 获取索引中的最大tfxidf值和最小tfxidf 值　　197
8.3.11 ConcurrentMain 类　　198
8.3.12 串行版　　199
8.3.13 对比两种解决方案　　199
8.4　小结　　202
第9章　使用并行流处理大规模数据集：MapCollect 模型　　203
9.1　使用流收集数据　　203
9.2　第一个例子：无索引条件下的数据搜索　　205
9.2.1　基本类　　205
9.2.2　第一种方式：基本搜索　　207
9.2.3　第二种方式：高级搜索　　209
9.2.4　本例的串行实现　　211
9.2.5　对比实现方案　　211
9.3　第二个例子：推荐系统　　212
9.3.1　公共类　　212
9.3.2　推荐系统：主类　　213
9.3.3　ConcurrentLoaderAccumulator 类　　215
9.3.4　串行版　　216
9.3.5　对比两个版本　　216
9.4　第三个例子：社交网络中的共同联系人　　217
9.4.1　基本类　　218
9.4.2　并发版本　　219
9.4.3　串行版本　　223
9.4.4　对比两个版本　　223
9.5　小结　　224
第10章　异步流处理：反应流　　225
10.1　Java 反应流简介　　225
10.1.1　Flow.Publisher 接口　　226
10.1.2　Flow.Subscriber 接口　　226
10.1.3　Flow.Subscription 接口　　226
10.1.4　SubmissionPublisher 类　　226
10.2　第一个例子：面向事件通知的集中式系统　　 227
10.2.1　Event 类　　227
10.2.2　Producer 类　　 227
10.2.3　Consumer 类　　 228
10.2.4　Main 类　　230
10.3　第二个例子：新闻系统　　231
10.3.1　News 类　　232
10.3.2　发布者相关的类　　232
10.3.3　Consumer 类　　 235
10.3.4　Main 类　　236
10.4　小结　　238
第11章　探究并发数据结构和同步工具　　240
11.1　并发数据结构　　240
11.1.1　阻塞型数据结构和非阻塞型数据结构　　241
11.1.2　并发数据结构　　241
11.1.3　使用新特性　　244
11.1.4　原子变量　　251
11.1.5　变量句柄　　252
11.2　同步机制　　254
11.2.1　CommonTask 类　　255
11.2.2　Lock 接口　　255
11.2.3　Semaphore 类　　256
11.2.4　CountDownLatch 类　　258
11.2.5　CyclicBarrier 类　　259
11.2.6　CompletableFuture 类　　261
11.3　小结　　268
第12章　测试与监视并发应用程序　　269
12.1　监视并发对象　　269
12.1.1　监视线程　　269
12.1.2　监视锁　　270
12.1.3　监视执行器　　272
12.1.4　监视Fork/Join 框架　　273
12.1.5　监视Phaser　　274
12.1.6　监视流API　　275
12.2　监视并发应用程序　　276
12.2.1　Overview 选项卡　　278
12.2.2　Memory 选项卡　　279
12.2.3　Threads 选项卡　　280
12.2.4　Classes 选项卡　　280
12.2.5　VM Summary 选项卡　　281
12.2.6　MBeans 选项卡　　283
12.2.7　About 选项卡　　284
12.3　测试并发应用程序　　284
12.3.1　使用MultithreadedTC 测试并发应用程序　　285
12.3.2　使用Java Pathfinder 测试并发应用程序　　288
12.4　小结　　293
第13章　JVM 中的并发处理：Clojure、带有GPars 库的Groovy 以及Scala　　294
13.1　Clojure 的并发处理　　294
13.1.1　使用Java 元素　　295
13.1.2　引用类型　　295
13.1.3　Ref 对象　　298
13.1.4　Delay　　299
13.1.5　Future　　300
13.1.6　Promise　　301
13.2　Groovy 及其GPars 库的并发处理　　302
13.3　软件事务性内存　　302
13.3.1　使用Java 元素　　302
13.3.2　数据并行处理　　303
13.3.3　Fork/Join 处理　　307
13.3.4　Actor　　308
13.3.5　Agent　　315
13.3.6　Dataf low　　316
13.4　Scala 的并发处理　　322
13.4.1　Scala 中的Future 对象　　322
13.4.2　Promise　　328
13.5　小结　　329
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Java并发编程（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Android并发开发
版权
版权声明
内容提要
前言
资源与支持
致谢
第1章　了解并发
第2章　Java并发
第3章　Android应用程序模型
第4章　AsyncTask和Loader
第5章　Looper/Handler
第6章　Service、进程和Binder IPC
第7章　定时任务
第8章　并发工具
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Android并发开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 9 并发编程实战
第 1章 线程管理 1
1.1 简介 1
1.2 线程的创建、运行和设置 2
1.3 线程中断 8
1.4 控制线程中断 11
1.5 线程的休眠和唤醒 14
1.6 等待线程执行结束 16
1.7 守护线程的创建与运行 19
1.8 处理线程中的不可控异常 23
1.9 使用线程本地变量 26
1.10 线程分组及线程组中不可控异常的处理 29
1.11 使用工厂创建线程 33
第 2章 线程同步基础 37
2.1 简介 37
2.2 方法同步 38
2.3 在同步代码块中使用条件 46
2.4　在同步代码块中使用锁机制 51
2.5 用读/写锁保护同步代码块 57
2.6 在一个锁中使用多个条件 62
2.7 高阶知识：StampedLock的使用 70
第3章 线程同步工具 78
3.1 简介 78
3.2 控制对资源的一个或多个副本的并发访问 79
3.3 等待多个并发事件 85
3.4 在指定状态点同步任务 90
3.5 运行阶段性并发任务 98
3.6 阶段性并发任务中阶段转变的控制 108
3.7 两个并发任务间的数据交换 114
3.8 异步地完成和关联任务 118
第4章 线程执行器 128
4.1 简介 128
4.2 创建一个线程执行器并实现其拒绝策略 129
4.3 在一个执行器里执行任务并返回结果 136
4.4 运行多个任务并处理第 一个返回结果 140
4.5 运行多个任务并处理全部返回结果 146
4.6 在执行器内延迟运行任务 150
4.7 在执行器内周期性地运行任务 154
4.8 在执行器内取消任务 157
4.9 在执行器内控制任务的完成 160
4.10 在执行器内分离任务的启动并处理返回结果 164
第5章 fork/join框架 171
5.1 简介 171
5.2 创建一个fork/join池 173
5.3 合并任务的执行结果 180
5.4 异步地运行任务 189
5.5 在任务中抛出异常 196
5.6 取消一个任务 200
第6章 并行反应式流 208
6.1 简介 208
6.2 使用不同的源创建流 210
6.3 归约一个流的元素 217
6.4 收集流中的元素 224
6.5 把一个动作应用到流的每个元素上 231
6.6 过滤流中的元素 234
6.7 转换流中的元素 237
6.8 排序流中的元素 241
6.9 在流中的元素上验证条件 244
6.10 在反应式流上反应式编程 248
第7章 并发集合 256
7.1 简介 256
7.2 运用非阻塞线程安全的双端队列 257
7.3 运用阻塞线程安全的双端队列 262
7.4 运用按优先级排序的阻塞线程安全队列 265
7.5 运用带延迟元素的线程安全列表 271
7.6 运用线程安全的跳表 276
7.7 运用线程安全的HashMap 281
7.8 运用原子性变量 287
7.9 运用原子性数组 294
7.10 运用volatile关键字 298
7.11 运用变量句柄 302
第8章 自定义并发类 307
8.1 简介 307
8.2 自定义ThreadPoolExecutor类 308
8.3 实现一个基于优先级的Executor类 313
8.4 实现ThreadFactory接口来生成自定义线程 317
8.5 在一个Executor对象中使用ThreadFactory 322
8.6 自定义在一个周期调度性线程池中运行的任务 324
8.7 实现一个ThreadFactory以生成fork/join框架的自定义线程 331
8.8 自定义运行于fork/join框架中的任务 338
8.9 实现一个自定义Lock类 342
8.10 实现一个基于优先级的传递队列 348
8.11 实现自己的原子性对象 359
8.12 实现自己的流生成器 363
8.13 实现自己的异步流 369
第9章 并发程序的测试 378
9.1 简介 378
9.2 监测Lock接口 379
9.3　监测Phaser类 383
9.4　监测Executor框架 387
9.5 监测fork/join任务池 390
9.6 监测流 395
9.7　输出有效日志信息 397
9.8　利用FindBugs分析并发程序代码 402
9.9　使用Eclipse调试并发程序代码 406
9.10　使用NetBeans调试并发程序代码 408
9.11 使用MultithreadedTC调试并发程序代码 413
9.12 使用JConsole监测 416
第 10章 附加信息 421
10.1 简介 421
10.2 在Executor框架中处理Runnable对象的结果 421
10.3 在ForkJoinPool类中处理未控制的异常 427
10.4 使用线程安全的阻塞队列在生产者和消费者之间进行交互 431
10.5 监测Thread类 436
10.6 监测Semaphore类 440
10.7 生成并发随机数 443
第 11章 并发编程设计 445
11.1 简介 445
11.2 尽可能使用不可变对象 446
11.3 对锁排序以避免死锁 449
11.4 使用原子变量替代同步 451
11.5 尽可能短地持有锁 455
11.6 委托执行器管理线程 459
11.7 使用并发数据结构替代手动编程 462
11.8 使用延迟初始化预防问题 464
11.9 使用fork/join框架替代执行器 466
11.10 避免在锁中使用阻塞操作 470
11.11 避免使用已弃用的方法 472
11.12 使用执行器替代线程组 473
11.13 使用流处理大数据集 474
11.14 其他提示和技巧 479
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 9 并发编程实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>并发模式与应用实践
译者序
前言
作者/评阅者简介
第1章　并发简介1
1.1　并发轻而易举2
1.1.1　推动并发3
1.1.2　分时6
1.1.3　两种并发编程模型7
1.2　消息传递模型8
1.2.1　协调和通信10
1.2.2　流控制12
1.2.3　分治策略14
1.2.4　进程状态的概念15
1.3　共享内存和共享状态模型16
1.3.1　线程交错—同步的需要18
1.3.2　竞争条件和海森堡bug20
1.3.3　正确的内存可见性和happens-before原则21
1.3.4　共享、阻塞和公平22
1.3.5　异步与同步执行24
1.3.6　Java的非阻塞I/O25
1.4　模式和范式26
1.4.1　事件驱动的架构28
1.4.2　响应式编程29
1.4.3　actor范式31
1.4.4　消息代理32
1.4.5　软件事务性内存33
1.4.6　并行集合34
1.5　本章小结35
第2章　并发模式初探37
2.1　线程及其上下文38
2.2　竞争条件40
2.2.1　监视器模式44
2.2.2　线程安全性、正确性和不变性45
2.2.3　双重检查锁定48
2.2.4　显式锁定52
2.2.5　生产者/消费者模式60
2.2.6　比较和交换66
2.3　本章小结68
第3章　更多的线程模式70
3.1　有界缓冲区72
3.1.1　策略模式—客户端轮询74
3.1.2　接管轮询和睡眠的策略75
3.1.3　使用条件变量的策略77
3.2　读写锁78
3.2.1　易读的RW锁80
3.2.2　公平锁84
3.3　计数信号量86
3.4　我们自己的重入锁89
3.5　倒计时锁存器91
3.6　循环屏障95
3.7　future任务97
3.8　本章小结100
第4章　线程池101
4.1　线程池102
4.1.1　命令设计模式104
4.1.2　单词统计105
4.1.3　单词统计的另一个版本107
4.1.4　阻塞队列107
4.1.5　线程中断语义111
4.2　fork-join池111
4.2.1　Egrep—简易版112
4.2.2　为什么要使用递归任务113
4.2.3　任务并行性116
4.2.4　使用fork-join API实现快速排序117
4.2.5　map-reduce技术124
4.3　线程的工作窃取算法125
4.4　主动对象128
4.4.1　隐藏和适应129
4.4.2　使用代理129
4.5　本章小结132
第5章　提升并发性133
5.1　无锁堆栈134
5.1.1　原子引用134
5.1.2　堆栈的实现135
5.2　无锁的FIFO队列137
5.2.1　流程如何运作140
5.2.2　无锁队列141
5.2.3　ABA问题147
5.3　并发的哈希算法152
5.3.1　add(v)方法153
5.3.2　contains(v)方法156
5.4　大锁的方法157
5.5　锁条纹设计模式159
5.6　本章小结162
第6章　函数式并发模式163
6.1　不变性164
6.1.1　不可修改的包装器165
6.1.2　持久数据结构167
6.1.3　递归和不变性169
6.2　future模式170
6.2.1　apply方法171
6.2.2　future—线程映射173
6.2.3　future模式是异步的174
6.2.4　糟糕的阻塞177
6.2.5　函数组合179
6.3　本章小结182
第7章　actor模式183
7.1　消息驱动的并发183
7.1.1　什么是actor185
7.1.2　状态封装189
7.1.3　并行性在哪里190
7.1.4　未处理的消息192
7.1.5　become模式193
7.1.6　让它崩溃并恢复197
7.1.7　actor通信—ask模式199
7.1.8　actor通信—tell模式204
7.1.9　pipeTo模式205
7.2　本章小结207
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>并发模式与应用实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go语言高并发与微服务实战
第一篇 云原生与微服务
云原生与微服务分别是什么，它们之间有什么关系呢？本部分围绕云原生与微服务的概 念展开介绍，我们透过云计算的历史和系统架构的演进，具体了解这两个概念的意义及其背 后的技术发展。
第 1 章 云原生架构
1.1 云计算的历史 1
1.1.1 云计算的基础：虚拟化技术 1
1.1.2 基于虚拟机的云计算 3
1.1.3 容器的横空出世和容器编排大战 5
1.1.4 云计算演进总结 6
1.2 云原生是什么 7
1.2.1 云原生出现的背景 7
1.2.2 云原生的定义 8
1.2.3 云原生与 12 因素 9
1.3 云原生的基础架构 11
1.3.1 微服务 11
1.3.2 容器 12
1.3.3 服务网格 13
1.3.4 DevOps 14
1.4 小结 15
第 2 章 微服务概述
2.1 系统架构的演进 16
2.1.1 单体架构 16
2.1.2 垂直分层架构 17
2.1.3 SOA 面向服务架构 17
2.1.4 微服务架构 19
2.1.5 云原生架构 21
2.2 常见的微服务框架 22
2.2.1 Java 中的 Spring Cloud 与 Dubbo 框架 22

2.2.2 Go 语言中的 Go Kit 与 Go Micro 框架 24
2.3 微服务设计的六大原则 27
1．高内聚，低耦合 27
2．高度自治 27
3．以业务为中心 28
4．弹性设计 28
5．日志与监控 28
6．自动化 28
2.4 领域驱动设计 28
2.4.1 设计微服务的困境 28
2.4.2 解困之法：领域驱动设计（DDD） 29
2.4.3 DDD 的应用领域 30
2.4.4 DDD 领域划分 31
2.4.5 微服务架构中的团队组织和管理 33
2.5 小结 34
第二篇 Go 语法基础与特性功能
在正式进入微服务组件的学习之前，我们要巩固一下 Go 语言的基础，包括容器、原生 数据类型、函数与接口、结构体和方法等常用的语法基础；其次是 Go 语言的特性功能：反 射与并发模型，介绍 Go 语言协程、通道、多路复用和同步的具体实践；最后是 Golang Web 的相关介绍，一起构建一个完整的 Go Web 服务器。
第 3 章 Go 语言基础
3.1 Go 语言介绍 35
3.2 环境安装 36
3.2.1 Go 开发包安装 36
3.2.2 第一个 Go 语言程序 38
3.2.3 编译工具 40
3.3 基本语法 41
3.3.1 变量的声明与初始化 41
3.3.2 原生数据类型 43
【实例 3-1】分别以 byte 和 rune 的方式遍历字符串 44
3.3.3 指针 45
【实例 3-2】使用 flag 从命令行中读取参数 47
3.3.4 常量与类型别名 48
3.3.5 分支与循环控制 49
3.4 Go 中常用的容器 50

3.4.1 数组 50
3.4.2 切片 51
【实例 3-3】切片的动态扩容 53
3.4.3 列表与字典 54
3.4.4 容器遍历 57
【实例 3-4】对给出的数组 nums、切片 slis 和字典 tmpMap 分别进行遍历 57
3.5 函数与接口 58
3.5.1 函数声明和参数传递 58
3.5.2 匿名函数和闭包 59
【实例 3-5】使用回调函数处理字符串 59
【实例 3-6】用闭包的特性实现一个简单的计数器 60
3.5.3 接口声明和嵌套 61
3.5.4 函数体实现接口 62
3.6 结构体和方法 62
3.6.1 结构体的定义 63
3.6.2 结构体的实例化和初始化 63
3.6.3 方法与接收器 64
【实例 3-7】为 Person 结构体添加修改姓名和输出个人信息两个方法 65
3.6.4 结构体实现接口 66
【实例 3-8】使用一个结构体同时实现 Cat 和 Dog 接口 66
3.6.5 内嵌和组合 67
【实例 3-9】内嵌不同结构体表现不同行为 68
3.7 小结 69
第 4 章 进阶——Go 语言高级特性
4.1 依赖管理 70
4.1.1 包管理 70
4.1.2 GOPATH 72
4.1.3 Go Modules 73
4.2 反射基础 73
4.2.1 reflect.Type 类型对象 74
4.2.2 类型对象 reflect.StructField 和 reflect.Method 76
4.2.3 reflect.Value 反射值对象 78
【实例 4-1】使用反射调用接口方法 80
4.3 并发模型 82
4.3.1 并发与并行 82
4.3.2 CSP 并发模型 82
4.3.3 常见的线程模型 83
4.3.4 MPG 线程模型概述 85

4.4 并发实践 87
4.4.1 协程 goroutine 87
4.4.2 通道 channel 89
【实例 4-2】协程使用 channel 发送和接收数据 90
【实例 4-3】使用带缓冲区的 channel 91
【实例 4-4】使用 switch 从多个 channel 中读取数据 92
4.4.3 sync 同步包 94
【实例 4-5】使用 sync.Mutex 控制多 goroutine 串行执行 94
【实例 4-6】sync.RWMutex 允许多读和单写 95
【实例 4-7】sync.WaitGroup 阻塞主 goroutine 直到其他 goroutine 执行结束 97
【实例 4-8】使用 sync.Map 并发添加数据 98
4.5 小结 99
第 5 章 构建 Go Web 服务器
5.1 Web 的工作原理 100
5.1.1 HTTP 协议详解 100
5.1.2 访问 Web 站点的过程 103
5.2 使用 Go 语言构建服务器 104
【实例 5-1】快速搭建一个 Go Web 服务器 104
5.3 接收和处理请求 105
5.3.1 Web 工作的几个概念 106
5.3.2 处理器处理请求 107
5.3.3 解析请求体 109
【实例 5-2】Go Web 请求体解析 109
5.3.4 返回响应体 111
【实例 5-3】返回响应体实践 112
5.4 实践案例：Golang Web 框架 Gin 实践 113
5.5 服务端数据存储 116
5.5.1 内存存储 116
【实例 5-4】服务端基于内存的存储方式实践 116
5.5.2 database/sql 接口 118
5.5.3 关系数据库存储（MySQL） 118
【实例 5-5】服务端基于 MySQL 的存储方式实践 119
5.5.4 Nosql 数据库存储（MongoDB） 120
【实例 5-6】服务端基于 MongoDB 的存储方式实践 121
5.6 Golang ORM 框架 beego 实践 122
5.7 小结 125

第三篇 微服务核心组件
本部分是全书的核心，介绍微服务中各个核心组件的原理和实践应用，包括分布式配置 中心、服务注册与发现、微服务网关、微服务的容错、微服务中的通信与负载均衡、统一认 证与授权、微服务中的链路追踪。通过组件原理的介绍、组件的选型对比以及组件的实践应 用，吃透每一个微服务组件。
第 6 章 服务注册与发现
6.1 服务注册与发现的基本原理 126
6.1.1 服务注册与发现中心的职责 126
6.1.2 服务实例注册服务信息 127
6.1.3 CAP 原理 127
6.2 常用的服务注册与发现框架 128
6.2.1 基于 Raft 算法的开箱即用服务发现组件 Consul 128
6.2.2 基于 HTTP 协议的分布式 key/Value 存储组件 Etcd 130
6.2.3 重量级一致性服务组件 Zookeeper 131
6.2.4 服务注册与发现组件的对比与选型 132
6.3 Consul 安装和接口定义 133
6.3.1 Consul 的安装与启动 133
6.3.2 Go-kit 项目结构 134
6.3.3 服务注册与发现接口 135
6.3.4 项目的总体结构 135
6.4 实践案例：直接使用 HTTP 的方式和 Consul 交互 140
6.4.1 服务注册与健康检查 142
6.4.2 服务注销 144
6.4.3 服务发现 146
6.5 实践案例：借助 Go-kit 服务注册与发现包和 Consul 交互 147
6.5.1 服务注册与健康检查 148
6.5.2 服务注销 149
6.5.3 服务发现 150
6.5.4 服务实例信息缓存 150
6.5.5 MyDiscoverClient 和 KitDiscoverClient 的比较 153
6.6 实践案例：基于服务注册与发现的 string-service 153
6.6.1 项目结构 153
6.6.2 各层构建 154
6.7 小结 162

第 7 章 远程过程调用 RPC
7.1 RPC 机制和实现过程 164
7.1.1 RPC 机制 164
7.1.2 传递参数 167
7.1.3 通信协议制定 168
7.1.4 出错和超时处理 170
7.1.5 通用 RPC 接口 171
7.2 简易的 Go 语言原生 RPC 172
7.2.1 实践案例：Go 语言 RPC 过程调用实践 172
7.2.2 服务端注册实现原理分析 175
7.2.3 服务端处理 RPC 请求原理分析 178
7.2.4 客户端发送 RPC 请求原理分析 182
7.2.5 资源重用 187
7.3 高性能的 gRPC 188
7.3.1 gRPC 的安装 189
7.3.2 实践案例：gRPC 过程调用实践 190
7.3.3 流式编程 193
【实例 7-1】gRPC 流式请求 193
7.4 便捷的 Go-kit RPC 196
7.4.1 Go-kit 简介 196
7.4.2 实践案例：Go-kit 过程调用实践 197
7.5 小结 202
第 8 章 分布式配置中心
8.1 如何管理分布式应用的配置 203
8.2 常见分布式配置中心开源组件 204
8.2.1 Spring Cloud Config. 204
8.2.2 Apollo 205
8.2.3 Disconf 208
8.2.4 分布式配置中心的对比 210
8.3 应用 Spring Cloud Config 统一管理配置 210
8.3.1 搭建 Spring Cloud Config Server 210
8.3.2 Viper 介绍 213
【实例 8-1】Viper 实现读取本地配置信息 214
8.3.3 实战案例：动手实现 Spring Cloud Config 的 Go 语言客户端 216
8.4 实践案例：实现配置的热更新 219
8.4.1 如何实现热更新 219
8.4.2 Go 语言客户端改进 220

8.4.3 结果验证 223
8.5 配置信息的加密解密 224
8.5.1 JCE 环境安装 225
8.5.2 对称加密与解密 225
8.5.3 非对称加密与解密 226
8.6 小结 227
第 9 章 微服务网关
9.1 微服务网关介绍与功能特性 228
9.2 实践案例：自己动手实现一个网关 231
9.2.1 实现思路 231
9.2.2 编写反向代理方法 232
9.2.3 编写入口方法 233
9.2.4 运行 235
9.2.5 测试 235
9.3 API 网关选型 235
9.3.1 标配组件：Nginx 网关 236
9.3.2 Java 前置网关服务最佳选型：Netflix Zuul 237
9.3.3 高可用服务网关：Mashape Kong 239
9.3.4 三种常用 API 网关组件的指标对比 240
9.4 Kong 接入 240
9.4.1 为什么使用 Kong 240
9.4.2 Kong 安装实践 241
【实例 9-1】Docker 方式安装 Kong 242
9.4.3 创建服务 244
9.4.4 创建路由 245
9.5 安装 Kong 插件 246
9.5.1 跨域身份验证：JWT 认证插件 246
9.5.2 系统监控报警：Prometheus 可视化监控插件 248
9.5.3 实时链路数据追踪：Zipkin 插件 250
9.5.4 进阶应用：自定义 Kong 插件 252
【实例 9-2】自定义鉴权插件 token-auth 252
9.6 小结 257
第 10 章 微服务的容错处理与负载均衡
10.1 服务熔断 258
10.1.1 分布式系统中的服务雪崩 258
10.1.2 服务熔断保障系统可用性 260
10.1.3 断路器 261

10.2 负载均衡 262
10.2.1 负载均衡类型 262
10.2.2 负载均衡算法 262
10.3 实践案例：服务熔断和负载均衡使用 263
10.3.1 负载均衡器 263
10.3.2 服务编写 264
10.3.3 使用 Go-kit Hystrix 中间件 270
【实例 10-1】使用 Go-kit Hystrix 中间件修饰 Endpoint 270
10.4 Hystrix 详解 271
10.4.1 Hystrix 基本使用 272
10.4.2 运行流程 273
10.4.3 常用参数配置 274
10.5 Hystrix 监控面板 275
10.5.1 获取 Hystrix 命令调用信息 275
10.5.2 使用 Hystrix Dashboard 可视化面板 277
10.6 实践案例：在网关中添加 Hystrix 熔断和负载均衡 279
10.7 小结 282
第 11 章 统一认证与授权
11.1 微服务安全的挑战和现状 283
11.2 常见的认证与授权方案 283
11.2.1 当前行业授权标准 OAuth2 283
11.2.2 数据共享的分布式 Session 287
11.2.3 安全传输对象 JWT 288
11.3 实践案例：基于 OAuth2 协议和 JWT 实现一套简单 的认证和授权系统 290
11.3.1 系统整体架构 290
11.3.2 授权服务器 291
1．用户服务和客户端服务 292
2．TokenGrant 令牌生成器 294
3．TokenService 令牌服务 296
4．TokenStore 令牌存储器 300
5．/oauth/token 和/oauth/check_token 303
6．请求访问令牌和刷新令牌 306
11.3.3 资源服务器 311
1．令牌认证 311
2．鉴权 312
3．访问受限资源 313
11.4 小结 317

第 12 章 分布式链路追踪
12.1 诊断分布式系统的问题 318
12.1.1 为什么需要分布式链路追踪 318
12.1.2 什么是分布式链路追踪 319
12.1.3 分布式链路追踪规范：OpenTracing 320
12.1.4 分布式链路追踪的基础概念 321
12.2 几种流行的分布式链路追踪组件 323
12.2.1 简单易上手的 Twitter Zipkin 323
12.2.2 云原生链路监控组件 Uber Jaeger 324
12.2.3 探针性能低损耗的 SkyWalking 326
12.2.4 链路统计详细的 Pinpoint 327
12.2.5 4 种分布式链路追踪组件的指标对比 328
12.3 实践案例：应用 Zipkin 追踪 Go 微服务 329
12.3.1 微服务中集成 zipkin-go 330
12.3.2 Go-kit 微服务框架集成 Zipkin 实现链路追踪 337
1．HTTP 调用方式的链路追踪 338
2．gRPC 调用方式的链路追踪 342
12.4 小结 346
第四篇 综合实战
本部分是商品秒杀系统的实战项目，综合难度相对较高，我们通过分析业务系统的领域 设计，将系统划分成具体的微服务，整合各个微服务组件，最终实现一个高并发的商品秒杀 系统。
第 13 章 综合实战：秒杀系统的设计与实现
13.1 秒杀系统简介 347
13.2 项目架构简介 350
13.2.1 项目简述 350
13.2.2 架构信息 350
13.2.3 流程简介 352
13.3 整合升级：各个微服务脚手架的组装 353
13.3.1 服务注册和发现 353
13.3.2 负载均衡策略 357
13.3.3 RPC 客户端装饰器 360
13.3.4 限流 362
13.3.5 Go 语言 Redis 使用简介 364

13.3.6 Zookeeper 集成 366
13.3.7 Go-kit 开发利器 Truss 367
13.4 秒杀核心逻辑 368
13.4.1 秒杀业务系统 370
13.4.2 秒杀核心系统 380
13.4.3 秒杀管理系统 384
13.5 性能压测 386
13.5.1 查看服务的配置文件 386
13.5.2 压测实验 387
13.6 小结 390
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go语言高并发与微服务实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.NET并发编程实战
目    录

第Ⅰ部分  函数式编程在并发程序中所体现的优势
第1章  函数式并发基础   3
1.1  你将从本书中学到什么   4
1.2  让我们从术语开始   5
1.2.1  顺序编程——一次执行一个任务   6
1.2.2  并发编程——同时运行多个任务   7
1.2.3  并行编程——同时执行多个任务   8
1.2.4  多任务处理——同时在一段时间内执行多个任务   9
1.2.5  多线程性能调优   10
1.3  为什么需要并发   11
1.4  并发编程的陷阱   14
1.4.1  并发的危害   14
1.4.2  共享状态的演变   17
1.4.3  一个简单的真实示例：并行快速排序   17
1.4.4  F#中的基准测试   21
1.5  为什么选择函数式编程实现并发   21
1.6  拥抱函数式范式   24
1.7  为什么选择F#和C#进行函数式并发编程   25
1.8  本章小结   27
第2章  并发函数式编程技术   29
2.1  使用函数组合解决复杂的问题   30
2.1.1  C#的函数组合   30
2.1.2  F#的函数组合   32
2.2  闭包简化函数式思考   33
2.2.1  使用lambda表达式捕获闭包中的变量   34
2.2.2  多线程环境中的闭包   36
2.3  用于程序加速的记忆化缓存技术   38
2.4  记忆快速网络爬虫的操作   42
2.5  延迟记忆化以获得更好的性能   46
2.6  有效率的并行推测以摊销昂贵计算成本   47
2.6.1  具有天然函数支持的预计算   50
2.6.2  使最佳计算获胜   51
2.7  延迟是件好事情   52
2.7.1  对严格求值语言并发行为的理解   52
2.7.2  延迟缓存技术和线程安全的单例模式   54
2.7.3  F#中的延迟支持   55
2.7.4  延迟和任务，一个强大的组合   55
2.8  本章小结   57
第3章  函数式数据结构和不可变性   59
3.1  真实世界的例子：捕猎线程不安全的对象   60
3.1.1  .NET不可变集合：一种安全的解决方案   63
3.1.2  .NET并发集合：更快的解决方案   67
3.1.3  代理消息传递模式：更快、更好的解决方案   69
3.2  在线程之间安全地共享函数式数据结构   72
3.3  修改的不可变性   73
3.3.1  数据并行的函数式数据结构   75
3.3.2  使用不可变性的性能影响   75
3.3.3  C#的不可变性   76
3.3.4  F#的不可变性   79
3.3.5  函数式列表：连接一条链中的单元格   80
3.3.6  构建可持久化数据结构：不可变二叉树   86
3.4  递归函数：一种自然的迭代方式   89
3.4.1  正确递归函数尾部：尾部调用优化   90
3.4.2  延续传递风格以优化递归函数   91
3.5  本章小结   95
第Ⅱ部分  如何处理并发程序的不同部分
第4章  处理大数据的基础：数据并行，第1部分   99
4.1  什么是数据并行   100
4.1.1  数据和任务并行   101
4.1.2  “尴尬并行”概念   102
4.1.3  .NET中的数据并行支持   102
4.2  Fork / Join模式：并行Mandelbrot   103
4.2.1  当GC是瓶颈时：结构与类对象   109
4.2.2  并行循环的缺点   111
4.3  测量性能速度   111
4.3.1  Amdahl定律定义了性能改进的极限   112
4.3.2  Gustafson定律：进一步衡量性能改进   113
4.3.3  并行循环的局限性：素数之和   113
4.3.4  简单循环可能会出现什么问题   115
4.3.5  声明式并行编程模型   117
4.4  本章小结   118
第5章  PLINQ和MapReduce：数据并行，第2部分   121
5.1  PLINQ简介   122
5.1.1  PLINQ如何更具函数式   123
5.1.2  PLINQ和纯函数：并行字计数器   123
5.1.3  使用纯函数避免副作用   125
5.1.4  隔离和控制副作用：重构并行字计数器   127
5.2  并行聚合和归约数据   128
5.2.1  择伐(Deforesting)：折叠的诸多优点之一   130
5.2.2  PLINQ中的fold：Aggregate函数   131
5.2.3  为PLINQ实现并行Reduce函数   137
5.2.4  F#的并行列表解析：PSeq   139
5.2.5  F#的并行数组   140
5.3  并行MapReduce模式   142
5.3.1  Map和Reduce函数   143
5.3.2  在NuGet 包库中使用 MapReduce   144
5.4  本章小结   149
第6章  实时事件流：函数式反应式编程   151
6.1  反应式编程: 大事件处理   152
6.2  用于反应式编程的.NET工具   155
6.2.1  事件组合器——更好的解决方案   156
6.2.2  .NET与F#组合器的互操作性   157
6.3  .NET中的反应式编程：反应式扩展(Rx)   160
6.3.1  从LINQ/PLINQ到Rx   162
6.3.2  IObservable：对偶IEnumerable   163
6.3.3  Action中的反应式扩展   164
6.3.4  Rx实时流   165
6.3.5  从事件到F# Observable   166
6.4  驯服事件流：使用Rx编程进行Twitter情绪分析   167
6.5  Rx发布者-订阅者   176
6.5.1  为强大的发布者-订阅者集线器使用Subject类型   176
6.5.2  与并发相关的Rx   177
6.5.3  实现可重用的Rx发布者-订阅者   178
6.5.4  使用Rx Pub-Sub类分析推文情绪   180
6.5.5  action中的观察者   183
6.5.6  方便的F#对象表达式   184
6.6  本章小结   184
第7章  基于任务的函数式并行   187
7.1  任务并行的简短介绍   188
7.1.1  为什么要进行任务并行和函数式编程   189
7.1.2  .NET中的任务并行化支持   189
7.2  .NET任务并行库   191
7.3  C# void的问题   196
7.4  延续传递风格(CPS)：函数式控制流程   198
7.4.1  为什么要利用CPS   199
7.4.2  等待任务完成：延续模型   200
7.5  组合任务操作的策略   205
7.5.1  使用数学模式以获得更好的组合   207
7.5.2  任务使用准则   212
7.6  并行函数式管道模式   212
7.7  本章小结   218
第8章  最终胜出的任务异步模型   219
8.1  异步编程模型(APM)   220
8.1.1  异步编程的价值   220
8.1.2  可扩展性和异步编程   223
8.1.3  CPU密集型和I/O密集型操作   223
8.2  异步编程不受限制的并行度   224
8.3  .NET的异步支持   225
8.3.1  异步编程会破坏代码结构   228
8.3.2  基于事件的异步编程   228
8.4  C#基于任务的异步编程   229
8.4.1  匿名异步lambda   232
8.4.2  Task<T>是一个monadic容器   232
8.5  基于任务的异步编程：案例研究   235
8.5.1  异步取消   240
8.5.2  带有monadic Bind运算符的基于任务的异步组合   244
8.5.3  延迟异步计算以实现组合   245
8.5.4  如果出现问题，请重试   246
8.5.5  异步操作的错误处理   247
8.5.6  股票市场历史的异步并行处理   249
8.5.7  任务完成后的异步股票市场并行处理   251
8.6  本章小结   252
第9章  F#的异步函数编程   253
9.1  异步函数式方面   254
9.2  什么是F#异步工作流   254
9.2.1  计算表达式中的延续传递风格   254
9.2.2  异步工作流操作：Azure Blob存储并行操作   257
9.3  异步计算表达式   261
9.3.1  计算表达式和单子之间的区别   263
9.3.2  异步重试：生成自己的计算表达式   264
9.3.3  扩展异步工作流   266
9.3.4  映射异步操作：Async.map函子   267
9.3.5  并行化异步工作流：Async.Parallel   269
9.3.6  异步工作流取消支持   274
9.3.7  驯服并行异步操作   276
9.4  本章小结   280
第10章  用于流畅式并发编程的函数式组合器   281
10.1  执行流并不总是处于正常情况：错误处理   282
10.2  错误组合器：C#中的Retry、Otherwise和Task.Catch   285
10.2.1  FP中的错误处理：流控制的异常   289
10.2.2  在C#中使用Task<Option<T>>处理错误   291
10.2.3  F# AsyncOption类型：组合Async和Option   291
10.2.4  F#惯用的函数式异步错误处理   292
10.2.5  使用Result类型保留异常语义   294
10.3  在异步操作中控制异常   298
10.3.1  F#使用Async和Result 建模错误处理   302
10.3.2  使用monadic运算符bind扩展F# AsyncResult类型   304
10.4  使用函数式组合器抽象化操作   308
10.5  函数式组合器概要   309
10.5.1  TPL内置异步组合器   310
10.5.2  利用Task.WhenAny组合器实现冗余和交叉   311
10.5.3  使用Task.WhenAll组合器进行异步for-each   312
10.5.4  回顾迄今看到的数学模式   314
10.6  最终的并行组合应用函子   317
10.6.1  使用应用函子运算符扩展F#异步工作流   324
10.6.2  带有中缀运算符的F#应用函子语义   326
10.6.3  利用应用函子实现异构并行计算   326
10.6.4  组合和执行异构并行计算   328
10.6.5  使用条件异步组合器控制流   330
10.6.6  运用异步组合器   334
10.7  本章小结   336
第11章  使用代理应用反应式编程   339
11.1  什么是反应式编程   340
11.2  异步消息传递编程模型   342
11.2.1  消息传递和不可变性的关系   344
11.2.2  天然隔离   344
11.3  代理是什么   345
11.3.1  代理的组件   346
11.3.2  代理可以做什么   347
11.3.3  无锁并发编程的无共享方法   347
11.3.4  基于代理的编程如何体现函数式思想   348
11.3.5  代理是面向对象的   349
11.4  F#代理：MailboxProcessor   349
11.5  使用F# MailboxProcessor避免数据库瓶颈   352
11.5.1  MailboxProcessor消息类型：可区分联合   355
11.5.2  MailboxProcessor双向通信   356
11.5.3  在C#中使用AgentSQL   357
11.5.4  成组协调代理来并行工作流   358
11.5.5  如何使用F# MailboxProcessor处理错误   360
11.5.6  停止MailboxProcessor代理——CancellationToken   361
11.5.7  使用MailboxProcessor分发工作   362
11.5.8  使用代理缓存操作   364
11.5.9  由MailboxProcessor报告结果   368
11.5.10  使用线程池报告来自MailboxProcessor的事件   371
11.6  F# MailboxProcessor：10 000个代理的生命游戏   371
11.7  本章小结   376
第12章  使用TPL Dataflow的并行工作流与代理编程   379
12.1  TPL Dataflow的强大性   380
12.2  组合式设计：TPL Dataflow块   381
12.2.1  使用BufferBlock<TInput>作为FIFO缓冲区   382
12.2.2  使用TransformBlock<TInput, TOutput>转换数据   383
12.2.3  使用ActionBlock<TInput>完成工作   384
12.2.4  连接数据流块   385
12.3  使用TDF实现复杂的生产者/消费者   386
12.3.1  多生产者/单消费者模式   386
12.3.2  单生产者/多消费者模式   387
12.4  使用TPL Dataflow在C#中启用代理模型   388
12.4.1  代理折叠状态和消息：聚合   392
12.4.2  代理交互：并行单词计数器   392
12.5  压缩和加密大型流的并行工作流   397
12.5.1  上下文：处理大型数据流的问题   397
12.5.2  确保消息流的顺序完整性   402
12.5.3  连接、传播和完成   403
12.5.4  构建TDF工作流的规则   405
12.5.5  组合Reactive Extensions(Rx)和TDF   406
12.6  本章小结   407
第Ⅲ部分  现代并发编程模式应用
第13章  成功的并发编程的配方和设计模式   411
13.1  循环利用对象以减少内存消耗   412
13.2  自定义并行Fork/Join运算符   415
13.3  并行具有依赖关系的任务：设计代码以优化性能   418
13.4  用于协调并发I/O操作共享资源的闸门：一次写入，多次读取   423
13.5  线程安全的随机数生成器   430
13.6  多态事件聚合器   432
13.7  自定义Rx调度程序来控制并行度   435
13.8  并发的反应式可扩展客户端/服务器   438
13.9  可复用的自定义高性能并行filter-map运算符   448
13.10  无阻塞同步消息传递模型   452
13.11  使用代理编程模型协调并发作业   457
13.12  组合monadic函数   462
13.13  本章小结   465
第14章  使用并发函数式编程构建可扩展的移动应用程序   467
14.1  现实世界服务器上的函数式编程   468
14.2  如何设计一个成功的高性能应用程序   469
14.2.1  秘制酱：ACD   470
14.2.2  不同的异步模式：将工作排队以稍后执行   470
14.3  选择正确的并发编程模型   472
14.4  实时交易：股票市场示例的高层架构   475
14.5  股票市场应用程序的基本要素   479
14.6  编写股票市场交易应用程序   479
14.7  本章小结   501
附录A  函数式编程   503
附录B  F#概述   517
附录C  F#异步工作流和.NET Task之间的互操作性   535
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.NET并发编程实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>并行算法设计与性能优化
前言
第1章绪论
1.1并行和向量化的作用
1.2为什么要并行或向量化
1.3为什么向量化或并行难
1.4并行的替代方法
1.5进程、线程与处理器
1.6并行硬件平台
1.7向量化和多核技术不是万能的
1.8本章小结
第2章现代处理器特性
2.1指令级并行
2.1.1指令流水线
2.1.2乱序执行
2.1.3指令多发射
2.1.4分支预测
2.1.5VLIW
2.2向量化并行
2.2.1SIMD
2.2.2SIMT
2.3线程级并行
2.3.1内核线程和用户线程
2.3.2多线程编程库
2.3.3多核上多线程并行要注意的问题
2.3.4多线程程序在多核和单核上运行的不同
2.4缓存
2.4.1缓存层次结构
2.4.2缓存一致性
2.4.3缓冲不命中
2.4.4写缓存
2.4.5越过缓存
2.4.6硬件预取
2.4.7缓存结构
2.4.8映射策略
2.5虚拟存储器和TLB
2.6NUMA技术
2.7本章小结
第3章算法性能和程序性能的度量与分析
3.1算法分析的性能度量标准
3.1.1时间复杂度与空间复杂度
3.1.2实现复杂度
3.2程序和指令的性能度量标准
3.3程序性能优化的度量标准
3.3.1加速比与并行效率
3.3.2Amdahl定律和Gustafson定律
3.4程序性能分析实用工具
3.5本章小结
第4章串行代码性能优化
4.1系统级别
4.2应用级别
4.3算法级别
4.4函数级别
4.4.1函数调用参数
4.4.2内联小函数
4.5循环级别
4.5.1循环展开
4.5.2循环累积
4.5.3循环合并
4.5.4循环拆分
4.6语句级别
4.6.1减少内存读写
4.6.2选用尽量小的数据类型
4.6.3结构体对齐
4.6.4表达式移除
4.6.5分支优化
4.6.6优化交换性能
4.7指令级别
4.8本章小结
第5章依赖分析
5.1指令级依赖
5.1.1结构化依赖
5.1.2数据依赖
5.1.3控制依赖
5.2循环级依赖
5.2.1循环数据依赖
5.2.2循环控制依赖
5.3寄存器重命名
5.4本章小结
第6章并行编程模型及环境
6.1并行编程模型
6.1.1指令级并行
6.1.2向量化并行
6.1.3易并行
6.1.4任务并行
6.1.5数据并行
6.1.6循环并行化
6.1.7流水线并行
6.1.8区域分解并行
6.1.9隐式和显式并行化
6.1.10SPMD
6.1.11共享存储器并行
6.1.12分布式存储器并行
6.2常见并行编程环境
6.2.1MPI
6.2.2OpenMP
6.2.3fork/pthread
6.2.4CUDA
6.2.5OpenCL
6.2.6OpenACC
6.2.7NEON内置函数
6.2.8SSE/AVX内置函数
6.3本章小结
第7章并行算法设计方法
7.1划分
7.1.1分而治之
7.1.2划分原则
7.1.3常见划分方法
7.1.4并行性和局部性
7.2通信
7.2.1操作的原子性
7.2.2结果的可见性
7.2.3顺序一致性
7.2.4函数的可重入与线程安全
7.2.5volatile关键字
7.2.6锁
7.2.7临界区
7.2.8原子操作
7.2.9栅栏
7.3结果归并
7.4负载均衡
7.4.1静态负载均衡
7.4.2动态负载均衡
7.4.3动态负载均衡算法的一般步骤
7.5本章小结
第8章并行算法缺陷
8.1启动结束时间
8.2负载均衡
8.3竞写
8.4锁
8.4.1死锁
8.4.2活锁
8.5饿死
8.6伪共享
8.7原子操作
8.8存储器栅栏
8.9缓存一致性
8.10顺序一致性
8.11volatile同步错误
8.12本章小结
第9章并行编程模式实践
9.1map模式
9.2reduce模式
9.3结合map和reduce模式
9.4scan模式
9.5zip/unzip模式
9.6流水线模式
9.7本章小结
第10章如何并行遗留代码
10.1找出软件的计算热点
10.2判断是否并行化热点
10.3设计算法并实现
10.3.1选择何种工具进行向量化或并行化
10.3.2重构热点代码
10.3.3依据硬件实现算法
10.4将实现后的代码嵌入原软件
10.4.1混合编译
10.4.2动态链接库
10.5示例：如何并行化word2vec
10.6本章小结
第11章超级并行
11.1超级并行方式编程
11.1.1进程+线程
11.1.2进程+GPU线程
11.1.3线程+GPU线程
11.1.4线程+向量指令
11.1.5进程+线程+向量指令
11.1.6进程+线程+GPU线程
11.2矩阵乘法
11.2.1多机CPU矩阵乘法
11.2.2单机多GPU矩阵乘法
11.2.3多机多GPU矩阵乘法
11.3本章小结
第12章并行算法设计的一般准则
12.1并行算法设计14准则
12.2本章小结
附录A整型数据与浮点数据
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>并行算法设计与性能优化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java线程
前言
第一章 Thread导论
Java术语
关于范例
为何要用Thread？
总结
第二章 Thread的创建与管理
什么是Thread？
创建Thread
Thread的生命周期
两种停止Thfead的方式
Runnable工nterface
Thread与对象
总结
第三章 数据同步
Synchronized关键字
Volatile关键字
更多RaceCOnd“iOn的讨论
明确的 (explicit)Locking
Lock Scope
选择Locking机制
Nested Lock
死锁
Lock公平 (Fairness)
总结
第四章 Thread NOtification
等待与通知
条件变量
总结
第五章 极简同步技巧
能避免同步吗？
Atomic变量
Thread局部变量
总结
第六章 高级同步议题
同步术语
J2SE 5.0中加入的同步Class
防止死锁
死锁检测
Lock饥饿
总结
第七章 Thread与Swing
Swing Threading的限制
事件派发Thread的处理
使用invokeLater()与invokeAndWait()
长时间运行的事件回调
总结
第八章 Thread与Collection Class
Collection Class的概述
同步与Collection Class
生产者/肖费者模式
使用CollectionClass
总结
第九章 Thread调度
Thread调度的概述
以Thread优先级来调度
常见Threading的实现
总结
第十章 Thread Pool
为何要用Thread Pool？
Executor
使用Thread Pool
Queue与大小
创建Thread
Callable Task与Future结果
单一Thread化的访问
总结
第十一章 Task的调度
Task调度的概述
java.util.Timer Class
javax.Swing.Timer Class
SCheduledThreadPoolExecutor Class
总结
第十二章 Thread与I／O
传统的I／O服务器
新的I／O服务器
被中断的I／O
总结
第十三章 各种Thread议题
Thread Group
Thread与Java安全性
Daemon Thread
Thread与C1ass的力口载
Thread与异常处理
Thread、Stack、 内存的使用
总结
第十四章 Thread性能
性能的概述
同步的Collection
Atomic变量与有竞争的同步
Thread的创建与Thread Pool
总结
第十五章 多处理器计算机的并行化循环
对单一Threaded程序的并行化
多处理器扩大(scaling)
总结
附录 被撤换的Threading功能
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java线程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>多处理器编程的艺术
出版者的话
译者序
前言
教学建议
第1章   引言	1
1.1   共享对象和同步	2
1.2   生活实例	4
1.2.1   互斥特性	6
1.2.2   道德	7
1.3   生产者-消费者问题	7
1.4   读者-写者问题	9
1.5   并行的困境	9
1.6   并行程序设计	11
1.7   本章注释	11
1.8   习题	11
第一部分   原       理
第2章   互斥	14
2.1   时间	14
2.2   临界区	14
2.3   双线程解决方案	16
2.3.1   LockOne类	16
2.3.2   LockTwo类	17
2.3.3   Peterson锁	18
2.4   过滤锁	19
2.5   公平性	21
2.6   Bakery算法	21
2.7   有界时间戳	23
2.8   存储单元数量的下界	25
2.9   本章注释	27
2.10   习题	28
第3章   并发对象	31
3.1   并发性与正确性	31
3.2   顺序对象	33
3.3   静态一致性	34
3.4   顺序一致性	35
3.5   可线性化性	38
3.5.1   可线性化点	38
3.5.2   评析	38
3.6   形式化定义	38
3.6.1   可线性化性	39
3.6.2   可线性化性的复合性	40
3.6.3   非阻塞特性	40
3.7   演进条件	41
3.8   Java存储器模型	43
3.8.1   锁和同步块	44
3.8.2   volatile域	44
3.8.3   final域	44
3.9   评析	45
3.10   本章注释	46
3.11   习题	46
第4章   共享存储器基础	50
4.1   寄存器空间	50
4.2   寄存器构造	54
4.2.1   MRSW安全寄存器	55
4.2.2   MRSW规则布尔寄存器	55
4.2.3   M-值MRSW规则寄存器	56
4.2.4   SRSW原子寄存器	57
4.2.5   MRSW原子寄存器	59
4.2.6   MRMW原子寄存器	60
4.3   原子快照	62
4.3.1   无障碍快照	63
4.3.2   无等待快照	64
4.3.3   正确性证明	66
4.4   本章注释	67
4.5   习题	67
第5章   同步原子操作的相对能力	70
5.1   一致数	70
5.2   原子寄存器	72
5.3   一致性协议	74
5.4   FIFO队列	74
5.5   多重赋值对象	77
5.6   读-改-写操作	79
5.7   Common2 RMW操作	80
5.8   compareAndSet()操作	81
5.9   本章注释	82
5.10   习题	83
第6章   一致性的通用性	87
6.1   引言	87
6.2   通用性	88
6.3   一种通用的无锁构造	88
6.4   一种通用的无等待构造	91
6.5   本章注释	95
6.6   习题	95
第二部分   实      践
第7章   自旋锁与争用	98
7.1   实际问题	98
7.2   测试-设置锁	100
7.3   再论基于TAS的自旋锁	102
7.4   指数后退	102
7.5   队列锁	104
7.5.1   基于数组的锁	104
7.5.2   CLH队列锁	106
7.5.3   MCS队列锁	107
7.6   时限队列锁	110
7.7   复合锁	112
7.8   层次锁	118
7.8.1   层次后退锁	118
7.8.2   层次CLH队列锁	119
7.9   由一个锁管理所有的锁	123
7.10   本章注释	123
7.11   习题	124
第8章   管程和阻塞同步	126
8.1   引言	126
8.2   管程锁和条件	126
8.2.1   条件	127
8.2.2   唤醒丢失问题	130
8.3   读者-写者锁	131
8.3.1   简单的读者-写者锁	131
8.3.2   公平的读者-写者锁	132
8.4   我们的可重入锁	134
8.5   信号量	135
8.6   本章注释	136
8.7   习题	136
第9章   链表：锁的作用	139
9.1   引言	139
9.2   基于链表的集合	140
9.3   并发推理	141
9.4   粗粒度同步	142
9.5   细粒度同步	143
9.6   乐观同步	146
9.7   惰性同步	149
9.8   非阻塞同步	153
9.9   讨论	157
9.10   本章注释	157
9.11   习题	158
第10章   并行队列和ABA问题	159
10.1   引言	159
10.2   队列	160
10.3   部分有界队列	160
10.4   完全无界队列	163
10.5   无锁的无界队列	164
10.6   内存回收和ABA问题	166
10.7   双重数据结构	170
10.8   本章注释	172
10.9   习题	172
第11章   并发栈和消除	174
11.1   引言	174
11.2   无锁的无界栈	174
11.3   消除	176
11.4   后退消除栈	176
11.4.1   无锁交换机	177
11.4.2   消除数组	179
11.5   本章注释	181
11.6   习题	181
第12章   计数、排序和分布式协作	184
12.1   引言	184
12.2   共享计数	184
12.3   软件组合	185
12.3.1   概述	185
12.3.2   一个扩展实例	190
12.3.3   性能和健壮性	191
12.4   静态一致池和计数器	192
12.5   计数网	192
12.5.1   可计数网	193
12.5.2   双调计数网	194
12.5.3   性能和流水线	201
12.6   衍射树	201
12.7   并行排序	204
12.8   排序网	204
12.9   样本排序	207
12.10   分布式协作	208
12.11   本章注释	208
12.12   习题	209
第13章   并发哈希和固有并行	212
13.1   引言	212
13.2   封闭地址哈希集	213
13.2.1   粗粒度哈希集	214
13.2.2   空间分带哈希集	215
13.2.3   细粒度哈希集	217
13.3   无锁哈希集	219
13.3.1   递归有序划分	219
13.3.2   BucketList类	222
13.3.3   LockFreeHashSet<T>类	223
13.4   开放地址哈希集	225
13.4.1   Cuckoo哈希	225
13.4.2   并发Cuckoo哈希	226
13.4.3   空间分带的并发Cuckoo哈希	230
13.4.4   细粒度的并发Cuckoo哈希集	231
13.5   本章注释	233
13.6   习题	234
第14章   跳表和平衡查找	235
14.1   引言	235
14.2   顺序跳表	235
14.3   基于锁的并发跳表	236
14.3.1   简介	236
14.3.2   算法	238
14.4   无锁并发跳表	243
14.4.1   简介	243
14.4.2   算法细节	245
14.5   并发跳表	251
14.6   本章注释	251
14.7   习题	251
第15章   优先级队列	253
15.1   引言	253
15.2   基于数组的有界优先级队列	253
15.3   基于树的有界优先级队列	254
15.4   基于堆的无界优先级队列	256
15.4.1   顺序堆	256
15.4.2   并发堆	258
15.5   基于跳表的无界优先级队列	262
15.6   本章注释	264
15.7   习题	265
第16章   异步执行、调度和工作分配	266
16.1   引言	266
16.2   并行分析	271
16.3   多处理器的实际调度	273
16.4   工作分配	274
16.4.1   工作窃取	275
16.4.2   屈从和多道程序设计	275
16.5   工作窃取双端队列	276
16.5.1   有界工作窃取双端队列	276
16.5.2   无界工作窃取双端队列	279
16.5.3   工作平衡	282
16.6   本章注释	283
16.7   习题	284
第17章   障碍	287
17.1   引言	287
17.2   障碍实现	288
17.3   语义换向障碍	288
17.4   组合树障碍	289
17.5   静态树障碍	291
17.6   终止检测障碍	293
17.7   本章注释	295
17.8   习题	296
第18章   事务内存	302
18.1   引言	302
18.1.1   关于锁的问题	302
18.1.2   关于compareAndSet()的问题	303
18.1.3   关于复合性的问题	304
18.1.4   我们能做什么	305
18.2   事务和原子性	305
18.3   软事务内存	306
18.3.1   事务和事务线程	309
18.3.2   僵尸事务和一致性	310
18.3.3   原子对象	311
18.3.4   如何演进	311
18.3.5   争用管理器	312
18.3.6   原子对象的实现	314
18.3.7   无干扰原子对象	315
18.3.8   基于锁的原子对象	318
18.4   硬事务内存	323
18.4.1   缓存一致性	324
18.4.2   事务缓存一致性	324
18.4.3   改进	325
18.5   本章注释	325
18.6   习题	326
第三部分   附      录
附录A   软件基础	328
附录B   硬件基础	340
参考文献	350
索引	359
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>多处理器编程的艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>多核计算与程序设计
第1部分 基础知识
第1章	多核计算概述	2
1.1	多核CPU概述	2
1.1.1	多核计算将成为发展趋势	2
1.1.2	多核CPU硬件架构介绍	4
1.1.3	多核给程序员带来的机遇和挑战	6
1.2	多核编程会遇到那些问题	9
1.2.1	并发性问题	9
1.2.2	CPU饥饿问题	9
1.2.3	任务的分解与调度问题	10
1.2.4	加速比性能问题	11
1.2.5	节能环保问题	12
1.2.6	扩展性问题	13
1.3	多核编程与单核多线程编程的区别	13
1.3.1	锁竞争导致的串行化的区别	13
1.3.2	线程分解与执行的区别	15
1.3.3	CPU核负载平衡的区别	15
1.3.4	任务调度策略的区别	15
1.3.5	CPU Cache存取的区别（伪共享问题）	16
1.3.6	任务优先级抢占的区别	18
1.3.7	串行计算与并行及分布式计算的区别	19
1.4	多核编程与多机分布式编程的区别	19
1.4.1	共享存储与分布式存储的区别	19
1.4.2	分布式计算的区别	20
1.4.3	编程环境上的区别	20
1.5	加速比系数	20
1.5.1	阿姆达尔定律	20
1.5.2	Gustafson定律	22
1.5.3	阿姆达尔定律和Gustafson定律的等价性	24
1.5.4	Karp-Flatt度量	25
1.5.5	实际情况中影响加速比系数的因素	27
1.5.6	并行计算开销情况下的加速比	27
1.6	锁竞争问题及对加速比的影响	28
1.6.1	线程粒度因子与锁粒度因子	28
1.6.2	锁竞争的性能情况	30
1.6.3	集中式锁竞争中的加速比分析	31
1.6.4	随机锁竞争中的加速比分析	33
1.6.5	分布式锁竞争的加速比分析	36
1.6.6	无锁编程的加速比分析	40
1.7	负载平衡问题对加速比的影响	43
1.7.1	影响负载平衡的主要因素	43
1.7.2	负载平衡的评价指标	43
1.7.3	负载平衡情况下的加速比	44
1.8	 参考文献	                                                     44
第2章	多线程编程基础	2
2.1	多线程编程基本概念	2
2.1.1	线程	2
2.1.2	锁	3
2.1.3	各种系统中常用的锁操作及信号量操作函数	6
2.1.4	用C++实现锁的自动释放	8
2.1.5	原子操作	10
2.1.6	锁与原子操作的区别	14
2.1.7	有锁计算、无锁计算与本地计算的概念	15
2.2	各种锁性能比较	15
2.2.1	各种锁在单线程情况下的性能	15
2.2.2	各种锁在多线程集中式锁竞争情况下的性能	17
2.2.3	各种锁在多线程分布式锁竞争情况下的性能	19
2.3	读写锁算法	21
2.3.1	读写锁概念的引出	21
2.3.2	读写锁算法的分析和实现	22
2.3.3	读写锁的编码实现	23
2.4	多线程退出算法	25
2.4.1	单个子线程退出算法	25
2.4.2	多个线程访问共享资源时的退出	27
2.4.3	有锁的多线程资源释放退出算法实现	30
2.4.4	无锁的退出算法	32
2.4.5	多线程退出算法的使用	34
2.5	参考文献	35
第3章	OpenMP程序设计	3
3.1	OpenMP基本概念	3
3.1.1	fork/join并行执行模式的概念	3
3.1.2	内存模型	5
3.1.3	性能例子	6
3.1.4	编译器对OpenMP的支持	6
3.2	OpenMP编程模型	8
3.2.1	OpenMP编译指导语句格式	8
3.2.2	OpenMP主要命令	9
3.2.3	OpenMP主要子句	10
3.2.4	OpenMP主要库函数	10
3.3	线程创建与工作分摊	11
3.3.1	parallel命令	11
3.3.2	for和parallel for命令	13
3.3.3	if子句（条件执行并行）	17
3.3.4	动态设置并行循环的线程数量	17
3.3.5	循环并行化的问题	19
3.3.6	sections和section命令	21
3.3.7	single命令	23
3.3.8	master命令	24
3.4	数据处理	25
3.4.1	private子句	25
3.4.2	firstprivate子句	26
3.4.3	lastprivate子句	26
3.4.4	threadprivate子句	27
3.4.5	shared子句	28
3.4.6	default子句	28
3.4.7	reduction子句	29
3.4.8	copyin子句	30
3.4.9	copyprivate子句	31
3.5	任务调度	32
3.5.1	Schedule子句用法	33
3.5.2	静态调度(static)	33
3.5.3	动态调度(dynamic)	35
3.5.4	guided调度（guided）	36
3.5.5	runtime调度（rumtime）	37
3.5.6	任务调度与伪共享问题	37
3.6	线程间的同步	37
3.6.1	barrier命令	37
3.6.2	critical命令	38
3.6.3	atomic命令	39
3.6.4	ordered命令和子句	40
3.6.5	nowait子句	41
3.6.6	flush命令	42
3.7	OpenMP库函数详解	43
3.7.1	执行环境函数	43
3.7.2	锁操作函数	45
3.7.3	时间操作函数	47
3.8	OpenMP环境变量	47
3.8.1	OMP_DYNAMIC	47
3.8.2	OMP_NUM_THREADS	48
3.8.3	OMP_NESTED	48
3.8.4	OMP_SCHEDULE	48
3.9	OpenMP内部控制变量及相关流程	48
3.9.1	内部控制变量	48
3.9.2	任务调度流程	49
3.9.3	线程数量决定流程	50
3.10	参考文献：	52
第二部份 基础数据结构与算法
第4章	数组	1
4.1	栈	2
4.1.1	栈的基本概念	2
4.1.2	栈的编码实现	3
4.1.3	多线程栈的实现	6
4.2	对数组进行快速排序	8
4.2.1	排序算法介绍	8
4.2.2	串行快速排序基本思想	9
4.2.3	串行快速排序的代码实现	11
4.2.4	非递归的快速排序算法	12
4.2.5	快速排序算法的复杂度分析	16
4.3	对数组进行查找	17
4.3.1	顺序查找	17
4.3.2	二分查找	17
4.4	实例：用数组管理一个HOOK功能	19
4.4.1	单个函数的HOOK实现	19
4.4.2	多个函数的HOOK实现	20
4.4.3	HOOK功能的应用简介	25
4.4.4	HOOK使用的注意事项	25
4.5	参考文献	25
第5章	链表	2
5.1	单向链表	2
5.1.1	存储表示	2
5.1.2	接口设计	3
5.1.3	添加节点到链表头部	4
5.1.4	基本功能编码实现	6
5.2	单向链表的排序	13
5.2.1	插入排序	13
5.2.2	归并插入排序	15
5.3	双向链表	19
5.3.1	双向链表的基本概念	19
5.3.2	双向链表的设计	20
5.3.3	双向链表的操作接口	21
5.3.4	双向链表的编码实现	21
5.4	链表的逐个节点遍历	33
5.4.1	逐个节点遍历基本概念	33
5.4.2	逐个节点遍历编码实现	34
5.5	多线程遍历算法	35
5.5.1	多线程链表的设计和编码实现	35
5.5.2	多线程链表的4种遍历方案	38
5.5.3	多个线程同时遍历的情况	42
5.6	实例：使用链表管理短信息系统的CACHE	42
5.6.1	短信息系统的CACHE管理基本概念	42
5.6.2	短信息系统的发送和接收分析	43
5.6.3	短信息系统CACHE管理的编码实现	44
第6章	哈希表	1
6.1	哈希表	2
6.1.1	哈希表的基本概念	2
6.1.2	哈希表的索引方法	3
6.1.3	哈希表的冲突解决方法	5
6.1.4	哈希表基本操作的源代码	6
6.2	哈希链表	12
6.2.1	哈希表和数组、链表的效率比较	12
6.2.2	时间效率和空间效率的关系	13
6.2.3	哈希链表的基本概念	14
6.2.4	哈希链表的操作	14
6.2.5	哈希链表的编码实现	16
6.3	实例：WebServer的动态CACHE文件管理	24
6.3.1	WebServer的动态CACHE文件管理基本概念	24
6.3.2	CACHE文件管理功能的设计	25
6.3.3	CACHE文件管理功能的编码实现	26
6.4	参考文献	31
第7章	普通树与二叉树	2
7.1	普通树	2
7.1.1	普通树的描述方法	2
7.1.2	树的操作接口设计	2
7.1.3	树的遍历算法	3
7.1.4	树的编码实现	5
7.1.5	使用树的遍历算法来实现Xcopy功能	10
7.2	二叉树	12
7.2.1	二叉树的基本概念	12
7.2.2	二叉树的树梢及二叉树的高度	13
7.2.3	二叉树的描述方法	14
7.3	二叉排序树	14
7.3.1	二叉排序树的基本概念	14
7.3.2	二叉排序树的查找	15
7.3.3	二叉排序树的插入	16
7.3.4	二叉排序树的删除	18
7.3.5	二叉排序树的遍历	21
7.3.6	二叉排序树的旋转操作	22
第8章	AVL搜索树	2
8.1	AVL搜索树的基本概念	2
8.2	AVL搜索树的插入	3
8.2.1	插入操作需要考虑的问题	3
8.2.2	不存在不平衡节点的情况分析	4
8.2.3	不平衡A节点的情况分析	5
8.2.4	存在不平衡节点的四种情况分析	5
8.2.5	LL型不平衡情况的调整	7
8.2.6	LR型不平衡情况的调整	7
8.2.7	插入操作的伪代码描述	8
8.3	AVL搜索树的删除	11
8.3.1	A节点的确定	11
8.3.2	几种不平衡情况的分析	13
8.3.3	L0型调整分析	15
8.3.4	L-1型调整分析	15
8.3.5	L1型调整分析	16
8.3.6	删除操作的伪代码描述	17
8.4	负载平衡的AVL树	19
8.4.1	基本概念的引出	19
8.4.2	插入操作中负载因子的调整	19
8.4.3	删除操作中负载因子的调整	21
8.4.4	L0和L-1型调整分析	24
8.4.5	L1型调整分析	24
8.5	AVL树的源代码	25
8.5.1	数据结构定义	25
8.5.2	创建、释放、查找等操作	26
8.5.3	旋转操作函数	28
8.5.4	插入操作函数	30
8.5.5	删除操作函数	36
8.6	参考文献	43
第9章 复合二叉树 ……………………………………………………………………
9.1  哈希红黑树……………………………………………………………………
9.1.1  哈希红黑树的基本概念…………………………………………………
9.1.1  哈希红黑树的查找…………………………………………………
9.1.3  哈希红黑树的插入…………………………………………………
9.1.4  哈希红黑树的删除…………………………………………………
9.1.5  哈希红黑树的释放…………………………………………………
9.1.6  哈希红黑树的遍历…………………………………………………
9.1.7  哈希红黑树的编码实现…………………………………………………
9.1.8  哈希红黑树的效率分析…………………………………………………
9.2  哈希AVL树……………………………………………………………
9.2.1  哈希AVL树的基本概念…………………………………………………
9.2.2  哈希AVL树的查找…………………………………………………
9.2.3  哈希AVL树的插入…………………………………………………
9.2.4  哈希AVL树的删除…………………………………………………
9.2.5  哈希AVL树的释放…………………………………………………
9.2.6  哈希AVL树的遍历…………………………………………………
9.2.7  哈希AVL树的编码实现…………………………………………………
9.3  复合数据结构的分类……………………………………………………………
9.4  抗DoS/DdoS攻击的实例…………………………………………………
9.4.1  DoS/DdoS攻击的概念…………………………………………………
9.4.2  常见DoS/DdoS攻击手段及防范策略……………………………………
9.4.3  抗DoS/DdoS攻击的实现…………………………………………………
9.4.4  抗DoS/DdoS攻击的编码实现…………………………………………………
9.5  参考文献………………………………………………………………………
第3部分 并行计算
第10章	并行程序设计模式	1
10.1	基本概念	1
10.1.1	强并行计算与弱并行计算	1
10.1.2	并行程序设计模式的基本思路	2
10.2	模式数据分解模式	2
10.3	分治模式	3
10.3.1	子问题求解时的负载平衡问题	3
10.3.2	子问题的解的合并可能引起的串行化问题	4
10.4	流水线模式	4
10.5	任务并行模式	5
10.6	任务调度模式	6
10.6.1	任务图调度模式	6
10.6.2	动态任务调度模式	7
第11章	并行搜索	1
11.1	并行顺序搜索	1
11.1.1	并行搜索指定数据	2
11.1.2	并行搜索最大数	2
11.1.3	终止检测算法	4
11.2	串行Dijkstra最短路径搜索	9
11.2.1	Dijkstra最短路径算法的描述	9
11.2.2	Dijkstra最短路径算法的过程图解	9
11.2.3	伪代码描述	11
11.2.4	算法流程图	12
11.2.5	C/C++代码实现	14
11.3	并行最短路径算法	17
11.3.1	Dijkstra算法的并行化	17
11.3.2	并行Dijkstra算法的代码实现	18
11.3.3	其他并行最短路径算法的介绍和分析	22
11.4	参考文献	23
第12章	并行排序	2
12.1	并行排序概述	2
12.2	冒泡排序	2
12.2.1	串行冒泡排序	2
12.2.2	奇偶排序	4
12.3	快速排序	6
12.3.1	串行快速排序基本思想	6
12.3.2	串行快速排序的代码实现	9
12.3.3	快速排序并行化方法	10
12.3.4	开源项目mcstl中的并行快速排序	11
12.3.5	基于任务窃取的快速排序	11
12.4	并行归并排序	11
12.4.1	串行归并算法	11
12.4.2	Cole并行归并算法	12
12.4.3	并行快速归并排序	13
12.5	基数排序	13
12.5.1	串行链式基数排序	13
12.5.2	串行数组基数排序	15
12.5.3	一步到位的分层排序	18
12.5.4	负载平衡的并行基数排序	18
12.5.5	分区的并行基数排序	22
第13章	并行数值计算	1
13.1	多核并行数值计算面临的问题	1
13.1.1	Cache的命中率问题	1
13.1.2	伪共享问题	2
13.2	求和及前缀求和	4
13.3	矩阵相加	4
13.4	矩阵相乘	4
13.4.1	基本概念	4
13.4.2	串行算法	4
13.4.3	并行算法	5
13.5	矩阵向量相乘	6
13.6	并行随机数生成	6
13.7	参考文献	6
第4部分 共享资源分布式计算
第14章	分布式计算设计模式	2
14.1	基本概念	2
14.1.1	共享资源的计算分解	2
14.1.2	共享资源计算的负载均衡问题	2
14.1.3	共享资源计算的算法设计思路与方法	3
14.2	线程分组竞争模式	3
14.2.1	标准的线程分组竞争模式	4
14.2.2	线程分组竞争模式的变种	4
14.3	线程随机竞争模式	6
14.3.1	基本概念	6
14.3.2	加速比性能的保证	6
14.4	数据本地化模式	8
14.4.1	取得比单核多线程更好的性能	8
14.4.2	数据本地化模式	8
14.4.3	优缺点分析	10
14.5	分布式数据结构设计	11
14.5.1	复合数据结构设计方法	11
14.5.2	分布式数据结构设计	12
14.5.3	分布式数据结构主要问题	12
14.6	参考文献	12
第15章	分布式队列	2
15.1	串行队列	2
15.1.1	简单环形队列	2
15.1.2	STL中的Deque	2
15.1.3	动态环形队列	2
15.2	队列池	2
15.2.1	共享队列	2
15.2.2	消息队列	2
15.2.3	队列池	2
15.2.4	队列池的几种实现方案	6
15.2.5	队列池的使用实例	6
15.3	带本地计算的分布式队列	6
15.3.1	基本思想	6
15.3.2	本地化队列的实现	6
15.3.3	任务偷取队列的实现	6
15.3.4	分布式队列的实现	6
15.3.5	线程池CThreadPool的实现	6
15.3.6	线程池CThreadPool的代码实现	7
15.3.7	CDistributedQueue源代码	10
15.3.8	CDistributedQueue的使用实例	10
第16章	分布式查找	2
16.1	多核中查找的问题与主要思路	2
16.2	静态负载平衡的二级查找结构设计	4
16.2.1	二级查找结构设计	4
16.2.2	分布式哈希AVL树	7
16.2.3	分布式顺序AVL树	7
16.3	动态负载平衡的多级查找结构设计	7
16.3.1	分布式查找中的负载平衡问题	7
16.3.2	多级查找结构设计方法	10
16.3.3	多级查找表的查找算法	13
16.3.4	多级查找表的插入操作算法	14
16.3.5	多级查找表的删除操作算法	16
16.3.6	多级顺序表	18
16.3.7	多级索引AVL树	18
16.3.8	分布式哈希多级AVL树	18
16.3.9	分布式顺序多级AVL树	18
16.4	多核环境中查找算法的选用方法	18
16.5	动态WebCache设计实例	19
第17章	分布式内存管理	2
17.1	多核内存管理的基本思想	2
17.1.1	内存管理方面的需求	2
17.1.2	多核系统中的内存管理思路	3
17.2	等尺寸内存管理	4
17.2.1	Freelist内存管理基本概念	4
17.2.2	Freelist编码实现	6
17.2.3	FreeLists内存管理	9
17.3	Intel 开源项目TBB中的内存管理	12
17.3.1	伪共享问题	12
17.3.2	Cache对齐的内存管理	12
17.3.3	数据结构	14
17.3.4	将内存管理器映射到线程	16
17.3.5	分配和释放算法	19
17.3.6	线程退出时的内存回收	24
17.4	抢夺式内存管理算法	24
17.4.1	算法基本思想	24
17.4.2	碎片重组回收利用技术	26
17.4.3	抢夺式算法的详细算法流程	28
17.4.4	代码实现	31
17.5	伪共享问题的深入分析	47
17.5.1	内存释放时的伪共享问题	47
17.5.2	伪共享问题的概率分析	48
17.5.3	用户程序使用内存过程中的伪共享问题	50
17.5.4	分布式内存管理的进一步改进措施	51
17.6	参考文献	53
第5部分 任务分解与调度
第18章	任务图分解与调度	2
18.1	任务分解与调度的问题	2
18.1.1	使用OpenMP调度的问题	2
18.1.2	任务图调度模型	3
18.1.3	任务图调度算法简介	5
18.2	任务组调度算法	6
18.2.1	基本思路	6
18.2.2	任务组调度算法	7
18.2.3	算法流程图	11
18.2.4	数据结构与接口设计	13
18.2.5	代码实现	15
18.2.6	任务组调度的应用分析	21
18.2.7	误差下降调度算法	21
18.3	任务图调度算法	24
18.3.1	任务图的分层算法	24
18.3.2	分层算法过程图解	26
18.3.3	数据结构和接口设计	29
18.3.4	分层算法的代码实现	31
18.3.5	任务调度器的代码实现	33
18.3.6	实例：任务图调度器的使用	35
18.4	手工任务分解的原则和方法	37
18.4.1	任务间负载均衡的影响因素	37
18.4.2	任务分解原则和方法	38
18.5	参考文献	39
第19章	动态任务分解与调度	1
19.1	动态任务分解的两种类型	1
19.2	非嵌套型动态任务调度	2
19.2.1	网络服务器软件中的任务调度	2
19.2.2	使用分布式队列的调度方法	4
19.2.3	CTaskScheduler的设计	7
19.2.4	CTaskScheduler的代码实现	9
19.3	嵌套型动态任务调度	11
19.3.1	基本思想	11
19.3.2	CNestTaskScheduler的设计	11
19.3.3	CNestTaskScheduler的代码实现	13
19.3.4	CNestTaskScheduler使用方法	15
19.4	实例：用任务调度器实现parallel_for	15
19.5	参考文献	15
附录1	：Lock-Free编程基础	2
$1.1	Lock-Free编程基本概念和问题	2
$1.1.1	CAS原子操作	2
$1.1.2	ABA问题	3
$1.1.3	ABA问题的解决方法	5
$1.1.4	内存删除问题	6
$1.1.5	数据竞争问题	8
$1.2	Lock-Free的队列	8
$1.2.1	无锁队列的链式实现方法	8
$1.2.2	串行实现方法	10
$1.2.3	出队操作的Lock-Free实现	11
$1.2.4	进队操作的Lock-Free实现	13
$1.2.5	CLockFreeQueue的实现代码	14
$1.3	Lock-Free程序的问题分析	16
$1.4	参考文献	17
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>多核计算与程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>响应式架构
目录
第１章　Actor模型和企业级软件概述. ................................... 1
为什么企业级软件难以开发........1
响应式应用程序简介....................4
响应性 ....................................5
韧性 ...6
灵活性 ....................................6
消息驱动 ................................7
企业级应用程序............................8
Actor模型 ..9
Actor模型的起源 ................10
了解 Actor模型 ................... 11
Actor模型的明晰性 .....................20
下章提要.21
第２章　使用Scala语言和Akka框架实现Actor模型............. 22
怎样获取Scala语言和Akka框架 23
使用 Typesafe Activator编辑器 ..............................23
使用 sbt ................................23
使用 Maven ..........................24
使用 Gradle ..........................25
使用Scala语言编写程序 .............26
Scala概要教程 ....................27
使用Akka框架编写程序.............39
Actor系统 ............................40
实现 Actor对象 ...................46
监督 .52
远程处理 ..............................55
集群功能 ..............................68
测试 Actor对象 ...................94
CompletableApp类 .............98
小结.......100
第３章　性能情结. ........................ 101
晶体管...101
时钟频率....................................103
核心和高速缓存........................104
可伸缩性....................................106
多线程技术的难点....................109
Actor模型的作用 ....................... 114
处理伪共享 ........................ 116
设计模式.................................... 117
第４章　通过Actor对象传递消息. . 119
消息通道....................................120
消息.......121
管道和过滤器............................126
消息路由器................................131
消息译码器................................134
消息端点....................................135
小结.......137
第５章　消息通道. ........................ 138
点对点通道................................140
发布—订阅通道........................143
本地事件流 ........................143
分布式发布—订阅通道 ....149
数据类型通道............................157
非法消息通道............................159
死信通道....................................161
确保送达机制............................164
通道适配器................................172
消息桥...174
消息总线....................................180
小结.......189
第６章　消息结构. ........................ 190
命令消息....................................191
文档消息....................................192
管理处理流程和处理过程 194
事件消息....................................195
请求—回复模式........................197
返回地址....................................199
相关标识符................................203
消息序列....................................204
消息有效期................................206
格式标识符................................209
小结.......213
第７章　消息路由. ........................ 214
基于内容的路由器....................215
消息过滤器................................219
动态路由器................................223
接收者列表................................232
分离器...241
聚合器...245
重新定序器................................252
组合消息处理器........................259
分散—聚集路由器....................260
传送名单....................................274
处理过程管理器........................282
消息经纪人路由器....................298
小结.......301
第８章　消息转换. ........................ 302
封装器...303
内容丰富器................................305
不可变的 DoctorVisitCompleted消息...................309
是否应在本地系统中创建 AccountingEnricherDispatcher对象 ..............309
内容过滤器................................310
存放证...313
标准化器....................................321
规范化消息模型........................322
Actor系统需要标准 ..........323
小结.......324
第９章　消息端点. ........................ 325
消息传输网关............................326
消息传输映射............................332
事务型客户端/ Actor对象 .........339
事务型客户端 ....................341
事务型 Actor对象 .............342
轮询消费者................................350
资源轮询 ............................354
由事件驱动的消费者................358
具有竞争性的消费者................359
消息调度器................................361
选择性消费者............................364
持久订阅者................................367
幂等接收者................................370
避免处理消息副本 ............370
使消息具有相同的效果 ....371
使状态切换操作不受收到消息副本的影响 .........372
服务激活剂................................378
小结.......379
第10章　系统管理和基础结构...... 380
控制总线....................................380
改道器...382
窃听器...384
消息元数据/历史记录 ...............385
消息日志/存储器 .......................389
智能代理....................................392
测试消息....................................397
通道净化器................................399
小结.......401
附录A　.NET平台上的Akka工具集：Dotsero. ................... 402
Dotsero的Actor系统 ..................402
通过C#和.NET使用Actor对象 .405
Dotsero实现 ...............................410
小结.......413
参考资料.. 414
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>响应式架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Erlang趣学指南
第1章　启程 1
1．1　使用Erlang shell　1
1．1．1　输入shell命令　1
1．1．2　退出shell　2
1．2　Erlang基础知识　3
1．2．1　数值类型　3
1．2．2　不变的变量　4
1．2．3　原子　5
1．2．4　布尔代数和比较操作符　6
1．2．5　元组　8
1．2．6　列表　10
1．2．7　列表推导式　13
1．3　处理二进制数据　14
1．3．1　位语法　15
1．3．2　二进制数的按位操作　17
1．3．3　二进制字符串　18
1．3．4　二进制推导式　19
第2章　模块　20
2．1　什么是模块　20
2．2　创建模块　21
2．3　编译代码　23
2．4　定义宏　26
2．5　模块的其他内容　27
2．5．1　元数据　27
2．5．2　环形依赖　28
第3章　函数　29
3．1　模式匹配　29
3．1．1　模式进阶　31
3．1．2　绑定中的变量　31
3．2　卫语句　33
3．3　if表达式　34
3．4　case ．．． of表达式　37
3．5　如何选择　38
第4章　类型　39
4．1　动态强类型　39
4．2　类型转换　40
4．3　数据类型检测函数　41
4．4　致静态类型爱好者　43
第5章　递归　44
5．1　递归的工作原理　44
5．1．1　列表的长度　45
5．1．2　列表长度的尾递归实现　46
5．2　更多递归函数　47
5．2．1　duplicate函数　47
5．2．2　reverse函数　48
5．2．3　sublist函数　49
5．2．4　zip函数　50
5．2．5　快速排序　51
5．3　不仅仅是列表　53
5．4　递归思维　55
第6章　高阶函数　58
6．1　一切都是函数　58
6．2　匿名函数　60
6．2．1　匿名函数的其他用途　60
6．2．2　函数的作用域和闭包　61
6．3　映射、过滤器、折叠以及其他　63
6．3．1　过滤器　63
6．3．2　折叠一切　64
6．3．3　其他抽象　66
第7章　错误和异常　67
7．1　错误编译　67
7．1．1　编译期错误　67
7．1．2　逻辑错误　69
7．1．3　运行时错误　69
7．2　引发异常　71
7．2．1　出错异常　71
7．2．2　退出异常　72
7．2．3　抛出异常　73
7．3　处理异常　74
7．3．1　处理不同类型的异常　74
7．3．2　catch后的after语句　76
7．3．3　尝试多个表达式　76
7．3．4　更多选择　78
7．4　在树中使用try语句　80
第8章　用函数式思维解决问题　82
8．1　逆波兰式计算器　82
8．1．1　RPN计算器的工作原理　82
8．1．2　实现RPN计算器　84
8．1．3　代码测试　85
8．2　从希思罗到伦敦　87
8．2．1　递归地解决问题　87
8．2．2　编写代码　89
8．2．3　不使用Erlang shell运行程序　93
第9章　常用数据结构简介　95
9．1　记录　95
9．1．1　定义记录　95
9．1．2　读取记录字段值　97
9．1．3　更新记录　99
9．1．4　共享记录定义　99
9．2　键/值存储　100
9．2．1　小数据量存储　100
9．2．2　大数据量存储：字典和通用平衡树　101
9．3　集合　102
9．4　有向图　104
9．5　队列　104
9．6　小结　105
第10章　并发编程漫游指南　106
10．1　不必惊慌　106
10．2　并发概念　107
10．2．1　伸缩性　108
10．2．2　容错　108
10．2．3　并发实现　109
10．3　并非完全不能线性伸缩　110
10．4　再见，谢谢你的鱼　111
10．4．1　创建进程　112
10．4．2　发送消息　113
10．4．3　接收消息　114
第11章　深入多重处理　118
11．1　定义进程状态　118
11．2　隐藏消息实现　120
11．3　超时　121
11．4　选择性接收　123
11．4．1　选择性接收的风险　124
11．4．2　邮箱使用的其他风险　126
第12章　错误与进程　127
12．1　链接　127
12．1．1　捕获退出信号　129
12．1．2　老异常，新概念　130
12．2　监控器　133
12．3　命名进程　134
第13章　并发应用设计　139
13．1　理解问题　139
13．2　设计协议　141
13．3　目录结构　143
13．4　事件模块　143
13．4．1　事件和循环　144
13．4．2　增加接口　146
13．5　事件服务器　148
13．5．1　处理消息　149
13．5．2　代码热升级　152
13．5．3　隐藏消息细节　153
13．6　测试　155
13．7　增加监督功能　156
13．8　命名空间　157
第14章　OTP简介　158
14．1　提炼通用进程　158
14．2　基础服务器　159
14．2．1　kitty服务器　159
14．2．2　通用化同步调用　161
14．2．3　通用化服务器循环　162
14．2．4　启动函数　164
14．2．5　通用化kitty服务器　165
14．3　专用与通用　166
14．4　面向未来的回调　167
14．4．1　init函数　167
14．4．2　handle_call函数　168
14．4．3　handle_cast函数　169
14．4．4　handle_info函数　169
14．4．5　terminate函数　169
14．4．6　code_change函数　169
14．5　gen_server实践　170
第15章　令人愤怒的有限状态机　174
15．1　什么是有限状态机　174
15．2　通用有限状态机　178
15．2．1　init函数　178
15．2．2　StateName函数　178
15．2．3　handle_event函数　179
15．2．4　handle_syn_event函数　179
15．2．5　code_change和terminate函数　179
15．3　交易系统规格说明　179
15．3．1　操作定义　180
15．3．2　定义状态图和状态迁移　181
15．4　游戏交易　186
15．4．1　公共接口　186
15．4．2　FSM到FSM的函数　187
15．4．3　gen_fsm回调函数　189
15．5　为自己骄傲　196
15．6　适用于真实世界吗　197
第16章　事件处理器　198
16．1　处理它！*泵式散弹枪*　198
16．2　通用事件处理器　199
16．2．1　init和terminate函数　200
16．2．2　handle_event函数　200
16．2．3　handle_call函数　201
16．2．4　handle_info函数　201
16．2．5　code_change函数　201
16．3　现在是冰壶比赛时间　201
16．3．1　记分牌　202
16．3．2　比赛事件　203
16．3．3　通知新闻界　206
第17章　谁来监督监督者　211
17．1　监督者中的概念　211
17．2　使用监督者　213
17．2．1　重启策略　213
17．2．2　重启限制　215
17．2．3　子进程规格说明　215
17．3　乐队排练　217
17．3．1　音乐人　217
17．3．2　乐队监督者　220
17．4　动态监督　223
17．4．1　动态使用标准监督者　223
17．4．2　使用simple_one_for_one监督者　224
第18章　构建应用　226
18．1　进程池　226
18．1．1　洋葱理论　227
18．1．2　进程池监督树　228
18．2　实现监督者　230
18．3　进程池服务器　233
18．4　实现工作者　239
18．5　运行进程池　240
18．6　小结　242
第19章　构建OTP应用　243
19．1　我还有辆车是一个游泳池　243
19．2　应用资源文件　244
19．3　把ppool转换成OTP应用　246
19．4　application行为　247
19．5　从混乱到应用　249
19．6　库应用　251
第20章　深入OTP应用　253
20．1　从OTP应用到真实的应用　253
20．1．1　应用文件　254
20．1．2　应用回调模块和监督者　255
20．1．3　分派器　256
20．1．4　计数模块　264
20．2　运行应用　265
20．3　包含应用　267
20．4　复杂的终止　267
第21章　发布　268
21．1　修理漏水的管道　268
21．1．1　终止VM　268
21．1．2　更新应用文件　269
21．1．3　编译应用　270
21．2　使用systools构建发布　270
21．2．1　创建启动文件　271
21．2．2　发布打包　272
21．3　使用Reltool构建发布　273
21．4　Reltool技巧集　279
21．5　基于release文件发布　282
第22章　升级Process Quest　283
22．1　升级面临的问题　283
22．2　Erlang学习的第9级　285
22．3　Process Quest　286
22．3．1　regis-1．0．0应用　287
22．3．2　processquest-1．0．0 应用　287
22．3．3　sockserv-1．0．0应用　288
22．3．4　发布　289
22．4　改进Process Quest　291
22．4．1　更改code_change函数　291
22．4．2　增加appup文件　293
22．4．3　发布升级　296
22．5　Relup回顾　299
第23章　套接字编程　301
23．1　IO列表　301
23．2　UDP和TCP：伙伴协议　302
23．2．1　UDP套接字　303
23．2．2　TCP套接字　306
23．3　使用Inet进行更多的控制　308
23．4　重新审视sockserv　310
23．5　下一步的工作　319
第24章　EUnit：单元测试框架　320
24．1　什么是EUnit　320
24．2　测试生成器　324
24．3　测试夹具　326
24．3．1　其他测试控制方法　328
24．3．2　测试文档　329
24．4　测试regis　329
24．5　EUnit小结　338
第25章　ETS：免费的内存NoSQL数据库　339
25．1　为什么需要ETS　339
25．2　ETS的概念　340
25．3　ETS的基本操作　342
25．3．1　表的创建和删除　342
25．3．2　数据的插入和查询　343
25．4　匹配操作　345
25．5　选择操作　347
25．6　DETS　351
25．7　少说一点，多做一点　351
25．7．1　接口　352
25．7．2　实现细节　352
第26章　分布式编程　357
26．1　这是我的火枪　358
26．2　分布式计算中的谬误　359
26．2．1　网络是可靠的　360
26．2．2　网络没有延迟　360
26．2．3　带宽是无限的　361
26．2．4　网络是安全的　361
26．2．5　网络拓扑不会变化　362
26．2．6　只有一个管理员　363
26．2．7　传输成本是零　363
26．2．8　网络是同质的　363
26．2．9　谬误小结　364
26．3　死亡还是失去联系　364
26．4　CAP定理　365
26．4．1　一致性　366
26．4．2　可用性　366
26．4．3　分区容忍　366
26．4．4　僵尸幸存者和CAP　367
26．5　搭建Erlang集群　369
26．5．1　节点命名　369
26．5．2　连接节点　370
26．5．3　更多工具　371
26．6　cookie　373
26．7　远程shell　374
26．8　隐藏节点　375
26．9　防火墙问题　376
26．10　高级调用　376
26．10．1　net_kernel模块　376
26．10．2　global模块　377
26．10．3　rpc模块　378
26．11　小结　380
第27章　分布式OTP应用　381
27．1　更多OTP内容　381
27．2　接管和故障切换　382
27．3　神奇8号球　383
27．3．1　构建应用　384
27．3．2　变身分布式应用　387
第28章　不寻常的Common Test　391
28．1　什么是Common Test　391
28．2　Common Test的组织结构　392
28．3　创建一个简单的测试套件　393
28．4　带状态的测试　396
28．5　测试组　397
28．5．1　定义测试组　398
28．5．2　测试组属性　399
28．5．3　会议室　400
28．6　再谈测试套件　404
28．7　测试规格说明　404
28．7．1　规格说明文件内容　405
28．7．2　创建规格说明文件　406
28．7．3　通过规格说明文件运行测试　407
28．8　大规模测试　407
28．8．1　创建分布式测试规格说明文件　409
28．8．2　运行分布式测试　410
28．9　集成Common Test和EUint　411
28．10　还有其他内容吗　411
第29章　Mnesia—记忆的艺术　412
29．1　Mnesia是什么　412
29．2　应该存储什么呢　413
29．2．1　需要存储的数据　413
29．2．2　表结构　414
29．3　从记录到表　415
29．4　Mnesia数据模式和表　416
29．5　创建表　418
29．5．1　安装数据库　418
29．5．2　启动应用　421
29．6　数据表存取上下文　422
29．7　读、写以及其他操作　423
29．8　实现第一个请求　424
29．8．1　测试增加服务　424
29．8．2　测试查询　427
29．8．3　账目和新的需求　430
29．9　满足老板　432
29．10　删除操作示例　434
29．11　列表推导式查询　437
29．12　记住Mnesia　438
第30章　类型规格说明与Dialyzer　439
30．1　PLT是最好的三明治　439
30．2　成功类型化　440
30．3　类型推导和错误　442
30．4　类型的种类　445
30．4．1　单例类型　445
30．4．2　联合类型和内置类型　445
30．4．3　定义类型　448
30．4．4　记录类型　449
30．5　为函数增加类型声明　450
30．6　类型定义实践　453
30．7　类型导出　457
30．8　OTP行为类型　459
30．9　多态类型　460
30．9．1　我们买了一个动物园　460
30．9．2　注意事项　462
30．10　Dialyzer，我的好朋友　463
30．11　朋友们，就这么多　463
后记　464
附录　Erlang语法　467
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Erlang趣学指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 企业设计模式
目录:
第1章 软件模式介绍 1
第2章 UML概述 5
第3章 软件生命周期 24
第4章 事务处理模式 26
第5章 分布式体系结构模式 59
第6章 分布式计算模式 96
第7章 并发模式 228
第8章 时间模式 289
第9章 数据库模式 329
附录A 持久框架 375
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 企业设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java线程
前言
第一章 线程简介
java术语
线程概述
为什么要使用线程？
总结
第二章 java线程api
通过thread类创建线程
使用runable接口的线程
线程的生命周期
线程命名
访问线程
线程的启动、停止和连接
总结
第三章 同步技术
银行的例子
异步读取数据
.一个进行同步操作的类
同步块
嵌套锁
死锁
返回到银行的例子
同步静态方法
总结
第四章 等待和通知
返回到银行的例子
等待和通知
wait（）、notify（）和notifyall（）
wait（）和sleep（）
线程中断
静态方法（有关同步的细节）
总结
第五章 java线程编程的例子
数据结构和容器
简单的同步例子
一个网络服务器类
asyncinputstream类
使用tcpserver和asynclnputstream
总结
第六章 java线程调度
线程调度概述
何时调度是重要的
调度和线程优先级
常见的调度实现
本地调度支持
其他线程调度方法
总结
第七章 java线程调度例子
线程池
循环调度
作业调度
总结
第八章 和同步相关的高级主题
同步术语
预防死锁
锁饥饿
非线程安全的类
总结
第九章 多处理器机器上的并行化
单线程程序并行化
内层循环线程化
循环输出
多处理器扩展
总结
第十章 线程组
线程组概念
创建线程组
线程组方法
操作线程组
线程组、线程和安全
总结
附录一 其他主题
附录二 异常和错误
词汇表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java线程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式实时处理系统：原理、架构与实现
目录
本书赞誉
序一
序二
序三
前言
第1章　分布式计算概述 1
1.1　分布式概念 1
1.2　分布式计算及其原理 2
1.3　分布式系统特性 3
1.3.1　容错性 3
1.3.2　高可扩展性 4
1.3.3　开放性 5
1.3.4　并发处理能力 5
1.3.5　透明性 6
1.4　通用分布式计算系统 6
1.4.1　Apache Hadoop 6
1.4.2　Apache Spark 8
1.4.3　Apache Storm 9
1.5　分布式存储系统 10
1.5.1　分布式存储概念 10
1.5.2　分布式存储系统特点 12
1.5.3　分布式存储系统分类 12
1.5.4　常见分布式存储系统 13
1.6　本章小结 14
第2章　分布式系统通信基础 15
2.1　时代的浪潮 15
2.1.1　集中式通信网 16
2.1.2　去中心化 16
2.2　可靠的数据链路 17
2.2.1　数据分组 17
2.2.2　帧同步 18
2.2.3　差错控制 18
2.2.4　链路管理 18
2.2.5　问题与解决方案 19
2.3　分层架构 19
2.4　网络层 22
2.4.1　寻找路径 22
2.4.2　网络分层 23
2.4.3　TCP/IP概述 23
2.4.4　IP协议 24
2.5　传输层 30
2.5.1　数据自动分包 30
2.5.2　端到端的传输 30
2.5.3　数据的可靠传输 30
2.6　应用层 35
2.6.1　ping 35
2.6.2　telnet 36
2.6.3　OSPF 36
2.6.4　DNS 36
2.6.5　HTTP协议 37
2.7　基于消息协议的公告牌 38
2.7.1　需求描述 38
2.7.2　制定协议 38
2.8　分布式通信举例——MapReduce 39
2.9　本章小结 41
第3章　通信系统高层抽象 42
3.1　RPC介绍 42
3.2　RESTful 44
3.2.1　资源和表现层 45
3.2.2　状态转移 45
3.2.3　RESTful总结 46
3.3　消息队列 46
3.4　序列化 49
3.5　使用Thrift实现公告牌服务 50
3.5.1　Apache Thrift介绍 51
3.5.2　安装Apache Thrift 51
3.5.3　编写Thrift文件 52
3.5.4　实现服务器 53
3.5.5　实现客户端 54
3.6　本章小结 56
第4章　走进C++高性能编程 57
4.1　基于C++的留言板系统 58
4.1.1　基于Socket的通信 58
4.1.2　C++中的内存与资源管理 64
4.2　来自服务器的天书 69
4.2.1　编码 69
4.2.2　C++98的编码缺陷 72
4.2.3　C++11编码支持 73
4.3　繁忙的服务器 75
4.3.1　分身乏术 75
4.3.2　fork——分身术 76
4.3.3　进程间通信 79
4.3.4　轻量级分身——线程 85
4.3.5　C++11线程 86
4.3.6　竞争问题与解决方案 88
4.3.7　多线程优化 95
4.3.8　异步I/O 99
4.4　消失不见的内存 105
4.4.1　内存分配与内存碎片 106
4.4.2　tcmalloc 108
4.4.3　内存池 110
4.5　本章小结 112
第5章　分布式实时处理系统 113
5.1　Hadoop与MapReduce 113
5.1.1　HDFS 114
5.1.2　MapReduce模型 115
5.2　Storm实时处理系统 129
5.2.1　历史 129
5.2.2　计算模型 130
5.2.3　总体架构 133
5.2.4　Storm元数据 133
5.2.5　Storm与Hadoop比较 138
5.3　有保证的消息处理 139
5.3.1　完全处理与元组树 139
5.3.2　元组的唯一标识 139
5.3.3　确认和失败 141
5.3.4　高效实现 143
5.4　本章小结 144
第6章　实时处理系统编程接口设计 145
6.1　总体架构设计 145
6.1.1　Hurricane与Storm比较 145
6.1.2　总体架构 146
6.1.3　任务接口 148
6.2　消息源接口设计 149
6.3　消息处理器接口设计 150
6.4　数据收集器设计 151
6.5　元组接口设计 154
6.6　序列化接口设计 160
6.7　本章小结 161
第7章　服务组件设计与实现 162
7.1　Executor设计与实现 162
7.1.1　事件驱动的消息队列 162
7.1.2　动态装载技术 167
7.1.3　Executor实现 169
7.2　Task设计与实现 171
7.3　本章小结 172
第8章　管理服务设计与实现 173
8.1　President功能与设计 173
8.2　President实现 174
8.2.1　简单的网络通信实现 175
8.2.2　Topology装载实现 182
8.2.3　Manager管理调度实现 184
8.2.4　序列化实现 193
8.3　本章小结 198
第9章　实时处理系统编程接口实现 199
9.1　消息源接口实现 200
9.1.1　消息源执行器 200
9.1.2　WordCount实现实例 205
9.2　消息处理单元接口实现 207
9.2.1　消息处理单元执行器 207
9.2.2　事件处理 212
9.2.3　WordCount实现实例 215
9.3　数据收集器实现 218
9.3.1　分发策略 218
9.3.2　传输层实现 224
9.4　本章小结 226
第10章　可靠消息处理 227
10.1　基本概念 227
10.1.1　完全处理 227
10.1.2　失败与重发 229
10.2　接口设计 229
10.3　具体实现 233
10.3.1　简单实现 233
10.3.2　高效实现 235
10.4　本章小结 237
第11章　通信系统设计与实现 238
11.1　I/O多路复用方案解析 239
11.1.1　基本网络编程接口 239
11.1.2　非阻塞的服务器程序 241
11.1.3　使用select()接口的基于事件驱动的服务器模型 242
11.1.4　使用epoll实现异步事件通知模型 245
11.2　基础工具 249
11.2.1　线程工具 250
11.2.2　日志工具 254
11.3　传输层实现 263
11.3.1　Reactor模式 263
11.3.2　定义抽象TP传输层 264
11.3.3　实现基于epoll的TP传输层 269
11.3.4　实现基于IOCP的TP传输层 290
11.4　应用层HTTP实现 307
11.4.1　HttpContext 307
11.4.2　HttpRequest 311
11.4.3　HttpResponse 313
11.4.4　HttpConnection 315
11.4.5　HttpServer 317
11.4.6　总结 319
11.5　跨平台分割编译 320
11.5.1　Makefile 320
11.5.2　Kake 323
11.6　与实时处理系统集成 325
11.6.1　修改NetListener 325
11.6.2　修改NetConnector 327
11.7　本章小结 330
第12章　事务性Topology实现 331
12.1　Exact-once语义解决方案 331
12.2　设计细节 333
12.2.1　构造事务性Topology 333
12.2.2　消息处理单元 334
12.3　事务性Topology API 337
12.3.1　消息处理单元 337
12.3.2　事务性消息源 339
12.4　本章小结 339
第13章　多语言接口 340
13.1　C语言通用接口 340
13.1.1　元组接口 342
13.1.2　消息源接口 346
13.1.3　消息处理单元接口 349
13.1.4　计算拓扑接口 352
13.2　Python接口 354
13.2.1　ctypes 354
13.2.2　元组接口 356
13.2.3　消息源接口 359
13.2.4　消息处理单元接口 360
13.2.5　计算拓扑接口 361
13.2.6　应用示例 364
13.3　JavaScript接口 365
13.3.1　V8引擎 366
13.3.2　Node.js 366
13.3.3　V8的互操作接口 367
13.3.4　任务接口 368
13.3.5　消息源接口 369
13.3.6　消息处理单元接口 370
13.3.7　计算拓扑接口 371
13.3.8　应用示例 373
13.4　Java接口 375
13.4.1　任务接口 375
13.4.2　消息源接口 376
13.4.3　消息处理单元接口 377
13.4.4　计算拓扑接口 377
13.4.5　本地代码 380
13.4.6　应用示例 382
13.5　Swift接口 384
13.5.1　应用范围 385
13.5.2　任务接口 385
13.5.3　消息源接口 386
13.5.4　消息处理单元接口 387
13.5.5　计算拓扑接口 388
13.6　本章小结 390
第14章　Squared设计与实现——实现高级抽象元语 391
14.1　Storm Trident介绍 391
14.1.1　Squared示例 391
14.1.2　DRPC示例 394
14.2　Squared实现 396
14.2.1　SquaredTopology和Spout 396
14.2.2　SquaredBolt 401
14.2.3　Stream 405
14.2.4　状态存储 410
14.2.5　DRPC实现 412
14.2.6　操作与处理节点 416
14.2.7　流操作 419
14.3　本章小结 423
第15章　实战：日志流处理 425
15.1　日志流处理设计方案 425
15.2　实现Topology 427
15.2.1　编写消息源 427
15.2.2　编写索引消息处理单元 428
15.2.3　编写统计消息处理单元 429
15.3　本章小结 431
第16章　实战：频繁组合查找 432
16.1　背景介绍 432
16.1.1　数据挖掘概念 432
16.1.2　关联规则和频繁项集 433
16.1.3　啤酒与尿布 435
16.2　频繁二项集挖掘方法 435
16.2.1　频繁二项集 435
16.2.2　算法设计思路 438
16.2.3　Hurricane实现思路 439
16.3　编写Spout 439
16.4　编写Bolt 441
16.4.1　SplitBolt 441
16.4.2　PairCountBolt 442
16.4.3　PairTotalCountBolt 443
16.4.4　ConfidenceComputeBolt 444
16.4.5　SupportComputeBolt 445
16.4.6　FilterBolt 447
16.5　编写Topology 448
16.6　本章小结 449
第17章　实战：在AWS和阿里云上部署Hurricane实时处理系统 450
17.1　AWS部署 450
17.1.1　搭建虚拟私有云 452
17.1.2　配置安全组 455
17.1.3　加载EC2实例 456
17.1.4　弹性IP地址管理 461
17.2　阿里云部署 464
17.2.1　创建虚拟私有云 464
17.2.2　管理安全组 467
17.2.3　创建ECS 468
17.2.4　SSH登录 471
17.3　Hurricane分布式部署与管理 471
17.3.1　分布式部署原理 472
17.3.2　分布式安装配置 472
17.3.3　分布式启动 476
17.4　部署分布式实时处理系统 477
17.5　未来之路 478
17.6　本章小结 479
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式实时处理系统：原理、架构与实现
