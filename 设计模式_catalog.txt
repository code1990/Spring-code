>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式
序言
前言
读者指南
第1章 引言
第2章 实例研究：设计一个文档编辑器
第3章 创建型模式
第4章 结构型模式
第5章 行为模式
第6章 结论
附录A 词汇表
附录B 图示符号指南
附录C 基本类
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Head First 设计模式（中文版）
引子
谁适合读这本书?
我们知道你的大脑在想什么
元认知
让你的大脑就范
技术审校
致谢
1　欢迎来到设计模式世界：设计模式入门
模拟鸭子应用
Joe想到继承
利用接口如何？
软件开发的不变真理
分开变化和不变部分
设计鸭子的行为
测试鸭子的代码
动态地设置行为
封装行为的大局观
“有一个”比“是一个”更好
策略模式
共享模式词汇的威力
我如何使用设计模式？
设计箱内的工具
习题解答
2　让你的对象知悉现况
气象观测站
认识观察者模式
出版者＋订阅者＝观罕者模式
五分钟短剧：观察主题
定义观察者模式
松耦合的威力
设计气象站
实现气象站
使用Java内建的观察者模式
java.util.Observable的黑暗面
设计箱内的工具
习题解答
……
3　装饰者模式：装饰对象
4　工厂模式：烘烤OO的精华
5　单件模式：独一无二的对象
6　命令模式：封装调用
7　适配器模式与外观模式：随遇而安
8　模板方法模式：封装算法
9　送代器与组合模式：管理良好的集合
10　状态模式：事物的状态
11　代理模式：控制对象访问
12　复合模式：模式中的模式
13　与设计模式相处：真实世界中的模式
A　附录A：剩下的模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Head First 设计模式（中文版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大话设计模式
第1章 代码无错就是优？——简单工厂模式 1
1.1 面试受挫 1
1.2 初学者代码毛病 2
1.3 代码规范 2
1.4 面向对象编程 4
1.5 活字印刷，面向对象 4
1.6 面向对象的好处 5
1.7 复制vs.复用 6
1.8 业务的封装 6
1.9 紧耦合vs.松耦合 8
1.10 简单工厂模式 10
1.11 UML类图 12
第2章 商场促销——策略模式 17
2.1 商场收银软件 17
2.2 增加打折 18
2.3 简单工厂实现 19
2.4 策略模式 22
2.5 策略模式实现 25
2.6 策略与简单工厂结合 27
2.7 策略模式解析 28
第3章 拍摄UFO——单一职责原则 30
3.1 新手机 30
3.2 拍摄 30
3.3 没用的东西 31
3.4 单一职责原则 31
3.5 方块游戏的设计 31
3.6 手机职责过多吗？ 33
第4章 考研求职两不误——开放-封闭原则 34
4.1 考研失败 34
4.2 开放-封闭原则 35
4.3 何时应对变化 36
4.4 两手准备，并全力以赴 37
第5章 会修电脑不会修收音机？——依赖倒转原则 38
5.1 MM请求修电脑 38
5.2 电话遥控修电脑 39
5.3 依赖倒转原则 40
5.4 里氏代换原则 41
5.5 修收音机 43
第6章 穿什么有这么重要？——装饰模式 44
6.1 穿什么有这么重要？ 44
6.2 小菜扮靓第一版 45
6.3 小菜扮靓第二版 47
6.4 装饰模式 50
6.5 小菜扮靓第三版 53
6.6 装饰模式总结 56
第7章 为别人做嫁衣——代理模式 57
7.1 为别人做嫁衣！ 57
7.2 没有代理的代码 58
7.3 只有代理的代码 60
7.4 符合实际的代码 61
7.5 代理模式 63
7.6 代理模式应用 65
7.7 秀才让小六代其求婚 66
第8章 雷锋依然在人间——工厂方法模式 67
8.1 再现活雷锋 67
8.2 简单工厂模式实现 68
8.3 工厂方法模式实现 69
8.4 简单工厂vs.工厂方法 71
8.5 雷锋工厂 72
第9章 简历复印——原型模式 77
9.1 夸张的简历 77
9.2 简历代码初步实现 78
9.3 原型模式 80
9.4 简历的原型实现 82
9.5 浅复制与深复制 84
9.6 简历的深复制实现 87
9.7 复制简历vs.手写求职信 89
第10章 考题抄错会做也白搭——模板方法模式 90
10.1 选择题不会做，蒙呗！ 90
10.2 重复=易错+难改 91
10.3 提炼代码 93
10.4 模板方法模式 96
10.5 模板方法模式特点 98
10.6 主观题，看你怎么蒙 98
第11章 无熟人难办事？——迪米特法则 100
11.1 第一天上班 100
11.2 无熟人难办事 100
11.3 迪米特法则 102
第12章 牛市股票还会亏钱？——外观模式 103
12.1 牛市股票还会亏钱？ 103
12.2 股民炒股代码 104
12.3 投资基金代码 106
12.4 外观模式 108
12.5 何时使用外观模式 110
第13章 好菜每回味不同——建造者模式 112
13.1 炒面没放盐 112
13.2 建造小人一 113
13.3 建造小人二 114
13.4 建造者模式 115
13.5 建造者模式解析 118
13.6 建造者模式基本代码 119
第14章 老板回来，我不知道——观察者模式 123
14.1 老板回来？我不知道！ 123
14.2 双向耦合的代码 124
14.3 解耦实践一 126
14.4 解耦实践二 128
14.5 观察者模式 131
14.6 观察者模式特点 134
14.7 观察者模式的不足 135
14.8 事件委托实现 136
14.9 事件委托说明 139
14.10 石守吉失手机后的委托 140
第15章 就不能不换DB吗？——抽象工厂模式 141
15.1 就不能不换DB吗？ 141
15.2 最基本的数据访问程序 142
15.3 用了工厂方法模式的数据访问程序 143
15.4 用了抽象工厂模式的数据访问程序 146
15.5 抽象工厂模式 149
15.6 抽象工厂模式的优点与缺点 151
15.7 用简单工厂来改进抽象工厂 151
15.8 用反射+抽象工厂的数据访问程序 154
15.9 用反射+配置文件实现数据访问程序 157
15.10 无痴迷，不成功 157
第16章 无尽加班何时休——状态模式 158
16.1 加班，又是加班！ 158
16.2 工作状态-函数版 159
16.3 工作状态-分类版 160
16.4 方法过长是坏味道 162
16.5 状态模式 163
16.6 状态模式好处与用处 165
16.7 工作状态-状态模式版 166
第17章 在NBA我需要翻译——适配器模式 171
17.1 在NBA我需要翻译！ 171
17.2 适配器模式 171
17.3 何时使用适配器模式 174
17.4 篮球翻译适配器 174
17.5 适配器模式的.NET应用 178
17.6 扁鹊的医术 178
第18章 如果再回到从前——备忘录模式 180
18.1 如果再给我一次机会…… 180
18.2 游戏存进度 180
18.3 备忘录模式 183
18.4 备忘录模式基本代码 184
18.5 游戏进度备忘 186
第19章 分公司=一部门——组合模式 189
19.1 分公司不就是一部门吗？ 189
19.2 组合模式 190
19.3 透明方式与安全方式 193
19.4 何时使用组合模式 194
19.5 公司管理系统 194
19.6 组合模式好处 198
第20章 想走？可以！先买票——迭代器模式 200
20.1 乘车买票，不管你是谁！ 200
20.2 迭代器模式 201
20.3 迭代器实现 202
20.4 .NET的迭代器实现 206
20.5 迭代高手 208
第21章 有些类也需计划生育——单例模式 209
21.1 类也需要计划生育 209
21.2 判断对象是否是null 210
21.3 生还是不生是自己的责任 213
21.4 单例模式 214
21.5 多线程时的单例 216
21.6 双重锁定 217
21.7 静态初始化 218
第22章 手机软件何时统一——桥接模式 220
22.1 凭什么你的游戏我不能玩 220
22.2 紧耦合的程序演化 221
22.3 合成/聚合复用原则 225
22.4 松耦合的程序 226
22.5 桥接模式 229
22.6 桥接模式基本代码 231
22.7 我要开发“好”游戏 233
第23章 烤羊肉串引来的思考——命令模式 234
23.1 吃烤羊肉串！ 234
23.2 烧烤摊vs.烧烤店 235
23.3 紧耦合设计 236
23.4 松耦合设计 237
23.5 松耦合后 240
23.6 命令模式 242
23.7 命令模式作用 244
第24章 加薪非要老总批？——职责链模式 245
24.1 老板，我要加薪！ 245
24.2 加薪代码初步 246
24.3 职责链模式 249
24.4 职责链的好处 251
24.5 加薪代码重构 252
24.6 加薪成功 256
第25章 世界需要和平——中介者模式 257
25.1 世界需要和平！ 257
25.2 中介者模式 258
25.3 安理会做中介 262
25.4 中介者模式优缺点 265
第26章 项目多也别傻做——享元模式 267
26.1 项目多也别傻做！ 267
26.2 享元模式 269
26.3 网站共享代码 272
26.4 内部状态与外部状态 274
26.5 享元模式应用 277
第27章 其实你不懂老板的心——解释器模式 279
27.1 其实你不懂老板的心 279
27.2 解释器模式 280
27.3 解释器模式好处 282
27.4 音乐解释器 283
27.5 音乐解释器实现 284
27.6 料事如神 289
第28章 男人和女人——访问者模式 291
28.1 男人和女人！ 291
28.2 最简单的编程实现 292
28.3 简单的面向对象实现 293
28.4 用了模式的实现 295
28.5 访问者模式 300
28.6 访问者模式基本代码 301
28.7 比上不足，比下有余 304
第29章 OOTV杯超级模式大赛——模式总结 305
29.1 演讲任务 305
29.2 报名参赛 305
29.3 超模大赛开幕式 306
29.4 创建型模式比赛 309
29.5 结构型模式比赛 314
29.6 行为型模式一组比赛 321
29.7 行为型模式二组比赛 325
29.8 决赛 330
29.9 梦醒时分 333
29.10 没有结束的结尾 334
附 录 A 培训实习生——面向对象基础 335
A.1 培训实习生 335
A.2 类与实例 335
A.3 构造方法 337
A.4 方法重载 338
A.5 属性与修饰符 340
A.6 封装 342
A.7 继承 343
A.8 多态 347
A.9 重构 350
A.10 抽象类 353
A.11 接口 354
A.12 集合 358
A.13 泛型 360
A.14 委托与事件 362
A.15 客套 366
附 录 B 参考文献 367
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大话设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>网站交互设计模式
第1部分 web网站设计基础.
第1章 以用户为中心的web设计：不只是一个好主意
1．1 web设计的发展史
1．1．1 第一代
1．1．2 第二代
1．1．3 第三代
1．1．4 第四代
1．2 “以用户为中心”设计的重要性
1．3 统一设计、可用性和市场的第1步
1．4 为什么我们倾向于以用户为中心的设计
1．4．1 以使用者为中心的设计
1．4．2 以公司为中心的设计
1．4．3 以技术为中心的设计
1．4．4 以设计者为中心的设计
1．4．5 以用户为中心的设计的优势
1．5 9种关于以用户为中心的荒谬说法
1．5．1 谬误1：好的设计很普通
1．5．2 谬误2：只有专家才能进行好的设计
1．5．3 谬误3：web界面能够在发布前被重新设计
1．5．4 谬误4：好的设计会花费太长的时间，成本也太高
.1．5．5 谬误5：好的设计只是一些美观的图形
1．5．6 谬误6：web界面的指南会帮助您完成好的设计
1．5．7 谬误7：用户总可以依赖文档和帮助信息
1．5．8 谬误8：市场研究会揭示所有用户的需求
1．5．9 谬误9：质量保证小组会确认网站是否工作良好
1．6 实施以客户为中心的设计
1．6．1 原则
1．6．2 过程
1．6．3 模式
1．6．4 使用原则、过程和模式
1．7 小结
第2章 web设计模式
2．1 什么是模式
2．2 一个模式的例子
2．3 如何阅读模式
2．4 随着时间的流逝，模式会如何变化
2．5 如何使用模式
2．6 一个使用模式的例子
2．7 小结
第3章 了解用户：规则和技术
3．1 了解用户的有关规则
3．1．1 自己并不是用户
3．1．2 理解组成单元，平衡影响力
3．1．3 理解用户
3．1．4 用户是不同的
3．1．5 用户又是一样的
3．1．6 理解用户的业务
3．1．7 减少工作
3．1．8 业务培训
3．1．9 帮助人们成为专家
3．1．10 理解技术
3．1．11 理解用户的社会问题
3．2 用于了解用户的技术
3．2．1 开始业务分析
3．2．2 构建应用场景
3．2．3 选择业务
3．2．4 对用户的观察和面谈
3．2．5 用户调查
3．2．6 运用焦点组
3．2．7 分析已经存在的网站
3．3 小结
第4章 与用户一起做迭代设计
4．1 迭代设计过程
4．2 采用迭代设计的原因
4．2．1 在错误还很容易修正并且开销很小时修正它们
4．2．2 构建正确的网站和正确地构建网站
4．3 有目标和原则的设计
4．3．1 设定可度量的设计目标
4．3．2 坚持设计原则
4．3．3 信息结构、导航设计和图形设计
4．4 快速原型
4．4．1 网站地图、故事板和图表
4．4．2 真实度从低到高的渐进式的提炼
4．4．3 横向和纵向原型
4．4．4 原型的局限
4．5 评估网站
4．5．1 专家评审
4．5．2 非正式评估
4．5．3 正式可用性评估
4．5．4 选择一种评估技术
4．6 小结
第5章 开发以用户为中心网站的过程
5．1 开发过程概览
5．2 发现阶段
5．2．1 发现过程
5．2．2 发现过程的交付物
5．3 探索阶段
5．3．1 探索过程
5．3．2 探索过程的交付物
5．4 精练阶段
5．4．1 精练过程
5．4．2 精练过程交付物
5．5 制作阶段
5．5．1 制作过程
5．5．2 制作阶段交付物
5．6 实现阶段
5．6．1 实现过程
5．6．2 实现阶段交付物
5．7 执行阶段
5．8 维护阶段
5．8．1 维护过程
5．8．2 维护阶段交付物
5．9 小结
第2部分 模式
模式组a 网站风格
网站风格a
a1 个人电子商务
a2 新闻马赛克
a3 社区会议
a4 自我服务的政府
a5 提供帮助的非营利性网络
a6 大众信息站点
a7 有价值的公司网站
a8 教育论坛
a9 有刺激性的艺术和娱乐内容
a10 web应用程序
a11 内部网
a12 博客..
模式组b 创建导航框架
b1 导航的不同方法
b2 可分类浏览的内容
b3 层次化结构
b4 基于任务的组织结构
b5 字母顺序的组织结构
b6 时间顺序的组织结构
b7 基于流行度的组织结构
b8 目录页
b9 站点可达性
模式组c 建立一个强有力的主页
c1 主页入口
c2 提前价值定位
模式组d 制作和管理内容
d1 页面模板
d2 内容模块
d3 标题和简介
d4 个性化内容
d5 留言簿
d6 制作符合搜索引擎要术的网站
d7 倒金字塔编写方式
d8 可打印的页面
d9 与众不同的html标题
d10 国际化和本地化内容
d11 样式表
模式组e 建立信任和信誉
e1 网站商标
e2 e-mail订阅
e3 公平信息处理条例
e4 隐私政策
e5 关于我们
e6 安全连接
e7 e-mail提示
e8 稳私偏好
e9 防止诈骗
模式组f 基本电子商务
f1 快速结账
f2 清晰的产品详细资料
f3 购物车
f4 快速选址
f5 选择快速运输方式
f6 付款方式
f7 订单概要
f8 订单确认和感谢
f9 轻松退货
模式组g 高级电子商务
g1 特色产品
g2 交叉销售和提升销售
g3 个人推荐
g4 推荐社团
g5 多重目的地
g6 礼品赠与
g7 订单跟踪和历史
模式组h 帮助用户完成任务
h1 过程漏斗
h2 登录/新用户
h3 客人账户
h4 账户管理
h5 持久的用户会话
h6 浮动窗口
h7 常见问题
h8 上下文帮助
h9 直接操作
h10 明文形式
h11 预言性的输入
h12 向下钻取选项
h13 进度条
模式组i 设计让人印象深刻的页面布局
i1 表格式布局
i2 折线之上
i3 清晰的第一印象
i4 扩大屏幕宽度
i5 固定的屏幕宽度
i6 相关内容的一致侧边栏
模式组j 加速网站并恰当地搜索
j1 搜索动作模块
j2 直接搜索形式
j3 有组织的搜索结果
模式组k 轻松导航
k1 统一的浏览层次
k2 导航栏
k3 标签行
k4 动作按钮
k5 高可见动作按钮
k6 位置面包屑
k7 嵌入式链接
k8 外部链接
k9 描述性的长链接名
k10 显著的链接
k11 熟悉的语言
k12 预防错误
k13 有意义的错误消息
k14 页面没有找到
k15 永久链接
k16 跳跃菜单
k17 网站地图
模式组l 加速网站
l1 少量的文件
l2 快速加载的图片
l3 独立的表格
l4 html power
l5 可重用的图片
l6 快速加载的内容
模式组m 移动网站
m1 手机屏幕尺寸
m2 手机输入控制
m3 定位服务
第3部分 附录
附录a 运行可行性测试
a．1 设定目标
a．2 提出任务
a．3 招募参与者
a．4 测试
a．5 分析数据
a．6 呈现结果
附录b 网站评估方案示例
b．1 角色
b．2 介绍
b．3 任务
b．4 听取报告
附录c 样品知情同意书
附录d 样品观察者表格
附录e 在线研究
e．1 开始：定义研究目标
e．2 分阶段研究
e．3 研究类型
e．4 测试
e．5 分析数据
e．6 研究方法的比较
e．7 小结
附录f 术语表
附录g 资源
第1部分 web网站设计基础
第2部分 模式
第3部分 附录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>网站交互设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaScript设计模式与开发实践
第一部分　基础知识
第1章　面向对象的JavaScript
1.1 动态类型语言和鸭子类型　　2
1.2 多态　　4
1.3 封装　　12
1.4 原型模式和基于原型继承的JavaScript对象系统　　14
第2章　this、call和apply
2.1 this　　24
2.2 call和apply　　29
第3章　闭包和高阶函数
3.1 闭包 35
3.2 高阶函数　　44
3.3 小结　　58
第二部分 设计模式
第4章　单例模式
4.1 实现单例模式　　60
4.2 透明的单例模式　　61
4.3 用代理实现单例模式　　62
4.4 JavaScript中的单例模式　　63
4.5 惰性单例　　65
4.6 通用的惰性单例　　68
4.7 小结　　70
第5章　策略模式
5.1 使用策略模式计算奖金　　72
5.2 JavaScript 版本的策略模式　　75
5.3 多态在策略模式中的体现　　76
5.4 使用策略模式实现缓动动画　　76
5.5 更广义的“算法”　　80
5.6 表单校验　　80
5.7 策略模式的优缺点　　86
5.8 一等函数对象与策略模式　　86
5.9 小结　　87
第6章　代理模式
6.1 第一个例子——小明追MM的故事　　88
6.2 保护代理和虚拟代理　　91
6.3 虚拟代理实现图片预加载　　91
6.4 代理的意义　　93
6.5 代理和本体接口的一致性　　94
6.6 虚拟代理合并HTTP 请求　　95
6.7 虚拟代理在惰性加载中的应用　　97
6.8 缓存代理　　99
6.9 用高阶函数动态创建代理　　100
6.10 其他代理模式　　101
6.11 小结　　102
第7章　迭代器模式
7.1 jQuery 中的迭代器　　103
7.2 实现自己的迭代器　　104
7.3 内部迭代器和外部迭代器　　104
7.4 迭代类数组对象和字面量对象　　106
7.5 倒序迭代器　　106
7.6 中止迭代器　　107
7.7 迭代器模式的应用举例　　107
7.8 小结　　109
第8章　发布—订阅模式
8.1 现实中的发布—订阅模式　　110
8.2 发布—订阅模式的作用　　110
8.3 DOM 事件　　111
8.4 自定义事件　　112
8.5 发布—订阅模式的通用实现　　113
8.6 取消订阅的事件　　115
8.7 真实的例子——网站登录　　115
8.8 全局的发布—订阅对象　　117
8.9 模块间通信　　119
8.10 必须先订阅再发布吗　　120
8.11 全局事件的命名冲突　　121
8.12 JavaScript实现发布—订阅模式的便利性　　124
8.13 小结　　124
第9章　命令模式
9.1 命令模式的用途　　125
9.2 命令模式的例子——菜单程序　　126
9.3 JavaScript中的命令模式　　128
9.4 撤销命令　　130
9.5 撤消和重做　　132
9.6 命令队列　　134
9.7 宏命令　　134
9.8 智能命令与傻瓜命令　　135
9.9 小结　　136
第10章　组合模式
10.1 回顾宏命令　　138
10.2 组合模式的用途　　139
10.3 请求在树中传递的过程　　139
10.4 更强大的宏命令　　140
10.5 抽象类在组合模式中的作用　　143
10.6 透明性带来的安全问题　　144
10.7 组合模式的例子——扫描文件夹　　145
10.8 一些值得注意的地方　　147
10.9 引用父对象　　148
10.10 何时使用组合模式　　150
10.11 小结　　150
第11章　模板方法模式
11.1 模板方法模式的定义和组成　　151
11.2 第一个例子——Coffee or Tea　　151
11.3 抽象类　　156
11.4 模板方法模式的使用场景　　159
11.5 钩子方法　　160
11.6 好莱坞原则　　162
11.7 真的需要“继承”吗　　162
11.8 小结　　164
第12章　享元模式
12.1 初识享元模式　　165
12.2 内部状态与外部状态　　166
12.3 享元模式的通用结构　　167
12.4 文件上传的例子　　167
12.5 享元模式的适用性　　173
12.6 再谈内部状态和外部状态　　173
12.7 对象池　　175
12.8 小结　　178
第13章　职责链模式
13.1 现实中的职责链模式　　179
13.2 实际开发中的职责链模式　　180
13.3 用职责链模式重构代码　　181
13.4 灵活可拆分的职责链节点　　183
13.5 异步的职责链　　184
13.6 职责链模式的优缺点　　185
13.7 用AOP 实现职责链　　186
13.8 用职责链模式获取文件上传对象　　187
13.9 小结　　188
第14章　中介者模式
14.1 现实中的中介者　　190
14.2 中介者模式的例子——泡泡堂游戏　　191
14.3 中介者模式的例子——购买商品　　199
14.4 小结　　207
第15章　装饰者模式
15.1 模拟传统面向对象语言的装饰者模式　　210
15.2 装饰者也是包装器　　211
15.3 回到JavaScript 的装饰者　　212
15.4 装饰函数　　212
15.5 用AOP 装饰函数　　214
15.6 AOP 的应用实例　　216
15.7 装饰者模式和代理模式　　222
15.8 小结　　223
第16章　状态模式
16.1 初识状态模式　　224
16.2 状态模式的定义　　230
16.3 状态模式的通用结构　　230
16.4 缺少抽象类的变通方式　　　231
16.5 另一个状态模式示例——文件上传　　232
16.6 状态模式的优缺点　　241
16.7 状态模式中的性能优化点　　241
16.8 状态模式和策略模式的关系　　241
16.9 JavaScript版本的状态机　　242
16.10 表驱动的有限状态机　　244
16.11 实际项目中的其他状态机　　245
16.12 小结　　245
第17章　适配器模式
17.1 现实中的适配器　　246
17.2 适配器模式的应用　　247
17.3 小结　　250
第三部分 设计原则和编程技巧
第18章　单一职责原则
18.1 设计模式中的SRP原则　　252
18.2 何时应该分离职责　　256
18.3 违反SRP原则　　256
18.4 SRP 原则的优缺点　　257
第19章　最少知识原则
19.1 减少对象之间的联系　　258
19.2 设计模式中的LKP原则　　259
19.3 封装在LKP 原则中的体现　　261
第20章　开放-封闭原则
20.1 扩展window.onload函数　　263
20.2 开放和封闭　　264
20.3 用对象的多态性消除条件分支　　265
20.4 找出变化的地方　　266
20.5 设计模式中的开放—封闭原则　　268
20.6 开放—封闭原则的相对性　　270
20.7 接受第一次愚弄　　270
第21章　接口和面向接口编程
21.1 回到Java的抽象类　　271
21.2 interface　　276
21.3 JavaScript 语言是否需要抽象类和interface　　275
21.4 用鸭子类型进行接口检查　　277
21.5 用TypeScript 编写基于interface的命令模式　　278
第22章　代码重构
22.1 提炼函数　　282
22.2 合并重复的条件片段　　283
22.3 把条件分支语句提炼成函数　　284
22.4 合理使用循环　　285
22.5 提前让函数退出代替嵌套条件分支　　285
22.6 传递对象参数代替过长的参数列表　　286
22.7 尽量减少参数数量　　287
22.8 少用三目运算符　　288
22.9 合理使用链式调用　　288
22.10 分解大型类　　289
22.11 用return退出多重循环　　290
参考文献　　293
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaScript设计模式与开发实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式之禅
前 言
第一部分 大旗不挥，谁敢
冲锋—热身篇
第1章 单一职责原则
1.1 我是“牛”类，我可以担任多职吗
1.2 绝杀技，打破你的传统思维
1.3 我单纯，所以我快乐
1.4 最佳实践
第2章 里氏替换原则
2.1 爱恨纠葛的父子关系
2.2 纠纷不断，规则压制
2.3 最佳实践
第3章 依赖倒置原则
3.1 依赖倒置原则的定义
3.2 言而无信，你太需要契约
3.3 依赖的三种写法
3.4 最佳实践
第4章 接口隔离原则
4.1 接口隔离原则的定义
4.2 美女何其多，观点各不同
.4.3 保证接口的纯洁性
4.4 最佳实践
第5章 迪米特法则
5.1 迪米特法则的定义
5.2 我的知识你知道得越少越好
5.3 最佳实践
第6章 开闭原则
6.1 开闭原则的定义
6.2 开闭原则的庐山真面目
6.3 为什么要采用开闭原则
6.4 如何使用开闭原则
6.5 最佳实践
第二部分 我惹了谁—
真刀实枪篇
第7章 单例模式
7.1 我是皇帝我独苗
7.2 单例模式的定义
7.3 单例模式的应用
7.4 单例模式的扩展
7.5 最佳实践
第8章 工厂方法模式
8.1 女娲造人的故事
8.2 工厂方法模式的定义
8.3 工厂方法模式的应用
8.3.1 工厂方法模式的优点
8.3.2 工厂方法模式的使用场景
8.4 工厂方法模式的扩展
8.5 最佳实践
第9章 抽象工厂模式
9.1 女娲的失误
9.2 抽象工厂模式的定义
9.3 抽象工厂模式的应用
9.3.1 抽象工厂模式的优点
9.3.2 抽象工厂模式的缺点
9.3.3 抽象工厂模式的使用场景
9.3.4 抽象工厂模式的注意事项
9.4 最佳实践
第10章 模板方法模式
10.1 辉煌工程—制造悍马
10.2 模板方法模式的定义
10.3 模板方法模式的应用
10.4 模板方法模式的扩展
10.5 最佳实践
第11章 建造者模式
11.1 变化是永恒的
11.2 建造者模式的定义
11.3 建造者模式的应用
11.4 建造者模式的扩展
11.5 最佳实践
第12章 代理模式
12.1 我是游戏至尊
12.2 代理模式的定义
12.3 代理模式的应用
12.3.1 代理模式的优点
12.3.2 代理模式的应用
12.4 代理模式的扩展
12.4.1 普通代理
12.4.2 强制代理
12.4.3 代理是有个性的
12.4.4 虚拟代理
12.4.5 动态代理
12.5 最佳实践
第13章 原型模式
13.1 个性化电子账单
13.2 原型模式的定义
13.3 原型模式的应用
13.3.1 原型模式的优点
13.3.2 原型模式的使用场景
13.4 原型模式的注意事项
13.4.1 构造函数不会被执行
13.4.2 浅拷贝和深拷贝
13.4.3 clone与final两个冤家
13.5 最佳实践
第14章 中介者模式
14.1 进销存管理是这个样子的吗？
14.2 中介者模式的定义
14.3 中介者模式的应用
14.4 中介者模式的实际应用
14.5 最佳实践
第15章 命令模式
15.1 项目经理也难当
15.2 命令模式的定义
15.3 命令模式的应用
15.3.1 命令模式的优点
15.3.2 命令模式的缺点
15.3.3 命令模式的使用场景
15.4 命令模式的扩展
15.4.1 未讲完的故事
15.4.2 反悔问题
15.5 最佳实践
第16章 责任链模式
16.1 古代妇女的枷锁—“三从四德”
16.2 责任链模式的定义
16.3 责任链模式的应用
16.3.1 责任链模式的优点
16.3.2 责任链模式的缺点
16.3.3 责任链模式的注意事项
16.4 最佳实践
第17章 装饰模式
17.1 罪恶的成绩单
17.2 装饰模式的定义
17.3 装饰模式应用
17.3.1 装饰模式的优点
17.3.2 装饰模式的缺点
17.3.3 装饰模式的应用
17.4 最佳实践
第18章 策略模式
18.1 刘备江东娶妻，赵云他容易吗
18.2 策略模式的定义
18.3 策略模式的应用
18.3.1 策略模式的优点
18.3.2 策略模式的缺点
18.3.3 策略模式的应用
18.3.4 策略模式的注意事项
18.4 策略模式的扩展
18.5 最佳实践
第19章 适配器模式
19.1 业务发展—上帝才能控制
19.2 适配器模式的定义
19.3 适配器模式的应用
19.3.1 适配器模式的优点
19.3.2 适配器模式的应用
19.3.3 适配器模式的注意事项
19.4 适配器模式的扩展
19.5 最佳实践
第20章 迭代器模式
20.1 整理项目信息—苦差事
20.2 迭代器模式的定义
20.3 迭代器模式的应用
20.4 最佳实践
第21章 组合模式
21.1 公司的人事架构是这样的吗
21.2 组合模式的定义
21.3 组合模式的应用
21.3.1 组合模式的优点
21.3.2 组合模式的缺点
21.3.3 组合模式的应用
21.3.4 组合模式的注意事项
21.4 组合模式的扩展
21.4.1 真实的组合模式
21.4.2 透明的组合模式
21.4.3 组合模式的遍历
21.5 最佳实践
第22章 观察者模式
22.1 韩非子身边的卧底是谁派来的
22.2 观察者模式的定义
22.3 观察者模式的应用
22.3.1 观察者模式的优点
22.3.2 观察者模式的缺点
22.3.3 观察者模式的应用
22.3.4 观察者模式的注意事项
22.4 观察者模式的扩展
22.4.1 java世界中的观察者模式
22.4.2 项目中真实观察者模式
22.4.3 订阅发布模型
22.5 最佳实践
第23章 门面模式
23.1 我要投递信件
23.2 门面模式的定义
23.3 门面模式的应用
23.3.1 门面模式的优点
23.3.2 门面模式的缺点
23.3.3 门面模式的应用
23.4 门面模式的注意事项
23.4.1 一个子系统可以有多个
门面
23.4.2 门面不参与子系统内的
业务逻辑
23.5 最佳实践
第24章 备忘录模式
24.1 如此追女孩子，你还不乐
24.2 备忘录模式的定义
24.3 备忘录模式的应用
24.3.1 备忘录模式的应用
24.3.2 备忘录模式的注意事项
24.4 备忘录模式的扩展
24.4.1 clone方式的备忘录
24.4.2 多状态的备忘录模式
24.4.3 多备份的备忘录
24.4.4 封装得更好一点
24.5 最佳实践
第25章 访问者模式
25.1 员工的隐私何在？
25.2 访问者模式的定义
25.3 访问者模式的应用
25.3.1 访问者模式的优点
25.3.2 访问者模式的缺点
25.3.3 访问者模式的应用
25.4 访问者模式的扩展
25.4.1 统计功能
25.4.2 多个访问者
25.4.3 双分派
25.5 最佳实践
第26章 状态模式
26.1 城市的纵向发展功臣—电梯
26.2 状态模式的定义
26.3 状态模式的应用
26.3.1 状态模式的优点
26.3.2 状态模式的缺点
26.3.3 状态模式的应用
26.3.4 状态模式的注意事项
26.4 最佳实践
第27章 解释器模式
27.1 四则运算你会吗
27.2 解释器模式的定义
27.3 解释器模式的应用
27.3.1 解释器模式的优点
27.3.2 解释器模式的缺点
27.3.3 解释器模式使用的场景
27.3.4 解释器模式的注意事项
27.4 最佳实践
第28章 享元模式
28.1 内存溢出，司空见惯
28.2 享元模式的定义
28.3 享元模式的应用
28.3.1 享元模式优点和缺点
28.3.2 享元模式的应用
28.4 享元模式的扩展
28.4.1 线程安全的问题
28.4.2 性能平衡
28.5 最佳实践
第29章 桥梁模式
29.1 我有一个梦想……
29.2 桥梁模式的定义
29.3 桥梁模式的应用
29.3.1 桥梁模式的优点
29.3.2 桥梁模式的应用
29.3.3 桥梁模式的注意事项
29.4 最佳实践
第三部分 谁的地盘谁做主—模式pk篇
第30章 创建类模式大pk
30.1 工厂方法模式vs建造者模式
30.1.1 按工厂方法建造超人
30.1.2 按建造者模式建造超人
30.1.3 最佳实践
30.2 抽象工厂模式vs建造者模式
30.2.1 按抽象工厂模式生产车辆
30.2.2 按建造者模式生产车辆
30.2.3 最佳实践
第31章 结构类模式大pk
31.1 代理模式vs装饰模式
31.1.1 代理模式
31.1.2 装饰模式
31.1.3 最佳实践
31.2 装饰模式vs适配器模式
31.2.1 按装饰模式描述丑小鸭
31.2.2 按适配器模式实现丑小鸭
31.2.3 最佳实践
第32章 行为类模式大pk
32.1 命令模式vs策略模式
32.1.1 策略模式实现压缩算法
32.1.2 命令模式实现压缩算法
32.1.3 小结
32.2 策略模式vs状态模式
32.2.1 策略模式实现人生
32.2.2 状态模式实现人生
32.2.3 小结
32.3 观察者模式vs责任链模式
32.3.1 责任链模式实现dns
解析过程
32.3.2 触发链模式实现dns解析过程
32.3.3 小结
第33章 跨战区pk
33.1 策略模式vs桥梁模式
33.1.1 策略模式实现邮件发送
33.1.2 桥梁模式实现邮件发送
33.1.3 最佳实践
33.2 门面模式vs中介者模式
33.2.1 中介者模式实现工资计算
33.2.2 门面模式实现工资计算
33.2.3 最佳实践
33.3 包装模式群pk
33.3.1 代理模式
33.3.2 装饰模式
33.3.3 适配器模式
33.3.4 桥梁模式
33.3.5 最佳实践
第四部分 完美世界—混编模式
第34章 命令模式+责任链模式
34.1 搬移unix的命令
34.2 混编小结
第35章 工厂方法模式+策略模式
35.1 迷你版的交易系统
35.2 混编小结
第36章 观察者模式+中介者模式
36.1 事件触发器的开发
36.2 混编小结
第37章 规格模式
37.1 规格模式的实现
37.2 最佳实践
第38章 mvc框架
38.1 mvc框架的实现
38.1.1 mvc的系统架构
38.1.2 模型管理器
38.1.3 值栈
38.1.4 视图管理器
38.1.5 工具类
38.2 最佳实践
附录：23个设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式之禅
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>移动应用UI设计模式
第1章 　导航　　1
1.1 　主要导航模式　　4
1.1.1 　跳板式　　4
1.1.2 　列表菜单式　　8
1.1.3 　选项卡式　　10
1.1.4 　陈列馆式　　14
1.1.5 　仪表式　　16
1.1.6 　隐喻式　　16
1.1.7 　超级菜单式　　19
1.2 　次级导航模式　　20
1.2.1 　页面轮盘式　　22
1.2.2 　图片轮盘式　　24
1.2.3 　扩展列表式　　26
第2章 　表单　　29
2.1 　登录表单　　33
2.2 　注册表单　　35
2.3 　核对表单　　37
2.4 　计算表单　　39
2.5 　搜索表单　　41
2.6 　多步骤表单　　43
2.7 　长表单　　46
第3章 　表格和列表　　49
3.1 　基本表格　　53
3.2 　无表头表格　　53
3.3 　固定列表格的表格　　54
3.4 　带有内容总览和数据的表格　　55
3.5 　行分组表格　　57
3.6 　级联式列表　　58
3.7 　带有视觉指示器的表格　　59
3.8 　可编辑表格　　60
第4章 　搜索、分类和过滤　　61
4.1 　搜索　　63
4.1.1 　显性搜索　　64
4.1.2 　自动补全搜索　　66
4.1.3 　动态搜索　　68
4.1.4 　范围搜索　　68
4.1.5 　保存搜索记录并显示最近搜索内容　　70
4.1.6 　搜索表单　　71
4.1.7 　搜索结果/　　浏览结果　　72
4.2 　分类　　74
4.2.1 　屏内分类　　74
4.2.2 　分类排序选择器　　75
4.2.3 　分类表单　　77
4.3 　过滤　　78
4.3.1 　屏内过滤　　79
4.3.2 　过滤容器　　81
4.3.3 　过滤对话框　　81
4.3.4 　过滤表单　　82
第5章 　工具　　85
5.1 　工具栏　　90
5.2 　选项菜单　　93
5.3 　调用动作按钮　　94
5.4 　情境工具　　96
5.5 　内联操作　　98
5.6 　多状态按钮　　100
5.7 　批量操作102
第6章 　图表　　105
6.1 　带过滤器的图表　　109
6.2 　带预览窗口的图表　　112
6.3 　总览加数据式图表　　114
6.4 　数据点细节图　　116
6.5 　详细信息图　　118
6.6 　缩放图表　　120
6.7 　数据透视表　　121
6.8 　火花谱线图　　122
第7章 　视觉吸引　　125
7.1 　对话框　　129
7.2 　提示　　130
7.3 　使用向导　　131
7.4 　视频演示　　132
7.5 　幻灯片133
7.6 　首次使用引导　　134
7.7 　持续视觉吸引　　135
7.8 　可发现的视觉吸引　　136
第8章 　反馈与功能可见性　　137
8.1 　反馈　　139
8.2 　出错信息　　140
8.3 　确认　　141
8.4 　系统状态　　144
8.5 　功能可见性　　146
8.5.1 　触摸　　147
8.5.2 　滑动　　148
8.5.3 　拖曳　　150
第9章 　帮助　　153
9.1 　使用说明　　155
9.2 　界面元素说明　　157
9.3 　使用向导　　157
第10章 　反模式　　161
10.1 　标新立异　　163
10.2 　隐喻错位　　169
10.2.1 　控制错位　　169
10.2.2 　图标错位　　171
10.2.3 　心理模型错位　　171
10.3 　愚蠢的对话框　　173
10.4 　图表垃圾　　174
10.5 　按钮海　　178
附录　　181
关于作者　　206
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>移动应用UI设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>移动应用UI设计模式（第2版）
序　　X
前言　　XII
第1章　导航　　1
主导航模式—全局导航　　2
跳板式　　6
卡片式　　10
列表菜单式　　12
仪表盘式　　15
陈列馆式　　16
选项卡菜单式　　17
隐喻式　　25
主导航模式—瞬时导航　　28
侧边抽屉式　　28
下拉菜单式　　37
转盘菜单式　　40
次级导航模式　　41
翻页式　　43
滚动选项卡式　　46
折叠菜单式　　46
第2章　表单　　49
登录表单　　51
注册表单　　56
个性化注册表单　　64
多步骤表单　　66
结账表单　　72
技巧1：同时提供登录、注册和客人用户选项　　73
技巧2：简化流程　　74
技巧3：提供省时的快捷方式　　74
技巧4：提供快速结账方式　　76
技巧5：忘掉网页端　　77
计算表单　　80
搜索表单　　82
长表单　　84
第3章　表格　　87
基本表格　　89
无表头表格　　89
固定列表格　　91
概览加数据型表格　　93
行分组表格　　94
带有视觉指示器的表格　　95
可编辑表格　　97
第4章　搜索、排序和筛选　　100
搜索模式　　101
隐式搜索　　102
显式搜索　　105
自动完成搜索　　110
动态搜索　　112
限定范围的搜索　　113
保存的搜索、最近搜索记录和热门搜索　　114
搜索表单　　116
搜索结果/ 查看结果　　117
排序模式　　121
单页排序　　122
排序浮层　　124
排序表单　　125
筛选模式　　128
单页筛选　　129
筛选浮层　　131
筛选表单　　133
筛选抽屉　　135
基于手势的筛选　　137
第5章　工具　　138
工具栏　　140
iOS　　140
安卓　　142
Windows Phone　　143
与操作系统无关的模式：上下文工具栏　　144
工具箱　　145
行为召唤按钮　　147
行内操作　　152
多状态按钮　　154
上下文工具　　155
批量操作　　159
锁屏控件　　162
第6章　图表　　163
带有筛选器的图表　　168
交互式时间线　　171
数据点详情　　173
逐级深入　　176
概览加数据　　177
交互式预览　　179
仪表盘　　181
缩放　　183
迷你图　　185
嵌入式图例　　187
阈值　　187
透视表格　　189
整合　　190
第7章　引导和视觉吸引　　193
引导原则　　194
原则1：少用文字　　196
原则2：不要前置引导　　201
原则3：给予用户成就感　　205
原则4：在使用中强化学习　　209
原则5：倾听用户的心声　　211
视觉吸引模式　　212
提示　　212
持续的视觉吸引　　214
可发现的视觉吸引　　216
番外篇：视觉吸引—铺上欢迎毯　　217
迭代欢迎体验　　218
总结　　224
第8章　社交模式　　225
社交注册　　225
连接　　227
关注　　230
个人资料　　232
群组　　234
游戏化　　237
第9章　反馈与功能可见性　　242
反馈模式　　242
错误提示　　243
确认　　244
系统状态　　252
功能可见性　　256
点击　　256
滑动/ 轻扫　　258
拖拽　　262
第10章　帮助　　266
入门介绍　　271
用户指南/ 帮助系统　　272
常见问题解答　　275
功能使用向导　　276
新手引导　　279
上下文帮助　　281
收集反馈　　283
第11 章　反模式　　286
标新立异　　287
不必要的复杂　　292
隐喻错位　　296
控件错位　　296
图标错位　　298
手势错位　　298
心理模型错位　　299
愚蠢的对话框　　300
图表垃圾　　303
按钮海　　306
格格不入　　310
番外篇：避免移动应用中的注册/ 登录反模式　　312
附　录　　314
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>移动应用UI设计模式（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaScript设计模式
第一部分　面向对象的JavaScript
第1章　富有表现力的JavaScript
1.1　JavaScript的灵活性
1.2　弱类型语言
1.3　函数是一等对象
1.4　对象的易变性
1.5　继承
1.6　JavaScript中的设计模式
1.7　小结
第2章　接口
2.1　什么是接口
2.1.1　接口之利
2.1.2　接口之弊
2.2　其他面向对象语言处理接口的方式
2.3　在JavaScript中模仿接口
2.3.1　用注释描述接口
2.3.2　用属性检查模仿接口
2.3.3　用鸭式辨型模仿接口
2.4　本书采用的接口实现方法
2.5　Interface类
2.5.1　Interface类的使用场合
2.5.2　Interface类的用法
2.5.3　示例：使用Interface类
2.6　依赖于接口的设计模式
2.7　小结
第3章　封装和信息隐藏
3.1　信息隐藏原则
3.1.1　封装与信息隐藏
3.1.2　接口扮演的角色
3.2　创建对象的基本模式
3.2.1　门户大开型对象
3.2.2　用命名规范区别私用成员
3.2.3　作用域、嵌套函数和闭包
3.2.4　用闭包实现私用成员
3.3　更多高级对象创建模式
3.3.1　静态方法和属性
3.3.2　常量
3.3.3　单体和对象工厂
3.4　封装之利
3.5　封装之弊
3.6　小结
第4章　继承
4.1　为什么需要继承
4.2　类式继承
4.2.1　原型链
4.2.2　extend函数
4.3　原型式继承
4.3.1　对继承而来的成员的读和写的不对等性
4.3.2　clone函数
4.4　类式继承和原型式继承的对比
4.5　继承与封装
4.6　掺元类
4.7　示例：就地编辑
4.7.1　类式继承解决方案
4.7.2　原型式继承解决方案
4.7.3　掺元类解决方案
4.8　继承的适用场合
4.9　小结
第5章　单体模式
5.1　单体的基本结构
5.2　划分命名空间
5.3　用作特定网页专用代码的包装器的单体
5.4　拥有私用成员的单体
5.4.1　使用下划线表示法
5.4.2　使用闭包
5.4.3　两种技术的比较
5.5　惰性实例化
5.6　分支
5.7　示例：用分支技术创建XHR对象
5.8　单体模式的适用场合
5.9　单体模式之利
5.10　单体模式之弊
5.11　小结
第3章　封装和信息隐藏
第4章　继承
第5章　单体模式
第6章　方法的链式调用
第二部分　设计模式
第7章　工厂模式
第8章　桥接模式
第9章　组合模式
第10章　门面模式
第11章　适配器模式
第12章　装饰者模式
第13章　享元模式
第14章　代理模式
第15章　观察者模式
第16章　命令模式
第17章　职责链模式
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaScript设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图解设计模式
第1部分　适应设计模式　　1
第1章　Iterator模式——一个一个遍历　　1
1.1　Iterator模式　　2
1.2　示例程序　　2
Aggregate接口　　3
Iterator接口　　5
Book类　　5
BookShelf类　　5
BookShelfIteraotr类　　6
Main类　　7
1.3　Iterator模式中的登场角色　　8
1.4　拓展思路的要点　　9
不管实现如何变化，都可以使用Iterator　　9
难以理解抽象类和接口　　9
Aggregate和Iterator的对应　　9
容易弄错“下一个”　　10
还容易弄错“最后一个”　　10
多个Iterator　　10
迭代器的种类多种多样　　10
不需要deleteIterator　　10
1.5　相关的设计模式　　11
1.6　本章所学知识　　11
1.7　练习题　　11
第2章　Adapter模式——加个“适配器”以便于复用　　13
2.1　Adapter模式　　14
2.2　示例程序（1）（使用继承的适配器）　　14
Banner类　　15
Print接口　　16
PrintBanner类　　16
Main类　　16
2.3　示例程序（2）（使用委托的示例程序）　　17
Print类　　18
PrintBanner类　　18
2.4　Adapter模式中的登场角色　　18
2.5　拓展思路的要点　　19
什么时候使用Adapter模式　　19
如果没有现成的代码　　20
版本升级与兼容性　　20
功能完全不同的类　　20
2.6　相关的设计模式　　20
2.7　本章所学知识　　21
2.8　练习题　　21
第2部分　交给子类　　23
第3章　Template Method模式——将具体处理交给子类　　23
3.1　Template Method模式　　24
什么是模板　　24
什么是Template Method模式　　24
3.2　示例程序　　24
AbstractDisplay类　　25
CharDisplay类　　26
StringDisplay类　　27
Main类　　28
3.3　Template Method模式中的登场角色　　28
3.4　拓展思路的要点　　29
可以使逻辑处理通用化　　29
父类与子类之间的协作　　29
父类与子类的一致性　　29
3.5　相关的设计模式　　30
3.6　延伸阅读：类的层次与抽象类　　30
父类对子类的要求　　30
抽象类的意义　　30
父类与子类之间的协作　　31
3.7　本章所学知识　　31
3.8　练习题　　31
第4章　Factory Method模式——将实例的生成交给子类　　33
4.1　Factory Method模式　　34
4.2　示例程序　　34
Product类　　35
Factory类　　35
IDCard类　　36
IDCardFactory类　　36
Main类　　37
4.3　Factory Method模式中的登场角色　　37
4.4　拓展思路的要点　　39
框架与具体加工　　39
生成实例——方法的三种实现方式　　39
使用模式与开发人员之间的沟通　　40
4.5　相关的设计模式　　40
4.6　本章所学知识　　41
4.7　练习题　　41
第3部分　生成实例　　43
第5章　Singleton模式——只有一个实例　　43
5.1　Singleton模式　　44
5.2　示例程序　　44
Singleton类　　44
Main类　　45
5.3　Singleton模式中的登场角色　　46
5.4　拓展思路的要点　　46
为什么必须设置限制　　46
何时生成这个唯一的实例　　46
5.5　相关的设计模式　　47
5.6　本章所学知识　　47
5.7　练习题　　47
第6章　Prototype模式——通过复制生成实例　　49
6.1　Prototype模式　　50
6.2　示例程序　　50
Product接口　　51
Manager类　　52
MessageBox类　　52
UnderlinePen类　　53
Main类　　54
6.3　Prototype模式中的登场角色　　55
6.4　拓展思路的要点　　56
不能根据类来生成实例吗　　56
类名是束缚吗　　56
6.5　相关的设计模式　　57
6.6　延伸阅读：clone方法和java.lang.Clonable接口　　57
Java语言的clone　　57
clone方法是在哪里定义的　　58
需要实现Cloneable的哪些方法　　58
clone方法进行的是浅复制　　58
6.7　本章所学知识　　58
6.8　练习题　　59
第7章　Builder模式——组装复杂的实例　　61
7.1　Builder模式　　62
7.2　示例程序　　62
Builder类　　63
Director类　　63
TextBuilder类　　64
HTMLBuilder类　　65
Main类　　65
7.3　Builder模式中的登场角色　　67
7.4　相关的设计模式　　69
7.5　拓展思路的要点　　69
谁知道什么　　69
设计时能够决定的事情和不能决定的事情　　70
代码的阅读方法和修改方法　　70
7.6　本章所学知识　　70
7.7　练习题　　70
第8章　Abstract Factory模式——将关联零件组装成产品　　73
8.1　Abstract Factory模式　　74
8.2　示例程序　　74
抽象的零件：Item类　　77
抽象的零件：Link类　　78
抽象的零件：Tray类　　78
抽象的产品：Page类　　79
抽象的工厂：Factory类　　79
使用工厂将零件组装称为产品：Main类　　80
具体的工厂：ListFactory类　　81
具体的零件：ListLink类　　82
具体的零件：ListTray类　　82
具体的产品：ListPage类　　83
8.3　为示例程序增加其他工厂　　84
具体的工厂：TableFactory类　　85
具体的零件：TableLink类　　86
具体的零件：TableTray类　　86
具体的产品：TablePage类　　87
8.4　Abstract Factory模式中的登场角色　　87
8.5　拓展思路的要点　　89
易于增加具体的工厂　　89
难以增加新的零件　　89
8.6　相关的设计模式　　89
8.7　延伸阅读：各种生成实例的方法的介绍　　90
8.8　本章所学知识　　91
8.9　练习题　　91
第4部分　分开考虑　　93
第9章　Bridge模式——将类的功能层次结构与实现层次结构分离　　93
9.1　Bridge模式　　94
9.2　示例程序　　95
类的功能层次结构：Display类　　96
类的功能层次结构：CountDisplay类　　97
类的实现层次结构：DisplayImpl类　　97
类的实现层次结构：StringDisplayImpl类　　98
Main类　　98
9.3　Bridge模式中的登场角色　　99
9.4　拓展思路的要点　　100
分开后更容易扩展　　100
继承是强关联，委托是弱关联　　100
9.5　相关的设计模式　　101
9.6　本章所学知识　　101
9.7　练习题　　102
第10章　Strategy模式——整体地替换算法　　103
10.1　Strategy模式　　104
10.2　示例程序　　104
Hand类　　105
Strategy接口　　106
WinningStrategy类　　106
ProbStrategy类　　107
Player类　　109
Main类　　109
10.3　Strategy模式中的登场角色　　111
10.4　拓展思路的要点　　112
为什么需要特意编写Strategy角色　　112
程序运行中也可以切换策略　　112
10.5　相关的设计模式　　113
10.6　本章所学知识　　113
10.7　练习题　　113
第5部分　一致性　　117
第11章　Composite模式——容器与内容的一致性　　117
11.1　Composite模式　　118
11.2　示例程序　　118
Entry类　　119
File类　　120
Directory类　　121
FileTreatMentException类　　122
Main类　　122
11.3　Composite模式中的登场角色　　124
11.4　拓展思路的要点　　125
多个和单个的一致性　　125
Add方法应该放在哪里　　126
到处都存在递归结构　　126
11.5　相关的设计模式　　126
11.6　本章所学知识　　127
11.7　练习题　　127
第12章　Decorator模式——装饰边框与被装饰物的一致性　　129
12.1　Decorator模式　　130
12.2　示例程序　　130
Display类　　131
StringDisplay类　　132
Border类　　132
SideBorder类　　133
FullBorder类　　134
Main类　　135
12.3　Decorator模式中的登场角色　　136
12.4　拓展思路的要点　　137
接口（API）的透明性　　137
在不改变被装饰物的前提下增加功能　　138
可以动态地增加功能　　138
只需要一些装饰物即可添加许多功能　　138
java.io包与Decorator模式　　138
导致增加许多很小的类　　139
12.5　相关的设计模式　　139
12.6　延伸阅读：继承和委托中的一致性　　140
继承——父类和子类的一致性　　140
委托——自己和被委托对象的一致性　　140
12.7　本章所学知识　　142
12.8　练习题　　142
第6部分　访问数据结构　　145
第13章　Visitor模式——访问数据结构并处理数据　　145
13.1　Visitor模式　　146
13.2　示例程序　　146
Visitor类　　147
Element接口　　148
Entry类　　148
File类　　148
Directory类　　149
ListVisitor类　　150
FileTreatmentException类　　151
Main类　　151
Visitor与Element之间的相互调用　　152
13.3　Visitor模式中的登场角色　　154
13.4　拓展思路的要点　　155
双重分发　　155
为什么要弄得这么复杂　　155
开闭原则——对扩展开放，对修改关闭　　155
易于增加ConcreteVisitor角色　　156
难以增加ConcreteElement角色　　156
Visitor工作所需的条件　　156
13.5　相关的设计模式　　157
13.6　本章所学知识　　157
13.7　练习题　　157
第14章　Chain of Responsibility模式——推卸责任　　161
14.1　Chain of Responsibility模式　　162
14.2　示例程序　　162
Trouble类　　163
Support类　　163
NoSupport类　　164
LimitSupport类　　164
OddSupport类　　165
SpecialSupport类　　165
Main类　　166
14.3　Chain of Responsibility模式中的登场角色　　167
14.4　拓展思路的要点　　168
弱化了发出请求的人和处理请求的人之间的关系　　168
可以动态地改变职责链　　168
专注于自己的工作　　169
推卸请求会导致处理延迟吗　　169
14.5　相关的设计模式　　169
14.6　本章所学知识　　169
14.7　练习题　　169
第7部分　简单化　　171
第15章　Facade模式——简单窗口　　171
15.1　Facade模式　　172
15.2　示例程序　　172
Database类　　173
HtmlWriter类　　174
PageMaker类　　175
Main类　　176
15.3　Facade模式中的登场角色　　176
15.4　拓展思路的要点　　177
Facade角色到底做什么工作　　177
递归地使用Facade模式　　178
开发人员不愿意创建Facade角色的原因——心理原因　　178
15.5　相关的设计模式　　178
15.6　本章所学知识　　178
15.7　练习题　　179
第16章　Mediator模式——只有一个仲裁者　　181
16.1　Mediator模式　　182
16.2　示例程序　　182
Mediator接口　　185
Colleague接口　　186
ColleagueButton类　　186
ColleagueTextField类　　187
ColleagueCheckbox类　　188
LoginFrame类　　188
Main类　　191
16.3　Mediator模式中的登场角色　　191
16.4　拓展思路的要点　　192
当发生分散灾难时　　192
通信线路的增加　　193
哪些角色可以复用　　193
16.5　相关的设计模式　　193
16.6　本章所学知识　　193
16.7　练习题　　194
第8部分　管理状态　　195
第17章　Observer模式——发送状态变化通知　　195
17.1　Observer模式　　196
17.2　示例程序　　196
Observer接口　　196
NumberGenerator类　　197
RandomNumberGenerator类　　198
DigitObserver类　　198
GraphObserver类　　199
Main类　　199
17.3　Observer模式中的登场角色　　200
17.4　拓展思路的要点　　201
这里也出现了可替换性　　201
Observer的顺序　　202
当Observer的行为会对Subject产生影响时　　202
传递更新信息的方式　　202
从“观察”变为“通知”　　203
Model/View/Controller（MVC）　　203
17.5　延伸阅读：java.util.Observer接口　　203
17.6　相关的设计模式　　204
17.7　本章所学知识　　204
17.8　练习题　　204
第18章　Memento模式——保存对象状态　　207
18.1　Memento模式　　208
18.2　示例程序　　208
Memento类　　209
Gamer类　　210
Main类　　211
18.3　Memento模式中的登场角色　　215
18.4　拓展思路的要点　　216
两种接口（API）和可见性　　216
需要多少个Memento　　217
Memento的有效期限是多久　　217
划分Caretaker角色和Originator角色的意义　　217
18.5　相关的设计模式　　218
18.6　本章所学知识　　218
18.7　练习题　　218
第19章　State模式——用类表示状态　　221
19.1　State模式　　222
19.2　示例程序　　222
金库警报系统　　222
不使用State模式的伪代码　　223
使用了State模式的伪代码　　224
State接口　　226
DayState类　　226
NightState类　　227
Context接口　　228
SafeFrame类　　228
Main类　　231
19.3　State模式中的登场角色　　232
19.4　拓展思路的要点　　233
分而治之　　233
依赖于状态的处理　　233
应当是谁来管理状态迁移　　233
不会自相矛盾　　234
易于增加新的状态　　234
实例的多面性　　235
19.5　相关的设计模式　　235
19.6　本章所学知识　　235
19.7　练习题　　236
第9部分　避免浪费　　237
第20章　Flyweight模式——共享对象，避免浪费　　237
20.1　Flyweight模式　　238
20.2　示例程序　　238
BigChar类　　240
BigCharFactory类　　241
BigString类　　242
Main类　　244
20.3　Flyweight模式中的登场角色　　244
20.4　拓展思路的要点　　245
对多个地方产生影响　　245
Intrinsic与Extrinsic　　246
不要让被共享的实例被垃圾回收器回收了　　246
内存之外的其他资源　　247
20.5　相关的设计模式　　247
20.6　本章所学知识　　247
20.7　练习题　　247
第21章　Proxy模式——只在必要时生成实例　　249
21.1　Proxy模式　　250
21.2　示例程序　　250
Printer类　　251
Printable接口　　252
PrinterProxy类　　253
Main类　　254
21.3　Proxy模式中的登场角色　　254
21.4　拓展思路的要点　　255
使用代理人来提升处理速度　　255
有必要划分代理人和本人吗　　256
代理与委托　　256
透明性　　256
HTTP代理　　256
各种Proxy模式　　257
21.5　相关的设计模式　　257
21.6　本章所学知识　　257
21.7　练习题　　257
第10部分　用类来表现　　259
第22章　Command模式——命令也是类　　259
22.1　Command模式　　260
22.2　示例程序　　260
Command接口　　261
MacroCommand类　　262
DrawCommand类　　263
Drawable接口　　263
DrawCanvas类　　264
Main类　　265
22.3　Command模式中的登场角色　　268
22.4　拓展思路的要点　　269
命令中应该包含哪些信息　　269
保存历史记录　　269
适配器　　269
22.5　相关的设计模式　　271
22.6　本章所学知识　　272
22.7　练习题　　272
第23章　Interpreter模式——语法规则也是类　　273
23.1　Interpreter模式　　274
23.2　迷你语言　　274
迷你语言的命令　　274
迷你语言程序示例　　275
迷你语言的语法　　278
终结符表达式与非终结符表达式　　279
23.3　示例程序　　279
Node类　　281
ProgramNode类　　281
CommandListNode类　　282
CommandNode类　　283
RepeatCommandNode类　　284
PrimitiveCommandNode类　　285
Context类　　285
ParseException类　　286
Main类　　287
23.4　Interpreter模式中的登场角色　　288
23.5　拓展思路的要点　　289
还有其他哪些迷你语言　　289
跳过标记还是读取标记　　290
23.6　相关的设计模式　　290
23.7　本章所学知识以及本书的结束语　　290
23.8　练习题　　290
附录　　293
附录A　习题解答　　294
附录B　示例程序的运行步骤　　359
附录C　GoF对设计模式的分类　　361
附录D　设计模式Q&A　　362
附录E　参考书籍　　365
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图解设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图解Java多线程设计模式
序章1　Java线程　　1
I1.1　Java线程　　2
I1.2　何谓线程　　2
明为跟踪处理流程，实为跟踪线程　　2
单线程程序　　3
多线程程序　　4
Thread类的run方法和start方法　　5
I1.3　线程的启动　　9
线程的启动（1）——利用Thread类的子类　　9
线程的启动（2）——利用Runnable接口　　10
I1.4　线程的暂停　　12
I1.5　线程的互斥处理　　13
synchronized方法　　14
synchronized代码块　　17
I1.6　线程的协作　　18
等待队列——线程休息室　　19
wait方法——将线程放入等待队列　　19
notify方法——从等待队列中取出线程　　21
notifyAll方法——从等待队列中取出所有线程　　23
wait、notify、notifyAll是Object类的方法　　24
I1.7　线程的状态迁移　　24
I1.8　线程相关的其他话题　　26
I1.9　本章所学知识　　26
I1.10　　练习题　　26
序章2　多线程程序的评价标准　　31
I2.1　多线程程序的评价标准　　32
安全性——不损坏对象　　32
生存性——必要的处理能够被执行　　32
可复用性——类可重复利用　　33
性能——能快速、大批量地执行处理　　33
评价标准总结　　33
I2.2　本章所学知识　　34
I2.3　练习题　　34
第1章　　Single Threaded Execution模式——能通过这座桥的只有一个人　　35
1.1　Single Threaded Execution模式　　36
1.2　示例程序1：不使用Single Threaded Execution模式的程序　　36
Main类　　37
非线程安全的Gate类　　37
UserThread类　　38
执行起来看看……出错了　　39
为什么会出错呢　　40
1.3　示例程序2：使用Single Threaded Execution模式的程序　　41
线程安全的Gate类　　41
synchronized的作用　　42
1.4　Single Threaded Execution模式中的登场角色　　43
1.5　拓展思路的要点　　44
何时使用（可使用Single Threaded Execution模式的情况）　　44
生存性与死锁　　45
可复用性和继承反常　　46
临界区的大小和性能　　46
1.6　相关的设计模式　　47
Guarded Suspension模式　　47
Read-Write Lock模式　　47
Immutable模式　　47
Thread-Specific Storage模式　　48
1.7　延伸阅读1：关于synchronized　　48
synchronized语法与Before/After模式　　48
synchronized在保护着什么　　49
该以什么单位来保护呢　　50
使用哪个锁保护　　50
原子操作　　51
long与double的操作不是原子的　　51
1.8　延伸阅读2：java.util.concurrent包和计数信号量　　52
计数信号量和Semaphore类　　52
使用Semaphore类的示例程序　　52
1.9　本章所学知识　　55
1.10　　练习题　　55
第2章　　Immutable模式——想破坏也破坏不了　　61
2.1　Immutable模式　　62
2.2　示例程序　　62
使用Immutable模式的Person类　　62
Main类　　63
PrintPersonThread类　　63
2.3　Immutable模式中的登场角色　　65
2.4　拓展思路的要点　　66
何时使用（可使用Immutable模式的情况）　　66
考虑成对的mutable类和immutable类 [性能]　　66
为了确保不可变性 [可复用性]　　67
标准类库中用到的Immutable模式　　67
2.5　相关的设计模式　　69
Single Threaded Execution模式　　69
Read-Write Lock模式　　69
Flyweight模式　　69
2.6　延伸阅读1：final　　69
final的含义　　69
2.7　延伸阅读2：集合类与多线程　　71
示例1：非线程安全的java.util.ArrayList类　　71
示例2：利用Collections.synchronizedList方法所进行的同步　　74
示例3：使用copy-on-write的java.util.concurrent.CopyOnWriteArrayList类　　75
2.8　本章所学知识　　76
2.9　练习题　　77
第3章　　Guarded Suspension模式——等我准备好哦　　81
3.1　Guarded Suspension模式　　82
3.2　示例程序　　82
Request类　　83
RequestQueue类　　84
ClientThread类　　85
ServerThread类　　85
Main类　　86
java.util.Queue与java.util.LinkedList的操作　　87
getRequest详解　　87
putRequest详解　　89
synchronized的含义　　89
wait与锁　　89
3.3　Guarded Suspension模式中的登场角色　　90
3.4　拓展思路的要点　　91
附加条件的synchronized　　91
多线程版本的if　　91
忘记改变状态与生存性　　91
wait与notify/notifyAll的责任 [可复用性]　　91
各种称呼　　91
使用java.util.concurrent.LinkedBlockingQueue的示例程序　　93
3.5　相关的设计模式　　94
Single Threaded Execution模式　　94
Balking模式　　94
Producer-Consumer模式　　94
Future模式　　94
3.6　本章所学知识　　95
3.7　练习题　　95
第4章　　Balking模式——不需要就算了　　99
4.1　Balking模式　　100
4.2　示例程序　　100
Data类　　100
SaverThread类　　102
ChangerThread类　　102
Main类　　103
4.3　Balking模式中的登场角色　　105
4.4　拓展思路的要点　　106
何时使用（可使用Balking模式的情况）　　106
balk结果的表示方式　　107
4.5　相关的设计模式　　107
Guarded Suspension模式　　107
Observer模式　　107
4.6　延伸阅读：超时　　108
Balking模式和Guarded Suspension模式之间　　108
wait何时终止呢　　108
guarded timed的实现（使用wait）　　109
synchronized中没有超时，也不能中断　　110
java.util.concurrent中的超时　　111
4.7　本章所学知识　　111
4.8　练习题　　112
第5章　　Producer-Consumer模式——我来做，你来用　　115
5.1　Producer-Consumer模式　　116
5.2　示例程序　　116
Main类　　116
MakerThread类　　117
EaterThread类　　118
Table类　　118
解读put方法　　120
解读take方法　　121
5.3　Producer-Consumer模式中的登场角色　　122
5.4　拓展思路的要点　　123
守护安全性的Channel角色（可复用性）　　123
不可以直接传递吗　　124
Channel角色的剩余空间所导致的问题　　124
以什么顺序传递Data角色呢　　125
“存在中间角色”的意义　　125
Consumer角色只有一个时会怎么样呢　　126
5.5　相关的设计模式　　126
Mediator模式　　126
Worker Thread模式　　126
Command模式　　126
Strategy模式　　127
5.6　延伸阅读1：理解InterruptedException异常　　127
可能会花费时间，但可以取消　　127
加了throws InterruptedException的方法　　127
sleep方法和interrupt方法　　128
wait方法和interrupt方法　　128
join方法和interrupt方法　　129
interrupt方法只是改变中断状态　　129
isInterrupted方法——检查中断状态　　130
Thread.interrupted方法——检查并清除中断状态　　130
不可以使用Thread类的stop方法　　130
5.7　延伸阅读2：java.util.concurrent包和Producer-Consumer模式　　131
java.util.concurrent包中的队列　　131
使用java.util.concurrent.ArrayBlockingQueue的示例程序　　132
使用java.util.concurrent.Exchanger类交换缓冲区　　133
5.8　本章所学知识　　136
5.9　练习题　　137
第6章　　Read-Write Lock模式——大家一起读没问题，但读的时候不要写哦　　141
6.1　Read-Write Lock模式　　142
6.2　示例程序　　142
Main类　　143
Data类　　143
WriterThread类　　146
ReaderThread类　　146
ReadWriteLock类　　147
执行起来看看　　149
守护条件的确认　　150
6.3　Read-Write Lock模式中的登场角色　　151
6.4　拓展思路的要点　　153
利用“读取”操作的线程之间不会冲突的特性来提高程序性能　　153
适合读取操作繁重时　　153
适合读取频率比写入频率高时　　153
锁的含义　　153
6.5　相关的设计模式　　154
Immutable模式　　154
Single Threaded Execution模式　　154
Guarded Suspension模式　　154
Before/After模式　　154
Strategized Locking模式　　154
6.6　延伸阅读：java.util.concurrent.locks包和Read-Write Lock模式　　154
java.util.concurrent.locks包　　154
使用java.util.concurrent.locks的示例程序　　155
6.7　本章所学知识　　156
6.8　练习题　　157
第7章　　Thread-Per-Message模式——这项工作就交给你了　　163
7.1　Thread-Per-Message模式　　164
7.2　示例程序　　164
Main类　　164
Host类　　165
Helper类　　166
7.3　Thread-Per-Message模式中的登场角色　　168
7.4　拓展思路的要点　　169
提高响应性，缩短延迟时间　　169
适用于操作顺序没有要求时　　169
适用于不需要返回值时　　169
应用于服务器　　169
调用方法＋启动线程→发送消息　　170
7.5　相关的设计模式　　170
Future模式　　170
Worker Thread模式　　170
7.6　延伸阅读1：进程与线程　　171
7.7　延伸阅读2：java.util.concurrent包和Thread-Per-Message模式　　171
java.lang.Thread类　　171
java.lang.Runnable接口　　172
java.util.concurrent.ThreadFactory接口　　173
java.util.concurrent.Executors类获取的ThreadFactory　　174
java.util.concurrent.Executor接口　　175
java.util.concurrent.ExecutorService接口　　176
java.util.concurrent.ScheduledExecutorService类　　177
总结　　178
7.8　本章所学知识　　180
7.9　练习题　　180
第8章　　Worker Thread模式——工作没来就一直等，工作来了就干活　　187
8.1　Worker Thread模式　　188
8.2　示例程序　　188
Main类　　189
ClientThread类　　190
Request类　　190
Channel类　　191
WorkerThread类　　192
8.3　Worker Thread模式中的登场角色　　193
8.4　拓展思路的要点　　195
提高吞吐量　　195
容量控制　　195
调用与执行的分离　　196
Runnable接口的意义　　197
多态的Request角色　　198
独自一人的Worker角色　　199
8.5　相关的设计模式　　199
Producer-Consumer模式　　199
Thread-Per-Message模式　　199
Command模式　　199
Future模式　　199
Flyweight模式　　199
Thread-Specific Storage模式　　200
Active Ojbect模式　　200
8.6　延伸阅读1：Swing事件分发线程　　200
什么是事件分发线程　　200
事件分发线程只有一个　　200
事件分发线程调用监听器　　201
注册监听器的意义　　201
事件分发线程也负责绘制界面　　201
javax.swing.SwingUtilities类　　202
Swing的单线程规则　　203
8.7　延伸阅读2：java.util.concurrent包和Worker Thread模式　　204
ThreadPoolExecutor类　　204
通过java.util.concurrent包创建线程池　　205
8.8　本章所学知识　　207
8.9　练习题　　208
第9章　　Future模式——先给您提货单　　211
9.1　Future模式　　212
9.2　示例程序　　212
Main类　　214
Host类　　214
Data接口　　215
FutureData类　　216
RealData类　　217
9.3　Future模式中的登场角色　　218
9.4　拓展思路的要点　　219
吞吐量会提高吗　　219
异步方法调用的“返回值”　　220
“准备返回值”和“使用返回值”的分离　　220
变种——不让主线程久等的Future角色　　220
变种——会发生变化的Future角色　　221
谁会在意多线程呢？“可复用性”　　221
回调与Future模式　　221
9.5　相关的设计模式　　222
Thread-Per-Message模式　　222
Builder模式　　222
Proxy模式　　222
Guarded Suspension模式　　222
Balking模式　　222
9.6　延伸阅读：java.util.concurrent包与Future模式　　222
java.util.concurrent包　　222
使用了java.util.concurrent包的示例程序　　223
9.7　本章所学知识　　226
9.8　练习题　　226
第10章　　Two-Phase Termination模式——先收拾房间再睡觉　　231
10.1　Two-Phase Termination模式　　232
10.2　示例程序　　233
CountupThread类　　234
Main类　　236
10.3　Two-Phase Termination模式中的登场角色　　237
10.4　拓展思路的要点　　238
不能使用Thread类的stop方法　　238
仅仅检查标志是不够的　　239
仅仅检查中断状态是不够的　　239
在长时间处理前检查终止请求　　239
join方法和isAlive方法　　240
java.util.concurrent.ExecutorService接口与Two-Phase Termination模式　　240
要捕获程序整体的终止时　　241
优雅地终止线程　　243
10.5　相关的设计模式　　243
Before/After模式　　243
Multiphase Cancellation模式　　243
Multi-Phase Startup模式　　244
Balking模式　　244
10.6　延伸阅读1：中断状态与InterruptedException异常的相互转换　　244
中断状态→InterruptedException异常的转换　　244
InterruptedException异常→中断状态的转换　　245
InterruptedException异常→InterruptedException异常的转换　　245
10.7　延伸阅读2：java.util.concurrent包与线程同步　　246
java.util.concurrent.CountDownLatch类　　246
java.util.concurrent.CyclicBarrier类　　249
10.8　本章所学知识　　253
10.9　练习题　　253
第11章　　Thread-Specific Storage模式——一个线程一个储物柜　　263
11.1　Thread-Specific Storage模式　　264
11.2　关于java.lang.ThreadLocal类　　264
java.lang.ThreadLocal就是储物间　　264
java.lang.ThreadLocal与泛型　　265
11.3　示例程序1：不使用Thread-Specific Storage模式的示例　　265
Log类　　266
Main类　　266
11.4　示例程序2：使用了Thread-Specific Storage模式的示例　　267
线程特有的TSLog类　　268
Log类　　269
ClientThread类　　270
Main类　　271
11.5　Thread-Specific Storage模式中的登场角色　　272
11.6　拓展思路的要点　　274
局部变量与java.lang.ThreadLocal类　　274
保存线程特有的信息的位置　　275
不必担心其他线程访问　　275
吞吐量的提高很大程序上取决于实现方式　　276
上下文的危险性　　276
11.7　相关的设计模式　　277
Singleton模式　　277
Worker Thread模式　　277
Single Threaded Execution模式　　277
Proxy模式　　277
11.8　延伸阅读：基于角色与基于任务　　277
主体与客体　　277
基于角色的考虑方式　　278
基于任务的考虑方式　　278
实际上两种方式是综合在一起的　　279
11.9　本章所学知识　　279
11.10　　练习题　　280
第12章　　Active Object模式——接收异步消息的主动对象　　283
12.1　Active Object模式　　284
12.2　示例程序1　284
调用方：Main类　　287
调用方：MakerClientThread类　　288
调用方：DisplayClientThread类　　289
主动对象方：ActiveObject接口　　289
主动对象方：ActiveObjectFactory类　　290
主动对象方：Proxy类　　290
主动对象方：SchedulerThread类　　291
主动对象方：ActivationQueue类　　292
主动对象方：MethodRequest类　　293
主动对象方：MakeStringRequest类　　294
主动对象方：DisplayStringRequest类　　295
主动对象方：Result类　　295
主动对象方：FutureResult类　　296
主动对象方：RealResult类　　296
主动对象方：Servant类　　297
示例程序1的运行　　297
12.3　ActiveObject模式中的登场角色　　298
12.4　拓展思路的要点　　304
到底做了些什么事情　　304
运用模式时需要考虑问题的粒度　　304
关于并发性　　304
增加方法　　305
Scheduler角色的作用　　305
主动对象之间的交互　　306
通往分布式——从跨越线程界线变为跨越计算机界线　　306
12.5　相关的设计模式　　306
Producer-Consumer模式　　306
Future模式　　307
Worker Thread模式　　307
Thread-Specific Storage模式　　307
12.6　延伸阅读：java.util.concurrent包与Active Object模式　　307
类与接口　　307
调用方：Main类　　309
调用方：MakerClientThread类　　309
调用方：DisplayClientThread类　　310
主动对象方：ActiveObject接口　　311
主动对象方：ActiveObjectFactory类　　311
主动对象：ActiveObjectImpl类　　312
示例程序2的运行　　313
12.7　本章所学知识　　314
12.8　练习题　　315
第13章　　总结——多线程编程的模式语言　　321
13.1　多线程编程的模式语言　　322
模式与模式语言　　322
13.2　Single Threaded Execution模式
——能通过这座桥的只有一个人　　323
13.3　Immutable模式
——想破坏也破坏不了　　324
13.4　Guarded Suspension模式
——等我准备好哦　　325
13.5　Balking模式
——不需要就算了　　326
13.6　Producer-Consumer模式
——我来做，你来用　　327
13.7　Read-Write Lock模式
——大家一起读没问题，但读的时候不要写哦　　328
13.8　Thread-Per-Message模式
——这项工作就交给你了　　329
13.9　Worker Thread模式
——工作没来就一直等，工作来了就干活　　330
13.10　　Future模式
——先给您提货单　　330
13.11　Two-Phase Termination模式
——先收拾房间再睡觉　　331
13.12　Thread-Specific Storage模式
——一个线程一个储物柜　　332
13.13　Active Object模式
——接收异步消息的主动对象　　333
13.14　写在最后　　335
附录　　337
附录A　习题解答　　338
附录B　Java内存模型　　447
附录C　Java线程的优先级　　467
附录D　线程相关的主要API　　469
附录E　java.util.concurrent包　　475
附录F　示例程序的运行步骤　　483
附录G　参考文献　　485
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图解Java多线程设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Android 源码设计模式解析与实战
第1章 走向灵活软件之路——面向对象的六大原则 1
1.1 优化代码的第一步——单一职责原则 1
1.2 让程序更稳定、更灵活——开闭原则 5
1.3 构建扩展性更好的系统——里氏替换原则 12
1.4 让项目拥有变化的能力——依赖倒置原则 13
1.5 系统有更高的灵活性——接口隔离原则 16
1.6 更好的可扩展性——迪米特原则 18
1.7 总结 22
第2章 应用最广的模式——单例模式 23
2.1 单例模式介绍 23
2.2 单例模式的定义 23
2.3 单例模式的使用场景 23
2.4 单例模式UML类图 23
2.5 单例模式的简单示例 24
2.6 单例模式的其他实现方式 26
2.6.1 懒汉模式 26
2.6.2 Double CheckLock ( DCL )
实现单例 26
2.6.3 静态内部类单例模式 27
2.6.4 枚举单例 28
2.6.5 使用容器实现单例模式 28
2.7 Android源码中的单例模式 29
2.8 无名英雄——深入理解LayoutInflater 33
2.9 运用单例模式 40
2.10 总结 42
第3章 自由扩展你的项目——Builder模式 43
3.1 Builder模式介绍 43
3.2 Builder模式的定义 43
3.3 Builder模式的使用场景 43
3.4 Builder模式的UML类图 43
3.5 Builder模式的简单实现 44
3.6 Android源码中的Builder模式实现 46
3.7 深入了解WindowManager 52
3.8 Builder模式实战 59
3.9 总结 64
第4章 使程序运行更高效——原型模式 66
4.1 原型模式介绍 66
4.2 原型模式的定义 66
4.3 原型模式的使用场景 66
4.4 原型模式的UML类图 66
4.5 原型模式的简单实现 67
4.6 浅拷贝和深拷贝 69
4.7 Android源码中的原型模式实现 72
4.8 Intent的查找与匹配 74
4.8.1 App信息表的构建 74
4.8.2 精确匹配 80
4.9 原型模式实战 83
4.10 总结 85
第5章 应用最广泛的模式——工厂方法模式 87
5.1 工厂方法模式介绍 87
5.2 工厂方法模式的定义 87
5.3 工厂方法模式的使用场景 87
5.4 工厂方法模式的UML类图 87
5.5 模式的简单实现 90
5.6 Android源码中的工厂方法模式实现 93
5.7 关于onCreate方法 95
5.8 工厂方法模式实战 102
5.9 总结 105
第6章 创建型设计模式——抽象工厂模式 106
6.1 抽象工厂模式介绍 106
6.2 抽象工厂模式的定义 106
6.3 抽象工厂模式的使用场景 106
6.4 抽象工厂模式的UML类图 106
6.5 抽象工厂方法模式的简单实现 109
6.6 Android源码中的抽象工厂方法模式实现 112
6.7 总结 116
第7章 时势造英雄——策略模式 117
7.1 策略模式介绍 117
7.2 策略模式的定义 117
7.3 策略模式的使用场景 117
7.4 策略模式的UML类图 118
7.5 策略模式的简单实现 118
7.6 Android源码中的策略模式实现 123
7.6.1 时间插值器 123
7.6.2 动画中的时间插值器 124
7.7 深入属性动画 128
7.7.1 属性动画体系的总体设计 128
7.7.2 属性动画的核心类介绍 128
7.7.3 基本使用 129
7.7.4 流程图 130
7.7.5 详细设计 131
7.7.6 核心原理分析 131
7.8 策略模式实战应用 142
7.9 总结 144
第8章 随遇而安——状态模式 145
8.1 状态模式介绍 145
8.2 状态模式的定义 145
8.3 状态模式的使用场景 145
8.4 状态模式的UML类图 145
8.5 状态模式的简单示例 146
8.6 Wi-Fi管理中的状态模式 150
8.7 状态模式实战 159
8.8 总结 164
第9章 使编程更有灵活性——责任链模式 165
9.1 责任链模式介绍 165
9.2 责任链模式的定义 165
9.3 责任链模式的使用场景 165
9.4 责任链模式的UML类图 165
9.5 责任链模式的简单实现 170
9.6 Android源码中的责任链模式实现 173
9.7 责任链模式实战 178
9.8 总结 181
第10章 化繁为简的翻译机——解释器模式 182
10.1 解释器模式介绍 182
10.2 解释器模式的定义 182
10.3 解释器模式的使用场景 183
10.4 解释器模式的UML类图 184
10.5 解释器模式的简单实现 185
10.6 Android源码中的解释器模式实现 189
10.7 关于PackageManagerService 195
10.8 总结 203
第11章 让程序畅通执行——命令模式 204
11.1 命令模式介绍 204
11.2 命令模式的定义 204
11.3 命令模式的使用场景 204
11.4 命令模式的UML类图 204
11.5 命令模式的简单实现 207
11.6 Android源码中的命令模式实现 211
11.7 Android事件输入系统介绍 214
11.8 命令模式实战 216
11.9 总结 223
第12章 解决、解耦的钥匙——观察者模式 224
12.1 观察者模式介绍 224
12.2 观察者模式的定义 224
12.3 观察者模式的使用场景 224
12.4 观察者模式的UML类图 224
12.5 观察者模式的简单实现 225
12.6 Android源码分析 227
12.7 观察者模式的深入拓展 230
12.8 实战 238
12.9 总结 245
第13章 编程中的“后悔药”——备忘录模式 247
13.1 备忘录模式介绍 247
13.2 备忘录模式的定义 247
13.3 备忘录模式的使用场景 247
13.4 备忘录模式的UML类图 247
13.5 备忘录模式的简单示例 248
13.6 Android源码中的备忘录模式 250
13.7 深度拓展 257
13.7.1 onSaveInstanceState调用的时机 257
13.7.2 使用V4包存储状态的bug 257
13.8 实战 260
13.9 总结 267
第14章 解决问题的“第三者”——迭代器模式 268
14.1 迭代器模式介绍 268
14.2 迭代器模式的定义 268
14.3 迭代器模式的使用场景 268
14.4 迭代器模式的UML类图 268
14.5 模式的简单实现 271
14.6 Android源码中的模式实现 275
14.7 总结 277
第15章 抓住问题核心——模板方法模式 278
15.1 模板方法模式介绍 278
15.2 模板方法模式的定义 278
15.3 模板方法模式的使用场景 278
15.4 模板方法模式的UML类图 278
15.5 模板方法模式的简单示例 279
15.6 Android源码中的模板方法模式 281
15.7 深度拓展 283
15.8 模板方法实战 296
15.9 总结 299
第16章 访问者模式 301
16.1 访问者模式介绍 301
16.2 访问者模式的定义 301
16.3 访问者模式的使用场景 301
16.4 访问者模式的UML类图 301
16.5 访问者模式的简单示例 302
16.6 Android源码中的模式 306
16.7 访问者模式实战 309
16.8 总结 316
第17章 “和事佬”——中介者模式 317
17.1 中介者模式介绍 317
17.2 中介者模式的定义 318
17.3 中介者模式的使用场景 318
17.4 中介者模式的UML类图 318
17.5 中介者模式的简单实现 320
17.6 Android源码中的中介者模式实现 324
17.7 中介者模式实战 326
17.8 总结 329
第18章 编程好帮手——代理模式 330
18.1 代理模式介绍 330
18.2 代理模式的定义 330
18.3 代理模式的使用场景 330
18.4 代理模式的UML类图 330
18.5 代理模式的简单实现 332
18.6 Android源码中的代理模式实现 336
18.7 Android中的Binder跨进程通信机制与AIDL 340
18.8 代理模式实战 351
18.9 总结 355
第19章 物以类聚——组合模式 356
19.1 组合模式介绍 356
19.2 组合模式的定义 357
19.3 组合模式的使用场景 357
19.4 组合模式的UML类图 357
19.5 组合模式的简单实现 363
19.6 Android源码中的模式实现 367
19.7 为什么ViewGroup有容器的功能 368
19.8 总结 370
第20章 得心应手的“粘合剂”——适配器模式 371
20.1 适配器模式介绍 371
20.2 适配器模式的定义 371
20.3 适配器模式的使用场景 371
20.4 适配器模式的UML类图 371
20.5 适配器模式应用的简单示例 372
20.5.1 类适配器模式 372
20.5.2 对象适配器模式 373
20.6 Android源码中的适配器模式 375
20.7 深度拓展 380
20.8 实战演示 393
20.9 总结 402
第21章 装饰模式 403
21.1 装饰模式介绍 403
21.2 装饰模式的定义 403
21.3 装饰模式的使用场景 403
21.4 装饰模式的UML类图 403
21.5 模式的简单实现 406
21.6 Android源码中的模式实现 408
21.7 Context与ContextImpl 410
21.8 模式实战 419
21.9 总结 419
第22章 对象共享，避免创建多对象——享元模式 420
22.1 享元模式介绍 420
22.2 享元模式定义 420
22.3 享元模式的使用场景 420
22.4 享元模式的UML类图 420
22.5 享元模式的简单示例 421
22.6 Android源码中的享元模式 424
22.7 深度拓展 429
22.7.1 深入了解Android的消息机制 429
22.7.2 子线程中创建Handler为何会抛出异常 438
22.8 总结 439
第23章 统一编程接口——外观模式 440
23.1 外观模式介绍 440
23.2 外观模式定义 440
23.3 外观模式的使用场景 440
23.4 外观模式的UML类图 440
23.5 外观模式的简单示例 441
23.6 Android源码中的外观模式 443
23.7 深度拓展 448
23.7.1 Android资源的加载与匹配 448
23.7.2 动态加载框架的实现 455
23.8 外观模式实战 461
23.9 总结 464
第24章 连接两地的交通枢钮——桥接模式 465
24.1 桥接模式介绍 465
24.2 桥接模式的定义 465
24.3 桥接模式的使用场景 465
24.4 桥接模式的UML类图 465
24.5 桥接模式的简单实现 467
24.6 Android源码中的桥接模式实现 470
24.7 关于WindowManagerService 471
24.8 桥接模式实战 479
24.9 总结 482
第25章 MVC的介绍与实战 483
25.1 MVC的起源与历史 483
25.2 MVC在Android中的实现 484
25.3 总结 486
第26章 MVP应用架构模式 487
26.1 MVP模式介绍 487
26.2 MVP模式的三个角色 488
26.3 与MVC、MVVM的区别 488
26.4 MVP的实现 489
26.5 MVP与Activity、Fragment的生命周期 493
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Android 源码设计模式解析与实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>时间触发嵌入式系统设计模式
绪言
第一章 什么是时间触发的嵌入式系统
第二章 使用模式来设计嵌入式系统
第一篇 硬件基础
第三章 8051系列微控制器
第四章 振荡器硬件
第五章 硬件复位
第六章 存储器问题
第七章 直流负载驱动
第八章 交流负载驱动
第二篇 软件基础
第九章 基本的软件体系结构
第十章 使用端口
第十一章 延迟
第十二章 看门狗
第三篇 单处理器系统的时间触发结构
第十三章 调度器的介绍
第十四章 合作式调度器
第十五章 学会以合作的方式思考
第十六章 面向任务的设计
第十七章 混合式调度器
第四篇 用户界面
第十八章 通过RS-232与PC通信
第十九章 开关接口
第二十章 键盘接口
第二十一章 多路复用LED显示
第二十二章 控制LCD显示面板
第五篇 使用串行外围模块
第二十三章 使用IC外围模块
第二十四章 使用SPI外围模块
第六篇 多处理器系统的时间触发体系结构
第二十五章 共享时钟调器的介绍
第二十六章 使用外部中断的共享时钟调度器
第二十七章 使用UART的共享时钟调度器
第二十八章 使用CAN的共享时钟调度器
第二十九章 多处理器系统的设计
第七篇 监视与控制组件
第三十章 脉冲频率检测
第三十一章 脉冲频率调制
第三十二章 模拟-数字转换器的应用
第三十三章 脉冲宽度调制
第三十四章 数模转换器的应用
第三十五章 进行控制
第八篇 特殊的时间触发结构
第三十六章 减少系统开销
第三十七章 提高调度的稳定性
结论
第三十八章 本书试图实现的目标
第三十九章 收集的参考文献和书目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>时间触发嵌入式系统设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程实战指南（设计模式篇）
1章  Java多线程编程实战基础	1
1.1  无处不在的线程	1
1.2  线程的创建与运行	2
1.3  线程的状态与上下文切换	5
1.4  线程的监视	7
1.5  原子性、内存可见性和重排序——重新认识synchronized和volatile	10
1.6  线程的优势和风险	11
1.7  多线程编程常用术语	13
第2章  设计模式简介	17
2.1  设计模式及其作用	17
2.2  多线程设计模式简介	20
2.3  设计模式的描述	21
第3章  Immutable Object（不可变对象）模式	23
3.1  Immutable Object模式简介	23
3.2  Immutable Object模式的架构	25
3.3  Immutable Object模式实战案例	27
3.4  Immutable Object模式的评价与实现考量	31
3.5  Immutable Object模式的可复用实现代码	32
3.6  Java标准库实例	32
3.7  相关模式	34
3.7.1  Thread Specific Storage模式（第10章）	34
3.7.2  Serial Thread Confinement模式（第11章）	34
3.8  参考资源	34
第4章  Guarded Suspension（保护性暂挂）模式	35
4.1  Guarded Suspension模式简介	35
4.2  Guarded Suspension模式的架构	35
4.3  Guarded Suspension模式实战案例解析	39
4.4  Guarded Suspension模式的评价与实现考量	45
4.4.1  内存可见性和锁泄漏（Lock Leak）	46
4.4.2  线程过早被唤醒	46
4.4.3  嵌套监视器锁死	47
4.5  Guarded Suspension模式的可复用实现代码	50
4.6  Java标准库实例	50
4.7  相关模式	51
4.7.1  Promise模式（第6章）	51
4.7.2  Producer-Consumer模式（第7章）	51
4.8  参考资源	51
第5章  Two-phase Termination（两阶段终止）模式	52
5.1  Two-phase Termination模式简介	52
5.2  Two-phase Termination模式的架构	53
5.3  Two-phase Termination模式实战案例	56
5.4  Two-phase Termination模式的评价与实现考量	63
5.4.1  线程停止标志	63
5.4.2  生产者-消费者问题中的线程停止	64
5.4.3  隐藏而非暴露可停止的线程	65
5.5  Two-phase Termination模式的可复用实现代码	65
5.6  Java标准库实例	66
5.7  相关模式	66
5.7.1  Producer-Consumer模式（第7章）	66
5.7.2  Master-Slave模式（第12章）	66
5.8  参考资源	66
第6章  Promise（承诺）模式	67
6.1  Promise模式简介	67
6.2  Promise模式的架构	68
6.3  Promise模式实战案例解析	70
6.4  Promise模式的评价与实现考量	74
6.4.1  异步方法的异常处理	75
6.4.2  轮询（Polling）	75
6.4.3  异步任务的执行	75
6.5  Promise模式的可复用实现代码	77
6.6  Java标准库实例	77
6.7  相关模式	78
6.7.1  Guarded Suspension模式（第4章）	78
6.7.2  Active Object模式（第8章）	78
6.7.3  Master-Slave模式（第12章）	78
6.7.4  Factory Method模式	78
6.8  参考资源	79
第7章  Producer-Consumer（生产者/消费者）模式	80
7.1  Producer-Consumer模式简介	80
7.2  Producer-Consumer模式的架构	80
7.3  Producer-Consumer模式实战案例解析	83
7.4  Producer-Consumer模式的评价与实现考量	87
7.4.1  通道积压	87
7.4.2  工作窃取算法	88
7.4.3  线程的停止	92
7.4.4  高性能高可靠性的Producer-Consumer模式实现	92
7.5  Producer-Consumer模式的可复用实现代码	92
7.6  Java标准库实例	93
7.7  相关模式	93
7.7.1  Guarded Suspension模式（第4章）	93
7.7.2  Thread Pool模式（第9章）	93
7.8  参考资源	93
第8章  Active Object（主动对象）模式	94
8.1  Active Object模式简介	94
8.2  Active Object模式的架构	95
8.3  Active Object模式实战案例解析	98
8.4  Active Object模式的评价与实现考量	105
8.4.1  错误隔离	107
8.4.2  缓冲区监控	108
8.4.3  缓冲区饱和处理策略	108
8.4.4  Scheduler空闲工作者线程清理	109
8.5  Active Object模式的可复用实现代码	109
8.6  Java标准库实例	111
8.7  相关模式	112
8.7.1  Promise模式（第6章）	112
8.7.2  Producer-Consumer模式（第7章）	112
8.8  参考资源	112
第9章  Thread Pool（线程池）模式	113
9.1  Thread Pool模式简介	113
9.2  Thread Pool模式的架构	114
9.3  Thread Pool模式实战案例解析	116
9.4  Thread Pool模式的评价与实现考量	117
9.4.1  工作队列的选择	118
9.4.2  线程池大小调校	119
9.4.3  线程池监控	121
9.4.4  线程泄漏	122
9.4.5  可靠性与线程池饱和处理策略	122
9.4.6  死锁	125
9.4.7  线程池空闲线程清理	126
9.5  Thread Pool模式的可复用实现代码	127
9.6  Java标准库实例	127
9.7  相关模式	127
9.7.1  Two-phase Termination模式（第5章）	127
9.7.2  Promise模式（第6章）	127
9.7.3  Producer-Consumer模式（第7章）	127
9.8  参考资源	128
第10章  Thread Specific Storage（线程特有存储）模式	129
10.1  Thread Specific Storage模式简介	129
10.2  Thread Specific Storage模式的架构	131
10.3  Thread Specific Storage模式实战案例解析	133
10.4  Thread Specific Storage模式的评价与实现考量	135
10.4.1  线程池环境下使用Thread Specific Storage模式	138
10.4.2  内存泄漏与伪内存泄漏	139
10.5  Thread Specific Storage模式的可复用实现代码	145
10.6  Java标准库实例	146
10.7  相关模式	146
10.7.1  Immutable Object模式（第3章）	146
10.7.2  Proxy（代理）模式	146
10.7.3  Singleton（单例）模式	146
10.8  参考资源	147
第11章  Serial Thread Confinement（串行线程封闭）模式	148
11.1  Serial Thread Confinement模式简介	148
11.2  Serial Thread Confinement模式的架构	148
11.3  Serial Thread Confinement模式实战案例解析	151
11.4  Serial Thread Confinement模式的评价与实现考量	155
11.4.1  任务的处理结果	155
11.5  Serial Thread Confinement模式的可复用实现代码	156
11.6  Java标准库实例	160
11.7  相关模式	160
11.7.1  Immutable Object模式（第3章）	160
11.7.2  Promise模式（第6章）	160
11.7.3  Producer-Consumer模式（第7章）	160
11.7.4  Thread Specific Storage（线程特有存储）模式 （第10章）	161
11.8  参考资源	161
第12章  Master-Slave（主仆）模式	162
12.1  Master-Slave模式简介	162
12.2  Master-Slave模式的架构	162
12.3  Master-Slave模式实战案例解析	164
12.4  Master-Slave模式的评价与实现考量	171
12.4.1  子任务的处理结果的收集	172
12.4.2  Slave参与者实例的负载均衡与工作窃取	173
12.4.3  可靠性与异常处理	173
12.4.4  Slave线程的停止	174
12.5  Master-Slave模式的可复用实现代码	174
12.6  Java标准库实例	186
12.7  相关模式	186
12.7.1  Two-phase Termination模式（第5章）	186
12.7.2  Promise模式（第6章）	186
12.7.3  Strategy（策略）模式	186
12.7.4  Template（模板）模式	186
12.7.5  Factory Method（工厂方法）模式	186
12.8  参考资源	187
第13章  Pipeline（流水线）模式	188
13.1  Pipeline模式简介	188
13.2  Pipeline模式的架构	189
13.3  Pipeline模式实战案例解析	194
13.4  Pipeline模式的评价与实现考量	208
13.4.1  Pipeline的深度	209
13.4.2  基于线程池的Pipe	209
13.4.3  错误处理	212
13.4.4  可配置的Pipeline	212
13.5  Pipeline模式的可复用实现代码	212
13.6  Java标准库实例	222
13.7  相关模式	222
13.7.1  Serial Thread Confinement模式（第11章）	222
13.7.2  Master-Slave模式（第12章）	222
13.7.3  Composite模式	223
13.8  参考资源	223
第14章  Half-sync/Half-async（半同步/半异步）模式	224
14.1  Half-sync/Half-async模式简介	224
14.2  Half-sync/Half-async模式的架构	224
14.3  Half-sync/Half-async模式实战案例解析	226
14.4  Half-sync/Half-async模式的评价与实现考量	234
14.4.1  队列积压	235
14.4.2  避免同步层处理过慢	235
14.5  Half-sync/Half-async模式的可复用实现代码	236
14.6  Java标准库实例	240
14.7  相关模式	240
14.7.1  Two-phase Termination模式（第5章）	240
14.7.2  Producer-Consumer模式（第7章）	241
14.7.3  Active Object模式（第8章）	241
14.7.4  Thread Pool模式（第9章）	241
14.8  参考资源	241
第15章  模式语言	242
15.1  模式与模式间的联系	242
15.2  mmutable Object（不可变对象）模式	244
15.3  Guarded Suspension（保护性暂挂）模式	244
15.4  Two-phase Termination（两阶段终止）模式	245
15.5  Promise（承诺）模式	246
15.6  Producer-Consumer（生产者/消费者）模式	247
15.7  Active Object（主动对象）模式	248
15.8  Thread Pool（线程池）模式	249
15.9  Thread Specific Storage（线程特有存储）模式	250
15.10  Serial Thread Confinement（串行线程封闭）模式	251
15.11  Master-Slave（主仆）模式	252
15.12  Pipeline（流水线）模式	253
15.13  Half-sync/Half-async（半同步/半异步）模式	254
附录  本书常用UML图指南	255
A.1  UML简介	255
A.2  类图（Class Diagram）	256
A.1.1  类的属性、方法和立体型（Stereotype）	256
A.1.2  类与类之间的关系	258
A.3  序列图（Sequence Diagram）	261
参考文献	263
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程实战指南（设计模式篇）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaScript设计模式
第1章　介绍　1
第2章　什么是模式　3
我们每天都在使用模式　4
第3章　模式状态测试、proto模式及三法则　6
第4章　设计模式的结构　8
第5章　编写设计模式　11
第6章　反模式　13
第7章　设计模式类别　15
第8章　设计模式分类　17
有关类(class)的要点　17
第9章 javascript设计模式　20
9.1 constructor(构造器)模式　21
9.1.1 对象创建　21
9.1.2 基本constructor(构造器)　23
9.1.3 带原型的constructor(构造器)　24
9.2 module(模块)模式　25
9.2.1 对象字面量　25
9.2.2 module(模块)模式　27
9.2.3 module模式变化　31
.9.3 revealing module(揭示模块)模式　36
9.3.1 优点　38
9.3.2 缺点　38
9.4 singleton(单例)模式　38
9.5 observer(观察者)模式　42
9.5.1 observer(观察者)模式和publish/subscribe(发布/订阅)模式的区别　47
9.5.2 优点　49
9.5.3 缺点　49
9.5.4 publish/subscribe实现　49
9.6 mediator(中介者)模式　59
9.6.1 基本实现　60
9.6.2 高级实现　61
9.6.3 示例　67
9.6.4 优点和缺点　68
9.6.5 中介者(mediator)与观察者(observer)　69
9.6.6 中介者(mediator)与外观(facade)　69
9.7 prototype(原型)模式　70
9.8 command(命令)模式　73
9.9 facade(外观)模式　75
有关抽象的要点　78
9.10 factory(工厂)模式　78
9.10.1 何时使用factory模式　81
9.10.2 何时不应使用factory模式　81
9.10.3 abstract factory(抽象工厂)　81
9.11 mixin模式　82
9.11.1 子类化　83
9.11.2 mixin(混入)　84
9.12 decorator(装饰者)模式　88
9.12.1 伪经典decorator(装饰者)　91
9.12.2 使用jquery的装饰者　96
9.12.3 优点和缺点　97
9.13 flyweight(享元)模式　98
9.13.1 使用flyweight模式　98
9.13.2 flyweight和共享数据　99
9.13.3 实现经典flyweight(享元)　99
9.13.4 转换代码以使用flyweight(享元)模式　103
9.13.5 基本工厂　105
9.13.6 管理外部状态　106
9.13.7 flyweight(享元)模式和dom　107
第10章　javascript mv*模式　112
10.1 mvc　112
smalltalk-80 mvc　113
10.2 为javascript开发人员提供的mvc　114
10.2.1 model(模型)　114
10.2.2 view(视图)　116
10.2.3 controller(控制器)　119
10.2.4 spine.js与backbone.js　120
10.3 mvc为我们提供了什么　122
10.4 javascript中的smalltalk-80 mvc　122
10.4.1 深入挖掘　123
10.4.2 总结　123
10.5 mvp　124
10.5.1 model、view和presenter　124
10.5.2 mvp或mvc？　125
10.5.3 mvc、mvp和backbone.js　126
10.6 mvvm　128
10.6.1 历史　129
10.6.2 model　129
10.6.3 view　130
10.6.4 viewmodel　133
10.6.5 小结：view和viewmodel　135
10.6.6 小结：viewmodel和model　135
10.7 利与弊　135
10.7.1 优点　135
10.7.2 缺点　136
10.8 使用更松散数据绑定的mvvm　136
10.9 mvc、mvp与mvvm　141
10.10 backbone.js与knockoutjs　142
第11章 模块化的javascript设计模式　144
11.1 脚本加载器要点　145
11.2 amd　145
11.2.1 模块入门　146
11.2.2 使用dojo的amd模块　150
11.2.3 amd模块设计模式(dojo)　151
11.2.4 使用jquery的amd模块　152
11.2.5 amd总结　155
11.3 commonjs　155
11.3.1 入门指南　156
11.3.2 使用多个依赖　157
11.3.3 支持commonjs的加载器和框架　158
11.3.4 commonjs适用于浏览器吗？　158
11.3.5 延伸阅读　159
11.4 amd和commonjs：互相竞争，标准同效　159
umd：用于插件的amd和commonjs兼容模块　160
11.5 es harmony　165
11.5.1 具有imports和exports的模块　166
11.5.2 从远程数据源加载的模块　167
11.5.3 模块加载器api　167
11.5.4 用于服务器的类commonjs模块　168
11.5.5 具有构造函数、getter和setter的类　168
11.5.6 es harmony总结　169
11.5.7 延伸阅读　170
11.6 总结　170
第12章 jquery中的设计模式　171
12.1 composite(组合)模式　171
12.2 adapter(适配器)模式　173
12.3 facade(外观)模式　174
12.4 observer(观察者)模式　177
12.5 iterator(迭代器)模式　180
12.6 延迟初始化　181
12.7 proxy(代理)模式　183
12.8 builder(生成器)模式　184
第13章 jquery插件设计模式　187
13.1 模式　188
13.2 lightweight start模式　189
延伸阅读　191
13.3 完整的widget factory模式　191
延伸阅读　194
13.4 嵌套命名空间插件模式　194
延伸阅读　196
13.5 自定义事件插件模式(使用widget factory)　196
延伸阅读　198
13.6 使用dom-to-object bridge模式的原型继承　198
延伸阅读　200
13.7 jquery ui widget factory bridge模式　200
延伸阅读　203
13.8 使用widget factory的jquery mobile widget　203
13.9 requirejs和jquery ui widget factory　206
13.9.1 用法　208
13.9.2 延伸阅读　209
13.10 全局选项和单次调用可重写选项(最佳选项模式)　209
延伸阅读　211
13.11 高可配和高可变的插件模式　211
延伸阅读　213
13.12 是什么使插件超越模式　213
13.12.1 质量　214
13.12.2 代码风格　214
13.12.3 兼容性　214
13.12.4 可靠性　214
13.12.5 性能　214
13.12.6 文档　215
13.12.7 维护的可能性　215
13.13 总结　215
13.14 命名空间模式　215
13.15 命名空间基础　216
13.15.1 单一全局变量　216
13.15.2 命名空间前缀　217
13.15.3 对象字面量表示法　217
13.15.4 嵌套命名空间　221
13.15.5 立即调用的函数表达式(iife)　222
13.15.6 命名空间注入　224
13.16 高级命名空间模式　226
13.16.1 自动嵌套的命名空间　227
13.16.2 依赖声明模式　229
13.16.3 深度对象扩展　229
13.16.4 推荐　232
第14章　总结　233
附录　参考文献　235
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaScript设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式之禅（第2版）
前  言
第一部分   大旗不挥，谁敢冲
锋—6大设计原则全新解读
第1章   单一职责原则	2
1.1   我是“牛”类，我可以担任多职吗	2
1.2   绝杀技，打破你的传统思维	3
1.3   我单纯，所以我快乐	6
1.4   最佳实践	7
第2章   里氏替换原则	8
2.1   爱恨纠葛的父子关系	8
2.2   纠纷不断，规则压制	9
2.3   最佳实践	18
第3章   依赖倒置原则	19
3.1   依赖倒置原则的定义	19
3.2   言而无信，你太需要契约	20
3.3   依赖的三种写法	25
3.4   最佳实践	26
第4章   接口隔离原则	28
4.1   接口隔离原则的定义	28
4.2   美女何其多，观点各不同	29
4.3   保证接口的纯洁性	33
4.4   最佳实践	35
第5章   迪米特法则	36
5.1   迪米特法则的定义	36
5.2   我的知识你知道得越少越好	36
5.3   最佳实践	43
第6章   开闭原则	44
6.1   开闭原则的定义	44
6.2   开闭原则的庐山真面目	44
6.3   为什么要采用开闭原则	49
6.4   如何使用开闭原则	51
6.5   最佳实践	55
第二部分   真刀实枪—23种设计模式完美演绎
第7章   单例模式	58
7.1   我是皇帝我独苗	58
7.2   单例模式的定义	59
7.3   单例模式的应用	60
7.3.1   单例模式的优点	60
7.3.2   单例模式的缺点	60
7.3.3   单例模式的使用场景	61
7.3.4   单例模式的注意事项	61
7.4   单例模式的扩展	62
7.5   最佳实践	64
第8章   工厂方法模式	65
8.1   女娲造人的故事	65
8.2   工厂方法模式的定义	69
8.3   工厂方法模式的应用	70
8.3.1   工厂方法模式的优点	70
8.3.2   工厂方法模式的使用场景	71
8.4   工厂方法模式的扩展	71
8.5   最佳实践	77
第9章   抽象工厂模式	78
9.1   女娲的失误	78
9.2   抽象工厂模式的定义	83
9.3   抽象工厂模式的应用	86
9.3.1   抽象工厂模式的优点	86
9.3.2   抽象工厂模式的缺点	86
9.3.3   抽象工厂模式的使用场景	86
9.3.4   抽象工厂模式的注意事项	86
9.4   最佳实践	87
第10章   模板方法模式	88
10.1   辉煌工程—制造悍马	88
10.2   模板方法模式的定义	93
10.3   模板方法模式的应用	94
10.3.1   模板方法模式的优点	94
10.3.2   模板方法模式的缺点	95
10.3.3   模板方法模式的使用场景	95
10.4   模板方法模式的扩展	95
10.5   最佳实践	99
第11章   建造者模式	100
11.1   变化是永恒的	100
11.2   建造者模式的定义	109
11.3   建造者模式的应用	111
11.3.1   建造者模式的优点	111
11.3.2   建造者模式的使用场景	111
11.3.3   建造者模式的注意事项	111
11.4   建造者模式的扩展	111
11.5   最佳实践	112
第12章   代理模式	113
12.1   我是游戏至尊	113
12.2   代理模式的定义	116
12.3   代理模式的应用	118
12.3.1   代理模式的优点	118
12.3.2   代理模式的使用场景	119
12.4   代理模式的扩展	119
12.4.1   普通代理	119
12.4.2   强制代理	121
12.4.3   代理是有个性的	126
12.4.4   动态代理	128
12.5   最佳实践	134
第13章   原型模式	135
13.1   个性化电子账单	135
13.2   原型模式的定义	141
13.3   原型模式的应用	142
13.3.1   原型模式的优点	142
13.3.2   原型模式的使用场景	142
13.4   原型模式的注意事项	143
13.4.1   构造函数不会被执行	143
13.4.2   浅拷贝和深拷贝	144
13.4.3   clone与final两个冤家	146
13.5   最佳实践	146
第14章   中介者模式	147
14.1   进销存管理是这个样子的吗	147
14.2   中介者模式的定义	156
14.3   中介者模式的应用	159
14.3.1   中介者模式的优点	159
14.3.2   中介者模式的缺点	159
14.3.3   中介者模式的使用场景	159
14.4   中介者模式的实际应用	160
14.5   最佳实践	161
第15章   命令模式	162
15.1   项目经理也难当	162
15.2   命令模式的定义	170
15.3   命令模式的应用	173
15.3.1   命令模式的优点	173
15.3.2   命令模式的缺点	173
15.3.3   命令模式的使用场景	173
15.4   命令模式的扩展	173
15.4.1   未讲完的故事	173
15.4.2   反悔问题	174
15.5   最佳实践	175
第16章   责任链模式	178
16.1   古代妇女的枷锁—“三从四德”	178
16.2   责任链模式的定义	186
16.3   责任链模式的应用	189
16.3.1   责任链模式的优点	189
16.3.2   责任链模式的缺点	190
16.3.3   责任链模式的注意事项	190
16.4   最佳实践	190
第17章   装饰模式	192
17.1   罪恶的成绩单	192
17.2   装饰模式的定义	198
17.3   装饰模式应用	201
17.3.1   装饰模式的优点	201
17.3.2   装饰模式的缺点	201
17.3.3   装饰模式的使用场景	201
17.4   最佳实践	201
第18章   策略模式	203
18.1   刘备江东娶妻，赵云他容易吗	203
18.2   策略模式的定义	206
18.3   策略模式的应用	208
18.3.1   策略模式的优点	208
18.3.2   策略模式的缺点	208
18.3.3   策略模式的使用场景	209
18.3.4   策略模式的注意事项	209
18.4   策略模式的扩展	209
18.5   最佳实践	214
第19章   适配器模式	215
19.1   业务发展—上帝才能控制	215
19.2   适配器模式的定义	221
19.3   适配器模式的应用	223
19.3.1   适配器模式的优点	223
19.3.2   适配器模式的使用场景	224
19.3.3   适配器模式的注意事项	224
19.4   适配器模式的扩展	224
19.5   最佳实践	229
第20章   迭代器模式	230
20.1   整理项目信息—苦差事	230
20.2   迭代器模式的定义	236
20.3   迭代器模式的应用	239
20.4   最佳实践	239
第21章   组合模式	240
21.1   公司的人事架构是这样的吗	240
21.2   组合模式的定义	253
21.3   组合模式的应用	255
21.3.1   组合模式的优点	255
21.3.2   组合模式的缺点	256
21.3.3   组合模式的使用场景	256
21.3.4   组合模式的注意事项	256
21.4   组合模式的扩展	256
21.4.1   真实的组合模式	256
21.4.2   透明的组合模式	257
21.4.3   组合模式的遍历	259
21.5   最佳实践	260
第22章   观察者模式	262
22.1   韩非子身边的卧底是谁派来的	262
22.2   观察者模式的定义	271
22.3   观察者模式的应用	273
22.3.1   观察者模式的优点	273
22.3.2   观察者模式的缺点	274
22.3.3   观察者模式的使用场景	274
22.3.4   观察者模式的注意事项	274
22.4   观察者模式的扩展	275
22.4.1   Java世界中的观察者模式	275
22.4.2   项目中真实的观察者模式	276
22.4.3   订阅发布模型	277
22.5   最佳实践	277
第23章   门面模式	278
23.1   我要投递信件	278
23.2   门面模式的定义	283
23.3   门面模式的应用	284
23.3.1   门面模式的优点	284
23.3.2   门面模式的缺点	285
23.3.3   门面模式的使用场景	285
23.4   门面模式的注意事项	285
23.4.1   一个子系统可以有多个门面	285
23.4.2   门面不参与子系统内的业务逻辑	286
23.5   最佳实践	288
第24章   备忘录模式	289
24.1   如此追女孩子，你还不乐	289
24.2   备忘录模式的定义	294
24.3   备忘录模式的应用	297
24.3.1   备忘录模式的使用场景	297
24.3.2   备忘录模式的注意事项	297
24.4   备忘录模式的扩展	297
24.4.1   clone方式的备忘录	297
24.4.2   多状态的备忘录模式	300
24.4.3   多备份的备忘录	304
24.4.4   封装得更好一点	305
24.5   最佳实践	307
第25章   访问者模式	308
25.1   员工的隐私何在	308
25.2   访问者模式的定义	316
25.3   访问者模式的应用	320
25.3.1   访问者模式的优点	320
25.3.2   访问者模式的缺点	320
25.3.3   访问者模式的使用场景	320
25.4   访问者模式的扩展	321
25.4.1   统计功能	321
25.4.2   多个访问者	323
25.4.3   双分派	326
25.5   最佳实践	328
第26章   状态模式	329
26.1   城市的纵向发展功臣—电梯	329
26.2   状态模式的定义	341
26.3   状态模式的应用	343
26.3.1   状态模式的优点	343
26.3.2   状态模式的缺点	344
26.3.3   状态模式的使用场景	344
26.3.4   状态模式的注意事项	344
26.4   最佳实践	344
第27章   解释器模式	346
27.1   四则运算你会吗	346
27.2   解释器模式的定义	352
27.3   解释器模式的应用	354
27.3.1   解释器模式的优点	354
27.3.2   解释器模式的缺点	354
27.3.3   解释器模式使用的场景	355
27.3.4   解释器模式的注意事项	355
27.4   最佳实践	355
第28章   享元模式	356
28.1   内存溢出，司空见惯	356
28.2   享元模式的定义	361
28.3   享元模式的应用	364
28.3.1   享元模式的优点和缺点	364
28.3.2   享元模式的使用场景	364
28.4   享元模式的扩展	365
28.4.1   线程安全的问题	365
28.4.2   性能平衡	366
28.5   最佳实践	369
第29章   桥梁模式	371
29.1   我有一个梦想	371
29.2   桥梁模式的定义	379
29.3   桥梁模式的应用	381
29.3.1   桥梁模式的优点	381
29.3.2   桥梁模式的使用场景	382
29.3.3   桥梁模式的注意事项	382
29.4   最佳实践	382
第三部分   谁的地盘谁做主—设计模式PK
第30章   创建类模式大PK	384
30.1   工厂方法模式VS建造者模式	384
30.1.1   按工厂方法建造超人	384
30.1.2   按建造者模式建造超人	386
30.1.3   最佳实践	389
30.2   抽象工厂模式VS建造者模式	390
30.2.1   按抽象工厂模式生产车辆	390
30.2.2   按建造者模式生产车辆	394
30.2.3   最佳实践	399
第31章   结构类模式大PK	400
31.1   代理模式VS装饰模式	400
31.1.1   代理模式	400
31.1.2   装饰模式	402
31.1.3   最佳实践	403
31.2   装饰模式VS适配器模式	404
31.2.1   用装饰模式描述丑小鸭	404
31.2.2   用适配器模式实现丑小鸭	407
31.2.3   最佳实践	410
第32章   行为类模式大PK	411
32.1   命令模式VS策略模式	411
32.1.1   策略模式实现压缩算法	411
32.1.2   命令模式实现压缩算法	414
32.1.3   小结	419
32.2   策略模式VS状态模式	420
32.2.1   策略模式实现人生	420
32.2.2   状态模式实现人生	423
32.2.3   小结	425
32.3   观察者模式VS责任链模式	426
32.3.1   责任链模式实现DNS
解析过程	427
32.3.2   触发链模式实现DNS
解析过程	432
32.3.3   小结	437
第33章   跨战区PK	438
33.1   策略模式VS桥梁模式	438
33.1.1   策略模式实现邮件发送	439
33.1.2   桥梁模式实现邮件发送	442
33.1.3   最佳实践	445
33.2   门面模式VS中介者模式	446
33.2.1   中介者模式实现工资计算	446
33.2.2   门面模式实现工资计算	451
33.2.3   最佳实践	454
33.3   包装模式群PK	455
33.3.1   代理模式	455
33.3.2   装饰模式	457
33.3.3   适配器模式	459
33.3.4   桥梁模式	461
33.3.5   最佳实践	464
第四部分   完美世界—设计模式混编
第34章   命令模式+责任链模式	466
34.1   搬移UNIX的命令	466
34.2   混编小结	481
第35章   工厂方法模式+策略模式	483
35.1   迷你版的交易系统	483
35.2   混编小结	493
第36章   观察者模式+中介者模式	495
36.1   事件触发器的开发	495
36.2   混编小结	508
第五部分   扩展篇
第37章   MVC框架	510
37.1   MVC框架的实现	510
37.1.1   MVC的系统架构	512
37.1.2   模型管理器	518
37.1.3   值栈	522
37.1.4   视图管理器	522
37.1.5   工具类	526
37.2   最佳实践	528
第38章   新模式	530
38.1   规格模式	530
38.1.1   规格模式的实现	530
38.1.2   最佳实践	543
38.2   对象池模式	546
38.2.1   正确的池化	546
38.2.2   对象池模式的意图	547
38.2.3   最佳实践	549
38.3   雇工模式	549
38.3.1   雇工合作	549
38.3.2   雇工模式的意图	551
38.3.3   最佳实践	552
38.4   黑板模式	552
38.4.1   黑板模式的意图	552
38.4.2   黑板模式的实现方法	553
38.5   空对象模式	554
38.5.1   空对象模式的例子	554
38.5.2   最佳实践	555
附录　23种设计模式彩图
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式之禅（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>反应式设计模式
第Ⅰ部分  简介
第1章  为什么需要反应式?   3
1.1  剖析反应式应用   5
1.2  应对负载   6
1.3  应对失败   7
1.4  让系统即时响应   9
1.5  避免大泥球   10
1.6  整合非反应式组件   11
1.7  小结   12
第2章  《反应式宣言》概览   13
2.1  对用户作出反应   13
2.1.1  理解传统方法   14
2.1.2  使用共享资源的延迟分析   16
2.1.3  使用队列限制最大延迟   17
2.2  利用并行性   18
2.2.1  通过并行化降低延迟   19
2.2.2  使用可组合的Future改善并行性   21
2.2.3  为序列式执行表象买单   22
2.3  并行执行的限制   24
2.3.1  阿姆达尔定律   24
2.3.2  通用伸缩性法则   25
2.4  对失败作出反应   26
2.4.1  划分与隔离   28
2.4.2  使用断路器   29
2.4.3  监督   30
2.5  放弃强一致性   32
2.5.1  ACID 2.0   33
2.5.2  接受更新   34
2.6  对反应式设计模式的需求   35
2.6.1  管理复杂性   36
2.6.2  使编程模型更贴近真实世界   37
2.7  小结   38
第3章  行业工具   39
3.1  反应式的早期解决方案   39
3.2  函数式编程   41
3.2.1  不可变性   42
3.2.2  引用透明性   44
3.2.3  副作用   45
3.2.4  函数作为一等公民   46
3.3  即时响应用户   47
3.4  对反应式设计的现有支持   49
3.4.1  绿色线程   49
3.4.2  事件循环   50
3.4.3  通信顺序进程   51
3.4.4  Future和Promise   53
3.4.5  反应式扩展工具包   58
3.4.6  Actor模型   59
3.5  小结   64
第Ⅱ部分  微言大义
第4章  消息传递   67
4.1  消息   67
4.2  垂直伸缩   68
4.3 “基于事件”与“基于消息”   69
4.4  “同步”与“异步”   71
4.5  流量控制   73
4.6  送达保证   75
4.7  作为消息的事件   77
4.8  同步消息传递   79
4.9  小结   79
第5章  位置透明性   81
5.1  什么是位置透明性？   81
5.2  透明化远程处理的谬误   82
5.3  基于显式消息传递的纠正方案   83
5.4  优化本地消息传递   84
5.5  消息丢失   85
5.6  水平扩展性   87
5.7  位置透明性使测试更加简单   88
5.8  动态组合   88
5.9  小结   90
第6章  分而治之   91
6.1  分层拆解问题   92
6.2 “依赖”与“子模块”   94
6.3  构建你自己的大公司   96
6.4  规范和测试的优点   97
6.5  水平扩展性和垂直伸缩性   98
6.6  小结   99
第7章  原则性失败处理   101
7.1  所有权意味着承诺   101
7.2  所有权隐含生命周期控制   103
7.3  所有级别上的回弹性   104
7.4  小结   105
第8章  有界一致性   107
8.1  封装模块纠正方案   108
8.2  根据事务边界对数据和行为进行分组   109
8.3  跨事务边界建模工作流   109
8.4  失败单元即一致性单元   110
8.5  分离职责   111
8.6  坚持一致性的隔离范围   113
8.7  小结   114
第9章  按需使用非确定性   115
9.1  逻辑编程和声明式数据流   115
9.2  函数式反应式编程   117
9.3  不共享简化并发   118
9.4  共享状态的并发   119
9.5  如何窘境突围？   119
9.6  小结   121
第10章  消息流   123
10.1  推动数据向前流动   123
10.2  模型化领域流程   125
10.3  认清回弹性的局限性   125
10.4  估计速率和部署规模   126
10.5  为流量控制进行规划   127
10.6  小结   127
第Ⅲ部分  设计模式
第11章  测试反应式应用程序   131
11.1  如何测试   131
11.1.1  单元测试   132
11.1.2  组件测试   133
11.1.3  联动测试   133
11.1.4  集成测试   133
11.1.5  用户验收测试   134
11.1.6  黑盒测试与白盒测试   134
11.2  测试环境   135
11.3  异步测试   136
11.3.1  提供阻塞的消息接收者   137
11.3.2  选择超时时间的难题   139
11.3.3  断言消息的缺失   145
11.3.4  提供同步执行引擎   146
11.3.5  异步断言   148
11.3.6  完全异步的测试   149
11.3.7  断言没有发生异步错误   151
11.4  测试非确定性系统   154
11.4.1  执行计划的麻烦   155
11.4.2  测试分布式组件   155
11.4.3  模拟Actor   156
11.4.4  分布式组件   157
11.5  测试弹性   157
11.6  测试回弹性   158
11.6.1  应用程序回弹性   158
11.6.2  基础设施的回弹性   162
11.7  测试即时响应性   164
11.8  小结   165
第12章  容错及恢复模式   167
12.1  简单组件模式   167
12.1.1  问题设定   168
12.1.2  模式应用   168
12.1.3  模式回顾   170
12.1.4  适用性   171
12.2  错误内核模式   171
12.2.1  问题设定   172
12.2.2  模式应用   172
12.2.3  模式回顾   175
12.2.4  适用性   176
12.3  放任崩溃模式   176
12.3.1  问题设定   177
12.3.2  模式应用   177
12.3.3  模式回顾   178
12.3.4  实现上的考虑   179
12.3.5  推论：心跳模式   180
12.3.6  推论：主动失败信号模式   180
12.4  断路器模式   181
12.4.1  问题设定   182
12.4.2  模式应用   182
12.4.3  模式回顾   186
12.4.4  适用性   187
12.5  小结   187
第13章  复制模式   189
13.1  主动-被动复制模式   190
13.1.1  问题设定   190
13.1.2  模式应用   191
13.1.3  模式回顾   203
13.1.4  适用性   204
13.2  多主复制模式   204
13.2.1  基于共识的复制   205
13.2.2  具有冲突检测与处理方案的复制方式   208
13.2.3  无冲突的可复制数据类型   210
13.3  主动-主动复制模式   217
13.3.1  问题设定   218
13.3.2  模式应用   218
13.3.3  模式回顾   225
13.3.4  与虚拟同步模型的关系   226
13.4  小结   227
第14章  资源管理模式   229
14.1  资源封装模式   229
14.1.1  问题设定   230
14.1.2  模式应用   230
14.1.3  模式回顾   236
14.1.4  适用性   237
14.2  资源借贷模式   237
14.2.1  问题设定   238
14.2.2  模式应用   238
14.2.3  模式回顾   240
14.2.4  适用性   241
14.2.5  实现上的考虑   242
14.2.6  变体：使用资源借贷模式进行局部公开   242
14.3  复杂命令模式   243
14.3.1  问题设定   243
14.3.2  模式应用   244
14.3.3  模式回顾   251
14.3.4  适用性   252
14.4  资源池模式   252
14.4.1  问题设定   253
14.4.2  模式应用   253
14.4.3  模式回顾   255
14.4.4  实现上的考虑   256
14.5  托管阻塞模式   257
14.5.1  问题设定   257
14.5.2  模式应用   258
14.5.3  模式回顾   260
14.5.4  适用性   261
14.6  小结   262
第15章  消息流模式   263
15.1  请求-响应模式   264
15.1.1  问题设定   264
15.1.2  模式应用   265
15.1.3  该模式的常见实例   267
15.1.4  模式回顾   272
15.1.5  适用性   272
15.2  消息自包含模式   273
15.2.1  问题设定   273
15.2.2  模式应用   274
15.2.3  模式回顾   276
15.2.4  适用性   277
15.3  询问模式   277
15.3.1  问题设定   278
15.3.2  模式应用   278
15.3.3  模式回顾   281
15.3.4  适用性   283
15.4  转发流模式   283
15.4.1  问题设定   283
15.4.2  模式应用   284
15.4.3  模式回顾   284
15.4.4  适用性   285
15.5  聚合器模式   285
15.5.1  问题设定   285
15.5.2  模式应用   286
15.5.3  模式回顾   289
15.5.4  适用性   290
15.6  事务序列模式   290
15.6.1  问题设定   291
15.6.2  模式应用   291
15.6.3  模式回顾   293
15.6.4  适用性   294
15.7  业务握手协议(或可靠投递模式)   294
15.7.1  问题设定   295
15.7.2  模式应用   295
15.7.3  模式回顾   300
15.7.4  适用性   301
15.8  小结   301
第16章  流量控制模式   303
16.1  拉取模式   303
16.1.1  问题设定   304
16.1.2  模式应用   304
16.1.3  模式回顾   306
16.1.4  适用性   307
16.2  托管队列模式   307
16.2.1  问题设定   308
16.2.2  模式应用   308
16.2.3  模式回顾   310
16.2.4  适用性   310
16.3  丢弃模式   311
16.3.1  问题设定   311
16.3.2  模式应用   311
16.3.3  模式回顾   313
16.3.4  适用性   316
16.4  限流模式   316
16.4.1  问题设定   316
16.4.2  模式应用   317
16.4.3  模式回顾   320
16.5  小结   320
第17章  状态管理和持久化模式   321
17.1  领域对象模式   321
17.1.1  问题设定   322
17.1.2  模式应用   322
17.1.3  模式回顾   326
17.2  分片模式   326
17.2.1  问题设定   326
17.2.2  模式应用   327
17.2.3  模式回顾   329
17.2.4  重要警告   329
17.3  事件溯源模式   330
17.3.1  问题设定   330
17.3.2  模式应用   330
17.3.3  模式回顾   333
17.3.4  适用性   333
17.4  事件流模式   334
17.4.1  问题设定   334
17.4.2  模式应用   334
17.4.3  模式回顾   336
17.4.4  适用性   337
17.5  小结   337
附录A  反应式系统图示   339
附录B  一个虚构的案例   341
附录C 《反应式宣言》正文   355
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>反应式设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构设计模式
目　　录
写给中文版读者的话
译者序
中文版序一
中文版序二
前言
引言
第1章　逃离单体地狱   / 1
1.1　迈向单体地狱的漫长旅程   / 2
1.1.1　FTGO应用程序的架构   / 3
1.1.2　单体架构的好处   / 4
1.1.3　什么是单体地狱   / 4
1.2　为什么本书与你有关   / 7
1.3　你会在本书中学到什么   / 8
1.4　拯救之道：微服务架构   / 8
1.4.1　扩展立方体和服务   / 9
1.4.2　微服务架构作为模块化的一种形式   / 11
1.4.3　每个服务都拥有自己的数据库   / 12
1.4.4　FTGO的微服务架构   / 12
1.4.5　微服务架构与SOA的异同   / 14
1.5　微服务架构的好处和弊端   / 15
1.5.1　微服务架构的好处   / 15
1.5.2　微服务架构的弊端   / 17
1.6　微服务架构的模式语言   / 19
1.6.1　微服务架构并不是“银弹”   / 20
1.6.2　模式和模式语言   / 21
1.6.3　微服务架构的模式语言概述   / 24
1.7　微服务之上：流程和组织   / 29
1.7.1　进行软件开发和交付的组织   / 30
1.7.2　进行软件开发和交付的流程   / 31
1.7.3　采用微服务架构时的人为因素   / 32
第2章　服务的拆分策略   / 34
2.1　微服务架构到底是什么   / 35
2.1.1　软件架构是什么，为什么它如此重要   / 35
2.1.2　什么是架构的风格   / 37
2.1.3　微服务架构是一种架构风格   / 40
2.2　为应用程序定义微服务架构   / 43
2.2.1　识别系统操作   / 45
2.2.2　根据业务能力进行服务拆分   / 50
2.2.3　根据子域进行服务拆分   / 53
2.2.4　拆分的指导原则   / 54
2.2.5　拆分单体应用为服务的难点   / 56
2.2.6　定义服务API   / 59
第3章　微服务架构中的进程间通信   / 63
3.1　微服务架构中的进程间通信概述   / 64
3.1.1　交互方式   / 64
3.1.2　在微服务架构中定义API   / 66
3.1.3　API的演化   / 67
3.1.4　消息的格式   / 69
3.2　基于同步远程过程调用模式的通信   / 70
3.2.1　使用REST   / 71
3.2.2　使用gRPC   / 74
3.2.3　使用断路器模式处理局部故障   / 75
3.2.4　使用服务发现   / 78
3.3　基于异步消息模式的通信   / 82
3.3.1　什么是消息传递   / 83
3.3.2　使用消息机制实现交互方式   / 84
3.3.3　为基于消息机制的服务API创建API规范   / 86
3.3.4　使用消息代理   / 87
3.3.5　处理并发和消息顺序   / 91
3.3.6　处理重复消息   / 92
3.3.7　事务性消息   / 93
3.3.8　消息相关的类库和框架   / 97
3.4　使用异步消息提高可用性   / 99
3.4.1　同步消息会降低可用性   / 99
3.4.2　消除同步交互   / 101
第4章　使用Saga管理事务　   / 106
4.1　微服务架构下的事务管理   / 107
4.1.1　微服务架构对分布式事务的需求   / 108
4.1.2　分布式事务的挑战   / 109
4.1.3　使用Saga模式维护数据一致性   / 109
4.2　Saga的协调模式   / 113
4.2.1　协同式Saga   / 113
4.2.2　编排式Saga   / 117
4.3　解决隔离问题   / 121
4.3.1　缺乏隔离导致的问题   / 122
4.3.2　Saga模式下实现隔离的对策   / 123
4.4　Order Service和Create Order Saga的设计   / 127
4.4.1　OrderService类   / 128
4.4.2　Create Order Saga的实现   / 129
4.4.3　OrderCommandHandlers类   / 136
4.4.4　OrderServiceConfiguration类   / 138
第5章　微服务架构中的业务逻辑设计   / 141
5.1　业务逻辑组织模式   / 142
5.1.1　使用事务脚本模式设计业务逻辑   / 143
5.1.2　使用领域模型模式设计业务逻辑   / 144
5.1.3　关于领域驱动设计   / 146
5.2　使用聚合模式设计领域模型   / 146
5.2.1　模糊边界所带来的问题   / 147
5.2.2　聚合拥有明确的边界   / 149
5.2.3　聚合的规则   / 150
5.2.4　聚合的颗粒度   / 152
5.2.5　使用聚合设计业务逻辑   / 153
5.3　发布领域事件   / 154
5.3.1　为什么需要发布变更事件   / 154
5.3.2　什么是领域事件   / 155
5.3.3　事件增强   / 155
5.3.4　识别领域事件   / 156
5.3.5　生成和发布领域事件   / 157
5.3.6　消费领域事件   / 161
5.4　Kitchen Service的业务逻辑   / 162
5.5　Order Service的业务逻辑   / 167
5.5.1　Order聚合   / 169
5.5.2　 OrderService类   / 173
第6章　使用事件溯源开发业务逻辑   / 176
6.1　使用事件溯源开发业务逻辑概述   / 177
6.1.1　传统持久化技术的问题   / 177
6.1.2　什么是事件溯源   / 179
6.1.3　使用乐观锁处理并发更新   / 186
6.1.4　事件溯源和发布事件   / 186
6.1.5　使用快照提升性能   / 188
6.1.6　幂等方式的消息处理   / 189
6.1.7　领域事件的演化   / 190
6.1.8　事件溯源的好处   / 192
6.1.9　事件溯源的弊端   / 193
6.2　实现事件存储库   / 194
6.2.1　Eventuate Local事件存储库的工作原理   / 195
6.2.2　Eventuate的Java客户端框架   / 198
6.3　同时使用Saga和事件溯源   / 201
6.3.1　使用事件溯源实现协同式Saga   / 203
6.3.2　创建编排式Saga   / 203
6.3.3　实现基于事件溯源的Saga参与方   / 205
6.3.4　实现基于事件溯源的Saga编排器   / 208
第7章　在微服务架构中实现查询   / 212
7.1　使用API组合模式进行查询   / 213
7.1.1　findOrder()查询操作   / 213
7.1.2　什么是API组合模式   / 214
7.1.3　使用API组合模式实现findOrder()查询操作   / 215
7.1.4　API组合模式的设计缺陷   / 216
7.1.5　API组合模式的好处和弊端   / 219
7.2　使用CQRS模式   / 220
7.2.1　为什么要使用CQRS   / 220
7.2.2　什么是CQRS   / 223
7.2.3　CQRS的好处   / 226
7.2.4　CQRS的弊端   / 227
7.3　设计CQRS视图   / 228
7.3.1　选择视图存储库   / 229
7.3.2　设计数据访问模块   / 230
7.3.3　添加和更新CQRS视图   / 232
7.4　实现基于AWS DynamoDB的CQRS视图   / 233
7.4.1　OrderHistoryEventHandlers模块   / 234
7.4.2　DynamoDB中的数据建模和查询设计   / 235
7.4.3　OrderHistoryDaoDynamoDb类   / 239
第8章　外部API模式   / 244
8.1　外部API的设计难题   / 245
8.1.1　FTGO移动客户端API的设计难题   / 246
8.1.2　其他类型客户端API的设计难题   / 248
8.2　API Gateway模式   / 250
8.2.1　什么是API Gateway模式   / 250
8.2.2　API Gateway模式的好处和弊端   / 256
8.2.3　以Netflix为例的API Gateway   / 257
8.2.4　API Gateway的设计难题   / 258
8.3　实现一个API Gateway   / 260
8.3.1　使用现成的API Gateway产品或服务   / 261
8.3.2　开发自己的API Gateway   / 262
8.3.3　使用GraphQL实现API Gateway   / 269
第9章　微服务架构中的测试策略（上）   / 282
9.1　微服务架构中的测试策略概述   / 284
9.1.1　什么是测试   / 284
9.1.2　微服务架构中的测试挑战   / 289
9.1.3　部署流水线   / 295
9.2　为服务编写单元测试   / 296
9.2.1　为实体编写单元测试   / 298
9.2.2　为值对象编写单元测试   / 299
9.2.3　为Saga编写单元测试   / 300
9.2.4　为领域服务编写单元测试   / 302
9.2.5　为控制器编写单元测试   / 303
9.2.6　为事件和消息处理程序编写单元测试   / 305
第10章　微服务架构中的测试策略（下）   / 308
10.1　编写集成测试   / 308
10.1.1　针对持久化层的集成测试   / 311
10.1.2　针对基于REST的请求/响应式交互的集成测试   / 312
10.1.3　针对发布/订阅式交互的集成测试   / 316
10.1.4　针对异步请求/响应式交互的集成契约测试   / 320
10.2　编写组件测试   / 324
10.2.1　定义验收测试   / 325
10.2.2　使用Gherkin编写验收测试   / 326
10.2.3　设计组件测试   / 328
10.2.4　为FTGO的Order Service编写组件测试   / 330
10.3　端到端测试   / 334
10.3.1　设计端到端测试   / 335
10.3.2　编写端到端测试   / 335
10.3.3　运行端到端测试   / 336
第11章　开发面向生产环境的微服务应用   / 338
11.1　开发安全的服务   / 339
11.1.1　传统单体应用程序的安全性   / 340
11.1.2　在微服务架构中实现安全性   / 343
11.2　设计可配置的服务   / 349
11.2.1　使用基于推送的外部化配置   / 350
11.2.2　使用基于拉取的外部化配置   / 352
11.3　设计可观测的服务   / 353
11.3.1　使用健康检查API模式   / 355
11.3.2　使用日志聚合模式   / 357
11.3.3　使用分布式追踪模式   / 358
11.3.4　使用应用程序指标模式   / 361
11.3.5　使用异常追踪模式   / 364
11.3.6　使用审计日志模式   / 365
11.4　使用微服务基底模式开发服务   / 367
11.4.1　使用微服务基底   / 368
11.4.2　从微服务基底到服务网格   / 368
第12章　部署微服务应用   / 371
12.1　部署模式：编程语言特定的发布包格式   / 374
12.1.1　使用编程语言特定的发布包格式进行部署的好处   / 376
12.1.2　使用编程语言特定的发布包格式进行部署的弊端   / 377
12.2　部署模式：将服务部署为虚拟机   / 378
12.2.1　将服务部署为虚拟机的好处   / 380
12.2.2　将服务部署为虚拟机的弊端   / 380
12.3　部署模式：将服务部署为容器   / 381
12.3.1　使用Docker部署服务   / 383
12.3.2　将服务部署为容器的好处   / 385
12.3.3　将服务部署为容器的弊端   / 386
12.4　使用Kubernetes部署FTGO应用程序   / 386
12.4.1　什么是Kubernetes   / 386
12.4.2　在Kubernetes上部署Restaurant Service   / 389
12.4.3　部署API Gateway   / 392
12.4.4　零停机部署   / 393
12.4.5　使用服务网格分隔部署与发布流程   / 394
12.5　部署模式：Serverless部署   / 402
12.5.1　使用AWS Lambda进行Serverless部署   / 403
12.5.2　开发Lambda函数   / 404
12.5.3　调用Lambda函数   / 404
12.5.4　使用Lambda函数的好处   / 405
12.5.5　使用Lambda函数的弊端   / 406
12.6　使用AWS Lambda和AWS Gateway部署RESTful服务   / 406
12.6.1　AWS Lambda版本的Restaurant Service   / 407
12.6.2　把服务打包为ZIP文件   / 411
12.6.3　使用Serverless框架部署Lambda函数   / 412
第13章　微服务架构的重构策略   / 415
13.1　重构到微服务需要考虑的问题   / 416
13.1.1　为什么要重构单体应用   / 416
13.1.2　绞杀单体应用   / 417
13.2　将单体应用重构为微服务架构的若干策略   / 420
13.2.1　将新功能实现为服务   / 420
13.2.2　隔离表现层与后端   / 422
13.2.3　提取业务能力到服务中   / 423
13.3　设计服务与单体的协作方式   / 429
13.3.1　设计集成胶水   / 430
13.3.2　在服务和单体之间维持数据一致性   / 434
13.3.3　处理身份验证和访问授权   / 438
13.4　将新功能实现为服务：处理错误配送订单   / 440
13.4.1　Delayed Delivery Service的设计   / 441
13.4.2　为Delayed Delivery Service设计集成胶水   / 442
13.5　从单体中提取送餐管理功能   / 444
13.5.1　现有的送餐管理功能   / 444
13.5.2　Delivery Service概览   / 446
13.5.3　设计Delivery Service的领域模型   / 447
13.5.4　Delivery Service集成胶水的设计   / 450
13.5.5　修改FTGO单体使其能够与Delivery Service交互   / 451
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Python设计模式
第一部分　创建型模式
第1章　工厂模式　　2
1.1　工厂方法　　2
1.1.1　现实生活的例子　　2
1.1.2　软件的例子　　3
1.1.3　应用案例　　3
1.1.4　实现　　4
1.2　抽象工厂　　11
1.2.1　现实生活的例子　　11
1.2.2　软件的例子　　12
1.2.3　应用案例　　12
1.2.4　实现　　12
1.3　小结　　17
第2章　建造者模式　　18
2.1　现实生活的例子　　18
2.2　软件的例子　　19
2.3　应用案例　　19
2.4　实现　　22
2.5　小结　　29
第3章　原型模式　　30
3.1　现实生活的例子　　31
3.2　软件的例子　　32
3.3　应用案例　　32
3.4　实现　　33
3.5　小结　　37
第二部分　结构型模式
第4章　适配器模式　　40
4.1　现实生活的例子　　40
4.2　软件的例子　　41
4.3　应用案例　　41
4.4　实现　　42
4.5　小结　　45
第5章　修饰器模式　　46
5.1　现实生活的例子　　46
5.2　软件的例子　　47
5.3　应用案例　　48
5.4　实现　　48
5.5　小结　　52
第6章　外观模式　　53
6.1　现实生活的例子　　54
6.2　软件的例子　　54
6.3　应用案例　　54
6.4　实现　　55
6.5　小结　　60
第7章　享元模式　　61
7.1　现实生活的例子　　62
7.2　软件的例子　　62
7.3　应用案例　　62
7.4　实现　　62
7.5　小结　　66
第8章　模型—视图—控制器模式　　67
8.1　现实生活的例子　　68
8.2　软件的例子　　68
8.3　应用案例　　68
8.4　实现　　70
8.5　小结　　73
第9章　代理模式　　74
9.1　现实生活的例子　　76
9.2　软件的例子　　77
9.3　应用案例　　77
9.4　实现　　78
9.5　小结　　81
第三部分　行为型模式
第10章　责任链模式　　84
10.1　现实生活的例子　　85
10.2　软件的例子　　86
10.3　应用案例　　86
10.4　实现　　87
10.5　小结　　91
第11章　命令模式　　92
11.1　现实生活的例子　　92
11.2　软件的例子　　93
11.3　应用案例　　93
11.4　实现　　94
11.5　小结　　99
第12章　解释器模式　　101
12.1　现实生活的例子　　102
12.2　软件的例子　　102
12.3　应用案例　　103
12.4　实现　　103
12.5　小结　　109
第13章　观察者模式　　110
13.1　现实生活的例子　　110
13.2　软件的例子　　111
13.3　应用案例　　111
13.4　实现　　112
13.5　小结　　117
第14章　状态模式　　118
14.1　现实生活的例子　　119
14.2　软件的例子　　120
14.3　应用案例　　120
14.4　实现　　121
14.5　小结　　126
第15章　策略模式　　127
15.1　现实生活的例子　　128
15.2　软件的例子　　128
15.3　应用案例　　130
15.4　实现　　130
15.5　小结　　134
第16章　模板模式　　135
16.1　现实生活的例子　　139
16.2　软件的例子　　140
16.3　应用案例　　141
16.4　实现　　141
16.5　小结　　143
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Python设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式的艺术
第1部分基 础 知 识
第1章从招式与内功谈起——设计模式概述
1.1设计模式从何而来
1.2设计模式是什么
1.3设计模式有什么用
1.4个人观点
1.5知识回顾
第2章预备知识——UML类图与面向对象设计原则
2.1UML概述
2.2类与类的UML图示
2.3类之间的关系
2.4面向对象设计原则概述
2.5单一职责原则
2.6开闭原则
2.7里氏代换原则
2.8依赖倒转原则
2.9接口隔离原则
2.10合成复用原则
2.11迪米特法则
2.12知识回顾
第2部分创建的艺术——创建型模式
第3章确保对象的唯一性——单例模式
3.1单例模式的动机
3.2单例模式概述
3.3负载均衡器的设计
3.4饿汉式单例与懒汉式单例的讨论
3.5一种更好的单例实现方法
3.6单例模式总结
3.7知识回顾
第4章集中式工厂的实现——简单工厂模式
4.1图表库的设计
4.2简单工厂模式概述
4.3完整解决方案
4.4方案的改进
4.5创建对象与使用对象
4.6简单工厂模式的简化
4.7简单工厂模式总结
4.8知识回顾
第5章多态工厂的实现——工厂方法模式
5.1日志记录器的设计
5.2工厂方法模式概述
5.3完整解决方案
5.4反射与配置文件
5.5重载的工厂方法
5.6工厂方法的隐藏
5.7工厂方法模式总结
5.8知识回顾
第6章产品族的创建——抽象工厂模式
6.1界面皮肤库的初始设计
6.2产品等级结构与产品族
6.3抽象工厂模式概述
6.4完整解决方案
6.5开闭原则的倾斜性
6.6抽象工厂模式总结
6.7知识回顾
第7章对象的克隆——原型模式
7.1大同小异的工作周报
7.2原型模式概述
7.3完整解决方案
7.4带附件的周报
7.5原型管理器的引入和实现
7.6原型模式总结
7.7知识回顾
第8章复杂对象的组装与创建——建造者模式
8.1游戏角色设计
8.2建造者模式概述
8.3完整解决方案
8.4关于Director的进一步讨论
8.5建造者模式总结
8.6知识回顾
第3部分组合的艺术——结构型模式
第9章不兼容结构的协调——适配器模式
9.1没有源码的算法库
9.2适配器模式概述
9.3完整解决方案
9.4类适配器模式
9.5双向适配器模式
9.6缺省适配器模式
9.7适配器模式总结
9.8知识回顾
第10章处理多维度变化——桥接模式
10.1跨平台图像浏览系统
10.2桥接模式概述
10.3完整解决方案
10.4适配器模式与桥接模式的联用
10.5桥接模式总结
10.6知识回顾
第11章树形结构的处理——组合模式
11.1设计杀毒软件的框架结构
11.2组合模式概述
11.3完整解决方案
11.4透明组合模式与安全组合模式
11.5Sunny公司组织结构
11.6组合模式总结
11.7知识回顾
第12章扩展系统功能——装饰模式
12.1图形界面构件库的设计
12.2装饰模式概述
12.3完整解决方案
12.4透明装饰模式与半透明装饰模式
12.5装饰模式注意事项
12.6装饰模式总结
12.7知识回顾
第13章提供统一入口——外观模式
13.1文件加密模块的设计
13.2外观模式概述
13.3完整解决方案
13.4抽象外观类的引入
13.5外观角色设计补充说明
13.6外观模式总结
13.7知识回顾
第14章实现对象的复用——享元模式
14.1围棋棋子的设计
14.2享元模式概述
14.3完整解决方案
14.4带外部状态的解决方案
14.5单纯享元模式和复合享元模式
14.6关于享元模式的几点补充
14.7享元模式总结
14.8知识回顾
第15章对象的间接访问——代理模式
15.1收费商务信息查询系统的设计
15.2代理模式概述
15.3完整解决方案
15.4远程代理
15.5虚拟代理
15.6Java动态代理
15.7代理模式总结
15.8知识回顾
第4部分交互的艺术——行为型模式
第16章请求的链式处理——职责链模式
16.1采购单的分级审批
16.2职责链模式概述
16.3完整解决方案
16.4纯与不纯的职责链模式
16.5职责链模式总结
16.6知识回顾
第17章请求发送者与接收者解耦——命令模式
17.1自定义功能键
17.2命令模式概述
17.3完整解决方案
17.4命令队列的实现
17.5撤销操作的实现
17.6请求日志
17.7宏命令
17.8命令模式总结
17.9知识回顾
第18章自定义语言的实现——解释器模式
18.1机器人控制程序
18.2文法规则和抽象语法树
18.3解释器模式概述
18.4完整解决方案
18.5再谈Context的作用
18.6解释器模式总结
18.7知识回顾
第19章遍历聚合对象中的元素——迭代器模式
19.1销售管理系统中数据的遍历
19.2迭代器模式概述
19.3完整解决方案
19.4使用内部类实现迭代器
19.5JDK内置迭代器
19.6迭代器模式总结
19.7知识回顾
第20章协调多个对象之间的交互——中介者模式
20.1客户信息管理窗口的初始设计
20.2中介者模式概述
20.3完整解决方案
20.4中介者与同事类的扩展
20.5中介者模式总结
20.6知识回顾
第21章撤销功能的实现——备忘录模式
21.1可悔棋的中国象棋
21.2备忘录模式概述
21.3完整解决方案
21.4实现多次撤销
21.5再谈备忘录的封装
21.6备忘录模式总结
21.7知识回顾
第22章对象间的联动——观察者模式
22.1多人联机对战游戏的设计
22.2观察者模式概述
22.3完整解决方案
22.4JDK对观察者模式的支持
22.5观察者模式与Java事件处理
22.6观察者模式与MVC
22.7观察者模式总结
22.8知识回顾
第23章对象状态及其转换——状态模式
23.1银行系统中的账户类设计
23.2状态模式概述
23.3完整解决方案
23.4共享状态
23.5使用环境类实现状态转换
23.6状态模式总结
23.7知识回顾
第24章算法的封装与切换——策略模式
24.1电影票打折方案
24.2策略模式概述
24.3完整解决方案
24.4策略模式的两个典型应用
24.5策略模式总结
24.6知识回顾
第25章定义算法的框架——模板方法模式
25.1银行利息计算模块
25.2模板方法模式概述
25.3完整解决方案
25.4钩子方法的使用
25.5模板方法模式总结
25.6知识回顾
第26章操作复杂对象结构——访问者模式
26.1OA系统中员工数据汇总
26.2访问者模式概述
26.3完整解决方案
26.4访问者模式与组合模式联用
26.5访问者模式总结
26.6知识回顾
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式的艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++设计新思维
译序by 侯捷	i
译序by 於春景	iii
目录	 v
序言by scott meyers	 xi
序言by john vlissides	 xv
前言	 xvii
致谢	 xxi
第一篇 技术（techniques）	1
第1章	基于policy的class设计（policy-based class design）	3
1.1	软件设计的多样性（multiplicity）	 3
1.2	全功能型（do-it-all）接口的失败	 4
1.3	多重继承（multiple inheritance）是救世主？	5
1.4	templates带来曙光	 6
1.5	policies和policy classes	 7
1.6	更丰富的policies	 12
1.7	policy classes的析构函数（destructors）	 12
1.8	通过不完全具现化（incomplete instantiation）而获得的选择性机能（optional functionality）	 13
1.9	结合policy classes	14
.	1.10	以policy classes定制结构	16
1.11	policies的兼容性	 17
1.12	将一个class分解为一堆policies	 19
1.13	摘要	 20
第2章	技术（techniques）	 23
2.1	编译期（compile-time）assertions	23
2.2	partial template specialization（模板偏特化）	26
2.3	局部类（local classes）	 28
2.4	常整数映射为型别（mapping integral constants to types）	29
2.5	型别对型别的映射（type-to-type mapping）	31
2.6	型别选择（type selection）	 33
2.7	编译期间侦测可转换性（convertibility）和继承性（inheritance）	34
2.8	type_info的一个外覆类（wrapper）	37
2.9	nulltype和emptytype	 39
2.10	type traits	 40
2.11	摘要	 46
第3章	typelists	 49
3.1	typelists的必要性 49
3.2	定义typelists	 51
3.3	将typelist的生成线性化（linearizing）	52
3.4	计算长度	 53
3.5	间奏曲	 54
3.6	索引式访问（indexed access）	55
3.7	查找typelists	 56
3.8	附加元素至typelists	 57
3.9	移除typelist中的某个元素	58
3.10	移除重复元素（erasing duplicates）59
3.11	取代typelist中的某个元素	60
3.12	为typelists局部更换次序（partially ordering）	61
3.13	运用typelists自动产生classes	 64
3.14	摘要	 74
3.15	typelist要点概览	 75
第4章	小型对象分配技术（small-object allocation）	 77
4.1	缺省的free store分配器	 78
4.2	内存分配器的工作方式	 78
4.3	小型对象分配器（small-object allocator）	80
4.4	chunks（大块内存）	 81
4.5	大小一致（fixed-size）的分配器	84
4.6	smallobjallocator class	 87
4.7	帽子下的戏法	 89
4.8	简单，复杂，终究还是简单	92
4.9	使用细节	 93
4.10	摘要	 94
4.11	小型对象分配器（small-object allocator）要点概览	94
第二篇	组件（components）	 97
第5章	泛化仿函数（generalized functors）	99
5.1	command设计模式	 100
5.2	真实世界中的command	 102
5.3	c++ 中的可呼叫体（callable entities）	 103
5.4	functor class template骨干	104
5.5	实现“转发式”（forwarding）functor::operator()	 108
5.6	处理仿函数	 110
5.7	做一个，送一个	 112
5.8	引数（argument）和返回型别（return type）的转换	 114
5.9	处理pointer to member function（成员函数指针）	 115
5.10	绑定（binding）	 119
5.11	将请求串接起来（chaining requests）	122
5.12	现实世界中的问题之1：转发式函数的成本	122
5.13	现实世界中的问题之2：heap分配	 124
5.14	通过functor实现undo和redo	 125
5.15	摘要	 126
5.16	functor要点概览	 126
第6章	singletons（单件）实现技术	 129
6.1	静态数据 + 静态函数 != singleton	130
6.2	用以支持singleton的一些c++ 基本手法	131
6.3	实施“singleton的唯一性”	 132
6.4	摧毁singleton	 133
6.5	dead（失效的）reference问题	 135
6.6	解决dead reference问题（i）：phoenix singleton	 137
6.7	解决dead reference问题（ii）：带寿命的singletons	139
6.8	实现“带寿命的singletons”	 142
6.9	生活在多线程世界	 145
6.10	将一切组装起来	 148
6.11	使用singletonholder	 153
6.12	摘要	 155
6.13	singletonholder class template要点概览	155
第7章	smart pointers（智能指针）	157
7.1	smart pointers基础	157
7.2	交易	 158
7.3	smart pointers的存储	160
7.4	smart pointer的成员函数	161
7.5	拥有权（ownership）管理策略	 163
7.6	address-of（取址）操作符	 170
7.7	隐式转换（implicit conversion）至原始指针型别	 171
7.8	相等性（equality）和不等性（inequality）	 173
7.9	次序比较（ordering comparisons）	178
7.10	检测及错误报告（checking and error reporting）	 181
7.11	smart pointers to const和const smart pointers	 182
7.12	arrays	 183
7.13	smart pointers和多线程（multithreading）	184
7.14	将一切组装起来	187
7.15	摘要	 194
7.16	smartptr要点概览194
第8章	object factories（对象工厂）	197
8.1	为什么需要object factories	198
8.2	object factories in c++：classes和objects	200
8.3	实现一个object factory	 201
8.4	型别标识符（type identifiers）	206
8.5	泛化（generalization）	 207
8.6	细节琐务	210
8.7	clone factories（克隆工厂、翻制工厂、复制工厂）	211
8.8	通过其他泛型组件来使用object factories	 215
8.9	摘要	 216
8.10	factory class template要点概览	 216
8.11	clonefactory class template要点概览	217
第9章	abstract factory（抽象工厂）	219
9.1	abstract factory扮演的体系结构角色（architectural role）	219
9.2	一个泛化的abstract factory接口	 223
9.3	实作出abstractfactory	 226
9.4	一个prototype-based abstract factory实作品	228
9.5	摘要	233
9.6	abstractfactory和concretefactory要点概览	233
第10章	visitor（访问者、视察者）	235
10.1	visitor 基本原理	235
10.2	重载（overloading）：catch-all函数	 242
10.3	一份更加精炼的实作品：acyclic visitor	 243
10.4	visitor之泛型实作	248
10.5	再论 "cyclic" visitor	255
10.6	变化手段	 258
10.7	摘要	 260
10.8	visitor泛型组件要点概览	 261
第11章	multimethods	 263
11.1	什么是multimethods?	264
11.2	何时需要multimethods？	264
11.3	double switch-on-type：暴力法	265
11.4	将暴力法自动化	 268
11.5	暴力式dispatcher 的对称性	273
11.6	对数型（logarithmic）double dispatcher	276
11.7	fndispatcher 和对称性	 282
11.8	double dispatch（双重分派）至仿函数（functors）	282
11.9	引数的转型：static_cast或dynamic_cast？	 285
11.10	常数时间的multimethods：原始速度（raw speed）	290
11.11	将basicdispatcher 和basicfastdispatcher当做policies	293
11.12	展望	294
11.13	摘要	296
11.14	double dispatcher要点概览	297
附录	一个超迷你的多线程程序库（a minimalist multithreading library）	301
a.1	多线程的反思	302
a.2	loki的作法	303
a.3	整数型别上的原子操作（atomic operations）	303
a.4	mutexes（互斥器）	305
a.5	面向对象编程中的锁定语意（locking semantics）	306
a.6	可有可无的（optional）volatile标识符	308
a.7	semaphores, events和其他好东西	 309
a.8	摘要	309
参考书目（bibliography）	311
索引（index）	 313
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++设计新思维
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式解析
第一部分　面向对象软件开发简介
第1章　面向对象范型 3
1.1 概览 3
1.2 面向对象范型之前：功能分解 3
1.3 需求问题 5
1.4 应对变化：使用功能分解 6
1.5 应对需求变更 8
1.6 面向对象范型 11
1.7 面向对象程序设计实践 16
1.7 特殊对象方法 18
1.8 小结 19
复习题 20
简答题 20
阐述题 21
观点与应用题 21
第2章　UML 22
2.1 概览 22
2.2 什么是UML 22
2.3 为什么使用UML 23
2.4 类图 23
2.5 交互图 29
2.6 小结 31
复习题 31
简答题 31
阐述题 31
观点与应用题 31
第二部分 传统面向对象设计的局限
第3章　对代码灵活性要求很高的问题 35
3.1 概览 35
3.2 提取CAD/CAM系统的信息 35
3.3 了解专业术语 36
3.4 问题描述 37
3.5 挑战及其解决方案 39
3.6 小结 41
复习题 42
简答题 42
阐述题 42
观点与应用题 42
第4章　标准的面向对象解决方案 43
4.1 概览 43
4.2 作为特例来解决 43
4.3 小结 50
复习题 51
简答题 51
阐述题 51
观点与应用题 51
第三部分 设 计 模 式
第5章　设计模式简介 55
5.1 概览 55
5.2 设计模式源自建筑学和人类学 55
5.3 从建筑模式到软件设计模式 59
5.4 为什么学习设计模式 60
5.5 学习设计模式的其他好处 64
5.6 小结 65
复习题 65
简答题 65
阐述题 66
观点与应用题 66
第6章　Facade模式 67
6.1 概览 67
6.2 Facade模式简介 67
6.3 学习Facade模式 67
6.4 实践注记：Facade模式 70
6.5 Facade模式与CAD／CAM问题的联系 71
6.6 小结 72
复习题 72
简答题 72
阐述题 72
观点与应用题 73
第7章　Adapter模式 74
7.1 概览 74
7.2 Adapter模式简介 74
7.3 学习Adapter模式 75
7.4 实践注记：Adapter模式 79
7.5 Adapter模式与CAD/CAM问题的联系 82
7.6 小结 82
复习题 82
简答题 82
阐述题 83
观点与应用题 83
第8章　开拓视野 84
8.1 概览 84
8.2 对象：传统看法与新看法 85
8.3 封装：传统看法与新看法 86
8.4 发现变化并将其封装 89
8.5 共性和可变性分析与抽象类 92
8.6 敏捷编程的品质 94
8.7 小结 97
复习题 98
简答题 98
阐述题 98
观点与应用题 99
第9章　Strategy模式 100
9.1 概览 100
9.2 处理新需求的一种途径 100
9.3 国际电子商务系统案例研究：最初的需求 102
9.4 处理新的需求 103
9.5 Strategy模式 110
9.6 实践注记：使用Strategy模式 112
9.7 小结 113
复习题 114
简答题 114
阐述题 114
观点与应用题 114
第10章　Bridge模式 115
10.1 概览 115
10.2 Bridge模式简介 115
10.3 学习Bridge模式：示例 116
10.4 对使用设计模式的观察 125
10.5 学习Bridge模式：通过将它推演出来 126
10.6 Bridge模式回顾 133
10.7 实践注记：使用Bridge模式 134
10.8 小结 137
复习题 139
简答题 139
阐述题 139
观点与应用题 139
第11章　Abstract Factory模式 140
11.1 概览 140
11.2 Abstract Factory模式简介 140
11.3 学习Abstract Factory模式：示例 140
11.4 学习Abstract Factory模式：实现该模式 146
11.5 实践注记：Abstract Factory模式 151
11.6 将Abstract Factory模式与CAD/CAM问题联系起来 153
11.7 小结 153
复习题 154
简答题 154
阐述题 154
观点与应用题 154
第四部分 组合起来：用模式思考
第12章　专家设计之道 157
12.1 概览 157
12.2 添加特征的创建方式 157
12.3 小结 163
复习题 163
简答题 163
阐述题 164
观点与应用题 164
第13章　用模式解决CAD/CAM问题 165
13.1 概览 165
13.2 对CAD/CAM问题的回顾 165
13.3 用模式思考 166
13.4 用模式思考：步骤1 167
13.5 用模式思考：步骤2a 168
13.6 用模式思考：步骤2b 172
13.7 用模式思考：步骤2c 175
13.8 用模式思考：重复步骤2a和2b（Facade模式） 176
13.9 用模式思考：重复步骤2a和2b（Adapter模式） 177
13.10 用模式思考：重复步骤2a和2b（Abstract Factory模式） 177
13.11 用模式思考：步骤3 178
13.12 与原解决方案的比较 178
13.13 小结 179
复习题 180
简答题 180
阐述题 180
观点与应用题 180
第五部分 迈向新的设计方式
第14章　设计模式的原则与策略 183
14.1 概览 183
14.2 开闭原则 184
14.3 从背景设计原则 184
14.4 封装变化原则 188
14.5 抽象类与接口 189
14.6 理性怀疑原则 190
14.7 小结 190
复习题 191
简答题 191
阐述题 191
观点与应用题 191
第15章　共性与可变性分析 192
15.1 概览 192
15.2 共性和可变性分析与应用程序设计 192
15.3 用CVA解决CAD/CAM问题 193
15.4 小结 197
复习题 197
简答题 197
阐述题 197
观点与应用题 198
第16章　分析矩阵 199
16.1 概览 199
16.2 现实世界：充满变化 199
16.3 国际电子商务系统案例研究：应对变化 200
16.4 实践注记 206
16.5 小结 209
复习题 209
简答题 209
阐述题 209
观点与应用题 209
第17章　Decorator模式 210
17.1 概览 210
17.2 更多细节 210
17.3 Decorator模式 212
17.4 将Decorator模式应用到我们的案例研究 213
17.5 另一个例子：输入/输出 216
17.6 实践注记：使用Decorator模式 218
17.7 Decorator模式的本质 219
17.8 小结 220
复习题 220
简答题 220
阐述题 220
观点与应用题 220
第六部分 其他重要模式
第18章　Observer模式 223
18.1 概览 223
18.2 模式的分类 223
18.3 国际电子商务案例的更多需求 224
18.4 Observer模式 225
18.5 将Observer模式应用到我们的案例研究 226
18.6 实践注记：使用Observer模式 230
18.7 小结 232
复习题 232
简答题 232
阐述题 233
观点与应用题 233
第19章　Template Method模式 234
19.1 概览 234
19.2 案例研究的更多需求 234
19.3 Template Method模式 235
19.4 将Template Method模式应用到我们的案例研究 235
19.5 使用Template Method模式减少冗余 236
19.6 实践注记：使用Template Method模式 241
19.7 小结 242
复习题 243
简答题 243
阐述题 243
第七部分 各种工厂模式
第20章　来自设计模式的教益：各种工厂模式 247
20.1 概览 247
20.2 工厂 247
20.3 再谈背景 248
20.4 工厂遵循我们的准则 250
20.5 限制变化的影响 251
20.6 对工厂的另一种思考方式 251
20.7 工厂的不同角色 252
20.8 实践注记 252
20.9 小结 253
复习题 253
简答题 253
阐述题 253
观点与应用题 253
第21章　Singleton模式和Double-CheckedLocking模式 254
21.1 概览 254
21.2 Singleton模式简介 254
21.3 将Singleton模式应用到我们的案例研究 255
21.4 一种变体：Double-Checked Locking模式 257
21.5 反思 260
21.6 实践注记：使用Singleton模式和 260
Double-Checked Locking模式 260
21.7 小结 261
复习题 261
简答题 261
阐述题 261
观点与应用题 261
第22章　Object Pool模式 262
22.1 概览 262
22.2 一个需要对对象进行管理的问题 262
22.3 Object Pool模式 268
22.4 观察：工厂的作用不仅是实例化 268
22.5 小结 270
复习题 270
简答题 270
阐述题 271
观点与应用题 271
第23章　Factory Method模式 272
23.1 概览 272
23.2 案例研究的更多需求 272
23.3 Factory Method模式 273
23.4 Factory Method模式与面向对象语言 273
23.5 实践注记：使用Factory Method模式 274
23.6 小结 275
复习题 276
简答题 276
阐述题 276
观点与应用题 276
第24章　工厂模式的总结 277
24.1 概览 277
24.2 软件开发过程中的步骤 277
24.3 工厂与极限编程实践殊途同归 278
24.4 系统的扩展性 278
第八部分 终点与起点
第25章　设计模式回顾：总结与新起点 283
25.1 概览 283
25.2 面向对象原则的总结 283
25.3 设计模式如何封装实现 284
25.4 共性和可变性分析与设计模式 284
25.5 按责任分解问题域 285
25.6 模式和从背景设计 286
25.7 模式内部的关联 286
25.8 设计模式与敏捷编程实践 288
25.9 实践注记 288
25.10 小结 288
复习题 289
简答题 289
阐述题 289
观点与应用题 289
第26章　参考书目 290
26.1 本书配套网站 290
26.2 推荐阅读 291
26.3 针对Java程序员的推荐读物 292
26.4 针对C++程序员的推荐读物 293
26.5 针对COBOL程序员的推荐读物 294
26.6 极限编程的推荐读物 294
26.7 程序设计的一般性推荐读物 294
26.8 个人推荐 295
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式解析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>界面设计模式（第2版）
第2版介绍 ............................................................................ xii
前言 .................................................................................... xvi
第1章 用户做些什么 .........................................................................1
1.1 达到某种目的的手段 ....................................................................................2
1.2 用户研究基础知识 ........................................................................................4
1.3 用户的学习动机 ............................................................................................6
1.4 模式 ................................................................................................................8
安全探索 ........................................................................................................9
即时满足 ......................................................................................................10
满意即可 ......................................................................................................10
中途变卦 ......................................................................................................11
延后选择 ......................................................................................................12
递增构建 ......................................................................................................13
习惯 ..............................................................................................................14
小片时间 ......................................................................................................15
空间记忆 ......................................................................................................16
前瞻记忆 ......................................................................................................17
简化重复工作 ..............................................................................................19
只支持键盘 ..................................................................................................20
旁人建议 ......................................................................................................21
个性化推荐 ..................................................................................................22
第2章 组织内容：信息架构和应用结构 ..........................................23
2.1 从全局出发 ..................................................................................................23
2.2 模式 ..............................................................................................................27
主题、搜索和浏览 ......................................................................................28
新闻流 ..........................................................................................................32
图片管理器 ..................................................................................................38
信息板 ..........................................................................................................43
画布加调色板工具条 ..................................................................................48
向导 ..............................................................................................................52
设置编辑器 ..................................................................................................57
可选视图 ......................................................................................................62
多工作空间 ..................................................................................................66
多级帮助 ......................................................................................................69
第3章 到处走走：导航、路标和找路 ..............................................75
3.1 不要迷路 ......................................................................................................75
3.2 导航的代价 ..................................................................................................77
3.3 常见的导航模型 ..........................................................................................78
3.4 网站设计习惯用法 ......................................................................................83
3.5 模式 ..............................................................................................................84
清楚的入口点 .............................................................................................85
菜单页面 ......................................................................................................88
金字塔 ..........................................................................................................92
模态面板 ......................................................................................................95
深度链接状态 ..............................................................................................98
逃生舱 ........................................................................................................101
胖菜单 .......................................................................................................104
页脚站点地图 ............................................................................................108
登录工具 ....................................................................................................113
序列地图 ....................................................................................................116
面包屑层级结构 ........................................................................................119
注释滚动条 ................................................................................................122
动画转换 ....................................................................................................124
第4章 组织页面：页面元素的布局 ...............................................127
4.1 页面布局基础知识 ....................................................................................127
4.2 模式 ............................................................................................................136
视觉框架 ....................................................................................................138
中央舞台 ....................................................................................................142
对等网格 ....................................................................................................146
带标题的区域 ............................................................................................149
模态Tab ......................................................................................................152
手风琴模式 ................................................................................................156
可收起面板 ................................................................................................160
可移动的面板 ............................................................................................165
右/左对齐 ...................................................................................................170
对角线平衡 ................................................................................................173
响应式展开 ................................................................................................175
响应式允许 ................................................................................................179
流体布局 ....................................................................................................183
第5章 列表 ..................................................................................187
5.1 列表的使用场景 ........................................................................................187
5.2 回到信息架构 ............................................................................................188
5.3 一些解决方案 ............................................................................................190
5.4 模式 ............................................................................................................193
双面板选择器 ............................................................................................194
单窗口深入 ................................................................................................198
列表嵌入 ....................................................................................................202
缩略图网格 ................................................................................................206
传送带 ........................................................................................................211
斑马行 ........................................................................................................215
分页 ............................................................................................................219
条目跳转 ....................................................................................................223
字母表滚动条 ............................................................................................225
级联列表 ....................................................................................................227
树表 ............................................................................................................229
新列表行 ....................................................................................................231
第6章 完成任务：动作与命令 ......................................................234
6.1 扩展边界 ....................................................................................................237
6.2 模式 ............................................................................................................239
按钮组 ........................................................................................................241
悬浮工具 ....................................................................................................244
动作面板 ....................................................................................................247
突出“完成”按钮 ....................................................................................251
智能菜单项 ................................................................................................255
预览 ............................................................................................................257
进度提示 ....................................................................................................259
可取消性 ....................................................................................................262
多级撤销 ....................................................................................................265
命令历史 ....................................................................................................269
宏 ................................................................................................................271
第7章 显示复杂数据：树、表格及其他信息图形 ..........................275
7.1 信息图形基础 ............................................................................................275
7.2 模式 ............................................................................................................289
总览加细节 ................................................................................................290
数据提示 ....................................................................................................293
数据焦点 ....................................................................................................297
动态查询 ....................................................................................................302
数据刷 ........................................................................................................306
局部缩放 ....................................................................................................310
可排序表格 ................................................................................................314
径向表 ........................................................................................................317
多Y值图 .....................................................................................................322
多个小对象 ................................................................................................325
树状地图 ....................................................................................................330
第8章 获取用户输入：表单与控件 ...............................................335
8.1 表单设计基础 ............................................................................................335
8.2 控件选择 ....................................................................................................338
8.3 模式 ............................................................................................................350
容错格式 ....................................................................................................351
结构化的格式 ............................................................................................354
填空 ............................................................................................................356
输入提示 ....................................................................................................358
输入提醒 ....................................................................................................361
密码强度计 ................................................................................................364
自动完成 ....................................................................................................367
下拉选择器 ................................................................................................372
列表构造器 ................................................................................................375
良好的默认值 ............................................................................................377
同页错误信息 ............................................................................................379
第9章 利用社交媒体 .....................................................................384
9.1 本章不涉及的内容 ....................................................................................385
9.2 社交媒体的基础 ........................................................................................385
9.3 模式 ............................................................................................................388
编辑混合 ....................................................................................................389
个人声音 ....................................................................................................393
转帖和评论 ................................................................................................397
发起会话 ....................................................................................................401
倒置纳米金字塔 ........................................................................................403
择时策略 ....................................................................................................406
专用流 ........................................................................................................409
社交链接 ....................................................................................................413
共享组件 ....................................................................................................416
新闻框 ........................................................................................................420
内容列表区域 ............................................................................................424
新近谈话 ....................................................................................................428
第10章 迈向移动设计 ...................................................................431
10.1 移动设计的挑战 ......................................................................................432
10.2 模式 ..........................................................................................................437
纵向堆叠 ..................................................................................................439
胶片 ..........................................................................................................442
触摸工具 ..................................................................................................444
底部导航 ..................................................................................................446
小图片加文字的列表 ..............................................................................449
无限列表 ..................................................................................................452
宽边界 ......................................................................................................454
文本清除按钮 ..........................................................................................456
加载提示 ..................................................................................................458
应用互联 ..................................................................................................460
精简品牌形象 ..........................................................................................463
第11章 修饰外观：视觉风格和美感 ............................................467
11.1 相同的内容、不同的风格 ......................................................................469
11.2 视觉设计基础 ..........................................................................................478
11.3 这对桌面应用来说意味着什么 ..............................................................486
11.4 模式 ..........................................................................................................488
深色背景 ..................................................................................................489
少一点颜色、多一些价值 ......................................................................493
角落处理 ..................................................................................................497
边界回应字体 ..........................................................................................499
发丝 ..........................................................................................................502
粗细字体对比 ..........................................................................................505
皮肤和主题 ..............................................................................................508
参考文献 .......................................................................................511
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>界面设计模式（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>研磨设计模式
第1章 设计模式基础
1.1 设计模式是什么
1.1.1 什么是模式
1.1.2 设计模式的概念
1.1.3 设计模式的理解
1.1.4 设计模式的历史
1.2 设计模式有什么
1.2.1 设计模式的组成
1.2.2 设计模式的分类
1.3 设计模式的学习
1.3.1 为什么要学习设计模式
1.3.2 学习设计模式的层次
1.3.3 如何学习设计模式
1.4 本书的组织方式
1.4.1 本书所讲述的设计模式的提纲
1.4.2 每个模式的讲述结构
第2章 简单工厂
2.1 场景问题
2.1.1 接口回顾
2.1.2 面向接口编程
2.1.3 不用模式的解决方案
2.1.4 有何问题
2.2 解决方案
2.2.1 使用简单工厂来解决问题
2.2.2 简单工厂的结构和说明
2.2.3 简单工厂示例代码
2.2.4 使用简单工厂重写示例
2.3 模式讲解
2.3.1 典型疑问
2.3.2 认识简单工厂
2.3.3 简单工厂中方法的写法
2.3.4 可配置的简单工厂
2.3.5 简单工厂的优缺点
2.3.6 思考简单工厂
2.3.7 相关模式
第3章 外观模式
3.1 场景问题
3.1.1 生活中的示例
3.1.2 代码生成的应用
3.1.3 不用模式的解决方案
3.1.4 有何问题
3.2 解决方案
3.2.1 使用外观模式来解决问题
3.2.2 外观模式的结构和说明
3.2.3 外观模式示例代码
3.2.4 使用外观模式重写示例
3.3 模式讲解
3.3.1 认识外观模式
3.3.2 外观模式的实现
3.3.3 外观模式的优缺点
3.3.4 思考外观模式
3.3.5 相关模式
第4章 适配器模式（Adapter）
4.1 场景问题
4.1.1 装配电脑的例子
4.1.2 同时支持数据库和文件的日志管理
4.1.3 有何问题
4.2 解决方案
4.2.1 使适配器模式来解决问题
4.2.2 模式的结构和说明
4.2.3 适配器模式示例代码
4.2.4 使用适配器模式来实现示例
4.3 模式讲解
4.3.1 认识适配器模式
4.3.2 适配器模式的实现
4.3.3 双向适配器
4.3.4 对象适配器和类适配器
4.3.5 适配器模式的优缺点
4.3.6 思考适配器模式
4.3.7 相关模式
第5章 单例模式（Singleton）
5.1 场景问题
5.1.1 读取配置文件的内容
5.1.2 不用模式的解决方案
5.1.3 有何问题
5.2 解决方案
5.2.1 使用单例模式来解决问题
5.2.2 单例模式的结构和说明
5.2.3 单例模式示例代码
5.2.4 使用单例模式重写示例
5.3 模式讲解
5.3.1 认识单例模式
5.3.2 懒汉式和饿汉式实现
5.3.3 延迟加载的思想
5.3.4 缓存的思想
5.3.5 Java中缓存的基本实现
5.3.6 利用缓存来实现单例模式
5.3.7 单例模式的优缺点
5.3.8 在Java中一种更好的单例实现方式
5.3.9 单例和枚举
5.3.10 思考单例模式
5.3.11 相关模式
第6章 工厂方法模式（Factory Method）
6.1 场景问题
6.1.1 导出数据的应用框架
6.1.2 框架的基础知识
6.1.3 有何问题
6.2 解决方案
6.2.1 使用工厂方法模式来解决问题
6.2.2 工厂方法模式的结构和说明
6.2.3 工厂方法模式示例代码
6.2.4 使用工厂方法模式来实现示例
6.3 模式讲解
6.3.1 认识工厂方法模式
6.3.2 工厂方法模式与IoC/DI
6.3.3 平行的类层次结构
6.3.4 参数化工厂方法
6.3.5 工厂方法模式的优缺点
6.3.6 思考工厂方法模式
6.3.7 相关模式
第7章 抽象工厂模式 （Abstract Factory）
7.1 场景问题
7.1.1 选择组装电脑的配件
7.1.2 不用模式的解决方案
7.1.3 有何问题
7.2 解决方案
7.2.1 使用抽象工厂模式来解决问题
7.2.2 抽象工厂模式的结构和说明
7.2.3 抽象工厂模式示例代码
7.2.4 使用抽象工厂模式重写示例
7.3 模 式 讲 解
7.3.1 认识抽象工厂模式
7.3.2 定义可扩展的工厂
7.3.3 抽象工厂模式和DAO
7.3.4 抽象工厂模式的优缺点
7.3.5 思考抽象工厂模式
7.3.6 相关模式
第8章 生成器模式（Builder）
8.1 场景问题
8.1.1 继续导出数据的应用框架
8.1.2 不用模式的解决方案
8.1.3 有何问题
8.2 解决方案
8.2.1 使用生成器模式来解决问题
8.2.2 生成器模式的结构和说明
8.2.3 生成器模式示例代码
8.2.4 使用生成器模式重写示例
8.3 模式讲解
8.3.1 认识生成器模式
8.3.2 生成器模式的实现
8.3.3 使用生成器模式构建复杂对象
8.3.4 生成器模式的优点
8.3.5 思考生成器模式
8.3.6 相关模式
第9章 原型模式（Prototype）
9.1 场景问题
9.1.1 订单处理系统
9.1.2 不用模式的解决方案
9.1.3 有何问题
9.2 解决方案
9.2.1 使用原型模式来解决问题
9.2.2 原形模式的结构和说明
9.2.3 原型模式示例代码
9.2.4 使用原型模式重写示例
9.3 模式讲解
9.3.1 认识原型模式
9.3.2 Java中的克隆方法
9.3.3 浅度克隆和深度克隆
9.3.4 原型管理器
9.3.5 原型模式的优缺点
9.3.6 思考原型模式
9.3.7 相关模式
第10章 中介者模式（Mediator）
10.1 场景问题
10.1.1 如果没有主板
10.1.2 有何问题
10.1.3 使用电脑来看电影
10.2 解决方案
10.2.1 使用中介者模式来解决问题
10.2.2 中介者模式的结构和说明
10.2.3 中介者模式示例代码
10.2.4 使用中介者模式来实现示例
10.3 模式讲解
10.3.1 认识中介者模式
10.3.2 广义中介者
10.3.3 中介者模式的优缺点
10.3.4 思考中介者模式
10.3.5 相关模式
第11章 代 理 模 式（Proxy）
11.1 场景问题
11.1.1 访问多条数据
11.1.2 不用模式的解决方案
11.1.3 有何问题
11.2 解决方案
11.2.1 使用代理模式来解决问题
11.2.2 代理模式的结构和说明
11.2.3 代理模式示例代码
11.2.4 使用代理模式重写示例
11.3 模式讲解
11.3.1 认识代理模式
11.3.2 保护代理
11.3.3 Java中的代理
11.3.4 代理模式的特点
11.3.5 思考代理模式
11.3.6 相关模式
第12章 观察者模式(Observer)
12.1 场景问题
12.1.1 订阅报纸的过程
12.1.2 订阅报纸的问题
12.2 解决方案
12.2.1 使用观察者模式来解决问题
12.2.2 观察者模式的结构和说明
12.2.3 观察者模式示例代码
12.2.4 使用观察者模式实现示例
12.3 模式讲解
12.3.1 认识观察者模式
12.3.2 推模型和拉模型
12.3.3 Java中的观察者模式
12.3.4　观察者模式的优缺点
12.3.5 思考观察者模式
12.3.6 Swing中的观察者模式
12.3.7 简单变形示例——区别对待观察者
12.3.8 相关模式
第13章 命令模式(Command)
13.1 场景问题
13.1.1 如何开机
13.1.2 与我何干
13.1.3 有何问题
13.2 解决方案
13.2.1 使用命令模式来解决问题
13.2.2 命令模式的结构和说明
13.2.3 命令模式示例代码
13.2.4 使用命令模式来实现示例
13.3 模式解
13.3.1 认识命令模式
13.3.2 参数化配置
13.3.3 可撤销的操作
13.3.4 宏命令
13.3.5 队列请求
13.3.6 日志请求
13.3.7 命令模式的优点
13.3.8 思考命令模式
13.3.9 退化的命令模式
13.3.10 相关模式
第14章 迭代器模式（Iterator）
14.1 场景问题
14.1.1 工资表数据的整合
14.1.2 有何问题
14.2 解决方案
14.2.1 使用迭代器模式来解决问题
14.2.2 选化器模式的结构和说明
14.2.3 迭代器模式示例代码
14.2.4 使用迭代器模式来实现示例
14.3 模式讲解
14.3.1 认识迭代器模式
14.3.2 使用Java的迭代器
14.3.3 带迭代策略的迭代器
14.3.4 双向迭代器
14.3.5 迭代器模式的优点
14.3.6 思考迭代器模式
14.3.7 翻页迭代
14.3.8 相关模式
第15章 组合模式(Composite)
15.1 场景问题
15.1.1 商品类别树
15.1.2 不用模式的解决方案
15.1.3 有何问题
15.2 解决方案
15.2.1 使用组合模式来解决问题
15.2.2 组合模式的结构和说明
15.2.3 组合模式示例代码
15.2.4 使用组合模式重写示例
15.3 模式讲解
15.3.1 认识组合模式
15.3.2 安全性和透明性
15.3.3 父组件引用
15.3.4 环状引用
15.3.5 组合模式的优缺点
15.3.6 思考组合模式
15.3.7 相关模式
第16章 模板方法模式(Template Method)
16.1 场景问题
16.1.1 登录控制
16.1.2 不用模式的解决方案
16.1.3 有何问题
16.2 解决方案
16.2.1 使用模板方法模式来解决问题
16.2.2 模板方法模式的结构和说明
16.2.3 模板方法模式示例代码
16.2.4 使用模板方法模式重写示例
16.3 模式讲解
16.3.1 认识模板方法模式
16.3.2 模板的写法
16.3.3 Java回调与模板方法模式
16.3.4 典型应用：排序
16.3.5 实现通用的增删改查
16.3.6 模板方法模式的优缺点
16.3.7 思考模板方法模式
16.3.8 相关模式
第17章 策略模式(Strategy)
17.1 场景问题
17.1.1 报价管理
17.1.2 不用模式的解决方案
17.1.3 有何问题
17.2 解 决 方 案
17.2.1 使用策略模式来解决问题
17.2.2 策略模式的结构和说明
17.2.3 策略模式示例代码
17.2.4 使用策略模式重写示例
17.3 模式讲解
17.3.1 认识策略模式
17.3.2 Context和Strategy的关系
17.3.3 容错恢复机制
17.3.4 策略模式结合模板方法模式
17.3.5 策略模式的优缺点
17.3.6 思考策略模式
17.3.7 相关模式
第18章 状态模式（State）
18.1 场景问题
18.1.1 实现在线投票
18.1.2 不用模式的解决方案
18.1.3 有何问题
18.2 解决方案
18.2.1 使用状态模式来解决问题
18.2.2 状态模式的结构和说明
18.2.3 状态模式示例代码
18.2.4 使用状态模式重写示例
18.3 模式讲解
18.3.1 认识状态模式
18.3.2 状态的维护和转换控制
18.3.3 使用数据库来维护状态
18.3.4 模拟工作流
18.3.5 状态模式的优缺点
18.3.6 思考状态模式
18.3.7 相关模式
第19章 备忘录模式（Memento）
19.1 场景问题
19.1.1 开发仿真系统
19.1.2 不用模式的解决方案
19.1.3 有何问题
19.2 解决方案
19.2.1 使用备忘录模式来解决问题
19.2.2 备忘录模式的结构和说明
19.2.3 备忘录模式示例代码
19.2.4 使用备忘录模式重写示例
19.3 模式讲解
19.3.1 认识备忘录模式
19.3.2 结合原型模式
19.3.3 离线存储
19.3.4 再次实现可撤销操作
19.3.5 备忘录模式的优缺点
19.3.6 思考备忘录模式
19.3.7 相关模式
第20章 享元模式（Flyweight）
20.1 场景问题
20.1.1 加入权限控制
20.1.2 不使用模式的解决方案
20.1.3 有何问题
20.2 解决方案
20.2.1 使用享元模式来解决问题
20.2.2 享元模式的结构和说明
20.2.3 享元模式示例代码
20.2.4 使用享元模式重写示例
20.3 模式讲解
20.3.1 认识享元模式
20.3.2 不需要共享的享元实现
20.3.3 对享元对象的管理
20.3.4 享元模式的优缺点
20.3.5 思考享元模式
20.3.6 相关模式
第21章 解释器模式（Interpreter）
21.1 场景问题
21.1.1 读取配置文件
21.1.2 不用模式的解决方案
21.1.3 有何问题
21.2 解决方案
21.2.1 使用解释器模式来解决问题
21.2.2 解释器模式的结构和说明
21.2.3 解释器模式示例代码
21.2.4 使用解释器模式重写示例
21.3 模式讲解
21.3.1 认识解释器模式
21.3.2 读取多个元素或属性的值
21.3.3 解析器
21.3.4 解释器模式的优缺点
21.3.5 思考解释器模式
21.3.6 相关模式
第22章 装饰模式（Decorator）
22.1 场景问题
22.1.1 复杂的奖金计算
22.1.2 简化后的奖金计算体系
22.1.3 不用模式的解决方案
22.1.4 有何问题
22.2 解决方案
22.2.1 使用装饰模式来解决问题
22.2.2 装饰模式的结构和说明
22.2.3 装饰模式示例代码
22.2.4 使用装饰模式重写示例
22.3 模式讲解
22.3.1 认识装饰模式
22.3.2 Java中的装饰模式应用
22.3.3 装饰模式和AOP
22.3.4 装饰模式的优缺点
22.3.5 思考装饰模式
22.3.6 相关模式
第23章 职责链模式（Chain of Responsibility）
23.1 场景问题
23.1.1 申请聚餐费用
23.1.2 不用模式的解决方案
23.1.3 有何问题
23.2 解决方案
23.2.1 使用职责链模式来解决问题
23.2.2 职责链模式的结构和说明
23.2.3 职责链模式示例代码
23.2.4 使用职责链模式重写示例
23.3 模式讲解
23.3.1 认识职责链模式
23.3.2 处理多种请求
23.3.3 功能链
23.3.4 职责链模式的优缺点
23.3.5 思考职责链模式
23.3.6 相关模式
第24章 桥接模式（Bridge）
24.1 场景问
24.1.1 发送提示消息
24.1.2 不用模式的解决方案
24.1.3 有何问题
24.2 解决方案
24.2.1 使用桥接模式来解决问题
24.2.2 桥接模式的结构和说明
24.2.3 桥接模式示例代码
24.2.4 使用桥接模式重写示例
24.3 模式讲解
24.3.1 认识桥接模式
24.3.2 谁来桥接
24.3.3 典型例子——JDBC
24.3.4 广义桥接——Java中无处不桥接
24.3.5 桥接模式的优缺点
24.3.6 思考桥接模式
24.3.7 相关模式
第25章 访问者模式（Visitor）
25.1 场景问题
25.1.1 扩展客户管理的功能
25.1.2 不用模式的解决方案
25.1.3 有何问题
25.2 解决方案
25.2.1 使用访问者模式来解决问题
25.2.2 访问者模式的结构和说明
25.2.3 访问者模式示例代码
25.2.4 使用访问者模式重写示例
25.3 模式讲解
25.3.1 认识访问者模式
25.3.2 操作组合对象结构
25.3.3 谁负责遍历所有元素对象
25.3.4 访问者模式的优缺点
25.3.5 思考访问者模式
25.3.6 相关模式
附录A 常见面向对象设计原则
A.1 设计模式和设计原则
A.1.1 设计模式和设计原则的关系
A.1.2 为何不重点讲解设计原则
A.2 常见的面向对象设计原则
A.2.1 单一职责原则SRP（Single Responsibility Principle）
A.2.2 开放-关闭原则OCP（Open-Closed Principle）
A.2.3 里氏替换原则LSP（Liskov Substitution Principle）
A.2.4 依赖倒置原则DIP（Dependence Inversion Principle）
A.2.5 接口隔离原则ISP（Interface Segregation Principle）
A.2.6 最少知识原则LKP（Least Knowledge Principle）
A.2.7 其他原则
附录B UML简介
B.1 UML基础
B.1.1 UML是什么
B.1.2 UML历史
B.1.3 UML能干什么
B.1.4 UML有什么
B.2 类图
B.2.1 类图的概念
B.2.2 类图的基本表达
B.2.3 抽象类和接口
B.2.4 关系
B.3 顺序图
B.3.1 顺序图的概念
B.3.2 顺序图的基本表达
临别赠言
不是结束而是新的开始
你该怎么做
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>研磨设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式沉思录
第1章　介绍　　1.1　对模式的十大误解　　1.2　观察　第2章　运用模式进行设计　　2.1　基础　　2.2　孤儿、孤儿的收养以及代用品　　2.3　“但是应该如何引入代用品呢？”　　2.4　访问权限　　2.5　关于 VISITOR的一些警告　　2.6　单用户文件系统的保护　　2.7　多用户文件系统的保护　　2.8　小结　第3章　主体和变体　　3.1　终止SINGLETON　　3.2　OBSERVER的烦恼　　3.3　重温VISITOR　　3.4　GENERATION GAP　　3.5　Type Laundering　　3.6　感谢内存泄漏　　3.7　推拉模型　第4章　爱的奉献　第5章　高效模式编写者的7个习惯　　5.1　习惯1：经常反思　　5.2　习惯2：坚持使用同一套结构　　5.3　习惯3：尽早且频繁地涉及具体问题　　5.4　习惯4：保持模式间的区别和互补性　　5.5　习惯5：有效地呈现　　5.6　习惯6：不懈地重复　　5.7　习惯7：收集并吸取反馈　　5.8　没有银弹　参考文献　索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式沉思录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式精解
第一篇  面向对象软件设计简介
第一章  面向对象范式
第二章  UML――统一建模语言
第二篇  传统面向对象设计的局限性
第三章  一个急需灵活代码的问题
第四章  一个标准面向对象解决方案
第三篇 设计模式
第五章  设计模式简介
第六章  FACADE（外观）模式
第七章  ADAPTER（适配器）模式
第八章  扩展我们的视野
第九章  BRIDGE（桥接）模式
第十章  ABSTRACT FACTROY（抽象工厂）模式
第四篇  将所有这些放在一起：用模式的方法思考
第十一章  专家如何进行设计
第十二章  用模式解决CAD/CAM问题
第十三章  设计模式的原则和策略
第五篇  用设计模式处理变化
第十四章  STRATEGY（策略）模式
第十五章  DECORATOR（装饰）模式
第十六章  SINGLETON（单件）模式和DOUBLE-CHECKED LOCKING（双重检查锁定）模式
第十七章  OBSERVER（观察者）模式
第十八章  TEMPLATE METHOD（模板方法）模式
第十九章  FACTORY METHOD（工厂方法）模式
第二十章  分析矩阵
第六篇  终点和起点
第二十一章  从面向对象设计的新视角进行的设计模式回顾
第二十二章  推荐书目

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式精解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Ruby设计模式
本书的赞誉
译者序
序
前言
致谢
第一部分 设计模式和Ruby
第1章 使用设计模式创建更好的程序
第2章 从Ruby起步
第二部分 Ruby中的模式
第3章 使用模板方法变换算法
第4章 使用策略替换算法
第5章 通过观察器保持协调
第6章 使用组合模式将各部分组成整体
第7章 通过迭代器遍历集合
第8章 使用命令模式完成任务
第9章 使用适配器填补空隙
第10章 通过代理来到对象面前
第11章 使用装饰器改善对象
第12章 使用单例确保仅有一个
第13章 使用工厂模式挑选
第14章 通过生产器简化对象创建
第15章 使用解释器组建系统
第三部分 Ruby的设计模式
第16章 采用域指定语言打开系统
第17章 使用元编程创建自定义对象
第18章 惯例优于配置
第19章 总结
附录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Ruby设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java设计模式
第1章 设计模式介绍 1
1.1 为什么使用模式 1
1.2 为什么使用设计模式 2
1.3 为什么使用Java 2
1.4 UML 3
1.5 自我突破 3
1.6 本书的组织方式 3
1.7 欢迎来到Oozinoz公司 4
1.8 小结 5
第一部分 接口型模式
第2章 接口型模式介绍 8
2.1 接口和抽象类 8
2.2 接口和责任 9
2.3 小结 10
2.4 超越普通接口 10
第3章 Adapter (适配器) 模式 11
3.1 接口适配 11
3.2 类和对象适配器 14
3.3 为JTable适配数据 16
3.4 标识适配器 20
3.5 小结 20
第4章 Facade (外观) 模式 21
4.1 外观类、工具类和示例类 21
4.2 重构为Facade模式 22
4.3 小结 29
第5章 Composite (组合) 模式 30
5.1 常见的组合 30
5.2 Composite模式的递归特性 31
5.3 组合、树和环 32
5.4 含有环的Composite模式 35
5.5 环的影响 38
5.6 小结 39
第6章 Bridge (桥接) 模式 40
6.1 经典范例：普通抽象 40
6.2 从抽象到Bridge模式 42
6.3 应用Bridge模式的驱动程序 43
6.4 数据库驱动程序 44
6.5 小结 45
第二部分 责任型模式
第7章 责任型模式介绍 48
7.1 常见的责任型模式 48
7.2 通过可见性属性控制责任 49
7.3 小结 50
7.4 超越普通责任型模式 50
第8章 Singleton (单例) 模式 51
8.1 Singleton模式机制 51
8.2 单例和线程 52
8.3 识别单例 53
8.4 小结 54
第9章 Observer (观察者) 模式 55
9.1 经典范例：GUI中的Observer模式 55
9.2 模型/视图/控制器 58
9.3 维护Observable类对象 62
9.4 小结 64
第10章 Mediator (中介者) 模式 65
10.1 经典范例：GUI的Mediator模式 65
10.2 利用Mediator模式管理关系完整性 68
10.3 小结 73
第11章 Proxy (代理) 模式 74
11.1 经典范例：图像代理 74
11.2 重新思考图像代理 78
11.3 远程代理 79
11.4 动态代理 84
11.5 小结 87
第12章 Chain of Responsibility (责任链) 模式 88
12.1 常见的责任链 88
12.2 重构为Chain of Responsibility模式 89
12.3 固定责任链 91
12.4 不带组合结构的Chain of Responsibility模式 92
12.5 小结 93
第13章 Flyweight (享元) 模式 94
13.1 不变性 94
13.2 提取享元中不可变的部分 95
13.3 共享享元 96
13.4 小结 99
第三部分 构造型模式
第14章 构造型模式介绍 102
14.1 普通构造的挑战 102
14.2 小结 103
14.3 超越普通构造 103
第15章 Builder (生成器) 模式 105
15.1 常见的生成器 105
15.2 根据约束构造对象 107
15.3 根据不完整信息构造符合约束的对象 109
15.4 小结 109
第16章 Factory Method (工厂方法) 模式 110
16.1 经典范例：迭代器 110
16.2 识别Factory Method模式 111
16.3 决定要实例化的对象 111
16.4 并行层次结构中的Factory Method模式 112
16.5 小结 114
第17章 Abstract Factory (抽象工厂) 模式 115
17.1 经典范例：GUI工具包 115
17.2 抽象工厂和工厂方法 118
17.3 包和抽象工厂 121
17.4 小结 122
第18章 Prototype (原型) 模式 123
18.1 作为工厂的原型 123
18.2 利用克隆进行原型化 124
18.3 小结 126
第19章 Memento (备忘录) 模式 127
19.1 经典范例：使用备忘录实现撤销操作 127
19.2 备忘录的持久性 132
19.3 跨越会话的持久性备忘录 132
19.4 小结 135
第四部分 操作型模式
第20章 操作型模式介绍 138
20.1 操作和方法 138
20.2 签名 139
20.3 异常 139
20.4 算法和多态性 140
20.5 小结 141
20.6 超越普通操作 141
第21章 Template Method (模板方法) 模式 142
21.1 经典范例：排序 142
21.2 完成算法 145
21.3 Template Method模式钩子 147
21.4 重构为Template Method模式 148
21.5 小结 149
第22章 State (状态) 模式 150
22.1 状态建模 150
22.2 重构为State模式 153
22.3 使状态成为常量 156
22.4 小结 157
第23章 Strategy (策略) 模式 158
23.1 策略建模 158
23.2 重构为Strategy模式 160
23.3 比较Strategy模式和State模式 163
23.4 比较Strategy模式和Template Method模式 164
23.5 小结 164
第24章 Command (命令) 模式 165
24.1 经典范例：菜单命令 165
24.2 使用Command模式提供服务 167
24.3 Command模式钩子 168
24.4 Command模式与其他模式的关系 169
24.5 小结 170
第25章 Interpreter (解释器) 模式 171
25.1 Interpreter模式范例 171
25.2 解释器、语言和解析器 180
25.3 小结 180
第五部分 扩展型模式
第26章 扩展型模式介绍 184
26.1 面向对象设计原则 184
26.2 Liskov替换原则 (LSP) 184
26.3 Demeter法则 185
26.4 消除代码坏味 186
26.5 超越普通的扩展 187
26.6 小结 187
第27章 Decorator (装饰器) 模式 188
27.1 经典范例：流和输出器 188
27.2 函数包装器 193
27.3 与其他模式相关的Decorator模式 199
27.4 小结 199
第28章 Iterator (迭代器) 模式 200
28.1 常规迭代 200
28.2 线程安全的迭代 201
28.3 对组合结构进行迭代 206
28.3.1 组合枚举器的深度 211
28.3.2 枚举叶节点 212
28.4 小结 213
第29章 Visitor (访问者) 模式 214
29.1 Visitor模式机制 214
29.2 常见的Visitor模式 216
29.3 Visitor模式循环 220
29.4 Visitor模式危机 223
29.5 小结 224
第六部分 附录
附录A 指南 226
A.1 从本书中学到更多 226
A.2 理解设计模式的典型范例 226
A.3 在实践中应用设计模式 227
A.4 不断地学习 228
附录B 参考答案 229
B.1 接口型模式介绍 (第2章) 229
B.2 Adapter (适配器) 模式 (第3章) 230
B.3 Fa?ade (外观) 模式 (第4章) 233
B.4 Composite (组合) 模式 (第5章) 235
B.5 Bridge (桥接) 模式 (第6章) 237
B.6 责任型模式介绍 (第7章) 239
B.7 Singleton (单例) 模式 (第8章) 240
B.8 Observer (观察者) 模式 (第9章) 241
B.9 Mediator (中介者) 模式 (第10章) 245
B.10 Proxy (代理) 模式 (第11章) 248
B.11 Chain of Responsibility (责任链) 模式 (第12章) 249
B.12 Flyweight (享元) 模式 (第13章) 252
B.13 构造型模式介绍 (第14章) 254
B.14 Builder (生成器) 模式 (第15章) 255
B.15 Factory Method (工厂方法) 模式(第16章) 257
B.16 Abstract Factory (抽象工厂) 模式 (第17章) 260
B.17 Prototype (原型) 模式 (第18章) 262
B.18 Memento (备忘录) 模式 (第19章) 264
B.19 操作模式介绍 (第20章) 266
B.20 Template Method (模板方法) 模式 (第21章) 267
B.21 State (状态) 模式 (第22章) 268
B.22 Strategy (策略) 模式 (第23章) 270
B.23 Command (命令) 模式 (第24章) 271
B.24 Interpreter (解释器) 模式 (第25章) 274
B.25 扩展型模式介绍 (第26章) 275
B.26 Decorator (装饰器) 模式 (第27章) 276
B.27 Iterator (迭代器) 模式 (第28章) 278
B.28 Visitor (访问者) 模式 (第29章) 279
附录C Oozinoz源代码 282
C.1 获取和使用源代码 282
C.2 构建Oozinoz源代码 282
C.3 使用JUnit测试代码 282
C.4 自己查找文件 283
C.5 小结 283
附录D UML概览 284
D.1 类 284
D.2 类间关系 285
D.3 接口 286
D.4 对象 287
D.5 状态 288
词汇表 289
参考文献 294
索引 296
设计模式列表 308
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Cocoa设计模式
译者序
序
前言
作者简介
第一部分　一种可控制一切的模式
第1章　模型-视图-控制器	2
1.1　Cocoa中的MVC3
1.1.1　模型子系统的核心数据支持3
1.1.2　视图子系统的应用程序工具箱支持4
1.1.3　控制器子系统的应用程序工具箱支持6
1.1.4　Cocoa的文本架构7
1.1.5　Cocoa的文档架构7
1.1.6　Cocoa编写脚本的能力10
1.1.7　Cocoa的偏好窗格架构11
1.1.8　Quartz Composer的架构11
1.1.9　QTKit的架构12
1.2　小结12
第2章　分析和应用MVC13
2.1　非MVC设计13
2.2　MVC设计17
2.3　小结21
第二部分　基 础 模 式
第3章　两阶段创建24
3.1　动机24
3.2　解决方案25
3.2.1　分区26
3.2.2　初始化已分配的内存26
3.2.3　实现指定的初始化方法27
3.2.4　在初始化方法中使用分区29
3.2.5　创建临时实例30
3.3　Cocoa中的示例31
3.4　后果35
第4章　模板方法36
4.1　动机36
4.2　解决方案36
4.2.1　默认模板方法38
4.2.2　利用模板方法进行设计38
4.3　Cocoa中的示例38
4.3.1　使用-drawRect:模板方法39
4.3.2　其他Cocoa模板方法39
4.4　后果42
第5章　动态创建43
5.1　动机43
5.2　解决方案43
5.2.1　使用动态创建43
5.2.2　用动态创建实现插件架构49
5.3　Cocoa中的示例50
5.4　后果50
第6章　类别52
6.1　动机52
6.2　解决方案52
6.2.1　非正式协议55
6.2.2　匿名类别56
6.2.3　代码组织57
6.2.4　何时使用类别与子类化57
6.3　Cocoa中的示例57
6.3.1　把类别用于组织58
6.3.2　把类别用于非正式协议58
6.3.3　把类别用于框架划分60
6.4　后果61
6.4.1　方法冲突61
6.4.2　替换方法61
6.4.3　软件维护62
第7章　匿名类型和异类容器63
7.1　动机63
7.2　解决方案63
7.2.1　匿名类型64
7.2.2　赋值66
7.2.3　异类容器67
7.3　Cocoa中的示例68
7.4　后果68
第8章　枚举器70
8.1　动机70
8.2　解决方案70
8.2.1　使用枚举器对象70
8.2.2　使用快速枚举71
8.2.3　创建自定义的枚举器72
8.2.4　实现快速枚举76
8.2.5　内部枚举79
8.3　Cocoa中的示例80
8.4　后果80
第9章　执行选择器和延迟执行82
9.1　动机82
9.2　解决方案82
9.2.1　延迟执行84
9.2.2　Objective-C消息发送的实现85
9.3　Cocoa中的示例86
9.4　后果87
第10章　访问器89
10.1　动机90
10.2　解决方案90
10.2.1　引用计数的内存管理91
10.2.2　管理保留计数的访问器92
10.2.3　将内存管理限制在访问器中95
10.2.4　可变性95
10.2.5　NSKeyValueCoding97
10.2.6　Interface Builder插座变量98
10.2.7　Objective-C 2.0的属性98
10.3　Cocoa中的示例98
10.4　后果101
第11章　归档和解档102
11.1　动机102
11.2　解决方案102
11.3　Cocoa中的示例105
11.3.1　实现NSCoding协议106
11.3.2　编码和解码非对象类型108
11.3.3　对象替换110
11.3.4　nib意识110
11.4　后果111
第12章　复制112
12.1　动机112
12.2　解决方案114
12.3　Cocoa中的示例116
12.3.1　实现NSCopying116
12.3.2　实现深复制117
12.3.3　实现NSMutableCopying118
12.3.4　必需的复制119
12.3.5　复制Objective-C 2.0的属性119
12.3.6　避免使用NSCopyObject()121
12.4　后果121
第三部分　主要通过解耦来变得更强大的模式
第13章　单例124
13.1　动机124
13.2　解决方案124
13.2.1　封装共享资源124
13.2.2　创建和访问共享实例126
13.2.3　控制实例化127
13.2.4　取消分配129
13.2.5　确定是否创建了单例130
13.2.6　线程安全130
13.2.7　与Interface Builder协作130
13.3　Cocoa中的示例131
13.4　后果132
第14章　通知133
14.1　动机133
14.2　解决方案134
14.2.1　MYNotification类134
14.2.2　MYNotificationCenter类135
14.2.3　联合存储140
14.3　Cocoa中的示例140
14.3.1　全局通知名称140
14.3.2　 “Will”和“Did”通知141
14.3.3　同步通知与异步通知141
14.3.4　分布式通知143
14.4　后果144
第15章　委托146
15.1　动机146
15.2　解决方案149
15.2.1　实现委托支持150
15.2.2　实现委托155
15.2.3　数据源156
15.3　Cocoa中的示例157
15.4　后果157
第16章　层次结构159
16.1　动机159
16.2　解决方案159
16.2.1　实现层次结构160
16.2.2　Cocoa视图层次结构162
16.2.3　视图层次结构中的坐标系统163
16.2.4　浏览视图层次结构164
16.3　Cocoa中的示例171
16.4　后果171
第17章　插座变量、目标和动作172
17.1　动机173
17.2　解决方案173
17.2.1　插座变量176
17.2.2　目标176
17.2.3　动作176
17.2.4　动作和响应者链178
17.3　Cocoa中的示例179
17.4　后果181
第18章　响应者链183
18.1　动机183
18.2　解决方案183
18.2.1　术语183
18.2.2　响应者链184
18.2.3　扩展的响应者链185
18.2.4　遍历扩展的响应者链187
18.2.5　插入对象到响应者链中188
18.2.6　利用响应者链189
18.3　Cocoa中的示例191
18.4　后果191
第19章　联合存储192
19.1　动机192
19.2　解决方案192
19.3　Cocoa中的示例195
19.3.1　引用计数的内存管理195
19.3.2　键值编码198
19.4　后果198
第20章　调用200
20.1　动机200
20.2　解决方案200
20.2.1　方法签名200
20.2.2　使用NSInvocation对象201
20.2.3　使用计时器205
20.2.4　延迟的消息发送209
20.3　Cocoa中的示例210
20.4　后果211
第21章　原型212
21.1　动机212
21.2　解决方案212
21.3　Cocoa中的示例214
21.3.1　使用MYLabeledBarCell实例作为原型214
21.3.2　使用MYColorLabeledBarCell实例作为原型216
21.4　后果218
第22章　享元219
22.1　动机219
22.2　解决方案219
22.3　Cocoa中的示例219
22.3.1　封装非对象值220
22.3.2　减少存储需求220
22.3.3　替代其他对象221
22.4　后果222
第23章　装饰器223
23.1　动机224
23.2　解决方案224
23.3　Cocoa的示例225
23.4　后果226
第四部分　主要用于隐藏复杂性的模式
第24章　包228
24.1　动机228
24.2　解决方案228
24.3　Cocoa中的示例230
24.4　后果232
第25章　类簇233
25.1　动机233
25.2　解决方案233
25.3　Cocoa中的示例237
25.3.1　子类化类簇的公共接口类238
25.3.2　NSString的MYShortString子类239
25.3.3　从MYShortString获得的经验教训248
25.4　后果248
第26章　外观250
26.1　动机250
26.2　解决方案251
26.3　Cocoa中的示例254
26.3.1　文本外观254
26.3.2　图像外观255
26.3.3　持久存储外观255
26.3.4　用户交互外观256
26.4　后果257
第27章　代理和转发258
27.1　动机258
27.2　解决方案258
27.2.1　实现转发258
27.2.2　代理259
27.2.3　高阶消息265
27.3　Cocoa中的示例270
27.4　后果270
第28章　管理者271
28.1　动机271
28.2　解决方案271
28.2.1　扩展单例模式272
28.2.2　添加其他管理者特性275
28.3　Cocoa中的示例277
28.4　后果277
第29章　控制器279
29.1　动机279
29.2　解决方案279
29.2.1　MYShapeDraw模型子系统280
29.2.2　MYShapeDraw视图子系统281
29.2.3　MYShapeEditor控制器子系统283
29.2.4　扩展MYShapeDraw视图子系统以进行编辑292
29.2.5　重新设计和泛化解决方案294
29.3　Cocoa中的示例299
29.4　后果300
第五部分　模式应用的实用工具
第30章　核心数据模型304
30.1　模型子系统的角色304
30.2　核心数据的术语305
30.2.1　实体305
30.2.2　特性305
30.2.3　关系306
30.2.4　属性306
30.3　核心数据内模式之间的协作307
30.3.1　NSManagedObject和NSEntityDescription307
30.3.2　设计核心数据模型312
30.3.3　NSManagedObjectContext312
30.3.4　NSPersistentStoreCoordinator和NSPersistentStore313
30.4　核心数据的局限性和好处314
第31章　应用程序工具箱视图315
31.1　视图子系统的角色315
31.2　应用程序工具箱内的模式之间的协作316
31.2.1　NSApplication、事件和运行循环316
31.2.2　响应者317
31.2.3　响应者链317
31.2.4　NSWindow概述318
31.2.5　NSView概述319
31.2.6　目标和动作321
31.2.7　归档的对象和nib322
31.2.8　撤销和重做324
31.2.9　管理者324
31.3　应用程序工具箱的局限性和好处325
第32章　绑定和控制器326
32.1　绑定和控制器的角色326
32.1.1　绑定避免耦合328
32.1.2　结合使用控制器与绑定的重要性328
32.2　绑定和控制器内的模式之间的协作329
32.2.1　在-bind:toObject:withKeyPath:options:中发生了什么事情330
32.2.2　键值观察如何检查对所观察属性的更改使得观察对象可以得到通知330
32.2.3　在观察的属性的值改变时发送什么消息来通知注册的观察者331
32.3　绑定和控制器的局限性和好处333
附录　资源334
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Cocoa设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>领域驱动设计模式、原理与实践
第1部分领域驱动设计的原则与实践
第1章什么是领域驱动设计
1.1为复杂问题域创建软件的挑战
1.1.1未使用通用语言创建的代码
1.1.2组织结构的缺乏
1.1.3泥球模式将扼杀开发
1.1.4缺乏对问题域的关注
1.2领域驱动设计模式如何管理复杂性
1.2.1DDD的战略模式
1.2.2DDD的战术模式
1.2.3问题空间与解空间
1.3领域驱动设计的实践与原则
1.3.1专注于核心领域
1.3.2通过协作进行学习
1.3.3通过探索和实验来创建模型
1.3.4通信
1.3.5理解模型的适用性
1.3.6让模型持续发展
1.4领域驱动设计的常见误区
1.4.1战术模式是DDD的关键
1.4.2DDD是一套框架
1.4.3DDD是一颗灵丹妙药
1.5要点
第2章提炼问题域
2.1知识提炼与协作
2.1.1通过通用语言达成共识
2.1.2领域知识的重要性
2.1.3业务分析员的角色
2.1.4一个持续过程
2.2与领域专家一起获得领域见解
2.2.1领域专家与业务相关人员的对比
2.2.2对于业务的更深刻理解
2.2.3与你的领域专家互动
2.3有效提炼知识的模式
2.3.1专注在最有意思的对话上
2.3.2从用例开始
2.3.3提出有力的问题
2.3.4草图
2.3.5CRC卡
2.3.6延迟对模型中概念的命名
2.3.7行为驱动开发
2.3.8快速成型
2.3.9查看基于纸面的系统
2.4查看现有模型
2.4.1理解意图
2.4.2事件风暴
2.4.3影响地图
2.4.4理解业务模型
2.4.5刻意发现
2.4.6模型探讨漩涡
2.5要点
第3章专注于核心领域
3.1为何要分解一个问题域
3.2如何捕获问题的实质
3.2.1超越需求
3.2.2为达成什么是核心内容的共识而捕获领域愿景
3.3如何专注于核心问题
3.3.1提炼问题域
3.3.2核心领域
3.3.3将你的核心领域当作一款产品而非一个项目
3.3.4通用域
3.3.5支撑域
3.4子域如何决定解决方案的形成
3.5并非一个系统的所有部分都会经过良好设计
3.5.1专注于清晰边界而非完美模型
3.5.2一开始核心领域不必总是需要是完美的
3.5.3构建用于替代而非重用的子域
3.6如果没有核心领域怎么办
3.7要点
第4章模型驱动设计
4.1什么是领域模型
4.1.1领域与领域模型的对比
4.1.2分析模型
4.1.3代码模型
4.1.4代码模型是领域模型的主要表现
4.2模型驱动设计
4.2.1预先设计的挑战
4.2.2团队建模
4.3使用通用语言将分析和代码模型绑定在一起
4.3.1语言的生存周期将大于软件
4.3.2业务语言
4.3.3开发人员和业务之间的转译
4.4基于通用语言进行协作
4.4.1通过使用具体示例来定制出语言
4.4.2教导你的领域专家专注在问题上而不要跳到解决方案
4.4.3塑造语言的最佳实践
4.5如何创建有效的领域模型
4.5.1不要让实情妨碍一个好模型
4.5.2仅对相关内容建模
4.5.3领域模型都是暂时有用的
4.5.4要十分清楚专业术语
4.5.5限制你的抽象
4.6何时应用模型驱动设计
4.6.1如果它不值得花费精力，则不要尝试对其建模
4.6.2专注于核心领域
4.7要点
第5章领域模型实现模式
5.1领域层
5.2领域模型实现模式
5.2.1领域模型
5.2.2事务脚本
5.2.3表模块
5.2.4活动记录
5.2.5贫血领域模型
5.2.6贫血领域模型和函数编程
5.3要点
第6章使用有界上下文维护领域模型的完整性
6.1单个模型的挑战
6.1.1模型的复杂性可能会增加
6.1.2多个团队处理单个模型
6.1.3模型语言中的歧义
6.1.4领域概念的适用范围
6.1.5集成遗留代码或第三方代码
6.1.6领域模型并非企业模型
6.2使用有界上下文划分和破除大模型
6.2.1定义模型的边界
6.2.2子域和有界上下文之间的差异
6.3实现有界上下文
6.4要点
第7章上下文映射
7.1一个现实情况的映射
7.1.1技术的现实
7.1.2组织的现实
7.1.3映射一个相关现实情况
7.1.4用X标记核心领域的位置
7.2认识有界上下文之间的关系
7.2.1防止损坏层
7.2.2共享内核
7.2.3开放宿主服务
7.2.4分道扬镳
7.2.5合作关系
7.2.6一种上游／下游关系
7.3传递上下文映射
7.4上下文映射的战略重要性
7.4.1保持完整性
7.4.2解决计划的基础
7.4.3理解所有权和职责
7.4.4揭示业务工作流中的混乱区域
7.4.5识别非技术障碍
7.4.6鼓励良好的沟通
7.4.7帮助加入的新员工
7.5要点
第8章应用程序架构
8.1应用程序架构
8.1.1分离应用程序的问题
8.1.2从领域的复杂性中进行抽象
8.1.3分层架构
8.1.4依赖倒置
8.1.5领域层
8.1.6应用程序服务层
8.1.7基础架构层
8.1.8跨层通信
8.1.9隔离测试
8.1.10不要在有界上下文之间共享数据结构
8.1.11应用程序架构与用于有界上下文的架构的对比
8.2应用程序服务
8.2.1应用程序逻辑与领域逻辑的对比
8.2.2定义和公开能力
8.2.3业务用例协作
8.2.4应用程序服务表示的是用例，而不是创建、读取、更新和删除
8.2.5作为实现详情的领域层
8.2.6领域报告
8.2.7读取模型与事务模型的对比
8.3应用程序客户端
8.4要点
第9章团队开始应用领域驱动设计通常会遭到的问题
9.1过分强调战术模式的重要性
9.1.1将相同架构用于所有的有界上下文
9.1.2力求战术模式尽善尽美
9.1.3错误估计构造块对于DDD的价值
9.1.4专注于代码而非DDD的原则
9.2缺失了DDD的真实价值：协作、通信和上下文
9.2.1由于低估上下文的重要性而产生大泥球
9.2.2未能成功创建UL将造成歧义和误解
9.2.3由于缺乏协作将只能设计专注于技术的解决方案
9.3在不重要的部分花费太多时间
9.4简单问题复杂化
9.4.1将DDD原则应用到具有少量业务预期的琐碎领域
9.4.2别将CRUD作为反模式
9.4.3将领域模型模式用于每一个有界上下文
9.4.4问一问自己：额外的复杂性是否值得
9.5低估应用DDD的成本
9.5.1尝试在没有积极专注的团队的情况下取得成功
9.5.2项目背后没有领域专家时的协作尝试
9.5.3在非迭代式开发方法中进行学习
9.5.4将DDD应用到每一个问题
9.5.5为不必要的纯粹性而牺牲实用主义
9.5.6寻求验证会浪费精力
9.5.7永远力求代码之美
9.5.8DDD关乎的是提供价值
9.6要点
第10章应用DDD的原则、实践与模式
10.1推广使用DDD
10.1.1培训团队
10.1.2与业务人员进行交流
10.2应用DDD的原则
10.2.1理解愿景
10.2.2捕获所需的行为
10.2.3理解环境的现实情况
10.2.4对解决方案建模
10.3探究和实验
10.3.1质疑假设
10.3.2建模是一项持续性活动
10.3.3不存在错误的模型
10.3.4灵活的代码有助于探索发现
10.4让隐式内容变得显式
10.4.1处理歧义
10.4.2为事物命名
10.5问题解决人先行，技术专家后行
10.6如何才能知道我在正确地工作
10.6.1好用就足够了
10.6.2实践、实践、实践
10.7要点
第Ⅱ部分战略模式：在有界上下文之间通信
第11章有界上下文集成介绍
11.1如何集成有界上下文
11.1.1有界上下文是独立自主的
11.1.2在代码层面集成有界上下文的挑战
11.1.3使用物理边界来强制实现整洁的模型
11.1.4集成遗留系统
11.2集成分布式有界上下文
11.2.1集成用于分布式有界上下文的策略
11.2.2数据库集成
11.2.3平面文件集成
11.2.4RPC
11.2.5消息传递
11.2.6REST
11.3DDD使用分布式系统的挑战
11.4分布式事务将损害可扩展性和可靠性
11.4.1有界上下文不必彼此保持一致
11.4.2最终一致性
11.5事件驱动响应式DDD
11.5.1展示响应式解决方案的弹性和可扩展性
11.5.2异步消息传递的挑战和取舍
11.5.3RPC还有价值吗
11.6SOA和响应式DDD
11.6.1将你的有界上下文视作SOA服务
11.6.2进一步处理微服务架构
11.7要点
第12章通过消息传递集成
12.1消息传递基础
12.1.1消息总线
12.1.2可靠的消息传递
12.1.3存储转发
12.1.4命令和事件
12.1.5最终一致性
12.2使用NServiceBus构建一个电子商务应用程序
12.2.1系统设计
12.2.2从Web应用程序发送命令
12.2.3处理命令和发布事件
12.2.4使用消息传递网关让外部HTTP调用变得可靠
12.2.5实践中的最终一致性
12.2.6有界上下文会存储其本地所需的所有数据
12.2.7把所有内容都放在UI中
12.3维护消息传递应用程序
12.3.1消息版本管理
12.3.2监控和扩展
12.4将有界上下文与公共传输集成
12.4.1消息传递桥
12.4.2公共传输
12.5要点
第13章通过使用RPC和REST的HTTP来集成
13.1为何选用HTTP
13.1.1没有平台耦合
13.1.2每个人都理解HTTP
13.1.3大量的成熟工具和库
13.1.4内部测试你的API
13.2RPC
13.2.1在HTTP上实现RPC
13.2.2选择一种RPC风格
13.3REST
13.3.1深入浅出地解释REST
13.3.2用于有界上下文集成的REST
13.3.3维护REST应用程序
13.3.4将REST用于有界上下文集成的缺点
13.4要点
……
第Ⅲ部分战术模式：创建有效的领域模型
第Ⅳ部分有效应用程序的设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>领域驱动设计模式、原理与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式：可复用面向对象软件的基础
出版者的话
赞誉
序言
前言
读者指南
第1章引言┊1
1.1　什么是设计模式┊3
1.2　Smalltalk MVC中的设计模式┊4
1.3　描述设计模式┊6
1.4　设计模式的编目┊7
1.5　组织编目┊8
1.6　设计模式怎样解决设计问题┊10
1.6.1　寻找合适的对象┊10
1.6.2　决定对象的粒度┊11
1.6.3　指定对象接口┊11
1.6.4　描述对象的实现┊12
1.6.5　运用复用机制┊15
1.6.6　关联运行时和编译时的结构┊18
1.6.7　设计应支持变化┊19
1.7　怎样选择设计模式┊22
1.8　怎样使用设计模式┊24
第2章实例研究：设计一个文档编辑器┊25
2.1　设计问题┊27
2.2　文档结构┊27
2.2.1　递归组合┊28
2.2.2　图元┊29
2.2.3　组合模式┊31
2.3　格式化┊31
2.3.1　封装格式化算法┊31
2.3.2　Compositor和Composition┊32
2.3.3　策略模式┊33
2.4　修饰用户界面┊34
2.4.1　透明围栏┊34
2.4.2　Monoglyph┊35
2.4.3　Decorator模式┊36
2.5　支持多种视感标准┊37
2.5.1　对象创建的抽象┊37
2.5.2　工厂类和产品类┊38
2.5.3　Abstract Factory 模式┊40
2.6　支持多种窗口系统┊40
2.6.1　是否可以使用Abstract Factory模式┊40
2.6.2　封装实现依赖关系┊41
2.6.3　Window和WindowImp┊43
2.6.4　Bridge模式┊46
2.7　用户操作┊46
2.7.1　封装一个请求┊47
2.7.2　Command类及其子类┊47
2.7.3　撤销和重做┊48
2.7.4　命令历史记录┊49
2.7.5　Command模式┊50
2.8　拼写检查和断字处理┊50
2.8.1　访问分散的信息┊51
2.8.2　封装访问和遍历┊51
2.8.3　Iterator类及其子类┊52
2.8.4　Iterator模式┊55
2.8.5　遍历和遍历过程中的动作┊55
2.8.6　封装分析┊56
2.8.7　Visitor类及其子类┊59
2.8.8　Visitor模式┊60
2.9　小结┊60
第3章创建型模式┊62
3.1　Abstract Factory（抽象工厂）—对象创建型模式┊66
3.2　Builder（生成器）—对象创建型模式┊74
3.3　Factory Method（工厂方法）—对象创建型模式┊81
3.4　Prototype（原型）—对象创建型模式┊89
3.5　Singleton（单件）—对象创建型模式┊96
3.6　创建型模式的讨论┊102
第4章结构型模式┊104
4.1　Adapter（适配器）—类对象结构型模式┊106
4.2　Bridge（桥接）—对象结构型模式┊115
4.3　Composite（组合）—对象结构型模式┊123
4.4　Decorator（装饰）—对象结构型模式┊132
4.5　Facade（外观）—对象结构型模式┊┊139
4.6　Flyweight（享元）—对象结构型模式┊146
4.7　Proxy（代理）—对象结构型模式┊155
4.8　结构型模式的讨论 ┊164
4.8.1　Adapter与Bridge┊164
4.8.2　Composite、Decorator与Proxy┊164
第5章行为型模式┊166
5.1　Chain of Responsibility（职责链）—对象行为型模式┊167
5.2　Command（命令）—对象行为型模式┊175
5.3　Interpreter（解释器）—类行为型模式┊183
5.4　Iterator（迭代器）—对象行为型模式┊193
5.5　 Mediator（中介者）—对象行为型模式┊205
5.6　Memento（备忘录）—对象行为型模式┊212
5.7　Observer（观察者）—对象行为型模式┊219
5.8　State（状态）—对象行为型模式┊227
5.9　Strategy（策略）—对象行为型模式┊234
5.10　Template Method（模板方法）— 类行为型模式┊242
5.11　Visitor（访问者）—对象行为型 模式┊246
5.12　行为型模式的讨论┊256
5.12.1　封装变化┊256
5.12.2　对象作为参数┊257
5.12.3　通信应该被封装还是被分布┊257
5.12.4　对发送者和接收者解耦┊258
5.12.5　总结┊260
第6章结论┊261
6.1　设计模式将带来什么┊262
6.1.1　一套通用的设计词汇┊262
6.1.2　书写文档和学习的辅助手段┊263
6.1.3　现有方法的一种补充┊263
6.1.4　重构的目标┊264
6.2　本书简史┊265
6.3　模式界┊266
6.3.1　Alexander的模式语言┊266
6.3.2　软件中的模式┊267
6.4　邀请参与┊267
6.5　临别感想┊268
附录A词汇表┊269
附录B图示符号指南┊273
附录 C基本类┊277
参考文献┊284
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式：可复用面向对象软件的基础
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Android应用UI设计模式
第一部分　用户体验原则和Android特色
第1章　向Android迁移（案例）　　2
1.1 　启动图标　　2
1.2 　操作栏与信息架构　　3
1.2.1 　重新设计前　　3
1.2.2 　重新设计后　　5
1.3 　选项卡　　8
1.4 　专用选择页　　8
1.5 　选择控件　　9
1.5.1 　重新设计前　　9
1.5.2 　重新设计后　　10
1.6 　按钮　　10
1.7 　搜索结果屏幕　　11
1.7.1 　重新设计前　　11
1.7.2 　重新设计后　　12
1.8 　结果详情屏幕　　13
1.8.1 　重新设计前　　13
1.8.2 　重新设计后　　14
1.9 　最终结果　　16
第2章　Android的特色　　19
2.1 　这里是平面国　　19
2.2 　轻按任何地方　　21
2.3 　适合各种设备　　22
2.4 　摆脱空间限制　　24
2.5 　大局着眼，小处着手　　27
第3章　Android分散化　　31
3.1 　何谓分散化　　31
3.2 　花无百日红　　31
3.3 　Android设备类型　　32
3.3.1 　紧凑型手机　　32
3.3.2 　全尺寸移动手机　　33
3.3.3 　平板手机　　34
3.3.4 　小型平板　　35
3.3.5 　大型平板　　37
3.4 　为分散化而歌　　39
第4章　移动设计流程　　40
4.1 　现场观察用户如何与移动设备交互　　40
4.2 　原型设计方法必须考虑尺寸因素　　40
4.3 　用户测试必须涵盖运动、声音和多点触控等方面　　41
4.4 　触控界面必须既简约又精巧　　41
4.5 　愉悦不可或缺　　41
4.6 　讲述完整的故事——为跨界而设计　　42
4.7 　移动设计案例研究　　42
4.7.1 　第1步：范围、概念和规划　　42
4.7.2 　第2步：设计研讨会　　44
4.7.3 　第3步：使用便利贴做RITE调查　　45
4.7.4 　第4步：视觉设计　　48
第二部分　Android 设计模式与反模式
第5章　欢迎体验　　50
5.1 　最终用户许可协议（反模式）　　50
5.1.1 　出现的时间和场合　　50
5.1.2  　示例　　50
5.1.3  　为何要避免　　52
5.1.4  　其他考虑因素　　52
5.2 　联系障碍（反模式）　　52
5.2.1 　出现的时间和场合　　52
5.2.2 　示例　　53
5.2.3 　为何要避免　　54
5.2.4 　其他考虑因素　　54
5.3 　注册（反模式）　　55
5.3.1 　出现的时间和场合　　55
5.3.2 　示例　　55
5.3.3 　为何要避免　　56
5.3.4 　其他考虑因素　　56
5.4 　欢迎动画　　57
5.4.1 　工作原理　　57
5.4.2 　示例　　57
5.4.3 　使用的时机和场合　　58
5.4.4 　使用的原因　　58
5.4.5 　其他用途　　58
5.4.6 　Pet Shop应用　　58
5.4.7 　平板应用　　59
5.5 　使用说明　　59
5.5.1 　工作原理　　59
5.5.2 　示例　　59
5.5.3 　使用的时机和场合　　61
5.5.4 　使用的原因　　61
5.5.5 　其他用途　　61
5.5.6 　Pet Shop应用　　62
5.5.7 　平板应用　　62
第6章　主屏幕　　63
6.1 　链接列表　　63
6.1.1 　工作原理　　63
6.1.2 　示例　　63
6.1.3 　使用的时机和场合　　65
6.1.4 　使用的原因　　65
6.1.5 　其他用途　　65
6.1.6 　Pet Shop应用　　66
6.1.7 　平板应用　　66
6.2 　仪表板　　66
6.2.1 　工作原理　　67
6.2.2 　示例　　67
6.2.3 　使用的时机和场合　　67
6.2.4 　使用的原因　　68
6.2.5 　Pet Shop应用　　68
6.2.6 　平板应用　　69
6.3 　更新　　69
6.3.1 　工作原理　　69
6.3.2 　示例　　69
6.3.3 　使用的时机和场合　　70
6.3.4 　使用的原因　　70
6.3.5 　其他用途　　71
6.3.6 　Pet Shop应用　　71
6.3.7 　平板应用　　72
6.4 　浏览　　72
6.4.1 　工作原理　　72
6.4.2 　示例　　73
6.4.3 　使用的时机和场合　　74
6.4.4 　使用的原因　　74
6.4.5 　其他用途　　74
6.4.6 　Pet Shop应用　　75
6.4.7 　平板应用　　76
6.5 　地图　　76
6.5.1 　工作原理　　76
6.5.2 　示例　　76
6.5.3 　使用的时机和场合　　77
6.5.4 　使用的原因　　77
6.5.5 　其他用途　　77
6.5.6 　Pet Shop应用　　78
6.5.7 　平板应用　　79
6.6 　历史记录　　80
6.6.1 　工作原理　　80
6.6.2 　示例　　80
6.6.3 　使用的时机和场合　　80
6.6.4 　使用的原因　　81
6.6.5 　其他用途　　81
6.6.6 　Pet Shop应用　　82
6.6.7 　平板应用　　83
第7章　搜索　　84
7.1 　语音搜索　　84
7.1.1 　工作原理　　84
7.1.2 　示例　　84
7.1.3 　使用的时机和场合　　85
7.1.4 　使用的原因　　86
7.1.5 　其他用途　　86
7.1.6 　Pet Shop应用　　87
7.1.7 　平板应用　　87
7.2 　自动完成与自动建议　　89
7.2.1 　工作原理　　89
7.2.2 　示例　　89
7.2.3 　使用的时机和场合　　90
7.2.4 　使用的原因　　90
7.2.5 　其他用途　　91
7.2.6 　Pet Shop应用　　91
7.2.7 　平板应用　　92
7.3 　轻按优先　　93
7.3.1 　工作原理　　93
7.3.2 　示例　　94
7.3.3 　使用的时机和场合　　94
7.3.4 　使用的原因　　94
7.3.5 　其他用途　　95
7.3.6 　Pet Shop应用　　95
7.3.7 　平板应用　　95
7.4 　拖动刷新　　96
7.4.1 　工作原理　　96
7.4.2 　示例　　96
7.4.3 　使用的时机和场合　　97
7.4.4 　使用的原因　　97
7.4.5 　其他用途　　97
7.4.6 　Pet Shop应用　　97
7.4.7 　平板应用　　97
7.5 　从菜单搜索　　98
7.5.1 　工作原理　　98
7.5.2 　示例　　98
7.5.3 　使用的时机和场合　　99
7.5.4 　使用的原因　　99
7.5.5 　其他用途　　99
7.5.6 　Pet Shop应用　　99
7.5.7 　平板应用　　100
7.6 　从操作栏搜索　　100
7.6.1 　工作原理　　101
7.6.2 　示例　　101
7.6.3 　使用的时机和场合　　102
7.6.4 　使用的原因　　102
7.6.5 　其他用途　　102
7.6.6 　Pet Shop应用　　103
7.6.7 　平板应用　　103
7.7 　专用搜索　　104
7.7.1 　工作原理　　104
7.7.2 　示例　　104
7.7.3 　使用的时机和场合　　105
7.7.4 　使用的原因　　105
7.7.5 　其他用途　　105
7.7.6 　Pet Shop应用　　105
7.7.7 　平板应用　　106
7.8 　在内容页面中搜索　　106
7.8.1 　工作原理　　106
7.8.2 　示例　　106
7.8.3 　使用的时机和场合　　107
7.8.4 　使用的原因　　107
7.8.5 　其他用途　　107
7.8.6 　Pet Shop应用　　108
7.8.7 　平板应用　　108
7.9 　搜索与细化分离（反模式）　　109
7.9.1 　出现的时间和场合　　109
7.9.2 　示例　　109
7.9.3 　为何要避免　　110
7.9.4 　其他考虑因素　　110
第8章　排序和筛选　　112
8.1 　残缺的细化（反模式）　　112
8.1.1 　出现的时机和场合　　112
8.1.2 　示例　　112
8.1.3 　为何要避免　　114
8.2 　细化页面　　115
8.2.1 　工作原理　　115
8.2.2 　示例　　115
8.2.3 　使用的时机和场合　　118
8.2.4 　使用的原因　　118
8.2.5 　其他用途　　118
8.2.6 　Pet Shop应用　　119
8.2.7 　平板应用　　119
8.3 　筛选带　　120
8.3.1 　工作原理　　120
8.3.2 　示例　　120
8.3.3 　使用的时机和场合　　121
8.3.4 　使用的原因　　121
8.3.5 　其他用途　　121
8.3.6 　Pet Shop应用　　122
8.3.7 　平板应用　　123
8.4 　并行架构　　123
8.4.1 　工作原理　　124
8.4.2 　示例　　124
8.4.3 　使用的时机和场合　　125
8.4.4 　使用的原因　　125
8.4.5 　其他用途　　125
8.4.6 　Pet Shop应用　　125
8.4.7 　平板应用　　126
8.5 　选项卡　　129
8.5.1 　工作原理　　129
8.5.2 　示例　　129
8.5.3 　使用的时机和场合　　131
8.5.4 　使用的原因　　131
8.5.5 　其他用途　　131
8.5.6 　Pet Shop应用　　132
8.5.7 　平板应用　　133
第9章　避免无结果或无关结果　　136
9.1 　不指出系统状态（反模式）　　136
9.1.1 　出现的时机和场合　　136
9.1.2 　示例　　136
9.1.3 　为何要避免　　137
9.1.4 　其他考虑因素　　138
9.2 　低效界面（反模式）　　138
9.2.1 　出现的时机和场合　　138
9.2.2 　示例　　138
9.2.3 　其他考虑因素　　139
9.3 　无用控件（反模式）　　139
9.3.1 　出现的时机和场合　　139
9.3.2 　示例　　139
9.3.3 　为何要避免　　140
9.4 　你要找的是不是……　　140
9.4.1 　工作原理　　140
9.4.2 　示例　　141
9.4.3 　使用的时机和场合　　141
9.4.4 　使用的原因　　142
9.4.5 　其他用途　　142
9.4.6 　Pet Shop应用　　142
9.4.7 　平板应用　　142
9.5 　部分匹配　　143
9.5.1 　工作原理　　143
9.5.2 　示例　　143
9.5.3 　使用的时机和场合　　145
9.5.4 　使用的原因　　145
9.5.5 　其他用途　　145
9.5.6 　Pet Shop应用　　145
9.5.7 　平板应用　　145
9.6 　本地结果　　146
9.6.1 　工作原理　　146
9.6.2 　示例　　146
9.6.3 　使用的时机和场合　　147
9.6.4 　使用的原因　　147
9.6.5 　其他用途　　147
9.6.6 　Pet Shop应用　　148
9.6.7 　平板应用　　149
第10章　数据输入　　150
10.1 　滑块　　150
10.1.1 　工作原理　　150
10.1.2 　示例　　150
10.1.3 　使用的时机和场合　　151
10.1.4 　使用的原因　　151
10.1.5 　其他用途　　152
10.1.6 　Pet Shop应用　　152
10.1.7 　平板应用　　153
10.2 　步进器　　155
10.2.1 　工作原理　　155
10.2.2 　示例　　155
10.2.3 　使用的时机和场合　　156
10.2.4 　使用的原因　　156
10.2.5 　其他用途　　156
10.2.6 　Pet Shop应用　　157
10.2.7 　平板应用　　159
10.3 　可滚动的日历　　159
10.3.1 　工作原理　　159
10.3.2 　示例　　159
10.3.3 　使用的时机和场合　　160
10.3.4 　使用的原因　　160
10.3.5 　其他用途　　160
10.3.6 　Pet Shop应用　　161
10.3.7 　平板应用　　161
10.4 　日期与时间选择器　　163
10.4.1 　工作原理　　163
10.4.2 　示例　　163
10.4.3 　使用的时机和场合　　166
10.4.4 　使用的原因　　166
10.4.5 　其他用途　　166
10.4.6 　Pet Shop应用　　167
10.4.7 　平板应用　　168
10.5 　下拉列表　　170
10.5.1 　工作原理　　170
10.5.2 　示例　　170
10.5.3 　使用的时机和场合　　172
10.5.4 　使用的原因　　172
10.5.5 　其他用途　　172
10.5.6 　Pet Shop应用　　173
10.5.7 　平板应用　　173
10.6 　多选　　174
10.6.1 　工作原理　　174
10.6.2 　示例　　174
10.6.3 　使用的时机和场合　　175
10.6.4 　使用的原因　　175
10.6.5 　其他用途　　175
10.6.6 　Pet Shop应用　　176
10.6.7 　平板应用　　177
10.7 　自由文本输入与提取　　177
10.7.1 　工作原理　　178
10.7.2 　示例　　178
10.7.3 　使用的时机和场合　　179
10.7.4 　使用的原因　　179
10.7.5 　其他用途　　179
10.7.6 　Pet Shop应用　　179
10.7.7 　平板应用　　179
10.8 　带输入掩码的文本框　　182
10.8.1 　工作原理　　183
10.8.2 　示例　　183
10.8.3 　使用的时机和场合　　185
10.8.4 　使用的原因　　185
10.8.5 　其他用途　　185
10.8.6 　Pet Shop应用　　186
10.8.7 　平板应用　　186
10.9 　带原子实体的文本框　　189
10.9.1 　工作原理　　189
10.9.2 　示例　　189
10.9.3 　使用的时机和场合　　189
10.9.4 　使用的原因　　190
10.9.5 　其他用途　　191
10.9.6 　Pet Shop应用　　191
10.9.7 　平板应用　　192
第11章　表单　　193
11.1 　内嵌式错误消息　　193
11.1.1 　工作原理　　193
11.1.2 　示例　　193
11.1.3 　使用的时机和场合　　195
11.1.4 　使用的原因　　195
11.1.5 　其他用途　　195
11.1.6 　Pet Shop应用　　196
11.1.7 　平板应用　　197
11.2 　提示框　　198
11.2.1 　工作原理　　198
11.2.2 　示例　　198
11.2.3 　使用的时机和场合　　200
11.2.4 　使用的原因　　200
11.2.5 　其他用途　　200
11.2.6 　Pet Shop应用　　201
11.2.7 　平板应用　　201
11.3 　弹出框　　203
11.3.1 　工作原理　　203
11.3.2 　示例　　203
11.3.3 　使用的时机和场合　　205
11.3.4 　使用的原因　　205
11.3.5 　其他用途　　205
11.3.6 　Pet Shop应用　　206
11.3.7 　平板应用　　207
11.4 　回调验证　　210
11.4.1 　工作原理　　210
11.4.2 　示例　　210
11.4.3 　使用的时机和场合　　211
11.4.4 　使用的原因　　211
11.4.5 　其他用途　　211
11.4.6 　Pet Shop应用　　211
11.4.7 　平板应用　　212
11.5 　取消/确定　　212
11.5.1 　工作原理　　212
11.5.2 　示例　　212
11.5.3 　使用的时机和场合　　214
11.5.4 　使用的原因　　215
11.5.5 　其他用途　　215
11.5.6 　Pet Shop应用　　217
11.5.7 　平板应用　　217
11.6 　上方标签　　221
11.6.1 　工作原理　　221
11.6.2 　示例　　221
11.6.3 　使用的时机和场合　　222
11.6.4 　使用的原因　　222
11.6.5 　其他用途　　224
11.6.6 　Pet Shop应用　　224
11.6.7 　平板应用　　225
11.7 　从环境获取输入　　227
11.7.1 　工作原理　　227
11.7.2 　示例　　227
11.7.3 　使用的时机和场合　　231
11.7.4 　使用的原因　　231
11.7.5 　其他用途　　231
11.7.6 　Pet Shop应用　　233
11.7.7 　平板应用　　233
11.8 　输入加速　　234
11.8.1 　工作原理　　234
11.8.2 　示例　　234
11.8.3 　使用的时机和场合　　235
11.8.4 　使用的原因　　235
11.8.5 　其他用途　　235
11.8.6 　Pet Shop应用　　235
11.8.7 　平板应用　　236
第12章　移动银行　　238
12.1 　登录加速器　　238
12.1.1 　工作原理　　238
12.1.2 　示例　　238
12.1.3 　使用的时机和场合　　241
12.1.4 　使用的原因　　241
12.1.5 　其他用途　　242
12.1.6 　Pet Shop应用　　243
12.1.7 　平板应用　　244
12.2 　专用选择页面　　245
12.2.1 　工作原理　　245
12.2.2 　示例　　246
12.2.3 　使用的时机和场合　　246
12.2.4 　使用的原因　　246
12.2.5 　其他用途　　247
12.2.6 　Pet Shop应用　　247
12.2.7 　平板应用　　248
12.3 　表单至上　　249
12.3.1 　工作原理　　249
12.3.2 　示例　　249
12.3.3 　使用的时机和场合　　250
12.3.4 　使用的原因　　250
12.3.5 　其他用途　　250
12.3.6 　Pet Shop应用　　250
12.3.7 　平板应用　　251
12.4 　专用页面向导　　251
12.4.1 　工作原理　　251
12.4.2 　示例　　252
12.4.3 　使用的时机和场合　　253
12.4.4 　使用的原因　　253
12.4.5 　其他用途　　253
12.4.6 　Pet Shop应用　　254
12.4.7 　平板应用　　255
12.5 　以表单结尾的向导　　255
12.5.1 　工作原理　　255
12.5.2 　示例　　255
12.5.3 　使用的时机和场合　　256
12.5.4 　使用的原因　　256
12.5.5 　其他用途　　257
12.5.6 　Pet Shop应用　　257
12.5.7 　平板应用　　258
12.6 　核对?确认　　260
12.6.1 　工作原理　　260
12.6.2 　示例　　260
12.6.3 　使用的时机和场合　　261
12.6.4 　使用的原因　　261
12.6.5 　其他用途　　261
12.6.6 　Pet Shop应用　　262
12.6.7 　平板应用　　262
12.7 　近场通信　　263
12.7.1 　工作原理　　263
12.7.2 　示例　　263
12.7.3 　使用的时机和场合　　266
12.7.4 　使用的原因　　266
12.7.5 　其他用途　　267
12.7.6 　Pet Shop应用　　267
12.7.7 　平板应用　　268
第13章　导航　　270
13.1 　上窜下跳（反模式）　　270
13.1.1 　出现的时间和场合　　270
13.1.2 　示例　　270
13.1.3 　为何要避免　　271
13.1.4 　其他考虑因素　　271
13.1.5 　出现的时间和场合　　271
13.2 　多个推荐区域（反模式）　　272
13.2.1 　出现的时间和场合　　272
13.2.2 　示例　　272
13.2.3 　为何要避免　　273
13.2.4 　其他考虑因素　　273
13.3 　轮播　　274
13.3.1 　工作原理　　274
13.3.2 　示例　　274
13.3.3 　使用的时机和场合　　275
13.3.4 　使用的原因　　275
13.3.5 　其他用途　　275
13.3.6 　Pet Shop应用　　276
13.3.7 　平板应用　　276
13.4 　弹出式菜单　　279
13.4.1 　工作原理　　279
13.4.2 　示例　　279
13.4.3 　使用的时机和场合　　281
13.4.4 　使用的原因　　281
13.4.5 　其他用途　　281
13.4.6 　Pet Shop应用　　282
13.4.7 　平板应用　　283
13.5 　水印　　285
13.5.1 　工作原理　　285
13.5.2 　示例　　286
13.5.3 　使用的时机和场合　　287
13.5.4 　使用的原因　　287
13.5.5 　其他用途　　287
13.5.6 　Pet Shop应用　　287
13.5.7 　平板应用　　288
13.6 　瑞士军刀导航　　290
13.6.1 　工作原理　　290
13.6.2 　示例　　290
13.6.3 　使用的时机和场合　　293
13.6.4 　使用的原因　　293
13.6.5 　其他用途　　294
13.6.6 　Pet Shop应用　　297
13.6.7 　平板应用　　298
13.7 　集成　　299
13.7.1 　工作原理　　300
13.7.2 　示例　　300
13.7.3 　使用的时机和场合　　300
13.7.4 　使用的原因　　301
13.7.5 　其他用途　　301
13.7.6 　Pet Shop应用　　303
13.7.7 　平板应用　　303
第14章　平板模式　　306
14.1 　片段　　306
14.1.1 　工作原理　　306
14.1.2 　示例　　306
14.1.3 　使用的时机和场合　　307
14.1.4 　使用的原因　　308
14.1.5 　其他用途　　308
14.2 　复合视图　　308
14.2.1 　工作原理　　308
14.2.2 　示例　　308
14.2.3 　使用的时机和场合　　309
14.2.4 　使用的原因　　309
14.2.5 　其他用途　　309
14.3 　侧面导航（试验模式）　　310
14.3.1 　工作原理　　310
14.3.2 　示例　　311
14.3.3 　使用的时机和场合　　312
14.3.4 　使用的原因　　313
14.3.5 　其他用途　　313
14.4 　将内容用作导航元素　　314
14.4.1 　工作原理　　314
14.4.2 　示例　　314
14.4.3 　使用的时机和场合　　316
14.4.4 　使用的原因　　316
14.4.5 　其他用途　　316
14.5 　二维更多类似　　317
14.5.1 　工作原理　　317
14.5.2 　示例　　317
14.5.3 　使用的时机和场合　　318
14.5.4 　使用的原因　　318
14.5.5 　其他用途　　318
14.6 　C形轻扫（试验模式）　　319
14.6.1 　工作原理　　320
14.6.2 　示例　　320
14.6.3 　使用的时机和场合　　321
14.6.4 　使用的原因　　321
14.6.5 　其他用途　　321
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Android应用UI设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java设计模式
序	xv
第1章  绪论	1
为何需要模式	1
为何需要设计模式	2
为何选择Java	3
UML	3
挑战	4
本书的组织	4
欢迎来到Oozinoz公司	6
小结	6
第1部分  接口型模式
第2章  接口型模式介绍	8
接口与抽象类	8
接口与职责	10
小结	11
超越普通接口	12
第3章  适配器（Adapter）模式	13
接口适配	13
类与对象适配器	17
JTable对数据的适配	20
识别适配器	24
小结	25
第4章  外观（Facade）模式	27
外观类、工具类和示例类	27
重构到外观模式	29
小结	38
第5章  合成（Composite）模式	39
常规组合	39
合成模式中的递归行为	40
组合、树与环	42
含有环的合成模式	47
环的影响	50
小结	51
第6章  桥接（Bridge）模式	52
常规抽象：桥接模式的一种方法	52
从抽象到桥接模式	54
使用桥接模式的驱动器	57
数据库驱动	57
小结	59
第2部分  职责型模式
第7章  职责型模式介绍	62
常规的职责型模式	62
根据可见性控制职责	64
小结	65
超越普通职责	65
第8章  单例（Singleton）模式	67
单例模式机制	67
单例和线程	68
识别单例	70
小结	71
第9章  观察者（Observer）模式	72
经典范例：GUI中的观察者模式	72
模型/视图/控制器	76
维护Observable对象	82
小结	84
第10章  调停者（Mediator）模式	85
经典范例：GUI调停者（Mediator）	85
关系一致性中的调停者模式	89
小结	96
第11章  代理（Proxy）模式	97
经典范例：图像代理	97
重新思考图片代理	102
远程代理	104
动态代理	109
小结	114
第12章  职责链（Chain of Responsibility）模式	115
现实中的职责链模式	115
重构为职责链模式	117
固定职责链	119
没有组合结构的职责链模式	121
小结	121
第13章  享元（Flyweight）模式	122
不变性	122
抽取享元中不可变的部分	123
共享享元	125
小结	128
第3部分  构造型模式
第14章  构造型模式介绍	130
构造函数的挑战	130
小结	132
超出常规的构造函数	132
第15章  构建者（Builder）模式	134
常规的构建者	134
在约束条件下构建对象	137
可容错的构建者	139
小结	140
第16章  工厂方法（Factory Method）模式	141
经典范例：迭代器	141
识别工厂方法	142
控制要实例化的类	143
并行层次结构中的工厂方法模式	145
小结	147
第17章  抽象工厂（Abstract Factory）模式	148
经典范例：图形用户界面工具箱	148
抽象工厂和工厂方法	153
包和抽象工厂	157
小结	157
第18章  原型（Prototype）模式	158
作为工厂的原型	158
利用克隆进行原型化	159
小结	162
第19章  备忘录（Memento）模式	163
经典范例：使用备忘录模式执行撤销操作	163
备忘录的持久性	170
跨会话的持久性备忘录	170
小结	174
第4部分  操作型模式
第20章  操作型模式介绍	176
操作和方法	176
签名	177
异常	178
算法和多态	179
小结	180
超越常规的操作	181
第21章  模板方法（Template Method）模式	182
经典范例：排序	182
完成一个算法	186
模板方法钩子	188
重构为模板方法模式	189
小结	191
第22章  状态（State）模式	193
对状态进行建模	193
重构为状态模式	197
使状态成为常量	201
小结	203
第23章  策略（Strategy）模式	204
策略建模	204
重构到策略模式	207
比较策略模式与状态模式	211
比较策略模式和模板方法模式	211
小结	212
第24章  命令（Command）模式	213
经典范例：菜单命令	213
使用命令模式来提供服务	216
命令钩子	217
命令模式与其他模式的关系	219
小结	220
第25章  解释器（Interpreter）模式	221
一个解释器示例	221
解释器、语言和解析器	233
小结	234
第5部分  扩展型模式
第26章  扩展型模式介绍	236
面向对象设计的原则	236
Liskov替换原则	237
迪米特法则	238
消除代码的坏味道	239
超越常规的扩展	240
小结	241
第27章  装饰器（Decorator）模式	242
经典范例：流和输出器	242
函数包装器	250
装饰器模式和其他设计模式的关系	257
小结	258
第28章  迭代器（Iterator）模式	259
普通的迭代	259
线程安全的迭代	261
基于合成结构的迭代	267
小结	277
第29章  访问者（Visitor）模式	278
访问者模式机制	278
常规的访问者模式	280
Visitor环	286
访问者模式的危机	290
小结	292
附录A  指南	293
附录B  答案	297
附录C  Oozinoz源代码	366
附录D  UML概览	369
参考文献	375
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaScript设计模式
第一篇 面向对象编程
第1章 灵活的语言——JavaScript 2
1.1 入职第一天 2
1.2 函数的另一种形式 2
1.3 用对象收编变量 3
1.4 对象的另一种形式 4
1.5 真假对象 4
1.6 类也可以 5
1.7 一个检测类 5
1.8 方法还可以这样用 6
1.9 函数的祖先 7
1.10 可以链式添加吗 8
1.11 换一种方式使用方法 9
下章剧透 10
忆之获 10
我问你答 10
第2章 写的都是看到的——面向
对象编程 11
2.1 两种编程风格——面向过程与
面向对象 11
2.2 包装明星——封装 12
2.3 传宗接代——继承 19
2.4 老师不止一位——多继承 27
2.5 多种调用方式——多态 29
下章剧透 30
忆之获 31
我问你答 31
第二篇 创建型设计模式
第3章 神奇的魔术师——简单工厂模式 34
3.1 工作中的第一次需求 34
3.2 如果类太多，那么提供一个 35
3.3 一个对象有时也可代替许多类 37
3.4 你的理解决定你选择的方式 38
下章剧透 39
忆之获 39
我问你答 39
第4章 给我一张名片——工厂方法模式 40
4.1 广告展现 40
4.2 方案的抉择 41
4.3 安全模式类 42
4.4 安全的工厂方法 43
下章剧透 44
忆之获 44
我问你答 44
第5章 出现的都是幻觉——抽象
工厂模式 45
5.1 带头模范——抽象类 45
5.2 幽灵工厂——抽象工厂模式 46
5.3 抽象与实现 47
下章剧透 49
忆之获 49
我问你答 49
第6章 分即是合——建造者模式 50
6.1 发布简历 50
6.2 创建对象的另一种形式 50
6.3 创建一位应聘者 52
下章剧透 53
忆之获 53
我问你答 54
第7章 语言之魂——原型模式 55
7.1 语言中的原型 55
7.2 创建一个焦点图 55
7.3 最优的解决方案 56
7.4 原型的拓展 58
7.5 原型继承 58
下章剧透 59
忆之获 60
我问你答 60
第8章 一个人的寂寞——单例模式 61
8.1 滑动特效 61
8.2 命名空间的管理员 62
8.3 模块分明 63
8.4 创建一个小型代码库 63
8.5 无法修改的静态变量 64
8.6 惰性单例 65
下章剧透 65
忆之获 66
我问你答 66
第三篇 结构型设计模式
第9章 套餐服务——外观模式 68
9.1 添加一个点击事件 68
9.2 兼容方式 69
9.3 除此之外 70
9.4 小型代码库 70
下章剧透 71
忆之获 71
我问你答 72
第10章 水管弯弯——适配器模式 73
10.1 引入jQuery 73
10.2 生活中的适配器 73
10.3 jQuery适配器 74
10.4 适配异类框架 74
10.5 参数适配器 75
10.6 数据适配 76
10.7 服务器端数据适配 77
下章剧透 77
忆之获 77
我问你答 78
第11章 牛郎织女——代理模式 79
11.1 无法获取图片上传模块数据 79
11.2 一切只因跨域 79
11.3 站长统计 80
11.4 JSONP 81
11.5 代理模板 81
下章剧透 83
忆之获 83
我问你答 84
第12章 房子装修——装饰者模式 85
12.1 为输入框的新需求 85
12.2 装饰已有的功能对象 86
12.3 为输入框添砖加瓦 86
下章剧透 87
忆之获 87
我问你答 88
第13章 城市间的公路——桥接模式 89
13.1 添加事件交互 89
13.2 提取共同点 90
13.3 事件与业务逻辑之间的桥梁 90
13.4 多元化对象 91
下章剧透 93
忆之获 93
我问你答 93
第14章 超值午餐——组合模式 94
14.1 新闻模块十万火急 94
14.2 餐厅里的套餐业务 95
14.3 每个成员要有祖先 95
14.4 组合要有容器类 96
14.5 创建一个新闻类 97
14.6 把新闻模块创建出来 99
14.7 表单中的应用 100
下章剧透 101
忆之获 101
我问你答 102
第15章 城市公交车——享元模式 103
15.1 翻页需求 103
15.2 冗余的结构 104
15.3 享元对象 104
15.4 实现需求 105
15.5 享元动作 106
下章剧透 108
忆之获 108
我问你答 108
第四篇 行为型设计模式
第16章 照猫画虎——模板方法模式 110
16.1 提示框归一化 110
16.2 美味的蛋糕 111
16.3 创建基本提示框 111
16.4 模板的原型方法 112
16.5 根据模板创建类 113
16.6 继承类也可作为模板类 113
16.7 创建一个提示框 114
16.8 创建多类导航 114
16.9 创建导航更容易 116
下章剧透 116
忆之获 116
我问你答 117
第17章 通信卫星——观察者模式 118
17.1 团队开发的坎坷 118
17.2 卫星的故事 118
17.3 创建一个观察者 119
17.4 拉出来溜溜 121
17.5 使用前的思考 121
17.6 大显身手 121
17.7 对象间解耦 123
17.8 课堂演练 124
下章剧透 125
忆之获 125
我问你答 125
第18章 超级玛丽——状态模式 126
18.1 最美图片 126
18.2 分支判断的思考 126
18.3 状态对象的实现 127
18.4 状态对象演练 127
18.5 超级玛丽 128
18.6 状态的优化 129
18.7 两种使用方式 130
下章剧透 131
忆之获 131
我问你答 131
第19章 活诸葛——策略模式 132
19.1 商品促销 132
19.2 活诸葛 132
19.3 策略对象 133
19.4 诸葛奇谋 133
19.5 缓冲函数 134
19.6 表单验证 134
19.7 算法拓展 135
19.8 算法调用 135
下章剧透 136
忆之获 136
我问你答 137
第20章 有序车站——职责链模式 138
20.1“半成品”需求 138
20.2 分解需求 139
20.3 第一站——请求模块 139
20.4 下一站——响应数据适配模块 140
20.5 终点站——创建组件模块 141
20.6 站点检测——单元测试 141
20.7 方案确定 142
下章剧透 142
忆之获 143
我问你答 143
第21章 命令模式 144
21.1 自由化创建视图 144
21.2 命令对象 145
21.3 视图创建 145
21.4 视图展示 146
21.5 命令接口 147
21.6 大功告成 147
21.7 绘图命令 148
21.8 写一条命令 150
下章剧透 150
忆之获 151
我问你答 151
第22章 驻华大使——访问者模式 152
22.1 设置样式 152
22.2 自娱自乐的IE 152
22.3 访问操作元素 153
22.4 事件自定义数据 153
22.5 原生对象构造器 154
22.6 对象访问器 154
22.7 操作类数组 155
下章剧透 156
忆之获 156
我问你答 156
第23章 媒婆——中介者模式 157
23.1 导航设置层 157
23.2 创建中介者对象 158
23.3 试试看，可否一用 159
23.4 攻克需求 159
23.5 订阅消息 160
23.6 发布消息 161
下章剧透 162
忆之获 162
我问你答 162
第24章 做好笔录——备忘录模式 163
24.1 新闻展示 163
24.2 缓存数据 164
24.3 新闻缓存器 164
24.4 工作中的备忘录 166
下章剧透 166
忆之获 166
我问你答 166
第25章 点钞机——迭代器模式 167
25.1 简化循环遍历 167
25.2 迭代器 167
25.3 实现迭代器 168
25.4 小试牛刀 170
25.5 数组迭代器 171
25.6 对象迭代器 171
25.7 试用迭代器 172
25.8 同步变量迭代器 172
25.9 分支循环嵌套问题 174
25.10 解决方案 176
下章剧透 177
忆之获 177
我问你答 177
第26章 语言翻译——解释器模式 178
26.1 统计元素路径 178
26.2 描述文法 179
26.3 解释器 179
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaScript设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>PHP设计模式
第Ⅰ部分  初识设计模式与PHP第1章  理解设计模式  1.1  什么是设计模式    1.1.1  一个普通的示例    1.1.2  设计模式能够解决相同的问题    1.1.3  设计模式无所不在    1.1.4  设计模式的公共部分  1.2  设计模式未涵盖的内容    1.2.1  设计模式并非即插即用    1.2.2  设计模式是可维护的，但并非总是最有效的    1.2.3  设计模式是重构的必经之路，但不是最终目标  1.3  设计模式的相关论证  1.4  在PHP中使用设计模式的原因  1.5  本章小结第2章  使用现有的工具  2.1  已有架构中的模式    2.1.1  PEAR.中的设计模式    2.1.2  Zend Framework中的设计模式    2.1.3  Doctrine中的设计模式  2.2  PHP标准库    2.2.1  SPL Observer与SPL Subject    2.2.2  SPL迭代器  2.3  使用具有模式的Eclipse PDT  2.4  本章小结第Ⅱ部分  参考内容第3章  适配器模式  3.1  问题与解决方案  3.2  UML  3.3  代码示例第4章  建造者模式  4.1  问题与解决方案  4.2  UML  4.3  代码示例第5章  数据访问对象模式  5.1  问题与解决方案  5.2  UML  5.3  代码示例第6章  装饰器模式  6.1  问题与解决方案  6.2  UML  6.3  代码示例第7章  委托模式  7.1  问题与解决方案  7.2  UML  7.3  代码示例第8章  外观模式  8.1  问题与解决方案  8.2  UML  8.3  代码示例第9章  工厂模式  9.1  问题与解决方案  9.2  UML  9.3  代码示例第10章  解释器模式  10.1  问题与解决方案  10.2  UML  10.3  代码示例第11章  迭代器模式  11.1  问题与解决方案  11.2  UML  11.3  代码示例第12章  中介者模式  12.1  问题与解决方案  12.2  UML  12.3  代码示例第13章  观察者模式  13.1  问题与解决方案  13.2  UML  13.3  代码示例第14章  原型模式  14.1  问题与解决方案  14.2  UML  14.3  代码示例第15章  代理模式  15.1  问题与解决方案  15.2  UML  15.3  代码示例第16章  单元素模式  16.1  问题与解决方案  16.2  UML  16.3  代码示例第17章  策略模式  17.1  问题与解决方案  17.2  UML  17.3  代码示例第18章  模板模式  18.1  问题与解决方案  18.2  UML  18.3  代码示例第19章  访问者模式  19.1  问题与解决方案  19.2  UML  19.3  代码示例第Ⅲ第20章  需求分析  20.1  初始需求    20.1.1  执行纲要    20.1.2  作用域    20.1.3  假设邝艮制    20.1.4  详细需求  20.2  初始需求分析    20.2.1  大小／用户规模    20.2.2  联系方式信息的类型    20.2.3  应用程序访问    20.2.4  联系方式同步    20.2.5  用户证书  20.3  最新需求文档    20.3.1  执行纲要    20.3.2  假设/限制    20.3.3  详细需求  20.4  对最新需求的讨论  20.5  本章小结第21章  选择设计模式与计划  21.1  设计核心  21.2  设计用户交互    21.2.1  身份验证和授权    21.2.2  创建、编辑和删除用户    21.2.3  提供对所有用户的管理访问  21.3  设计联系方式管理    21.3.1  处理联系方式与信息    21.3.2  联系方式信息关系    21.3.3  导入联系方式    21.3.4  查看联系方式  21.4  本章小结第22章  应用程序编程  22.1  信息准备  22.2  应用程序编程    22.2.1  应用程序核心的编程    22.2.2  用户交互与管理的编程    22.2.3  联系方式管理的编程  22.3  本章小结第23章  使用更多设计模式进行改进  23.1  处理联系方式的导入    23.1.1  Outlook联系方式适配器    23.1.2  构建联系方式数组  23.2  去除视图中的逻辑  23.3  尽力实现设计模式    23.3.1  设计模式和错误检查    23.3.2  设计模式和联系方式管理    23.3.3  设计模式和视图类型    23.3.4  设计模式和删除对象    23.3.5  分享您的设计模式完善工作  23.4  本章小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>PHP设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ActionScript 3设计模式
第Ⅰ部分　成功的项目
第1章　系统设计
1.1　分析阶段
1.1.1　用例介绍
1.1.2　书写正式用例
1.1.3 编写用例
1.1.4　UML的使用
1.2　设计阶段
1.2.1 CRC卡介绍
1.2.2　类确定
1.2.3　类功能确定
1.2.4　确定协作类
1.2.5　确定类与类之间的联系
1.2.6 确定公共接口函数(API)
1.2.7 设计阶段UML的应用
1.3 实现阶段
1.3.1　编程规范
1.3.2　封装
1.3.3　继承和组合
1.3.4　耦合
1.4　测试阶段
1.4.1　创建基本单元测试
1.4.2　异步单元测试创建
1.5　本章小结
第2章　接口编程
2.1　接口定义
2.2　多态性的使用
2.3　本章小结
第Ⅱ部分　模式
第3章　模型/视图/控制器模式
3.1　MVC元素
3.2　构建一个简单示例
3.3　多视图显示
3.4　模型实现代码的修改
3.5　添加控制器
3.6　本章小结
第4章　单件模式
4.1　对象实例化
4.2　单件模式和静态成员
4.3　构建简单的单件类
4.4　设置框架的构建
4.5　本章小结
第5章　工厂方法和模板方法模式
5.1　抽象类
5.2　模板方法
5.3　工厂方法
5.4　本章小结
第6章　代理模式
6.1　虚拟代理
6.2　远程代理
6.3　适配器模式和Facade模式
6.4　本章小结
第7章　迭代器模式
第8章　组合模式
第9章　装饰器模式
第10章　命令模式
第11章　备忘录模式
第12章	状态模式
第Ⅲ部分　高级Action Script主题
第13章 事件
第14章 发送和加载数据
第15章 E4X(XML)
第16章 正则表达式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ActionScript 3设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>HTML5与CSS3设计模式
第1章 　设计模式：简化CSS使用　　1
1.1 　设计模式——结构化方法　　2
1.2 　使用设计模式　　2
1.3 　使用样式表　　7
1.4 　CSS语法　　7
1.4.1 　CSS语法详解　　8
1.4.2 　在CSS中使用空白字符　　9
1.4.3 　使用属性值　　9
1.5 　使用层叠顺序　　12
1.6 　简化层叠顺序　　14
1.7 　CSS和HTML链接　　15
1.8 　CSS常用属性　　16
1.9 　CSS属性与值：常用　　17
1.10 　CSS属性与值：内容　　18
1.11 　CSS属性与值：布局　　19
1.12 　CSS属性与值：专用　　20
1.13 　选择器　　20
1.14 　媒体查询　　21
1.15 　灵活尺寸单位　　22
1.16 　固定度量单位　　22
1.17 　96 dpi下度量单位的换算　　23
1.18 　96 dpi下的常用字号　　23
1.19 　过渡、动画与2D变换　　23
1.20 　修复CSS错误　　24
1.21 　样式表的规范化　　26
第2章 　HTML设计模式　　29
2.1 　概述　　29
2.2 　HTML结构　　30
2.3 　HTML结构（续）　　32
2.4 　XHTML　　37
2.5 　DOCTYPE　　39
2.6 　页头元素　　41
2.7 　条件样式表　　43
2.8 　结构块元素　　45
2.9 　终止块元素　　47
2.10 　多功能块元素　　49
2.11 　行内元素　　51
2.12 　类和ID属性　　53
2.13 　HTML空白字符　　55
第3章 　CSS选择器与继承　　57
3.1 　概述　　57
3.2 　类型、类和ID选择器　　58
3.3 　位置选择器和选择器分组　　60
3.4 　属性选择器　　62
3.5 　伪元素选择器　　64
3.6 　伪类选择器　　66
3.7 　子类选择器　　68
3.8 　继承　　70
3.9 　可视化继承　　72
第4章 　框模型　　75
4.1 　概述　　75
4.2 　Display　　76
4.3 　框模型　　78
4.4 　行内框　　80
4.5 　行内块级框　　82
4.6 　块级框　　84
4.7 　表格框　　86
4.8 　绝对框　　88
4.9 　浮动框　　90
第5章 　框模型的范围　　93
5.1 　概述　　93
5.2 　宽度　　94
5.3 　高度　　96
5.4 　设定尺寸　　98
5.5 　收缩适应　　100
5.6 　拉伸　　102
第6章 　框模型属性　　105
6.1 　概述　　105
6.2 　外边距　　106
6.3 　边框　　108
6.4 　内边距　　111
6.5 　背景　　113
6.6 　溢出　　115
6.7 　可见性　　117
6.8 　分页符　　119
第7章 　定位模型　　121
7.1 　概述　　121
7.2 　定位模型　　122
7.3 　设定位置　　124
7.4 　最近定位祖先元素　　126
7.5 　堆叠上下文　　128
7.6 　原子显示　　130
7.7 　静态定位　　132
7.8 　绝对定位　　134
7.9 　固定定位　　136
7.10 　相对定位　　138
7.11 　浮动定位与复位　　140
7.12 　相对浮动定位　　142
第8章 　定位方式：缩进、偏移与对齐　　145
8.1 　概述　　145
8.2 　缩进　　146
8.3 　静态偏移　　148
8.4 　静态表格偏移与缩进　　150
8.5 　浮动偏移　　152
8.6 　绝对偏移与固定偏移　　154
8.7 　相对偏移　　156
8.8 　静态行内对齐　　158
8.9 　静态块级对齐与偏移　　160
8.10 　静态表格对齐与偏移　　162
8.11 　绝对对齐与偏移　　164
8.12 　绝对居中对齐　　166
8.13 　外部对齐　　168
第9章 　高级定位　　171
9.1 　概述　　171
9.2 　左对齐　　172
9.3 　左偏移　　174
9.4 　右对齐　　176
9.5 　右偏移　　178
9.6 　居中对齐　　180
9.7 　居中偏移　　182
9.8 　上对齐　　184
9.9 　上偏移　　186
9.10 　下对齐　　188
9.11 　下偏移　　190
9.12 　垂直居中对齐　　192
9.13 　垂直居中偏移　　194
第10章 　设置文字样式　　197
10.1 　概述　　197
10.2 　字体　　198
10.3 　高亮显示　　200
10.4 　文字修饰　　202
10.5 　文字阴影　　204
10.6 　使用图片替换文字　　206
10.7 　使用Canvas和VML替换文字　　208
10.8 　嵌入字体　　210
10.9 　不可见文字　　212
10.10 　仅供屏幕阅读器读取　　214
第11章 　内容间隔　　217
11.1 　间隔　　218
11.2 　块级化　　220
11.3 　不换行　　222
11.4 　保留空格　　224
11.5 　代码　　226
11.6 　填充内容　　228
11.7 　行内分隔区　　230
11.8 　行内装饰　　232
11.9 　换行　　234
11.10 　行内水平线规则　　236
第12章 　内容对齐　　239
12.1 　文字缩进　　240
12.2 　悬挂缩进　　242
12.3 　水平对齐内容　　244
12.4 　垂直对齐内容　　246
12.5 　垂直偏移内容　　248
12.6 　下标与上标　　250
12.7 　嵌套对齐　　252
12.8 　高级对齐示例　　254
第13章 　块级元素　　257
13.1 　概述　　257
13.2 　结构含义　　258
13.3 　可视化结构　　260
13.4 　节　　262
13.5 　列表　　264
13.6 　项目符号背景　　266
13.7 　行内化　　268
13.8 　合并外边距　　270
13.9 　插入　　272
13.10 　水平线规则　　274
13.11 　块级分隔区　　276
13.12 　块级间隔删除器　　278
13.13 　左旁注　　280
13.14 　右旁注　　282
第14章 　图片　　285
14.1 　概述　　285
14.2 　图片　　286
14.3 　图片地图　　288
14.4 　淡出　　290
14.5 　半透明　　292
14.6 　替换文字　　294
14.7 　内容覆盖图片　　296
14.8 　内容覆盖背景图片　　298
14.9 　CSS精灵图　　300
14.10 　CSS精灵图（续）　　302
14.11 　基本阴影图片　　304
14.12 　阴影图片　　306
14.13 　阴影图片（续）　　308
14.14 　阴影图片（再续）　　310
14.15 　圆角　　312
14.16 　圆角（续）　　314
14.17 　图片示例　　316
第15章 　表格　　319
15.1 　概述　　319
15.2 　表格　　320
15.3 　行组与列组　　322
15.4 　表格选择器　　324
15.5 　拆分边框　　326
15.6 　合并边框　　328
15.7 　合并边框样式　　330
15.8 　隐藏与删除单元格　　332
15.9 　删除与隐藏行和列　　334
15.10 　垂直对齐数据　　336
15.11 　表格条纹　　338
15.12 　表格化、行化和单元格化　　340
15.13 　表格布局　　342
第16章 　表格列布局　　345
16.1 　表格布局模型　　345
16.2 　使用列布局　　346
16.3 　概述　　346
16.4 　列宽　　348
16.5 　收缩适应列　　350
16.6 　设定尺寸列　　352
16.7 　按内容比例划分列　　354
16.8 　按宽度比例划分列　　356
16.9 　按百分比比例划分列　　358
16.10 　按反比例划分列　　360
16.11 　最小等宽列　　362
16.12 　等宽列　　364
16.13 　小尺寸列　　366
16.14 　弹性列　　368
16.15 　混合列布局　　370
第17章 　布局　　373
17.1 　概述　　373
17.2 　流动布局概述　　374
17.3 　由外而内框　　376
17.4 　浮动节　　380
17.5 　浮动分隔区　　382
17.6 　流动布局　　384
17.7 　两侧浮动　　386
17.8 　事件样式　　388
17.9 　卷起　　390
17.10 　选项卡菜单　　394
17.11 　选项卡　　398
17.12 　飞出菜单　　402
17.13 　按钮　　406
17.14 　布局链接　　410
17.15 　多列布局　　412
17.16 　模板布局　　414
17.17 　布局示例　　416
第18章 　首字下沉　　419
18.1 　概述　　419
18.2 　对齐首字下沉　　420
18.3 　首字母下沉　　422
18.4 　悬挂首字下沉　　424
18.5 　嵌入式图片下沉　　426
18.6 　浮动首字下沉　　428
18.7 　浮动图片下沉　　430
18.8 　旁注式首字下沉　　432
18.9 　旁注式图片下沉　　434
第19章 　突出引用与普通引用　　437
19.1 　概述　　437
19.2 　左浮动突出引用　　438
19.3 　右浮动突出引用　　440
19.4 　居中突出引用　　442
19.5 　左旁注突出引用　　444
19.6 　右旁注突出引用　　446
19.7 　块级普通引用　　448
19.8 　行内块级普通引用　　450
19.9 　行内普通引用　　452
第20章 　警告框　　455
20.1 　概述　　455
20.2 　JavaScript警告框　　456
20.3 　工具提示警告框　　458
20.4 　弹出式警告框　　460
20.5 　弹出式警告框（续）　　462
20.6 　警告框　　464
20.7 　行内警告框　　466
20.8 　悬挂式警告框　　468
20.9 　图片警告框　　470
20.10 　插入警告框　　472
20.11 　浮动警告框　　474
20.12 　左旁注警告框　　476
20.13 　右旁注警告框　　478
20.14 　表单验证　　480
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>HTML5与CSS3设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++设计模式
第Ⅰ部分 C++和Qt4简介
第1章 C++简介
第2章 类
第3章 Qt简介
第4章 列表
第5章 函数
第6章 继承与多态
第Ⅱ部分 高级编程
第7章 库
第8章 设计模式简介
第9章 QObject
第10章 范型与容器
第11章 Qt GUI部件
第12章 并行
第13章 验证与正则表达式
第14章 解析XML
第15章 元对象、性质和反射编程
第16章 更多设计模式
第17章 模型与视图
第18章 Qt SQL类
第Ⅲ部分 C++语言参考
第19章 类型与表达式
第20章 作用域类与存储类
第21章 语句与控制结构
第22章 内存访问
第23章 继承详述
第24章 其他相关话题
第Ⅳ部分 编程作业
第25章 MP3点唱机作业
第Ⅴ部分 附录
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>服务设计模式
译者序
Martin Fowler所作的序
Ian Robinson所作的序
前言
致谢
第1章　从对象到Web服务
1.1　Web服务是什么
1.2　从本地对象到分布式对象
1.3　为什么使用Web服务
1.4　Web服务的考虑因素和替代方案
1.5　服务和松散耦合的承诺
1.6　SOA是什么
1.7　总结
第2章　Web服务API风格
2.1　引言
2.2　设计Web服务API的考虑因素
2.3　RPC API
2.4　消息API
2.5　资源API
第3章　客户端与服务之间的交互
3.1　引言
3.2　请求/响应模式
3.3　请求/确认模式
3.4　媒体类型协商模式
3.5　链接服务
第4章　请求和响应管理
4.1　引言
4.2　服务控制器
4.3　数据传输对象
4.3.1　数据绑定考虑因素
4.3.2　总体考虑因素
4.4　请求映射器
4.5　响应映射器
第5章　Web服务实现风格
5.1　引言
5.2　Web服务实现的设计考虑因素
5.3　事务脚本
5.4　数据源适配器
5.5　操作脚本
5.6　命令调用器
5.7　工作流连接器
第6章　Web服务基础结构
6.1　引言
6.2　服务连接器
6.3　服务描述符
6.4　异步响应处理器
6.5　服务拦截器
6.6　幂等重试
6.7　SOA基础结构模式简述
6.7.1　服务注册表
6.7.2　企业服务总线
6.7.3　编排引擎
第7章　Web服务的演化
7.1　导言
7.2　导致破坏性变化的因素
7.2.1　对媒体类型或者消息的结构性修改
7.2.2　服务描述符变化
7.3　常见版本控制策略
7.4　单消息参数
7.5　数据集修改
7.6　宽容阅读器
7.7　消费者驱动契约
7.8　模式对服务演化的促进或者妨碍
附录　对外部模式的引用
词汇表
参考书目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>服务设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式解析
第一部分　面向对象软件开发简介
第1章　面向对象范型	2
1.1 概览	2
1.2 面向对象范型之前：功能分解	2
1.3 需求问题	4
1.4 应对变化：使用功能分解	5
1.5 应对需求变更	7
1.6 面向对象范型	10
1.7 面向对象程序设计实践	15
1.8 特殊对象方法	17
1.9 小结	18
复习题	19
简答题	19
阐述题	20
观点与应用题	20
第2章　UML	21
2.1 概览	21
2.2 什么是UML	21
2.3 为什么使用UML	22
2.4 类图	22
2.5 交互图	28
2.6 小结	30
复习题	30
简答题	30
阐述题	30
观点与应用题	30
第二部分 传统面向对象设计的局限
第3章　对代码灵活性要求很高的问题	33
3.1 概览	33
3.2 提取CAD/CAM系统的信息	33
3.3 了解专业术语	34
3.4 问题描述	35
3.5 挑战及其解决方案	37
3.6 小结	39
复习题	40
简答题	40
阐述题	40
观点与应用题	40
第4章　标准的面向对象解决方案	41
4.1 概览	41
4.2 作为特例来解决	41
4.3 小结	48
复习题	48
简答题	48
阐述题	49
观点与应用题	49
第三部分 设 计 模 式
第5章　设计模式简介	53
5.1 概览	53
5.2 设计模式源自建筑学和人类学	53
5.3 从建筑模式到软件设计模式	57
5.4 为什么学习设计模式	58
5.5 学习设计模式的其他好处	62
5.6 小结	63
复习题	63
简答题	63
阐述题	64
观点与应用题	64
第6章　Facade模式	65
6.1 概览	65
6.2 Facade模式简介	65
6.3 学习Facade模式	65
6.4 实践注记：Facade模式	68
6.5 Facade模式与CAD／CAM问题的联系	69
6.6 小结	70
复习题	70
简答题	70
阐述题	70
观点与应用题	71
第7章　Adapter模式	72
7.1 概览	72
7.2 Adapter模式简介	72
7.3 学习Adapter模式	73
7.4 实践注记：Adapter模式	77
7.5 Adapter模式与CAD/CAM问题的联系	80
7.6 小结	80
复习题	80
简答题	80
阐述题	81
观点与应用题	81
第8章　开拓视野	82
8.1 概览	82
8.2 对象：传统看法与新看法	83
8.3 封装：传统看法与新看法	84
8.4 发现变化并将其封装	87
8.5 共性和可变性分析与抽象类	90
8.6 敏捷编程的品质	92
8.7 小结	95
复习题	96
简答题	96
阐述题	96
观点与应用题	97
第9章　Strategy模式	98
9.1 概览	98
9.2 处理新需求的一种途径	98
9.3 国际电子商务系统案例研究：最初的需求	100
9.4 处理新的需求	101
9.5 Strategy模式	108
9.6 实践注记：使用Strategy模式	110
9.7 小结	111
复习题	111
简答题	111
阐述题	112
观点与应用题	112
第10章　Bridge模式	113
10.1 概览	113
10.2 Bridge模式简介	113
10.3 学习Bridge模式：示例	114
10.4 对使用设计模式的观察	123
10.5 学习Bridge模式：通过将它推演出来	124
10.6 Bridge模式回顾	131
10.7 实践注记：使用Bridge模式	132
10.8 小结	135
复习题	137
简答题	137
阐述题	137
观点与应用题	137
第11章　Abstract Factory模式	138
11.1 概览	138
11.2 Abstract Factory模式简介	138
11.3 学习Abstract Factory模式：示例	138
11.4 学习Abstract Factory模式：实现该模式	144
11.5 实践注记：Abstract Factory模式	149
11.6 将Abstract Factory模式与CAD/CAM问题联系起来	151
11.7 小结	151
复习题	152
简答题	152
阐述题	152
观点与应用题	152
第四部分 组合起来：用模式思考
第12章　专家设计之道	154
12.1 概览	154
12.2 添加特征的创建方式	154
12.3 小结	160
复习题	160
简答题	160
阐述题	161
观点与应用题	161
第13章　用模式解决CAD/CAM问题	162
13.1 概览	162
13.2 对CAD/CAM问题的回顾	162
13.3 用模式思考	163
13.4 用模式思考：步骤1	164
13.5 用模式思考：步骤2a	165
13.6 用模式思考：步骤2b	169
13.7 用模式思考：步骤2c	172
13.8 用模式思考：重复步骤2a和步骤2b（Facade模式）	173
13.9 用模式思考：重复步骤2a和步骤2b（Adapter模式）	174
13.10 用模式思考：重复步骤2a和步骤2b（Abstract Factory模式）	174
13.11 用模式思考：步骤3	175
13.12 与原解决方案的比较	175
13.13 小结	176
复习题	177
简答题	177
阐述题	177
观点与应用题	177
第五部分 迈向新的设计方式
第14章　设计模式的原则与策略	180
14.1 概览	180
14.2 开闭原则	181
14.3 从背景设计原则	181
14.4 封装变化原则	185
14.5 抽象类与接口	186
14.6 理性怀疑原则	187
14.7 小结	187
复习题	188
简答题	188
阐述题	188
观点与应用题	188
第15章　共性与可变性分析	189
15.1 概览	189
15.2 共性和可变性分析与应用程序设计	189
15.3 用CVA解决CAD/CAM问题	190
15.4 小结	194
复习题	194
简答题	194
阐述题	194
观点与应用题	195
第16章　分析矩阵	196
16.1 概览	196
16.2 现实世界：充满变化	196
16.3 国际电子商务系统案例研究：应对变化	197
16.4 实践注记	203
16.5 小结	206
复习题	206
简答题	206
阐述题	206
观点与应用题	206
第17章　Decorator模式	207
17.1 概览	207
17.2 更多细节	207
17.3 Decorator模式	209
17.4 将Decorator模式应用到我们的案例研究	210
17.5 另一个例子：输入/输出	213
17.6 实践注记：使用Decorator模式	215
17.7 Decorator模式的本质	216
17.8 小结	217
复习题	217
简答题	217
阐述题	217
观点与应用题	217
第六部分 其他重要模式
第18章　Observer模式	220
18.1 概览	220
18.2 模式的分类	220
18.3 国际电子商务案例的更多需求	221
18.4 Observer模式	222
18.5 将Observer模式应用到我们的案例研究	223
18.6 实践注记：使用Observer模式	227
18.7 小结	229
复习题	229
简答题	229
阐述题	230
观点与应用题	230
第19章　Template Method模式	231
19.1 概览	231
19.2 案例研究的更多需求	231
19.3 Template Method模式	232
19.4 将Template Method模式应用到我们的案例研究	232
19.5 使用Template Method模式减少冗余	233
19.6 实践注记：使用Template Method模式	238
19.7 小结	239
复习题	240
简答题	240
阐述题	240
第七部分 各种工厂模式
第20章　来自设计模式的教益：各种工厂模式	242
20.1 概览	242
20.2 工厂	242
20.3 再谈背景	243
20.4 工厂遵循我们的准则	245
20.5 限制变化的影响	246
20.6 对工厂的另一种思考方式	246
20.7 工厂的不同角色	247
20.8 实践注记	247
20.9 小结	248
复习题	248
简答题	248
阐述题	248
观点与应用题	248
第21章　Singleton模式和Double-Checked Locking模式	249
21.1 概览	249
21.2 Singleton模式简介	249
21.3 将Singleton模式应用到我们的案例研究	250
21.4 一种变体：Double-Checked Locking模式	252
21.5 反思	255
21.6 实践注记：使用Singleton模式和Double-Checked Locking模式	255
21.7 小结	256
复习题	256
简答题	256
阐述题	256
观点与应用题	256
第22章　Object Pool模式	257
22.1 概览	257
22.2 一个需要对对象进行管理的问题	257
22.3 Object Pool模式	263
22.4 观察：工厂的作用不仅是实例化	263
22.5 小结	265
复习题	265
简答题	265
阐述题	266
观点与应用题	266
第23章　Factory Method模式	267
23.1 概览	267
23.2 案例研究的更多需求	267
23.3 Factory Method模式	268
23.4 Factory Method模式与面向对象语言	268
23.5 实践注记：使用Factory Method模式	269
23.6 小结	270
复习题	271
简答题	271
阐述题	271
观点与应用题	271
第24章　工厂模式的总结	272
24.1 概览	272
24.2 软件开发过程中的步骤	272
24.3 工厂与极限编程实践殊途同归	273
24.4 系统的扩展性	273
第八部分 终点与起点
第25章　设计模式回顾：总结与新起点	276
25.1 概览	276
25.2 面向对象原则的总结	276
25.3 设计模式如何封装实现	277
25.4 共性和可变性分析与设计模式	277
25.5 按责任分解问题域	278
25.6 模式和从背景设计	279
25.7 模式内部的关联	279
25.8 设计模式与敏捷编程实践	281
25.9 实践注记	281
25.10 小结	281
复习题	282
简答题	282
阐述题	282
观点与应用题	282
第26章　参考书目	283
26.1 本书配套网站	283
26.2 推荐阅读	284
26.3 针对Java程序员的推荐读物	285
26.4 针对C++程序员的推荐读物	286
26.5 针对COBOL程序员的推荐读物	287
26.6 极限编程的推荐读物	287
26.7 程序设计的一般性推荐读物	287
26.8 个人推荐	288
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式解析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MapReduce设计模式
第1章　设计模式与MapReduce　1
1．1　设计模式　2
1．2　MapReduce简史　3
1．3　MapReduce和Hadoop简介　4
1．4　Hadoop示例：单词计数　6
1．5　Pig和Hive　10
第2章　概要模式　12
2．1　数值概要　12
2．1．1　模式描述　12
2．1．2　数值概要示例　16
2．2　倒排索引概要　30
2．2．1　模式描述　30
2．2．2　倒排索引示例　32
2．3　计数器计数　34
2．3．1　模式描述　34
2．3．2　计数器计数示例　36
第3章　过滤模式　39
3．1　过滤　40
3．1．1　模式描述　40
3．1．2　过滤示例　43
3．2　布隆过滤　45
3．2．1　模式描述　45
3．2．2　布隆过滤器示例　48
3．3　Top 10　53
3．3．1　模式描述　53
3．3．2　Top 10示例　58
3．4　去重　60
3．4．1　模式描述　60
3．4．2　去重示例　63
第4章　数据组织模式　65
4．1　分层结构　65
4．1．1　模式描述　65
4．1．2　分层结构示例　69
4．2　分区　76
4．2．1　模式描述　76
4．2．2　分区示例　79
4．3　分箱　81
4．3．1　模式描述　81
4．3．2　分箱示例　83
4．4　全排序　85
4．4．1　模式描述　85
4．4．2　全排序示例　88
4．5　混排　92
4．5．1　模式描述　92
4．5．2　混排示例　93
第5章　连接模式　96
5．1　连接简介　97
5．2　reduce端连接　102
5．2．1　模式描述　102
5．2．2　reduce端连接示例　104
5．2．3　使用布隆过滤器的reduce端连接　110
5．3　复制连接　112
5．3．1　模式描述　112
5．3．2　复制连接示例　114
5．4　组合连接　116
5．4．1　模式描述　116
5．4．2　组合连接示例　119
5．5　笛卡儿积　121
5．5．1　模式描述　121
5．5．2　笛卡儿积示例　124
第6章　元模式　131
6．1　作业链　131
6．1．1　关于驱动程序　132
6．1．2　作业链示例　133
6．1．3　关于shell脚本　142
6．1．4　关于JobControl　145
6．2　链折叠　149
6．2．1　ChainMapper方法和ChainReducer方法　153
6．2．2　链折叠示例　153
6．3　作业归并　158
作业归并示例　160
第7章　输入和输出模式　166
7．1　在Hadoop中自定义输入和输出　166
7．1．1　InputFormat　167
7．1．2　RecordReader　168
7．1．3　OutputFormat　169
7．1．4　RecordWriter　170
7．2　生成数据　170
7．2．1　模式描述　170
7．2．2　生成数据示例　172
7．3　外部源输出　177
7．3．1　模式描述　177
7．3．2　外部源输出示例　179
7．4　外部源输入　183
7．4．1　模型描述　183
7．4．2　外部源输入示例　185
7．5　分区裁剪　190
7．5．1　模式描述　190
7．5．2　分区裁剪示例　192
第8章　最后的思考与设计模式的未来　203
8．1　数据的本质趋势　203
8．1．1　图像、音频和视频　203
8．1．2　流式数据　204
8．2　YARN的影响　204
8．3　作为库或者组件的模式　205
8．4　读者可以帮到什么　205
附录　布隆过滤器　207
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MapReduce设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ASP.NET设计模式
目    录

第Ⅰ部分  模式与设计原则
第1章  成功应用程序的模式	3
1.1  设计模式释义	3
1.1.1  起源	4
1.1.2  必要性	4
1.1.3  有效性	4
1.1.4  局限性	5
1.2  设计原则	5
1.2.1  常见设计原则	5
1.2.2  S.O.L.I.D.设计原则	6
1.3  Fowler的企业设计模式	7
1.3.1  分层	7
1.3.2  领域逻辑模式	7
1.3.3  对象关系映射	8
1.3.4  Web表示模式	9
1.3.5  基本模式、行为模式和结构模式	9
1.4  其他有名的设计实践	10
1.4.1  测试驱动设计	10
1.4.2  领域驱动设计	10
1.4.3  行为驱动设计	10
1.5  小结	11
第2章  剖析模式的模式	13
2.1  如何阅读设计模式	13
2.1.1  GoF模式模板	13
2.1.2  简化模板	14
2.2  设计模式分组	14
2.2.1  创建型	14
2.2.2  结构型	15
2.2.3  行为型	15
2.3  如何选择和运用设计模式	16
2.4  快速模式示例	17
2.4.1  根据设计原则进行重构	19
2.4.2  根据Adapter模式进行重构	21
2.4.3  利用企业模式	24
2.5  小结	25
第Ⅱ部分  剖析ASP.NET应用程序：
学习并应用模式
第3章  应用程序分层与关注点分离	29
3.1  应用程序体系结构与设计	29
3.1.1  反模式：智能UI	29
3.1.2  分离关注点	35
3.2  小结	51
第4章  业务逻辑层：组织	53
4.1  理解业务组织模式	53
4.1.1  Transaction Script	53
4.1.2  Active Record	55
4.1.3  Domain Model	65
4.1.4  Anemic Domain Model	86
4.1.5  领域驱动设计	88
4.2  小结	91
第5章  业务逻辑层：模式	93
5.1  应用设计模式	93
5.1.1  Factory Method模式	93
5.1.2  Decorator模式	97
5.1.3  Template Method模式	103
5.1.4  State模式	107
5.1.5  Strategy模式	113
5.2  应用企业模式	117
5.2.1  Specification模式	117
5.2.2  Composite模式	119
5.2.3  Layer Supertype模式	124
5.3  应用设计原则	127
5.3.1  依赖倒置原则和依赖注入模式	127
5.3.2  接口分离原则	133
5.3.3  里氏替换原则	137
5.4  小结	147
第6章  服务层	149
6.1  服务层介绍	149
6.1.1  SOA	149
6.1.2  SOA的4项信条	152
6.1.3  Facade设计模式	152
6.2  应用Messaging模式	153
6.2.1  Document Message和
Request-Response模式	154
6.2.2  Reservation模式	155
6.2.3  Idempotent模式	156
6.3  SOA示例	156
6.3.1  领域模型和资源库	157
6.3.2  服务层	166
6.3.3  客户端代理	180
6.3.4  客户端	183
6.4  小结	187
第7章  数据访问层	189
7.1  DAL介绍	189
7.2  数据访问策略	189
7.2.1  Repository模式	190
7.2.2  Data Access Objects模式	191
7.3  数据访问模式	191
7.3.1  Unit of Work模式	191
7.3.2  数据并发控制	198
7.3.3  Lazy Loading和Proxy模式	201
7.3.4  Identity Map模式	206
7.3.5  Query Object模式	208
7.4  使用对象关系映射器	218
7.4.1  NHibernate	219
7.4.2  MS Entity Framework	219
7.4.3  ORM代码示例	219
7.5  小结	280
第8章  表示层	283
8.1  反转控制	283
8.1.1  Factory Method设计模式	283
8.1.2  Service Locator	285
8.1.3  IoC容器	286
8.1.4  StructureMap	286
8.2  Model-View-Presenter	290
8.3  Front Controller	313
8.3.1  Command模式	314
8.3.2  Chain of Responsibility模式	336
8.4  Model-View-Controller	344
8.4.1  ViewModel模式	344
8.4.2  ASP.NET MVC框架	345
8.4.3  利用AutoMapper映射ViewModel	357
8.4.4  Castle MonoRail	362
8.5  Page Controller模式	369
8.6  小结	370
第9章  用户体验层	371
9.1  什么是AJAX	371
9.2  使用JavaScript库	372
9.3  理解AJAX模式	372
9.3.1  Periodic Refresh和Timeout	372
9.3.2  Unique URL	390
9.3.3  利用JavaScript Template实现数据
绑定	390
9.3.4  Predictive Fetch	408
9.4  小结	414
第Ⅲ部分  案例研究：
在线电子商务商店
第10章  需求和基础设施	417
10.1  Agatha服装店需求	417
10.1.1  Product Catalog和Basket截屏	418
10.1.2  顾客账号屏幕	420
10.1.3  结账屏幕	422
10.1.4  缓存和日志	423
10.2  架构	423
10.3  小结	443
第11章  创建商品目录	445
11.1  创建产品目录	445
11.1.1  Product Catalog模型	445
11.1.2  Product Catalog数据表	450
11.1.3  Product Catalog资源库	451
11.1.4  Product服务	465
11.1.5  控制器	480
11.1.6  Product Catalog视图	490
11.1.7  设置IoC	513
11.2  小结	516
第12章  实现购物车	519
12.1  实现购物车	519
12.1.1  Basket领域模型	519
12.1.2  创建购物车数据表	529
12.1.3  NHibernate映射	530
12.1.4  购物车服务	533
12.1.5  购物车控制器和购物车视图	543
12.2  小结	565
第13章  顾客会员	567
13.1  顾客会员	567
13.1.1  Customer模型	568
13.1.2  Customer数据表	573
13.1.3  Customer NHibernate映射	573
13.1.4  Customer服务	576
13.1.5  身份验证服务	585
13.1.6  Customer控制器	593
13.1.7  Account控制器	597
13.1.8  顾客关系视图	607
13.1.9  身份验证视图	611
13.2  小结	617
第14章  订购和支付	619
14.1  结账	619
14.1.1  Order模型	620
14.1.2  Order数据表	635
14.1.3  Order NHibernate映射	636
14.1.4  Order服务	639
14.1.5  利用PalPay进行支付	648
14.1.6  Order、Payment与Checkout
控制器	657
14.1.7  Order和Checkout视图	666
14.2  小结	676

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ASP.NET设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js 设计模式（第 2 版）
第1 章欢迎来到Node.js 平台 1
Node.js 的哲学思想2
小核心2
小模块2
小接触面3
简单和实用3
认识Node.js 6 和ES2015 4
let 和const 关键字5
箭头函数6
类语法8
增强的对象字面量10
Map 和Set 集合11
WeakMap 和WeakSet 集合13
模板字面量14
其他ES2015 特性14
Reactor 模式15
I/O 是缓慢的15
阻塞I/O 15
非阻塞I/O 16
事件多路分解器17
Reactor 模式简介19
Node.js-libuv 的非阻塞I/O 引擎20
Node.js 的秘诀21
总结21
第2 章Node.js 基础设计模式  23
回调模式24
CPS（Continuation Passing Style） 24
同步或异步26
Node.js 回调约定31
模块系统及其模式34
揭示模块模式34
Node.js 模块解释35
模块定义模式42
观察者模式49
EventEmitter 类49
创建和使用EventEmitter 50
传播错误51
使任何对象可观察51
同步和异步事件53
EventEmitter 与回调54
组合回调和EventEmitter 55
总结55
第3 章异步控制流模式之回调函数  56
异步编程的困难56
创建一个简单的网络蜘蛛57
回调地狱59
使用纯JavaScript 60
回调规则60
应用回调规则61
顺序执行63
并行执行68
有限制的并行执行73
async 库77
顺序执行78
并行执行81
有限制的并行执行81
总结83
第4 章异步控制流模式之ES2015+   84
promise 84
什么是promise 85
Promises/A+ 实现87
Node.js 风格函数的promise 化88
顺序执行90
并行执行93
有限制的并行执行93
在公共API 中暴露callback 和promise 95
generator 97
generator 基础97
generator 的异步控制流100
顺序执行104
并行执行106
有限制的并行执行108
使用Babel 的async await 111
安装和运行Babel 112
比较113
总结114
第5 章流编程  115
流的重要性115
缓冲和流116
空间效率117
时间效率118
组合性121
开始学习流122
流的分类122
可读流123
可写流127
双向流(Duplex stream) 132
变换流132
使用管道拼接流135
使用流处理异步流程137
顺序执行138
无序并行执行139
无序有限制的并行执行143
顺序并行执行145
管道模式146
组合流146
复制流149
合并流150
复用和分解152
总结159
第6 章设计模式  160
工厂模式161
创建对象的通用接口161
一种封装的机制162
构建一个简单的代码分析器164
可组合的工厂函数166
扩展169
揭示构造函数170
只读事件触发器171
扩展172
代理模式173
实现代理模式的方法174
不同方法的比较176
创建日志记录的写入流176
生态系统中的代理模式——函数钩子与面向行为编程(AOP) 178
ES2015 中的Proxy 对象178
扩展180
装饰者模式(Decorator) 180
实现装饰者模式的方法181
装饰一个LevelUP 数据库182
扩展185
适配器模式(Adapter) 185
通过文件系统API 来使用LevelUP 数据库186
扩展189
策略模式(Strategy) 189
支持多种格式的配置对象190
扩展193
状态模式193
实现一个基本的自动防故障套接字194
模板模式(Template) 199
配置管理器模板199
扩展201
中间件(Middleware) 202
Express 中的中间件202
设计模式中的中间件203
为ØMQ 创建中间件框架204
在Koa 中使用生成器的中间件210
命令模式(Command) 213
灵活的设计模式214
总结218
第7 章连接模块  220
模块和依赖221
Node.js 中最常见的依赖221
内聚和耦合222
有状态的模块222
连接模块模式224
硬编码依赖224
依赖注入229
服务定位器234
依赖注入容器239
连接插件243
插件作为包243
扩展点245
插件控制与应用程序控制的扩展245
实现注销插件248
总结256
第8 章通用JavaScript 的Web 应用程序  257
与浏览器端共享代码258
共享模块258
Webpack 简介262
Webpack 的魔力263
Webpack 的优点264
使用ES2015 和Webpack 265
跨平台开发基础267
运行时代码分支268
构建时代码分支269
模块交换271
用于跨平台开发的设计模式273
React 介绍274
第一个React 组件275
JSX 是什么277
配置Webpack 以实现JSX 转换279
在浏览器中渲染280
React 路由库281
创建通用JavaScript 应用程序286
创建可用的组件287
服务端渲染289
通用渲染和路由293
通用数据检索294
总结304
第9 章高级异步编程技巧  305
需要异步初始化的模块305
规范解决方案306
预初始化队列307
题外话311
异步批处理和缓存312
实现没有缓存或批处理的服务器312
异步请求批处理314
异步请求缓存316
使用promise 进行批处理和缓存319
运行CPU 绑定的任务322
解决子集和问题322
交叉使用setImmediate 325
使用多进程328
总结335
第10 章扩展与架构模式  336
应用程序扩展介绍337
扩展Node.js 应用程序337
可扩展性的三个维度337
克隆和负载均衡339
集群模块340
处理有状态通信348
使用反向代理进行扩展350
使用服务注册表354
对等负载均衡360
分解复杂的应用程序362
单体式架构362
微服务架构364
微服务架构中的集成模式367
总结372
第11 章消息传递与集成模式  374
消息系统的基础375
单向和请求/应答模式375
消息类型376
异步消息和队列377
对等或基于代理的消息378
发布/订阅模式379
构建简约的实时聊天应用程序380
使用Redis 作为消息代理383
使用ØMQ 对等发布/订阅385
持久订阅者389
管道和任务分配模式396
ØMQ 扇出/扇入模式397
使用AMQP 实现管道和竞争消费者模式401
请求/应答模式406
关联标识符406
返回地址410
总结415
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js 设计模式（第 2 版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式
第1章 统一建模语言基础知识
1.1 uml简介
1.2 类图
1.3 顺序图
1.4 状态图
1.5 本章小结
思考与练习
第2章 面向对象设计原则
2.1 面向对象设计原则概述
2.2 单一职责原则
2.3 开闭原则
2.4 里氏代换原则
2.5 依赖倒转原则
2.6 接口隔离原则
2.7 合成复用原则
2.8 迪米特法则
2.9 本章小结
思考与练习
第3章 设计模式概述
3.1 设计模式的诞生与发展
3.2 设计模式的定义与分类
3.3 gof设计模式简介
3.4 设计模式的优点
3.5 本章小结
思考与练习
第4章 简单工厂模式
4.1 创建型模式
4.2 简单工厂模式动机与定义
4.3 简单工厂模式结构与分析
4.4 简单工厂模式实例与解析
4.5 简单工厂模式效果与应用
4.6 简单工厂模式扩展
4.7 本章小结
思考与练习
第5章 工厂方法模式
5.1 工厂方法模式动机与定义
5.2 工厂方法模式结构与分析
5.3 工厂方法模式实例与解析
5.4 工厂方法模式效果与应用
5.5 工厂方法模式扩展
5.6 本章上结
思考与练习
第6章 抽象工厂模式
6.1 抽象工厂模式动机与定义
6.2 抽象工厂模式结构与分析
6.3 抽象工厂模式实例与解析
6.4 抽象工厂模式效果与应用
6.5 抽象工厂模式扩展
6.6 本章小结
思考与练习
第7章 建造者模式
7.1 建造者模式动机与定义
7.2 建造者模式结构与分析
7.3 建造者模式实例与解析
7.4 建造者模式效果与应用
7.5 建造者模式扩展
7.6 本章小结
思考与练习
第8章 原型模式
8.1 原型模式动机与定义
8.2 原型模式结构与分析
8.3 原型模式实例与解析
8.4 原型模式效果与应用
8.5 原型模式扩展
8.6 本章小结
思考与练习
第9章 单例模式
9.1 单例模式动机与定义
9.2 单例模式结构与分析
9.3 单例模式实例与解析
9.4 单例模式效果与应用
9.5 单例模式扩展
9.6 本章小结
思考与练习
第10章 适配器模式
10.1 结构型模式
10.2 适配器模式动机与定义
10.3 适配器模式结构与分析
10.4 适配器模式实例与解析
10.5 适配器模式效果与应用
10.6 适配器模式扩展
10.7 本章小结
思考与练习
第11章 桥接模式
11.1 桥接模式动机与定义
11.2 桥接模式结构与分析
11.3 桥接模式实例与解析
11.4 桥接模式效果与应用
11.5 桥接模式扩展
11.6 本章小结
思考与练习
第12章 组合模式
12.1 组合模式动机与定义
12.2 组合模式结构与分析
12.3 组合模式实例与解析
12.4 组合模式效果与应用
12.5 组合模式扩展
12.6 本章小结
思考与练习
第13章 装饰模式
13.1 装饰模式动机与定义
13.2 装饰模式结构与分析
13.3 装饰模式实例与解析
13.4 装饰模式效果与应用
13.5 装饰模式扩展
13.6 本章小结
思考与练习
第14章 外观模式
14.1 外观模式动机与定义
14.2 外观模式结构与分析
14.3 外观模式实例与解析
14.4 外观模式效果与应用
14.5 外观模式扩展
14.6 本章小结
思考与练习
第15章 享元模式
15.1 享元模式动机与定义
15.2 享元模式结构与分析
15.3 享元模式实例与解析
15.4 享元模式效果与应用
15.5 享元模式扩展
15.6 本章小结
思考与练习
第16章 代理模式
16.1 代理模式动机与定义
16.2 代理模式结构与分析
16.3 代理模式实例与解析
16.4 代理模式效果与应用
16.5 代理模式扩展
16.6 本章小结
思考与练习
第17章 职责链模式
17.1 行为型模式
17.2 职责链模式动机与定义
17.3 职责链模式结构与分析
17.4 职责链模式实例与解析
17.5 职责链模式效果与应用
17.6 职责链模式扩展
17.7 本章上结
思考与练习
第18章 命令模式
18.1 命令模式动机与定义
18.2 命令模式结构与分析
18.3 命令模式实例与解析
18.4 命令模式效果与应用
18.5 命令模式扩展
18.6 本章小结
思考与练习
第19章 解释器模式
19.1 解释器模式动机与定义
19.2 解释器模式结构与分析
19.3 解释器模式实例与解析
19.4 解释器模式效果与应用
19.5 解释器模式扩展
19.6 本章小结
思考与练习
第20章 迭代器模式
20.1 迭代器模式动机与定义
20.2 迭代器模式结构与分析
20.3 迭代器模式实例与解析
20.4 迭代器模式效果与应用
20.5 迭代器模式扩展
20.6 本章小结
思考与练习
第21章 中介者模式
21.1 中介者模式动机与定义
21.2 中介者模式结构与分析
21.3 中介者模式实例与解析
21.4 中介者模式效果与应用
21.5 中介者模式扩展
21.6 本章小结
思考与练习
第22章 备忘录模式
22.1 备忘录模式动机与定义
22.2 备忘录模式结构与分析
22.3 备忘录模式实例与解析
22.4 备忘录模式效果与应用
22.5 备忘录模式扩展
22.6 本章小结
思考与练习
第23章 观察者模式
23.1 观察者模式动机与定义
23.2 观察者模式结构与分析
23.3 观察者模式实例与解析
23.4 观察者模式效果与应用
23.5 观察者模式扩展
23.6 本章小结
思考与练习
第24章 状态模式
24.1 状态模式动机与定义
24.2 状态模式结构与分析
24.3 状态模式实例与解析
24.4 状态模式效果与应用
24.5 状态模式扩展
24.6 本章小结
思考与练习
第25章 策略模式
25.1 策略模式动机与定义
25.2 策略模式结构与分析
25.3 策略模式实例与解析
25.4 策略模式效果与应用
25.5 策略模式扩展
25.6 本章小结
思考与练习
第26章 模板方法模式
26.1 模板方法模式动机与定义
26.2 模板方法模式结构与分析
26.3 模板方法模式实例与解析
26.4 模板方法模式效果与应用
26.5 模板方法模式扩展
26.6 本章小结
思考与练习
第27章 访问者模式
27.1 访问者模式动机与定义
27.2 访问者模式结构与分析
27.3 访问者模式实例与解析
27.4 访问者模式效果与应用
27.5 访问者模式扩展
27.6 本章小结
思考与练习
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE设计模式
第1章　企业级java应用程序架构和设计
简介	1
1.1　分布式计算的发展历程	1
1.1.1　单层架构	2
1.1.2　两层架构	2
1.1.3　三层架构	2
1.1.4　多层架构	4
1.1.5　java ee架构	4
1.2　java ee应用程序设计	8
1.3　java ee设计模式目录	9
1.4　使用uml描述java ee架构和设计	10
1.4.1　类图	10
1.4.2　序列图	12
1.5　小结	13
第2章　使用spring框架简化企业级java
应用程序	14
2.1　什么是spring	14
2.2　为什么spring很重要	14
2.3　spring框架的组成部分	16
2.3.1　spring core	16
.2.3.2　spring aop	22
2.3.3　spring dao	23
2.3.4　spring orm	23
2.3.5　jee	23
2.3.6　web mvc	23
2.4　使用spring构建分层应用程序	23
2.4.1　表现层	24
2.4.2　业务层	25
2.4.3　集成层	25
2.5　spring java设计模式讲解模板	26
2.5.1　名称	26
2.5.2　问题描述	26
2.5.3　模式目的	26
2.5.4　解决方案	26
2.5.5　模式评价	26
2.6　小结	26
第3章　表现层设计模式	27
3.1　前端控制器	28
3.1.1　问题描述	28
3.1.2　模式目的	30
3.1.3　解决方案	30
3.1.4　模式评价	33
3.2　应用程序控制器	33
3.2.1　问题描述	33
3.2.2　模式目的	34
3.2.3　解决方案	34
3.2.4　模式评价	46
3.3　页面控制器	47
3.3.1　问题描述	47
3.3.2　模式目的	47
3.3.3　解决方案	47
3.3.4　模式评价	63
3.4　上下文对象模式	64
3.4.1　问题描述	64
3.4.2　模式目的	64
3.4.3　解决方案	64
3.4.4　模式评价	70
3.5　拦截过滤器模式	70
3.5.1　问题描述	70
3.5.2　模式目的	70
3.5.3　解决方案	71
3.5.4　模式评价	76
3.6　视图助手模式	76
3.6.1　问题描述	76
3.6.2　模式目的	76
3.6.3　解决方案	77
3.6.4　模式评价	84
3.7　组合视图模式	85
3.7.1　问题描述	85
3.7.2　模式目的	85
3.7.3　解决方案	85
3.7.4　模式评价	89
3.8　分发者视图模式	89
3.8.1　问题描述	89
3.8.2　模式目的	89
3.8.3　解决方案	90
3.8.4　模式评价	94
3.9　服务到工作者模式	94
3.9.1　问题描述	94
3.9.2　模式目的	94
3.9.3　解决方案	95
3.9.4　模式评价	95
3.10　小结	96
第4章　业务层设计模式	97
4.1　服务定位器模式	97
4.1.1　问题描述	97
4.1.2　模式目的	100
4.1.3　解决方案	100
4.1.4　模式评价	109
4.2　业务代理模式	109
4.2.1　问题描述	109
4.2.2　模式目的	109
4.2.3　解决方案	109
4.2.4　模式评价	111
4.3　会话外观模式	112
4.3.1　问题描述	112
4.3.2　模式目的	112
4.3.3　解决方案	112
4.3.4　模式评价	116
4.4　应用程序服务模式	117
4.4.1　问题描述	117
4.4.2　模式目的	117
4.4.3　解决方案	118
4.4.4　模式评价	120
4.5　业务接口模式	121
4.5.1　问题描述	121
4.5.2　模式目的	121
4.5.3　解决方案	121
4.5.4　模式评价	127
4.6　小结	127
第5章　集成层设计模式	128
5.1　数据访问对象模式	128
5.1.1　问题描述	128
5.1.2　模式目的	131
5.1.3　解决方案	131
5.1.4　模式评价	140
5.2　过程访问对象模式	140
5.2.1　问题描述	140
5.2.2　模式目的	140
5.2.3　解决方案	140
5.2.4　模式评价	143
5.3　服务触发器模式	143
5.3.1　问题描述	143
5.3.2　模式目的	144
5.3.3　解决方案	144
5.3.4　模式评价	151
5.4　web服务代理模式	151
5.4.1　问题描述	151
5.4.2　模式目的	151
5.4.3　解决方案	152
5.4.4　模式评价	161
5.5　小结	161
第6章　横切设计模式	162
6.1　验证和授权实施者模式	163
6.1.1　问题描述	163
6.1.2　模式目的	164
6.1.3　解决方案	164
6.1.4　模式评价	182
6.2　审核拦截器模式	182
6.2.1　问题描述	182
6.2.2　模式目的	182
6.2.3　解决方案	183
6.2.4　模式评价	189
6.3　域服务所有者事务模式	189
6.3.1　问题描述	189
6.3.2　模式目的	189
6.3.3　解决方案	190
6.3.4　模式评价	197
6.4　小结	197
第7章　案例研究：构建订单管理系统	198
7.1　需求	198
7.1.1　用户故事卡：用户登录	199
7.1.2　用户故事卡：查询服务	199
7.1.3　用户故事卡：保存订单	199
7.2　迭代规划	199
7.3　架构	200
7.3.1　表现层	200
7.3.2　业务层	201
7.3.3　集成层	202
7.4　设计	202
7.5　安全机制	203
7.5.1　问题描述	203
7.5.2　模式目的	203
7.5.3　解决方案	203
7.6　jsp	203
7.6.1　问题描述	203
7.6.2　模式目的	204
7.6.3　解决方案	204
7.7　页面控制器	204
7.7.1　问题描述	204
7.7.2　模式目的	204
7.7.3　解决方案	204
7.8　开发	205
7.8.1　创建工作区	206
7.8.2　创建项目	207
7.8.3　添加依赖关系	208
7.8.4　构建项目	210
7.8.5　部署项目	219
7.9　小结	227
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>漫谈设计模式
第一篇 模式介绍	1
第1章 谈面向对象和模式	3
1.1 什么是对象	4
1.2 面向对象的好处	5
1.3 重用	6
1.4 模式简史	7
1.5 什么是模式	8
1.6 学习设计模式的一些常见问题	11
1.7 本章关键词	13
第2章 第1个模式——模板方法（template method）模式	15
2.1 从回家过年说起	16
2.1.1 DRY（don't repeat yourself）	18
2.1.2 变化+重复，如何维护	20
2.2 模板方法（template method）模式	21
2.2.1 使用继承	21
2.2.2 模板方法模式	24
2.3 引入回调（callback）	26
2.4 总结	30
2.5 本章关键词	30
第二篇 创建对象	31
第3章 单例（singleton）模式	33
3.1 最简单的单例	34
3.2 进阶	35
3.2.1 延迟创建	35
3.2.2 线程安全	36
3.2.3 double-check locking	37
3.2.4 initialization on demand holder	39
3.2.5 singleton的序列化	40
3.3 总结	41
3.4 本章关键词	42
第4章 工厂方法（factory method）模式	43
4.1 工厂方法模式	44
4.1.1 类图	44
4.1.2 创建数据库连接对象	47
4.2 静态工厂方法	52
4.3 总结	53
4.4 本章关键词	54
第5章 原型（prototype）模式	55
5.1 原型模式	56
5.2 寄个快递	57
5.3 实现	57
5.3.1 uml静态类图	57
5.3.2 代码实现	58
5.4 深拷贝（deep copy）	61
5.5 总结	65
5.6 本章关键词	65
第6章 控制反转（ioc）	67
6.1 从创建对象谈起	68
6.2 使用工厂方法模式的问题	70
6.3 inversion of control（控制反转）	71
6.3.1 ioc和di（dependency injection，依赖注入）	72
6.3.2 service locator（服务定位器）	73
6.3.3 dependency injection	76
6.4 总结	91
6.5 本章关键词	92
第三篇 构建复杂结构	93
第7章 装饰器（decorator）模式	95
7.1 记录历史修改	96
7.2 open-closed principle（开放—封闭原则，ocp）	99
7.3 装饰器（decorator）模式	101
7.3.1 类图	101
7.3.2 实现	101
7.3.3 一点变化	107
7.3.4 如何使用	108
7.3.5 测试	108
7.4 装饰器模式的优缺点	110
7.5 总结	111
7.6 本章关键词	111
第8章 代理（proxy）模式	113
8.1 代理（proxy）模式	114
8.1.1 类图	114
8.1.2 访问分布式对象	114
8.2 j2se动态代理	122
8.2.1 类和接口	122
8.2.2 调用原理	124
8.2.3 实现同步	125
8.2.4 总结	131
8.3 和装饰器（decorator）模式的比较	131
8.4 总结	132
8.5 本章关键词	132
第9章 适配器（adapter）模式	133
9.1 打桩	134
9.2 其他适配器模式	137
9.2.1 类适配器	137
9.2.2 双向适配器	138
9.3 测试	139
9.4 和代理（proxy）模式的比较	141
9.5 总结	141
9.6 本章关键词	142
第10章 外观（facade）模式	143
10.1 外观（facade）模式	144
10.2 least knowledge principle（最少知识原则）	144
10.3 懒惰的老板请客	145
10.4 ejb里的外观模式	148
10.5 总结	150
10.6 本章关键词	150
第11章 组合（composite）模式	151
11.1 组合模式概述	152
11.1.1 类图	152
11.1.2 使用组合（composite）模式	153
11.1.3 测试	156
11.2 透明的组合模式	159
11.3 安全的组合模式vs透明的组合模式	162
11.4 还需要注意什么	162
11.5 总结	163
11.6 本章关键词	163
第四篇 行为模式	165
第12章 策略（strategy）模式	167
12.1 既要坐飞机又要坐大巴	168
12.2 封装变化	169
12.3 策略模式	172
12.4 还需要继承吗	173
12.5 优先使用合成而非继承	175
12.6 总结	176
12.7 本章关键词	177
第13章 状态（state）模式	179
13.1 电子颜料板	180
13.2 switch-case实现	180
13.3 如何封装变化	181
13.4 状态模式	186
13.5 使用enum类型	186
13.6 与策略（strategy）模式的比较	191
13.7 总结	191
13.8 本章关键词	192
第14章 观察者（observer）模式	193
14.1 股票价格变了多少	194
14.2 观察者模式	194
14.2.1 如何实现	194
14.2.2 观察者模式	201
14.2.3 java标准库的观察者模式	201
14.3 总结	208
14.4 本章关键词	208
第五篇 终点还是起点	209
第15章 面向切面的编程（aop）	211
15.1 记录时间	212
15.2 aop（aspect-oriented programming）	215
15.2.1 一些重要概念	216
15.2.2 oop实现横切	217
15.2.3 aop实现技术	218
15.3 aop框架介绍	244
15.4 aop联盟（aop alliance）	245
15.5 使用aop编程的风险	245
15.6 oop还是aop	246
15.7 总结	247
15.8 本章关键词	248
第16章 面向对象开发	249
16.1 写在面向对象设计之前	250
16.2 汲取知识	251
16.3 横看成岭侧成峰	253
16.4 提炼模型	254
16.5 应用设计模式	259
16.6 不能脱离实现技术	259
16.7 重构	260
16.8 过度的开发（over-engineering）	262
16.9 总结	263
16.10 本章关键词	264
第17章 结语	265
17.1 感悟	266
17.2 面向对象的开发范式	266
17.3 一些原则	268
17.4 写在模式之后	269
17.5 本章关键词	269
附录A 推荐阅读资源	271
1 Java语言相关学习图书	272
2 J2EE技术相关图书	273
3 面向对象设计相关图书	273
4 给Agile（敏捷）开发人员推荐的书籍	275
5 网站和论坛	275
参考文献	277
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>漫谈设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式解析
第一部分　面向对象软件开发简介
第1章　面向对象范型　2
1.1　概览　2
1.2　面向对象范型之前：功能分解　2
1.3　需求问题　4
1.4　应对变化：使用功能分解　5
1.5　应对需求变更　7
1.6　面向对象范型　10
1.7　面向对象程序设计实践　15
1.8　特殊对象方法　17
1.9　小结　18
复习题　19
简答题　19
阐述题　20
观点与应用题　20
第2章　UML　21
2.1　概览　21
2.2　什么是UML　21
2.3　为什么使用UML　22
2.4　类图　22
2.5　交互图　28
2.6　小结　30
复习题　30
简答题　30
阐述题　30
观点与应用题　30
第二部分　传统面向对象设计的局限
第3章　对代码灵活性要求很高的问题　33
3.1　概览　33
3.2　提取CAD/CAM系统的信息　33
3.3　了解专业术语　34
3.4　问题描述　35
3.5　挑战及其解决方案　37
3.6　小结　39
复习题　40
简答题　40
阐述题　40
观点与应用题　40
第4章　标准的面向对象解决方案　41
4.1　概览　41
4.2　作为特例来解决　41
4.3　小结　48
复习题　48
简答题　48
阐述题　49
观点与应用题　49
第三部分　设计模式
第5章　设计模式简介　53
5.1　概览　53
5.2　设计模式源自建筑学和人类学　53
5.3　从建筑模式到软件设计模式　57
5.4　为什么学习设计模式　58
5.5　学习设计模式的其他好处　62
5.6　小结　63
复习题　63
简答题　63
阐述题　64
观点与应用题　64
第6章　Facade模式　65
6.1　概览　65
6.2　Facade模式简介　65
6.3　学习Facade模式　65
6.4　实践注记：Facade模式　68
6.5　Facade模式与CAD/CAM问题的联系　69
6.6　小结　70
复习题　70
简答题　70
阐述题　70
观点与应用题　71
第7章　Adapter模式　72
7.1　概览　72
7.2　Adapter模式简介　72
7.3　学习Adapter模式　73
7.4　实践注记：Adapter模式　77
7.5　Adapter模式与CAD/CAM问题的联系　80
7.6　小结　80
复习题　80
简答题　80
阐述题　81
观点与应用题　81
第8章　开拓视野　82
8.1　概览　82
8.2　对象：传统看法与新看法　83
8.3　封装：传统看法与新看法　84
8.4　发现变化并将其封装　87
8.5　共性和可变性分析与抽象类　90
8.6　敏捷编程的品质　92
8.7　小结　95
复习题　96
简答题　96
阐述题　96
观点与应用题　97
第9章　Strategy模式　98
9.1　概览　98
9.2　处理新需求的一种途径　98
9.3　国际电子商务系统案例研究：最初的需求　100
9.4　处理新的需求　101
9.5　Strategy模式　108
9.6　实践注记：使用Strategy模式　110
9.7　小结　111
复习题　111
简答题　111
阐述题　112
观点与应用题　112
第10章　Bridge模式　113
10.1　概览　113
10.2　Bridge模式简介　113
10.3　学习Bridge模式：示例　114
10.4　对使用设计模式的观察　123
10.5　学习Bridge模式：通过将它推演出来　124
10.6　Bridge模式回顾　131
10.7　实践注记：使用Bridge模式　132
10.8　小结　135
复习题　137
简答题　137
阐述题　137
观点与应用题　137
第11章　Abstract Factory模式　138
11.1　概览　138
11.2　Abstract Factory模式简介　138
11.3　学习Abstract Factory模式：示例　138
11.4　学习Abstract Factory模式：实现该模式　144
11.5　实践注记：Abstract Factory模式　149
11.6　将Abstract Factory模式与CAD/CAM问题联系起来　151
11.7　小结　151
复习题　152
简答题　152
阐述题　152
观点与应用题　152
第四部分　组合起来：用模式思考
第12章　专家设计之道　154
12.1　概览　154
12.2　添加特征的创建方式　154
12.3　小结　160
复习题　160
简答题　160
阐述题　161
观点与应用题　161
第13章　用模式解决CAD/CAM问题　162
13.1　概览　162
13.2　对CAD/CAM问题的回顾　162
13.3　用模式思考　163
13.4　用模式思考：步骤1　164
13.5　用模式思考：步骤2a　165
13.6　用模式思考：步骤2b　169
13.7　用模式思考：步骤2c　172
13.8　用模式思考：重复步骤2a和步骤2b(Facade模式)　173
13.9　用模式思考：重复步骤2a和步骤2b(Adapter模式)　174
13.10　用模式思考：重复步骤2a和步骤2b(Abstract Factory模式)　174
13.11　用模式思考：步骤3　175
13.12　与原解决方案的比较　175
13.13　小结　176
复习题　177
简答题　177
阐述题　177
观点与应用题　177
第五部分　迈向新的设计方式
第14章　设计模式的原则与策略　180
14.1　概览　180
14.2　开闭原则　181
14.3　从背景设计原则　181
14.4　封装变化原则　185
14.5　抽象类与接口　186
14.6　理性怀疑原则　187
14.7　小结　187
复习题　188
简答题　188
阐述题　188
观点与应用题　188
第15章　共性与可变性分析　189
15.1　概览　189
15.2　共性和可变性分析与应用程序设计　189
15.3　用CVA解决CAD/CAM问题　190
15.4　小结　194
复习题　194
简答题　194
阐述题　194
观点与应用题　195
第16章　分析矩阵　196
16.1　概览　196
16.2　现实世界：充满变化　196
16.3　国际电子商务系统案例研究：应对变化　197
16.4　实践注记　203
16.5　小结　206
复习题　206
简答题　206
阐述题　206
观点与应用题　206
第17章　Decorator模式　207
17.1　概览　207
17.2　更多细节　207
17.3　Decorator模式　209
17.4　将Decorator模式应用到我们的案例研究　210
17.5　另一个例子：输入/输出　213
17.6　实践注记：使用Decorator模式　215
17.7　Decorator模式的本质　216
17.8　小结　217
复习题　217
简答题　217
阐述题　217
观点与应用题　217
第六部分　其他重要模式
第18章　Observer模式　220
18.1　概览　220
18.2　模式的分类　220
18.3　国际电子商务案例的更多需求　221
18.4　Observer模式　222
18.5　将Observer模式应用到我们的案例研究　223
18.6　实践注记：使用Observer模式　227
18.7　小结　229
复习题　229
简答题　229
阐述题　230
观点与应用题　230
第19章　Template Method模式　231
19.1　概览　231
19.2　案例研究的更多需求　231
19.3　Template Method模式　232
19.4　将Template Method模式应用到我们的案例研究　232
19.5　使用Template Method模式减少冗余　233
19.6　实践注记：使用Template Method模式　238
19.7　小结　239
复习题　240
简答题　240
阐述题　240
第七部分　各种工厂模式
第20章　来自设计模式的教益：各种工厂模式　242
20.1　概览　242
20.2　工厂　242
20.3　再谈背景　243
20.4　工厂遵循我们的准则　245
20.5　限制变化的影响　246
20.6　对工厂的另一种思考方式　246
20.7　工厂的不同角色　247
20.8　实践注记　247
20.9　小结　248
复习题　248
简答题　248
阐述题　248
观点与应用题　248
第21章　Singleton模式和Double-Checked Locking模式　249
21.1　概览　249
21.2　Singleton模式简介　249
21.3　将Singleton模式应用到我们的案例研究　250
21.4　一种变体：Double-Checked Locking模式　252
21.5　反思　255
21.6　实践注记：使用Singleton模式和Double-Checked Locking模式　255
21.7　小结　256
复习题　256
简答题　256
阐述题　256
观点与应用题　256
第22章　Object Pool模式　257
22.1　概览　257
22.2　一个需要对对象进行管理的问题　257
22.3　Object Pool模式　263
22.4　观察：工厂的作用不仅是实例化　263
22.5　小结　265
复习题　265
简答题　265
阐述题　266
观点与应用题　266
第23章　Factory Method模式　267
23.1　概览　267
23.2　案例研究的更多需求　267
23.3　Factory Method模式　268
23.4　Factory Method模式与面向对象语言　268
23.5　实践注记：使用Factory Method模式　269
23.6　小结　270
复习题　271
简答题　271
阐述题　271
观点与应用题　271
第24章　工厂模式的总结　272
24.1　概览　272
24.2　软件开发过程中的步骤　272
24.3　工厂与极限编程实践殊途同归　273
24.4　系统的扩展性　273
第八部分　终点与起点
第25章　设计模式回顾：总结与新起点　276
25.1　概览　276
25.2　面向对象原则的总结　276
25.3　设计模式如何封装实现　277
25.4　共性和可变性分析与设计模式　277
25.5　按责任分解问题域　278
25.6　模式和从背景设计　279
25.7　模式内部的关联　279
25.8　设计模式与敏捷编程实践　281
25.9　实践注记　281
25.10　小结　281
复习题　282
简答题　282
阐述题　282
观点与应用题　282
第26章　参考书目　283
26.1　本书配套网站　283
26.2　推荐阅读　284
26.3　针对Java程序员的推荐读物　285
26.4　针对C++程序员的推荐读物　286
26.5　针对COBOL程序员的推荐读物　287
26.6　极限编程的推荐读物　287
26.7　程序设计的一般性推荐读物　287
26.8　个人推荐　288
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式解析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图解基础设施设计模式
第1章 什么是基础设施设计模式
1.1 什么是基础设施
1.2 基础设施故障引发的后果
1.3 基础设施构建中哪个阶段最重要
1.4 需求定义的重要性与难点
1.5 非功能性需求等级 克服非功能性需求定义困难 的工具
1.6 基础设施设计模式 研究能够满足需求的设计方式的工具
1.7 本书的内容安排
第2章 可用性需求的实现策略 防止 系统宕机
2.1 可用性策略的基础
2.2 Web/AP服务器的高可用性设计方式
2.3 DB服务器的可用性设计方式
2.4 虚拟服务器冗余的设计方式
2.5 LAN的可用性设计方式
2.6 WAN的可用性设计方式
2.7 互联网连接的设计方式
2.8 数据备份的可用性设计方式
2.9 灾害应对策略的设计方式
2.10 总结
第3章 安全性需求的实现策略 保护系统不受威胁
3.1 安全性策略的基础
3.2 非法访问应对策略的设计方式
3.3 身份认证的设计方式
3.4 ID管理和维护的设计方式
3.5 信息泄露应对策略的设计方式
3.6 总结
第4章 性能与可扩展性需求的实现策略 防止 系统性能下降
4.1 性能与可扩展性策略的基础
4.2 可扩展性策略的设计方式
4.3 超负荷应对策略的设计方式
4.4 总结
第5章 运用与维护性需求的实现策略不放过系统故障
5.1 运用与维护性策略的基础
5.2 运用与维护体制的设计方式
5.3 构成管理的设计方式
5.4 系统监控的设计方式
5.5 任务管理的设计方式
5.6 时钟同步、杀毒软件更新的设计方式
5.7 总结
第6章 基础设施构成的设计方式
6.1 Web系统的网络构成的设计方式
6.2 存储设备构成的设计方式
6.3 报表生成的设计方式
6.4 报表输出的设计方式
6.5 报表基础设施配置的设计方式
6.6 数据使用和信息分析的设计方式
6.7 基础设施交互结构的设计方式
6.8 总结
第7章 使用云计算服务的实现策略
7.1 云服务中性能与可扩展性的设计方式
7.2 云服务中备份的可用性设计方式
7.3 云服务中虚拟服务器的可用性设计方式
7.4 总结
第8 章 基于模式的设计实践
8.1 基础设施构成的讨论步骤
8.2 地理信息系统
8.3 综合 DB系统
8.4 总结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图解基础设施设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>NET与设计模式
第1篇 设计模式与面向对象设计
第1章 理解设计模式
第2章 UML与设计模式
第3章 面向对象软件设计的目标、原则和难点
第4章 小题大做：人戴帽子——面向对象设计与设计模式
第5章 在.NET平台下使用设计模式
第2篇 设计模式的实现与使用
第6章 简单工厂
第7章 工厂方法模式
第8章 抽象工厂
第9章 .NET的反射工厂
第10章 生成器
第11章 原型模式
第12章 专题——克隆图
第13章 单件模式
第14章 与对象创建相关的其他问题
第15章 适配器模式
第16章 桥接模式
第17章 外观模式
第18章 适配器模式、桥接模式与外观模式
第19章 装饰模式
第20章 代理模式
第21章 组合模式
第22章 享元模式
第23章 享元模式与共享对象
第24章 职责链模式
第25章 命令模式
第26章 解释器模式
第27章 迭代器模式
第28章 备忘录模式
第29章 状态模式
第30章 观察者模式
第31章 中介者模式
第32章 策略模式
第33章 模板方法模式
第34章 访问者模式
第35章 访问模式使用专题：访问业务域模型
第36章 委托技术与行为型设计模式
第3篇 开源项目中的设计模式
第37章 NUnit中的设计模式
第38章 DotNetNuke中的设计模式
第39章 Gentle中的设计模式
第40章 Log4net中的设计模式
第4篇 模式与交流
第41章 在组织中使用设计模式
第42章 发掘模式
第43章 小组学习的范例——PLoP的Workshop
第44章 模式的发展
附录A 设计模式与设计模式组合速查
参考文献
后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>NET与设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 企业设计模式
目录:
第1章 软件模式介绍 1
第2章 UML概述 5
第3章 软件生命周期 24
第4章 事务处理模式 26
第5章 分布式体系结构模式 59
第6章 分布式计算模式 96
第7章 并发模式 228
第8章 时间模式 289
第9章 数据库模式 329
附录A 持久框架 375
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 企业设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实用J2EE设计模式编程指南
第1章  J2EE设计模式
模式的演变
软件工程中的模式
何谓设计模式
标识模式
表示设计模式
设计模式如何帮助解决问题
选择适当的设计

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实用J2EE设计模式编程指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#设计模式
第一部分
C#面向对象程序设计
第1章
设计模式概述	2
1.1
定义设计模式	3
1.2
学习过程	4
1.3
学习设计模式	4
1.4
关于面向对象方法	4

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式与游戏完美开发
第1篇 设计模式与游戏设计
第1章 游戏实现中的设计模式 2
1.1 设计模式的起源 2
1.2 软件的设计模式是什么？ 3
1.3 面向对象设计中常见的设计原则 4
1.4 为什么要学习设计模式 7
1.5 游戏程序设计与设计模式 8
1.6 模式的应用与学习方式 10
1.7 结论 11
第2章 游戏范例说明 12
2.1 游戏范例 12
2.2 GoF的设计模式范例 15
第2篇 基础系统
第3章 游戏场景的转换——状态模式（State） 20
3.1 游戏场景 20
3.1.1 场景的转换 20
3.1.2 游戏场景可能的实现方式 23
3.2 状态模式（State） 24
3.2.1 状态模式（State）的定义 24
3.2.2 状态模式（State）的说明 25
3.2.3 状态模式（State）的实现范例 25
3.3 使用状态模式（State）实现游戏场景的转换 28
3.3.1 SceneState的实现 28
3.3.2 实现说明 29
3.3.3 使用状态模式（State）的优点 35
3.3.4 游戏执行流程及场景转换说明 36
3.4 状态模式（State）面对变化时 37
3.5 结论 37
第4章 游戏主要类——外观模式（Facade） 39
4.1 游戏子功能的整合 39
4.2 外观模式（Facade） 41
4.2.1 外观模式（Facade）的定义 41
4.2.2 外观模式（Facade）的说明 42
4.2.3 外观模式（Facade）的实现说明 43
4.3 使用外观模式（Facade）实现游戏主程序 44
4.3.1 游戏主程序架构设计 44
4.3.2 实现说明 45
4.3.3 使用外观模式（Facade）的优点 47
4.3.4 实现外观模式（Facade）时的注意事项 48
4.4 外观模式（Facade）面对变化时 48
4.5 结论 48
第5章 获取游戏服务的唯一对象——单例模式（Singleton） 50
5.1 游戏实现中的唯一对象 50
5.2 单例模式（Singleton） 51
5.2.1 单例模式（Singleton）的定义 51
5.2.2 单例模式（Singleton）的说明 51
5.2.3 单例模式（Singleton）的实现范例 52
5.3 使用单例模式（Singleton）获取唯一的游戏服务对象 53
5.3.1 游戏服务类的单例模式实现 53
5.3.2 实现说明 54
5.3.3 使用单例模式（Singleton）后的比较 55
5.3.4 反对使用单例模式（Singleton）的原因 55
5.4 少用单例模式（Singleton）时如何方便地引用到单一对象 58
5.5 结论 63
第6章 游戏内各系统的整合——中介者模式（Mediator） 64
6.1 游戏系统之间的沟通 64
6.2 中介者模式（Mediator） 68
6.2.1 中介者模式（Mediator）的定义 69
6.2.2 中介者模式（Mediator）的说明 69
6.2.3 中介者模式（Mediator）的实现范例 69
6.3 中介者模式（Mediator）作为系统之间的沟通接口 72
6.3.1 使用中介者模式（Mediator）的系统架构 73
6.3.2 实现说明 73
6.3.3 使用中介者模式（Mediator）的优点 79
6.3.4 实现中介者模式（Mediator）时的注意事项 79
6.4 中介者模式（Mediator）面对变化时 80
6.5 结论 80
第7章 游戏的主循环——Game Loop 82
7.1 GameLoop由此开始 82
7.2 怎么实现游戏循环（Game Loop） 84
7.3 在Unity3D中实现游戏循环 85
7.4 P级阵地的游戏循环 89
7.5 结论 92
第3篇 角色的设计
第8章 角色系统的设计分析 94
8.1 游戏角色的架构 94
8.2 角色类的规划 95
第9章 角色与武器的实现——桥接模式（Bridge） 98
9.1 角色与武器的关系 98
9.2 桥接模式（Bridge） 103
9.2.1 桥接模式（Bridge）的定义 103
9.2.2 桥接模式（Bridge）的说明 107
9.2.3 桥接模式（Bridge）的实现范例 108
9.3 使用桥接模式（Bridge）实现角色与武器接口 110
9.3.1 角色与武器接口设计 110
9.3.2 实现说明 111
9.3.3 使用桥接模式（Bridge）的优点 116
9.3.4 实现桥接模式（Bridge）的注意事项 116
9.4 桥接模式（Bridge）面对变化时 116
9.5 结论 117
第10章 角色属性的计算——策略模式（Strategy） 118
10.1 角色属性的计算需求 118
10.2 策略模式（Strategy） 121
10.2.1 策略模式（Strategy）的定义 122
10.2.2 策略模式（Strategy）的说明 122
10.2.3 策略模式（Strategy）的实现范例 123
10.3 使用策略模式（Strategy）实现攻击计算 124
10.3.1 攻击流程的实现 125
10.3.2 实现说明 125
10.3.3 使用策略模式（Strategy）的优点 132
10.3.4 实现策略模式（Strategy）时的注意事项 133
10.4 策略模式（Strategy）面对变化时 134
10.5 结论 135
第11章 攻击特效与击中反应——模板方法模式（Template Method） 137
11.1 武器的攻击流程 137
11.2 模板方法模式（Template Method） 139
11.2.1 模板方法模式（Template Method）的定义 139
11.2.2 模板方法模式（Template Method）的说明 141
11.2.3 模板方法模式（Template Method）的实现范例 141
11.3 使用模板方法模式实现攻击与击中流程 142
11.3.1 攻击与击中流程的实现 143
11.3.2 实现说明 143
11.3.3 运用模板方法模式（Template Method）的优点 145
11.3.4 修改击中流程的实现 145
11.4 模板方法模式（Template Method）面对变化时 147
11.5 结论 149
第12章 角色AI——状态模式（State） 150
12.1 角色的AI 150
12.2 状态模式（State） 158
12.3 使用状态模式（State）实现角色AI 159
12.3.1 角色AI的实现 159
12.3.2 实现说明 160
12.3.3 使用状态模式（State）的优点 169
12.3.4 角色AI执行流程 169
12.4 状态模式（State）面对变化时 170
12.5 结论 172
第13章 角色系统 174
13.1 角色类 174
13.2 游戏角色管理系统 176
第4篇 角色的产生
第14章 游戏角色的产生——工厂方法模式（Factory Method） 183
14.1 产生角色 183
14.2 工厂方法模式（Factory Method） 188
14.2.1 工厂方法模式（Factory Method）的定义 188
14.2.2 工厂方法模式（Factory Method）的说明 189
14.2.3 工厂方法模式（Factory Method）的实现范例 189
14.3 使用工厂方法模式（Factory Method）产生角色对象 195
14.3.1 角色工厂类 195
14.3.2 实现说明 196
14.3.3 使用工厂方法模式（Factory Method）的优点 199
14.3.4 工厂方法模式（Factory Method）的实现说明 199
14.4 工厂方法模式（Factory Method）面对变化时 203
14.5 结论 205
第15章 角色的组装——建造者模式（Builder） 206
15.1 角色功能的组装 206
15.2 建造者模式（Builder） 213
15.2.1 建造者模式（Builder）的定义 213
15.2.2 建造者模式（Builder）的说明 214
15.2.3 建造者模式（Builder）的实现范例 215
15.3 使用建造者模式（Builder）组装角色的各项功能 217
15.3.1 角色功能的组装 218
15.3.2 实现说明 219
15.3.3 使用建造者模式（Builder）的优点 226
15.3.4 角色建造者的执行流程 226
15.4 建造者模式（Builder）面对变化时 227
15.5 结论 228
第16章 游戏属性管理功能——享元模式（Flyweight） 229
16.1 游戏属性的管理 229
16.2 享元模式（Flyweight） 236
16.2.1 享元模式（Flyweight）的定义 236
16.2.2 享元模式（Flyweight）的说明 237
16.2.3 享元模式（Flyweight）的实现范例 238
16.3 使用享元模式（Flyweight）实现游戏 242
16.3.1 SceneState的实现 242
16.3.2 实现说明 245
16.3.3 使用享元模式（Flyweight）的优点 250
16.3.4 享元模式（Flyweight）的实现说明 250
16.4 享元模式（Flyweight）面对变化时 252
16.5 结论 252
第5篇 战争开始
第17章 Unity3D的界面设计——组合模式（Composite） 254
17.1 玩家界面设计 254
17.2 组合模式（Composite） 259
17.2.1 组合模式（Composite）的定义 259
17.2.2 组合模式（Composite）的说明 260
17.2.3 组合模式（Composite）的实现范例 261
17.2.4 分了两个子类但是要使用同一个操作界面 264
17.3 Unity3D游戏对象的分层式管理功能 265
17.3.1 游戏对象的分层管理 265
17.3.2 正确有效地获取UI的游戏对象 266
17.3.3 游戏用户界面的实现 267
17.3.4 兵营界面的实现 269
17.4 结论 274
第18章 兵营系统及兵营信息显示 276
18.1 兵营系统 276
18.2 兵营系统的组成 277
18.3 初始兵营系统 281
18.4 兵营信息的显示流程 287
第19章 兵营训练单位——命令模式（Command） 288
19.1 兵营界面上的命令 288
19.2 命令模式（Command） 291
19.2.1 命令模式（Command）的定义 291
19.2.2 命令模式（Command）的说明 294
19.2.3 命令模式（Command）的实现范例 294
19.3 使用命令模式（Command）实现兵营训练角色 297
19.3.1 训练命令的实现 297
19.3.2 实现说明 298
19.3.3 执行流程 302
19.3.4 实现命令模式（Command）时的注意事项 303
19.4 命令模式（Command）面对变化时 305
19.5 结论 306
第20章 关卡设计——责任链模式（Chain of Responsibility） 307
20.1 关卡设计 307
20.2 责任链模式（Chain of Responsibility） 312
20.2.1 责任链模式（Chain of Responsibility）的定义 312
20.2.2 责任链模式（Chain of Responsibility）的说明 314
20.2.3 责任链模式（Chain of Responsibility）的实现范例 314
20.3 使用责任链模式（Chain of Responsibility）实现关卡系统 317
20.3.1 关卡系统的设计 317
20.3.2 实现说明 318
20.3.3 使用责任链模式（Chain of Responsibility）的优点 329
20.3.4 实现责任链模式（Chain of Responsibility）时的注意事项 329
20.4 责任链模式（Chain of Responsibility）面对变化时 330
20.5 结论 332
第6篇 辅助系统
第21章 成就系统—观察者模式（Observer） 334
21.1 成就系统 334
21.2 观察者模式（Observer） 338
21.2.1 观察者模式（Observer）的定义 338
21.2.2 观察者模式（Observer）的说明 340
21.2.3 观察者模式（Observer）的实现范例 341
21.3 使用观察者模式（Observer）实现成就系统 344
21.3.1 成就系统的新架构 344
21.3.2 实现说明 346
21.3.3 使用观察者模式（Observer）的优点 358
21.3.4 实现观察者模式（Observer）时的注意事项 358
21.4 观察者模式（Observer）面对变化时 359
21.5 结论 361
第22章 存盘功能—备忘录模式（Memento） 362
22.1 存储成就记录 362
22.2 备忘录模式（Memento） 366
22.2.1 备忘录模式（Memento）的定义 366
22.2.2 备忘录模式（Memento）的说明 367
22.2.3 备忘录模式（Memento）的实现范例 367
22.3 使用备忘录模式（Memento）实现成就记录的保存 371
22.3.1 成就记录保存的功能设计 371
22.3.2 实现说明 371
22.3.3 使用备忘录模式（Memento）的优点 374
22.3.4 实现备忘录模式（Memento）的注意事项 374
22.4 备忘录模式（Memento）面对变化时 374
22.5 结论 375
第23章 角色信息查询—访问者模式（Visitor） 376
23.1 角色信息的提供 376
23.2 访问者模式（Visitor） 385
23.2.1 访问者模式（Visitor）的定义 386
23.2.2 访问者模式（Visitor）的说明 390
23.2.3 访问者模式（Visitor）的实现范例 392
23.3 使用访问者模式（Visitor）实现角色信息查询 397
23.3.1 角色信息查询的实现设计 397
23.3.2 实现说明 398
23.3.3 使用访问者模式（Visitor）的优点 405
23.3.4 实现访问者模式（Visitor）时的注意事项 405
23.4 访问者模式（Visitor）面对变化时 405
23.5 结论 408
第7篇 调整与优化
第24章 前缀字尾—装饰模式（Decorator） 410
24.1 前缀后缀系统 410
24.2 装饰模式（Decorator） 415
24.2.1 装饰模式（Decorator）的定义 415
24.2.2 装饰模式（Decorator）的说明 418
24.2.3 装饰模式（Decorator）的实现范例 419
24.3 使用装饰模式（Decorator）实现前缀后缀的功能 422
24.3.1 前缀后缀功能的架构设计 423
24.3.2 实现说明 423
24.3.3 使用装饰模式（Decorator）的优点 433
24.3.4 实现装饰模式（Decorator）时的注意事项 433
24.4 装饰模式（Decorator）面对变化时 434
24.5 结论 435
第25章 俘兵—适配器模式（Adapter） 436
25.1 游戏的宠物系统 436
25.2 适配器模式（Adapter） 440
25.2.1 适配器模式（Adapter）的定义 440
25.2.2 适配器模式（Adapter）的说明 441
25.2.3 适配器模式（Adapter）的实现范例 441
25.3 使用适配器模式（Adapter）实现俘兵系统 443
25.3.1 俘兵系统的架构设计 443
25.3.2 实现说明 443
25.3.3 与俘兵相关的新增部分 445
25.3.4 使用适配器模式（Adapter）的优点 450
25.4 适配器模式（Adapter）面对变化时 450
25.5 结论 451
第26章 加载速度的优化—代理模式（Proxy） 453
26.1 最后的系统优化 453
26.2 代理模式（Proxy） 457
26.2.1 代理模式（Proxy）的定义 458
26.2.2 代理模式（Proxy）的说明 458
26.2.3 代理模式（Proxy）的实现范例 459
26.3 使用代理模式（Proxy）测试和优化加载速度 460
26.3.1 优化加载速度的架构设计 460
26.3.2 实现说明 461
26.3.3 使用代理模式（Proxy）的优点 464
26.3.4 实现代理模式（Proxy）时的注意事项 464
26.4 代理模式（Prory）面对变化时 466
26.5 结论 466
第8篇 未明确使用的模式
第27章 迭代器模式（Iterator）、原型模式（Prototype）和解释器模式（Interpreter） 468
27.1 迭代器模式（Iterator） 468
27.2 原型模式（Prototype） 469
27.3 解释器模式（Interpreter） 471
第28章 抽象工厂模式（Abstract Factory） 472
28.1 抽象工厂模式（Abstract Factory）的定义 472
28.2 抽象工厂模式（Abstract Factory）的实现 473
28.3 可应用抽象工厂模式的场合 476
参考文献 477
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式与游戏完美开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>人人都懂设计模式：从生活中领悟设计模式：Python实现
基 础 篇
第0章　启程之前，请不要错过我	2
0.1　Python精简入门	2
0.1.1　Python的特点	2
0.1.2　基本语法	3
0.1.3　一个例子让你顿悟	7
0.1.4　重要说明	11
0.2　UML精简概述	11
0.2.1　UML的定义	11
0.2.2　常见的关系	12
第1章　监听模式	16
1.1　从生活中领悟监听模式	16
1.1.1　故事剧情—幻想中的智能热水器	16
1.1.2　用程序来模拟生活	17
1.2　从剧情中思考监听模式	19
1.2.1　什么是监听模式	19
1.2.2　监听模式设计思想	19
1.3　监听模式的模型抽象	19
1.3.1　代码框架	19
1.3.2　类图	20
1.3.3　基于框架的实现	21
1.3.4　模型说明	22
1.4　实战应用	23
1.5　应用场景	26
第2章　状态模式	28
2.1　从生活中领悟状态模式	28
2.1.1　故事剧情—人有少、壮、老，水之固、液、气	28
2.1.2　用程序来模拟生活	29
2.2　从剧情中思考状态模式	32
2.2.1　什么是状态模式	32
2.2.2　状态模式设计思想	33
2.3　状态模式的模型抽象	33
2.3.1　代码框架	33
2.3.2　类图	35
2.3.3　基于框架的实现	36
2.3.4　模型说明	38
2.4　应用场景	39
第3章　中介模式	40
3.1　从生活中领悟中介模式	40
3.1.1　故事剧情—找房子问中介	40
3.1.2　用程序来模拟生活	41
3.2　从剧情中思考中介模式	46
3.2.1　什么是中介模式	46
3.2.2　中介模式设计思想	46
3.3　中介模式的模型抽象	48
3.3.1　代码框架	48
3.3.2　类图	49
3.3.3　模型说明	50
3.4　实战应用	51
3.5　应用场景	56
第4章　装饰模式	57
4.1　从生活中领悟装饰模式	57
4.1.1　故事剧情—你想怎么搭就怎么搭	57
4.1.2　用程序来模拟生活	58
4.2　从剧情中思考装饰模式	62
4.2.1　什么是装饰模式	62
4.2.2　装饰模式设计思想	63
4.3　装饰模式的模型抽象	64
4.3.1　类图	64
4.3.2　Python中的装饰器	64
4.3.3　模型说明	69
4.4　应用场景	70
第5章　单例模式	71
5.1　从生活中领悟单例模式	71
5.1.1　故事剧情—你是我的唯一	71
5.1.2　用程序来模拟生活	72
5.2　从剧情中思考单例模式	73
5.2.1　什么是单例模式	73
5.2.2　单例模式设计思想	73
5.3　单例模式的模型抽象	73
5.3.1　代码框架	73
5.3.2　类图	78
5.3.3　基于框架的实现	78
5.4　应用场景	79
第6章　克隆模式	80
6.1　从生活中领悟克隆模式	80
6.1.1　故事剧情—给你一个分身术	80
6.1.2　用程序来模拟生活	80
6.2　从剧情中思考克隆模式	82
6.2.1　什么是克隆模式	82
6.2.2　浅拷贝与深拷贝	82
6.3　克隆模式的模型抽象	86
6.3.1　代码框架	86
6.3.2　类图	86
6.3.3　基于框架的实现	87
6.3.4　模型说明	87
6.4　实战应用	88
6.5　应用场景	90
第7章　职责模式	91
7.1　从生活中领悟职责模式	91
7.1.1　故事剧情—我的假条去哪儿了	91
7.1.2　用程序来模拟生活	92
7.2　从剧情中思考职责模式	96
7.2.1　什么是职责模式	96
7.2.2　职责模式设计思想	96
7.3　职责模式的模型抽象	97
7.3.1　代码框架	97
7.3.2　类图	98
7.3.3　基于框架的实现	99
7.3.4　模型说明	102
7.4　应用场景	103
第8章　代理模式	104
8.1　从生活中领悟代理模式	104
8.1.1　故事剧情—帮我拿一下快递	104
8.1.2　用程序来模拟生活	105
8.2　从剧情中思考代理模式	107
8.2.1　什么是代理模式	107
8.2.2　代理模式设计思想	107
8.3　代理模式的模型抽象	107
8.3.1　代码框架	107
8.3.2　类图	109
8.3.3　基于框架的实现	110
8.3.4　模型说明	111
8.4　应用场景	111
第9章　外观模式	113
9.1　从生活中领悟外观模式	113
9.1.1　故事剧情—学妹别慌，学长帮你	113
9.1.2　用程序来模拟生活	114
9.2　从剧情中思考外观模式	116
9.2.1　什么是外观模式	116
9.2.2　外观模式设计思想	116
9.3　外观模式的模型抽象	117
9.3.1　类图	117
9.3.2　软件的分层结构	117
9.3.3　模型说明	119
9.4　实战应用	119
9.5　应用场景	123
第10章　迭代模式	124
10.1　从生活中领悟迭代模式	124
10.1.1　故事剧情—下一个就是你了	124
10.1.2　用程序来模拟生活	125
10.2　从剧情中思考迭代模式	128
10.2.1　什么是迭代模式	128
10.2.2　迭代模式设计思想	129
10.3　迭代模式的模型抽象	130
10.3.1　代码框架	130
10.3.2　Python中的迭代器	132
10.3.3　类图	136
10.3.4　模型说明	137
10.4　应用场景	138
第11章　组合模式	139
11.1　从生活中领悟组合模式	139
11.1.1　故事剧情—自己组装电脑，价格再降三成	139
11.1.2　用程序来模拟生活	140
11.2　从剧情中思考组合模式	146
11.2.1　什么是组合模式	146
11.2.2　组合模式设计思想	147
11.3　组合模式的模型抽象	148
11.3.1　代码框架	148
11.3.2　类图	149
11.3.3　模型说明	150
11.4　实战应用	150
11.5　应用场景	153
第12章　构建模式	154
12.1　从生活中领悟构建模式	154
12.1.1　故事剧情—你想要一辆车还是一个庄园	154
12.1.2　用程序来模拟生活	155
12.2　从剧情中思考构建模式	157
12.2.1　什么是构建模式	157
12.2.2　构建模式设计思想	157
12.2.3　与工厂模式的区别	158
12.2.4　与组合模式的区别	158
12.3　构建模式的模型抽象	159
12.3.1　类图	159
12.3.2　基于框架的实现	160
12.3.3　模型说明	163
12.4　应用场景	164
第13章　适配模式	166
13.1　从生活中领悟适配模式	166
13.1.1　故事剧情——有个转换器就好了	166
13.1.2　用程序来模拟生活	167
13.2　从剧情中思考适配模式	170
13.2.1　什么是适配模式	170
13.2.2　适配模式设计思想	170
13.3　适配模式的模型抽象	172
13.3.1　代码框架	172
13.3.2　类图	172
13.3.3　模型说明	173
13.4　实战应用	174
13.5　应用场景	184
第14章　策略模式	185
14.1　从生活中领悟策略模式	185
14.1.1　故事剧情—怎么来不重要，人到就行	185
14.1.2　用程序来模拟生活	186
14.2　从剧情中思考策略模式	188
14.2.1　什么是策略模式	188
14.2.2　策略模式设计思想	188
14.3　策略模式的模型抽象	189
14.3.1　类图	189
14.3.2　模型说明	190
14.4　实战应用	190
14.5　应用场景	195
第15章　工厂模式	196
15.1　从生活中领悟工厂模式	196
15.1.1　故事剧情—你要拿铁还是摩卡呢	196
15.1.2　用程序来模拟生活	197
15.2　从剧情中思考工厂模式	199
15.2.1　什么是简单工厂模式	199
15.2.2　工厂模式设计思想	199
15.3　工厂三姐妹	199
15.3.1　简单工厂模式	200
15.3.2　工厂方法模式	201
15.3.3　抽象工厂模式	203
15.4　进一步思考	205
15.5　实战应用	205
第16章　命令模式	209
16.1　从生活中领悟命令模式	209
16.1.1　故事剧情—大闸蟹，走起	209
16.1.2　用程序来模拟生活	210
16.2　从剧情中思考命令模式	213
16.2.1　什么是命令模式	213
16.2.2　命令模式设计思想	213
16.3　命令模式的模型抽象	214
16.3.1　代码框架	214
16.3.2　类图	215
16.3.3　模型说明	216
16.4　实战应用	216
16.5　应用场景	224
第17章　备忘模式	225
17.1　从生活中领悟备忘模式	225
17.1.1　故事剧情—好记性不如烂笔头	225
17.1.2　用程序来模拟生活	226
17.2　从剧情中思考备忘模式	228
17.2.1　什么是备忘模式	228
17.2.2　备忘模式设计思想	229
17.3　备忘模式的模型抽象	229
17.3.1　类图	229
17.3.2　代码框架	230
17.3.3　模型说明	232
17.4　实战应用	232
17.5　应用场景	235
第18章　享元模式	236
18.1　从生活中领悟享元模式	236
18.1.1　故事剧情—颜料很贵，必须充分利用	236
18.1.2　用程序来模拟生活	237
18.2　从剧情中思考享元模式	239
18.2.1　什么是享元模式	239
18.2.2　享元模式设计思想	239
18.3　享元模式的模型抽象	239
18.3.1　类图	239
18.3.2　基于框架的实现	240
18.3.3　模型说明	242
18.4　应用场景	243
第19章　访问模式	244
19.1　从生活中领悟访问模式	244
19.1.1　故事剧情—一千个读者一千个哈姆雷特	244
19.1.2　用程序来模拟生活	245
19.2　从剧情中思考访问模式	246
19.2.1　什么是访问模式	246
19.2.2　访问模式设计思想	247
19.3　访问模式的模型抽象	247
19.3.1　代码框架	247
19.3.2　类图	248
19.3.3　基于框架的实现	249
19.3.4　模型说明	250
19.4　实战应用	251
19.5　应用场景	255
第20章　其他经典设计模式	256
20.1　模板模式	256
20.1.1　模式定义	256
20.1.2　类图结构	257
20.1.3　代码框架	257
20.1.4　应用案例	259
20.1.5　应用场景	261
20.2　桥接模式	261
20.2.1　模式定义	261
20.2.2　类图结构	261
20.2.3　应用案例	262
20.2.4　应用场景	266
20.3　解释模式	266
20.3.1　模式定义	266
20.3.2　类图结构	266
20.3.3　应用案例	267
20.3.4　应用场景	271
进 阶 篇
第21章　深入解读过滤器模式	274
21.1　从生活中领悟过滤器模式	274
21.1.1　故事剧情—制作一杯鲜纯细腻的豆浆	274
21.1.2　用程序来模拟生活	275
21.2　从剧情中思考过滤器模式	275
21.2.1　过滤器模式	276
21.2.2　与职责模式的联系	276
21.3　过滤器模式的模型抽象	276
21.3.1　代码框架	277
21.3.2　类图	278
21.3.3　基于框架的实现	278
21.3.4　模型说明	279
21.4　实战应用	280
21.5　应用场景	282
第22章　深入解读对象池技术	283
22.1　从生活中领悟对象池技术	283
22.1.1　故事剧情—共享让出行更便捷	283
22.1.2　用程序来模拟生活	284
22.2　从剧情中思考对象池机制	287
22.2.1　什么是对象池	287
22.2.2　与享元模式的联系	287
22.3　对象池机制的模型抽象	288
22.3.1　代码框架	288
22.3.2　类图	291
22.3.3　基于框架的实现	292
22.3.4　模型说明	294
22.4　应用场景	295
第23章　深入解读回调机制	296
23.1　从生活中领悟回调机制	296
23.1.1　故事剧情—把你的技能亮出来	296
23.1.2　用程序来模拟生活	296
23.2　从剧情中思考回调机制	298
23.2.1　回调机制	298
23.2.2　设计思想	299
23.3　回调机制的模型抽象	299
23.3.1　面向过程的实现方式	299
23.3.2　面向对象的实现方式	300
23.3.3　模型说明	301
23.4　实战应用	302
23.4.1　基于回调函数的实现	302
23.4.2　基于策略模式的实现	303
23.4.3  回调在异步中的应用	307
23.5　应用场景	310
第24章　深入解读MVC模式	311
24.1　从生活中领悟MVC模式	311
24.1.1　故事剧情—定格最美的一瞬间	311
24.1.2　用程序来模拟生活	312
24.2　从剧情中思考MVC模式	316
24.2.1　MVC模式	317
24.2.2　与中介模式的联系	317
24.2.3　与外观模式的联系	317
24.3　MVC模式的模型抽象	318
24.3.1　MVC	318
24.3.2　MVP	318
24.3.3　MVVM	319
24.3.4　模型说明	320
24.4　应用场景	320
经 验 篇
第25章　关于设计模式的理解	324
25.1　众多书籍之下为何还要写此书	324
25.2　设计模式玄吗	324
25.3　如何区分不同的模式	325
25.4　编程思想的三重境界	325
第26章　关于设计原则的思考	327
26.1　SOLID原则	327
26.1.1　单一职责原则	327
26.1.2　开放封闭原则	331
26.1.3　里氏替换原则	334
26.1.4　依赖倒置原则	337
26.1.5　接口隔离原则	341
26.2　是否一定要遵循这些设计原则	348
26.2.1　软件设计是一个逐步优化的过程	348
26.2.2　不是一定要遵循这些设计原则	349
26.3　更为实用的设计原则	349
26.3.1　LoD原则（Law of Demeter）	349
26.3.2　KISS原则（Keep It Simple and Stupid）	350
26.3.3　DRY原则（Don’t Repeat Yourself）	351
26.3.4　YAGNI原则（You Aren't Gonna Need It）	353
26.3.5　Rule Of Three原则	353
26.3.6　CQS原则（Command-Query Separation）	354
第27章　关于项目重构的思考	355
27.1　什么叫重构	355
27.2　为何要重构	355
27.3　什么时机进行重构	356
27.4　如何重构代码	357
27.4.1　重命名	357
27.4.2　函数重构	358
27.4.3　重新组织数据	359
27.4.4　用设计模式改善代码设计	360
27.5　代码整洁之道	360
27.5.1　命名的学问	360
27.5.2　整洁代码的案例	362
附录A　23种经典设计模式的索引对照表	368
附录B　Python中__new__、__init__和__call__的用法	370
附录C　Python中metaclass的原理	377
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>人人都懂设计模式：从生活中领悟设计模式：Python实现
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MongoDB应用设计模式
前言
第一部分 设计模式
第一章 嵌入还是引用
关系型数据模型和标准化
什么是范式？
MongoDB：不论如何，谁需要标准化呢？
为了潜在的高引数关系使用引用
总结
第2章 多态模式
多态模式支持面向对象编程
多态模式使得模式进化成为可能
多态模式支持半结构域数据
结论
第3章 模仿事务行为
一致性的有关方法
混合文档
使用复杂*新
使用补偿来优化*新
小结
第二部分 应用实例
第4章 运营智能
存储日志数据
预聚合报告
分层聚合
第5章 电子商务
产品目录
分类层级
存货管理
第6章 内容管理系统
元数据和资源管理
存储评论信息
第7章 在线广告网络
解决方案概述
设计一：基本广告服务
设计二：增加广告频次控制
设计三：关键字目标选择
第8章 社交网络
解决方案概述
模式设计
操作
分片
第9章 在线游戏
解决方案概述
模式设计
操作
分片
后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MongoDB应用设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#设计模式
第1部分 面向对象的C#编程第1章 什么是设计模式第2章 C#语法第3章 编写C#版Windows程序第4章 在C#中使用类和对象第5章 继承第6章 UML图第7章 C#中的数组、文件和异常第2部分  创建型模式第8章 简单工厂模式第9章 工厂方法第10章 抽象工厂模式第11章 单件模式第12章 生成器模式第13章 原型模式第3部分  结构型模式第14章 适配器模式第15章 桥接模式第16章 组合模式第17章 装饰器模式第18章 外观模式第19章 享元模式第20章 代理模式第4部分  行为型模式第21章 职责链第22章 命令模式第23章 解释器模式第24章 迭代器模式第25章 中介者模式第26章 备忘录模式第27章 观察者模式第28章 状态模式第29章 策略模式第30章 模板方法模式第31章 访问者模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE设计模式解析与应用
目    录
第Ⅰ部分  Java EE设计模式介绍
第1章  设计模式概览	3
1.1  何为设计模式	4
1.1.1  如何检测模式，为何需要模式	6
1.1.2  现实世界中的模式	6
1.2  设计模式基础	8
1.3  企业模式	8
1.3.1  从Java到企业级Java	9
1.3.2  企业Java模式的出现	10
1.3.3  设计模式与企业模式	11
1.3.4  当传统设计模式遇到Java EE	12
1.3.5  当模式变成反模式	13
1.4  小结	14
1.5  相关资料	14
第2章  Java EE基础	17
2.1  多层架构	19
2.2  客户端层	20
2.3  中间层	21
2.3.1  Web层	21
2.3.2  业务层	22
2.4  EIS层	23
2.5  Java EE服务器	24
2.6  Java EE Web Profile	25
2.7  Java EE核心原则	25
2.8  约定优于配置	26
2.9  上下文与依赖注入	26
2.10  拦截器	28
2.11  小结	30
2.12  本章练习	30
第Ⅱ部分  实现Java EE设计模式
第3章  门面模式	33
3.1  何为门面	34
3.2  使用普通代码实现门面模式	36
3.3  使用Java EE实现门面模式	38
3.3.1  使用无状态Bean实现门面	38
3.3.2  使用有状态Bean实现门面	41
3.4  何时以及何处该使用门面模式	42
3.5  小结	43
3.6  本章练习	43
3.7  相关资料	43
第4章  单例模式	45
4.1  何为单例？	46
4.1.1  单例模式类图	47
4.1.2  使用普通代码实现单例模式	48
4.2  使用Java EE实现单例模式	53
4.2.1  单例Bean	53
4.2.2  在启动时使用单例	54
4.2.3  确定启动顺序	56
4.2.4  管理并发	59
4.3  何处以及何时该使用单例模式	63
4.4  小结	63
4.5  本章练习	64
4.6  相关资料	65
第5章  依赖注入与CDI	67
5.1  何为依赖注入？	68
5.2  使用普通代码实现DI	69
5.3  使用Java EE实现DI	73
5.3.1  @Named注解	75
5.3.2  上下文与依赖注入(CDI)	76
5.3.3  CDI与EJB	77
5.3.4  CDI Bean	77
5.3.5  @Inject注解	79
5.3.6  上下文与作用域	79
5.3.7  命名与EL	80
5.3.8  用于Backing JSF的CDI Bean	81
5.3.9  限定符	81
5.3.10  Alternatives	82
5.3.11  Stereotypes	83
5.3.12  通过CDI实现的其他模式	84
5.4  小结	84
5.5  本章练习	85
5.6  相关资料	85
第6章  工厂模式	87
6.1  何为工厂？	88
6.2  工厂方法	89
6.3  抽象工厂	94
6.4  使用Java EE实现工厂模式	96
6.5  何处以及何时该使用工厂模式	110
6.6  小结	111
6.7  本章练习	111
6.8  相关资料	111
第7章  装饰模式	113
7.1  何为装饰器？	114
7.2  使用普通代码实现装饰模式	116
7.3  使用Java EE实现装饰模式	121
7.4  何处以及何时该使用装饰模式	129
7.5  小结	130
7.6  本章练习	130
7.7  相关资料	131
第8章  面向方面编程(拦截器)	133
8.1  何为面向方面编程？	134
8.2  使用普通代码实现AOP	137
8.3  Java EE中的方面—— 拦截器	140
8.3.1  拦截器生命周期	145
8.3.2  默认级别的拦截器	146
8.3.3  拦截器顺序	147
8.3.4  CDI拦截器	150
8.4  何处以及何时该使用拦截器	153
8.5  小结	154
8.6  相关资料	155
第9章  异步	157
9.1  何为异步编程	158
9.2  使用普通代码实现异步模式	161
9.3  Java EE中的异步编程	164
9.3.1  异步Bean	164
9.3.2  异步Servlet	167
9.4  何处以及何时该使用异步编程	172
9.5  小结	174
9.6  本章练习	174
9.7  相关资料	175
第10章  定时器服务	177
10.1  何为定时器服务	178
10.2  使用Java EE实现定时器	181
10.2.1  自动化定时器	181
10.2.2  编程式定时器	183
10.2.3  定时器表达式	187
10.2.4  事务	190
10.3  小结	191
10.4  本章练习	192
10.5  相关资料	192
第11章  观察者模式	193
11.1  何为观察者？	194
11.1.1  说明	195
11.1.2  观察者类图	197
11.2  使用普通代码实现观察者模式	197
11.3  使用Java EE实现观察者模式	200
11.4  何处以及何时该使用观察者模式	209
11.5  小结	210
11.6  本章练习	211
11.7  相关资料	211
第12章  数据访问模式	213
12.1  何为数据访问模式？	214
12.2  数据访问模式概览	216
12.2.1  数据传输对象模式	216
12.2.2  Java持久化架构API与对象关系映射	217
12.3  使用Java EE实现数据访问模式	218
12.4  何处以及何时该使用数据访问模式	227
12.5  小结	227
12.6  本章练习	228
12.7  相关资料	228
第13章  REST风格的Web Service	229
13.1  何为REST？	230
13.2  REST的6个约束	232
13.2.1  客户端-服务器	233
13.2.2  统一接口	233
13.2.3  无状态	233
13.2.4  可缓存	233
13.2.5  分层系统	234
13.2.6  按需编码	234
13.3  REST API的理查森能力成熟度模型	234
13.3.1  级别0：POX(Plain Old XML)沼泽	235
13.3.2  级别1：资源	235
13.3.3  级别2：HTTP动词	235
13.3.4  级别3：超媒体控件	235
13.4  设计REST风格的API	235
13.4.1  资源命名	236
13.4.2  名词而非动词	237
13.4.3  自说明	237
13.4.4  复数而非单数	237
13.4.5  HTTP方法	238
13.4.6  GET	238
13.4.7  POST	239
13.4.8  PUT	239
13.4.9  DELETE	240
13.5  REST实战	240
13.5.1  users名词	240
13.5.2  topics名词与posts名词	242
13.6  使用Java EE实现REST	244
13.7  HATEOAS	249
13.8  何处以及何时该使用REST	253
13.9  小结	253
13.10  本章练习	254
13.11  相关资料	254
第14章  模型、视图与控制器模式	255
14.1  何为MVC设计模式？	256
14.2  使用普通代码实现MVC模式	260
14.3  使用Java EE实现MVC模式	265
14.4  FacesServlet	265
14.5  使用FacesServlet实现MVC	266
14.6  何处以及何时该使用MVC模式	269
14.7  小结	269
14.8  本章练习	270
14.9  相关资料	270
第15章  Java EE中的其他模式	271
15.1  何为WebSockets？	272
15.2  何为面向消息的中间件	275
15.3  何为微服务架构？	277
15.3.1  单块架构	278
15.3.2  可伸缩性	279
15.3.3  分解为服务	280
15.3.4  微服务的好处	281
15.3.5  天下没有免费的午餐	282
15.3.6  结论	283
15.4  一些反模式	284
15.4.1  超级类	284
15.4.2  面条架构	284
15.4.3  哥伦布先生	285
15.4.4  利益之交	285
15.4.5  前沿技术	286
15.4.6  辅助类	286
15.5  相关资料	287
第Ⅲ部分  总    结
第16章  设计模式：好处、坏处与丑陋之处	291
16.1  好处：通往成功之路的模式	292
16.2  坏处：模式的过度使用与滥用	294
16.3  丑陋之处	296
16.4  小结	298
16.5  相关资料	298
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE设计模式解析与应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式解析（第2版·修订版）
第一部分　面向对象软件开发简介
第1章　面向对象范型	2
1．1 概览	2
1．2 面向对象范型之前：功能分解	2
1．3 需求问题	4
1．4 应对变化：使用功能分解	5
1．5 应对需求变更	7
1．6 面向对象范型	10
1．7 面向对象程序设计实践	15
1．8 特殊对象方法	17
1．9 小结	18
复习题	19
简答题	19
阐述题	20
观点与应用题	20
第2章　UML	21
2．1 概览	21
2．2 什么是UML	21
2．3 为什么使用UML	22
2．4 类图	22
2．5 交互图	28
2．6 小结	30
复习题	30
简答题	30
阐述题	30
观点与应用题	30
第二部分 传统面向对象设计的局限
第3章　对代码灵活性要求很高的问题	33
3．1 概览	33
3．2 提取CAD/CAM系统的信息	33
3．3 了解专业术语	34
3．4 问题描述	35
3．5 挑战及其解决方案	37
3．6 小结	39
复习题	40
简答题	40
阐述题	40
观点与应用题	40
第4章　标准的面向对象解决方案	41
4．1 概览	41
4．2 作为特例来解决	41
4．3 小结	48
复习题	48
简答题	48
阐述题	49
观点与应用题	49
第三部分 设 计 模 式
第5章　设计模式简介	53
5．1 概览	53
5．2 设计模式源自建筑学和人类学	53
5．3 从建筑模式到软件设计模式	57
5．4 为什么学习设计模式	58
5．5 学习设计模式的其他好处	62
5．6 小结	63
复习题	63
简答题	63
阐述题	64
观点与应用题	64
第6章　Facade模式	65
6．1 概览	65
6．2 Facade模式简介	65
6．3 学习Facade模式	65
6．4 实践注记：Facade模式	68
6．5 Facade模式与CAD／CAM问题的联系	69
6．6 小结	70
复习题	70
简答题	70
阐述题	70
观点与应用题	71
第7章　Adapter模式	72
7．1 概览	72
7．2 Adapter模式简介	72
7．3 学习Adapter模式	73
7．4 实践注记：Adapter模式	77
7．5 Adapter模式与CAD/CAM问题的联系	80
7．6 小结	80
复习题	80
简答题	80
阐述题	81
观点与应用题	81
第8章　开拓视野	82
8．1 概览	82
8．2 对象：传统看法与新看法	83
8．3 封装：传统看法与新看法	84
8．4 发现变化并将其封装	87
8．5 共性和可变性分析与抽象类	90
8．6 敏捷编程的品质	92
8．7 小结	95
复习题	96
简答题	96
阐述题	96
观点与应用题	97
第9章　Strategy模式	98
9．1 概览	98
9．2 处理新需求的一种途径	98
9．3 国际电子商务系统案例研究：最初的需求	100
9．4 处理新的需求	101
9．5 Strategy模式	108
9．6 实践注记：使用Strategy模式	110
9．7 小结	111
复习题	111
简答题	111
阐述题	112
观点与应用题	112
第10章　Bridge模式	113
10．1 概览	113
10．2 Bridge模式简介	113
10．3 学习Bridge模式：示例	114
10．4 对使用设计模式的观察	123
10．5 学习Bridge模式：通过将它推演出来	124
10．6 Bridge模式回顾	131
10．7 实践注记：使用Bridge模式	132
10．8 小结	135
复习题	137
简答题	137
阐述题	137
观点与应用题	137
第11章　Abstract Factory模式	138
11．1 概览	138
11．2 Abstract Factory模式简介	138
11．3 学习Abstract Factory模式：示例	138
11．4 学习Abstract Factory模式：实现该模式	144
11．5 实践注记：Abstract Factory模式	149
11．6 将Abstract Factory模式与CAD/CAM问题联系起来	151
11．7 小结	151
复习题	152
简答题	152
阐述题	152
观点与应用题	152
第四部分 组合起来：用模式思考
第12章　专家设计之道	154
12．1 概览	154
12．2 添加特征的创建方式	154
12．3 小结	160
复习题	160
简答题	160
阐述题	161
观点与应用题	161
第13章　用模式解决CAD/CAM问题	162
13．1 概览	162
13．2 对CAD/CAM问题的回顾	162
13．3 用模式思考	163
13．4 用模式思考：步骤1	164
13．5 用模式思考：步骤2a	165
13．6 用模式思考：步骤2b	169
13．7 用模式思考：步骤2c	172
13．8 用模式思考：重复步骤2a和步骤2b（Facade模式）	173
13．9 用模式思考：重复步骤2a和步骤2b（Adapter模式）	174
13．10 用模式思考：重复步骤2a和步骤2b（Abstract Factory模式）	174
13．11 用模式思考：步骤3	175
13．12 与原解决方案的比较	175
13．13 小结	176
复习题	177
简答题	177
阐述题	177
观点与应用题	177
第五部分 迈向新的设计方式
第14章　设计模式的原则与策略	180
14．1 概览	180
14．2 开闭原则	181
14．3 从背景设计原则	181
14．4 封装变化原则	185
14．5 抽象类与接口	186
14．6 理性怀疑原则	187
14．7 小结	187
复习题	188
简答题	188
阐述题	188
观点与应用题	188
第15章　共性与可变性分析	189
15．1 概览	189
15．2 共性和可变性分析与应用程序设计	189
15．3 用CVA解决CAD/CAM问题	190
15．4 小结	194
复习题	194
简答题	194
阐述题	194
观点与应用题	195
第16章　分析矩阵	196
16．1 概览	196
16．2 现实世界：充满变化	196
16．3 国际电子商务系统案例研究：应对变化	197
16．4 实践注记	203
16．5 小结	206
复习题	206
简答题	206
阐述题	206
观点与应用题	206
第17章　Decorator模式	207
17．1 概览	207
17．2 更多细节	207
17．3 Decorator模式	209
17．4 将Decorator模式应用到我们的案例研究	210
17．5 另一个例子：输入/输出	213
17．6 实践注记：使用Decorator模式	215
17．7 Decorator模式的本质	216
17．8 小结	217
复习题	217
简答题	217
阐述题	217
观点与应用题	217
第六部分 其他重要模式
第18章　Observer模式	220
18．1 概览	220
18．2 模式的分类	220
18．3 国际电子商务案例的更多需求	221
18．4 Observer模式	222
18．5 将Observer模式应用到我们的案例研究	223
18．6 实践注记：使用Observer模式	227
18．7 小结	229
复习题	229
简答题	229
阐述题	230
观点与应用题	230
第19章　Template Method模式	231
19．1 概览	231
19．2 案例研究的更多需求	231
19．3 Template Method模式	232
19．4 将Template Method模式应用到我们的案例研究	232
19．5 使用Template Method模式减少冗余	233
19．6 实践注记：使用Template Method模式	238
19．7 小结	239
复习题	240
简答题	240
阐述题	240
第七部分 各种工厂模式
第20章　来自设计模式的教益：各种工厂模式	242
20．1 概览	242
20．2 工厂	242
20．3 再谈背景	243
20．4 工厂遵循我们的准则	245
20．5 限制变化的影响	246
20．6 对工厂的另一种思考方式	246
20．7 工厂的不同角色	247
20．8 实践注记	247
20．9 小结	248
复习题	248
简答题	248
阐述题	248
观点与应用题	248
第21章　Singleton模式和Double-Checked Locking模式	249
21．1 概览	249
21．2 Singleton模式简介	249
21．3 将Singleton模式应用到我们的案例研究	250
21．4 一种变体：Double-Checked Locking模式 252
21．5 反思	255
21．6 实践注记：使用Singleton模式和Double-Checked Locking模式	255
21．7 小结	256
复习题	256
简答题	256
阐述题	256
观点与应用题	256
第22章　Object Pool模式	257
22．1 概览	257
22．2 一个需要对对象进行管理的问题	257
22．3 Object Pool模式	263
22．4 观察：工厂的作用不仅是实例化	263
22．5 小结	265
复习题	265
简答题	265
阐述题	266
观点与应用题	266
第23章　Factory Method模式	267
23．1 概览	267
23．2 案例研究的更多需求	267
23．3 Factory Method模式	268
23．4 Factory Method模式与面向对象语言	268
23．5 实践注记：使用Factory Method模式	269
23．6 小结	270
复习题	271
简答题	271
阐述题	271
观点与应用题	271
第24章　工厂模式的总结	272
24．1 概览	272
24．2 软件开发过程中的步骤	272
24．3 工厂与极限编程实践殊途同归	273
24．4 系统的扩展性	273
第八部分 终点与起点
第25章　设计模式回顾：总结与新起点	276
25．1 概览	276
25．2 面向对象原则的总结	276
25．3 设计模式如何封装实现	277
25．4 共性和可变性分析与设计模式	277
25．5 按责任分解问题域	278
25．6 模式和从背景设计	279
25．7 模式内部的关联	279
25．8 设计模式与敏捷编程实践	281
25．9 实践注记	281
25．10 小结	281
复习题	282
简答题	282
阐述题	282
观点与应用题	282
第26章　参考书目	283
26．1 本书配套网站	283
26．2 推荐阅读	284
26．3 针对Java程序员的推荐读物	285
26．4 针对C++程序员的推荐读物	286
26．5 针对COBOL程序员的推荐读物	287
26．6 极限编程的推荐读物	287
26．7 程序设计的一般性推荐读物	287
26．8 个人推荐	288
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式解析（第2版·修订版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式从入门到精通
第1章  设计模式初见第2章  面向对象设计原则第3章  统一建模语言UML概述第4章  工厂方法模式（Factory Method）第5章  抽象工厂模式（Abstract Factory）第6章  建造者模式（Builder Factory）第7章  原型模式（Prototype）第8章  单例模式（Singleton）第9章  适配器模式（Adapter）第10章  桥接模式（Bridge）第11章  代理模式（Proxy）第12章  外观模式（Facade）第13章  装饰模式（Decorator）第14章  组合模式（Composite）第15章  享元模式（Flyweight）第16章  命令模式（Command）第17章  观察者模式（Observer）第18章  责任链模式（Chain of Responsibility）第19章  迭代器模式（Iterator）第20章  访问者模式（Visitor）第21章  状态模式（State） 第22章  备忘录模式（Memento）第23章  策略模式（Strategy）第24章  调停者模式（Mediator）第25章  模板方法模式（Template Method）第26章  解释器模式（Interpreter）第27章  设计模式总结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式从入门到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>VISUAL BASIC设计模式(VB6.0和VB.NET附光盘)
第一部分 VB面向对象程序设计
第1章 设计模式概述
第2章 UML图
第3章 在VB中使用类和对象
第4章 面向对象的程序设计
……
第二部分 生成模式
第9章 简单工厂模式
第10章 工厂方法模式
第11章 抽象工厂模式
第12章 单一类模式
……
第三部分 结构模式
第15章 适配器模式
第16章 桥模式
第17章 组合模式
第18章 修饰模式
……
第四部分 行为模式
第22章 响应链
第23章 命令模式
第24章 解释模式
第25章 迭代模式
……
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>VISUAL BASIC设计模式(VB6.0和VB.NET附光盘)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>网站设计解构
第一部分 框架体系简介
第1章 框架体系呼之欲出      2
1.1 可重用策略      7
1.1.1 模式：预期行为的锦囊      7
1.1.2 组件：高效利用可重用的代码      8
1.1.3 框架体系：最后的拼图定乾坤      9
1.2 超越常规      12
1.2.1 分解工作量      12
1.2.2 古老问题有新解      12
1.2.3 问题，答案与灵感      13
第2章 可重用铁三角      14
2.1 设计模式      16
2.1.1 设计模式六要素      17
2.1.2 模式资源库      21
2.2 组件      .23
2.2.1 组件六要素      23
2.2.2 组件资源库      26
2.3 交互设计框架体系      27
2.3.1 交互设计框架体系包含的元素      28
2.3.2 框架体系的特质      33
2.3.3 第一个框架体系资源库      36
2.4 自然环境下的框架      38
第二部分 框架体系
第3章 目录框架      42
3.1 描述      43
3.2 上下文情境      43
3.3 任务流程      45
3.4 其他必备框架      45
3.5 相关框架      45
3.6 构成元素      45
3.6.1 分类页      45
3.6.2 陈列页      49
3.6.3 内容页      54
3.6.4 引导链接      58
3.7 设计标准      61
3.7.1 支持用户的探索      63
3.7.2 公布分类方法      69
4章 搜索框架      71
4.1 描述      72
4.2 上下文情境      73
4.3 任务流程      75
4.4 构成元素      76
4.4.1 快速搜索      76
4.4.2 搜索结果      80
4.4.3 搜索产出      82
4.4.4 高级搜索      83
4.4.5 过滤器      86
4.4.6 分页      88
4.5 设计标准      90
4.5.1 提供多条通向内容的路径      90
4.5.2 使内容与用户的用词相关联      91
4.5.3 让内容便于识别      91
5章 注册框架      93
5.1 描述      95
5.2 上下文情境      95
5.3 任务流程      96
5.4 构成元素      96
5.4.1 价值声明      96
5.4.2 投入成本明细      98
5.4.3 推荐语      .101
5.4.4 行动号召      102
5.4.5 白板/即时参与      104
5.4.6 注册表单      106
5.5 设计标准      108
5.5.1 传达明确的价值声明      108
5.5.2 建立起用户的预期      109
5.5.3 证明应用程序运行良好      110
5.5.4 鼓励操作并确保取得进展      111
5.5.5 让用户和他们的操作相联系      111
第6章 关于我们      114
6.1 描述      115
6.2 上下文情境      115
6.3 任务流程      116
6.4 构成元素      117
6.4.1 公司背景      117
6.4.2 财务状况      118
6.4.3 客户名录      121
6.4.4 团队介绍      121
6.4.5 时事与新闻      .123
6.4.6 工作机会      124
6.4.7 联系方式      127
6.5 设计标准      130
6.5.1 建立品牌信誉度      130
6.5.2 打开沟通的渠道      131
第7章 电影网站      134
7.1 描述      .136
7.2 上下文情境      139
7.3 构成元素      140
7.3.1 初始页      140
7.3.2 引子/预告片      142
7.3.3 演职员名单      144
7.3.4 故事梗概      145
7.4 设计标准      146
7.4.1 建立良好的声誉      147
7.4.2 实现口口相传的营销      148
7.4.3 让他们感兴趣      150
7.4.4 融入他们的生活      151
第三部分 框架体系的使用
第8章 搭建框架体系工具      154
8.1 打造你的框架      155
8.1.1 标识出问题      155
8.1.2 品鉴资源      156
8.1.3 把它写出来      160
8.1.4 分配工作量      164
第9章 使用框架体系      165
9.1 组织计划      165
9.2 搭建框架      166
9.2.1 在上下文中考虑上下文      167
9.2.2 选用模式      171
9.2.3 应用设计标准      172
9.3 让框架切实可行      173
9.3.1 资源库      173
9.3.2 模板      .175
第10章 改善我们的未来      177
10.1 挫折成本      179
10.2 资源      182
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>网站设计解构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java设计模式
目录



第1章设计模式概述

1.1设计模式的诞生与发展

1.1.1模式的诞生与定义

1.1.2软件模式概述

1.1.3设计模式的发展

1.2设计模式的定义与分类

1.2.1设计模式的定义

1.2.2设计模式的基本要素

1.2.3设计模式的分类

1.3GoF设计模式简介

1.4设计模式的优点

1.5本章小结

1.6习题

第2章面向对象设计原则

2.1面向对象设计原则概述

2.2单一职责原则

2.3开闭原则

2.4里氏代换原则

2.5依赖倒转原则

2.6接口隔离原则

2.7合成复用原则

2.8迪米特法则

2.9本章小结

2.10习题

第3章简单工厂模式

3.1创建型模式

3.2简单工厂模式概述

3.3简单工厂模式结构与实现

3.3.1简单工厂模式结构

3.3.2简单工厂模式实现

3.4简单工厂模式应用实例

3.5关于创建对象与使用对象

3.6简单工厂模式的简化

3.7简单工厂模式优/缺点与适用环境

3.7.1简单工厂模式优点

3.7.2简单工厂模式缺点

3.7.3简单工厂模式适用环境

3.8本章小结

3.9习题

第4章工厂方法模式

4.1工厂方法模式概述

4.2工厂方法模式结构与实现

4.2.1工厂方法模式结构

4.2.2工厂方法模式实现

4.3工厂方法模式应用实例

4.4反射机制与配置文件

4.5工厂方法的重载

4.6工厂方法的隐藏

4.7工厂方法模式优/缺点与适用环境

4.7.1工厂方法模式优点

4.7.2工厂方法模式缺点

4.7.3工厂方法模式适用环境

4.8本章小结

4.9习题

第5章抽象工厂模式

5.1产品等级结构与产品族

5.2抽象工厂模式概述

5.3抽象工厂模式结构与实现

5.3.1抽象工厂模式结构

5.3.2抽象工厂模式实现

5.4抽象工厂模式应用实例

5.5开闭原则的倾斜性

5.6抽象工厂模式优/缺点与适用环境

5.6.1抽象工厂模式优点

5.6.2抽象工厂模式缺点

5.6.3抽象工厂模式适用环境

5.7本章小结

5.8习题

第6章建造者模式

6.1建造者模式概述

6.2建造者模式结构与实现

6.2.1建造者模式结构

6.2.2建造者模式实现

6.3建造者模式应用实例

6.4指挥者类的深入讨论

6.5建造者模式优/缺点与适用环境

6.5.1建造者模式优点

6.5.2建造者模式缺点

6.5.3建造者模式适用环境

6.6本章小结

6.7习题

第7章原型模式

7.1原型模式概述

7.2原型模式结构与实现

7.2.1原型模式结构

7.2.2浅克隆与深克隆

7.2.3原型模式实现

7.3原型模式应用实例

7.4原型管理器

7.5原型模式优/缺点与适用环境

7.5.1原型模式优点

7.5.2原型模式缺点

7.5.3原型模式适用环境

7.6本章小结

7.7习题

第8章单例模式

8.1单例模式概述

8.2单例模式结构与实现

8.2.1单例模式结构

8.2.2单例模式实现

8.3单例模式应用实例

8.4饿汉式单例与懒汉式单例

8.5单例模式优/缺点与适用环境

8.5.1单例模式优点

8.5.2单例模式缺点

8.5.3单例模式适用环境

8.6本章小结

8.7习题

第9章适配器模式

9.1结构型模式

9.2适配器模式概述

9.3适配器模式结构与实现

9.3.1适配器模式结构

9.3.2适配器模式实现

9.4适配器模式应用实例

9.5缺省适配器模式

9.6双向适配器

9.7适配器模式优/缺点与适用环境

9.7.1适配器模式优点

9.7.2适配器模式缺点

9.7.3适配器模式适用环境

9.8本章小结

9.9习题

第10章桥接模式

10.1桥接模式概述

10.2桥接模式结构与实现

10.2.1桥接模式结构

10.2.2桥接模式实现

10.3桥接模式应用实例

10.4桥接模式与适配器模式的联用

10.5桥接模式优/缺点与适用环境

10.5.1桥接模式优点

10.5.2桥接模式缺点

10.5.3桥接模式适用环境

10.6本章小结

10.7习题

第11章组合模式

11.1组合模式概述

11.2组合模式结构与实现

11.2.1组合模式结构

11.2.2组合模式实现

11.3组合模式应用实例

11.4透明组合模式与安全组合模式

11.5组合模式优/缺点与适用环境

11.5.1组合模式优点

11.5.2组合模式缺点

11.5.3组合模式适用环境

11.6本章小结

11.7习题

第12章装饰模式

12.1装饰模式概述

12.2装饰模式结构与实现

12.2.1装饰模式结构

12.2.2装饰模式实现

12.3装饰模式应用实例

12.4透明装饰模式与半透明装饰模式

12.5装饰模式优/缺点与适用环境

12.5.1装饰模式优点

12.5.2装饰模式缺点

12.5.3装饰模式适用环境

12.6本章小结

12.7习题

第13章外观模式

13.1外观模式概述

13.2外观模式结构与实现

13.2.1外观模式结构

13.2.2外观模式实现

13.3外观模式应用实例

13.4抽象外观类

13.5外观模式优/缺点与适用环境

13.5.1外观模式优点

13.5.2外观模式缺点

13.5.3外观模式适用环境

13.6本章小结

13.7习题

第14章享元模式

14.1享元模式概述

14.2享元模式结构与实现

14.2.1享元模式结构

14.2.2享元模式实现

14.3享元模式应用实例

14.4有外部状态的享元模式

14.5单纯享元模式与复合享元模式

14.6享元模式与String类

14.7享元模式优/缺点与适用环境

14.7.1享元模式优点

14.7.2享元模式缺点

14.7.3享元模式适用环境

14.8本章小结

14.9习题

第15章代理模式

15.1代理模式概述

15.2代理模式结构与实现

15.2.1代理模式结构

15.2.2代理模式实现

15.3代理模式应用实例

15.4远程代理

15.5虚拟代理

15.6Java动态代理

15.7代理模式优/缺点与适用环境

15.7.1代理模式优点

15.7.2代理模式缺点

15.7.3代理模式适用环境

15.8本章小结

15.9习题

第16章职责链模式

16.1行为型模式

16.2职责链模式概述

16.3职责链模式结构与实现

16.3.1职责链模式结构

16.3.2职责链模式实现

16.4职责链模式应用实例

16.5纯与不纯的职责链模式

16.6职责链模式优/缺点与适用环境

16.6.1职责链模式优点

16.6.2职责链模式缺点

16.6.3职责链模式适用环境

16.7本章小结

16.8习题

第17章命令模式

17.1命令模式概述

17.2命令模式结构与实现

17.2.1命令模式结构

17.2.2命令模式实现

17.3命令模式应用实例

17.4实现命令队列

17.5记录请求日志

17.6实现撤销操作

17.7宏命令

17.8命令模式优/缺点与适用环境

17.8.1命令模式优点

17.8.2命令模式缺点

17.8.3命令模式适用环境

17.9本章小结

17.10习题

第18章解释器模式

18.1解释器模式概述

18.2文法规则和抽象语法树

18.3解释器模式结构与实现

18.3.1解释器模式结构

18.3.2解释器模式实现

18.4解释器模式应用实例

18.5解释器模式优/缺点与适用环境

18.5.1解释器模式优点

18.5.2解释器模式缺点

18.5.3解释器模式适用环境

18.6本章小结

18.7习题

第19章迭代器模式

19.1迭代器模式概述

19.2迭代器模式结构与实现

19.2.1迭代器模式结构

19.2.2迭代器模式实现

19.3迭代器模式应用实例

19.4使用内部类实现迭代器

19.5Java内置迭代器

19.6迭代器模式优/缺点与适用环境

19.6.1迭代器模式优点

19.6.2迭代器模式缺点

19.6.3迭代器模式适用环境

19.7本章小结

19.8习题

第20章中介者模式

20.1中介者模式概述

20.2中介者模式结构与实现

20.2.1中介者模式结构

20.2.2中介者模式实现

20.3中介者模式应用实例

20.4扩展中介者与同事类

20.5中介者模式优/缺点与适用环境

20.5.1中介者模式优点

20.5.2中介者模式缺点

20.5.3中介者模式适用环境

20.6本章小结

20.7习题

第21章备忘录模式

21.1备忘录模式概述

21.2备忘录模式结构与实现

21.2.1备忘录模式结构

21.2.2备忘录模式实现

21.3备忘录模式应用实例

21.4实现多次撤销

21.5备忘录模式优/缺点与适用环境

21.5.1备忘录模式优点

21.5.2备忘录模式缺点

21.5.3备忘录模式适用环境

21.6本章小结

21.7习题

第22章观察者模式

22.1观察者模式概述

22.2观察者模式结构与实现

22.2.1观察者模式结构

22.2.2观察者模式实现

22.3观察者模式应用实例

22.4JDK对观察者模式的支持

22.5观察者模式与Java事件处理

22.6观察者模式与MVC

22.7观察者模式优/缺点与适用环境

22.7.1观察者模式优点

22.7.2观察者模式缺点

22.7.3观察者模式适用环境

22.8本章小结

22.9习题

第23章状态模式

23.1状态模式概述

23.2状态模式结构与实现

23.2.1状态模式结构

23.2.2状态模式实现

23.3状态模式应用实例

23.4共享状态

23.5使用环境类实现状态转换

23.6状态模式优/缺点与适用环境

23.6.1状态模式优点

23.6.2状态模式缺点

23.6.3状态模式适用环境

23.7本章小结

23.8习题

第24章策略模式

24.1策略模式概述

24.2策略模式结构与实现

24.2.1策略模式结构

24.2.2策略模式实现

24.3策略模式应用实例

24.4Java SE中的布局管理

24.5策略模式优/缺点与适用环境

24.5.1策略模式优点

24.5.2策略模式缺点

24.5.3策略模式适用环境

24.6本章小结

24.7习题

第25章模板方法模式

25.1模板方法模式概述

25.2模板方法模式结构与实现

25.2.1模板方法模式结构

25.2.2模板方法模式实现

25.3模板方法模式应用实例

25.4钩子方法的使用

25.5模板方法模式优/缺点与适用环境

25.5.1模板方法模式优点

25.5.2模板方法模式缺点

25.5.3模板方法模式适用环境

25.6本章小结

25.7习题

第26章访问者模式

26.1访问者模式概述

26.2访问者模式结构与实现

26.2.1访问者模式结构

26.2.2访问者模式实现

26.3访问者模式应用实例

26.4访问者模式与组合模式联用

26.5访问者模式优/缺点与适用环境

26.5.1访问者模式优点

26.5.2访问者模式缺点

26.5.3访问者模式适用环境

26.6本章小结

26.7习题

附录AUML类图

A.1UML概述

A.2类与类的UML表示

A.3类之间的关系

附录B设计模式模拟试题

B.1模拟试题一

B.2模拟试题二

B.3模拟试题三

参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Python设计模式（第2版）
前言
第1章　设计模式简介
第2章　单例设计模式
第3章　工厂模式：建立创建对象的工厂
第4章　门面模式——与门面相适
第5章　代理模式——控制对象的访问
第6章　观察者模式——了解对象的情况
第7章　命令模式——封装调用
第8章　模板方法模式——封装算法
第9章　模型—视图—控制器——复合模式
第10章　状态设计模式
第11章　反模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Python设计模式（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java设计模式及实践
译者序
前言
关于作者
关于评审者
第1章　从面向对象到函数式编程 1
1.1　Java简介 1
1.2　Java编程范式 2
1.2.1　命令式编程 2
1.2.2　面向对象编程 3
1.2.3　声明式编程 6
1.2.4　函数式编程 6
1.3　流以及集合的使用 7
1.4　统一建模语言简介 8
1.5　设计模式和原则 11
1.5.1　单一职责原则 12
1.5.2　开闭原则 13
1.5.3　里氏替换原则 13
1.5.4　接口隔离原则 14
1.5.5　依赖倒置原则 16
1.6　总结 16
第2章　创建型模式 18
2.1　单例模式 18
2.1.1　同步锁单例模式 19
2.1.2　拥有双重校验锁机制的同步锁单例模式 20
2.1.3　无锁的线程安全单例模式 21
2.1.4　提前加载和延迟加载 21
2.2　工厂模式 22
2.2.1　简单工厂模式 22
2.2.2　工厂方法模式 25
2.2.3　抽象工厂模式 27
2.2.4　简单工厂、工厂方法与抽象工厂模式之间的对比 28
2.3　建造者模式 29
2.3.1　汽车建造者样例 30
2.3.2　简化的建造者模式 32
2.3.3　拥有方法链的匿名建造者 32
2.4　原型模式 33
2.5　对象池模式 34
2.6　总结 36
第3章　行为型模式 37
3.1　责任链模式 38
3.2　命令模式 40
3.3　解释器模式 43
3.4　迭代器模式 47
3.5　观察者模式 50
3.6　中介者模式 51
3.7　备忘录模式 53
3.8　状态模式 55
3.9　策略模式 55
3.10　模板方法模式 56
3.11　空对象模式 57
3.12　访问者模式 58
3.13　总结 59
第4章　结构型模式 60
4.1　适配器模式 61
4.2　代理模式 66
4.3　装饰器模式 70
4.4　桥接模式 73
4.5　组合模式 76
4.6　外观模式 79
4.7　享元模式 83
4.8　总结 88
第5章　函数式编程 89
5.1　函数式编程简介 89
5.1.1　lambda表达式 91
5.1.2　纯函数 92
5.1.3　引用透明性 92
5.1.4　初等函数 93
5.1.5　高阶函数 93
5.1.6　组合 93
5.1.7　柯里化 93
5.1.8　闭包 94
5.1.9　不可变性 95
5.1.10　函子 95
5.1.11　单子 96
5.2　Java中的函数式编程 97
5.2.1　lambda表达式 97
5.2.2　流 98
5.3　重新实现面向对象编程设计模式 102
5.3.1　单例模式 102
5.3.2　建造者模式 102
5.3.3　适配器模式 103
5.3.4　装饰器模式 103
5.3.5　责任链模式 103
5.3.6　命令模式 104
5.3.7　解释器模式 104
5.3.8　迭代器模式 104
5.3.9　观察者模式 105
5.3.10　策略模式 105
5.3.11　模板方法模式 105
5.4　函数式设计模式 106
5.4.1　MapReduce 106
5.4.2　借贷模式 107
5.4.3　尾调用优化 108
5.4.4　记忆化 109
5.4.5　执行around方法 110
5.5　总结 111
第6章　响应式编程 112
6.1　什么是响应式编程 113
6.2　RxJava简介 114
6.3　安装RxJava 115
6.3.1　Maven下的安装 115
6.3.2　JShell下的安装 116
6.4　Observable、Flowable、Observer和Subscription的含义 116
6.5　创建Observable 118
6.5.1　create操作符 118
6.5.2　defer操作符 119
6.5.3　empty操作符 120
6.5.4　from操作符 120
6.5.5　interval操作符 120
6.5.6　timer操作符 121
6.5.7　range操作符 121
6.5.8　repeat操作符 121
6.6　转换Observable 122
6.6.1　subscribe操作符 122
6.6.2　buffer操作符 122
6.6.3　flatMap操作符 122
6.6.4　groupBy操作符 124
6.6.5　map操作符 124
6.6.6　scan操作符 125
6.6.7　window操作符 125
6.7　过滤Observable 125
6.7.1　debounce操作符 125
6.7.2　distinct操作符 126
6.7.3　elementAt操作符 126
6.7.4　f?ilter操作符 127
6.7.5　f?irst/last操作符 127
6.7.6　sample操作符 128
6.7.7　skip操作符 128
6.7.8　take操作符 128
6.8　组合Observable 128
6.8.1　combine操作符 129
6.8.2　join操作符 129
6.8.3　merge操作符 130
6.8.4　zip操作符 131
6.9　异常处理 131
6.9.1　catch操作符 131
6.9.2　do操作符 132
6.9.3　using操作符 133
6.9.4　retry操作符 133
6.10　线程调度器 134
6.11　Subject 135
6.12　示例项目 136
6.13　总结 139
第7章　响应式设计模式 140
7.1　响应模式 140
7.1.1　请求-响应模式 140
7.1.2　异步通信模式 146
7.1.3　缓存模式 148
7.1.4　扇出与最快响应模式 149
7.1.5　快速失败模式 150
7.2　弹性模式 150
7.2.1　断路器模式 150
7.2.2　故障处理模式 151
7.2.3　有限队列模式 151
7.2.4　监控模式 152
7.2.5　舱壁模式 152
7.3　柔性模式 152
7.3.1　单一职责模式 153
7.3.2　无状态服务模式 154
7.3.3　自动伸缩模式 156
7.3.4　自包含模式 156
7.4　消息驱动通信模式 157
7.4.1　事件驱动通信模式 157
7.4.2　出版者-订阅者模式 157
7.4.3　幂等性模式 158
7.5　总结 158
第8章　应用架构的发展趋势 159
8.1　什么是应用架构 159
8.2　分层架构 160
8.2.1　分层架构示例 162
8.2.2　tier和layer的区别 1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java设计模式及实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务设计模式和最佳实践
目录
第1章 微服务概念 1
1.1 理解应用程序 2
1.1.1 领域驱动设计 2
1.1.2 单一职责原则 4
1.1.3 显式发布的接口 5
1.2 独立部署、更新、扩展以及替换 7
1.2.1 独立部署 7
1.2.2 更新 7
1.2.3 可扩展性 8
1.3 轻量级通信 12
1.3.1 同步 13
1.3.2 异步 13
1.4 异质/多语言 14
1.5 通信的文档化 14
1.6 Web应用程序端点 15
1.7 移动应用程序端点 15
1.8 缓存客户端 16
1.9 调节客户端 17
1.10 确定贫血域 17
1.11 确定fat域 18
1.12 针对业务确定微服务域 18
1.13 从域到实体 19
1.14 本章小结 20
第2章 微服务工具 21
2.1 编程语言 21
2.1.1 熟练程度 22
2.1.2 性能 22
2.1.3 实践开发 23
2.1.4 生态圈 23
2.1.5 扩展性的开销 24
2.1.6 选取编程语言 24
2.2 微服务框架 27
2.2.1 Python语言 27
2.2.2 Go语言 29
2.3 二进制通信—服务间的直接通信 31
2.3.1 理解通信方式 31
2.3.2 直接通信间的警示信息 35
2.4 消息代理—服务间的异步通信 37
2.4.1 ActiveMQ 38
2.4.2 RabbitMQ 39
2.4.3 Kafka 40
2.5 缓存工具 40
2.5.1 Memcached 42
2.5.2 Redis 42
2.6 故障警示工具 44
2.6.1 性能 44
2.6.2 构建 45
2.6.3 组件 46
2.6.4 实现鸿沟 47
2.7 数据库 47
2.8 本地性能度量 48
2.8.1 Apache Benchmark 49
2.8.2 WRK 50
2.8.3 Locust 51
2.9 本章小结 53
第3章 内部模式 55
3.1 开发结构 55
3.1.1 数据库 55
3.1.2 编程语言和工具 56
3.1.3 项目结构 56
3.2 缓存策略 71
3.2.1 缓存机制的应用 72
3.2.2 缓存优先 78
3.2.3 队列任务 79
3.2.4 异步机制和worker 81
3.3 CQRS—查询策略 87
3.3.1 CQRS的概念 87
3.3.2 理解CQRS 88
3.3.3 CQRS的优点和缺陷 90
3.4 事件源—数据完整性 91
3.5 本章小结 92
第4章 微服务生态环境 93
4.1 容器中的分离机制 93
4.1.1 分层服务架构 95
4.1.2 分离UsersService 96
4.2 存储分布 103
4.2.1 折旧数据 103
4.2.2 区域化数据 103
4.3 隔离—使用生态系统防止故障的出现 104
4.3.1 冗余设计 104
4.3.2 临界分区 109
4.3.3 隔离设计 110
4.3.4 快速故障 111
4.4 断路器 112
4.5 本章小结 113
第5章 共享数据微服务设计模式 115
5.1 理解模式 115
5.2 将单体应用程序划分为微服务 116
5.2.1 定义优先级 117
5.2.2 设置期限 117
5.2.3 定义应用程序域 117
5.2.4 试验操作 117
5.2.5 制定标准 118
5.2.6 构建原型 118
5.2.7 发送产品 118
5.2.8 开发新的微服务 118
5.3 数据编排 130
5.4 响应整合 132
5.5 微服务通信 132
5.6 存储共享反模式 133
5.7 最佳实践 133
5.8 测试机制 133
5.9 共享数据模式的利弊 135
5.10 本章小结 136
第6章 聚合器微服务设计模式 137
6.1 理解聚合器设计模式 137
6.2 使用CQRS和事件源 139
6.2.1 分离数据库 139
6.2.2 重构微服务 140
6.3 微服务通信 153
6.3.1 创建编排器 154
6.3.2 使用消息代理 159
6.4 模式扩展 163
6.5 瓶颈反模式 164
6.6 最佳实践 166
6.7 测试 167
6.7.1 功能测试 167
6.7.2 集成测试 168
6.8 聚合器设计模式的优缺点 170
6.8.1 聚合器设计模式的优点 170
6.8.2 聚合器设计模式的缺点 170
6.9 本章小结 170
第7章 代理微服务设计模式 171
7.1 代理方案 171
7.1.1 哑代理 172
7.1.2 智能代理 172
7.1.3 理解当前代理 173
7.2 编排器的代理策略 175
7.3 微服务通信 176
7.4 模式扩展性 176
7.5 最佳实践 177
7.5.1 纯粹的模式 177
7.5.2 瓶颈问题 178
7.5.3 代理制的缓存机制 178
7.5.4 简单的响应 178
7.6 代理设计模式的优缺点 179
7.7 本章小结 179
第8章 链式微服务设计模式 181
8.1 理解模式 181
8.2 数据编排和响应整合 184
8.3 微服务通信 185
8.4 模式扩展性 185
8.5 “大泥球”反模式 186
8.6 最佳实践方案 188
8.6.1 纯微服务 188
8.6.2 请求一致性数据 188
8.6.3 深入理解链式设计模式 189
8.6.4 关注通信层 189
8.7 链式设计模式的优缺点 189
8.8 本章小结 190
第9章 分支微服务设计模式 191
9.1 理解模式 191
9.2 数据编排和响应整合 194
9.3 微服务通信 195
9.4 模式扩展 197
9.5 最佳实践方案 198
9.5.1 域定义 198
9.5.2 遵守规则 198
9.5.3 关注物理组件 198
9.5.4 简化行为 199
9.6 分支设计模式的优缺点 199
9.7 本章小结 199
第10章 异步消息微服务 201
10.1 理解当前模式 201
10.2 域定义—RecommendationService 203
10.3 域定义—RecommendationService 204
10.4 微服务编码 204
10.5 微服务通信 211
10.5.1 使用消息代理和队列 211
10.5.2 准备pub/sub结构 212
10.6 模式的可扩展性 214
10.7 进程序列反模式 214
10.8 最佳实践方案 215
10.8.1 应用程序定义 215
10.8.2 不要尝试创建响应 216
10.8.3 保持简单性 216
10.9 异步消息传递设计模式的优缺点 216
10.10 本章小结 217
第11章 微服务间的协同工作 219
11.1 理解当前应用程序状态 219
11.1.1 公共饰面层 220
11.1.2 内部层 222
11.1.3 理解通用工具 223
11.2 通信层和服务间的委托 224
11.2.1 理解服务间的数据合约 225
11.2.2 使用二进制通信 228
11.3 模式分布 235
11.4 故障策略 236
11.5 API集成 237
11.6 本章小结 239
第12章 微服务测试 241
12.1 单元测试 241
12.2 针对集成测试配置容器 249
12.3 集成测试 251
12.4 端到端测试 253
12.5 发布管线 259
12.6 签名测试 259
12.7 Monkey测试 260
12.8 Chaos Monkey 260
12.9 本章小结 262
第13章 安全监测和部署方案 263
13.1 监测微服务 263
13.1.1 监测单一服务 264
13.1.2 监测多项服务 266
13.1.3 查看日志 267
13.1.4 应用程序中的错误 268
13.1.5 度量方法 271
13.2 安全问题 272
13.2.1 理解JWT 272
13.2.2 单点登录 275
13.2.3 数据安全 276
13.2.4 预防恶意攻击—识别攻击行为 277
13.2.5 拦截器 277
13.2.6 容器 278
13.2.7 API网关 279
13.3 部署 279
13.3.1 持续集成和持续交付/持续部署 280
13.3.2 蓝/绿部署模式和Canary发布 281
13.3.3 每台主机包含多个服务实例 282
13.3.4 每台主机的服务实例 283
13.4 本章小结 285
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务设计模式和最佳实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Python设计模式
第1章 前述 1
1.1 大师 1
1.2 成为更优秀的程序员 3
1.2.1 刻意训练 4
1.2.2 单一关注点 4
1.2.3 快速反馈 5
1.2.4 自我拓展 5
1.2.5 站在巨人的肩膀上 6
1.2.6 如何入手 6
1.2.7 保持路线正确的能力 7
1.3 系统化思考 8
1.4 思维模型 8
1.5 这项任务的适用工具 9
1.6 设计模式的概念 9
1.6.1 是什么造就了设计模式 10
1.6.2 分类 10
1.7 将用到的工具 11
1.8 本书的阅读方式 12
1.9 配置Python环境 12
1.9.1 Linux环境 12
1.9.2 Mac环境 13
1.9.3 Windows环境 14
1.9.4 VirtualEnv 15
1.10 编辑器 16
1.10.1 Atom 16
1.10.2 LightTable 16
1.10.3 PyCharm 16
1.10.4 Vim 17
1.10.5 Emacs 17
1.10.6 Sublime Text 17
1.11 本章小结 18
第2章 单例模式 19
2.1 问题 19
2.2 进入对象 23
2.3 整理 26
2.4 练习 29
第3章 原型模式 31
3.1 问题 31
3.2 迈出第一步之后 31
3.3 一个真实游戏的基础 32
3.4 实现原型模式 41
3.5 浅拷贝与深拷贝的对比 42
3.6 浅拷贝 43
3.7 处理嵌套结构 43
3.8 深拷贝 44
3.9 将所学知识用在项目中 45
3.10 练习 48
第4章 工厂模式 49
4.1 准备开始 49
4.2 游戏循环 50
4.3 工厂方法 54
4.4 抽象工厂 56
4.5 本章小结 57
4.6 练习 58
第5章 建造者模式 59
5.1 反模式 65
5.2 练习 70
第6章 适配器模式 71
6.1 不要重复自己(DRY) 72
6.2 关注点分离 73
6.3 样本问题 75
6.3.1 类适配器 76
6.3.2 对象适配器模式 77
6.3.3 鸭子类型 77
6.4 在现实环境中实现适配器模式 78
6.5 结束语 80
6.6 练习 81
第7章 装饰器模式 83
7.1 装饰器模式 85
7.1.1 闭包 89
7.1.2 保留函数的__name__和__doc__属性 89
7.2 装饰类 92
7.3 结束语 94
7.4 练习 95
第8章 外观模式 97
8.1 POS示例 97
8.2 系统演进 100
8.3 使外观模式凸显出来的原因 101
8.4 结束语 103
8.5 练习 104
第9章 代理模式 105
9.1 记忆法 105
9.2 代理模式 107
9.2.1 远程代理 109
9.2.2 虚拟代理 110
9.2.3 保护代理 110
9.3 结束语 110
9.4 练习 110
第10章 责任链模式 113
10.1 安装一台WSGI服务器 114
10.2 身份验证头信息 115
10.3 责任链模式 119
10.4 在项目中实现责任链 121
10.5 一种更趋Python化的实现 124
10.6 结束语 128
10.7 练习 129
第11章 命令模式 131
11.1 控制turtle 131
11.2 命令模式 133
11.3 结束语 138
11.4 练习 139
第12章 解释器模式 141
12.1 特定领域语言 141
12.1.1 DSL的优势 144
12.1.2 DSL的劣势 144
12.1.3 组合模式 148
12.1.4 使用组合模式的内部DSL实现 149
12.2 实现解释器模式 152
12.3 结束语 157
12.4 练习 158
第13章 迭代器模式 159
13.1 迭代器模式的Python内部实现 161
13.1.1 Itertools 166
13.1.2 生成器函数 167
13.1.3 生成器表达式 169
13.2 结束语 169
13.3 练习 170
第14章 观察者模式 171
14.1 结束语 183
14.2 练习 183
第15章 状态模式 185
15.1 状态模式 187
15.2 结束语 191
15.3 练习 191
第16章 策略模式 193
16.1 结束语 197
16.2 练习 197
第17章 模板方法模式 199
17.1 结束语 207
17.2 练习 208
第18章 访问者模式 209
18.1 访问者模式 218
18.2 结束语 226
18.3 练习 227
第19章 模型-视图-控制器模式 229
19.1 模型-视图-控制器概述 232
19.1.1 控制器 234
19.1.2 模型 234
19.1.3 视图 235
19.1.4 总述 235
19.2 结束语 239
19.3 练习 240
第20章 发布-订阅模式 241
20.1 分布式消息发送器 246
20.2 结束语 248
20.3 练习 249
附录 设计模式快速参考 251
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Python设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式沉思录
第1章 介绍	1
11　对模式的十大误解	2
12　观察	9
第2章 运用模式进行设计	11
21　基础	12
22　孤儿、孤儿的收养以及代用品	16
23　“但是应该如何引入代用品呢？”	22
24　访问权限	27
25　关于Visitor的一些警告	35
26　单用户文件系统的保护	37
27　多用户文件系统的保护	44
28　小结	56
第3章 主体和变体	59
31　终止Singleton	59
32　Observer的烦恼	70
33　重温Visitor	77
34　GENERATION GAP	82
35　Type Laundering	98
36　感谢内存泄漏	106
37　推拉模型	111
第4章 爱的奉献	119
第5章 高效模式编写者的7个习惯	143
51　习惯1：经常反思	143
52　习惯2：坚持使用同一套结构	145
53　习惯3：尽早且频繁地涉及具体问题	146
54　习惯4：保持模式间的区别和互补性	146
55　习惯5：有效地呈现	147
56　习惯6：不懈地重复	148
57　习惯7：收集并吸取反馈	149
58　没有银弹	149
参考文献	151
索　　引	155
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式沉思录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>React设计模式与最佳实践
第1章　React基础　　1
1.1　声明式编程　　2
1.2　React元素　　3
1.3　忘掉所学的一切　　5
1.4　常见误解　　7
1.5　小结　　9
第2章　整理代码　　10
2.1　JSX　　10
2.1.1　Babel　　11
2.1.2　Hello，World！　　12
2.1.3　DOM元素与React组件　　13
2.1.4　属性　　13
2.1.5　子元素　　13
2.1.6　JSX与HTML的区别　　14
2.1.7　展开属性　　17
2.1.8　JavaScript模板　　17
2.1.9　常见模式　　17
2.2　ESLint　　25
2.2.1　安装　　25
2.2.2　配置　　25
2.2.3　React插件　　28
2.2.4　Airbnb的配置　　29
2.3　函数式编程基础　　30
2.3.1　一等对象　　30
2.3.2　纯粹性　　31
2.3.3　不可变性　　31
2.3.4　柯里化　　32
2.3.5　组合　　33
2.3.6　函数式编程与UI　　33
2.4　小结　　33
第3章　开发真正可复用的组件　　34
3.1　创建类　　34
3.1.1　createClass工厂方法　　35
3.1.2　继承React.Component　　35
3.1.3　主要区别　　36
3.1.4　无状态函数式组件　　40
3.2　状态　　42
3.2.1　外部库　　43
3.2.2　工作原理　　43
3.2.3　异步　　44
3.2.4　React lumberjack　　45
3.2.5　使用状态　　45
3.3　prop类型　　48
3.4　可复用组件　　51
3.5　可用的风格指南　　54
3.6　小结　　58
第4章　组合一切　　59
4.1　组件间的通信　　59
4.2　容器组件与表现组件模式　　62
4.3　mixin　　67
4.4　高阶组件　　69
4.5　recompose　　72
4.6　函数子组件　　76
4.7　小结　　78
第5章　恰当地获取数据　　79
5.1　数据流　　79
5.1.1　子组件与父组件的通信（回调函数）　　81
5.1.2　公有父组件　　82
5.2　数据获取　　83
5.3　react-refetch　　88
5.4　小结　　92
第6章　为浏览器编写代码　　93
6.1　表单　　93
6.1.1　自由组件　　94
6.1.2　受控组件　　98
6.1.3　JSON schema　　100
6.2　事件　　102
6.3　ref　　104
6.4　动画　　108
6.5　可扩展矢量图形　　110
6.6　小结　　113
第7章　美化组件　　114
7.1　CSS in JavaScript　　114
7.2　行内样式　　116
7.3　Radium　　120
7.4　CSS模块　　123
7.4.1　Webpack　　124
7.4.2　搭建项目　　124
7.4.3　局部作用域的CSS　　126
7.4.4　原子级CSS模块　　131
7.4.5　React CSS模块　　132
7.5　Styled Component　　133
7.6　小结　　135
第8章　服务端渲染的乐趣与益处　　137
8.1　通用应用　　137
8.2　使用服务端渲染的原因　　138
8.2.1　SEO　　138
8.2.2　通用代码库　　139
8.2.3　性能更强　　140
8.2.4　不要低估复杂度　　140
8.3　基础示例　　141
8.4　数据获取示例　　146
8.5　Next.js　　149
8.6　小结　　151
第9章　提升应用性能　　153
9.1　一致性比较与key属性　　153
9.2　优化手段　　158
9.2.1　是否要更新组件　　158
9.2.2　无状态函数式组件　　160
9.3　常用解决方案　　160
9.3.1　why-did-you-update　　161
9.3.2　在渲染方法中创建函数　　162
9.3.3　props常量　　165
9.3.4　重构与良好设计　　167
9.4　工具与库　　172
9.4.1　不可变性　　172
9.4.2　性能监控工具　　173
9.4.3　Babel插件　　174
9.5　小结　　174
第10章　测试与调试　　176
10.1　测试的好处　　176
10.2　用Jest轻松测试JavaScript　　178
10.3　灵活的测试框架Mocha　　184
10.4　React JavaScript测试工具　　187
10.5　真实测试示例　　189
10.6　React组件树快照测试　　195
10.7　代码覆盖率工具　　198
10.8　常用测试方案　　199
10.8.1　测试高阶组件　　199
10.8.2　页面对象模式　　203
10.9　React开发者工具　　206
10.10　React错误处理　　207
10.11　小结　　209
第11章　需要避免的反模式　　210
11.1　用prop初始化状态　　210
11.2　修改状态　　212
11.3　将数组索引作为key　　215
11.4　在DOM元素上展开props对象　　218
11.5　小结　　219
第12章　未来的行动　　220
12.1　为React做贡献　　220
12.2　分发代码　　222
12.3　发布npm包　　224
12.4　小结　　225
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>React设计模式与最佳实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算架构设计模式
目录
Table of Contents
第1章  缓存驻留模式 1
背景和问题 1
解决方案 1
相关模式与指南 5
更多信息 5
第2章  断路器模式 6
背景和问题 6
解决方案 6
问题与思考 8
何时使用此模式 10
相关模式和指南 14
第3章  补偿事务模式 15
背景和问题 15
解决方案 16
问题与思考 16
何时使用此模式 17
相关模式和指南 18
第4章  竞争消费者模式 19
背景和问题 19
解决方案 19
问题与思考 20
何时使用此模式 21
第5章  计算资源合并模式 25
背景和问题 25
解决方案 26
问题与思考 26
应用场景 28
相关模式和指南 32
扩展阅读 32
第6章  命令和查询职责分离(CQRS)模式 33
背景和问题 33
解决方案 34
问题与思考 35
何时使用此模式 36
第7章  事件溯源模式 41
背景和问题 41
解决方案 41
问题与思考 43
何时使用此模式 44
相关模式和指南 47
第8章  外部配置存储模式 48
背景和问题 48
解决方案 48
问题与思考 49
何时使用此模式 50
关联模式和指南 56
第9章  联合身份模式 57
背景和问题 57
解决方案 57
问题与思考 59
何时使用此模式 59
相关模式和指南 61
更多信息 61
第10章  门卫模式 62
背景和问题 62
解决方案 62
问题与思考 63
何时使用此模式 63
相关模式和指南 64
第11章  健康终端监控模式 65
背景和问题 65
解决方案 65
问题与思考 67
何时使用此模式 68
相关模式和指南 71
更多信息 71

第12章  索引表模式 72
背景和问题 72
解决方案 73
问题与思考 75
何时使用此模式 76
相关模式与指南 77
第13章  领导者选举模式 79
背景和问题 79
解决方案 79
问题与思考 80
何时使用此模式 80
相关模式与指南 85
更多信息 85
第14章  实体化视图模式 86
背景和问题 86
解决方案 86
问题与思考 87
何时使用此模式 88
相关模式与指南 89
第15章  管道过滤器模式 90
背景和问题 90
解决方案 91
问题与思考 92
何时使用此模式 93
相关模式与指南 97
第16章  优先队列模式 98
背景和问题 98
解决方案 98
问题与思考 100
何时使用此模式 101
相关模式与指南 103
第17章  基于队列的负载均衡模式 105
背景和问题 105
解决方案 105
问题与思考 106
何时使用此模式 107
相关模式和指南 108
第18章  重试模式 109
背景和问题 109
解决方案 109
问题与思考 111
何时使用此模式 112
相关模式与指南 114
更多信息 114
第19章  运行时重配模式 115
背景和问题 115
解决方案 115
问题与思考 116
何时使用此模式 117
相关的模式和指南 120
更多的信息 121
第20章  调度器代理管理者模式 122
背景和问题 122
解决方案 122
问题与思考 125
何时使用此模式 125
相关模式与指南 128
更多信息 129
第21章  分片模式 130
背景和问题 130
解决方案 130
分片策略 131
问题与思考 135
何时使用此模式 136
相关模式与指南 138
第22章  静态内容托管模式 139
背景和问题 139
解决方案 139
问题与思考 139
何时使用此模式 140
相关模式与指南 143
更多信息 143
第23章  限流模式 144
背景和问题 144
解决方案 144
问题与思考 146
何时使用此模式 147
相关模式与指南 148
第24章  令牌秘钥模式 149
背景和问题 149
解决方案 149
问题与思考 150
何时使用此模式 152
相关模式和指南 154
更多信息 154
第25章  异步消息传输指南 155
消息队列本质 155
异步消息传递的场景 158
实现异步消息传递的注意事项 159
相关模式和指南 161
更多信息 162
第26章  自动伸缩指南 163
什么是自动伸缩 163
实施自动伸缩的场景 164
实施自动伸缩的注意事项 164
Azure解决方案中的自动伸缩 165
相关模式和指南 167
更多信息 167
第27章  缓存指南 168
云应用程序中的缓存 168
使用缓存的注意事项 170
管理缓存并发 172
相关模式和指南 173
更多信息 173
第28章  计算分区指南 174
Azure计算选项概述 174
计算界限设计指南 174
组件分离计算实例 176
相关模式与指南 177
更多信息 178
第29章  数据一致性指南 179
管理数据一致性 179
最终一致性实现的注意事项 182
相关模式与指南 185
第30章  数据分区指南 186
为什么需要数据分区 186
分区策略 187
设计可扩展性的数据分区 190
设计分区以提升查询性能 191
分区可用性设计 192
问题与思考 192
相关模式与指南 194
更多信息 194
第31章  数据复制与同步指南 195
为什么要数据复制及同步 195
复制和同步数据 195
数据复制和同步的注意事项 198
实现同步 200
相关模式与指南 201
更多信息 201
第32章  远程监控指南 202
为什么远程监控很重要 202
监控 202
语义日志记录 204
遥测 205
远程监控的注意事项 205
相关模式与指南 207
更多信息 208
第33章  多数据中心部署指南 209
为什么部署到多个数据中心 209
多数据中心部署的思考 213
相关模式及指南 217
第34章  服务调用统计指南 218
为什么服务调用统计很重要 218
服务调用统计的场景 218
服务调用统计的注意事项 220
示例 221
相关模式及指南 222
更多信息 222
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算架构设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Swift设计模式
第一部分　准备工作
第1章　设计模式　　2
1.1　将设计模式置于上下文中　　2
1.1.1　设计模式简介　　3
1.1.2　设计模式的结构　　3
1.1.3　量化设计模式　　4
1.1.4　问题出现之后使用设计模式　　4
1.1.5　设计模式的局限　　5
1.2　关于本书　　5
1.2.1　读者需要哪些知识背景　　5
1.2.2　读者需要哪些软件　　5
1.2.3　本书的结构　　6
1.2.4　获取示例代码　　6
1.3　总结　　6
第2章　熟悉Xcode的使用　　7
2.1　使用Xcode Playground　　7
2.1.1　创建Playground　　7
2.1.2　查看变量取值的历史记录　　9
2.1.3　使用取值时间轴　　11
2.1.4　在Playground中使用UI组件　　13
2.2　使用OS X命令行工具项目　　14
2.2.1　创建命令行工具项目　　14
2.2.2　Xcode的布局　　15
2.2.3　新建一个Swift文件　　16
2.3　总结　　19
第3章　开发SportsStore应用　　20
3.1　创建一个简单的iOS应用项目　　20
3.1.1　新建项目　　21
3.1.2　熟悉Xcode的布局　　22
3.1.3　定义数据　　23
3.2　构建简单的布局　　25
3.2.1　添加基本组件　　26
3.2.2　配置Auto Layout　　28
3.2.3　测试布局效果　　29
3.3　实现与显示库存总量的Label相关的代码　　30
3.3.1　创建引用　　30
3.3.2　更新界面显示　　31
3.4　实现table cell　　32
3.4.1　配置自定义table cell和布局　　32
3.4.2　配置table cell的布局约束　　34
3.4.3　创建table cell类和Outlet　　34
3.4.4　实现数据源协议　　36
3.4.5　注册数据源　　37
3.4.6　测试数据源　　38
3.5　处理编辑操作　　38
3.6　测试SportsStore应用　　41
3.7　总结　　42
第二部分　创建型模式
第4章　对象模板模式　　44
4.1　准备示例项目　　44
4.2　此模式旨在解决的问题　　45
4.3　对象模板模式　　47
4.4　实现对象模板模式　　48
4.5　对象模板模式的优点　　49
4.5.1　解耦的好处　　49
4.5.2　封装的优点　　50
4.5.3　不断演化外部呈现的好处　　52
4.6　对象模板模式的陷阱　　54
4.7　Cocoa中使用对象模板模式的示例　　54
4.8　在SportsStore应用中使用对象模板模式　　54
4.8.1　准备示例应用　　54
4.8.2　创建Product类　　56
4.8.3　使用Product类　　58
4.8.4　扩展应用的总结信息　　60
4.9　总结　　61
第5章　原型模式　　62
5.1　此模式旨在解决的问题　　62
5.1.1　初始化过程开销大　　62
5.1.2　对模板的依赖　　64
5.2　原型模式　　65
5.3　实现原型模式　　65
5.3.1　克隆引用类型　　67
5.3.2　浅复制与深复制　　70
5.3.3　复制数组　　73
5.4　原型模式的优点　　75
5.4.1　避免内存开销大的初始化操作　　75
5.4.2　分离对象的创建与使用　　77
5.5　原型模式的陷阱　　83
5.5.1　陷阱一：深复制与浅复制　　83
5.5.2　陷阱二：扭曲代码结构　　83
5.5.3　陷阱三：不标准的协议　　83
5.6　Cocoa中使用原型模式的实例　　83
5.6.1　使用Cocoa数组　　84
5.6.2　使用NSCopying属性修饰符　　86
5.7　在SportsStore应用中使用原型模式　　87
5.7.1　准备示例应用　　87
5.7.2　在Product类中实现NSCopying协议　　87
5.7.3　创建Logger类　　88
5.7.4　在View Controller中输出修改日志　　89
5.7.5　测试修改　　91
5.8　总结　　91
第6章　单例模式　　92
6.1　准备示例项目　　92
6.2　此模式旨在解决的问题　　92
6.3　单例模式　　96
6.4　实现单例模式　　96
6.4.1　快速实现单例模式　　96
6.4.2　创建一个传统的单例实现　　98
6.4.3　处理并发　　100
6.5　单例模式的陷阱　　104
6.5.1　泄露缺陷　　104
6.5.2　代码文件共享带来的问题　　105
6.5.3　并发陷阱　　105
6.6　Cocoa中使用单例模式的实例　　106
6.7　在SportsStore应用中使用单例模式　　106
6.7.1　保护数据数组　　107
6.7.2　保护回调　　108
6.7.3　定义单例　　109
6.8　总结　　111
第7章　对象池模式　　112
7.1　准备示例项目　　112
7.2　此模式旨在解决的问题　　113
7.3　对象池模式　　113
7.4　实现对象池模式　　114
7.4.1　定义Pool类　　114
7.4.2　使用Pool类　　118
7.5　对象池模式的陷阱　　121
7.6　Cocoa中使用对象池模式的实例　　121
7.7　在SportsStore应用中使用对象池模式　　122
7.7.1　准备示例应用　　122
7.7.2　创建一个（伪）服务器　　122
7.7.3　创建对象池　　123
7.7.4　应用对象池模式　　124
7.8　总结　　127
第8章　对象池模式的变体　　128
8.1　准备示例项目　　128
8.2　对象池模式的变体　　128
8.2.1　对象创建策略　　129
8.2.2　对象复用策略　　132
8.2.3　空池策略　　136
8.2.4　对象分配策略　　146
8.3　对象池模式变体的陷阱　　148
8.3.1　期望与现实之间的差距　　149
8.3.2　过度利用与低利用率　　149
8.4　Cocoa中使用对象池模式变体的示例　　149
8.5　在SportsStore应用中使用对象池模式变体　　149
8.6　总结　　151
第9章　工厂方法模式　　152
9.1　准备示例项目　　152
9.2　此模式旨在解决的问题　　154
9.3　工厂方法模式　　156
9.4　实现工厂方法模式　　156
9.4.1　定义全局工厂方法　　157
9.4.2　使用基类　　158
9.5　工厂方法模式的变体　　162
9.6　工厂方法模式的陷阱　　164
9.7　Cocoa中使用工厂方法模式的示例　　164
9.8　在SportsStore应用中使用工厂方法模式　　164
9.8.1　准备示例应用　　164
9.8.2　实现工厂方法模式　　166
9.8.3　应用工厂方法模式　　167
9.9　总结　　168
第10章　抽象工厂模式　　169
10.1　准备示例项目　　169
10.2　此模式旨在解决的问题　　172
10.3　抽象工厂模式　　172
10.4　实现抽象工厂模式　　174
10.4.1　创建抽象工厂类　　174
10.4.2　创建具体工厂类　　174
10.4.3　完善抽象工厂类　　175
10.4.4　使用抽象工厂模式　　176
10.5　抽象工厂模式的变体　　177
10.5.1　隐藏抽象工厂类　　177
10.5.2　在具体工厂类中使用单例模式　　178
10.5.3　在实现类中使用原型模式　　180
10.6　抽象工厂模式的陷阱　　185
10.7　Cocoa中使用抽象工厂模式的示例　　185
10.8　在SportsStore应用中使用抽象工厂模式　　186
10.8.1　准备示例应用　　186
10.8.2　定义实现类和协议　　186
10.8.3　定义抽象与具体工厂类　　187
10.8.4　使用工厂与实现类　　188
10.9　总结　　189
第11章　建造者模式　　190
11.1　准备示例项目　　190
11.2　建造者模式　　194
11.3　实现建造者模式　　195
11.3.1　定义建造者类　　195
11.3.2　使用建造者类　　196
11.3.3　此模式的影响　　196
11.4　建造者模式的变体　　200
11.5　建造者模式的陷阱　　202
11.6　Cocoa中使用建造者模式的实例　　202
11.7　在SportsStore应用中使用建造者模式　　203
11.7.1　准备示例应用　　203
11.7.2　定义建造者类　　203
11.7.3　使用建造者类　　204
11.8　总结　　205
第三部分　结构型模式
第12章　适配器模式　　208
12.1　准备示例项目　　208
12.1.1　创建数据源　　209
12.1.2　实现示例应用　　210
12.2　此模式旨在解决的问题　　211
12.3　适配器模式　　212
12.4　实现适配器模式　　213
12.5　适配器模式之变体　　215
12.5.1　定义一个适配器包装类　　215
12.5.2　创建一个双向适配器　　216
12.6　适配器模式的缺陷　　219
12.7　Cocoa中使用适配器模式的实例　　219
12.8　在SportsStore应用中使用适配器模式　　219
12.8.1　准备示例应用　　220
12.8.2　定义Adapter类　　220
12.8.3　使用适配功能　　221
12.9　总结　　222
第13章　桥接模式　　223
13.1　准备示例项目　　223
13.2　此模式旨在解决的问题　　225
13.3　桥接模式　　226
13.4　实现桥接模式　　228
13.4.1　实现信息部分　　228
13.4.2　实现通道部分　　229
13.4.3　创建桥接类　　229
13.4.4　增加信息类型与通道类型　　230
13.5　桥接模式的变体　　233
13.6　桥接模式的陷阱　　237
13.7　Cocoa中使用桥接模式的实例　　237
13.8　在SportsStore应用中使用此模式　　237
13.8.1　准备示例应用　　237
13.8.2　理解待解决的问题　　237
13.8.3　定义桥接类　　238
13.9　总结　　239
第14章　装饰器模式　　240
14.1　准备示例项目　　240
14.2　此模式旨在解决的问题　　242
14.3　装饰器模式　　244
14.4　实现装饰器模式　　244
14.5　装饰器模式的变体　　246
14.5.1　创建具有新功能的装饰器　　246
14.5.2　合并多个装饰器　　249
14.6　装饰器模式的陷阱　　251
14.7　Cocoa中使用装饰器模式的实例　　251
14.8　在示例项目中使用装饰器模式　　251
14.8.1　准备示例应用　　252
14.8.2　创建装饰器　　252
14.8.3　使用装饰器　　253
14.9　总结　　253
第15章　组合模式　　254
15.1　准备示例项目　　254
15.2　此模式旨在解决的问题　　256
15.3　组合模式　　257
15.4　实现组合模式　　257
15.5　组合模式的陷阱　　260
15.6　Cocoa中使用组合模式的实例　　261
15.7　在SportsStore应用中使用此模式　　261
15.7.1　准备示例应用　　261
15.7.2　定义组合类　　262
15.7.3　使用此模式　　263
15.8　总结　　264
第16章　外观模式　　265
16.1　准备示例项目　　265
16.2　此模式旨在解决的问题　　267
16.3　外观模式　　268
16.4　实现外观模式　　269
16.5　外观模式之变体　　270
16.6　外观模式的陷阱　　271
16.7　Cocoa中使用外观模式的实例　　272
16.8　在SportsStore应用中使用外观模式　　273
16.8.1　准备示例应用　　273
16.8.2　创建外观类　　274
16.8.3　使用外观类　　274
16.9　总结　　275
第17章　享元模式　　276
17.1　准备示例项目　　276
17.2　此模式旨在解决的问题　　278
17.3　享元模式　　278
17.4　实现享元模式　　279
17.4.1　创建Flyweight协议　　279
17.4.2　创建FlyweightImplementation类　　280
17.4.3　增加并发保护　　281
17.4.4　创建FlyweightFactory类　　282
17.4.5　应用享元模式　　284
17.5　享元模式之变体　　285
17.6　享元模式的陷阱　　286
17.6.1　陷阱一：重复的外部数据　　286
17.6.2　陷阱二：可变的外部数据　　287
17.6.3　陷阱三：并发访问　　287
17.6.4　陷阱四：过度优化　　287
17.6.5　陷阱五：误用　　287
17.7　Cocoa中使用享元模式的实例　　287
17.8　在SportsStore应用中使用享元模式　　288
17.8.1　准备示例应用　　289
17.8.2　创建Flyweight协议和实现类　　289
17.8.3　创建享元工厂　　289
17.8.4　应用享元模式　　290
17.9　总结　　290
第18章　代理模式　　291
18.1　准备示例项目　　291
18.2　此模式旨在解决的问题　　292
18.2.1　远程对象问题　　292
18.2.2　开销大的问题　　292
18.2.3　访问控制问题　　293
18.3　代理模式　　293
18.3.1　解决远程对象问题　　293
18.3.2　解决操作开销大的问题　　294
18.3.3　解决访问限制问题　　294
18.4　实现代理模式　　295
18.4.1　实现远程对象代理　　295
18.4.2　实现开销大的操作的代理　　297
18.4.3　实现访问限制代理　　299
18.5　代理模式之变体　　302
18.6　代理模式的陷阱　　305
18.7　Cocoa中使用代理模式的实例　　306
18.8　在SportsStore应用中使用代理模式　　306
18.8.1　准备示例应用　　306
18.8.2　定义协议、工厂方法和代理类　　306
18.8.3　更新ProductDataStore类　　307
18.8.4　发送库存更新　　308
18.9　总结　　310
第四部分　行为型模式
第19章　责任链模式　　312
19.1　准备示例项目　　312
19.2　此模式旨在解决的问题　　314
19.3　责任链模式　　315
19.4　实现责任链模式　　315
19.4.1　创建并使用责任链　　317
19.4.2　使用责任链模式　　318
19.5　责任链模式之变体　　318
19.5.1　使用工厂方法模式　　318
19.5.2　责任链响应反馈　　319
19.5.3　通知责任链中的其他链　　321
19.6　此模式的陷阱　　323
19.7　Cocoa中使用责任链模式的实例　　323
19.8　在SportsStore应用中使用责任链模式　　323
19.8.1　准备示例应用　　323
19.8.2　定义责任链及其链　　323
19.9　总结　　325
第20章　命令模式　　326
20.1　准备示例项目　　326
20.2　此模式旨在解决的问题　　327
20.3　命令模式　　328
20.4　实现命令模式　　328
20.4.1　定义Command协议　　329
20.4.2　定义Command实现类　　329
20.4.3　使用命令模式　　330
20.4.4　添加并发保护　　332
20.4.5　使用撤销操作的功能　　333
20.5　命令模式之变体　　333
20.5.1　创建复合命令　　334
20.5.2　将命令当作宏来用　　335
20.5.3　将闭包作为命令　　337
20.6　命令模式的陷阱　　339
20.7　Cocoa中使用命令模式的实例　　339
20.8　在SportsStore应用中使用命令模式　　340
20.8.1　准备示例项目　　340
20.8.2　实现撤销功能　　340
20.9　总结　　343
第21章　中介者模式　　344
21.1　准备示例项目　　344
21.2　此模式旨在解决的问题　　346
21.3　中介者模式　　348
21.4　实现中介者模式　　348
21.4.1　定义Meditator类　　349
21.4.2　遵循Peer协议　　349
21.4.3　实现并发保护　　351
21.5　中介者模式之变体　　353
21.5.1　将更多的逻辑置于中介者中　　353
21.5.2　通用化中介者与其管理的对象之间的关系　　355
21.6　中介者模式的陷阱　　360
21.7　Cocoa中使用中介者模式的实例　　361
21.8　在SportsStore应用中使用中介者模式　　363
21.9　总结　　363
第22章　观察者模式　　364
22.1　准备示例项目　　364
22.2　此模式旨在解决的问题　　366
22.3　观察者模式　　366
22.4　实现观察者模式　　367
22.4.1　创建SubjectBase类　　368
22.4.2　遵循Subject协议　　369
22.4.3　遵循Observer协议　　369
22.4.4　使用观察者模式　　370
22.5　观察者模式之变体　　371
22.5.1　通知的通用化　　371
22.5.2　使用弱引用　　375
22.5.3　处理生命周期较短的主题对象　　376
22.6　观察者模式的陷阱　　379
22.7　Cocoa中使用观察者模式的实例　　379
22.7.1　用户界面事件　　379
22.7.2　观察属性变化　　380
22.8　在SportsStore应用中使用此模式　　381
22.8.1　准备示例应用　　381
22.8.2　应用观察者模式　　381
22.9　总结　　383
第23章　备忘录模式　　384
23.1　准备示例项目　　384
23.2　此模式旨在解决的问题　　386
23.3　备忘录模式　　387
23.4　实现备忘录模式　　388
23.4.1　实现Memento类　　388
23.4.2　使用备忘录对象　　390
23.5　备忘录模式之变体　　390
23.6　备忘录模式的陷阱　　392
23.7　Cocoa中使用备忘录模式的实例　　393
23.8　在SportsStore中使用备忘录模式　　396
23.8.1　准备示例项目　　396
23.8.2　实现备忘录模式　　396
23.9　总结　　398
第24章　策略模式　　399
24.1　准备示例项目　　399
24.2　此模式旨在解决的问题　　400
24.3　策略模式　　401
24.4　实现策略模式　　402
24.4.1　定义策略和环境类　　402
24.4.2　使用策略模式　　403
24.5　策略模式之变体　　404
24.6　策略模式的陷阱　　405
24.7　Cocoa中使用策略模式的实例　　405
24.7.1　Cocoa框架中基于协议的策略　　405
24.7.2　Cocoa中基于选择器的策略　　406
24.8　在SportsStore应用中使用策略模式　　407
24.9　总结　　407
第25章　访问者模式　　408
25.1　准备示例项目　　408
25.2　此模式旨在解决的问题　　410
25.3　访问者模式　　412
25.4　实现访问者模式　　412
25.4.1　遵循Shape协议　　414
25.4.2　创建访问者　　416
25.4.3　使用访问者　　416
25.5　访问者模式之变体　　417
25.6　访问模式的陷阱　　417
25.7　Cocoa中使用访问者模式的实例　　417
25.8　在SportsStore应用中使用访问者模式　　417
25.9　总结　　417
第26章　模板方法模式　　418
26.1　准备示例项目　　418
26.2　此模式旨在解决的问题　　420
26.3　模板方法模式　　420
26.4　实现模板方法模式　　420
26.5　模板方法模式之变体　　422
26.6　模板方法模式的陷阱　　424
26.7　Cocoa中使用模板方法模式的实例　　424
26.8　在SportsStore应用中使用模板方法模式　　424
26.9　总结　　424
第五部分　MVC模式
第27章　MVC模式　　426
27.1　准备示例项目　　426
27.2　此模式旨在解决的问题　　426
27.3　MVC模式　　426
27.4　实现MVC模式　　430
27.4.1　实现通用的代码　　431
27.4.2　定义一个框架　　432
27.4.3　创建模型　　433
27.4.4　实现视图　　435
27.4.5　定义控制器　　436
27.4.6　完善框架　　439
27.4.7　运行应用　　439
27.4.8　扩展应用　　440
27.5　MVC模式之变体　　444
27.6　MVC模式的陷阱　　444
27.7　Cocoa中使用MVC模式的实例　　444
27.8　总结　　444
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Swift设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式精解及面试攻略
译者序
前言
致谢
第1章　概述	1
1.1　全书概览	1
1.2　设计模式简史	2
1.3　本书读者对象	2
1.4　本书对面试的帮助	3
1.5　如何阅读本书	3
1.6　本书主要内容	3
1.7　源代码免责声明	4
1.8　本书中使用的工具	4
第2章　UML基础	5
2.1　什么是UML	5
2.2　为什么使用UML	5
2.3　UML符号	6
2.4　面向对象概念	6
2.5　面向对象的分析与设计	8
2.6　UML构造块和符号	9
2.7　事物	9
2.8　关系	15
2.9　UML图	19
第3章　设计模式简介	28
3.1　什么是设计模式	28
3.2　设计模式简史	28
3.3　设计模式的作用	29
3.4　设计模式的分类	29
3.5　学习设计模式所需注意的问题	30
3.6　使用模式并积累设计经验	31
3.7　恰当使用设计模式	31
3.8　设计模式与软件框架	32
第4章　创造型模式	33
4.1　创造型模式	33
4.2　创造型模式的分类	33
4.3　工厂方法模式	34
4.4　抽象工厂模式	38
4.5　生成器模式	42
4.6　单例模式	49
4.7　原型模式	53
第5章　结构型模式	59
5.1　结构型模式	59
5.2　结构型模式的分类	59
5.3　适配器模式	60
5.4　桥接模式	66
5.5　组合模式	69
5.6　装饰模式	75
5.7　门面模式	81
5.8　代理模式	87
5.9　享元模式	90
第6章　行为型模式	97
6.1　行为型模式	97
6.2　行为型模式的类型	97
6.3　职责链模式	98
6.4　命令模式	104
6.5　解释器模式	109
6.6　迭代器模式	112
6.7　中介者模式	118
6.8　备忘录模式	124
6.9　观察者模式	128
6.10　状态模式	133
6.11　策略模式	136
6.12　模板方法模式	139
6.13　访问者模式	142
第7章　概念与提示	147
7.1　什么是反面模式	147
7.2　代码重构	147
7.3　提示	148
第8章　设计模式面试问题	150
8.1　设计模式面试问题	150
8.2　设计问题举例	228
第9章　其他概念	231
参考文献	247
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式精解及面试攻略
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大話設計模式
第01章　程式碼無錯就是優？—簡單工廠模式
第02章　商場促銷—策略模式
第03章　拍攝UFO—單一職責原則
第04章　升學求職兩不誤—開放-封閉原則
第05章　會修電腦不會修收音機？—依賴倒轉原則
第06章　穿什麼有這麼重要？—裝飾模式
第07章　為他人做嫁衣—代理模式
第08章　南丁格爾依然在人間—工廠方法模式
第09章　履歷影印—原型模式
第10章　考題抄錯會做也白搭—範本方法模式
第11章　無熟人難辦事？—迪米特法則
第12章　多頭市場股票還會虧錢？—外觀模式
第13章　好菜每回味不同—建造者模式
第14章　老闆回來，我不知道—觀察者模式
第15章　就不能不換嗎？—抽象工廠模式
第16章　無盡加班何時休—狀態模式
第17章　在NBA我需要翻譯—轉接器模式
第18章　如果再回到從前—備忘錄模式
第19章　分公司=一部門—組合模式
第20章　想走？可以！先買票—迭代器模式
第21章　有些類別也需計畫生育—獨體模式
第22章　手機軟體何時統一—橋接模式
第23章　烤羊肉串引來的思考—命令模式
第24章　加薪非要老總批？—職責鏈模式
第25章　世界需要和平—仲介者模式
第26章　專案多也別傻傻做—享元模式
第27章　其實你不懂老闆的心—解譯器模式
第28章　男人和女人—訪問者模式
第29章　OOTV杯超級模式大賽—模式總結
附 錄A　訓練實習生—物件導向基礎
附 錄B　參考文獻
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大話設計模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>J2EE设计模式
前言 
第一章  Java企业设计 
第二章  统一建模语言 
第三章  表达层体系结构 
第四章  高级表达层设计 
第五章  表达层可伸缩性 
第六章  业务层 
第七章  层通信 
第八章  数据库和数据模式 
第九章  业务层接口
第十章  企业并发
第十一章  消息通信
第十二章  J2EE反模式
附录一  表达层模式
附录二  业务层模式
附录三  消息通信模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>J2EE设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算设计模式
出版者的话
本书赞誉
译者序
致谢
第1章导言
1.1本书的目标
1.2本书所不包含的内容
1.3本书的读者
1.4本书的起源
1.5推荐阅读
1.6本书的组织方式
第2章理解设计模式
2.1关于模式档案
2.2关于复合模式
2.3设计模式应用衡量
2.4本书的使用
第3章共享、伸缩性和弹性模式
3.1共享资源
3.2工作负载分布
3.3动态可伸缩性
3.4服务负载平衡
3.5弹性资源容量
3.6弹性网络容量
3.7弹性磁盘配给
3.8负载平衡虚拟服务器实例
3.9负载平衡虚拟交换机
3.10服务状态管理
3.11存储工作负载管理
3.12动态数据规范化
3.13跨存储设备垂直分层
3.14存储设备内垂直数据分层
3.15内存过度分配
3.16网卡（NIC）聚合
3.17广泛访问
第4章可靠性、适应性和恢复模式
4.1资源池化
4.2资源保留
4.3虚拟化管理器群集
4.4冗余存储
4.5动态故障检测与恢复
4.6多路径资源访问
4.7为虚拟服务器建立冗余物理连接
4.8同步操作状态
4.9零停机时间
4.10存储维护窗口
4.11虚拟服务器自动崩溃恢复
4.12非破坏性服务重定位
第5章数据管理和存储设备模式
5.1直接I／O访问
5.2直接LUN访问
5.3单根I／O虚拟化
5.4云存储静态数据加密
5.5云存储数据生命期管理
5.6云存储数据管理
5.7云存储数据放置依从性检查
5.8云存储设备屏蔽
5.9云存储设备路径屏蔽
5.10云存储设备性能实施
5.11虚拟磁盘拆分
5.12子LUN分层
5.13基于RAID的数据放置
5.14lP存储隔离
第6章虚拟服务器和虚拟化管理器
连接性及管理模式
6.1虚拟服务器文件夹迁移
6.2持久化虚拟网络配置
6.3虚拟服务器连接性隔离
6.4虚拟交换机隔离
6.5虚拟服务器NAT连接性
6.6外部虚拟服务器可访问性
6.7跨虚拟化管理器工作负载
可移动性
6.8虚拟服务器—主机亲和性
6.9虚拟服务器—主机反亲和性
6.10虚拟服务器—主机连接性
6.11虚拟服务器间亲和性
6.12虚拟服务器间反亲和性
6.13无状态虚拟化管理器
第7章监控、配给和管理模式
7.1使用量监控
7.2现收现付
7.3实时资源可用性
7.4快速配给
7.5平台配给
7.6裸机配给
7.7自动管理
7.8集中远程管理
7.9资源管理
7.10自助配给
7.11电源消耗缩减
第8章云服务和存储安全性模式
8.1可信平台BIOS
8.2地理标签
8.3虚拟化管理器保护
8.4云VM平台加密
8.5可信云资源池
8.6安全云接口和API
8.7云资源访问控制
8.8用户安装VM安全问题的检测与缓解
8.9移动自带设备（BYOD）安全性
8.10云数据泄露保护
8.11永久性数据丢失保护
8.12传输中的云数据加密
第9章网络安全性、身份和访问管理及信任保证模式
9.1安全场内互联网访问
9.2安全外部云连接
9.3伸缩VM的安全连接
9.4云拒绝服务保护
9.5云流量劫持保护
9.6自动定义边界
9.7云身份验证网关
9.8联合云身份验证
9.9云密钥管理
9.10信任鉴证服务
9.11协作监控与日志记录
9.12独立云审计
9.13威胁情报处理
第10章常见复合模式
10.1私有云
10.2公共云
10.3软件即服务（SaaS）
10.4平台即服务（PaaS）
10.5基础设施即服务（IaaS）
10.6弹性环境
10.7多租户环境
10.8适应性环境
10.9云爆发
10.10向外爆发到私有云
10.11向外爆发到公共云
10.12向内爆发
10.13安全向外爆发到私有云／公共云
10.14云平衡
10.15云身份验证
10.16资源工作负载管理
10.17隔离信任边界
附录A云计算机制词汇表
附录B按字母顺序排列的设计模式
参考
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Token经济设计模式
赞誉
推荐序一
推荐序二
推荐序三
推荐序四
前言
第1章　产业区块链001
第1节　区块链的通俗解释001
第2节　通用术语002
第3节　产业区块链012
第4节　产业供应链金融018
第2章　Token必要性评估023
第1节　产业区块链的Token经济023
第2节　传统产业进行Token设计的12个必要条件024
第3节　传统产业进行Token设计的必要性评估025
第3章　Token设计方法论033
第1节　Token的分类034
第2节　Token设计的10个前提039
第3节　Token设计的12个自检问题042
第4节　Token模式画布042
第5节　设计方法054
如何使用模式画布054
头脑风暴创新方法055
第4章　Token的十大设计模式061
第1节　货币模式062
思考：数字法币与加密代币之间的差异求同062
概要定义066
业务模式067
设计068
要素070
Token案例071
第2节　溯源模式073
思考：从农产品溯源来看资产上链和数字可信073
概要定义078
业务模式079
设计080
要素082
Token案例083
第3节　积分模式087
思考：积分币会是会员和积分的未来吗？087
概要定义098
业务模式099
设计101
要素104
Token案例105
第4节　矿机模式110
思考：从各种XX星球XX宝来看软硬皆施的区块链矿机111
概要定义113
业务模式114
设计115
要素118
Token案例118
第5节　资产模式122
思考：数字加密资产化的金融产品设计123
概要定义127
业务模式128
设计129
要素132
Token案例132
第6节　数据模式139
思考：从小米的米链来看个人数据的货币化139
概要定义143
业务模式144
设计145
要素149
Token案例149
第7节　内容模式155
思考：从内容币来看创作者如何翻身当家做主人155
概要定义157
业务模式158
设计159
要素162
Token案例163
第8节　服务模式169
思考：从养老产业区块链来看分布式服务的区块链模式设计170
概要定义173
业务模式174
设计175
要素179
Token案例179
第9节　粉丝模式184
思考：从TFBOYS饭票来看如何养明星184
概要定义188
业务模式188
设计190
要素193
Token案例193
第10节　储存模式198
思考：如何让共享车成为岁月的分布式存储链？198
概要定义200
业务模式201
设计201
模式运营203
要素204
Token案例204
第11节　特殊模式207
场景207
功能209
Token案例212
交易平台213
第5章　Token的实现模式217
第1节　Token标准协议217
ERC-20协议218
ERC-721协议219
ERC-20和ERC-721的对比220
第2节　Token金融221
第3节　Token治理223
第4节　Token原则226
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Token经济设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实用软件设计模式教程(第2版)
第1章面向对象基础
1.1面向对象方法
1.1.1面向对象方法的特点
1.1.2面向对象方法的基本概念
1.1.3面向对象语言的产生
1.1.4面向对象的优势
1.2面向对象分析
1.2.1概论
1.2.2需求陈述
1.2.3建立对象模型
1.2.4建立动态模型
1.2.5建立功能模型
1.3面向对象设计
1.3.1面向对象设计的准则
1.3.2问题域部分设计
1.3.3人机交互部分设计
1.3.4数据管理部分设计
1.4面向对象编程实现
1.4.1编程语言的选择
1.4.2面向对象程序设计风格
1.5面向对象的测试
1.5.1面向对象测试概述
1.5.2面向对象测试策略
1.5.3设计测试用例
1.6面向对象软件设计原则
1.6.1开放封闭原则
1.6.2单一职责原则
1.6.3里氏代换原则
1.6.4依赖倒转原则
1.6.5接口隔离原则
1.6.6迪米特法则
1.6.7其他原则
本章小结
习题
参考文献
第2章C#面向对象编程基础
2.1类
2.1.1类的字段
2.1.2类的属性
2.1.3类的方法
2.1.4构造函数和析构函数
2.2继承
2.3抽象类
2.4接口
2.5多态
2.5.1虚函数
2.5.2多态
本章小结
习题
参考文献
第3章设计模式
3.1设计模式基础
3.1.1设计模式概念
3.1.2设计模式的基本要素
3.1.3怎样使用设计模式
3.1.4设计模式的类型
3.2创建型模式
3.2.1简单工厂模式
3.2.2工厂方法模式
3.2.3抽象工厂模式
3.2.4建造者模式
3.2.5单件模式
3.2.6原型模式
3.3结构型模式
3.3.1适配器模式
3.3.2装饰模式
3.3.3桥接模式
3.3.4享元模式
3.3.5外观模式
3.3.6代理模式
3.3.7组合模式
3.4行为型模式
3.4.1模板方法模式
3.4.2观察者模式
3.4.3迭代器模式
3.4.4责任链模式
3.4.5备忘录模式
3.4.6命令模式
3.4.7状态模式
3.4.8访问者模式
3.4.9中介者模式
3.4.10策略模式
3.4.11解释器模式
本章小结
习题
参考文献
第4章综合实例——武侯预伏锦囊计
4.1问题描述
4.2需求分析
4.3系统类结构
4.4各主要操作的活动图
4.5设计中采用的主要设计模式
4.6程序代码
参考文献
第5章软件架构与架构建模技术
5.1软件架构概况
5.1.1软件架构的发展史
5.1.2软件架构的定义
5.2客户机／服务器模式
5.2.1传统两层客户机／服务器模式
5.2.2经典三层客户机／服务器模式
5.3浏览器／服务器模式
5.4MVC架构模式
5.4.1MVC结构
5.4.2MVC的特点
5.5基于构件的模式
5.6软件架构建模技术
5.6.1软件架构“4+1”视图模型
5.6.2“4+1”视图模型建模方法
5.6.3软件架构建模的迭代过程
本章小结
习题
参考文献
第6章面向服务的软件架构——SOA
6.1SOA简介
6.1.1SOA参考模型
6.1.2SOA的设计原则
6.1.3SOA实现的主要技术规范
6.2SOA的框架
6.2.1以服务消费者为中心的SOA
6.2.2以用户为中心的SOA
6.3SOA实例——基于SOA的OA与ERP整合应用
6.4SOA的应用分析
本章小结
习题
参考文献
第7章云计算环境下的软件架构
7.1软件三层架构模型
7.1.1三层软件架构产生的原因
7.1.2三层软件架构介绍
7.1.3三层架构存在的问题
7.2基于云计算的软件架构
本章小结
习题
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实用软件设计模式教程(第2版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java设计模式及应用案例(第2版)
第1章 设计模式概述 1
1.1 设计模式简介 2
1.2 预备知识 2
1.2.1 接口和抽象类 2
1.2.2 反射 4
模式实践练习 10
第2章 单例模式 11
2.1 问题的提出 12
2.2 单例模式 12
2.3 单例模式的实现方式 12
2.4 应用示例 14
模式实践练习 20
第3章 工厂模式 21
3.1 关键角色 22
3.2 简单工厂 23
3.2.1 代码示例 23
3.2.2 代码分析 24
3.2.3 语义分析 24
3.3 工厂 25
3.3.1 代码示例 25
3.3.2 代码分析 26
3.4 抽象工厂 27
3.4.1 代码示例 28
3.4.2 代码分析 29
3.4.3 典型模型语义分析 29
3.4.4 其他情况 29
3.5 应用示例 32
3.6 自动选择工厂 37
模式实践练习 38
第4章 生成器模式 39
4.1 问题的提出 40
4.2 生成器模式 41
4.3 深入理解生成器模式 44
4.4 应用示例 46
模式实践练习 58
第5章 原型模式 59
5.1 问题的提出 60
5.2 原型模式 60
5.3 原型复制具体实现方法 61
5.3.1 利用构造函数方法 61
5.3.2 利用Cloneable接口方法 63
5.3.3 利用Serializable序列化接口方法 65
5.4 应用示例 67
模式实践练习 69
第6章 责任链模式 70
6.1 问题的提出 71
6.2 责任链设计模式 71
6.3 反射的作用 73
6.4 回调技术 75
模式实践练习 79
第7章 命令模式 80
7.1 问题的提出 81
7.2 命令模式 81
7.3 深入理解命令模式 83
7.3.1 命令集管理 83
7.3.2 加深命令接口定义的理解 85
7.3.3 命令模式与JDK事件处理 86
7.3.4 命令模式与多线程 90
7.4 应用示例 92
模式实践练习 99
第8章 迭代器模式 100
8.1 问题的提出 101
8.2 迭代器模式 103
8.3 应用示例 104
模式实践练习 109
第9章 访问者模式 110
9.1 问题的提出 111
9.2 访问者模式 111
9.3 深入理解访问者模式 113
9.4 应用示例 119
模式实践练习 128
第10章 中介者模式 129
10.1 问题的提出 130
10.2 中介者模式 130
10.3 应用示例 133
模式实践练习 139
第11章 备忘录模式 140
11.1 问题的提出 141
11.2 备忘录设计模式 143
11.3 应用示例 146
模式实践练习 151
第12章 观察者模式 152
12.1 问题的提出 153
12.2 观察者模式 153
12.3 深入理解观察者模式 155
12.4 JDK中的观察者设计模式 160
12.5 应用示例 163
模式实践练习 172
第13章 状态模式 173
13.1 问题的提出 174
13.2 状态模式 174
13.3 深入理解状态模式 175
13.4 应用示例 180
模式实践练习 191
第14章 策略模式 192
14.1 问题的提出 193
14.2 策略模式 193
14.3 深入理解Context 195
14.4 应用示例 198
模式实践练习 202
第15章 模板方法模式 203
15.1 问题的提出 204
15.2 方法模板 204
15.2.1 自定义方法模板 204
15.2.2 JDK方法模板 206
15.3 流程模板 208
15.4 应用示例 210
模式实践练习 213
第16章 解释器模式 214
16.1 问题的提出 215
16.2 解释器模式 215
16.2.1 文法规则和抽象语法树 215
16.2.2 解释器模式 216
16.3 应用示例 220
模式实践练习 224
第17章 享元模式 225
17.1 问题的提出 226
17.2 享元模式 226
17.3 系统中的享元模式 232
模式实践练习 234
第18章 适配器模式 235
18.1 问题的提出 236
18.2 适配器模式 236
18.2.1 对象适配器 236
18.2.2 类适配器 238
18.3 默认适配器 238
18.4 应用示例 240
模式实践练习 244
第19章 组合模式 246
19.1 问题的提出 247
19.2 组合模式 248
19.3 深入理解组合模式 250
19.3.1 其他常用操作 250
19.3.2 节点排序 252
19.4 应用示例 252
模式实践练习 264
第20章 代理模式 265
20.1 模式简介 266
20.2 虚拟代理 267
20.3 远程代理 272
20.3.1 RMI通信 272
20.3.2 RMI代理模拟 275
20.4 计数代理 277
20.4.1 动态代理的成因 279
20.4.2 自定义动态代理 279
20.4.3 JDK动态代理 282
模式实践练习 284
第21章 桥接模式 285
21.1 问题的提出 286
21.2 桥接模式 286
21.3 深入理解桥接模式 289
21.4 应用示例 292
模式实践练习 301
第22章 装饰器模式 302
22.1 问题的提出 303
22.2 装饰器模式 303
22.3 深入理解装饰器模式 305
22.3.1 具体构件角色的重要性 305
22.3.2 JDK中的装饰器模式 306
22.4 应用示例 309
模式实践练习 320
第23章 外观模式 321
23.1 问题的提出 322
23.2 外观模式 322
23.3 应用示例 323
模式实践练习 329
参考文献 330
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java设计模式及应用案例(第2版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件设计模式与体系结构
上篇 软件设计模式
第1章 软件设计模式概述
1.1 软件设计模式的由来
1.2 软件设计模式的概念及意义
1.3 软件设计模式与软件体系结构
1.4 软件设计模式的分类
第2章 创建型软件设计模式
2.1 工厂方法与抽象工厂模式
2.1.1 工厂方法应用场景
2.1.2 简单工厂方法模式
2.1.3 工厂方法模式
2.1.4 抽象工厂模式
2.1.5 关于工厂方法模式与抽象工厂模式的讨论
练习题与课下设计－编程作业1
2.2 生成器模式
2.2.1 生成器模式应用场景
2.2.2 生成器模式的概念与机制
2.2.3 生成器模式应用实例
2.2.4 工厂方法模式、抽象工厂模式与生成器模式的比较
课下设计－编程作业2
2.3 单例模式
2.3.1 单例模式的概念与机制
2.3.2 单例模式应用实例
2.3.3 多线程编程中的单例模式
练习题与课下设计－编程作业3
本章总结
第3章 结构型软件设计模式
3.1 组合模式
3.1.1 组合模式的应用场景
3.1.2 组合模式的概念与机制
3.1.3 组合模式应用实例
3.1.4 关于组合模式的讨论
练习题与课下设计－编程作业4
3.2 适配器模式
3.2.1 现实生活中的适配器
3.2.2 适配器模式的概念与机制
3.2.3 关于适配器模式的讨论
练习题与课下设计－编程作业5
3.3 外观模式
3.3.1 现实生活中的外观
3.3.2 外观模式的概念
3.3.3 使用外观模式进行设计的实例
3.3.4 关于外观模式的讨论
课下设计－编程作业6
3.4 桥接模式
3.4.1 桥接模式应用场景
3.4.2 桥接模式的概念与机制
3.4.3 桥接模式应用实例
3.4.4 关于桥接模式的讨论
练习题与课下设计－编程作业7
……
下篇 软件体系结构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件设计模式与体系结构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Android 源码设计模式解析与实战（第2版）
内容提要
前言
第二版自序
自序一
自序二
致谢
第1章 走向灵活软件之路——面向对象的六大原则
第2章 应用最广的模式——单例模式
第3章 自由扩展你的项目——Builder模式
第4章 使程序运行更高效——原型模式
第5章 应用最广泛的模式——工厂方法模式
第6章 创建型设计模式——抽象工厂模式
第7章 时势造英雄——策略模式
第8章 随遇而安——状态模式
第9章 使编程更有灵活性——责任链模式
第10章 化繁为简的翻译机——解释器模式
第11章 让程序畅通执行——命令模式
第12章 解决解耦的钥匙——观察者模式
第13章 编程中的“后悔药”——备忘录模式
第14章 解决问题的“第三者”——迭代器模式
第15章 抓住问题核心——模板方法模式
第16章 访问者模式
第17章 “和事佬”——中介者模式
第18章 编程好帮手——代理模式
第19章 物以类聚——组合模式
第20章 得心应手的“粘合剂”——适配器模式
第21章 装饰模式
第22章 对象共享，避免创建多对象——享元模式
第23章 统一编程接口——外观模式
第24章 连接两地的交通枢钮——桥接模式
第25章 MVC的介绍与实战
第26章 MVP应用架构模式
第27章 MVVM应用浅析
第28章 易混淆的设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Android 源码设计模式解析与实战（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Python设计模式（第2版）
第 1 章 工厂模式 1
1．1 工厂方法 2
1．1．1 现实生活中的例子 2
1．1．2 用例 2
1．1．3 工厂方法的实现 3
1．2 抽象工厂 9
1．2．1 现实生活中的例子 9
1．2．2 用例 9
1．2．3 抽象工厂模式的实现 10
1．3 小结 13
第 2 章 建造者模式 15
2．1 现实生活中的例子 16
2．2 用例 16
2．3 实现 19
2．4 小结 24
第 3 章 其他创建型模式 25
3．1 原型模式 25
3．1．1 现实生活中的例子 26
3．1．2 用例 26
3．1．3 实现 26
3．2 单例模式 29
3．2．1 现实生活中的例子 30
3．2．2 用例 30
3．2．3 实现 30
3．3 小结 33
第 4 章 适配器模式 35
4．1 现实生活中的例子 35
4．2 用例 36
4．3 实现 36
4．4 小结 38
第 5 章 装饰器模式 39
5．1 现实生活中的例子 39
5．2 用例 40
5．3 实现 40
5．4 小结 44
第 6 章 桥接模式 45
6．1 现实生活中的例子 45
6．2 用例 45
6．3 实现 46
6．4 小结 48
第 7 章 外观模式 49
7．1 现实生活中的例子 49
7．2 用例 50
7．3 实现 50
7．4 小结 54
第 8 章 其他结构型模式 55
8．1 享元模式 55
8．1．1 现实生活中的例子 56
8．1．2 用例 56
8．1．3 实现 57
8．2 MVC模式 61
8．2．1 现实生活中的例子 61
8．2．2 用例 62
8．2．3 实现 63
8．3 代理模式 66
8．3．1 现实生活中的例子 68
8．3．2 用例 68
8．3．3 实现 69
8．4 小结 72
第 9 章 职责链模式 73
9．1 现实生活中的例子 74
9．2 用例 75
9．3 实现 76
9．4 小结 80
第 10 章 命令模式 81
10．1 现实生活中的例子 81
10．2 用例 82
10．3 实现 82
10．4 小结 89
第 11 章 观察者模式 91
11．1 现实生活中的例子 91
11．2 用例 92
11．3 实现 92
11．4 小结 97
第 12 章 状态模式 99
12．1 现实生活中的例子 100
12．2 用例 100
12．3 实现 101
12．4 小结 106
第 13 章 其他行为型模式 109
13．1 解释器模式 110
13．1．1 现实生活中的例子 110
13．1．2 用例 110
13．1．3 实现 111
13．2 策略模式 116
13．2．1 现实生活中的例子 117
13．2．2 用例 117
13．2．3 实现 118
13．3 备忘录模式 121
13．3．1 现实生活中的例子 122
13．3．2 用例 122
13．3．3 实现 122
13．4 迭代器模式 125
13．4．1 现实生活中的例子 125
13．4．2 用例 126
13．4．3 实现 126
13．5 模板模式 129
13．5．1 现实生活中的例子 129
13．5．2 用例 129
13．5．3 实现 130
13．6 小结 132
第 14 章 响应式编程中的观察者模式 135
14．1 现实生活中的例子 136
14．1．1 用例 136
14．1．2 实现 136
14．2 小结 146
第 15 章 微服务与面向云的模式 147
15．1 微服务模式 147
15．1．1 现实生活中的例子 148
15．1．2 用例 148
15．1．3 实现 149
15．2 重试模式 153
15．2．1 现实生活中的例子 154
15．2．2 用例 154
15．2．3 实现 154
15．3 断路器模式 159
15．3．1 现实生活中的例子 159
15．3．2 用例 159
15．3．3 实现 160
15．4 旁路缓存模式 162
15．4．1 现实生活中的例子 162
15．4．2 用例 162
15．4．3 实现 162
15．5 节流模式 168
15．5．1 现实生活中的例子 168
15．5．2 用例 168
15．5．3 实现 169
15．6 小结 171
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Python设计模式（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程实战指南：设计模式篇（第2版）
第1章  Java多线程编程实战基础  1
1.1  无处不在的线程  1
1.2  线程的创建与运行  3
1.3  线程的状态与上下文切换  5
1.4  对线程的监视  8
1.5  原子性、内存可见性和重排序——重新认识synchronized
和volatile  11
1.6  多线程编程的优势和风险  13
1.7  多线程编程常用术语  14
第2章  设计模式简介  19
2.1  设计模式及其作用  19
2.2  多线程设计模式简介  22
2.3  设计模式的描述  23
第3章  Immutable Object（不可变对象）模式  25
3.1  Immutable Object模式简介  25
3.2  Immutable Object模式的架构  27
3.3  Immutable Object模式实战案例解析  29
3.4  Immutable Object模式的评价与实现考量  33
3.4.1  适用场景  33
3.4.2  对垃圾回收（Garbage Collection）的影响  34
3.4.3  使用等效或者近似的不可变对象  35
3.4.4  防御性复制  35
3.5  Immutable Object模式的可复用实现代码  35
3.6  Java标准库实例  35
3.7  相关模式  37
3.7.1  Thread Specific Storage模式（第10章）  37
3.7.2  Serial Thread Confinement模式（第11章）  37
3.8  参考资源  38
第4章  Guarded Suspension（保护性暂挂）模式  39
4.1  Guarded Suspension模式简介  39
4.2  Guarded Suspension模式的架构  39
4.3  Guarded Suspension模式实战案例解析  43
4.4  Guarded Suspension模式的评价与实现考量  50
4.4.1  内存可见性和锁泄漏（Lock Leak）  51
4.4.2  线程被过早地唤醒  52
4.4.3  嵌套监视器锁死  53
4.5  Guarded Suspension模式的可复用实现代码  56
4.6  Java标准库实例  56
4.7  相关模式  56
4.7.1  Promise模式（第6章）  57
4.7.2  Producer-Consumer模式（第7章）  57
4.8  参考资源  57
第5章  Two-phase Termination（两阶段终止）模式  58
5.1  Two-phase Termination模式简介  58
5.2  Two-phase Termination模式的架构  59
5.3  Two-phase Termination模式实战案例解析  61
5.4  Two-phase Termination模式的评价与实现考量  70
5.4.1  线程停止标志  71
5.4.2  生产者/消费者问题中的线程停止  71
5.4.3  隐藏而非暴露可停止线程  73
5.5  Two-phase Termination模式的可复用实现代码  73
5.6  Java标准库实例  73
5.7  相关模式  74
5.7.1  Producer-Consumer模式（第7章）  74
5.7.2  Master-Slave模式（第12章）  74
5.8  参考资源  74
第6章  Promise（承诺）模式  75
6.1  Promise模式简介  75
6.2  Promise模式的架构  75
6.3  Promise模式实战案例解析  78
6.4  Promise模式的评价与实现考量  81
6.4.1  异步方法的异常处理  82
6.4.2  轮询  82
6.4.3  异步任务的执行  83
6.5  Promise模式的可复用实现代码  84
6.6  Java标准库实例  85
6.7  相关模式  85
6.7.1  Guarded Suspension模式（第4章）  85
6.7.2  Active Object模式（第8章）  86
6.7.3  Master-Slave模式（第12章）  86
6.7.4  Factory Method（工厂方法）模式  86
6.8  参考资源  86
第7章  Producer-Consumer（生产者/消费者）模式  87
7.1  Producer-Consumer模式简介  87
7.2  Producer-Consumer模式的架构  87
7.3  Producer-Consumer模式实战案例解析  90
7.4  Producer-Consumer模式的评价与实现考量  93
7.4.1  产品的粒度  94
7.4.2  通道积压  94
7.4.3  非阻塞式反压与Reactive Streams规范  96
7.4.4  工作窃取算法  97
7.4.5  线程的停止  101
7.4.6  高性能、高可靠性的Producer-Consumer模式实现  101
7.5  Producer-Consumer模式的可复用实现代码  102
7.6  Java标准库实例  102
7.7  相关模式  102
7.7.1  Guarded Suspension模式（第4章）  102
7.7.2  Thread Pool模式（第9章）  103
7.8  参考资源  103
第8章  Active Object（主动对象）模式  104
8.1  Active Object模式简介  104
8.2  Active Object模式的架构  105
8.3  Active Object模式实战案例解析  108
8.4  Active Object模式的评价与实现考量  115
8.4.1  错误隔离  117
8.4.2  缓冲区监控  118
8.4.3  缓冲区饱和处理策略  118
8.4.4  Scheduler空闲工作者线程清理  119
8.5  Active Object模式的可复用实现代码  119
8.6  Java标准库实例  123
8.7  相关模式  123
8.7.1  Promise模式（第6章）  123
8.7.2  Producer-Consumer模式（第7章）  123
8.8  参考资源  124
第9章  Thread Pool（线程池）模式  125
9.1  Thread Pool模式简介  125
9.2  Thread Pool模式的架构  126
9.3  Thread Pool模式实战案例解析  128
9.4  Thread Pool模式的评价与实现考量  130
9.4.1  工作队列的选择  131
9.4.2  线程池大小调校  132
9.4.3  线程池监控  134
9.4.4  线程泄漏  135
9.4.5  可靠性与线程池饱和处理策略  135
9.4.6  死锁  138
9.4.7  线程池空闲线程清理  139
9.5  Thread Pool模式的可复用实现代码  140
9.6  Java标准库实例  140
9.7  相关模式  140
9.7.1  Two-phase Termination模式（第5章）  140
9.7.2  Promise模式（第6章）  141
9.7.3  Producer-Consumer模式（第7章）  141
9.8  参考资源  141
第10章  Thread Specific Storage（线程特有存储）模式  142
10.1  Thread Specific Storage模式简介  142
10.2  Thread Specific Storage模式的架构  144
10.3  Thread Specific Storage模式实战案例解析  146
10.4  Thread Specific Storage模式的评价与实现考量  149
10.4.1  在线程池环境下使用Thread Specific Storage模式  153
10.4.2  内存泄漏与伪内存泄漏  153
10.5  Thread Specific Storage模式的可复用实现代码  161
10.6  Java标准库实例  161
10.7  相关模式  162
10.7.1  Immutable Object模式（第3章）  162
10.7.2  Proxy（代理）模式  162
10.7.3  Singleton（单例）模式  162
10.8  参考资源  162
第11章  Serial Thread Confinement（串行线程封闭）模式  163
11.1  Serial Thread Confinement模式简介  163
11.2  Serial Thread Confinement模式的架构  163
11.3  Serial Thread Confinement模式实战案例解析  166
11.4  Serial Thread Confinement模式的评价与实现考量  170
11.5  Serial Thread Confinement模式的可复用实现代码  171
11.6  Java标准库实例  176
11.7  相关模式  177
11.7.1  Immutable Object模式（第3章）  177
11.7.2  Promise模式（第6章）  177
11.7.3  Producer-Consumer模式（第7章）  177
11.7.4  Thread Specific Storage模式（第10章）  177
11.8  参考资源  177
第12章  Master-Slave（主仆）模式  178
12.1  Master-Slave模式简介  178
12.2  Master-Slave模式的架构  178
12.3  Master-Slave模式实战案例解析  180
12.4  Master-Slave模式的评价与实现考量  187
12.4.1  子任务处理结果的收集  188
12.4.2  Slave参与者实例的负载均衡与工作窃取  189
12.4.3  可靠性与异常处理  190
12.4.4  Slave线程的停止  190
12.5  Master-Slave模式的可复用实现代码  190
12.6  Java标准库实例  204
12.7  相关模式  204
12.7.1  Two-phase Termination模式（第5章）  204
12.7.2  Promise模式（第6章）  204
12.7.3  Strategy（策略）模式  204
12.7.4  Template（模板）模式  205
12.7.5  Factory Method（工厂方法）模式  205
12.8  参考资源  205
第13章  Pipeline（流水线）模式  206
13.1  Pipeline模式简介  206
13.2  Pipeline模式的架构  207
13.3  Pipeline模式实战案例解析  212
13.4  Pipeline模式的评价与实现考量  219
13.4.1  Pipeline的深度  220
13.4.2  基于线程池的Pipe  220
13.4.3  错误处理  223
13.4.4  可配置的Pipeline  224
13.5  Pipeline模式的可复用实现代码  224
13.6  Java标准库实例  236
13.7  相关模式  236
13.7.1  Serial Thread Confinement模式（第11章）  236
13.7.2  Master-Slave模式（第12章）  237
13.7.3  Composite模式  237
13.8  参考资源  237
第14章  Half-sync/Half-async（半同步/半异步）模式  238
14.1  Half-sync/Half-async模式简介  238
14.2  Half-sync/Half-async模式的架构  238
14.3  Half-sync/Half-async模式实战案例解析  240
14.4  Half-sync/Half-async模式的评价与实现考量  249
14.4.1  队列积压  250
14.4.2  避免同步任务层处理过慢  251
14.5  Half-sync/Half-async模式的可复用实现代码  251
14.6  Java标准库实例  256
14.7  相关模式  256
14.7.1  Two-phase Termination模式（第5章）  256
14.7.2  Producer-Consumer模式（第7章）  256
14.7.3  Active Object模式（第8章）  256
14.7.4  Thread Pool模式（第9章）  257
14.8  参考资源  257
第15章  模式语言  258
15.1  设计模式之间的联系  258
15.2  Immutable Object模式  260
15.3  Guarded Suspension模式  261
15.4  Two-phase Termination模式  262
15.5  Promise模式  263
15.6  Producer-Consumer模式  264
15.7  Active Object模式  265
15.8  Thread Pool模式  266
15.9  Thread Specific Storage模式  267
15.10  Serial Thread Confinement模式  268
15.11  Master-Slave模式  269
15.12  Pipeline模式  270
15.13  Half-sync/Half-async模式  271
附录A  本书常用UML图指南  272
参考文献  281
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程实战指南：设计模式篇（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实战Python设计模式:可复用面向对象软件开发实践
第1 章 示例软件介绍 ··········································································· 1
1.1 准备工作 ············································································ 1
1.1.1 源代码下载 ································································· 1
1.1.2 安装开发环境 ······························································ 1
1.2 启动 ·················································································· 1
1.3 功能说明 ············································································ 2
1.4 功能概要 ············································································ 3
1.4.1 编辑 ·········································································· 3
1.4.2 逻辑调试 ···································································· 6
1.4.3 文件管理 ···································································· 6
1.4.4 代码生成 ···································································· 6
第2 章 创建型模式 ·············································································· 7
2.1 抽象工厂模式 ······································································ 7
2.1.1 问题说明 ···································································· 7
2.1.2 模式结构 ···································································· 8
2.1.3 示例代码 ···································································· 9
2.1.4 实战运用 ··································································· 12
2.1.5 效果讨论 ··································································· 19
2.1.6 提示和技巧 ································································ 19
2.2 工厂方法模式 ····································································· 19
2.2.1 问题说明 ··································································· 19
2.2.2 模式结构 ··································································· 21
2.2.3 示例代码 ··································································· 22
2.2.4 实战运用 ··································································· 24
2.2.5 效果讨论 ··································································· 26
2.2.6 提示和技巧 ································································ 26
2.3 原型模式 ··········································································· 27
2.3.1 问题说明 ··································································· 27
2.3.2 模式结构 ··································································· 28
2.3.3 示例代码 ··································································· 29
2.3.4 实战运用 ··································································· 30
2.3.5 效果讨论 ··································································· 34
2.3.6 提示和技巧 ································································ 34
2.4 生成器模式 ········································································ 35
2.4.1 问题说明 ··································································· 35
2.4.2 模式结构 ··································································· 37
2.4.3 示例代码 ··································································· 38
2.4.4 实战运用 ··································································· 42
2.4.5 效果讨论 ··································································· 43
2.4.6 提示和技巧 ································································ 44
2.5 单例模式 ··········································································· 44
2.5.1 问题说明 ··································································· 44
2.5.2 模式结构 ··································································· 45
2.5.3 示例代码 ··································································· 46
2.5.4 实战运用 ··································································· 47
2.5.5 效果讨论 ··································································· 50
2.5.6 提示和技巧 ································································ 50
2.6 创建型模式小结 ·································································· 50
第3 章 结构型模式 ············································································· 52
3.1 组合模式 ··········································································· 52
3.1.1 问题说明 ··································································· 52
3.1.2 模式结构 ··································································· 53
3.1.3 示例代码 ··································································· 54
3.1.4 实战运用 ··································································· 57
3.1.5 效果讨论 ··································································· 60
3.1.6 提示和技巧 ································································ 61
3.2 适配器模式 ········································································ 61
3.2.1 问题说明 ··································································· 61
3.2.2 模式结构 ··································································· 64
3.2.3 示例代码 ··································································· 64
3.2.4 实战运用 ··································································· 66
3.2.5 效果讨论 ··································································· 69
3.2.6 提示和技巧 ································································ 69
3.3 桥接模式 ··········································································· 70
3.3.1 问题说明 ··································································· 70
3.3.2 模式构造 ··································································· 72
3.3.3 示例代码 ··································································· 73
3.3.4 实战运用 ··································································· 76
3.3.5 效果讨论 ··································································· 79
3.3.6 提示和技巧 ································································ 80
3.4 装饰器模式 ········································································ 80
3.4.1 问题说明 ··································································· 80
3.4.2 模式结构 ··································································· 81
3.4.3 示例代码 ··································································· 82
3.4.4 实战运用 ··································································· 84
3.4.5 效果讨论 ··································································· 87
3.4.6 提示和技巧 ································································ 88
3.5 代理模式 ··········································································· 88
3.5.1 问题说明 ··································································· 88
3.5.2 模式结构 ··································································· 90
3.5.3 示例代码 ··································································· 91
3.5.4 实战运用 ··································································· 94
3.5.5 效果讨论 ··································································· 96
3.5.6 提示和技巧 ································································ 96
3.6 享元模式 ··········································································· 96
3.6.1 问题说明 ··································································· 96
3.6.2 模式结构 ··································································· 97
3.6.3 示例代码 ··································································· 98
3.6.4 实战运用 ································································· 100
3.6.5 效果讨论 ································································· 104
3.6.6 提示和技巧 ······························································ 104
3.7 外观模式 ········································································· 104
3.7.1 问题说明 ································································· 104
3.7.2 模式结构 ································································· 106
3.7.3 实战运用 ································································· 106
3.7.4 效果讨论 ································································· 109
3.7.5 提示和技巧 ······························································ 110
3.8 结构型模式小结 ································································ 110
第4 章 行为模式 ·············································································· 111
4.1 职责链模式 ······································································ 111
4.1.1 问题说明 ································································· 111
4.1.2 模式结构 ································································· 113
4.1.3 示例代码 ································································· 113
4.1.4 实战运用 ································································· 115
4.1.5 效果讨论 ································································· 119
4.1.6 提示和技巧 ······························································ 119
4.2 观察者模式 ······································································ 119
4.2.1 问题说明 ································································· 119
4.2.2 模式结构 ································································· 120
4.2.3 示例代码 ································································· 121
4.2.4 实战运用 ································································· 123
4.2.5 效果讨论 ································································· 127
4.2.6 提示和技巧 ······························································ 127
4.3 中介者模式 ······································································ 128
4.3.1 问题说明 ································································· 128
4.3.2 模式结构 ································································· 129
4.3.3 示例代码 ································································· 130
4.3.4 实战运用 ································································· 132
4.3.5 效果讨论 ································································· 133
4.3.6 提示和技巧 ······························································ 134
4.4 策略模式 ········································································· 134
4.4.1 问题说明 ································································· 134
4.4.2 模式结构 ································································· 136
4.4.3 示例代码 ································································· 137
4.4.4 实战运用 ································································· 139
4.4.5 效果讨论 ································································· 144
4.4.6 提示和技巧 ······························································ 145
4.5 命令模式 ········································································· 145
4.5.1 问题说明 ································································· 145
4.5.2 模式结构 ································································· 146
4.5.3 示例代码 ································································· 148
4.5.4 实战运用 ································································· 150
4.5.5 效果讨论 ································································· 154
4.5.6 提示和技巧 ······························································ 154
4.6 备忘录模式 ······································································ 155
4.6.1 问题说明 ································································· 155
4.6.2 模式结构 ································································· 156
4.6.3 示例代码 ································································· 157
4.6.4 实战运用 ································································· 159
4.6.5 效果讨论 ································································· 161
4.6.6 提示和技巧 ······························································ 161
4.7 模板方法模式 ··································································· 162
4.7.1 问题说明 ································································· 162
4.7.2 模式结构 ································································· 163
4.7.3 示例代码 ································································· 164
4.7.4 实战运用 ································································· 168
4.7.5 效果讨论 ································································· 170
4.7.6 提示和技巧 ······························································ 170
4.8 迭代器模式 ······································································ 171
4.8.1 问题说明 ································································· 171
4.8.2 模式结构 ································································· 172
4.8.3 示例代码 ································································· 173
4.8.4 实战运用 ································································· 176
4.8.5 效果讨论 ································································· 179
4.8.6 提示和技巧 ······························································ 179
4.9 访问者模式 ······································································ 180
4.9.1 问题说明 ································································· 180
4.9.2 模式结构 ································································· 182
4.9.3 示例代码 ································································· 183
4.9.4 实战运用 ································································· 187
4.9.5 效果讨论 ································································· 191
4.9.6 提示和技巧 ······························································ 192
4.10 状态模式 ········································································ 193
4.10.1 问题说明 ······························································· 193
4.10.2 模式结构 ······························································· 194
4.10.3 示例代码 ······························································· 195
4.10.4 实战运用 ······························································· 203
4.10.5 效果讨论 ······························································· 206
4.10.6 提示和技巧 ···························································· 206
4.11 解释器模式 ····································································· 206
4.11.1 问题说明 ······························································· 206
4.11.2 模式结构 ······························································· 207
4.11.3 示例代码 ······························································· 208
4.11.4 实战运用 ······························································· 214
4.11.5 效果讨论 ······························································· 219
4.11.6 提示和技巧 ···························································· 220
4.12 行为模式小结 ·································································· 220
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实战Python设计模式:可复用面向对象软件开发实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Python编程实战
译者序
序
前言
第1章　python的创建型设计模式 1
1.1　抽象工厂模式 1
1.1.1　经典的抽象工厂模式 2
1.1.2　python风格的抽象工厂模式 4
1.2　建造者模式 6
1.3　工厂方法模式 12
1.4　原型模式 18
1.5　单例模式 19
第2章　python的结构型设计模式 21
2.1　适配器模式 21
2.2　桥接模式 26
2.3　组合模式 31
2.3.1　常规的“组合体/非组合体”式层级 32
2.3.2　只用一个类来表示组合体与非组合体 35
2.4　修饰器模式 37
2.4.1　函数修饰器与方法修饰器 38
2.4.2　类修饰器 42
2.5　外观模式 47
2.6　享元模式 52
2.7　代理模式 54
第3章　python的行为型设计模式 58
3.1　责任链模式 58
3.1.1　用常规方式实现责任链 59
3.1.2　基于协程的责任链 60
3.2　命令模式 63
3.3　解释器模式 66
3.3.1　用eval()函数求表达式的值 67
3.3.2　用exec()函数执行代码 70
3.3.3　用子进程执行代码 73
3.4　迭代器模式 76
3.4.1　通过序列协议实现迭代器 77
3.4.2　通过双参数iter()函数实现迭代器 77
3.4.3　通过迭代器协议实现迭代器 79
3.5　中介者模式 81
3.5.1　用常规方式实现中介者 82
3.5.2　基于协程的中介者 85
3.6　备忘录模式 87
3.7　观察者模式 87
3.8　状态模式 91
3.8.1　用同一套方法来处理不同的状态 93
3.8.2　用不同的方法来处理不同的状态 94
3.9　策略模式 95
3.10　模板方法模式 98
3.11　访问者模式 101
3.12　案例研究：图像处理程序包 102
3.12.1　通用的图像处理模块 103
3.12.2　xpm模块概述 111
3.12.3　png包装器模块 113
第4章　python的高级并发技术 116
4.1　计算密集型并发 119
4.1.1　用队列及多进程实现并发 121
4.1.2　用future及多进程实现并发 126
4.2　i/o密集型并发 128
4.2.1　用队列及线程实现并发 129
4.2.2　用future及线程实现并发 134
4.3　案例研究：并发式gui应用程序 136
4.3.1　创建gui 138
4.3.2　编写与工作线程配套的imagescale模块 144
4.3.3　在gui中显示图像处理进度 146
4.3.4　处理gui程序终止时的相关事宜 148
第5章　扩充python 150
5.1　用ctypes访问c程序库 151
5.2　cython的用法 159
5.2.1　用cython访问c程序库 159
5.2.2　编写cython模块以进一步提升程序执行速度 164
5.3　案例研究：用cython优化图像处理程序包 169
第6章　python高级网络编程 173
6.1　编写xml-rpc应用程序 174
6.1.1　数据包装器 174
6.1.2　编写xml-rpc服务器 178
6.1.3　编写xml-rpc客户端 180
6.2　编写rpyc应用程序 188
6.2.1　线程安全的数据包装器 188
6.2.2　编写rpyc服务器 193
6.2.3　编写rpyc客户端 195
第7章　用tkinter开发图形用户界面 199
7.1　tkinter简介 201
7.2　用tkinter创建对话框 203
7.2.1　创建对话框式应用程序 205
7.2.2　创建应用程序中的对话框 212
7.3　用tkinter创建主窗口式应用程序 220
7.3.1　创建主窗口 222
7.3.2　创建菜单 224
7.3.3　创建带计分器的状态栏 226
第8章　用opengl绘制3d图形 229
8.1　用透视投影法创建场景 230
8.1.1　用pyopengl编写cylinder程序 231
8.1.2　用pyglet编写cylinder程序 235
8.2　用正交投影法制作游戏 238
8.2.1　绘制游戏场景 240
8.2.2　判断用户是否选中了场景里的物体 242
8.2.3　处理用户操作 244
附录a　结束语 248
附录b　参考书目摘录 250
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Python编程实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Objective-C编程之道
第一部分　设计模式初体验
第1章　你好，设计模式 2
1.1　这是一本什么书 2
1.2　开始前的准备 2
1.3　预备知识 3
1.4　似曾相识的设计 3
1.5　设计模式的起源——模型、视图和 控制器 4
1.5.1　在模型对象中封装数据和基 本行为 4
1.5.2　使用视图对象向用户展示信息 5
1.5.3　用控制器对象联系起模型和 视图 5
1.5.4　作为复合设计模式的MVC 5
1.6　影响设计的几个问题 6
1.6.1　针对接口编程，而不是针对实现编程 7
1.6.2　@protocol与抽象基类 7
1.6.3　对象组合与类继承 8
1.7　本书用到的对象和类 9
1.7.1　类图 9
1.7.2　对象图 12
1.8　本书如何安排模式的讲解 13
1.9　总结 13
第2章　案例分析：设计一个应用程序 14
2.1　想法的概念化 14
2.2　界面外观的设计 15
2.3　架构设计 17
2.3.1　视图管理 18
2.3.2　如何表现涂鸦 20
2.3.3　如何表现保存的涂鸦图 24
2.3.4　用户操作 27
2.4　所用设计模式的回顾 32
2.5　总结 33
第二部分　对象创建
第3章　原型 36
3.1　何为原型模式 36
3.2　何时使用原型模式 37
3.3　浅复制与深复制 38
3.4　使用Cocoa Touch框架中的对象 复制 39
3.5　为Mark聚合体实现复制方法 39
3.6　将复制的Mark用作“图样模板” 47
3.7　总结 49
第4章　工厂方法 50
4.1　何为工厂方法模式 50
4.2　何时使用工厂方法 51
4.3　为何这是创建对象的安全方法 51
4.4　在TouchPainter中生成不同画布 51
4.5　在Cocoa Touch框架中应用工厂 方法 57
4.6　总结 58
第5章　抽象工厂 59
5.1　把抽象工厂应用到TouchPainter 应用程序 60
5.2　在Cocoa Touch框架中使用抽象 工厂 66
5.3　总结 68
第6章　生成器 69
6.1　何为生成器模式 69
6.2　何时使用生成器模式 70
6.3　构建追逐游戏中的角色 71
6.4　总结 79
第7章　单例 80
7.1　何为单例模式 80
7.2　何时使用单例模式 81
7.3　在Objective-C中实现单例模式 81
7.4　子类化Singleton 85
7.5　线程安全 85
7.6　在Cocoa Touch框架中使用单例 模式 86
7.6.1　使用UIApplication类 86
7.6.2　使用UIAccelerometer类 86
7.6.3　使用NSFileManager类 86
7.7　总结 87
第三部分　接口适配
第8章　适配器 90
8.1　何为适配器模式 90
8.2　何时使用适配器模式 92
8.3　委托 92
8.4　用Objective-C协议实现适配器模式 93
8.5　用Objective-C的块在iOS 4中实现 适配器模式 99
8.5.1　块引用的声明 99
8.5.2　块的创建 100
8.5.3　把块用作适配器 100
8.6　总结 104
第9章　桥接 105
9.1　何为桥接模式 105
9.2　何时使用桥接模式 106
9.3　创建iOS版虚拟仿真器 106
9.4　总结 112
第10章　外观 113
10.1　何为外观模式 113
10.2　何时使用外观模式 114
10.3　为子系统的一组接口提供简化的 接口 114
10.4　在TouchPainter应用程序中使用外 观模式 117
10.5　总结 119
第四部分　对象去耦
第11章　中介者 122
11.1　何为中介者模式 122
11.2　何时使用中介者模式 124
11.3　管理TouchPainter应用程序中的 视图迁移 124
11.3.1　修改迁移逻辑的困难 126
11.3.2　集中管理UI交通 127
11.3.3　在Interface Builder中使用CoordinatingController 132
11.4　总结 135
第12章　观察者 136
12.1　何为观察者模式 136
12.2　何时使用观察者模式 138
12.3　在模型-视图-控制器中使用观察 者模式 138
12.4　在Cocoa Touch框架中使用观察者 模式 138
12.4.1　通知 139
12.4.2　键-值观察 139
12.5　在TouchPainter中更新CanvasView 上的线条 140
12.6　总结 149
第五部分　抽象集合
第13章　组合 152
13.1　何为组合模式 152
13.2　何时使用组合模式 154
13.3　理解TouchPainter中Mark的使用 154
13.4　在Cocoa Touch框架中使用组合 模式 163
13.5　总结 164
第14章　迭代器 165
14.1　何为迭代器模式 165
14.2　何时使用迭代器模式 167
14.3　在Cocoa Touch框架中使用迭代器 模式 167
14.3.1　NSEnumerator 167
14.3.2　基于块的枚举 168
14.3.3　快速枚举 169
14.3.4　内部枚举 170
14.4　遍历Scribble的顶点 170
14.5　总结 178
第六部分　行为扩展
第15章　访问者 180
15.1　何为访问者模式 180
15.2　何时应用访问者模式 182
15.3　用访问者绘制TouchPainter中的 Mark 182
15.4　访问者的其他用途 189
15.5　能不能用范畴代替访问者模式 189
15.6　总结 189
第16章　装饰 190
16.1　何为装饰模式 190
16.2　何时使用装饰模式 191
16.3　改变对象的“外表”和“内容” 192
16.4　为UIImage创建图像滤镜 192
16.4.1　通过真正的子类实现装饰 193
16.4.2　通过范畴实现装饰 201
16.5　总结 206
第17章　责任链 207
17.1　何为责任链模式 207
17.2　何时使用责任链模式 208
17.3　在RPG游戏中使用责任链模式 209
17.4　总结 214
第七部分　算法封装
第18章　模板方法 216
18.1　何为模板方法模式 216
18.2　何时使用模板方法 217
18.3　利用模板方法制作三明治 217
18.4　保证模板方法正常工作 224
18.5　向模板方法增加额外的步骤 225
18.6　在Cocoa Touch框架中使用模板 方法 228
18.6.1　UIView类中的定制绘图 228
18.6.2　Cocoa Touch框架中的其他 模板方法实现 228
18.7　总结 229
第19章　策略 230
19.1　何为策略模式 230
19.2　何时使用策略模式 231
19.3　在UITextField中应用验证策略 231
19.4　总结 239
第20章　命令 240
20.1　何为命令模式 240
20.2　何时使用命令模式 241
20.3　在Cocoa Touch框架中使用命令 模式 241
20.3.1　NSInvocation对象 242
20.3.2　NSUndoManager 243
20.4　在TouchPainter中实现撤销与恢 复 243
20.4.1　使用NSUndoManager实 现绘图与撤销绘图 244
20.4.2　自制绘图与撤销绘图的 基础设施 248
20.4.3　允许用户触发撤销与恢复 255
20.5　命令还能做什么 256
20.6　总结 257
第八部分　性能与对象访问
第21章　享元 260
21.1　何为享元模式 260
21.2　何时使用享元模式 262
21.3　创建百花池 262
21.4　总结 269
第22章　代理 270
22.1　何为代理模式 270
22.2　何时使用代理模式 271
22.3　用虚拟代理懒加载图像 272
22.4　在Cocoa Touch框架中使用代理 模式 277
22.5　总结 279
第九部分　对象状态
第23章　备忘录 282
23.1　何为备忘录模式 282
23.2　何时使用备忘录模式 283
23.3　在TouchPainter中使用备忘录模式 284
23.3.1　涂鸦图的保存 284
23.3.2　涂鸦图的恢复 285
23.3.3　ScribbleMemento的 设计与实现 286
23.4　Cocoa Touch框架中的备忘录模式 295
23.5　总结 297
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Objective-C编程之道
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>价值主张设计
1.画布
1.1客户概况
1.2价值图
1.3契合
2.设计
2.1创建原型可能性
2.2出发点
2.3了解客户
2.4做出选择
2.5发现正确的商业模式
2.6在现有的组织中设计
3.测试
3.1测试什么
3.2一步一步测试
3.3实验库
3.4汇集所有片段
4.发展
4.1达成一致意见
4.2衡量和监测
4.3不断改进
4.4不断重塑自我
4.5淘宝：重塑电子商务
术语表
核心团队
首批读者
作者简介
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>价值主张设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ACE程序员指南
译者序
序
前 言
第1部分 ACE基础知识
第1章 ACE简介
第2章 怎样构建ACE并在你的程序中使用它
第3章 使用ACE日志设施
第4章 收集运行时信息
第5章 ACE容器
第2部分 进程间通信
第6章 基本的TCP/IP Socket用法
第7章 处理事件及多个I/O流
第8章 异步I/O与ACE Proactor框架
第9章 其他IPC类型
第3部分 进程与线程管理
第10章 进程管理
第11章 信号
第12章 基本的多线程编程
第13章 线程管理
第14章 线程安全与同步
第15章 主动对象
第16章 线程池
第4部分 ACE高级特
第17章 共享内存
第18章 ACE Streams框架
第19章 ACE Service Configurator框架
第20章 定时器
第21章 ACE Naming Service
参考书目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ACE程序员指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>让云落地
第1章  为什么是云计算，为什么是现在	1
1.1  云计算的进化	4
1.2  进入云	9
1.3  初创企业案例研究：Instagram，一夜之间，从0到10亿美元	10
1.4  成熟公司案例研究：Netflix，从本地向云端迁移	11
1.5  政府案例研究： NOAA、电子邮件，以及云端协作	13
1.6  非营利案例研究：奥巴马竞选运动，在线6个月，峰值仅几天	14
1.7  总结	14
第2章  云服务模式	17
2.1  基础设施即服务	17
2.2  平台即服务	20
2.3  软件即服务	23
2.4  部署模式	24
2.5  总结	29
第3章  云计算的错误实践	31
3.1  迁移至云端时避免失败	31
3.2  将应用迁移至云端	32
3.3  不切实际的期望	36
3.4  云安全的错误认知	39
3.5  只选最喜欢的，不选最合适的	42
3.6  服务中断及停业场景	43
3.7  低估组织变革带来的影响	45
3.8  技术不足	47
3.9  对客户需求的错误认识	50
3.10  出乎意料的成本	51
3.11  总结	54
第4章  先从架构开始	56
4.1  5W1H的重要性	57
4.2  由业务架构开始	58
4.3  识别问题（原因）	64
4.4  评估用户特征（何人）	65
4.5  明确业务和技术需求（什么）	66
4.6  将服务消费者的体验可视化（何地）	67
4.7  明确项目约束条件（何时及什么要求）	70
4.8  了解当前的状况约束（如何）	71
4.9  总结	74
第5章  选择合适的云服务模式	75
5.1  考虑何时选择云服务模式	76
5.2  何时使用SaaS	80
5.3  何时使用PaaS	85
5.4  何时使用IaaS	89
5.5  常见的云使用案例	93
5.6  总结	95
第6章  云的关键：RESTful服务	96
6.1  为什么是REST	98
6.2  将遗留系统迁移至云端面临的挑战	101
6.3  总结	103
第7章  云中审计	104
7.1  数据和云安全	105
7.2  审计云应用	106
7.3  云中的法规	108
7.4  审计的设计策略	112
7.5  总结	115
第8章  云的数据考虑	116
8.1  数据特性	116
8.2  多租户或单租户	123
8.3  选择数据存储类型	127
8.4  总结	131
第9章  云中的安全设计	133
9.1  云中数据的真相	134
9.2  安全的程度	136
9.3  每种云服务模式下的责任	140
9.4  安全策略	146
9.5  焦点领域	148
9.6  总结	160
第10章  创建集中化的日志策略	161
10.1  日志文件使用	162
10.2  日志记录要求	163
10.3  总结	169
第11章  SLA管理	170
11.1  影响SLA的因素	170
11.2  界定SLA	175
11.3  管理供应商SLA	177
11.4  总结	181
第12章  监控策略	183
12.1  积极主动的监控vs. 消极被动的监控	183
12.2  需要监控的内容有哪些	184
12.3  分类别的监控策略	187
12.4  按云服务等级进行监控	194
12.5  总结	197
第13章  灾难恢复计划	198
13.1  什么是故障时间成本	199
13.2  IaaS的灾难恢复策略	201
13.3  主要数据中心的灾难恢复	203
13.4  PaaS的灾难恢复策略	209
13.5  SaaS的灾难恢复策略	210
13.6  混合云的灾难恢复	212
13.7  总结	214
第14章  使用DevOps文化来更快、更可靠地交付软件	215
14.1  发展DevOps心态	216
14.2  自动化基础设施	218
14.3  自动化部署	220
14.4  设计功能标记	221
14.5  测量、监控和试验	222
14.6  持续集成和持续交付	222
14.7  总结	225
第15章  评估云模式对组织的影响	227
15.1  企业模式vs. 弹性云模式	229
15.2  IT影响	230
15.3  商业影响	232
15.4  组织变革规划	236
15.5  真实世界的变革	240
15.6  总结	240
第16章  最后的思考	242
16.1  云在快速进化	243
16.2  云文化	245
16.3  新的商业模式	246
16.4  PaaS是游戏规则改变者	248
16.5  总结	25
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>让云落地
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精彩绝伦的Android UI设计
译者序
前言
第一部分 Android设计简介
第1章 用户界面设计和易用性入门  2
1.1 考虑技术与设计  2
1.2 理解心智模型  3
1.3 为用户设计  6
1.4 没有应用无所不精，选择适合自己的领域  9
1.5 你是专家，用户不是设计师  9
1.6 了解用户，为普通人设计  9
1.7 总结  11
第2章 不要马上开始编程  12
2.1 原型设计  12
2.2 设计工具  14
2.3 用户测试  17
2.4 总结  20
第3章 考虑为移动和触摸设备设计  21
3.1 为移动而设计  21
3.2 为触摸界面设计  26
3.3 总结  29
第4章 探索Android平台  30
4.1 Android平台的挑战  30
4.2 Android的版本  36
4.3 Android应用的发布  38
4.4 开源的意义是什么  40
4.5 总结  41
第二部分 Android平台的特性和UI组件
第5章 Android应用架构和在线指南  44
5.1 Android应用程序结构概览  44
5.2 Android项目结构概览  47
5.3 官方Android指南  48
5.4 总结  49
第6章 Android的意图系统  50
6.1 意图让应用程序相互协作  50
6.2 使用社交网络并分享  51
6.3 和浏览器一起工作  52
6.4 Android意图系统的工作原理  53
6.5 创建自定义行为  58
6.6 意图无处不在  58
6.7 意图与第三方API  58
6.8 总结  59
第7章 Android应用的导航结构  60
7.1 Android导航系统的组件：活动和意图  60
7.2 Android导航控件  61
7.3 总结  70
第8章 主界面应用小部件  71
8.1 主界面应用小部件的使用  71
8.2 更新应用小部件数据  73
8.3 应用小部件布局和功能  75
8.4 实现应用小部件  78
8.5 总结  80
第9章 通知及告知用户  81
9.1 Android通知方法  81
9.2 何时通知用户  83
9.3 何时不要通知用户  86
9.4 避免使用弹出框  86
9.5 从状态栏通知中获得更多信息  87
9.6 总结  91
第10章 物理按键、输入法和传感器的设计  92
10.1 触摸屏的设计  92
10.2 手机物理按键的设计  93
10.3 软键盘的设计  94
10.4 物理键盘设计  99
10.5 方向键和轨迹球设计  99
10.6 触控笔设计  100
10.7 声控设计  101
10.8 外接键盘、鼠标和触摸板的设计  101
10.9 智能附件的设计  102
10.10 传感器的设计  102
10.11 第二块屏幕的设计  102
10.12 总结  103
第11章 平台用户界面组件的设计  104
11.1 使用用户界面小部件  104
11.2 自定义用户界面小部件  111
11.3 调整排版  113
11.4 使用图标  117
11.5 使用动画和过渡效果  121
11.6 总结  127
第三部分 可扩展的Android设计
第12章 管理Android资源  130
12.1 使用Android资源  130
12.2 屏幕密度设计  132
12.3 屏幕大小和形状的设计  135
12.4 语言和地区设置  137
12.5 设备控件的设计  137
12.6 平台版本的设计  138
12.7 设备模式的设计  138
12.8 总结  138
第13章 Android应用布局  139
13.1 Android布局策略  139
13.2 用XML文件和代码布局  140
13.3 布局的管理  141
13.4 定义布局的尺寸  149
13.5 滚动条  149
13.6 z轴的布局顺序  150
13.7 内边距和外边距  150
13.8 导入与合并布局文件  150
13.9 自定义布局  151
13.10 Android开发工具和用户界面生成器  151
13.11 调试布局  152
13.12 总结  153
第14章 可缩放的图形  154
14.1 九宫格图片  154
14.2 绘图XML  158
14.3 用代码绘制  163
14.4 总结  166
第15章 超越可缩放——响应式设计  167
15.1 Android设备不仅仅只是手机  167
15.2 了解响应式设计  169
15.3 制作响应式用户界面的常见方法  176
15.4 总结  178
第16章 实现响应式用户界面  179
16.1 片段简介  179
16.2 片段和活动结构  181
16.3 移植现存的应用  182
16.4 示例程序  183
16.5 总结  193
第四部分 Android UI设计模式
第17章 用户界面设计模式简介  196
17.1 用户界面设计模式  196
17.2 使用UI设计模式的好处  197
17.3 Android设计指南中的设计模式  198
17.4 本书介绍的用户界面设计模式  198
17.5 总结  199
第18章 用户操作设计模式  200
18.1 使用操作栏模式  200
18.2 使用快捷操作设计模式  206
18.3 使用操作抽屉设计模式  210
18.4 使用下拉刷新设计模式  212
18.5 使用滑动忽略的手势  215
18.6 总结  217
第19章 导航和布局设计模式  218
19.1 使用层叠图库  218
19.2 使用仪表盘  220
19.3 使用工作空间  223
19.4 使用分拆视图  226
19.5 根据上下文扩展的设计模式  228
19.6 使用侧边导航  230
19.7 总结  232
第20章 数据设计模式  233
20.1 使用动态列表  233
20.2 使用图片占位符设计模式  234
20.3 非强制登录模式  236
20.4 使用拖动重排手柄模式  238
20.5 总结  239
第21章 用户界面设计反模式  240
21.1 避免使用启动界面  240
21.2 避免使用引导界面  241
21.3 避免使用确认窗口  242
21.4 避免在界面上使用Back按钮  243
21.5 避免使用菜单按钮  244
21.6 避免隐藏状态栏  244
21.7 避免为快捷操作使用滑动覆盖层  245
21.8 避免使用非Android的设计  246
21.9 总结  247
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精彩绝伦的Android UI设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与算法
第1章 概要
1.1 本书的主要内容
1.2 面向对象的设计
1.3 对象分级与设计方法
1.4 需要了解的C＋＋特性
1.5 本书是如何组织的？

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与算法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C现代编程
第1章　概要　　1
1.1　现在C依然很热门　　1
1.2　使用C进行嵌入式开发的特点　　3
1.3　本书的目标　　5
1.3.1　C与集成开发环境　　5
1.3.2　C与设计模式　　6
1.3.3　C与极限编程　　7
1.3.4　C与现代开发方式　　9
1.4　总结　　11
第2章　搭建开发环境　　13
2.1　概要　　13
2.2　获取Linux　　13
2.3　在Windows PC上搭建环境　　14
2.4　安装Linux　　20
2.4.1　准备工作　　20
2.4.2　制作安装介质　　21
2.4.3　安装Xubuntu　　24
2.5　安装Eclipse　　29
2.5.1　安装Java　　29
2.5.2　安装Eclipse　　30
2.5.3　安装其他工具　　33
2.6　Eclipse的基本操作　　34
2.6.1　Hello, World　　34
2.6.2　视图　　38
2.6.3　工程、工作区和透视图　　38
2.7　Eclipse的功能　　41
2.7.1　可视化调试　　41
2.7.2　导航器　　48
2.7.3　代码补全　　51
2.7.4　宏展开　　53
2.7.5　本地代码历史　　54
2.7.6　TODO注释　　55
2.7.7　与外部编辑器协作　　56
2.8　总结　　58
第3章　C语言与面向对象　　59
3.1　概要　　59
3.2　C的模块化与面向对象　　59
3.2.1　C与模块化　　60
3.2.2　使用结构体将数据结构与代码块分离　　62
3.2.3　使用C进行面向对象编程　　66
3.2.4　面向对象与多态性　　75
3.2.5　继承　　76
3.2.6　封装　　79
3.2.7　虚函数表　　80
3.2.8　非虚函数　　82
3.3　总结　　84
第4章　C语言与设计模式　　85
4.1　状态模式　　85
4.1.1　状态迁移图　　85
4.1.2　状态迁移表　　89
4.1.3　面向对象的状态模式　　90
4.1.4　多个状态集合相互关联的情况　　93
4.1.5　状态模式与内存管理　　94
4.2　模板方法模式　　95
4.2.1　返回非int值　　99
4.2.2　处理其他资源　　100
4.2.3　上下文　　107
4.3　观察者模式　　114
4.4　职责链模式　　125
4.5　访问者模式　　128
4.6　总结　　134
第5章　C语言与重构　　135
5.1　概要　　135
5.2　测试驱动开发　　136
5.3　TDD入门　　137
5.3.1　设置Eclipse　　137
5.3.2　初次测试驱动开发　　142
5.3.3　测试静态函数　　147
5.4　重构　　150
5.4.1　对外接口　　150
5.4.2　重构与投资　　150
5.5　TDD实践篇　　151
5.5.1　怪兽方法　　152
5.5.2　C语言的Mock测试　　162
5.5.3　完成重构　　182
5.5.4　获取代码覆盖率　　186
5.6　总结　　188
第6章　持续集成与部署　　191
6.1　概要　　191
6.2　持续集成的前提　　192
6.2.1　软件配置管理工具　　192
6.2.2　构建工具　　192
6.2.3　Bug跟踪系统（BTS）　　193
6.3　引入CI服务器　　193
6.4　CI入门　　196
6.4.1　本次CI的自动化目标　　196
6.4.2　Scons构建脚本　　197
6.4.3　gcovr的安装　　199
6.4.4　构建　　200
6.4.5　提交至SCM　　202
6.4.6　创建Jenkins任务　　203
6.5　内存Bug大作战　　214
6.5.1　安装　　214
6.5.2　运行Valgrind　　214
6.5.3　Valgrind可以检测出的错误　　215
6.5.4　Valgrind中检测出的内存错误的特点与对策　　220
6.5.5　在Jenkins中使用Valgrind　　221
6.6　CI实践篇　　228
6.6.1　Microchip工具　　229
6.6.2　构建内容　　230
6.6.3　分割构建文件　　234
6.6.4　独立构建服务器　　240
6.6.5　设置自动构建计划　　247
6.7　总结　　249
附录A　示例代码　　251
A.1　注意事项　　251
A.2　添加C99标准　　251
A.3　在Eclipse中导入示例代码　　252
A.3.1　解压示例代码压缩文件　　252
A.3.2　Eclipse中新建空白工程　　252
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C现代编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Web 2.0界面设计模式
第1章  导论	1
1.1  Web界面演化史	1
1.1.1  传统Web界面的发展	1
1.1.2  Web 2.0所引导的用户体验革新	2
1.2  Web 2.0界面设计模式	3
1.2.1  Web 2.0界面设计模式的特征	3
1.2.2  Web 2.0界面设计模式的应用	5
1.3  优秀的Web 2.0站点	6
1.3.1  Quora	6
1.3.2  Vimeo	9
1.3.3  Evernote	12
1.4  小结	14
第2章  页面布局设计模式	15
2.1  边界布局	15
2.2  网格布局	21
2.3  浮动式布局	25
2.4  标签页布局	29
2.5  手风琴布局	33
2.6  伸缩式布局	37
2.7  混合布局	41
2.8  小结	44
第3章  内容导航的设计模式	45
3.1  按内容组织导航	45
3.1.1  菜单（主导航）	45
3.1.2  目录导航	49
3.1.3  网站地图	52
3.2  路径导航	53
3.2.1  面包屑导航	53
3.2.2  分步导航	61
3.2.3  分页导航	63
3.2.4  树状导航	68
3.2.5  滚动列表	73
3.3  预览式导航（图像导航）	75
3.3.1  图标导航	75
3.3.2  滚动式菜单	78
3.3.3  内容预览导航	81
3.3.4  自动翻页	83
3.4  热点内容导航	86
3.4.1  标签云导航	86
3.4.2  标签列导航	90
3.5  地图导航	93
3.6  小结	95
第4章  数据呈现的设计模式	96
4.1  信息提示	96
4.1.1  信息更新提示	96
4.1.2  确认、警告及报错对话框	98
4.1.3  烤面包机模式	99
4.2  表格数据呈现	101
4.2.1  普通表格	101
4.2.2  列锁定表格	103
4.2.3  可编辑单元格	106
4.2.4  合并单元格	108
4.2.5  树状表格	111
4.3  按需加载和呈现	114
4.3.1  分页加载	114
4.3.2  虚拟滚动加载	115
4.3.3  显示滚动加载	118
4.4  数据可视化	119
4.4.1  折线图	120
4.4.2  条形图	123
4.4.3  烛柱图	129
4.4.4  饼图	133
4.4.5  雷达图	137
4.5  小结	142
第5章  数据交互设计模式	143
5.1  实时检测	143
5.1.1  输入后检测	144
5.1.2  输入时检测	147
5.2  数据选择	149
5.2.1  日历模式	149
5.2.2  时间选择模式	151
5.2.3  表格的间接选择模式	153
5.2.4  多层联动选择模式	154
5.2.5  导航式多级选择模式	155
5.2.6  旋转木马模式	157
5.3  实时内容过滤	159
5.3.1  下拉框内容过滤	159
5.3.2  表格内容过滤	162
5.3.3  树状内容过滤	165
5.3.4  精确内容过滤	169
5.3.5  模糊内容过滤	173
5.4  输入提示模式	176
5.4.1  输入占位符	176
5.4.2  自动完成	178
5.4.3  示例输入	180
5.5  输入向导模式	180
5.6  自动保存模式	182
5.6.1  客户端自动保存	182
5.6.2  服务器端自动保存	185
5.7  拖曳移动模式	188
5.7.1  自由移动模式	188
5.7.2  拖放模式	191
5.8  小结	193
第6章  Web 2.0动画与特效	194
6.1  Web动画与特效的使用场景	194
6.2  Web动画与特效的演化	197
6.2.1  静态HTML	197
6.2.2  Flash动画	198
6.2.3  JavaScript与CSS动画特效	198
6.2.4  HTML 5、CSS 3与Canvas特效	199
6.2.5  代码示例	199
6.2.6  Web 2.0 站点特效	200
6.3  常见Web 2.0站点使用的动画与特效	201
6.3.1  淡入与淡出	201
6.3.2  滑动	205
6.3.3  擦入/擦出效果	210
6.3.4  使用动画增强高亮效果	211
6.3.5  鱼眼特效	213
6.3.6  进度提示动画	215
6.3.7  启动画面	217
6.4  小结	219
第7章  应用案例	220
7.1  需求分析	220
7.1.1  微博的发展史	220
7.1.2  微博的特点	221
7.2  设计实践	222
7.2.1  了解目标用户	222
7.2.2  原型设计与模式应用	224
7.3  原型实现	229
7.3.1 “按需出现/消失”模式	229
7.3.2 “面板展开收起”模式	231
7.3.3  标签页布局模式	233
7.3.4  菜单导航模式	234
7.3.5  表格数据模式	235
7.3.6  线状图表模式	237
7.3.7  柱状图表模式	239
7.3.8  实时检测模式	240
7.3.9  淡入淡出动画效果模式	242
7.3.10  擦入/擦出动画效果模式	243
7.3.11  鱼眼效果模式	243
7.4  小结	245
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Web 2.0界面设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与算法
第一章 安全面临的威胁
1.1

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与算法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图解建筑结构
中文版序言
序言
1 建筑结构
2 结构模式
3 水平跨件
4 竖向维度
5 侧向稳定
6 大跨结构
7 高层结构
8 系统整合
参考书目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图解建筑结构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.NET设计规范
第1章 概述	1
1.1 精心设计的框架所具备的品质	2
1.1.1 精心设计的框架是简单的	2
1.1.2 精心设计的框架设计代价高	3
1.1.3 精心设计的框架充满利弊权衡	3
1.1.4 精心设计的框架应该借鉴过去	4
1.1.5 精心设计的框架要考虑未来发展	4
1.1.6 精心设计的框架应具有良好的集成性	4
1.1.7 精心设计的框架是一致的	4
第2章 框架设计基础	6
2.1 渐进框架	7
2.2 框架设计的基本原则	10
2.2.1 场景驱动设计的原则	11
2.2.2 低门槛原则	17
2.2.3 自说明对象模型原则	20
2.2.4 分层架构原则	25
2.3 小结	27
第3章 命名规范	28
3.1 大小写约定	29
3.1.1 标识符的大小写规则	29
.3.1.2 首字母缩写词的大小写	31
3.1.3 复合词和常用术语的大小写	33
3.1.4 是否区分大小写	35
3.2 通用命名约定	35
3.2.1 单词的选择	36
3.2.2 使用单词缩写和首字母缩写词	37
3.2.3 避免使用语言特有的名字	38
3.2.4 为已有api的新版本命名	39
3.3 程序集和dll的命名	42
3.4 名字空间的命名	43
3.5 类、结构和接口的命名	47
3.5.1 泛型类型参数的命名	49
3.5.2 常用类型的命名	50
3.5.3 枚举类型的命名	51
3.6 类型成员的命名	53
3.6.1 方法的命名	53
3.6.2 属性的命名	54
3.6.3 事件的命名	55
3.6.4 字段的命名	57
3.7 参数的命名	57
3.8 资源的命名	58
3.9 小结	59
第4章 类型设计规范	60
4.1 类型和名字空间	62
4.2 类和结构之间的选择	67
4.3 类和接口之间的选择	69
4.4 抽象类的设计	76
4.5 静态类的设计	78
4.6 接口的设计	79
4.7 结构的设计	81
4.8 枚举的设计	83
4.8.1 标记枚举的设计	89
4.8.2 给枚举添加值	93
4.9 嵌套类型	94
4.10 小结	96
第5章 成员设计	97
5.1 成员设计的一般规范	97
5.1.1 成员重载	97
5.1.2 显式地实现接口成员	102
5.1.3 属性和方法之间的选择	106
5.2 属性的设计	112
5.2.1 索引属性的设计	113
5.2.2 属性改变的通知事件	115
5.3 构造函数的设计	117
5.4 事件的设计	123
5.5 字段的设计	130
5.6 操作符重载	132
5.6.1 重载operator==	136
5.6.2 类型转换操作符	136
5.7 参数的设计	138
5.7.1 枚举和布尔参数之间的选择	140
5.7.2 参数的验证	142
5.7.3 参数的传递	145
5.7.4 参数数量可变的成员	147
5.7.5 指针参数	150
5.8 小结	152
第6章 为扩展性而设计	153
6.1 扩展机制	153
6.1.1 非密封类	153
6.1.2 保护成员	155
6.1.3 事件与回调函数	156
6.1.4 虚成员	158
6.1.5 抽象（抽象类型与抽象接口）	160
6.2 基类	162
6.3 密封	163
6.4 小结	166
第7章 异常	167
7.1 抛出异常	171
7.2 为抛出的异常选择合适的类型	175
7.2.1 错误消息的设计	176
7.2.2 异常处理	177
7.2.3 对异常进行封装	182
7.3 标准异常类型的使用	184
7.3.1 exception与systemexception	184
7.3.2 applicationexception	184
7.3.3 invalidoperationexception	184
7.3.4 argumentexception、argumentnullexception 及argumentoutofrangeexception	185
7.3.5 nullreferenceexception、indexoutofrangeexception及accessviolationexception	186
7.3.6 stackoverflowexception	186
7.3.7 outofmemoryexception	187
7.3.8 comexception、sehexception及其他clr异常	188
7.3.9 executionengineexception	188
7.4 自定义异常的设计	188
7.5 异常与性能	190
7.5.1 tester-doer模式	190
7.5.2 try-parse模式	191
7.6 小结	192
第8章 使用规范	193
8.1 数组	193
8.2 attribute	195
8.3 集合	198
8.3.1 集合参数	199
8.3.2 集合属性与返回值	200
8.3.3 数组与集合之间的选择	204
8.3.4 自定义集合的实现	205
8.4 icloneable	207
8.5 icomparable[t]与iequatable[t]	208
8.6 idisposable	210
8.7 对象	210
8.7.1 object.equals	210
8.7.2 object.gethashcode	212
8.7.3 object.tostring	213
8.8 uri	214
8.9 system.xml的使用	216
8.10 相等性操作符	218
8.10.1 值类型的相等性操作符	218
8.10.2 引用类型的相等性操作符	219
第9章 常用的设计模式	220
9.1 聚合组件	220
9.1.1 面向组件的设计	222
9.1.2 因子类型	224
9.1.3 聚合组件规范	224
9.2 async模式	227
9.3 dispose模式	232
9.3.1 基本dispose模式	234
9.3.2 可终结类型	240
9.4 factory模式	243
9.5 optional feature模式	247
9.6 template method模式	251
9.7 超时	252
9.8 结束语	254
附录a c#编程风格约定	255
a.1 通用风格约定	255
a.1.1 花括号的使用	255
a.1.2 空格的使用	257
a.1.3 缩进的使用	259
a.2 命名约定	259
a.3 注释	260
a.4 文件的组织	261
附录b 通过fxcop来实施设计规范	263
b.1 fxcop是什么？	263
b.2 fxcop的发展过程	264
b.3 fxcop的工作原理	265
b.4 fxcop规范的覆盖范围	265
b.4.1 与命名规范有关的fxcop规则	265
b.4.2 与类型设计规范有关的fxcop规则	274
b.4.3 与成员的设计有关的fxcop规则	277
b.4.4 与为扩展性而设计有关的fxcop规则	284
b.4.5 与异常有关的fxcop规则	285
b.4.6 与使用规范有关的fxcop规则	287
b.4.7 与设计模式有关的fxcop规则	291
附录c api规范样例	292
术语表	299
推荐读物	303
索引	305
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.NET设计规范
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>领域驱动设计与模式实战
第一部分　背景知识  第1章　应重视的价值，也是对过去几年的沉重反思    1.1　总体价值    1.2　应重视的架构风格      1.2.1　焦点之一：模型      1.2.2　焦点之二：用例      1.2.3　如果重视模型，就可以使用领域模型模式      1.2.4　慎重处理数据库      1.2.5　领域模型与关系数据库之间的阻抗失配      1.2.6　谨慎处理分布式      1.2.7　消息传递很重要    1.3　对过程的各个组成部分的评价      1.3.1　预先架构设计      1.3.2　领域驱动设计      1.3.3　测试驱动开发      1.3.4　重构      1.3.5　选择一种还是选择组合    1.4　　持续集成      1.4.1　解决方案(或至少是正确方向上的一大步)      1.4.2　从我的组织汲取的教训      1.4.3　更多信息    1.5　不要忘记运行机制      1.5.1　有关何时需要运行机制的一个例子      1.5.2　运行机制的一些例子      1.5.3　它不仅仅是我们的过错    1.6　小结  第2章　模式起步　32    ……  第3章　TDD与重构第二部分　应用DDD  第4章　新的默认架构  第5章　领域驱动设计进阶  第6章　准备基础架构  第7章　应用规则第三部分　应用PoEAA  第8章　用于持久化的基础架构  第9章　应用NHibernate第四部分　下一步骤  第10章　博采其他设计技术  第11章　关注UI第五部分　附录  附录A　其他领域模型风格  附录B　已讨论的模式的目录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>领域驱动设计与模式实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>美国包装设计模板
简介01  书籍和杂志02  手册和目录03  问候卡和邀请卡04  传单和邮件封套05  CD和DVD06  产品包装07  文具08  附录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>美国包装设计模板
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>字体设计-日本最新设计模板
一、字体常识
1.易读 一般规则/特殊禁忌 案例精解：亮色/间距/强调 宽松/方格/简洁 精彩贴图
2.间隔 一般规则/特殊禁忌 案例精解：连续/图形/团块 节奏/构成/版面 精彩贴图
3.方向性 一般规则/特殊禁忌 案例精解：远近/上下/不安 转折/倾斜/发射 精彩贴图 4.强调 一般规则/特殊禁忌 案例精解：点/色块/图形 构成/重量/古朴 精彩贴图
5.颜色 一般规则/特殊禁忌 案例精解：不同材料/单一/多色 块面/页面/节奏 精彩贴图
6.形态 一般规则/特殊禁忌 案例精解：人物/似人/组字 点/是与非/云形 精彩贴图
7.节奏 一般规则/特殊禁忌 案例精解：强调/重复/大小 屡次/排列/均等 精彩贴图
8.动感 一般规则/特殊禁忌 案例精解：变化/方向/飘动 不安/形状/旋转 精彩贴图
9.立体 一般规则/特殊禁忌 案例精解：重叠/发射/体积 片状/形态/构成 精彩贴图 10.引申 一般规则/特殊禁忌 案倒辅解：残像/面/远近 中间/渐变/立体 精彩贴图
11.直线 一般规则/特殊禁忌 案例精解：组台/可爱/形状 构成/对称/简洁 精彩贴图 12.曲线 一般规则/特殊禁忌 案例精解：圆点/胖形/可爱 书法/钢笔/立体 精彩贴图
=============================================================
二、字体手法
13.破形 一般规则/特殊禁忌 案例精解：效果/切割/变化 残缺/节奏/强调 精彩贴图 14.质感 一般规则/特殊禁忌 案例精解：道具/食品/铁 布/土/材料 精彩贴图
15.组合 一般规则/特殊禁忌 案例精解：花纹/斜线/图案 精彩贴图
16.透明 一般规则/特殊禁忌 案例精解：交叉/强调/空间 融合/独立/立体 精彩贴图 17.靠近 一般规则/特殊禁忌 案例精解：对比/装饰/节奏 重复/多重/强调 精彩贴图 18.同化 一般规则/特殊禁忌 案例精解：草地/人物/点线 图形/借助/强调 精彩贴图
=============================================================
三、字体风格
19.英文标志 一般规则/特殊禁忌 案例精解：流水/向上/重叠 轻松/金属/简洁 精彩贴图
20.汉字 一般规则/特殊禁忌 案例精解：书体/可爱/重叠 艺术/线形/菱形 精彩贴图 21.宋体 一般规则/特殊禁忌 案例精解：历史/旅馆/介绍 辞典/茶/酒 精彩贴图
22.手写体 一般规则/特殊禁忌 案例精解：纯净/潇洒/童趣 自然/精神/可爱 精彩贴图 23.美术字 一般规则/特殊禁忌 案例精解：肌理/线条/花 精彩贴图
24.粗细对比 一般规则/特殊禁忌 案例精解：渐变/快乐/节奏 精彩贴图
25.大小对比 一般规则/特殊禁忌 案例精解：动感/呼应/发射 精彩贴图
26.字体对比 一般规则/特殊禁忌 案例精解：宋体&多体/黑体&变形 变形&手写体/黑体&宋体 变形&宋体/黑体&美术体 精彩贴图四、字体运用
27.日常生活体 一般规则/特殊禁忌 案例精解：明快/轻松/美化 精彩贴图
28.感觉 一般规则/特殊禁忌 案例精解：热气/竹子/童趣 残缺/冷色/古朴 精彩贴图 29.可爱 一般规则/特殊禁忌 案例精解：简单/一笔体/立体 图骺/细小/拼贴 精彩贴图 30.男性 一般规则/特殊禁忌 案例精解：单一/颜色/粗壮 直线/明确/简洁 精彩贴图 31.女性 一般规则/特殊禁忌 案例精解：细纤/细小/变形 粉红/可爱/精致 精彩贴图 32.字与面 一般规则/特殊禁忌 案例精解：点/多层/形状 渐变/重量/粗壮 精彩贴图
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>字体设计-日本最新设计模板
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>插画设计-日本最新设计模板
一、表现技法
1．手绘
一般规则/特殊禁忌
案例精解：线条/自然/轻松/青春
可爱/精神/特别/自由
精彩贴图
2．肖像
一般规则/特殊禁忌
案例精解：线条/色块/朴素/漫画
特写/青年/写真/美人
精彩贴图
3．立体
一般规则/特殊禁忌
案例精解：动感/剪贴/单纯/夸张
木质/卡通/童话/色彩
精彩贴图
4．浮雕
一般规则/特殊禁忌
案例精解：淡雅/材料/梦幻/明快
漫画/模型/拼贴/装饰
精彩贴图
5．动漫
一般规则/特殊禁忌
案例精解：游戏/快乐/少女
少男/人与动物
拟人/连续/平面
精彩贴图
6．影视
一般规则/特殊禁忌
案例精解：生活/拟人/食物/漫画
卡通/互动/简单/连续
精彩贴图
7．网页
一般规则/特殊禁忌
案例精解：怪物/童话/吉祥物
邀请/简单/常规
导游/抽象
精彩贴图
8．电脑
一般规则/特殊禁忌
案例精解：游戏/场景/人物
吉祥物/怪物/创意
摄影/动漫
精彩贴图
9．当代
一般规则/特殊禁忌
案例精解：图形/立体/展示/拼贴
面与线/肖像/车/材质
精彩贴图
三、平面应用
10．辞典
一般规则/特殊禁忌
案例精解：对比/古典/木雕/模型
水彩画/工笔
超级写实/透明
精彩贴图
11．摄影
一般规则/特殊禁忌
案例精解：综合/时代/幽默/卡通
环境/衬托/气氛/线描
精彩贴图
12．杂志
一般规则/特殊禁忌
案例精解：夸张/肖像/快乐/随意
写实/水彩/设计/色块
精彩贴图
13．书
一般规则/特殊禁忌
案例精解：人物/场景/装饰/肖像
梦幻/构成/童话/图寨
精彩贴图
14．文章
一般规则/特殊禁忌
案例精解：黑白/豪华/气氛
读物/活跃/明信片
说明/线条
精彩贴图
15．儿童读物
一般规则/特殊禁忌
案例精解：欢笑/童话/主题/故事
动物/简单/读物/童趣
精彩贴图
16．年历
一般规则/特殊禁忌
案例精解：卡通/抽象/装饰/丰富
立体/组合/幻想/色彩
精彩贴图
17．CD、DVD
一般规则/特殊禁忌
案例精解：组合/卡通/动物
迪斯尼/软件/剧情
图案/歌手
精彩贴图
18．标志
一般规则/特殊禁忌
案例精解：线条/传统/怪物/拟人
快乐/气氛/人物/鸟
精彩贴图
19．VI
一般规则/特殊禁忌
案例精解：文件/文档/挂件
日常用品/包装材料
卫生用品/车子/奖品
精彩贴图
20．广告
一般规则/特殊禁忌
案例精解：剪影/文静/立体/五彩
卡通/配角/图案/装饰
精彩贴图
21．电影
一般规则/特殊禁忌
案例精解：幽默/夸张/重复/清新
中心/组合/气氛/简单
精彩贴图
22．戏剧
一般规则/特殊禁忌
案例精解：写实/图案/人物/道具
环境/写真&插画
构成/传统
精彩贴图
三、立体应用
23．吉祥物
一般规则/特殊禁忌
案例精解：帽于/朋友/成长
组画/ON&OFF
怪物/水果/蔬菜
精彩贴图
24．包装
一般规则/特殊禁忌
案例精解：金属/塑料/卡通/丰富
透明/系列/传统/饮料
精彩贴图
25．瓶贴
一般规则/特殊禁忌
案例精解：卡通/常规/互动/整体
点缀/吊牌/主角/个性
精彩贴图
26．服饰
一般规则/特殊禁忌
案例精解：电脑/手绘/青年/版画
配套/绘画/张扬/人像
精彩贴图
27．橱窗
一般规则/特殊禁忌
案例精解：几何/构成/动＆静
古纹/材料/人物
移植/画廊
精彩贴图
28．展示
一般规则/特殊禁忌
案例精解：平面/立体/店头
壁面/人物/仿生
灯箱/入口
精彩贴图
29．室外
一般规则/特殊禁忌
案例精解：艺术/气氛/幽默/装饰

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>插画设计-日本最新设计模板
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java应用架构设计
本书赞誉
译者序
序
序
前言
第一部分 模块化的理由
第1章 模块定义
1.1 定义模块
1.1.1 可部署
1.1.2 可管理
1.1.3 可测试
1.1.4 原生可重用
1.1.5 可组合
1.1.6 无状态
1.2 软件模块的简洁定义
1.3 结论
第2章 模块化的两个方面
2.1 运行时模型
2.2 开发模型
2.2.1 编程模型
2.2.2 设计范式
2.3 模块化现状
2.4 结论
第3章 架构与模块化
3.1 定义架构
3.2 关于软件架构的一个故事
3.2.1 象牙塔
3.2.2 乌龟和塔
3.3 架构的目标
3.3.1 悖论
3.3.2 消除架构
3.4 模块化：被忽视的部分
3.5 回答我们的问题
3.6 结论
3.7 参考文献
第4章 征服复杂性
4.1 企业级复杂性
4.2 技术债
4.3 设计腐化
4.3.1 干扰可维护性
4.3.2 阻止可扩展性
4.3.3 抑制可重用性
4.3.4 限制可测试性
4.3.5 妨碍集成
4.3.6 阻碍理解
4.4 循环依赖
4.4.1 循环类型
4.4.2 悄然引入的循环
4.4.3 管理循环
4.4.4 循环总是不好的吗
4.5 结合点、模块和SOLID
4.6 管理复杂性
4.7 模块化的益处
4.8 结论
4.9 参考文献
第5章 实现重用
5.1 可用重用悖论
5.2 关于重用的免责声明
5.2.1 粒度
5.2.2 重量级
5.3 重用还是可用
5.4 模块化权衡
5.5 模块化设计
5.6 结论
5.7 参考文献
第6章 模块化与SOA
6.1 重新审视“自上而下”
6.2 粒度——架构师的强大对手
6.2.1 现实世界的一个例子
6.2.2 提升一个等级
6.2.3 另一个维度
6.2.4 全景图
6.2.5 服务样例
6.3 另一个视图
6.4 结论
第7章 参考实现
7.1 为什么不用OSGi
7.2 这个练习的背景：构建系统
7.3 初始版本
7.4 第一次重构
7.5 第二次重构
7.6 第三次重构
7.7 第四次重构
7.7.1 关于OSGi的好处
7.7.2 小结并准备下一次重构
7.8 第五次重构
7.9 第六次重构
7.10 第七次重构
7.11 事后剖析
7.11.1 关于模块测试
7.11.2 关于管理模块依赖
7.11.3 关于模块重用
7.11.4 关于构建
7.11.5 关于面向对象
7.12 结论
7.13 参考文献
第二部分 模 式
第8章 基本模式
8.1 管理关系
8.1.1 表述
8.1.2 描述
8.1.3 多种实现
8.1.4 影响
8.1.5 样例
8.1.6 小结
8.2 模块重用
8.2.1 表述
8.2.2 描述
8.2.3 多种实现
8.2.4 效果
8.2.5 样例
8.2.6 小结
8.3 模块内聚
8.3.1 表述
8.3.2 描述
8.3.3 多种实现
8.3.4 效果
8.3.5 样例
8.3.6 小结
第9章 依赖模式
9.1 非循环关系
9.1.1 表述
9.1.2 描述
9.1.3 多种实现
9.1.4 效果
9.1.5 样例
9.1.6 小结
9.2 等级化模块
9.2.1 表述
9.2.2 描述
9.2.3 多种实现
9.2.4 效果
9.2.5 样例
9.2.6 小结
9.3 物理分层
9.3.1 表述
9.3.2 描述
9.3.3 多种实现
9.3.4 效果
9.3.5 样例
9.3.6 小结
9.4 容器独立
9.4.1 表述
9.4.2 描述
9.4.3 多种实现
9.4.4 效果
9.4.5 样例
9.4.6 小结
9.5 独立部署
9.5.1 表述
9.5.2 描述
9.5.3 多种实现
9.5.4 效果
9.5.5 样例
9.5.6 小结
9.6 参考文献
第10章 可用性模式
10.1 发布接口
10.1.1 表述
10.1.2 描述
10.1.3 多种实现
10.1.4 效果
10.1.5 样例
10.1.6 小结
10.2 外部配置
10.2.1 表述
10.2.2 描述
10.2.3 多种实现
10.2.4 效果
10.2.5 样例
10.2.6 小结
10.3 默认实现
10.3.1 表述
10.3.2 描述
10.3.3 多种实现
10.3.4 效果
10.3.5 样例
10.3.6 小结
10.4 模块门面
10.4.1 表述
10.4.2 描述
10.4.3 多种实现
10.4.4 效果
10.4.5 样例
10.4.6 小结
第11章 扩展性模式
11.1 抽象化模块
11.1.1 表述
11.1.2 描述
11.1.3 多种实现
11.1.4 效果
11.1.5 样例
11.1.6 小结
11.2 实现工厂
11.2.1 表述
11.2.2 描述
11.2.3 多种实现
11.2.4 效果
11.2.5 样例
11.2.6 小结
11.3 分离抽象
11.3.1 表述
11.3.2 描述
11.3.3 多种实现
11.3.4 效果
11.3.5 样例
11.3.6 小结
11.4 参考文献
第12章 通用模式
12.1 就近异常
12.1.1 表述
12.1.2 描述
12.1.3 多种实现
12.1.4 效果
12.1.5 样例
12.1.6 小结
12.2 等级化构建
12.2.1 表述
12.2.2 描述
12.2.3 多种实现
12.2.4 效果
12.2.5 样例
12.2.6 小结
12.3 测试模块
12.3.1 表述
12.3.2 描述
12.3.3 多种实现
12.3.4 效果
12.3.5 样例
12.3.6 小结  201
第三部分 模块化架构模式与OSGi
第13章 OSGi简介
13.1 一点历史
13.2 OSGi所能带来的收益
13.2.1 模块化开发
13.2.2 管理依赖
13.2.3 模块平台
13.2.4 版本化的bundle
13.2.5 动态（重）部署
13.2.6 环境相关的控制
13.3 深入理解OSGi
13.4 OSGi bundle
13.4.1 bundle状态
13.4.2 OSGi Service
13.5 OSGi运行时管理
13.6 重新查看模块化的两个方面
13.7 OSGi与模式
13.7.1 管理依赖
13.7.2 动态性
13.7.3 Blueprint规范
第14章 贷款样例与OSGi
14.1 起步
14.2 清单文件
14.3 Service
14.3.1 Blueprint服务
14.3.2 贷款样例配置
14.3.3 OSGi Service声明
14.4 安装与执行
14.5 结论
第15章 OSGi与Scala
15.1 起步
15.2 Scala代码
15.3 Scala bean配置
15.4 Scala Service配置
15.5 构建Scala模块
15.6 安装与执行
15.7 结论
第16章 OSGi与Groovy
16.1 起步
16.2 Groovy代码
16.3 Groovy bean配置
16.4 Groovy Service配置
16.5 构建Groovy模块
16.6 安装与执行
16.7 结论
第17章 OSGi的未来
17.1 将OSGi作为推动者
17.2 颠覆性
17.3 生态系统的威力
17.3.1 生态系统与模块化的两个方面
17.3.2 基于组件的开发（CBD）不是已经成功了吗
17.4 生态系统
17.5 结论
附录A 类设计的SOLID原则
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java应用架构设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>景观生态绿化工程设计模式研究
前言
第一篇电厂景观生态红化工程设计模式
第1章电厂周边生态系统特征解析
1??1周边生态系统域值界定
1??2周边生态系统变迁和发展趋向
1??3气候特征
1??4地貌类型
1??5水文特征与动态
1??6土壤环境
1??7植被类型与分布
1??8生物多样性
1??9土地利用现状
1??10森林资源状况
1??11土地荒漠化现状和发展态势
1??12社会经济结构和发展

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>景观生态绿化工程设计模式研究
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件设计精要与模式
第1篇 设计之要
第1章 设计之道
第2章 封装变化
第3章 体验重构
第4章 测试驱动开发实践
第5章 设计，由你掌握
第2篇 net framework与设计模式
第6章 framework模式
第7章 composite模式
第8章 decorator模式
第9章 lterator模式
第10章 strategy模式
第3篇 媒体播放器的设计之旅
第11章 面向对象设计与framework模式
第12章 探讨adapter模式
第13章 从adapter模式到decorator模式
第14章 visitor模式探索
第15章 再谈adapter模式
第4篇 设计模式应用实践
第16章 abstract factory模式应用实践
第17章 buider模式应用实践
第18章 command模式应用实践
第19章 chain of responsibility模式应用实践
第20章 observer模式应用实践
第21章 proxy模式应用实践
第22章 复合的设计模式应用实践
第5篇 net体系架构设计
第23章 软件体系架构设计
第24章 数据访问层设计
第25章 消息处理
第26章 asp.net缓存
第27章 业务逻辑层设计
第28章 表示层设计
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件设计精要与模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>室内设计模型制作
技巧篇1.制作锉磨平面的工具2.制作锉磨大圆角用的工具3.制作锉磨直角或圆形的工具4.制作速干胶水专用的滴管5.用酒精稀释聚苯乙烯胶水的方法6.制作上下弯曲自由的吸管7.用中性洗涤剂稀释木工粘合剂8.用含聚苯乙烯的木工油灰泥填补划痕或小孔9.堆砌木工油灰泥10.用稀释后的木工油灰泥修补聚苯乙烯材料表面的划痕，并使其表面呈现光滑11.填补模型表面的小洞和划痕12.填补外拐角处的裂缝13.填补内角裂缝的方法14.聚酯油灰泥表面裂缝的涂装方法15.切割较大的圆形和曲面16.利用复制的方式制作圆规17.测量不规则地板的具体尺寸18.制作不同颜色的地板19.用热水弯曲板材20.二次玻璃曲面的制作方法21.用热压法制作材料曲面22.用热加工法弯曲制作直角23.为白色模型准备材料24.利用混合喷漆颜料制作中间色调25.使颜色的喷雾粒子加粗的方法26.不溶和性材料的着色处理制作篇1.大理石模型的制作方法(玫瑰茶色效果)2.大理石模型的制作方法(万寿红效果)3.水磨石模型的制作方法(晶体图案效果)4.大理石模型的制作方法(水纹效果)5.白色花岗岩效果的制作方法6.制作表面感觉粗糙的大理石效果7.在圆柱及曲面上制作大理石的效果8.制作表面带有棋盘格图案的大理石效果9.将石纹进行粘贴后的效果10.制作水泥材料般的质感11.制作表面有铁钉感觉的混凝土墙12.混凝土块的制作方法13.瓷砖的制作方法14.碎花瓷砖的制作方法15.任意性花纹饰面的制作方法16.砖墙的制作方法17.经过烧制的砖块的制作方法18.石块建筑模型的制作方法19.在石块铺面的接缝中加上青苔效果的制作方法20.风化后的残垣断壁的制作方法21.砂岩石材的制作方法22.古埃及石材的制作方法23.地板材料的制作方法24.用日本桧木制作光面木材的方法25.用日本桧木制作表面近似白色的地板26.马赛克瓷砖效果的制作方法27.椅子的制作方法28.高脚凳的制作方法29.用氯乙烯板制作简单桌椅的方法30.光面木椅的制作方法31.欧式椅子的制作方法32.外翻腿的椅子制作方法33.皮革椅子的制作方法34.沙发的制作方法(I)35.沙发的制作方法(II)36.沙发的制作方法(III)37.椅子和沙发的作品展示方法38.橱柜的制作方法39.橱柜作品的展示方法40.厨房的制作方法41.靠垫的制作方法(I)(带有花边的沙发靠垫)42.靠垫的制作方法(II)(中间有凹凸纹样的靠垫)43.坐垫的制作方法44.窗帘的制作方法45.窗帘导轨的制作方法46.白色双垫床的制作方法47.床的制作方法(I)48.床的制作方法(II)(边缘带有花边的床)49.桌布的制作方法50.立式台灯的制作方法51.洗脸池的制作方法52.水龙头的制作方法53.抽水马桶的制作方法54.男用小便池的制作方法55.浴缸的制作方法56.橡胶模具的制作以及复制模型的方法(单面型开放模)57.组合型模具的制作方法(双面型套模)58.淡烟色玻璃的制作方法(含透明部分)59.磨砂玻璃的制作方法60.带几何图案变化的玻璃板的制作方法61.玻璃效果的制作方法62.圆柱类模型的制作方法(凸肚状圆柱)63.树木的制作方法64.盆景植物模型的制作方法65.行道树和绿化街的制作方法模型作品案例为作者写的几句话模型使用的材料介绍作者后记作者简介
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>室内设计模型制作
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>多设备体验设计
前言　　ix
第1章　设备互联的生态系统　　1
1.1　何谓生态系统　　2
1.2　3C框架：一致性、连续性和互补性　　3
1.3　基于单个设备的设计已成往事（还用你说！）　　6
1.3.1　智能手机，你好！　　7
1.3.2　App Store，你好！　　8
1.3.3　平板，你好！　　12
1.4　我们造了一个生态系统　　13
1.5　小结　　14
第2章　一致性设计方法　　15
2.1　何谓一致性设计　　15
2.1.1　优化一致性体验　　17
2.1.2　保持核心体验的一致　　20
2.2　极简交互界面下的一致性：Google Search　　23
2.2.1　设备间的一致体现在哪里　　24
2.2.2　对具体设备做了哪些优化　　26
2.3　一致性中的渐进式：Trulia　　28
2.3.1　设备间的一致体现在哪　　29
2.3.2　对具体设备做了哪些优化　　29
2.4　超越设备的可用性：Hulu Plus　　33
2.5　多设备只是途径，不是目的　　35
2.6　小结　　36
第3章　连续性设计方法　　38
3.1　何谓连续性设计　　38
3.2　单任务流　　40
3.2.1　观影体验的流媒体化：Apple AirPlay　　40
3.2.2　流畅的内容消费体验：Amazon Kindle　　42
3.2.3　内容创作和编辑流：Google Drive　　43
3.2.4　连续性体验和一致性体验间的联系　　44
3.3　系列任务流　　48
3.3.1　在设备中各取所长：Allrecipes　　49
3.3.2　让体验适应动态需求：Eventbrite　　51
3.3.3　现实世界与数字世界的桥梁：POP　　61
3.3.4　在开放平台上扩展连续性体验：Pocket　　62
3.4　小结　　66
第4章　互补性设计方法　　68
4.1　何谓互补性设计　　68
4.2　合作：必备设备　　70
4.2.1　和朋友一起玩乐：Real Racing 2—Party Play　　70
4.2.2　社交游戏的数字化：Scrabble for iPad—Party Play　　73
4.2.3　整合必备设备和优化性设备：Pad Racer　　75
4.2.4　不只为多人游戏设计：KL Dartboard　　77
4.3　合作：优化性设备　　78
4.3.1　收视之上的社交层：Heineken Star Player　　79
4.3.2　将第二屏体验化为平台：IntoNow　　81
4.3.3　尝试共同观影体验：复仇者联盟　　85
4.4　控制：优化性设备　　87
4.4.1　非同步性的体验：Slingbox　　87
4.4.2　当合作与控制相遇：Xbox SmartGlass　　88
4.5　这些迷人的使用案例对我的设计工作有何意义　　90
4.6　小结　　91
4.7　3C 设计框架总结　　91
第5章　整合设计方法　　94
5.1　把3C 设计框架当成设计的砖石　　94
5.1.1　多设备体验仍在发展的初期　　96
5.1.2　用户的需求并不是非黑即白　　97
5.1.3　出色的设备会带来高期待　　98
5.1.4　多设备体验设计：该做的和不该做的　　99
5.2　整合性方法：重新审视我们的案例　　100
5.2.1　互补性与一致性设计方法：Slingbox　　100
5.2.2　连续性和一致性：Allrecipes　　102
5.2.3　描述生态系统　　107
5.2.4　互补性、一致性和连续性：Hulu Plus、Wii U 和Xbox Smartglass　　109
5.3　整合设计方法：从新视角看新案例　　113
5.3.1　互补性与一致性设计方法：Withings 智能婴儿监控器　　114
5.3.2　互补性与一致性设计方法：Bitponics　　115
5.3.3　当互补性设计遇到一致性设计　　116
5.4　小结　　117
第6章　超越核心设备　　118
6.1　物联网　　118
6.2　物联网时代来了吗　　120
6.3　3C 设计框架的扩展　　121
6.3.1　适应性设计：Nest——会学习的恒温调节器　　121
6.3.2　让智能手机更强大：BiKN　　123
6.3.3　重新思考用户行为：Square　　125
6.3.4　整合的多设备体验：Nike+　　132
6.3.5　基于可穿戴设备的体验：Pebble Watch　　137
6.3.6　涉足服务设计：乐购虚拟超市　　140
6.3.7　增强现实（Augment Reality，AR）：2013 年的宜家产品录　　143
6.3.8　多设备（开放）平台：SmartThings　　145
6.4　小结　　152
第7章　多设备分析　　154
7.1　用户数据就是用户反馈　　154
7.1.1　事实胜于雄辩　　155
7.1.2　我们应该如何收集数据　　158
7.2　多设备分析　　160
7.2.1　一致性：将现有分析范式应用在设备之中　　161
7.2.2　互补性和连续性：将分析扩展到新的领域　　162
7.3　额外的分析考量　　169
7.3.1　电视与社交分析　　169
7.3.2　测量生态系统的投资收益率　　170
7.4　小结　　173
第8章　转变挑战　　174
8.1　生态系统设计和开发的挑战　　175
8.1.1　企业合作的挑战　　175
8.1.2　围墙花园的挑战　　177
8.1.3　资源和营销时机的挑战　　178
8.2　生态系统不会一夜间出现　　179
8.3　生态系统适应的挑战　　183
8.3.1　建立和启动生态系统的挑战　　183
8.3.2　应用过载的挑战　　188
8.4　同心生态系统　　189
8.4.1　生态系统与我的初心　　190
8.4.2　同心生态系统模范　　192
8.4.3　个性化可以（将会）走得更远　　194
8.5　混乱新（人类）世界　　199
8.6　小结　　200
附录　企业、产品与链接　　202
关于作者　　205
封面介绍　　205
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>多设备体验设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>统计模式识别
第1章 统计模式识别绪论
1.1 统计模式识别
1.1.1 引言
1.1.2 基本模型
1.2 解决模式识别问题的步骤
1.3 问题讨论
1.4 统计模式识别的方法
1.5 基本决策理论
1.5.1 最小错误贝叶斯决策规则
1.5.2 最小错误贝叶斯决策规则——拒绝分类
1.5.3 最小风险贝叶斯决策规则
1.5.4 最小风险贝叶斯决策规则——拒绝分类
1.5.5 NeymanPearson决策规则
1.5.6 最小最大决策
1.5.7 讨论
1.6 判别函数
1.6.1 引言
1.6.2 线性判别函数
1.6.3 分段线性判别函数
1.6.4 广义线性判别函数
1.6.5 小结
1.7 多重回归
1.8 本书梗概
1.9 提示及参考文献
习题
第2章 密度估计的参数法
2.1 引言
2.2 分布参数估计
2.2.1 估计法
2.2.2 预测法
2.3 高斯分类器
2.3.1 详述
2.3.2 高斯分类器插入估计的推导
2.3.3 应用研究举例
2.4 处理高斯分类器的奇异问题
2.4.1 引言
2.4.2 朴素贝叶斯
2.4.3 投影到子空间
2.4.4 线性判别函数
2.4.5 正则化判别分析
2.4.6 应用研究举例
2.4.7 拓展研究
2.4.8 小结
2.5 有限混合模型
2.5.1 引言
2.5.2 混合判别模型
2.5.3 正态混合模型的参数估计
2.5.4 正态混合模型协方差矩阵约束
2.5.5 混合模型分量的数量
2.5.6 期望最大化算法下的极大似然估计
2.5.7 应用研究举例
2.5.8 拓展研究
2.5.9 小结
2.6 应用研究
2.7 总结和讨论
2.8 建议
2.9 提示及参考文献
习题
第3章 密度估计的贝叶斯法
3.1 引言
3.1.1 基本原理
3.1.2 递归计算
3.1.3 比例性
3.2 解析解
3.2.1 共轭先验概率
3.2.2 方差已知的正态分布的均值估计
3.2.3 多元正态分布的均值及协方差矩阵估计
3.2.4 未知类先验概率的情形
3.2.5 小结
3.3 贝叶斯采样方案
3.3.1 引言
3.3.2 梗概
3.3.3 贝叶斯分类器的采样类型
3.3.4 拒绝采样
3.3.5 均匀比
3.3.6 重要性采样
3.4 马尔可夫链蒙特卡罗方法
3.4.1 引言
3.4.2 吉布斯(Gibbs)采样器
3.4.3 MetropolisHastings算法
3.4.4 数据扩充
3.4.5 可逆跳跃马尔可夫链蒙特卡罗方法
3.4.6 切片采样
3.4.7 MCMC举例——正弦噪声估计
3.4.8 小结
3.4.9 提示及参考文献
3.5 贝叶斯判别方法
3.5.1 标记训练数据
3.5.2 无类别标签的训练数据
3.6 连续蒙特卡罗采样
3.6.1 引言
3.6.2 基本方法
3.6.3 小结
3.7 变分贝叶斯方法
3.7.1 引言
3.7.2 描述
3.7.3 分解为因子的变分近似
3.7.4 简单的例子
3.7.5 模型选择中的运用
3.7.6 拓展研究与应用
3.7.7 小结
3.8 近似贝叶斯计算
3.8.1 引言
3.8.2 ABC拒绝采样
3.8.3 ABC MCMC采样
3.8.4 ABC总体蒙特卡罗采样
3.8.5 模型选择
3.8.6 小结
3.9 应用研究举例
3.10应用研究
3.11总结和讨论
3.12建议
3.13提示及参考文献
习题
第4章 密度估计的非参数法
4.1 引言
4.1.1 密度估计的基本性质
4.2 k近邻法
4.2.1 k近邻分类器
4.2.2 推导
4.2.3 距离度量的选择
4.2.4 最近邻法决策规则的性质
4.2.5 线性逼近排除搜索算法
4.2.6 分支定界搜索算法： kd树
4.2.7 分支定界搜索算法： ball树
4.2.8 剪辑方法
4.2.9 应用研究举例
4.2.10拓展研究
4.2.11小结
4.3 直方图法
4.3.1 直方图自适应数据
4.3.2 独立性假设（朴素贝叶斯）
4.3.3 Lancaster模型
4.3.4 最大权值相关树
4.3.5 贝叶斯网络
4.3.6 应用研究举例： 朴素贝叶斯文本分类
4.3.7 小结
4.4 核函数方法
4.4.1 有偏估计
4.4.2 延伸到多元
4.4.3 平滑参数的选择
4.4.4 核函数的选择
4.4.5 应用研究举例
4.4.6 拓展研究
4.4.7 小结
4.5 用基函数展开
4.6 copula方法
4.6.1 引言
4.6.2 数学基础
4.6.3 copula函数
4.6.4 copula概率密度函数的估计
4.6.5 简单举例
4.6.6 小结
4.7 应用研究
4.7.1 比较研究
4.8 总结和讨论
4.9 建议
4.10提示及参考文献
习题
第5章 线性判别分析
5.1 引言
5.2 两类问题算法
5.2.1 总体思路
5.2.2 感知准则
5.2.3 Fisher准则
5.2.4 最小均方误差法
5.2.5 拓展研究
5.2.6 小结
5.3 多类算法
5.3.1 总体思路
5.3.2 错误修正法
5.3.3 Fisher准则：线性判别分析
5.3.4 最小均方误差法
5.3.5 正则化
5.3.6 应用研究实例
5.3.7 拓展研究
5.3.8 小结
5.4 支持向量机
5.4.1 引言
5.4.2 两类线性可分数据问题
5.4.3 两类线性不可分数据问题
5.4.4 多类支持向量机
5.4.5 支持向量机回归
5.4.6 具体实施
5.4.7 应用研究举例
5.4.8 小结
5.5 logistic判别
5.5.1 两类问题
5.5.2 极大似然估计
5.5.3 多类logistic判别
5.5.4 应用研究举例
5.5.5 拓展研究
5.5.6 小结
5.6 应用研究
5.7 总结和讨论
5.8 建议
5.9 提示及参考文献
习题
第6章 非线性判别分析——核与投影法
6.1 引言
6.2 径向基函数
6.2.1 引言
6.2.2 模型的确定
6.2.3 指定函数的形式
6.2.4 中心位置
6.2.5 平滑参数
6.2.6 权值的计算
6.2.7 模型阶次的选择
6.2.8 简单径向基函数
6.2.9 一些调整
6.2.10径向基函数的性质
6.2.11应用研究举例
6.2.12拓展研究
6.2.13小结
6.3 非线性支持向量机
6.3.1 引言
6.3.2 二分类
6.3.3 核函数的类型
6.3.4 模型选择
6.3.5 多类支持向量机
6.3.6 概率估计
6.3.7 非线性回归
6.3.8 应用研究举例
6.3.9 拓展研究
6.3.10小结
6.4 多层感知器
6.4.1 引言
6.4.2 多层感知器结构的确定
6.4.3 多层感知器权值的确定
6.4.4 多层感知器的建模能力
6.4.5 logistic分类
6.4.6 应用研究举例
6.4.7 贝叶斯多层感知器网络
6.4.8 投影寻踪
6.4.9 小结
6.5 应用研究
6.6 总结和讨论
6.7 建议
6.8 提示及参考文献
习题
第7章 规则和决策树归纳法
7.1 引言
7.2 决策树
7.2.1 引言
7.2.2 决策树的构造
7.2.3 拆分规则的选择
7.2.4 终止拆分过程
7.2.5 为终端节点分配类标签
7.2.6 决策树剪枝（含实施示例）
7.2.7 决策树构造方法
7.2.8 其他问题
7.2.9 应用研究举例
7.2.10拓展研究
7.2.11小结
7.3 规则归纳
7.3.1 引言
7.3.2 从决策树生成规则
7.3.3 用连续覆盖算法进行规则归纳
7.3.4 应用研究举例
7.3.5 拓展研究
7.3.6 小结
7.4 多元自适应回归样条
7.4.1 引言
7.4.2 递归分割模型
7.4.3 应用研究举例
7.4.4 拓展研究
7.4.5 小结
7.5 应用研究
7.6 总结和讨论
7.7 建议
7.8 提示及参考文献
习题
第8章 组合方法
8.1 引言
8.2 分类器组合方案特性
8.2.1 特征空间
8.2.2 层次
8.2.3 训练程度
8.2.4 成员分类器的形式
8.2.5 结构
8.2.6 优化
8.3 数据融合
8.3.1 体系结构
8.3.2 贝叶斯方法
8.3.3 奈曼皮尔逊(NeymanPearson)公式
8.3.4 可训练规则
8.3.5 固定规则
8.4 分类器组合方法
8.4.1 乘积规则
8.4.2 和式规则
8.4.3 最小、最大及中值组合分类器
8.4.4 多数表决
8.4.5 Borda数
8.4.6 在类别预测上训练组合分类器
8.4.7 叠加归纳
8.4.8 专家混合器
8.4.9 bagging
8.4.10boosting
8.4.11随机森林
8.4.12模型平均
8.4.13方法小结
8.4.14应用研究举例
8.4.15拓展研究
8.5 应用研究
8.6 总结和讨论
8.7 建议
8.8 提示及参考文献
习题
第9章 性能评价
9.1 引言
9.2 性能评价
9.2.1 性能测度
9.2.2 判别力
9.2.3 可靠性
9.2.4 用于性能评价的ROC曲线
9.2.5 总体漂移和传感漂移
9.2.6 应用研究举例
9.2.7 拓展研究
9.2.8 小结
9.3 分类器性能的比较
9.3.1 哪种方法最好
9.3.2 统计检验
9.3.3 错分代价不定情况下的比较规则
9.3.4 应用研究举例
9.3.5 拓展研究
9.3.6 小结
9.4 应用研究
9.5 总结和讨论
9.6 建议
9.7 提示及参考文献
习题
第10章 特征选择与特征提取
10.1 引言
10.2 特征选择
10.2.1 引言
10.2.2 对特征选择方法的表述
10.2.3 评估方法
10.2.4 选择特征子集的搜索算法
10.2.5 全搜索： 分支定界法
10.2.6 顺序搜索
10.2.7 随机搜索
10.2.8 马尔可夫覆盖
10.2.9 特征选择的稳定性
10.2.10应用研究举例
10.2.11拓展研究
10.2.12小结
10.3 线性特征提取
10.3.1 主成分分析
10.3.2 KarhunenLoève变换
10.3.3 应用研究举例
10.3.4 拓展研究
10.3.5 小结
10.4 多维尺度分析
10.4.1 经典尺度分析
10.4.2 计量多维尺度
10.4.3 次序尺度分析
10.4.4 算法
10.4.5 用于特征提取的多维尺度分析
10.4.6 应用研究举例
10.4.7 拓展研究
10.4.8 小结
10.5 应用研究
10.6 总结和讨论
10.7 建议
10.8 提示及参考文献
习题
第11章 聚类
11.1 引言
11.2 分层聚类法
11.2.1 单链接方法
11.2.2 完全链接方法
11.2.3 平方和方法
11.2.4 通用合并算法
11.2.5 分层聚类法的性质
11.2.6 应用研究举例
11.2.7 小结
11.3 快速分类
11.4 混合模型
11.4.1 模型描述
11.4.2 应用研究举例
11.5 平方和方法
11.5.1 聚类准则
11.5.2 聚类算法
11.5.3 矢量量化
11.5.4 应用研究举例
11.5.5 拓展研究
11.5.6 小结
11.6 谱聚类
11.6.1 图论初步
11.6.2 相似矩阵
11.6.3 聚类应用
11.6.4 谱聚类算法
11.6.5 拉普拉斯矩阵的形式
11.6.6 应用研究举例
11.6.7 拓展研究
11.6.8 小结
11.7 聚类有效性
11.7.1 引言
11.7.2 统计检验
11.7.3 缺失类结构
11.7.4 各聚类的有效性
11.7.5 分级聚类
11.7.6 各单聚类的有效性
11.7.7 划分
11.7.8 相关准则
11.7.9 选择聚类个数
11.8 应用研究
11.9 总结和讨论
11.10建议
11.11提示及参考文献
习题
第12章 复杂网络
12.1 引言
12.1.1 特征
12.1.2 属性
12.1.3 问题阐述
12.1.4 描述性特征
12.1.5 概要
12.2 网络的数学描述
12.2.1 图矩阵
12.2.2 连通性
12.2.3 距离测度
12.2.4 加权网络
12.2.5 中心测度
12.2.6 随机图
12.3 社区发现
12.3.1 聚类方法
12.3.2 GirvanNewman算法
12.3.3 模块化方法
12.3.4 局部模块化
12.3.5 小集团过滤
12.3.6 应用研究举例
12.3.7 拓展研究
12.3.8 小结
12.4 链路预测
12.4.1 链路预测方法
12.4.2 应用研究举例
12.4.3 拓展研究
12.5 应用研究
12.6 总结和讨论
12.7 建议
12.8 提示及参考文献
习题
第13章 其他论题
13.1 模型选择
13.1.1 相互独立的训练集与测试集
13.1.2 交叉验证
13.1.3 贝叶斯观点
13.1.4 Akaike信息准则
13.1.5 最短描述长度
13.2 缺值数据
13.3 离群值检测和鲁棒方法
13.4 连续变量与离散变量的混合
13.5 结构风险最小化和VapnikChervonenkis维数
13.5.1 期望风险边界
13.5.2 VapnikChervonenkis维数
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>统计模式识别
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>叠加体验：用互联网思维设计商业模式
赞　誉
推荐序
序　言　互联网思维开启叠加体验
第一章
三大商业变革催生互联网思维  // 1
第一节　消费变革  // 3
第二节　生产变革  // 7
第三节　交易变革  // 12
第四节　互联网思维是什么  // 18
第二章
用互联网思维设计商业模式  // 23
第一节　商业模式的前世今生  // 24
第二节　商业模式四要素  // 31
第三节　三重产品体验  // 43
第四节　叠加体验  // 58
第三章
第1种叠加模式：完美终端+价值群落  // 71
第一节　第1种模式分析  // 72
第二节　案例1：大V卖水果——有个性才有大未来  // 82
第三节　案例2：黄太吉和马佳佳——做对了什么  // 85
第四节　案例3：买买茶——从手游到茶叶  // 89
第五节　案例4：小米——灰度用户迭代  // 94
第四章
第2种叠加模式：完美终端+云端服务  // 101
第一节　第2种模式分析  // 102
第二节　案例5：电商三国杀——“砸钱抢人”戏难休  // 120
第三节　案例6：万达vs.万科——冲锋或做局  // 125
第四节　案例7：亚马逊——大数据打造极致体验  // 129
第五章
第3种叠加模式：价值群落+云端服务  // 137
第一节　第3种模式分析  // 138
第二节　案例8：罗辑思维——社群大时代  // 144
第三节　案例9：微信——社交席卷一切  // 151
第六章
第4种叠加模式：完美终端+云端服务+价值群落  // 159
第一节　第4种模式分析  // 160
第二节　案例10：聚美优品——云端有“花痴”  // 170
第三节　案例11：凡客诚品——冒进失好局  // 179
第七章
互联网思维对企业的忠告  // 189
第一节　互联网思维下商业模式的“法与术”  // 190
第二节　互联网思维下的商业模式之“道”  // 195
参考文献  // 200
后记  // 202
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>叠加体验：用互联网思维设计商业模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.NET设计规范
第1章 概述	1
1.1 精心设计的框架所具备的品质	2
1.1.1 精心设计的框架是简单的	2
1.1.2 精心设计的框架设计代价高	3
1.1.3 精心设计的框架充满利弊权衡	4
1.1.4 精心设计的框架应该借鉴过去的经验	4
1.1.5 精心设计的框架要考虑未来发展	4
1.1.6 精心设计的框架应具有良好的集成性	5
1.1.7 精心设计的框架是一致的	5
第2章 框架设计基础	7
2.1 渐进框架	9
2.2 框架设计的基本原则	12
2.2.1 围绕场景进行设计的原则	12
2.2.2 低门槛原则	18
2.2.3 自说明对象模型原则	22
2.2.4 分层架构原则	28
2.3 小结	30
第3章 命名规范	31
3.1 大小写约定	31
3.1.1 标识符的大小写规则	32
.3.1.2 首字母缩写词的大小写	34
3.1.3 复合词和常用术语的大小写	36
3.1.4 是否区分大小写	37
3.2 通用命名约定	38
3.2.1 单词的选择	38
3.2.2 使用单词缩写和首字母缩写词	40
3.2.3 避免使用编程语言特有的名字	41
3.2.4 为已有api的新版本命名	43
3.3 程序集和dll的命名	45
3.4 名字空间的命名	46
3.5 类、结构和接口的命名	50
3.5.1 泛型类型参数的命名	53
3.5.2 常用类型的命名	53
3.5.3 枚举类型的命名	54
3.6 类型成员的命名	56
3.6.1 方法的命名	56
3.6.2 属性的命名	57
3.6.3 事件的命名	58
3.6.4 字段的命名	59
3.7 参数的命名	60
3.8 资源的命名	61
3.9 小结	62
第4章 类型设计规范	63
4.1 类型和名字空间	65
4.2 类和结构之间的选择	70
4.3 类和接口之间的选择	73
4.4 抽象类的设计	79
4.5 静态类的设计	80
4.6 接口的设计	82
4.7 结构的设计	84
4.8 枚举的设计	86
4.8.1 标记枚举的设计	92
4.8.2 给枚举添加值	95
4.9 嵌套类型	97
4.10 类型和程序集元数据	98
4.11 小结	100
第5章 成员设计	101
5.1 成员设计的通用规范	101
5.1.1 成员重载	101
5.1.2 显式地实现接口成员	107
5.1.3 属性和方法之间的选择	110
5.2 属性的设计	115
5.2.1 索引属性的设计	117
5.2.2 当属性发生改变时的通知事件	119
5.3 构造函数的设计	121
5.4 事件的设计	128
5.5 字段的设计	134
5.6 扩展方法	136
5.7 操作符重载	142
5.7.1 重载operator==	146
5.7.2 类型转换操作符	146
5.8 参数的设计	147
5.8.1 枚举和布尔参数之间的选择	149
5.8.2 参数的验证	151
5.8.3 参数的传递	154
5.8.4 参数数量可变的成员	156
5.8.5 指针参数	159
5.9 小结	161
第6章 扩展性设计	162
6.1 扩展机制	162
6.1.1 非密封类	162
6.1.2 受保护的成员	164
6.1.3 事件与回调函数	165
6.1.4 虚成员	169
6.1.5 抽象（抽象类型与抽象接口）	171
6.2 基类	173
6.3 密封	174
6.4 小结	177
第7章 异常	178
7.1 抛出异常	182
7.2 为抛出的异常选择合适的类型	187
7.2.1 错误消息的设计	190
7.2.2 异常处理	191
7.2.3 封装异常	196
7.3 标准异常类型的使用	197
7.3.1 exception与systemexcep- tion	198
7.3.2 applicationexception	198
7.3.3 invalidoperationexception	198
7.3.4 argumentexception、argumentnullexception及argumentoutofrange-exception	199
7.3.5 nullreferenceexception、indexoutofrangeexception及accessviolationexception	199
7.3.6 stackoverflowexception	200
7.3.7 outofmemoryexception	201
7.3.8 comexception、sehexception以及executionengine-exception	202
7.4 自定义异常的设计	202
7.5 异常与性能	203
7.5.1 tester-doer模式	204
7.5.2 try-parse模式	205
7.6 小结	206
第8章 使用规范	207
8.1 数组	207
8.2 修饰属性	208
8.3 集合	211
8.3.1 集合参数	213
8.3.2 集合属性与返回值	214
8.3.3 数组与集合之间的选择	218
8.3.4 自定义集合的实现	218
8.4 datetime和datetimeoffset	220
8.5 icloneable	222
8.6 icomparable[t]与iequatable[t]	223
8.7 idisposable	225
8.8 nullable[t]	225
8.9 object	226
8.9.1 object.equals	226
8.9.2 object.gethashcode	228
8.9.3 object.tostring	229
8.10 序列化	231
8.10.1 选择要支持的序列化技术	232
8.10.2 对数据协定序列化的支持	233
8.10.3 对xml序列化的支持	237
8.10.4 对运行时序列化的支持	238
8.11 uri	239
8.12 system.xml的使用	241
8.13 相等性操作符	242
8.13.1 值类型的相等性操作符	243
8.13.2 引用类型的相等性操作符	243
第9章 常用的设计模式	244
9.1 聚合组件	244
9.1.1 面向组件的设计	245
9.1.2 因子类型	248
9.1.3 聚合组件规范	249
9.2 async模式	251
9.2.1 选择合适的async模式	251
9.2.2 经典async模式	253
9.2.3 async模式的基本实现样例	256
9.2.4 基于事件的async模式	257
9.2.5 对输出参数和引用参数的支持	259
9.2.6 对取消操作的支持	260
9.2.7 对进度报告的支持	260
9.2.8 对增量结果的支持	262
9.3 依赖属性	263
9.3.1 依赖属性的设计	264
9.3.2 附加依赖属性的设计	266
9.3.3 依赖属性的验证	267
9.3.4 依赖属性的改变通知	268
9.3.5 依赖属性的强制赋值	269
9.4 dispose模式	269
9.4.1 基本dispose模式	272
9.4.2 可终结类型	277
9.5 factory模式	281
9.6 对linq的支持	285
9.6.1 linq概要	285
9.6.2 支持linq的几种方法	286
9.6.3 通过ienumerable[t]来支持linq	287
9.6.4 通过iqueryable[t]来支持linq	287
9.6.5 通过query模式来支持linq	288
9.7 optional feature模式	291
9.8 simulated covariance模式	294
9.9 template method模式	299
9.10 超时	301
9.11 可供xaml使用的类型	303
9.12 结束语	305
附录a c#编程风格约定	306
附录b 通过fxcop来实施设计规范	313
附录c api规格书样例	343
术语表	350
推荐读物	354
索引	356
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.NET设计规范
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>塞氏企业
推荐序一  流行的管理与经典的管理
推荐序二  有趣的管理和无趣的管理
序 言  如何设计更睿智的未来
第一部分 转型探索
01 我们的政策就是没有政策
02 摇滚青年能做合格接班人吗
03 迪克博士的大清洗
04 多元化是错误的开始
05 进取再进取，收购再收购
06 在挫折中保持平衡
07 收购霍巴特，征服新领地
08 病中反省：麻烦来了
第二部分 民主企业
09 改变, 从重组自己开始
10 工厂委员会：员工自治的开始
11 一个变化带来另一个变化
12 常识是最好的选择
13 香蕉吃猴子：涨工资引起罢工
14 数字化遇到企业巨人症
15 变形虫方法：拆分带来繁荣
16 摒弃泰勒制：没有流水线的工厂
17 先共享信息后共享财富
18 取消文员，解决文件困境
19 塞氏企业妇女计划
20 轮岗制：你不用担心生活枯燥
21 塞氏伦理：宽容与底线
22 要不要老板？员工们打分吧
23 不仅仅是工作，更是信任与合作
第三部分 自治公司
24 让金字塔旋转起来
25 自主薪酬：信任与透明机制再进化
26 总算圆了哈佛梦
27 春风得意时遭遇危机
28 在贪腐的巴西如何坚守底线
29 奇思妙想三剑客
30 流水线上的弹性工作制
第四部分 合作平台
31 凝聚力：应对经济危机之道
32 “卫星计划”：让员工自己做老板
33 分散与联合：塞氏企业联邦的新生
34 轮值CEO
35 塞氏经验：你也学得会
36 部落共存：将命运托付给员工
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>塞氏企业
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>建筑模型设计
前言
第1章 开始
设备、材料和模型类型
设备
基本设备
扩展设备
材料
模型类型
主要模型
次要模型
第2章 接
组合模型组件的基本工艺
切割材料
切割薄片
切割杆和金属线
切割与钻孔
修剪与裁剪
附着部件
附着面板

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>建筑模型设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>创新设计
第 1 章新型创新者...............................................................................1
1.1 新型创新者：务实经营.............................................................2
1.2 新型创新者：全球品牌和工业设计.........................................6
1.3 新型创新者：工程化和超前思维...........................................13
1.4 那么谁是新型创新者...............................................................17
1.5 揭示创新...................................................................................18
第 2 章务实创新——新的使命.........................................................20
2.1 变革的使命...............................................................................21
2.2 务实创新（与发明有何不同）...............................................22
2.3 福特从发明到创新：F-150 的重新设计.................................27
2.4 创业公司中的创新...................................................................31
2.5 生产质量——新的产品............................................................36
2.6 创新——新的使命....................................................................37
2.7 全球维度的创新.......................................................................40
2.8 创新的弄潮儿...........................................................................43
第 3 章商业的艺术与科学.................................................................44
3.1 Adidas 1 的发布........................................................................46
3.2 市场营销在产品开发早期阶段的角色...................................49
3.3 产品成功的不可预知性...........................................................51
创新设计：如何打造赢得用户的产品、服务与商业模式
3.4 远见的坚实基础（是的，你可以跟着感觉走）...................52
3.5 务实创新的过程.......................................................................54
3.5.1 判定战略价值的范围...................................................56
3.5.2 对人的研究...................................................................56
3.5.3 找准时机.......................................................................57
3.5.4 确定设计标准...............................................................57
3.5.5 达到标准.......................................................................57
3.5.6 生产/不生产的决定......................................................58
3.6 基本原则：了解创新者对流程的认识...................................58
3.6.1 第一点：对思维的要求...............................................58
3.6.2 第二点：创新产生独特性...........................................60
3.6.3 第三点：不要在成功面前止步....................................61
3.6.4 第四点：动机需求.......................................................62
第 4 章解读趋势，创造明天.............................................................64
4.1 先导用户与新技术...................................................................67
4.2 苹果公司：趋势的解读者.......................................................68
4.3 怎样才能读懂趋势...................................................................70
4.4 产品影响趋势...........................................................................72
4.5 趋势解读，以人为本...............................................................76
4.6 米拉办公椅的设计...................................................................79
第 5 章为渴望而设计——新产品的配方..........................................83
5.1 哈利•波特现象.......................................................................84
5.2 形式和功能...............................................................................86
5.3 体验经济...................................................................................87
5.4 幻想经济...................................................................................88
5.4.1 日常用品里的幻想.......................................................90
5.4.2 形式和功能满足幻想...................................................92
5.5 哈利•波特的幻想...................................................................94
5.6 日常体验中的幻想驱动型产品...............................................97
第 6 章利益相关者的力量——那些激发创新的人们....................100
6.1 路博润公司（Lubrizol）——从技术到产品........................102
6.2 10 的次方镜头........................................................................106
6.3 10 的次方分析法的具体操作................................................108
6.3.1 10 的 1 次方：分子....................................................109
6.3.2 10 的 2 次方：混合....................................................110
6.3.3 10 的 3 次方：搅拌机................................................110
6.3.4 10 的 4 次方：系统运行............................................111
6.3.5 10 的 5 次方：社区....................................................112
6.3.6 10 的 6 次方：地区....................................................113
6.3.7 10 的 7 次方：大陆....................................................114
6.3.8 10 的 8 次方：全球环境............................................115
6.4 情景化思考让人们更现实.....................................................115
第 7 章 B2B 创新——梦幻的新前沿...............................................117
7.1 工业新领域.............................................................................119
7.2 工业产品中的幻想.................................................................120
7.3 RedZone 机器人公司：从项目到产品..................................123
7.4 战略计划.................................................................................126
7.4.1 战略一：认知和了解利益相关者..............................126
7.4.2 战略二：规划产品.....................................................127
7.4.3 战略三：规划企业的产品开发方法..........................128
7.5 成效：下水道的修复和超越.................................................130
7.6 下水道上面的世界.................................................................132
创新设计：如何打造赢得用户的产品、服务与商业模式
第 8 章为利润做决策——成功诞生于危机....................................135
8.1 决策过程中的复杂性.............................................................137
8.2 组织决策制定的过程.............................................................139
8.3 蝴蝶效应.................................................................................142
8.4 架构内部的混乱.....................................................................144
8.5 制定跨专业的决策.................................................................146
第 9 章产品创新过程.......................................................................151
9.1 新百伦.....................................................................................153
9.2 通过合作创新.........................................................................154
9.3 “新百伦”创新的案例研究：新产品开发的四个阶段.......155
9.3.1 第一阶段：明确产品机会.........................................157
9.3.2 第二阶段：理解产品机会.........................................159
9.3.3 价值机会.....................................................................160
9.3.4 实地了解客户.............................................................162
9.3.5 第三阶段：概念化产品机会......................................164
9.3.6 第四阶段：实现产品机会.........................................165
第 10 章建立知识产权保护品牌元素.............................................168
10.1 Swiffer：宝洁公司创新的成功...........................................170
10.1.1 为什么 Swiffer 会领先..............................................172
10.2 知识产权：实用专利...........................................................173
10.3 知识产权：外观设计专利...................................................175
10.4 知识产权：版权及商标.......................................................176
10.5 知识产权：商业外观...........................................................177
10.6 知识产权：商业机密...........................................................178
10.7 知识产权：临时专利保护...................................................179
10.8 使用知识产权保护品牌和产品生存周期圈.......................180
10.9 用专利保护产品系统...........................................................182
10.10 用专利保护产品的生产和运输.........................................184
10.11 总结.....................................................................................185
第 11 章聘用顾问还是内部自建——这是个问题..........................186
11.1 设计的力量...........................................................................187
11.2 重用产品开发顾问...............................................................189
11.3 IDEO：产品设计界的星巴克..............................................192
11.4 顾问类型...............................................................................195
11.5 Product Insight 公司：客户研究及设计..............................197
11.6 用招聘平衡软品质与硬品质...............................................200
11.7 设计管理...............................................................................202
后记创新的力量——机会的新经济................................................205
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>创新设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>资本与商业模式顶层设计——互联网时代如何发现企业高利润区
第一章 企业为什么需要做顶层设计
一、万达广场的BT模式 / 3
二、重庆某钢琴培训公司的BT模式 / 4
三、杭州一家健身房的商业模式 / 5
四、轻资产——只有3个人的旅游公司 / 6
五、转型、转向、转行——商业模式是关键 / 6
六、FBI 最新数字编码体系带来的启发 / 7
七、中国企业到美国上市，一个好的定位战略是与一个成功的美国企业建立类比关联 / 8
八、什么样的企业是投资者眼中的好企业？ / 9
九、巴菲特眼中好的商业模式 / 10
十、做得比别人好就能够成功吗 / 12
十一、智慧的精髓是“心随精英、口随大众” / 17
第二章 投资成长型企业的股权最赚钱
一、如何成为一个预知趋势的专家 / 23
二、资源类 / 25
案例：中国森林公司 / 26
三、三农 / 28
案例：多利农庄——用新模式让你相信这真的是有机蔬菜 / 31
案例：艾格菲的转型 / 33
案例：加加食品的毛利润为什么如此之高？ / 35
四、消费品 / 37
案例： 用肯德基物流聚集“冷链”——打造陕西最大的餐饮
公司 / 37
案例：经销商在手，本土老大很有话语权 / 40
案例：雪津啤酒设计经销商模式，一发不可收 / 40
案例： PE 投资和VC 投资需注重经销商环节 / 43
案例： 浪潮经销商《销售员股权对赌激励实施办法》的思
路 / 44
案例：上海红酒交易中心：红酒融金 / 45
案例：华录百纳影视——一家只有42 个人的上市公司 / 47
案例：儿童体验产业 / 49
案例：宋城如何成为中国旅游演艺第一股 / 54
五、现代服务业 67
案例：利乐公司在中国是如何发展壮大的 / 69
案例：东风股份的转型——掌控高利润区 / 70
案例： 金螳螂的标准化创新，成为国内第一家上市的装修
公司 / 70
六、新能源 / 72
七、有科技含量的技术 / 73
第三章
八、金融业 / 73
案例：宜信：小额信贷“P2P” / 75
案例：神奇的金融街8 号当铺——金融仓储模式 / 77
九、房地产业 / 84
十、类房地产行业 / 85
案例：瑞卡租车 / 85
案例：北京世鳌商务中心 / 86
十一、TMT / 88
案例：信泽传媒：从“圈地”到“圈人” / 89
案例：客多传媒：店铺Matrix / 90
案例：四海商舟，借“舟”出海 / 92
案例：易到用车，租车业的携程模式 / 93
案例：HomeAway：全球最大的假日房屋租赁在线平台 / 95
案例：袜管家：网上如何卖袜子 / 97
案例：病友网 / 98
案例：技能分享网 / 99
十二、连锁行业 / 102
案例：吉峰农机如何在农村搞连锁，一定要靠收购？ / 106
案例：汽车维修业的高利润点在哪里 / 107
案例：乔氏商店 / 109
案例：“美元树” / 111
十三、商鞅为秦国设计的军功制商业模式 / 113
十四、商业模式的创新＝复制＋改良 / 119
十五、“财富中国”的商业模式 / 120
十六、商业模式创新与易经的关系 / 129
十七、余额宝二号助力阿里小贷，马云金融帝国的商业模式 / 133
十八、房地产企业战略转型，未来可以转向8 个高利润区 / 142
第三章 股权改革——让企业自动运转
一、机制的力量 / 155
二、企业分钱到底分谁的钱 / 156
三、蒙牛的财聚人散、财散人聚的结果如何？ / 157
四、华为的股权激励 / 159
五、土豆网的股权纠纷 / 160
六、百丽如何用股权激活上游、下游 / 161
七、晋商的核心竞争力——“财股与身股结合、身股为大” / 162
八、麦当劳的股权解析 / 163
九、股权的概念 / 165
十、机制可以让企业做大，体系可以让企业快速发展 / 168
股权激励案例：中诚伟业股份改造方案 / 169
股权激励案例：某高科技公司的劳动股份制（创业型） / 171
股权激励案例：天津文光集团的股改方案，利润增加了10 倍 / 173
股权激励案例：A 公司股改方案 / 175
股权激励案例：一家养生品公司——“北京时间” / 179
股权激励案例：博文科技股权对赌案例 / 182
股权激励案例：星巴克的股权案例 / 184
股权激励案例：期权的学问：创业公司如何公平分配股权 / 186
机制设计案例：如何让一家混乱的公司变成精锐部队 / 189
机制设计案例：一家快速扩张的公司如何设计制度 / 192
第四章 低成本股权激励及融资上市
一、直接融资的方式——私募 / 197
1. 某企业私募融资1.2 亿元的商业模式 / 197
2. 私募投资方关注的问题 / 199
3. 向私募基金融资的企业应关注的问题 / 200
4. 专业投资人在准备投资时，会签署两个文件 / 201
5. 私募股权多种投资工具的选择 / 202
6. 企业估值方法 / 203
7. 私募股权投资退出的方式 / 206
8. GP 和LP 的权利责任与利益分配 / 207
9. 股权融资中的9 个细节问题 / 208
10. 企业引入私募基金的四个步骤 / 211
11. 私募合同的核心条款 / 212
二、企业直接融资的方式——上市 / 213
1. 公开上市的益处 / 213
2. 上市费用 / 217
3. 中国资本证券市场的特点 / 218
4. 创业板与中小企业板上市条件比较 / 219
5. 华致酒行被否案例 / 220
6. 证监会眼中的好企业指标 / 220
7. 证监会审核企业的条件 / 222
8. 上海丰科为什么被否定 / 227
9. 华谊兄弟传媒集团成功融资上市的案例分析 / 228
10. 海伦哲成功上市的案例分析 / 230
11. 拟上市的股权持股模式 / 231
12. 拟上市公司的股份来源 / 232
13. 上市后股东行权的税收问题 / 233
14. 58 家企业的商业价值分析 / 234
15. 一些主要地区和国家上市的情况 / 259
16. 中国企业去海外上市的途径及操作 / 260
17. 各个国家交易所比较 / 263
18. 在美国上市的要求 / 264
19. 在英国上市的要求 / 268
20. 在中国香港上市的要求 / 269
21. 阿里巴巴在中国香港上市的双股权结构设计——史上最牛的资本创新
案例 / 270
22. 在新加坡上市的要求 / 272
23. 其他国际资本市场简单介绍 / 273
24. 财富中国上市辅导时间表及内容 / 274
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>资本与商业模式顶层设计——互联网时代如何发现企业高利润区
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>制度变迁与政府会计模式选择和优化研究
第一章 导论
第一节 选题背景
第二节 研究意义
第三节 研究方法与内容
一、研究方法
二、研究内容
第四节 创新与局限
一、创新之处
二、局限性
第二章 概念界定与文献综述
第一节 核心概念界定
一、会计模式
二、政府会计模式
三、政府会计模式变迁
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>制度变迁与政府会计模式选择和优化研究
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>手游与社交游戏设计：盈利模式与游戏机制解密
第1 章　序曲 / 1
1.1　潮流变化 / 1
1.2　此书非彼书 / 5
第2 章　社交游戏是什么？手游社交化吗？ / 7
2.1　迎接挑战 / 7
2.2　BBS 与MUD 游戏 / 9
2.3　MMO 游戏 / 11
2.4　社交游戏不止于多用户 / 13
2.5　优秀手游离不开社交 / 14
2.6　《Words With Friends》创作者Paul Bettner 和David Bettner 访谈 / 16
第3 章　游戏货币化发展史 / 20
3.1　货币化的含义 / 20
3.2　游戏货币化发展简史 / 20
3.3　Richard Garriott 访谈：游戏的三大时代 / 25
第4 章　为什么要开发社交游戏或手游 / 33
4.1　社交游戏与手游赋予开发者强大力量 / 33
4.1.1　更小的开发团队与更短的开发周期 / 34
4.1.2　没有必要发行盒装产品 / 34
4.1.3　成为自己的发行商 / 35
4.1.4　更快的支付 / 35
4.1.5　无须自有服务器 / 36
4.1.6　快速获得玩家反馈 / 36
4.2　社交游戏赋予开发者责任 / 37
4.3　社交游戏赋予用户力量 / 38
4.3.1　让游戏易于上手 / 38
4.3.2　简化游戏的结束流程 / 39
4.3.3　让游戏更便于与好友同玩 / 41
4.3.4　由用户决定花费的金额 / 42
4.3.5　简化重返游戏的流程 / 44
4.4　二手零售类游戏销售：结交社交游戏和手游开发商 / 44
4.5　Jason Decker 与《口袋传奇》访谈：来自社区的情书 / 46
第5 章　行业术语与指标 / 54
5.1　引言 / 54
5.2　衡量用户规模 / 54
5.2.1　日活跃用户数 / 55
5.2.2　月活跃用户数 / 55
5.2.3　最高同时在线人数 / 56
5.3　衡量收益 / 57
5.4　社交网络广告 / 58
5.5　手游术语 / 59
5.6　通用术语 / 59
5.7　为什么这些指标很重要 / 62
5.8　案例研究：《Ravenwood Fair》与游戏设计中的指标运用 / 64
5.9　Everett Lee 访谈：社交游戏设计的科学 / 70
第6 章　什么是社交网络 / 76
6.1　如何成为社交游戏 / 76
6.2　认识典型的社交游戏玩家与典型的手游玩家 / 79
6.3　当前流行社交网络 / 83
6.4　游戏全球化 / 90
6.5　一切都与规模有关 / 92
6.6　借助社交网络扩展传统游戏 / 93
6.7　创建作为平台支持者的社交网络 / 97
6.8　苹果游戏中心是社交网络吗 / 99
6.9　小结 / 100
6.10　Janus Anderson 访谈：游戏与社交图谱 / 100
第7 章　如何获取/ 留存/ 重获用户 / 109
7.1　如何做游戏才能吸引用户 / 109
7.2　购买漏斗 / 109
7.3　获取：如何获得玩家 / 112
7.4　在Facebook 获取新用户 / 114
7.5　在手机平台获取新用户 / 115
7.6　有效投放广告 / 116
7.7　不断上涨的CPI 成本 / 116
7.8　病毒式传播 / 117
7.9　用户重定向 / 119
7.10　如何留存用户 / 120
7.11　追踪留存用户 / 122
7.12　通过排行榜和消息推送增加黏性 / 122
7.13　用信息召回用户 / 126
7.14　最后一步才是最重要的 / 127
7.15　Exploding Barrel Games 访谈：给玩家想要的 / 128
第8 章　货币化战略 / 137
8.1　我们渴望盈利 / 137
8.2　经典的有偿下载模式 / 137
8.2.1　移动应用商店 / 138
8.2.2　Steam / 139
8.2.3　Steam 的竞争者 / 140
8.3　订购 / 142
8.4　免费增值 / 143
8.4.1　出售时间 / 143
8.4.2　出售虚拟商品 / 144
8.4.3　游戏内容解锁与PDLC / 144
8.4.4　服务费 / 146
8.4.5　利用玩家的关注实现盈利 / 146
8.4.6　推广墙 / 147
8.4.7　弹出式广告 / 148
8.4.8　植入式广告 / 149
8.4.9　娱乐化广告 / 150
8.4.10　促进LTNV 的提升 / 150
8.5　关注数字 / 151
8.6　组合 / 152
8.7　案例研究：《狩猎者：第一章》与不同的货币化方法 / 152
8.8　为什么要避免给玩家现金 / 156
8.9　过渡模式 / 157
8.10　不同游戏与不同模式 / 159
8.10.1　角色扮演类游戏 / 159
8.10.2　回合制建设类游戏 / 160
8.10.3　模拟类游戏 / 161
8.10.4　虚拟世界 / 161
8.10.5　非持久性动作游戏与即时战略游戏 / 162
8.10.6　在线集换式卡牌类游戏 / 164
8.11　Ryan Cleven 访谈：社交平台 / 166
第9 章　虚拟商品 / 174
9.1　伪资产 / 174
9.2　出售优质商品 / 175
9.3　功能优势 / 176
9.4　关乎游戏平衡的若干因素 / 179
9.5　美丽的“虚荣”道具 / 180
9.6　限量销售 / 181
9.7　Deadpan Dodo 创始人Dimitri Delattre 访谈：独立游戏视角 / 182
第10 章　货币 / 188
10.1　获胜经济学 / 188
10.2　单货币系统 / 189
10.3　双货币系统 / 190
10.3.1　软硬货币的用途 / 191
10.3.2　双货币游戏运营技巧 / 192
10.4　封闭与开放经济 / 194
10.5　游戏的“公平” / 196
10.6　Ben Lamm 访谈：混沌控制 / 197
第11 章　尾声 / 201
11.1　时代的趋势 / 201
11.2　回顾 / 203
11.3　向朋友们道别 / 209
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>手游与社交游戏设计：盈利模式与游戏机制解密
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>敏捷软件开发
第Ⅰ部分 敏捷开发
第一章 敏捷实践
1.1 敏捷联盟
1.2 原则
1.3 结论
参考文献
第二章 极限编程概述
2.1 极限编程实践
2.2 结论
参考文献
第三章 计划
3.1 初始探索
3.2 发布计划
3.3 迭代计划
3.4 任务计划
3.5 迭代
3.6 结论
参考文献
第四章 测试
4.1 测试驱动的开发方法
4.2 验收测试
4.3 结论
参考文献
第五章 重构
5.1 素数产生程序一个简单的重构示例
5.2 结论
参考文献
第六章 一次编程实践
6.1 保龄球比赛
6.2 结论
第Ⅱ部分 敏捷设计
第七章 什么是敏捷设计
7.1 软件出了什么错
7.2 设计的臭味——腐化软件的气味
7.3 “Copy”程序
7.4 保持尽可能好的设计
7.5 结论
参考文献
第八章 单一责任原则（SRP）
8.1 单一职责原则（SRP）
8.2 结论
参考文献
第九章 开放—封闭原则（OCP）
9.1 开放—封闭原则（OCP）
9.2 描述
9.3 关键是抽象
9.4 结论
参考文献
第十章 Liskov替换原则（LSP）
10.1 Liskov替换原则（LSP）
10.2 一个违反LSP的简单例子
10.3 正方形和矩形，更微妙的违规
10.4 一个实际的例子
10.5 用提取公共部分的方法代替继承
10.6 启发式规则和习惯用法
10.7 结论
参考文献
第十一章 依赖倒置原则（DIP）
11.1 依赖倒置原则（DIP）
11.2 层次化
11.3 一个简单的例子
11.4 熔炉示例
11.5 结论
参考文献
第十二章 接口隔离原则（ISP）
12.1 接口污染
12.2 分离客户就是分离接口
12.3 接口隔离原则（ISP）
12.4 类接口与对象接口
12.5 ATM用户界面的例子
12.6 结论
参考文献
第Ⅲ部分 薪水支付案例研究
第十三章 COMMAND模式和ACTIVE OBJECT模式
第十四章 TEMPLATE METHOD模式和STRATEGY模式：继承与委托
第十五章 FACADE模式和MEDIATOR模式
第十六章 SINGLETON模式和MONOSTATE模式
第十七章 NULL OBJECT模式
第十八章 薪水支付案例研究：第一次迭代开始
第十九章 薪水支付案例研究：实现
第Ⅳ部分 打包薪水支付系统
第二十章 包的设计原则
第二十一章 FACTORY模式
第二十二章 薪水支付案例研究（第2部分）
第Ⅴ部分 气象站案例研究
第二十三章 COMPOSITE模式
第二十四章 OBSERVER模式——回归为模式
第二十五章 ABSTRACT SERVER模式、ADAPTER模式和BRIDGE模式
第二十六章 PROXY模式和STAIRWAY TO HEAVEN模式：管理第三方API
第二十七章 案例研究：气象站
第Ⅵ部分 ETS案例研究
第二十八章 VISITOR模式
第二十九章 STATE模式
第三十章 ETS框架
附录
附录A UML表示法Ⅰ：CGI示例
附录B UML表示法Ⅱ：统计多路复用器
附录C 两个公司的讽刺小品
附录D 源代码就是设计
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>敏捷软件开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>中日会计模式比较研究
目录：&nbsp;《中日会计模式比较研究》（中文版）执笔者 原文快照

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>中日会计模式比较研究
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SPSS 10.0与统计模式建构
第1章 SPSS入门
第2章 文件的建立与读取
第3章 数据管理
第4章 统计数据整合
第5章 统计概论
第6章 2D统计图表的制作
第7章 3D统计图表的制作
第8章 OLAP多维度图表制作
第9章 叙述性统计量
第10章 单一样本的检验
第11章 X平方独立性检验
第12章 两个母体平均数的检定
第13章 单因子变异量分析
第14章 回归分析
第15章 因素分析
第16章 判别分析
第17章 群集分析
第18章 复选题分析
第19章 可信度分析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SPSS 10.0与统计模式建构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>碧罗雪山两麓人民的生计模式
绪论
第一节 本书的研究对象及其方法
第二节 碧罗雪山两麓生计研究的简要回顾
第三节 研究碧罗雪山两麓生计模式的意义
第四节 一次翻越碧罗雪山的经历
第一章 碧罗雪山两麓地理环境及历史
第一节 自然气候
第二节 生物资源
第三节 族源及其历史
第二章 多元生计的形成及其中介(上)
第一节 采集狩猎：一种生计遗存
第二节 游牧：民族迁徙与文化传播
第三节 畜牧业：转场放牧
第四节 农业生计与土地所有制
第三章 多元生计的形成及其中介(下)
第一节 传统制盐业：生理需求与族群互动
第二节 民族商贸：共生与互动
第三节 天主教的传播：葡萄种植
第四节 “政治场域”下的别样生计
第四章 峡谷农业
第一节 土地类型和耕作条件
第二节 作物种类和农事活动的地方性知识
第三节 耕作技术与生产方式
第五章 转场放牧
第一节 牧场资源的分布以及放牧方式
第二节 牲畜的种类与用途
第三节 草场管理以及畜牧业的可持续发展
第六章 采集渔猎
第一节 采集
第二节 狩猎
第三节 捕鱼
第七章 澜沧江畔的传统盐业
第一节 生命之盐
第二节 传统的制盐技术
第三节 盐业贸易
第四节 盐民的生活
第八章 产品加工与手工技术
第一节 食物的加工与制作
第二节 编织和纺织
第三节 建筑
第四节 木器、竹器和陶器
第九章 政教合一及其制度下的生计
第一节 康区政教合一制度
第二节 寺院对政治经济活动的影响
第三节 川、滇、藏间的商贸往来
第四节 别样生计
参考文献
后 记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>碧罗雪山两麓人民的生计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.NET应用架构设计
前言
第一部分　架构与设计的原则和模式
第1章　架构与设计的流程和核心概念/2
1.1　正确认识软件架构/2
1.1.1　什么是架构/2
1.1.2　架构师的职责/3
1.1.3　架构设计/6
1.1.4　架构设计的优点/8
1.2　正确理解设计的含义/11
1.2.1　设计的重要性/12
1.2.2　架构和设计的关系/12
1.3　架构设计中的重要概念/14
1.3.1　Tier和Layer/14
1.3.2　架构与框架/15
1.3.3　架构与模式/15
1.4　本章小结/16
第2章　模式、设计原则和方法/17
2.1　设计原则与软件设计/17
2.1.1　设计原则简述/17
2.1.2　设计原则实战/18
2.2　设计模式/23
2.2.1　设计模式简介/23
2.2.2　正确使用设计模式/25
2.2.3　设计模式实战/26
2.3　企业应用架构模式/31
2.3.1　什么是企业架构/31
2.3.2　什么是企业级开发/31
2.3.3　再议架构设计和模式/32
2.3.4　企业架构模式介绍/33
2.4　企业架构模式实战/34
2.5　设计方法/38
2.5.1　测试驱动开发/38
2.5.2　领域驱动开发/39
2.5.3　行为驱动开发/39
2.6　本章小结/39
第二部分　架构与设计的方法和最佳实践
第3章　架构分层/42
3.1　反模式项目实例/42
3.2　分层设计/45
3.2.1　正确理解分层/45
3.2.2　常见的分层架构设计/46
3.2.3　N-Tier架构/52
3.2.4　N-Tier架构需要考虑的因素/52
3.3　从重构到分层/56
3.3.1　业务层设计实战/58
3.3.2　数据访问层设计实战/62
3.3.3　服务层设计实战/63
3.3.4　显示层设计实战/66
3.4　本章小结/69
第4章　业务层设计/70
4.1　业务层组织模式剖析/70
4.1.1　Transaction Script模式与实战/70
4.1.2　Active Record模式与实战/72
4.1.3　Domain Model模式与实战/78
4.1.4　Anemic Domain Model模式与实战/90
4.1.5　业务层组织模式比较/91
4.2　业务层常用设计模式解析及实战/92
4.2.1　工厂方法模式/92
4.2.2　装饰者模式/95
4.2.3　模板方法模式/102
4.2.4　状态模式/104
4.2.5　策略模式/109
4.2.6　模板方法模式、状态模式、策略模式的比较/109
4.3　业务层常用的企业架构模式及实战/113
4.4　模式联合实战/115
4.4.1　需求规格模式/115
4.4.2　组合模式/116
4.5　业务层常用的设计原则及实战/123
4.6　本章小结/126
第5章　服务层设计/127
5.1　服务层详解/127
5.1.1　服务层的由来/127
5.1.2　服务层的职责是什么/130
5.1.3　服务层的必要性/130
5.2　服务层常用设计模式解析/131
5.2.1　外观模式/131
5.2.2　远程外观模式/133
5.2.3　数据传输对象模式/135
5.3　SOA介绍/136
5.3.1　SOA用途/136
5.3.2　SOA原则/139
5.3.3　服务设计原则/140
5.3.4　服务解惑/142
5.3.5　服务操作设计原则/143
5.3.6　服务粒度介绍/144
5.4　服务层常用消息模式解析/146
5.4.1　文档消息模式与请求-响应模式/146
5.4.2　预约保留模式/147
5.4.3　等幂模式/148
5.5　SOA实战——WCF实现/149
5.5.1　系统分析/149
5.5.2　业务层实战/151
5.5.3　数据层实战/152
5.5.4　服务层实战/155
5.5.5　代理层实战/160
5.5.6　显示层实战/162
5.6　本章小结/163
第6章　数据访问层设计/164
6.1　数据访问层简述/164
6.2　数据访问层的设计策略/165
6.2.1　仓储模式/165
6.2.2　数据访问对象模式/166
6.3　数据访问层常用模式与原则解析/166
6.3.1　工作单元/167
6.3.2　标识映射/175
6.3.3　延迟加载/178
6.3.4　数据并发控制/182
6.3.5　查询对象/184
6.4　ORM对象关系映射/190
6.4.1　NHibernate介绍/191
6.4.2　Entity Framework介绍/191
6.5　企业级领域驱动设计项目实战/192
6.5.1　业务层的实现/192
6.5.2　服务层的实现/197
6.5.3　数据访问层的实现/203
6.5.4　显示层的实现/221
6.6　本章小结/223
第7章　数据存储层设计/224
7.1　合理选择数据存储方案/224
7.1.1　数据存储的三种方式/224
7.1.2　选择合理的数据存储方案/227
7.2　数据库架构设计/228
7.2.1　分布数据/229
7.2.2　数据拆分/229
7.2.3　读写分离/233
7.2.4　数据缓存/234
7.3　数据库设计/236
7.3.1　数据库计划/236
7.3.2　逻辑数据库设计/236
7.3.3　物理数据库设计/238
7.4　SQL Server数据库性能瓶颈分析与解决方案/240
7.4.1　缺失索引的瓶颈分析与解决方案/240
7.4.2　昂贵查询的瓶颈分析与解决方案/255
7.4.3　数据库碎片的瓶颈分析与解决方案/259
7.5　本章小结/261
第8章　显示层设计/262
8.1　MVP模式的原理与实战/262
8.1.1　MVP模式实战（ASP.NET实现）/263
8.1.2　MVP模式经验谈/269
8.1.3　MVP模式之高级话题/276
8.2　前端控制器模式的原理与实战/283
8.2.1　前端控制器模式介绍/283
8.2.2　深入浅出命令模式/284
8.2.3　前端控制器模式实战/287
8.3　MVC模式的原理与实战/289
8.3.1　深入浅出MVC模式/290
8.3.2　MVC模式之高级话题/297
8.3.3　MVC模式实战——对ASP.NET MVC源码进行分析/298
8.4　PM模式的原理与实战/313
8.4.1　PM模式的解析/313
8.4.2　PM模式实战/316
8.5　MVVM模式的原理与实战/324
8.5.1　MVVM模式介绍/324
8.5.2　MVVM模式深度剖析/325
8.5.3　MVVM模式高级话题/337
8.6　本章小结/342
第三部分　.NET应用的架构与设计实战
第9章　IT创业产品互推平台的项目背景与功能介绍/344
9.1　IT创业产品互推平台背景/344
9.2　SNS功能介绍/344
9.2.1　用户管理/345
9.2.2　个人信息管理/346
9.2.3　软件展示功能/347
9.2.4　好友功能/348
9.2.5　站内信息功能/349
9.2.6　多媒体文件管理/350
9.2.7　博客/351
9.2.8　用户群/353
9.2.9　微博/354
9.2.10　共享功能/355
9.2.11　论坛/355
9.2.12　活动/356
9.2.13　投票/358
9.2.14　页面布局定制/359
9.2.15　评级/359
9.3　本章小结/360
第10章　IT创业产品互推平台架构设计/361
10.1　分层设计/361
10.1.1　逻辑分层的总体设计/361
10.1.2　通用功能设计/362
10.1.3　业务层设计/363
10.1.4　数据持久层设计/364
10.1.5　显示层设计/364
10.2　部署设计/365
10.2.1　单服务器部署/365
10.2.2　多服务器部署/365
10.3　文件存储的设计/367
10.4　基础类库的设计/369
10.4.1　缓存/369
10.4.2　配置读取/375
10.4.3　邮件发送/376
10.4.4　日志记录/378
10.4.5　辅助类的实现/382
10.5　本章小结/383
第11章　IT创业产品互推平台用户管理/384
11.1　用户管理功能分析/384
11.1.1　用户注册/384
11.1.2　用户登录/384
11.1.3　找回密码/386
11.1.4　激活账户/386
11.1.5　删除用户/386
11.1.6　更新用户/387
11.1.7　查询用户/387
11.2　用户管理接口的定义/390
11.2.1　服务层实现定义/390
11.2.2　业务模型定义/392
11.2.3　数据访问层的接口定义/393
11.3　用户管理的实现/393
11.3.1　服务层实现/393
11.3.2　业务层实现/400
11.3.3　数据访问层实现/403
11.3.4　显示层实现/404
11.4　本章小结/406
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.NET应用架构设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>为配送中心下定义
"    目　录
第一部分　配送中心何时导入
餐饮企业配送中心何时导入，是餐饮企业连锁经营无法规避的问题！连
锁经营讲规模经济，要运用销售终端优势扩大市场份额，实现规模经营。连
锁经营讲集约经营，要运用物流优势来实现成本、品质、安全最优。
第一章　连锁经营价值金链
■ 销售为王战略选择
■ 物流为王策略设计
■ 基地为王竞争优势
■ 链式经营黄金法则
第二章　双制式的逻辑对接
■ 采购与申购的对接
■ 中心与周转的对接
■ 中间与终端的对接
■ 配送与验货的对接
第三章　配送中心导入时机
■ 启动阶段导入配送
■ 初创阶段导入配送
■ 发展阶段导入配送
■ 成熟阶段导入配送
第四章　配送中心实现模式
■ 自主经营投资运作
■ 兼并改造投资运作
■ 合作控股投资运作
■ 服务外包契约运作
第二部分　配送中心如何建立
配送中心建立是专业运作，因而要有学科、专业、组合支持，配送中心
建立是逻辑运作，因而要理解配送中心拿地、规划、营建的逻辑，配送中心
建立是投资行为，因而要掌握做正确的事，把事情做正确的规则。
第五章　配送中心拿地模式
■ 开发区域拿地模式
■ 城市周边拿地模式
■ 兼并改造拿地模式
■ 合作控股拿地模式
第六章　配送中心前期营建
■ 配送中心前期规划
■ 配送中心环境测评
■ 配送中心建安工程
■ 配送中心造价控制
第七章　配送中心项目规划
■ 信息中心营建规划
■ 采购功能营建规划
■ 仓储功能营建规划
■ 配送功能营建规划
第八章　加工工场项目规划
■ 加工工场区域规划
■ 加工工场平面布局
■ 加工工场设备方案
■ 加工工场设施方案
案例分享：和合谷的配送中心
第三部分　配送中心如何运营
餐饮企业连锁经营发展到一定阶段，虽然建立了配送中心，但运营效果
并不理想。配送中心应以低成本、高效率、系统化的运营管理理念与管理模
式，实现对连锁店铺营运物流支持。由于业界没有成熟理论、没有成熟模式、
缺少交流平台，导致配送中心运营成为餐饮企业连锁经营发展的瓶颈。
第九章　物流ＥＲＰ系统建立
■ 采购ＥＲＰ系统建立
■ 仓储ＥＲＰ系统建立
■ 加工ＥＲＰ系统建立
■ 配送ＥＲＰ系统建立
第十章　配送中心运营模式
■ 信息中心功能设计
■ 信息中心配置设计
■ 信息中心运行设计
■ 信息中心安全设计
第十一章　配送中心运营流程
■ 计划链条导入运营
■ 任务链条导入运营
■ 时间链条导入运营
■ 责任链条导入运营
第十二章　配送中心运营安全
■ 行业标准导入运营
■ 质量认证导入运营
■ 危险控制导入运营
■ 企业规范导入运营
附录１　中央工场的量身定做———北京润锐科技有限公司
附录２　管理顾问与指导机构———北京英特莱思管理顾问公司
附录３　加工工场的解决方案———南京乐鹰商用厨房设备公司
后记
"
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>为配送中心下定义
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>平靜科技
第一章　為下一世代的五百億件裝置做設計
第二章　平靜科技的原則
第三章　平靜科技溝通模式
第四章　平靜科技案例練習
第五章　在機構中實踐平靜科技
第六章　平靜科技的歷史與未來
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>平靜科技
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>智设计·活文化
绪论 2
一、民族文化 3
二、民族文化的构成与价值 6
三、中国民族文化的现状 9
四、写作初衷 11
上篇活文化
第一章中国民族文化的现状
一、中国民族文化是“黑金” 15
二、中国民族文化概述 l7
1.中国民族文化的特点 l7
2.中国民族文化的内容 22
三、中国民族文化面临的困境 22
1.民族文化的保护不足 23
2.民族文化继承断代的危机 27
3.地理条件的制约 28
4.外来文化的侵蚀 30
5.走出困境的全新思考迫在眉睫 30
第二章民族文化应该是鲜活的
一、我国民族文化现实发展中的问题 33
1.缺乏创新性 33
2.缺乏系统性 33
3.缺乏可持续性 36
二、文化创意产业 37
1.文化创意产业的含义 37
2.文化创意产业的内容 37
3.文化创意产业价值与当代文化创意产业 39
三、民族文化创意产业的设计战略 40
1.设计的含义 40
2.设计战略的含义 40
3.设计战略的核心理念 41
4.设计战略的特点 42
5.设计战略中“专属民族文化品牌战略”的导入 51
6.设计战略相关联的产业 52
7.设计战略的意义 52
四、民族文化应该是鲜活的 53
第三章民族文化创意产业“新型模式”
一、民族文化、设计战略、文化创意产业之间的关系 58
二、民族文化创意产业“新型模式”的产生 59
三、民族文化创意产业“新型模式”的内容 60
四、“前店+后厂”民族文化创意产业“新型模式” 61
1.前店 61
2.后厂 63
五、民族文化创意产业“新型模式”的内在关系 71
六、民族文化创意产业“新型模式”与低碳产业的结合 72
1.“新型模式”与低碳产业相结合的重要性 72
2.低碳节能设计标准化的建立 73
3.“新型模式”中导入低碳设计标准 74
七、民族文化创意产业“新型模式”研究的目的和意义 75
下篇智设计
第四章民族文化创意产业“新型模式”的实践
一、北京阿斯牛牛（凉山）彝族文化体验式综合体 79
二、西昌阿斯牛牛彝族音乐村寨 l27
三、四川恩阳古镇风情商业街 160
四、北京798创意产业园区（参考） 181
结语
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>智设计·活文化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>淘宝天猫网店设计从入门到精通 店铺装修+广告海报+修图修片+架构布局+配色应用+设计模版
导读
01 本书怎么读？
02 五个步骤搞定网店装修
第一步：*替换源文件中的图片和文本信息
第二步：*在Photoshop中制作切片并优化处理
第三步：*将切片处理后的图片上传到网络空间
第四步：在Dreamweaver中添加链接并制作代码
第五步：*复制代码到店铺装修指定区域
========================================================
第一篇 网店装修前的准备工作
第1章 对店铺装修进行初步了解
1.1 什么是网店装修
1.2 网店装修的意义
1.2.1 获取店铺信息
1.2.2 直观掌握更多的商品信息
1.3 店铺装修与转化率的关系
1.4 常见电商平台及其配色
1.4.1 淘宝与天猫
1.4.2 唯品会
1.4.3 京东
1.4.4 当当网
1.5 如何确定装修的风格
1.5.1 网店整体色调的选择
1.5.2 详情页面橱窗照的设计
1.5.3 网店中各个模块的合理布局
1.6 网店装修中的误区
========================================================
第2章* 做好准备让装修有条不紊-前期工作
2.1 拍摄宝贝图片
2.1.1 摄影器材的选择
2.1.2 布置拍摄场地
2.1.3 多角度、重细节地拍摄宝贝
2.1.4 拍摄小窍门
2.1.5 后期修片原则
2.2 收集装修所需的设计素材
2.3 获得图片的存储空间
2.3.1 常用的免费空间相册
2.3.2 其他获取图片空间的方法
2.4 了解装修中遇到的文件格式
========================================================
第3章* 视觉营销三大要素——色彩、文字、版式
3.1 了解色彩的基本要点
3.1.1 色彩的种类
3.1.2 色彩三要素
3.1.3 色调的倾向
3.2 记忆中的色彩
3.2.1 暖色系色彩的性格和表现
3.2.2 冷色系色彩的性格和表现
3.3 常见配色方案
3.3.1 对比配色在网店装修中的应用
3.3.2 调和配色在网店装修中的应用
3.4 文字的重要表现
3.4.1 常见的字体风格
3.4.2 了解文字的编排准则
3.4.3 运用合理分割方式来安排文字
3.4.4 字体的创意设计
3.5 版式布局对网页界面的影响
3.5.1 版式设计的形式法则
3.5.2 版式布局中图片的处理
3.5.3 了解版式布局中的视觉流程
3.5.4 版式布局中的对齐方式
========================================================
第4章* 店铺装修的基础工具——美图秀秀和
4.1* 最易上手的商品图片修饰软件
——美图秀秀
========================================================
第5章 专业的网店装修利器——P
第二篇 网店装修六大核心区域的设计
第6章 打出过目不忘的招牌——店招
第7章 帮助顾客精确定位——导航条
第8章 第一印象很重要-首页欢迎模块
第9章* 巧用心思赢得回头客-店铺收藏区
第10章 给顾客解惑答疑——客服区
第11章* 体现宝贝的专业品质
========================================================
第三篇 统一整店风格强化客户对店铺及品牌的意识
第12章 服装类店铺装修大集合
第13章 鞋包配饰类店铺装修大集合
第14章 珠宝手表类店铺装修大集合
第15章 手机数码类店铺装修大集合
第16章 彩妆美肤类店铺装修大集合
第17章 家居家纺类店铺装修大集合
第18章 小商品类店铺装修大集合
========================================================
附录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>淘宝天猫网店设计从入门到精通 店铺装修+广告海报+修图修片+架构布局+配色应用+设计模版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SAP ABAP 面向对象程序设计
前言
第一篇　ABAP语言程序设计基础
第1章　ABAP语言概述2
1.1　ABAP的特点2
1.2　ABAP开发基础4
1.2.1　ABAP SAP GUI开发环境5
1.2.2　ABAP开发环境的设置5
1.2.3　ABAP的语法结构8
1.2.4　ABAP的语法帮助8
1.3　ABAP的数据类型10
1.3.1　预定义数据类型10
1.3.2　全局数据类型（数据字典类型）11
1.3.3　局部数据类型（用户自定义类型）13
1.3.4　按结构区分的数据类型13
1.4　ABAP变量命名规则14
1.4.1　全局变量的命名规则15
1.4.2　局部变量的命名规则17
1.4.3　向对象变量的命名规则17
第2章　ABAP语言关键知识点21
2.1　ABAP的变量21
2.1.1　变量的分类21
2.1.2　采用LIKE定义变量26
2.1.3　采用REF TO定义变量26
2.1.4　变量的赋值30
2.1.5　变量的动态传入30
2.2　内表31
2.2.1　内表的定义和分类31
2.2.2　内表的操作34
2.3　ABAP的SQL语句47
2.3.1　OPEN SQL简介47
2.3.2　查询数据48
2.3.3　插入数据50
2.3.4　更新数据51
2.3.5　删除数据51
2.3.6　修改数据52
2.3.7　Native SQL简介53
2.3.8　HANA SQL Script简介55
第二篇　向对象ABAP语言程序设计基础
第3章　向对象程序设计基础60
3.1　向对象语言发展史60
3.2　向对象的理论基础69
3.3　向对象的概念—对象69
3.4　向对象的概念—类70
3.5　类之间的关系71
第4章　ABAP向对象程序设计基础76
4.1　创建局部类76
4.2　创建全局类78
4.3　类的属性80
4.4　类的方法88
4.5　类的事件96
4.6　类的构造方法99
4.7　类方法的异常103
4.8　类的友元109
4.9　ABAP调用类对象113
4.10　类对象的内存释放118
第三篇　向对象程序设计概念
与思想
第5章　向对象程序设计重要概念122
5.1　向对象设计的基本概念123
5.2　封装123
5.2.1　封装的概述123
5.2.2　封装的实现126
5.3　继承134
5.3.1　继承的概述134
5.3.2　继承的实现136
5.4　多态146
5.4.1　多态的概述146
5.4.2　多态的实现（基于非抽象类）152
5.4.3　多态的实现（基于抽象类）161
5.4.4　多态的小结172
5.5　接口173
5.5.1　接口的概述173
5.5.2　接口的实现175
第6章　向对象程序设计基本原则183
6.1　概述183
6.2　单一责任原则（SRP）184
6.3　开放封闭原则（OCP）185
6.4　里氏替换原则（LSP）199
6.5　接口分离原则（ISP）203
6.6　依赖倒置原则（DIP）204
6.7　合成复用原则（CRP）210
6.8　迪米特法则（LoD）211
6.9　向对象设计基本原则总结212
第7章　向对象设计常用的设计模式214
7.1　设计模式概述214
7.2　单例模式217
7.3　简单工厂模式221
7.4　适配器模式223
7.5　桥接模式228
7.6　外观模式236
7.7　观察者模式241
7.8　策略模式254
7.9　设计模式总结261
第四篇　向对象程序设计实例
第8章　ABAP OOP开发实例266
8.1　ABAP中数据和对象的动态创建和调用266
8.2　字段符号在ABAP OOP中的应用268
8.3　ABAP中的泛型271
8.4　ABAP日志类的使用278
8.5　调试的使用285
8.6　OO ALV的应用296
8.7　ABAP OOP实现网店购物车302
8.8　持久类和对象持久化的应用307
8.9　基于向对象的BAdI的使用317
8.9.1　旧BAdI（Classic BAdI）318
8.9.2　新BAdI（Kernel BAdI）325
8.10　ABAP代码的重构333
第9章　向对象分析设计的过程339
9.1　向对象分析设计的基本过程339
9.2　设计思维在SAP程序设计中的应用343
9.3　敏捷Scrum在SAP开发中的应用354
9.4　基于向对象的单元测试362
9.5　分析实例：IoT物联网应用设计与开发367
参考文献386
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SAP ABAP 面向对象程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图解建筑结构（第2版）
中文版序言
序言
1 建筑结构
2 结构模式
3 水平跨件
4 竖向维度
5 侧向稳定
6 大跨结构
7 高层结构
8 系统整合
参考书目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图解建筑结构（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图解产品设计模型制作
第1章  工业产品模型制作概述  1.1  产品模型制作的重要意义    1.1.1  产品模型制作是设计实践过程    1.1.2  产品模型制作是综合表达设计内容的有效方法    1.1.3  产品模型是展示、评价、验证设计的依据  1.2  产品模型的种类与用途    1.2.1  形态研究模型    1.2.2  功能实验模型    1.2.3  交流展示模型    1.2.4  手板样机模型  1.3  产品模型材料选用    1.3.1  考虑模型材料的适用性    1.3.2  考虑模型材料的易加工性    1.3.3  按材料区分模型第2章  黏土模型制作  2.1  黏土的成型特性  2.2  制作黏土模型的主要设备、工具及辅助材料  2.3  黏土材料的制备  2.4  黏土模型成型方法    2.4.1  黏土形态草模型成型方法    2.4.2  黏土标准原型成型方法第3章  油泥模型制作  3.1  油泥的成型特性  3.2  制作油泥模型的主要设备、工具及辅助材料  3.3  油泥模型成型方法  3.4  油泥模型表面装饰    3.4.1  涂饰工具与涂饰材料    3.4.2  油泥模型表面涂饰方法第4章  石膏模型制作  4.1  石膏的成型特性  4.2  制作石膏模型的主要设备、工具及辅助材料  4.3  石膏模型成型方法    4.3.1  调和石膏溶液    4.3.2  反求成型（复制成型）    4.3.3  旋转成型    4.3.4  雕刻成型  4.4  石膏模型表面涂饰    4.4.1  涂饰工具与涂饰材料    4.4.2  石膏模型表面涂饰方法第5章  硅橡胶模具制作  5.1  硅橡胶的成型特性  5.2  制作硅橡胶模具的主要设备、工具及辅助材料  5.3  硅橡胶模具成型方法    5.3.1  双组分室温硫化硅橡胶的调和方法    5.3.2  浇注成型    5.3.3  涂刷成型  5.4  通过硅橡胶模具反求成型第6章  塑料模型制作  6.1  热塑性塑料的成型特性  6.2  制作热塑性塑料模型的主要设备、工具及辅助材料  6.3  热塑性塑料成型方法    6.3.1  冷加工成型    6.3.2  热加工成型    6.3.3  塑料表面抛光处理    6.3.4  制作案例  6.4  塑料模型表面涂饰    6.4.1  涂饰工具与涂饰材料    6.4.2  塑料模型表面涂饰方法第7章  玻璃钢模型制作  7.1  玻璃钢的成型特性  7.2  制作玻璃钢模型的主要设备、工具及辅助材料  7.3  玻璃钢模型成型方法    7.3.1  不饱和聚酯树脂的调和方法    7.3.2  裱糊成型  7.4  玻璃钢模型表面涂饰第8章  木模型制作  8.1  木材的成型特性  8.2  制作木模型的主要设备、工具及辅助材料  8.3  木模型成型方法  8.4  木模型表面涂饰    8.4.1  涂饰工具与涂饰材料    8.4.2  木模型表面涂饰方法第9章  金属模型制作  9.1  金属的成型特性  9.2  制作金属模型的主要设备、工具及辅助材料  9.3  金属模型成型方法    9.3.1  使用金属管材、棒材加工成型    9.3.2  使用金属板材加工成型    9.3.3  使用金属丝网加工成型    9.3.4  金属零件组装成型  9.4  金属模型表面涂饰第10章  快速原型技术制作产品模型  10.1  快速原型成型原理及成型方法  10.2  成型实例第11章  模型制作赏析后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图解产品设计模型制作
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.NET框架设计
第1章　框架设计的基本概念　　1
1.1　框架　　2
1.1.1　框架的通常作用及层面　　2
1.1.2　框架的生命周期　　3
1.2　框架设计　　4
1.2.1　确定问题域和识别变化点　　4
1.2.2　选择合适的架构模式、配置变化数据、可视化管理　　5
1.3　框架设计核心三元素：模式、配置和工具　　7
1.3.1　框架模式　　7
1.3.2　框架配置　　7
1.3.3　框架工具　　7
1.3.4　总结　　8
第2章　C#、.NET Library高级应用　　9
2.1　重温C#——灵活运用各元素　　10
2.1.1　类、继承、接口　　10
2.1.2　字段、属性、常量、枚举　　14
2.1.3　方法、委托、事件　　16
2.1.4　泛型、协变/逆变、类型推断　　21
2.1.5　扩展方法　　24
2.1.6　部分类、部分方法　　25
2.1.7　特性、元数据　　26
2.1.8　反射、代码对象模型、动态编译、动态缓存　　28
2.2　面向C#设计模式的关键技术　　30
2.2.1　创建型——工厂模式、工厂规则注入、委托工厂　　30
2.2.2　行为型——观察者模式、基于事件的观察者　　32
2.2.3　结构型——桥接模式、扩展方法　　34
2.3　编码时应注意防御性、稳定性和性能　　37
2.3.1　常被忽视的防御性判断　　37
2.3.2　避免直接返回NULL，保持80%的稳定性　　38
2.3.3　空对象模式和扩展方法的NULL验证　　39
2.3.4　注重性能的编码方式　　41
2.4　单元测试、可测试性代码、持续重构　　42
2.4.1　单元测试的重要性及核心意义　　42
2.4.2　可测试性代码的重点　　44
2.4.3　类中受保护方法的测试　　47
2.4.4　基于完善的单元测试用例　　49
2.4.5　TDD的优势　　50
2.5　第三方库是可插拨的、依赖库的版本　　51
2.5.1　依赖抽象接口　　51
2.5.2　依赖库的版本　　51
第3章　框架模式——框架的精髓　　53
3.1　提供程序模式　　55
3.1.1　问题域和基本模型　　55
3.1.2　相关的设计模式　　56
3.1.3　实例　　57
3.1.4　总结　　63
3.2　链式编程模式　　65
3.2.1　问题域和基本模型　　65
3.2.2　实例——非扩展方法实现链式编程模式　　68
3.2.3　实例——扩展方法实现链式编程模式　　71
3.2.4　配置带有算法的逻辑并将逻辑算法作为配置保存　　72
3.2.5　链式编程模式在领域模型中的价值　　72
3.2.6　总结　　73
3.3　管道模式　　74
3.3.1　问题域和基本模型　　74
3.3.2　实例　　76
3.3.3　自治管道与约定管道的区别　　85
3.3.4　总结　　85
3.4　逻辑上下文模式　　86
3.4.1　上下文相关概念　　86
3.4.2　问题域和基础模型　　86
3.4.3　实例　　88
3.4.4　总结　　93
3.5　钝化程序模式　　94
3.5.1　问题域及基础模型　　94
3.5.2　实例　　96
3.5.3　总结　　103
3.6　规则外挂模式　　105
3.6.1　问题域及基础模型　　105
3.6.2　调整逻辑架构——分离业务逻辑于业务规则　　106
3.6.3　实例　　107
3.6.4　总结　　114
3.7　语句组件模式　　116
3.7.1　问题域和基础模型　　116
3.7.2　实例　　118
3.7.3　总结　　129
3.8　面向契约式模式　　130
3.8.1　问题域和基础模型　　130
3.8.2　契约条目检查器　　132
3.8.3　面向查询的契约文件　　132
3.8.4　实例　　132
3.8.5　总结　　143
3.9　异步消息事件驱动模式　　144
3.9.1　问题域及基础模型　　144
3.9.2　相关的设计模式　　145
3.9.3　实例　　146
3.9.4　总结　　154
3.10　总线消息路由模式　　155
3.10.1　问题域及基础模型　　155
3.10.2　实例　　156
3.10.3　总结　　163
3.11　元数据及元数据缓存池模式　　165
3.11.1　问题域及基础模型　　165
3.11.2　元数据的生成方式　　166
3.11.3　实例　　167
3.11.4　总结　　173
第4章　配置化——提高灵活性及扩展性　　174
4.1　配置内容及存放位置　　175
4.1.1　配置内容　　175
4.1.2　存放位置　　179
4.2　配置的领域概念及文档对象模型　　180
4.2.1　传统领域信息配置项　　180
4.2.2　设计具有领域概念的配置项　　181
4.2.3　配置相关的文档对象模型（DOM）　　　185
4.3　动态代码配置　　192
4.3.1　模板引擎介绍　　192
4.3.2　动态代码配置　　193
第5章　工具——可视化使用　　197
5.1　设计时工具 198
5.1.1　自动代码生成　　198
5.1.2　暴露框架中的某个工具支撑库　　201
5.2　运行时工具特性　　203
5.2.1　脚本引擎　　203
5.2.2　执行上下文　　203
5.2.3　可插拔　　203
第6章　框架设计总结　　204
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.NET框架设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>冒号课堂
上篇：编程范式与编程语言
第1课 开班导言
1.1 开班发言——程序员的4层境界
1.2 首轮提问——什么语言好？
1.3 语言选择——合适的就是好的
1.4 初识范式——程序王国中的世界观与方法论
1.5 开发技术——实用还是时髦？
第2课 重要范式
2.1 命令范式——一切行动听指挥
2.2 声明范式——目标决定行动
2.3 对象范式——民主制社会的编程法则
2.4 并发范式——合作与竞争
第3课 常用范式
3.1 泛型范式——抽象你的算法
3.2 超级范式——提升语言的级别
3.3 切面范式——多角度看问题
3.4 事件驱动——有事我叫你，没事别烦我
第4课 重温范式
4.1 函数范式——精巧的数学思维
4.2 逻辑范式——当算法失去了控制
4.3 汇总范式——一张五味俱全的大烙饼
4.4 情景范式——餐馆里的编程范式
第5课 语言小谈
5.1 教学计划——接下来的故事
5.2 数据类型——规则与变通
5.3 动态语言——披着彩衣飞舞的脚本语言
5.4 语言误区——语言的宗教情结
第6课 语言简评
6.1 系统语言——权力的双刃剑
6.2 平台语言——先搭台后唱戏
6.3 前台语言——视觉与交互的艺术
6.4 后台脚本——敏捷开发的利器
下篇：抽象机制与对象范式
第7课 抽象封装
7.1 抽象思维——减法和除法的学问
7.2 数据抽象——“做什么”重于“怎么做”
7.3 封装隐藏——包装的讲究
第8课 抽象接口
8.1 软件应变——随需而变，适者生存
8.2 访问控制——代码的多级管理
8.3 接口服务——讲诚信与守规矩
第9课 继承机制
9.1 继承关系——继承财富，更要继承责任
9.2 慎用继承——以谨慎之心对待权力
第10课 多态机制
10.1 多态类型——静中之动
10.2 抽象类型——实中之虚
第11课 值与引用
11.1 语法类型——体用之分
11.2 语义类型——阴阳之道
第12课 设计原则
12.1 间接原则——柔胜于刚，曲胜于直
12.2 依赖原则——有求皆苦，无欲则刚
12.3 肉聚原则——不是一家人，不进一家门
12.4 保变原则——与魔鬼打交道的艺术
第13课 设计模式
13.1 创建模式——不要问我从哪里来
13.2 结构模式——建筑的技巧
13.3 行为模式——君子之交淡如水
13.4 闭班小结——软件无形，编程有道
索引
设计手记
编辑手记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>冒号课堂
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>商业模式的全新设计
目录
引子　从战略管理到商业模式　　//1
首先需要变革的，是管理学的研究视角　　//9
其次需要变革的，是管理学的研究视野　　//12
第1 章　什么是商业模式　　//17
从盲人摸象说开去　　//20
企业赚钱的价值基础　　//25
企业赚钱的价值链路基础　　//31
商业模式到底是什么　　//35
第2 章　需求定位及客户锁定　　//41
定位首先是需求定位　　//44
需求链及利益相关者　　//51
超越营销，锁定客户　　//54
案例实战：客户锁定　　//62
第3 章　价值环节及其重组　　//71
价值流、价值链路及价值环节　　//75
重组价值环节，改变商业模式　　//78
商业模式创新的价值重组手术　　//89
案例实战：价值类型转换　　//99
第4 章　交易方式及其变换　　//107
变换交易方式，改良商业模式　　//111
变换交易构形，改进商业模式　　//118
降低交易成本，减少交易风险　　//125
案例实战：交易方式变换　　//130
第5 章　赢利模式与商业位势　　//139
赢利模式与价值交易形态　　//143
基于第三方的赢利模式优化　　//149
商业位势与收益分配　　//155
案例实战：赢利模式升级与优化　　//162
第6 章　商业模式重构与商业模式设计　　//169
局部优化的商业模式重构　　//172
案例实战：商业模式重构　　//180
从头开始的商业模式设计　　//184
案例实战：商业模式的全新设计　　//195
参考文献　　//203
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>商业模式的全新设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>商业模式创新设计大全：90%的成功企业都在用的55种商业模式
第一部分 如何推动商业模式创新
1 什么是商业模式以及为何要进行商业模式创新 3
2 商业模式导航 21
3 管理变革 68
第二部分 55 种最吸金的成功商业模式
4附加商业模式： 对附加产品收取额外费用 91
5联盟商业模式： 你的成功就是我的成功 98
6合气道模式： 将竞争者的优势转化为劣势 103
7拍卖商业模式： 一次， 两次……成交 108
8物物交换商业模式： 一报还一报 113
9取款机商业模式： 利用负运营资本赚取利润 118
10交叉销售商业模式： 一箭双雕 123
11众筹模式： 大家一起来投资 127
12众包模式： 外包给大众 132
13客户忠诚度商业模式： 忠诚度的长期激励机制 137
14数字化商业模式： 把实际产品数字化 142
15直销商业模式： 跳过中间商 148
15电子商务商业模式： 更加透明、 更加节约的网上交易 153
17体验式销售商业模式： 打造具有情感吸引力的产品 159
18固定费用模式：“ 任你吃” ——固定价格内的无限制消费 165
19分式产权商业模式： 分时度假有助于高效率 170
20特许经营权模式： 人人为我， 我为人人 175
21免费增值模式： 免费的基础版本和付费的高级版本二选一 181
22从推动到拉动模式： 消费者创造一个价值漩涡 185
23保证可用性模式： 产品的可靠途径 191
24隐性收入模式： 寻找替代来源 196
25成分品牌商业模式： 品牌中的品牌 201
26集成者商业模式： 参与整个生产链 206
27单一业务商业模式： 从专业服务中获益 211
28客户数据杠杆化商业模式： 充分利用已知信息 215
29许可证经营模式： 知识产权商业化 221
30锁定模式： 用高转移成本确保客户忠诚度 226
31长尾模式： 积少成多的小额收入 231
32附加值商业模式： 使核心业务以外的技术多样化 236
33大规模定制模式： 大批量生产个性化产品 241
34平价服务模式 ： 无论怎样， 至少很便宜 246
35开放式创新模式 ： 推动协作以创造价值 251
36开源创新模式： 共同合作设计出免费的解决方案 257
37指挥家模式： 价值链管控 262
38计费购买模式： 按程计费 266
39按需付费模式： 无论如何， 你值得拥有 271
40P2P 模式： 个人对个人的商业模式 275
41绩效契约模式： 以结果计费 281
42剃刀和刀片模式： 诱饵和鱼钩 286
43租赁模式： 购买短期使用权 290
44收入共享模式： 双赢的共生关系 295
45逆向工程模式： 向竞争者学习 300
46逆向创新模式： 学习出色的解决方案 305
47罗宾汉式商业模式： 取之富者， 施之贫者 310
48自助服务模式： 让消费者自己干活 315
49店中店模式： 搭载经营 320
50解决方案提供者模式： 在一站式商店中找到你需要的一切 325
51订购模式： 购买季票享受服务 330
52超市模式： 越多越便宜 334
53以穷人为目标的商业模式： 锁定处于收入金字塔底层的消费者 338
54垃圾变现模式： 垃圾变现金 343
55双边市场模式： 激发间接网络效应 348
56极致奢侈模式： 只有想不到， 没有做不到 353
57用户设计模式： 用户成为独具创造性的创业者 358
58白标模式： 实施自己的品牌策略 363
第三部分 商业模式创新实践
59商业模式创新的十个建议 371
60 55 种商业模式概述 375
61 附录 391
译者后记 398
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>商业模式创新设计大全：90%的成功企业都在用的55种商业模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>建筑的永恒之道
永恒之道
第1章 永恒之道
质
第2章 无名特质
第3章 生机勃勃
第4章 事件模式
第5章 空间模式
第6章 有活力的模式
第7章 有活力模式的复合
第8章 特质本身
门
第9章 花与种子
第10章 我们的模式语言
第11章 我们的模式语言（续）
第12章 语言的创造力
第13章 语言的瓦解
第14章 可共享的模式
第15章 模式的真实
第16章 语言的结构
第17章 城市共同语言的演化
道
第18章 语言的发生力
第19章 空间的分化
第20章 每次一个模式
第21章 建筑的形成
第22章 建筑组团的形成
第23章 建造的过程
第24章 修整的过程
第25章 城市的缓慢出现
第26章 其超时代的特征
道之核心
第27章 道之核心
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>建筑的永恒之道
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>2009室内设计模型
现代风格
中式风格
欧式风格
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>2009室内设计模型
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>薪酬体系设计：结构化设计方法——人力资源管理新模式丛书
第1章 薪酬体系的战略思考
  中国企业薪酬分配问题分析
  薪酬分配的四个基本命题
  薪酬分配的根本目的
  新经济时代薪酬分配的显著特点
  基于战略的薪酬体系模型
第2章 薪酬战略制定及框架结构设计
  企业工作文化与薪酬战略
  企业发展阶段与薪酬战略
  薪酬的评价要素
  薪酬体系结构
第3章 工作分析与职位评估
  工作分析
  职位描述-----职位说明书
  职位评估
第4章 薪酬数据调查
  薪酬调查的基本问题
  影响薪酬外部竞争性因素
  薪酬调查方法
第5章 薪酬制度设计
  工资政策线的制定----外部公平性
  工资结构的制定----内部公平性
  工资等级及区间设计
  年薪制的设计
  以绩效为导向的工资制度设计
  以能力为导向的工资制度设计
  计量制工资制度设计
  奖金分配设计
  特殊团队的薪酬制度
第6章 股票期权设计
  股票期权产生的历史过程
  股票期权设计的基本原则
  美国股票期权种类
  经营者股票期权及激励效果
  美国知名企业股票期权方案
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>薪酬体系设计：结构化设计方法——人力资源管理新模式丛书
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>环境设计模型制作艺术
前言
第一章模型的概述
第二章模型的工具、材料及特殊工艺
第一节工具
第二节材料
第三节常见的几种特殊工艺
第三章模型的制作过程
第一节模型表现方案的设计
第二节建筑单体模型的制作过程
第三节建筑小区模型的制作过程
第四节方案工作模型的制作过程
第五节环境景观模型的制作过程
第六节室内剖面模型的制作过程
第七节产品模型的制作过程
第八节铁道、舰船、航空模型的制作
第四章模型的声、光、电、影效果
第一节关于光源及电路
第二节声、光、电、影效果合成框架
第三节模型的气雾效果
第五章模型的未来发展趋势
第一节模型材料的发展
第二节模型加工手段的发展
第三节模型与高科技结合的发展趋势
第六章模型的欣赏及其教学应用
第一节构成模型审美的几大要素
第二节建筑模型在教学实践中的必要性
第三节建筑模型专题教学方案研讨
第七章模型的商业策划及运作
第一节房地产销售模型的解决方案
第二节科普模型策划的解决方案
第八章模型艺术作品集锦
编后语
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>环境设计模型制作艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>巅峰创想—精彩纸质包装盒设计模版
第1章 纸质包装设计基础
第2章 国际标准盒型
第3章 经典案例
第4章 趣味纸盒
第5章 环保包装
第6章 五花八门的模切版
第7章 隔板和纸托
结束语
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>巅峰创想—精彩纸质包装盒设计模版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>郊区改造
前言vi
2011版更新内容viii
在当前形势下郊区改造比以往更具有现实性viii
美国经济大萧条产生的影响xi
公共部门应该发挥主导作用xiii
再居住：对现状设施进行适当再利用，提供更多的社区服务xiv
再开发：拆建原有建筑，以及在地面停车场上进行建设xv
再绿化：已开发用地上的生态系统恢复xxi
立足当下，展望未来xxii
引语xxv
导论xxvii
城市与郊区的建设形态比较xxviii
为什么要进行郊区改造？为什么选择现在？xxx
老化、过时的近郊房产xxx
边缘城市或“无边界城市”中繁荣的新建成区xxx
郊区区位和经济特征的转变xxxi
人口和市场特征的转变xxxi
精明增长的政策和实践xxxi
本书的组织结构xxxi
致谢xxxiii
第一部分论证
第1章
速成建筑、速成城市和渐进大都市主义
速成城市和郊区改造2
速成建筑，速成公共空间6
渐进大都市主义9
如何可持续？如何城市化？11
第二部分案例
第2章
改造花园住宅和居住小区，强调密度发展，适应人口新形势
绝不同质？新郊区化发展史17
人口构成变化17
改造政策20
改造居住小区21
改变规则：堪萨斯城第一郊区协会和西雅图的独立附属住宅单元23
连通尽端路：阿波罗海滩和劳瑞海湾24
从居住小区到边缘城市：格林韦广场25
从居住小区到TOD：地铁西区27
整合花园公寓的缓冲区29
容纳新移民：布鲁克赛德公寓和格夫顿30
市场价值贬低：帕克福里斯特居住区32
中产阶级化填充式改造：格拉姆西和侨居村33
明日的郊区居民35
第3章
住宅区改造案例：“莱维敦”改造
二战后的早期郊区住宅走过60年
莱维敦、威林伯勒和帕克福里斯特人口的多样性46
零售地产的挫败和再开发51
居住模式改变的困难52
多元化住宅选择53
通向未来变化之路55
第4章
改造商业街区域的社会生活
郊区的第三场所？59
ICSC购物中心定义61
商业街的历史及建筑类型62
从城镇驶向外围的旅途62
适当再利用大型购物中心和购物广场为社区服务设施66
拯救“鬼屋”67
从购物广场到社区标志物：拉格兰德橙和卡米诺·奴沃69
改造购物中心：中等尺度71
用地返绿: 法伦72
支持改造的公共部门策略75
桑塔纳街通向富裕阶层的不平坦道路77
从商业街中心到新建城市中心区：坦帕台80
改造廊道：为机动交通、可达性交通还是为两者而设计81
大运量公共交通大道和城市交通网络82
多路径林荫大道的回归：大主教城84
廊道二次区划：亚特兰大的三个案例86
通过基于形态的区划法则吸引大运量公共交通：以哥伦比亚派克为例89
改造商业街区的城市结构92
社会基础设施93
第5章
购物广场实例:马萨诸塞州鳕鱼角的马什皮康芒斯
一个完善的城市化片段的技术指标
基地历史98
从商业街到市中心：马什皮的第三场所101
形态学分析102
第6章
通过混合功能利用和公共空间塑造，将区域性购物中心改造为新的城市中心区
公共空间的重要性110
商场的简明发展史112
倒闭和濒临倒闭的购物中心114
华尔街巨鳄：零售店房地产投资信托基金115
改变用途来满足地方需求117
再开发的障碍118
缩小面积：帕克福里斯特和威林伯勒119
从封闭式的购物中心到新城市中心区122
从倒闭的购物中心到新的城市中心区：米兹纳公园123
释放购物中心的内部空间：冬季公园村125
丹佛市周边的渐进式大都市化：恩格尔伍德城市中心129
在有活力的购物中心周边的填充式开发134
既保护树木，又有蒂凡尼首饰：核桃溪市134
从购物中心到大运量公共交通服务的大学和办公楼：萨里中心城136
改造后购物中心的混合利用和公共空间的职能与形式137
改造购物中心的技巧总结139
第7章
购物中心案例研究：犹他州霍拉迪市的卡顿伍德
从理念到公布规则
对购物中心地产的重新定位142
市场研究与小型专家研讨会143
专家研讨会146
召开专家研讨会的益处151
第8章
购物中心案例研究：贝尔玛，莱克伍德市，科罗拉多州
莱克伍德新城市中心区：“不是美化你的草坪，而是丰富你的生活”
“用地返绿”：寻找可持续城市化的资金来源159
与莱克伍德市政执行官迈克·洛克的问答161
形态学分析162
从沙坑到街道景观的蜕变：公共空间166
新功能/新的使用者170
第9章
边缘城市的填充式建设：改善可步行性和街道的连通性
对边缘城市的重新定位173
设计适于步行的场所175
边缘城市和无边界城市的演化177
无边界城市179
填充边缘城市179
阿狄森瑟克尔180
莱加西城镇中心182
佩里米特中心183
增建策略产生了怎样的效果？185
涉及多个地块的边缘城市改造187
边缘城市的未来191
第10章
边缘城市案例研究：佛罗里达州迈阿密戴德县肯德尔城市中心区/戴德兰德
利用区划手段在多个地块内设置新的街区和广场
调整城市化过程的框架结构196
形态学分析198
人口分析：互通性带来的益处201
第11章
以吸引创意阶层为目的的郊区办公和工业园区改造
郊区工业园区、办公园区和企业园区204
非同心的通勤模式206
办公和工业园区的改造优势207
多中心发展的亚特兰大：莱诺克斯园区的贝尔南方公司、中城和林德伯格城市中心207
聘用创意阶层209
创意校园：天歌210
郊区生产性用地的改造211
玻璃框架Loft：九云天阁212
州际公路上的Loft空间：厄珀罗克213
马里兰州洛克维尔的改造项目为何如此之多？215
工业园区改造216
速成城市化：韦斯特伍德车站周边区域217
第12章
办公园区研究：马里兰州乔治王子县大学城中心项目
延续半个世纪的工程
大运量公共交通为增建混合功能利用的设施创造了机会222
形态学分析225
人口分析：对创意阶层是否具有吸引力？228
后记
2050年渐进大都市化的城市图景
注释234
图片版权248
词汇表249
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>郊区改造
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>国广一叶室内设计模型库
办公建筑
酒店建筑
商业建筑
文化建筑
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>国广一叶室内设计模型库
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>国广一叶室内设计模型库.构成元素.1
家具
灯具电器
装饰细部
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>国广一叶室内设计模型库.构成元素.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>国广一叶室内设计模型库
客厅
其他功能用房
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>国广一叶室内设计模型库
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>国广一叶室内设计模型库
家具
灯具电器
装饰细部
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>国广一叶室内设计模型库
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>欧式风格家居(附光盘)(精)/2017室内设计模型库
客厅
卧室
其他功能空间
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>欧式风格家居(附光盘)(精)/2017室内设计模型库
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>2018室内设计模型集成
办公空间
商业空间
学校空间
房产空间
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>2018室内设计模型集成
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>33堂倫敦設計大師的創意＆創益思考課
Chapter 1__Insight 伦敦文创力解析
1-1 Christine Losecaat（Little Dipper国际顾问公司负责人）
──全球化媒体就是你创业的平台
1-2 Iwona Maria Blazwick（Whitechapel Gallery创意总监）
──了解你的天赋，并致力于获得此专业百分之百的知识
1-3 John Howkins（文创之父，《创意经济》作者）
──独立、包容、实验、挑战，打造多元创意城市
1-4 Martin Roth（维多利亚&亚伯特博物馆馆长）
──伦敦在厚实传统的文化中，焠鍊出当代城市视野
1-5 Tony Chambers（Wallpaper*总编辑）
──编辑是每位成功创作者的必备技能
Chapter 2__Creative Spirit伦敦创意热点
2-1 伦敦，文创产业的兴起与繁荣
2-2伦敦创意地点
2-3伦敦创意事件
2-4 伦敦艺术&设计学校
Chapter 3__Map for Idea Finding伦敦灵感地图
Chapter 4__Born to create 伦敦设计大师的创意&创益思考课
平面设计师──
Fuel
John Morgan
Marcus Fairs
Mark Noad
Nicolas Roope
产品／家具设计师──
Glithero Studio
Industrial Facility
Paperself
Peter Marigold
REAL STUDIOS
Stuart Haygarth
安积伸
服装／织品设计师──
Hussein Chalayan
The Rug Company
Zandra Rhodes
陈劭彦
工业设计师──
Georg Baldele
Marc Newson
Paul Cocksedge
Ross Lovegrove

建筑师──
Albert Taylor-Williams
Kevin Owens
Malcolm Reading
Rod Sheard

装置艺术／艺术家──0
Ben Evans
Linda Florence
Mark Humphrey
Alexandra Daisy Ginsberg
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>33堂倫敦設計大師的創意＆創益思考課
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>生态战略：设计未来企业新模式
第一部分 生态思维
1.生态：企业进化新思维
有一种说法认为产品型公司值十亿美金，平台型公司值百亿美金，生态型公司值千亿美金，这背后蕴含着怎样的企业成长逻辑?互联网早已超越单纯的技术属性，成为社会、文化与技术的综合体，深度改变着这个世界的运行法则，无论是新生的未来型企业还是不断进化的传统企业，都在被新的法则接管。
2.价值网：生态价值模式的创新
和传统企业相比，未来企业的价值评估有着极大的不同，甚至是颠覆了传统的经济理论，全新的企业生态价值公式，也重新定义了企业的增长模式。这股生态系统的“洪荒之力”，不仅改变了企业运营的方式，它在重构产业价值链的同时，也必将重塑产业竞争的格局，构建起全新的生态价值网络。
第二部分 生态战略
3.生态位与战略跃迁
每一个物种都拥有自己的角色和地位，占据特定的空间，发挥特定的功能，即“生态位”。然而企业在商业中的生态位并不是一成不变，企业从一颗充满希望的“种子”，成长为市场上不可撼动的参天“大树”，再通过共享与开放的战略，成为共生共荣的“森林”，需要经历两次生态位的战略跃迁。
4. 生态角色与战略选择
这是一个外部环境具有易变性、不确定性、复杂性和模糊性的时代，企业要想做出正确的战略选择，必须去了解所赖以生存的商业生态系统，洞察不同的生态类型对于战略能力的要求，并在动态进化的生态路径中，重新思考和定位自身在商业生态系统中可能扮演的角色。
5. 模块化、生态构件与战略组合
商业生态的建设不可能一蹴而就，在短时间内形成难以被攻破的复杂性，但模块化生长与组装可以帮助企业封装核心竞争力向生态进化。模块化作为半自律系统特有的独立性、可延展性、可变性等优势和生态战略的要求不谋而合。
6.  生态商业模式与盈利模式
不同的战略构件通过不同的策略组合成多样化的商业模式转盘，以用户为核心，以能力为半径，指向无限多的商业可能性。零边际成本存在的背后是这个世界正在不可逆转的数字化，并且将覆盖越来越多的商品，使其遵循免费（或低价）的网络法则，并推动着企业盈利模式从所有权到使用权，从产品到服务，从单一向复合进化。
第三部分 生态组织
7. 商业生态与组织进化法则
进化乃是万物的宿命，每一次颠覆性技术的出现都会推动商业生态发生新旧物种大规模替代。企业必须借进化之力，行演化之道，不断开放，相互连接，共同进化成开放的、多样化的、竞争的、自驱动组织，以提高在复杂的商业生态中生存的几率。
8.  企业组织与管理的新生态
战略决定组织，组织决定成败。我们已无法运用泰勒的原理，继续工作在韦伯的科层体制中去应对当今复杂的商业生态系统。当传统管理模式走向终结，生命、生态成为新管理范式的第一隐喻，未来企业又该以怎样的管理、结构、领导力和人才共筑组织与管理的新生态，使之成为新物种诞生与崛起的沃土呢？
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>生态战略：设计未来企业新模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>程序员修炼之道（第2版）
序 XVII
新版前言 XXI
第一版前言 XV
提示1：关注你的技艺 XVII
如果你不关心怎么做好，为什么还要花时间去开发软件呢？
提示2：思考！思考你的工作 XVII
关掉辅助驾驶，由自己掌控，持续不断地评估所做的工作。
第1章 务实的哲学 1
1 人生是你的 2
提示3：你有权选择 3
人生是自己的。把握住人生，让它如你所愿。
2 我的源码被猫吃了 3
提示4：提供选择，别找借口 5
提供选择而不是去找理由。不要只说做不到；解释一下都能做些什么。
3 软件的熵 6
提示5：不要放任破窗 7
只要看到不好的设计、错误的决策、糟糕的代码，就赶紧去纠正。
4 石头做的汤和煮熟的青蛙 9
提示6：做推动变革的催化剂 10
你无法强迫人们去改变，但可以展示美好未来，并帮助他们参与创造。
提示7：牢记全景 10
不要过度沉浸于细枝末节，以免察觉不到周围正在发生的事情。
5 够好即可的软件 11
提示8：将质量要求视为需求问题 12
让用户参与对项目真实质量需求的确定。
6 知识组合 14
提示9：对知识组合做定期投资 16
养成学习的习惯。
提示10：批判性地分析你读到和听到的东西 18
不要受供应商、媒体炒作或教条的影响，根据自身和项目的实际情况来分析信息。
7 交流！ 20
提示11：英语就是另一门编程语言 20
将英语视作一门编程语言。写文档和编程一样要遵循 DRY 原则、ETC、自动化等。
提示12：说什么和怎么说同样重要 23
如果无法有效交流，任何伟大的想法都是没有意义的。
提示13：把文档嵌进去，而不要栓在表面 24
与代码隔离的文档，很难保持正确并及时更新。
第2章 务实的方法 27
8 优秀设计的精髓 28
提示14：优秀的设计比糟糕的设计更容易变更 28
适合使用者的事物，都已经过良好设计。对代码来说，这意味着必须适应变化。
9 DRY——邪恶的重复 30
提示15：DRY——不要重复自己 31
系统中的每一条知识，都必须有单一且无歧义的权威陈述。
提示16：让复用变得更容易 39
只要复用方便，人们就会去做。创建一个支持复用的环境。
10 正交性 40
提示17：消除不相关事物之间的影响 41
设计的组件，需要自成一体、独立自主，有单一的清晰定义的意图。
11 可逆性 48
提示18：不设最终决定 50
不要把决定刻在石头上，而要将其视为写在沙滩上的东西，时刻准备应变。
提示19：放弃追逐时尚 50
尼尔·福特说过：“昨日之最佳实践，即明日之反模式。”要基于基本原则去选择架构，而不应盲从于流行。
12 曳光弹 51
提示20：使用曳光弹找到目标 53
通过不断尝试并看清着弹点，曳光弹可确保你最终击中目标。
13 原型与便签 57
提示21：用原型学习 58
制作原型旨在学习经验，其价值不在于过程中产生的代码，而在于得到的教训。
14 领域语言 60
提示22：靠近问题域编程 61
用问题领域的语言来做设计和编程。
15 估算 67
提示23：通过估算来避免意外 67
开始之前做估算，能提前发现潜在问题。
提示24：根据代码不断迭代进度表 72
利用实施过程中获得的经验来精细化项目的时间尺度。
第3章 基础工具 74
16 纯文本的威力 75
提示25：将知识用纯文本保存 76
纯文本不会过时。它能够让你的工作事半功倍，并能简化调试和测试工作。
17 Shell游戏 79
提示26：发挥 Shell 命令的威力 80
当图形化界面无法胜任时，使用 Shell。
18 加强编辑能力 82
提示27：游刃有余地使用编辑器 82
既然编辑器是至关重要的工具，不妨了解一下如何用它更快更准确地实现需求。
19 版本控制 85
提示28：永远使用版本控制 87
版本控制为你的工作创造了一个时间机器，可以用它重返过去。
20 调试 90
提示29：去解决问题，而不是责备 91
Bug 到底来自你的失误还是别人的失误真的不重要——它终究是你的问题，需要你来修复。
提示30：不要恐慌 91
不管是对银河系搭车客，还是对开发者来说，都应这样。
提示31：修代码前先让代码在测试中失败 93
在你修 Bug 前，先创建一个聚焦于该 Bug 的测试。
提示32：读一下那些该死的出错信息 93
大多数异常都能告诉失败之物与失败之处。如果足够幸运，你甚至能得到具体的参数值。
提示33：“select”没出问题 97
在操作系统或编译器中发现 Bug 非常罕见，甚至在第三方产品或库中也是如此。Bug 大多出现在应用程序中。
提示34：不要假设，要证明 97
在真实环境中证实你的假设——要依赖真实的数据及边界条件。
21 文本处理 99
提示35：学习一门文本处理语言 99
既然每天都要花大量的时间与文本打交道，何不让计算机帮你分担一二？
22 工程日记 101
第4章 务实的偏执 103
提示36：你无法写出完美的软件 103
软件不可能是完美的。对于在所难免的错误，要保护代码和用户免受其影响。
23 契约式设计 104
提示37：通过契约进行设计 107
代码是否不多不少刚好完成它宣称要做的事情，可以使用契约加以校验和文档化。
24 死掉的程序不会说谎 113
提示38：尽早崩溃 114
彻底死掉的程序通常比有缺陷的程序造成的损害要小。
25 断言式编程 115
提示39：使用断言去预防不可能的事情 115
如果一件事情不可能发生，那么就用断言来确保其的确不会发生。断言在校验你的假设，要使用断言在不确定的世界中将你的代码保护起来。
26 如何保持资源的平衡 119
提示40：有始有终 119
只要有可能，对资源进行分配的函数或对象就有责任去释放该资源。
提示41：在局部行动 122
将易变的变量维持在一个范围内，打开资源的过程要短暂且明显可见。
27 不要冲出前灯范围 127
提示42：小步前进——由始至终 127
永远小步前进，不断检查反馈，并且在推进前先做调整。
提示43：避免占卜 129
只在你能看到的范围内做计划。
第5章 宁弯不折 130
28 解耦 131
提示44：解耦代码让改变更容易 132
耦合使事物紧紧绑定在一起，以至于很难只改变其中之一。
提示45：只管命令不要询问 133
不要从对象中取出值，在加以变换后再塞回去，让对象自己来完成这些工作。
提示46：不要链式调用方法 135
当访问某事物时，使用的点号不要超过一个。
提示47：避免全局数据 137
最好给每个方法增加一个额外的参数。
提示48：如果全局唯一非常重要，那么将它包装到API 中 137
……但是，仅限于你真的非常希望它是全局的。
29 在现实世界中抛球杂耍 139
30 变换式编程 149
提示49：编程讲的是代码，而程序谈的是数据 151
所有的程序都在变换数据——将输入转换为输出。开始用变换式方法来设计吧！
提示50：不要囤积状态，传递下去 156
不要把数据保持在函数或模块的内部，拿出来传递下去。
31 继承税 162
提示51：不要付继承税 165
考虑一下能更好满足需求的替代方案，比如接口、委托或mixin。
提示52：尽量用接口来表达多态 167
无需继承引入的耦合，接口就能明确描述多态性。
提示53：用委托提供服务：“有一个”胜过“是一个” 167
不要从服务中继承，应该包含服务。
提示54：利用 mixin 共享功能 169
mixin 不必承担继承税就可以给类添加功能，而与接口结合可以让多态不再令人痛苦。
32 配置 170
提示55：使用外部配置参数化应用程序 170
如果代码对一些在应用程序发布后还有可能改变的值有所依赖，那么就在应用外部维护这些值。
第6章 并发 174
33 打破时域耦合 175
提示56：通过分析工作流来提高并发性 176
利用用户工作流中的并发性。
34 共享状态是不正确的状态 179
提示57：共享状态是不正确的状态 180
共享状态会带来无穷的麻烦，而且往往只有重启才能解决。
提示58：随机故障通常是并发问题 186
或许时间和上下文的变化能暴露并发Bug，但并发Bug无法始终保持一致，也很难重现。
35 角色与进程 187
提示59：用角色实现并发性时不必共享状态 188
使用角色来管理并发状态，可以避免显式的同步。
36 黑板 193
提示60：使用黑板来协调工作流 195
使用黑板来协调不相关的事实和代理人，能同时保持参与者之间的独立性和孤立性。
第7章 当你编码时 198
37 听从蜥蜴脑 199
提示61：倾听你内心的蜥蜴 201
当编程举步维艰时，其实是潜意识在告诉你有什么地方不对劲。
38 巧合式编程 204
提示62：不要依赖巧合编程 207
只能依赖可靠的事物。注意偶然事件的复杂性，不要混淆快乐的巧合与有目的的计划。
39 算法速度 210
提示63：评估算法的级别 214
在开始编程前，对这件事情大概会花多长时间要有概念。
提示64：对估算做测试 214
针对算法的数学分析无法说明所有问题，尝试在目标环境中测试一下执行代码的耗时。
40 重构 216
提示65：尽早重构，经常重构 219
像除草和翻整花园那样，只要有需要就对代码进行重新编写、修订和架构，以便找到问题的根源并加以修复。
41 为编码测试 220
提示66：测试与找 Bug 无关 221
测试是观察代码的一个视角，可以从中得到针对设计、接口和耦合度的反馈。
提示67：测试是代码的第一个用户 222
用测试的反馈来引导工作。
提示68：既非自上而下，也不自下而上，基于端对端构建 225
创建一小块端到端的功能，从中获悉问题之所在。
提示69：为测试做设计 228
写下代码之前先从测试角度思考。
提示70：要对软件做测试，否则只能留给用户去做 230
无情地测试，不要等用户来帮你找 Bug。
42 基于特性测试 231
提示71：使用基于特性的测试来校验假设 231
基于特性的测试将会进行你从未想过的尝试，并会以你不曾打算采用的方式操练你的代码。
43 出门在外注意安全 238
提示72：保持代码简洁，让攻击面最小 241
复杂的代码给 Bug 以滋生之沃土，给攻击者以可趁之机。
提示73：尽早打上安全补丁 243
攻击者会尽可能快地部署攻击，你必须快上加快。
44 事物命名 245
提示74：好好取名；需要时更名 249
用名字向读者表达你的意图，并且在意图改变时及时更名。
第8章 项目启动之前 251
45 需求之坑 252
提示75：无人确切知道自己想要什么 252
他们或许知道大概的方向，但不会了解过程的曲折。
提示76：程序员帮助人们理解他们想要什么 253
软件开发更像是一种由用户和程序员协同创造的行为。
提示77：需求是从反馈循环中学到的 254
理解需求需要探索和反馈，因此决策的结果可以用来完善最初的想法。
提示78：和用户一起工作以便从用户角度思考 255
这是看透系统将如何被真正使用的最佳方法。
提示79：策略即元数据 256
不要将策略硬编码进系统，而应该将其表达为系统的一组元数据。
提示80：使用项目术语表 259
为项目的所有特定词汇创建一张术语表，并且在单一源头维护。
46 处理无法解决的难题 260
提示81：不要跳出框框思考——找到框框 261
在面对无法解决的难题时，识别出真正的约束。可以问自己：“必须这样做才能搞定吗？必须搞定它吗？”
47 携手共建 264
提示82：不要一个人埋头钻进代码中 267
编程往往困难又费力，找个朋友和你一起干。
提示83：敏捷不是一个名词；敏捷有关你如何做事 267
敏捷是一个形容词，有关如何做事情。
48 敏捷的本质 267
第9章 务实的项目 271
49 务实的团队 272
提示84：维持小而稳定的团队 272
团队应保持稳定、小巧，团队中的每个人都应相互信任、互相依赖。
提示85：排上日程以待其成 274
如果你不把事情纳入日程表，它们就不会发生。反思、实验、学习、提高技能，这些事都应放入日程表。
提示86：组织全功能的团队 276
围绕功能而不是工作职能组织团队。不要将 UI/UX 设计者从程序员中分离出去，也不要分开前端和后端；不要区分数据建模者和测试人员，以及开发和设计。构建一个团队，这样你就可以渐进地不断迭代端到端的代码。
50 椰子派不上用场 277
提示87：做能起作用的事，别赶时髦 279
不要仅仅因为别的公司正在那么干就采纳一项技术或采用一个开发方法，而是要采用自己所处环境中对团队有效的东西。
提示88：在用户需要时交付 281
不要卡着流程要求，刻意等到几周甚至几个月后才交付。
51 务实的入门套件 281
提示89：使用版本控制来驱动构建、测试和发布 282
利用提交或推送来触发构建、测试、发布，利用版本控制的标签来进行生产部署。
提示90：尽早测试，经常测试，自动测试 283
每次构建都跑一下的测试，要比束之高阁的测试计划有效得多。
提示91：直到所有的测试都已运行，编码才算完成 283
无须多言。
提示92：使用破坏者检测你的测试 285
在一个单独的源码副本中特意引入 Bug，验证测试能否将其捕获。
提示93：测试状态覆盖率，而非代码覆盖率 286
要识别并测试重要的程序状态，只测试一行行的代码是不够的。
提示94：每个 Bug 只找一次 286
只要人类测试者找到一个 Bug ，就应该是该 Bug 最后一次被人类发现。从此之后，自动化测试完全可以发现它。
提示95：不要使用手动程序 287
计算机能一次又一次，按照同样的次序，执行相同的指令。
52 取悦用户 288
提示96：取悦用户，而不要只是交付代码 289
为用户开发能够带来商业价值的解决方案，并让他们每天都感到愉快。
提示97：在作品上签名 290
过去的工匠在为他们的作品签名时非常自豪，你也应该这样。
53 傲慢与偏见 290
跋 292
提示98：先勿伤害 293
犯错在所难免，确保犯错后没人会因此受难。
提示99：不要助纣为虐 294
因为这样做你也有变成纣王的风险。
参考文献 295
练习的参考答案 297
译者跋 312
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>程序员修炼之道（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>建筑模式语言（上下）
上册
本书使用说明
1 《建筑模式语言》
2 《建筑模式语言》概要
3 为你的设计选用模式语言
4 诗意盎然的模式语言
一、城镇  使用语言模式
下册
二、建筑  使用语言模式
三、构造  使用语言模式
四、城镇  使用语言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>建筑模式语言（上下）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业应用架构模式
译者序
前言
模式列表
引言 1
0.1 架构 1
0.2 企业应用 2
0.3 企业应用的种类 3
0.4 关于性能的考虑 4
0.5 模式 6
0.5.1 模式的结构 7
0.5.2 模式的局限性 9
第一部分 表述
第1章 分层 12
1.1 企业应用中层次的演化 13
1.2 三个基本层次 14
1.3 为各层选择运行环境 15
第2章 组织领域逻辑 19
2.1 抉择 22
2.2 服务层 23
第3章 映射到关系数据库 25
.3.1 架构模式 25
3.2 行为问题 28
3.3 读取数据 29
3.4 结构映射模式 30
3.4.1 关系的映射 30
3.4.2 继承 33
3.5 建立映射 34
3.6 使用元数据 35
3.7 数据库连接 36
3.8 其他问题 38
3.9 进一步阅读 38
第4章 Web表现层 39
4.1 视图模式 41
4.2 输入控制器模式 43
4.3 进一步阅读 43
第5章 并发 45
5.1 并发问题 45
5.2 执行语境 46
5.3 隔离与不变性 47
5.4 乐观并发控制和悲观并发控制 48
5.4.1 避免不一致读 49
5.4.2 死锁 49
5.5 事务 50
5.5.1 ACID 51
5.5.2 事务资源 51
5.5.3 减少事务隔离以提高灵活性 52
5.5.4 业务事务和系统事务 53
5.6 离线并发控制的模式 54
5.7 应用服务器并发 55
5.8 进一步阅读 56
第6章 会话状态 57
6.1 无状态的价值 57
6.2 会话状态 58
6.3 存储会话状态的方法 59
第7章 分布策略 61
7.1 分布对象的诱惑 61
7.2 远程接口和本地接口 62
7.3 必须使用分布的情况 63
7.4 关于分布边界 64
7.5 分布接口 64
第8章 通盘考虑 67
8.1 从领域层开始 67
8.2 深入到数据源层 68
8.2.1 事务脚本的数据源 68
8.2.2 表模块的数据源 69
8.2.3 领域模型的数据源 69
8.3 表现层 69
8.4 一些关于具体技术的建议 70
8.4.1 Java和J2EE 70
8.4.2 .NET 71
8.4.3 存储过程 71
8.4.4 Web Services 72
8.5 其他分层方式 72
第二部分 模 式
第9章 领域逻辑模式 76
9.1 事务脚本（Transaction Script） 76
9.1.1 运行机制 76
9.1.2 使用时机 77
9.1.3 收入确认问题 78
9.1.4 例：收入确认（Java） 78
9.2 领域模型（Domain Model） 81
9.2.1 运行机制 81
9.2.2 使用时机 83
9.2.3 进一步阅读 83
9.2.4 例：收入确认（Java） 84
9.3 表模块（Table Module） 87
9.3.1 运行机制 88
9.3.2 使用时机 90
9.3.3 例：基于表模块的收入确认（C#） 90
9.4 服务层（Service Layer） 93
9.4.1 运行机制 94
9.4.2 使用时机 96
9.4.3 进一步阅读 96
9.4.4 例：收入确认（Java） 96
第10章 数据源架构模式 101
10.1 表数据入口（Table Data Gateway） 101
10.1.1 运行机制 101
10.1.2 使用时机 102
10.1.3 进一步阅读 102
10.1.4 例：人员入口（C#） 103
10.1.5 例：使用ADO.NET数据集（C#） 104
10.2 行数据入口（Row Data Gateway） 106
10.2.1 运行机制 107
10.2.2 使用时机 108
10.2.3 例：人员记录（Java） 108
10.2.4 例：领域对象的数据保持器（Java） 111
10.3 活动记录（Active Record） 112
10.3.1 运行机制 112
10.3.2 使用时机 113
10.3.3 例：一个简单的Person类（Java） 113
10.4 数据映射器（Data Mapper） 115
10.4.1 运行机制 116
10.4.2 使用时机 119
10.4.3 例：一个简单的数据映射器（Java） 119
10.4.4 例：分离查找方法（Java） 123
10.4.5 例：创建一个空对象（Java） 126
第11章 对象－关系行为模式 129
11.1 工作单元（Unit of Work） 129
11.1.1 运行机制 129
11.1.2 使用时机 133
11.1.3 例：使用对象注册的工作单元（Java） 134
11.2 标识映射（Identity Map） 137
11.2.1 运行机制 137
11.2.2 使用时机 139
11.2.3 例：标识映射中的方法（Java） 139
11.3 延迟加载（Lazy Load） 140
11.3.1 运作机制 140
11.3.2 使用时机 142
11.3.3 例：延迟初始化（Java） 142
11.3.4 例：虚代理（Java） 142
11.3.5 例：使用值保持器（Java） 144
11.3.6 例：使用重影（C#） 144
第12章 对象－关系结构模式 151
12.1 标识域（Identity Field） 151
12.1.1 工作机制 151
12.1.2 使用时机 154
12.1.3 进一步阅读 154
12.1.4 例：整型键（C#） 154
12.1.5 例：使用键表（Java） 155
12.1.6 例：使用组合键（Java） 157
12.2 外键映射（Foreign Key Mapping） 166
12.2.1 运行机制 167
12.2.2 使用时机 169
12.2.3 例：单值引用（Java） 169
12.2.4 例：多表查询（Java） 172
12.2.5 例：引用集合（C#） 173
12.3 关联表映射（Association Table Mapping） 175
12.3.1 运行机制 176
12.3.2 使用时机 176
12.3.3 例：雇员和技能（C#） 177
12.3.4 例：使用直接的SQL（Java） 179
12.3.5 例：用一次查询查多个雇员（Java） 182
12.4 依赖映射（Dependent Mapping） 186
12.4.1 运行机制 186
12.4.2 使用时机 187
12.4.3 例：唱片和曲目（Java） 188
12.5 嵌入值（Embedded Value） 190
12.5.1 运行机制 190
12.5.2 使用时机 190
12.5.3 进一步阅读 191
12.5.4 例：简单值对象（Java） 191
12.6 序列化LOB（Serialized LOB） 192
12.6.1 运行机制 193
12.6.2 使用时机 194
12.6.3 例：在XML中序列化一个部门层级（Java） 194
12.7 单表继承（Single Table Inheritance） 196
12.7.1 运行机制 197
12.7.2 使用时机 197
12.7.3 例：运动员的单表（C#） 198
12.7.4 从数据库中加载对象 199
12.8 类表继承（Class Table Inheritance） 202
12.8.1 运行机制 202
12.8.2 使用时机 203
12.8.3 进一步阅读 203
12.8.4 例：运动员和他们的家属（C#） 203
12.9 具体表继承（Concrete Table Inheritance） 208
12.9.1 运行机制 209
12.9.2 使用时机 210
12.9.3 例：具体运动员（C#） 210
12.10 继承映射器（Inheritance Mappers） 214
12.10.1 运行机制 215
12.10.2 使用时机 216
第13章 对象－关系元数据映射模式 217
13.1 元数据映射（Metadata Mapping） 217
13.1.1 运行机制 217
13.1.2 使用时机 218
13.1.3 例：使用元数据和反射（Java） 219
13.2 查询对象（Query Object） 224
13.2.1 运行机制 225
13.2.2 使用时机 225
13.2.3 进一步阅读 226
13.2.4 例：简单的查询对象（Java） 226
13.3 资源库（Repository） 228
13.3.1 运行机制 229
13.3.2 使用时机 230
13.3.3 进一步阅读 231
13.3.4 例：查找一个人所在的部门（Java） 231
13.3.5 例：资源库交换策略（Java） 231
第14章 Web表现模式 233
14.1 模型－视图－控制器（Model View Controller） 233
14.1.1 运行机制 233
14.1.2 使用时机 234
14.2 页面控制器（Page Controller） 235
14.2.1 运行机制 235
14.2.2 使用时机 236
14.2.3 例：Servlet控制器和JSP视图的简单演示（Java） 236
14.2.4 例：使用JSP充当处理程序（Java） 238
14.2.5 例：代码隐藏的页面控制器（C#） 241
14.3 前端控制器（Front Controller） 243
14.3.1 运行机制 244
14.3.2 使用时机 245
14.3.3 进一步阅读 246
14.3.4 例：简单的显示（Java） 246
14.4 模板视图（Template View） 248
14.4.1 运行机制 249
14.4.2 使用时机 251
14.4.3 例：分离的控制器，使用JSP充当视图（Java） 252
14.4.4 例：ASP.NET服务器页面（C#） 253
14.5 转换视图（Transform View） 256
14.5.1 运行机制 256
14.5.2 使用时机 257
14.5.3 例：简单的转换（Java） 257
14.6 两步视图（Two Step View） 259
14.6.1 运行机制 259
14.6.2 使用时机 260
14.6.3 例：两阶XSLT（XSLT） 264
14.6.4 例：JSP和定制标记（Java） 266
14.7 应用控制器（Application Controller） 269
14.7.1 运行机制 270
14.7.2 使用时机 271
14.7.3 进一步阅读 271
14.7.4 例：状态模型应用控制器（Java） 271
第15章 分布模式 275
15.1 远程外观（Remote Facade） 275
15.1.1 运行机制 276
15.1.2 使用时机 278
15.1.3 例：使用Java语言的会话bean来作为远程外观（Java） 278
15.1.4 例：Web Service（C#） 281
15.2 数据传输对象（Data Transfer Object） 285
15.2.1 运行机制 285
15.2.2 使用时机 288
15.2.3 进一步阅读 289
15.2.4 例：传输唱片信息（Java） 289
15.2.5 例：使用XML实现序列化（Java） 293
第16章 离线并发模式 295
16.1 乐观离线锁（Optimistic Offline Lock） 295
16.1.1 运行机制 296
16.1.2 使用时机 298
16.1.3 例：领域层与数据映射器（Java） 298
16.2 悲观离线锁（Pessimistic Offline Lock） 302
16.2.1 运行机制 303
16.2.2 使用时机 305
16.2.3 例：简单锁管理对象（Java） 305
16.3 粗粒度锁（Coarse-Grained Lock） 310
16.3.1 运行机制 310
16.3.2 使用时机 312
16.3.3 例：共享的乐观离线锁（Java） 312
16.3.4 例：共享的悲观离线锁（Java） 316
16.3.5 例：根对象乐观离线锁（Java） 317
16.4 隐含锁（Implicit Lock） 318
16.4.1 运行机制 318
16.4.2 使用时机 319
16.4.3 例：隐含的悲观离线锁（Java） 319
第17章 会话状态模式 321
17.1 客户会话状态（Client Session State） 321
17.1.1 运行机制 321
17.1.2 使用时机 322
17.2 服务器会话状态（Server Session State） 322
17.2.1 运行机制 322
17.2.2 使用时机 324
17.3 数据库会话状态（Database Session State） 324
17.3.1 运行机制 324
17.3.2 使用时机 325
第18章 基本模式 327
18.1 入口（Gateway） 327
18.1.1 运行机制 327
18.1.2 使用时机 328
18.1.3 例：私有消息服务的入口（Java） 329
18.2 映射器（Mapper） 331
18.2.1 运行机制 332
18.2.2 使用时机 332
18.3 层超类型（Layer Supertype） 332
18.3.1 运行机制 332
18.3.2 使用时机 333
18.3.3 例：领域对象（Java） 333
18.4 分离接口（Separated Interface） 333
18.4.1 运行机制 334
18.4.2 使用时机 335
18.5 注册表（Registry） 335
18.5.1 运行机制 336
18.5.2 使用时机 337
18.5.3 例：单子注册表（Java） 337
18.5.4 例：线程安全的注册表（Java） 338
18.6 值对象（Value Object） 339
18.6.1 运行机制 339
18.6.2 使用时机 340
18.7 货币（Money） 340
18.7.1 运行机制 341
18.7.2 使用时机 342
18.7.3 例：货币类（Java） 343
18.8 特殊情况（Special Case） 346
18.8.1 运行机制 347
18.8.2 使用时机 347
18.8.3 进一步阅读 347
18.8.4 例：一个简单的空对象（C#） 347
18.9 插件（Plugin） 348
18.9.1 运行机制 349
18.9.2 使用时机 350
18.9.3 例：ID生成器（Java） 350
18.10 服务桩（Service Stub） 352
18.10.1 运行机制 352
18.10.2 使用时机 353
18.10.3 例：销售税服务（Java） 353
18.11 记录集（Record Set） 355
18.11.1 运行机制 355
18.11.2 使用时机 356
参考文献 359
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业应用架构模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual Basic语言程序设计模拟试卷
1 笔试模拟试卷及参考答案
2 上机考试模拟试卷
3 附录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual Basic语言程序设计模拟试卷
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高级语言程序设计模拟试题分析与解答
模拟试题（一）
模拟试题（一）参考解答
模拟试题（一）试题分析
模拟试题（二）
模拟试题（二）参考解答
模拟试题（二）试题分析
模拟试题（三）
模拟试题（三）参考解答
模拟试题（三）试题分析
模拟试题（四）
模拟试题（四）参考解答
模拟试题（四）试题分析
模拟试题（五）
模拟试题（五）参考解答
模拟试题（五）试题分析
……
参考书目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高级语言程序设计模拟试题分析与解答
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>新商业模式创新设计：当资本插上“互联网+”的翅膀
第一章
资本与“互联网+”帮助企业高速成长 / 1
一、类金融模式设计——积德粮行的案例 / 1
二、云南龙生普洱茶公司的农业与“互联网+”商业模式 / 2
三、“定向增发基金”的商业模式 / 5
四、“喜临门”基金持股模式 / 8
五、泸州老窖的“期权模式”，绑定经销商的利益 / 9
六、《新资本模式课程》的全新商业模式：“买课程+送股权”模式 / 10
七、“借壳上市”模式，通过资产增发实现 / 12
八、如何通过“买壳”模式赚钱 / 14
九、“并购基金”的商业模式 / 17
十、互联网+ / 18
十一、新三板的高成长型企业案例分析 / 20
第二章
新商业模式的典型类型与定位 / 32
一、传统经营模式的误区 / 32
二、什么才是真正的商业模式 / 37
【案例一】 中国奥运代表队改革后的商业模式，夺得51块金牌的真相 / 38
【案例二】 蒙牛起家时的商业模式 / 39
【案例三】 古罗马繁荣昌盛的模式 / 39
【案例四】 一本高端杂志全新的商业模式 / 40
【案例五】 唱片行业的商业模式 / 41
三、商业模式成功的前提，选对人胜过做对事 / 42
【案例一】 刘邦封一人而安天下，用君子也要用小人 / 42
【案例二】 爱而知其短，恨而用其长 / 44
【案例三】 不要让沉默的人寂寞，不要让伯乐不快乐 / 45
【案例四】 用人所长，叫智慧；用人所短，叫大智慧 / 46
【案例五】 用人就是用天赋，没有天赋的专业是无效的专业 / 47
四、人才的资产负债理论 / 49
第三章
新商业模式的运用与创新 / 52
一、“消费者+股东”模式（适用于所有连锁企业、奢侈品行业） / 52
【案例一】 M1NT 股东制富豪俱乐部 / 52
二、开创蓝海成功的唯一途径：分化模式（适合于所有能创品牌的行业） / 54
【案例一】 苹果掌上电脑、海尔两用洗衣机、娃哈哈咖啡可乐、微软智能钱包
失败的案例 / 61
【案例二】 分化带来的巨大商机 / 62
三、模式创新=复制+改良 / 64
四、创新成功的几个案例 / 66
五、发现产业中的高利润区，要么聚焦高端，要么聚焦低端（适合于所有行业） / 69
【案例一】 航空业、百货业、汽车行业走中间路线失败的教训 / 70
【案例二】 中国台湾液晶电视品牌维伊奥聚焦高端，获得高利润 / 74
【案例三】 美国“全食食品”聚焦高端，成为美国最大的“有机食品连锁超市” / 76
【案例四】 乐活城聚焦高端有机蔬菜 / 77
【案例五】 美国“布法罗鸡翅酒吧”聚焦低端，计划要开1000家分店 / 78
【案例六】 纯本百货独创“0租金、0折扣率、7天一结账”模式 / 80
【案例七】 一分钟诊所聚焦低端，让看病相对标准化 / 81
【案例八】 瑞文眼科的低成本商业模式 / 83
【案例九】 倍智咨询的商业模式：人力资源的“沃尔玛” / 88
六、零售业如何创新商业模式的5个步骤（适用于所有零售业、经销商、连锁企业） / 90
【案例一】 道法自然的聚焦战略 / 93
【案例二】 麦当劳标准化的前提，聚焦战略 / 94
【案例三】 两大手机行业竞争比较 / 95
【案例四】 体育品牌竞争分析 / 96
【案例五】 舍得的艺术，管理好自己的欲望 / 98
【案例六】 汽车产业的竞争关系 / 98
【案例七】 春兰空调的教训 / 103
【案例八】 茶饮料竞争的误区 / 104
【案例九】 聚焦玩具，玩具反斗城的超常规发展的商业模式 / 105
【案例十】 李文锁城，聚焦锁类，广泛进货，获得成功 / 107
【案例十一】 一家聚焦女子百货，创新的商业模式 / 108
【案例十二】“ 一伍一拾”聚焦10元钱的千万生意，年收入近亿元 / 111
【案例十三】 “ 完美健身”完美转型成功的商业模式 / 114
【案例十四】 聚焦三明治，赛百味在全球独领风骚 / 116
【案例十五】 聚焦存货，广泛进货，上海炫动的模式被大量复制 / 117
【案例十六】 戴尔电脑曾经犯下的错误 / 124
【案例十七】 沃尔沃汽车曾经在瑞典的错误战略 / 125
【案例十八】 取得市场主导权以后，应该何去何从 / 127
七、“加码”模式（“钩”和“饵”的模式）的创新（适合于所有行业） / 129
【案例一】 亚布罕靠“加码”赚大钱，成为全世界最赚钱的咨询顾问 / 134
【案例二】 美国忠实航空为什么利润率是西南航空的6倍 / 135
【案例三】 卖长销书比卖畅销书更能增加作家收入 / 137
【案例四】 未来真正有水平的咨询顾问，会按效果收费 / 137
【案例五】 李阳疯狂英语的“钩”和“饵”模式 / 137
【案例六】 如何设计募捐的“钩”和“饵”模式 / 138
【案例七】 NBA设计的“钩”和“饵”模式 / 138
【案例八】 益生康健设计的“钩”和“饵” / 138
【案例九】 拉斯维加斯赌城的酒店设计的“钩”和“饵” / 139
【案例十】 一位菜贩设计的“钩”和“饵”模式 / 139
【案例十一】 健身公约设计的“钩”和“饵”，健身行业的新模式 / 140
【案例十二】 星巴克设计的“钩”和“饵”模式 / 141
【案例十三】 宝洁、高露洁、联合利华设计的“钩”和“饵”模式 / 141
【案例十四】 通用电器设计的“钩”和“饵”模式 / 142
【案例十五】 通用汽车设计的“钩”和“饵”模式 / 143
【案例十六】 耐克设计的“钩”和“饵”模式 / 143
【案例十七】 苹果公司设计的“钩”和“饵”模式 / 143
【案例十八】“ 加码”模式的其他方式 / 144
八、计算顾客的终身价值 / 147
九、加盟与直营的利与弊（适用于所有加盟商） / 151
【案例一】 湖北鸭脖大王为何只做直营模式 / 151
【案例二】 谭木匠为何只做加盟模式 / 155
十、商业模式创新思维的应用 / 159
【案例一】 太平洋建设集团的BT模式:既是蓝海市场，更是商业模式的创新 / 159
【案例二】 巧妙利用拍卖行的模式 / 162
【案例三】 巧妙利用法律手段规避行政壁垒 / 162
【案例四】 集团快速成长、发展壮大的商业模式：超市、楼市、股市三联动 / 164
【案例五】“ 汇源”创始人朱新礼“空手套白狼”起家史 / 165
【案例六】 广东邦家全新的租赁加销售模式 / 167
十一、轻资产模式（适用于所有行业的创新） / 170
【案例一】 美国的电话医生 / 170
【案例二】 只有3个人的旅游公司 / 170
【案例三】 爱尔眼科充沛的现金流 / 171
【案例四】 轻资产咨询公司，荟才环球的员工没有办公桌 / 173
【案例五】 一家轻资产的健康护理公司 / 177
【案例六】 轻资产的大学——美国斯特雷教育公司和阿波罗教育集团 / 179
【案例七】 轻资产模式卖海岛，22个人卖了2000个岛屿 / 181
第四章
新商业模式的发展 / 186
一、连环返租交易模式（商业模式创新思维的应用） / 186
二、日本的“女婿养子”模式（适用于强大的家族企业） / 187
三、为什么管理中最大的成本是信任 / 189
四、有声读物“一路听天下”的商业模式（独特的招聘模式） / 190
五、逆转顾客风险模式（适用于所有加盟连锁企业） / 193
六、直接邮寄的模式，中小企业的低成本的商业模式 / 199
七、创建转介绍模式 / 207
八、产业发展的二元定律 / 218
九、机制创新 / 219
【案例一】 晋商的核心竞争力是“财股与身股结合、身股为大”的机制 / 219
【案例二】 一家食品公司有效的“手机电话管理”机制创新。 / 223
【案例三】 师傅带徒弟的机制创新，彻底解决了“教会徒弟、饿死师傅”
的问题 / 224
十、杰亚伯拉罕的100个经过测试的最著名的标题 / 226
附　录 A / 246
A.1 财富中国商业模式内训 / 246
A.2 财富中国商业模式咨询 / 246
参考文献 / 250
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>新商业模式创新设计：当资本插上“互联网+”的翅膀
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>编程语言实现模式
第1部分  读取输入
第1章  初探语言应用 3
1.1  大局观 3
1.2  模式概览 5
1.3  深入浅出语言应用 9
1.4  为语言应用选择合适的模式 17
第2章  基本解析模式 21
2.1  识别式子的结构 22
2.2  构建递归下降语法解析器 24
2.3  使用文法DSL来构建语法解析器 26
2.4  词法单元和句子 27
第3章  高阶解析模式 49
3.1  利用任意多的向前看符号进行解析 50
3.2  记忆式解析 52
3.3  采用语义信息指导解析过程 52
第2部分  分析输入
第4章  从语法树构建中间表示 73
4.1  为什么要构建树 75
4.2  构建抽象语法树 77
4.3  简要介绍ANTLR 84
4.4  使用ANTLR文法构建AST 86
第5章  遍历并改写树形结构 101
5.1  遍历树以及访问顺序 102
5.2  封装访问节点的代码 105
5.3  根据文法自动生成访问者 107
5.4  将遍历与匹配解耦 110
第6章  记录并识别程序中的符号 131
6.1  收集程序实体的信息 132
6.2  根据作用域划分符号 134
6.3  解析符号 139
第7章  管理数据聚集的符号表 155
7.1  为结构体构建作用域树 156
7.2  为类构建作用域树 158
第8章  静态类型检查 181
第3部分  解释执行
第9章  构建高级解释器 219
9.1  高级解释器存储系统的设计 220
9.2  高级解释器中的符号记录 222
9.3  处理指令 224
第10章  构建字节码解释器 239
10.1  设计字节码解释器 241
10.2  定义汇编语言语法 243
10.3  字节码机器的架构 245
10.4  如何深入 250
第4部分  生成输出
第11章  语言的翻译 278
11.1  语法制导的翻译 280
11.2  基于规则的翻译 281
11.3  模型驱动的翻译 283
11.4  创建嵌套的输出模型 291
第12章  使用模板生成DSL 312
12.1  熟悉StringTemplate 313
12.2  StringTemplate的性质 316
12.2  从一个简单的输入模型生成模板 317
12.4  在输入模型不同的情况下复用模板 320
12.5  使用树文法来创建模板 323
12.6  对数据列表使用模板 330
12.7  编写可改变输出结果的翻译器 336
第13章  知识汇总 348
13.1  在蛋白质结构中查找模式 348
13.2  使用脚本构建三维场景 349
13.3  处理XML 350
13.4  读取通用的配置文件 352
13.5  对代码进行微调 353
13.6  为Java添加新的类型 354
13.7  美化源代码 355
13.8  编译为机器码 356
参考文献 359
索引 361
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>编程语言实现模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>重塑商业新生态
第1章 商业模式入此门// 1
1.1 赢家通吃的力量// 3
1.2 商业模式：新经济时代的理论武器// 9
1.3 商业模式不同于战略，更超越营销策划// 12
1.4 8大问题测评企业商业模式的优劣// 13
本章脑图// 17
第2章 商业模式的哲学观和方法论// 19
2.1 商业模式创新的哲学观：资源向价值的转化率不断提高// 21
2.1.1 衡量商业模式创新的标尺// 21
2.1.2 商业模式进化的三条路径// 23
2.1.3 跨界创新，跨越头脑疆界// 26
2.1.4 并入时间维度看商业模式创新// 27
2.1.5 价值流入企业与流出企业的两重天// 32
2.2 设计商业模式的方法论：构建与重塑企业的生态系统// 34
2.2.1 从个体与环境的关系理解生态系统// 34
2.2.2 商业模式构建的最小单元与关键步骤// 39
2.3 商业模式理论的突出特征// 46
本章脑图// 51
第3章 挖掘商业模式金矿的三大利润律// 53
3.1 商业模式创新的标志：开启新的价值空间// 55
3.1.1 巨大的商业成功源自进入新的价值空间// 55
3.1.2 真正的价值空间同时让用户得益、企业得利// 57
3.2 流失律：看自身，发现流失的利润// 60
3.3 流向律：看行业，预知下一个“风口”// 66
3.3.1 掌握利润的分布与流向规律// 67
3.3.2 预知未来，提前布局价值流入点// 72
3.4 边缘律：找蓝海，在边缘市场创新 // 75
本章脑图// 79
第4章 商业模式创新设计的五大步骤// 81
4.1 商业模式理论武器的心法与招式// 83
4.2 商业模式依序渐进的五大步骤// 85
4.2.1 确认企业基因// 85
4.2.2 发现新的价值空间// 86
4.2.3 破解价值锁// 87
4.2.4 再造收入成本结构// 88
4.2.5 从单维到多维，形成生态系统// 90
4.3 商业模式创新设计的内心准备与常见错误// 91
本章脑图// 95
第5章 确认企业基因// 97
5.1 以企业基因为核心开展有效创新才能释放价值潜力// 99
5.2 企业基因对商业模式的选择具有决定性作用// 104
5.2.1 企业基因的形成、识别与改变// 104
5.2.2 优秀的商业模式创新基于基因、保护基因// 106
5.3 商业模式创新时警惕偏离企业基因的信号// 113
本章脑图// 115
第6章 发现新的价值空间，进入无人之境// 117
6.1 创新有道：“三条链”发现价值空间// 119
6.1.1 价值链:发现惊人的浪费和闲置// 120
6.1.2 用户链:发现用户未言明的需求// 122
6.1.3 行业链:发现行业中利润的流向// 125
6.2 实际应用中的启发性问题// 128
本章脑图// 135
第7章 破解价值锁，开启宝藏之门// 137
7.1 开启价值空间的关键步骤// 139
7.2 绘制价值曲线，细分动态市场，验证目标市场// 145
7.2.1 价值曲线是非常有效的描绘价值空间的工具// 145
7.2.2 对细分市场创造性地界定，而非静态性分析// 147
7.3 案例模拟：推导低成本航空的商业模式创新// 150
本章脑图// 155
第8章 再造收入成本结构，提升利润率// 157
8.1 梦想境界：羊毛出在狗身上，猪来买单// 159
8.2 找到第三方，打造成本收入组合结构// 164
8.2.1 三大步骤寻找第三方// 164
8.2.2 12 种收入成本组合模式// 166
8.2.3 再造收入和成本结构的注意事项// 169
本章脑图// 171
第9章 升维：从产品到生态系统// 173
9.1 商业模式既是设计企业的手段，也是企业设计的目的// 175
9.2 逐步扩展生态系统规模的步骤与关键点// 177
9.2.1 确认主生态链，构建最小系统// 177
9.2.2 依序添加生态角色// 178
9.2.3 检验生态动力// 182
9.2.4 统一客户体验，避免生态破坏// 183
9.2.5 推动生态系统生长、进化、互利、共生// 184
本章脑图// 189
第10章 别让过去的成功阻碍你迈向未来的成功// 191
10.1 换心智模式才能换商业模式// 193
10.2 认识头脑的疆界，探索疆域之外// 197
10.2.1 头脑的疆界就是我们所认识的世界// 197
10.2.2 做疆域外的思考，想象10年后的世界// 200
10.2.3 开启大脑的创新模式// 203
本章脑图// 209
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>重塑商业新生态
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Akka应用模式：分布式应用程序设计实践指南
前言 .......................................................................................... xvii
第1 章 Actor 模型 ........................................................................1
现实是最终一致的 .................................................................................................1
解构Actor 模型 .....................................................................................................3
所有的计算都在一个actor 中执行 .........................................................................4
actor 之间只能通过消息进行通信 .........................................................................5
actor 可以创建子actor ...........................................................................................6
actor 可以改变自己的状态或行为 .........................................................................8
一切都是actor .......................................................................................................9
Actor 模型的使用 .................................................................................................10
定义清晰的边界 ................................................................................................... 11
何时适合使用Actor 模型 ....................................................................................13
结论 .....................................................................................................................13
第2 章 Akka 简介 .......................................................................15
Akka 是什么......................................................................................................... 15
Akka 是开源的 .............................................................................................. 15
Akka 正在蓬勃发展 .......................................................................................16
Akka 是为分布式设计的 ...............................................................................16
Akka 组件 ............................................................................................................17
Akka actor .....................................................................................................17
子actor .......................................................................................................... 18
remoting ：不同JVM 上的actor ....................................................................20
clustering ：集群成员的自动化管理 ..............................................................20
Akka HTTP ...................................................................................................24
TestKit ........................................................................................................... 25
contrib ........................................................................................................... 25
Akka OSGi ................................................................................................... 25
Akka HTTP ...................................................................................................26
Akka Streams ................................................................................................26
Akka 实现的Actor 模型 ......................................................................................26
Actor 模型中的Akka actor ..................................................................................26
消息传递 .......................................................................................................27
actor 系统 ...................................................................................................... 28
Akka Typed 项目 .................................................................................................. 28
结论 ....................................................................................................................29
第3 章 分布式领域驱动设计 ........................................................31
DDD 概述 ............................................................................................................31
DDD 的好处 .........................................................................................................32
DDD 组件 ............................................................................................................33
域实体 ..................................................................................................................34
域值对象 .............................................................................................................34
聚合与聚合根 ..................................................................................................... 35
仓储 .....................................................................................................................37
工厂和对象创建 ................................................................................................... 38
域服务 .................................................................................................................. 38
有界上下文 ..........................................................................................................39
结论 ....................................................................................................................41
第4 章 优秀的Actor 设计 ...........................................................43
大系统小做 ..........................................................................................................43
封装actor 中的状态 ............................................................................................44
使用字段封装状态 .......................................................................................44
使用“状态”容器封装状态 ........................................................................47
使用become 封装状态 ................................................................................. 48
将futures 与actors 混合 ............................................................................... 50
Ask 模式和替代方案 ............................................................................................ 54
Ask 模式的问题 ........................................................................................... 55
附带的复杂性 ................................................................................................ 57
Ask 的替代方案 ........................................................................................... 57
命令与事件 .......................................................................................................... 59
构造函数的依赖注入 ....................................................................................61
使用路径查找actor ......................................................................................61
结论 ....................................................................................................................62
第5 章 数据流 ............................................................................63
吞吐量与延迟 ......................................................................................................63
流 .........................................................................................................................64
路由器 ..................................................................................................................66
邮箱 ..................................................................................................................... 68
无界邮箱 ...................................................................................................... 68
有界邮箱 ......................................................................................................69
拉取的工作模式 ..................................................................................................70
背压 .....................................................................................................................73
ack .................................................................................................................73
高水位标记 ...................................................................................................73
队列长度监控 ................................................................................................74
速率监控 ......................................................................................................74
Akka 数据流.........................................................................................................74
源 .................................................................................................................. 75
汇 ..................................................................................................................77
RunnableGraph ............................................................................................. 78
流 ..................................................................................................................79
交叉点 ........................................................................................................... 80
Akka 流中的背压 ......................................................................................... 81
Akka 流的使用 ............................................................................................. 82
结论 .................................................................................................................... 84
第6 章 一致性和可扩展性 ...........................................................85
事务和一致性 ...................................................................................................... 85
强一致性与最终一致性 ....................................................................................... 86
并发性与并行性 ................................................................................................... 86
为什么全局一致的分布式状态影响可扩展性 ...................................................... 86
位置透明性 ......................................................................................................... 87
交付保证 ............................................................................................................. 87
最多投递一次 ................................................................................................ 87
最少投递一次 ................................................................................................ 88
恰好一次交付是不可能的（但可以近似做到） .............................................91
如何近似做到恰好一次交付 .........................................................................91
集群单例 .......................................................................................................92
可扩展性 ..............................................................................................................94
避免全局状态 ............................................................................................... 98
避免共享状态 ............................................................................................... 98
遵循Actor 模型 .............................................................................................99
避免顺序操作 ...............................................................................................99
隔离阻塞型操作 ...........................................................................................99
监控和调优 ..................................................................................................99
集群分片和一致性 ...............................................................................................99
分片 ............................................................................................................. 100
Akka 中的分片 ........................................................................................... 101
分片键的生成 ............................................................................................. 102
分片的分布 ................................................................................................ 103
一致性边界 ................................................................................................. 103
可扩展性边界 ............................................................................................. 104
分片聚合根 ................................................................................................ 105
持久化 ......................................................................................................... 106
钝化 ............................................................................................................. 106
使用集群分片保证一致性 ........................................................................... 107
结论 .................................................................................................................. 109
第7 章 容错 .............................................................................111
故障类型 ........................................................................................................... 112
异常 ............................................................................................................ 112
JVM 中的致命错误 .................................................................................... 113
外部服务故障 ............................................................................................. 113
不符合服务等级协议 .................................................................................. 113
操作系统和硬件级故障 .............................................................................. 114
故障隔离 ........................................................................................................... 114
舱壁模式 .................................................................................................... 114
优雅降级 ..................................................................................................... 117
使用Akka 集群隔离故障 ............................................................................ 119
使用熔断器控制故障 ................................................................................... 119
故障处理 ............................................................................................................ 122
异常处理 ..................................................................................................... 123
外部服务的故障处理 .................................................................................. 128
结论 ................................................................................................................... 131
第8 章 可用性 ..........................................................................133
微服务和单体式应用 ........................................................................................ 133
用有界上下文划分微服务 ................................................................................. 134
细粒度的微服务 ................................................................................................. 135
集群感知路由器 ................................................................................................. 135
分布式数据 ....................................................................................................... 137
优雅降级 ............................................................................................................ 140
部署 ................................................................................................................... 141
分阶段部署/ 滚动重启 ..................................................................................... 142
蓝/ 绿部署 ........................................................................................................ 142
崩溃恢复/ 运维监测 ......................................................................................... 143
健康检查和应用状态页面 .......................................................................... 143
度量 ............................................................................................................ 145
日志 ............................................................................................................. 146
看门狗工具 ................................................................................................. 146
结论 .................................................................................................................. 147
第9 章 性能 ...........................................................................149
隔离瓶颈 ........................................................................................................... 150
优化Akka ......................................................................................................... 150
减少或隔离阻塞型操作 .............................................................................. 150
缩短消息处理时间 ...................................................................................... 151
增加处理消息的actor ................................................................................ 151
派发器 ................................................................................................................ 151
标准派发器 ................................................................................................. 151
固定派发器 ................................................................................................. 153
平衡派发器 ................................................................................................ 154
calling-thread 派发器 .................................................................................. 154
何时使用单独的派发器 .............................................................................. 155
提高并行性 ................................................................................................ 157
结论 .................................................................................................................. 158
后记 ..........................................................................................159
参考文献 ...................................................................................161
关于作者 ...................................................................................162
封面介绍 ...................................................................................163
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Akka应用模式：分布式应用程序设计实践指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数字图像模式识别工程软件设计
前言第1章  图像模式识别导论  1.1  图像模式识别概述  1.2  图像模式识别的应用  1.3  基于图像分析的黄豆质量评估系统设计    1.3.1  图像特征识别系统的基本技术要求    1.3.2  图像特征识别统计系统的构架及软件实现技术第2章  数字图像预处理  2.1  图像的灰度化    2.1.1  图像的灰度化处理的基本原理    2.1.2  图像的灰度化的程序实现  2.2  图像的二值化    2.2.1  图像的二值化处理的基本原理    2.2.2  图像的二值化处理的程序实现  2.3  图像的反色    2.3.1  图像的反色处理的基本原理    2.3.2  图像的反色处理的程序实现  2.4  图像的中值滤波    2.4.1  图像的中值滤波处理的基本原理    2.4.2  图像的中值滤波处理的程序实现  2.5  图像的高斯滤波    2.5.1  图像的高斯滤波处理的基本原理    2.5.2  图像的高斯滤波处理的程序实现  2.6  Gabor变换    2.6.1  Gabor变换的基本原理    2.6.2  Gabor滤波器设计    2.6.3  Gabor变换的程序实现  2.7  各向异性扩散平滑滤波    2.7.1  各向异性扩散平滑滤波的基本原理    2.7.2  各向异性扩散平滑滤波的程序实现  2.8  二值图像的腐蚀    2.8.1  二值图像的腐蚀的基本原理    2.8.2  二值图像腐蚀的程序实现  2.9  二值图像的膨胀    2.9.1  二值图像的膨胀的基本原理    2.9.2  二值图像的膨胀的程序实现  2.10  二值图像的开运算  2.11  二值图像的闭运算  2.12  灰度图像腐蚀    2.12.1  灰度图像腐蚀的基本原理    2.12.2  灰度图像腐蚀的程序实现  2.13  灰度图像膨胀    2.13.1  灰度图像膨胀的基本原理    2.13.2  灰度图像膨胀的程序实现  2.14  灰度图像开运算  2.15  灰度图像闭运算  2.16  灰度图像腐蚀和膨胀的其他衍生运算  2.17  图像的Sobel边缘检测    2.17.1  图像的Sobel边缘检测的原理    2.17.2  Sobel边缘检测的程序实现  2.18  图像的Prewitt边缘检测    2.18.1  图像的Prewiu边缘检测的原理    2.18.2  Prewitt边缘检测的程序实现  2.19  图像的Robert边缘检测    2.19.1  图像的Robert边缘检测的基本原理    2.19.2  Robert边缘检测的程序实现  2.20  Kirsch边缘检测    2.20.1  Kirsch边缘检测的基本原理    2.20.2  Kirsch边缘检测的程序实现  2.21  Laplace边缘检测    2.21.1  Laplace边缘检测的基本原理    2.21.2  Laplace边缘检测的程序实现  2.22  Gauss-Laplace边缘检测    2.22.1  Gauss-Laplace边缘检测的基本原理    2.22.2  Gauss-Laplace边缘检测的程序实现  2.23  Canny边缘检测    2.23.1  Canny边缘检测的基本原理    2.23.2  Canny边缘检测的程序实现  2.24  Marr边缘检测    2.24.1  Marr边缘检测的基本原理    2.24.2  Marr边缘检测的程序实现  2.25  基于图像预处理技术的细小颗粒计数系统的软件设计    2.25.1  细小颗粒计数系统的软件系统要求    2.25.2  细小颗粒计数系统的软件系统设计框架    2.25.3  细小颗粒计数系统的软件模块设计第3章  模板分类器  3.1  模板匹配分类法  3.2  基于模板分类器的手写数字识别工程软件设计    3.2.1  手写数字识别系统的软件设计要求    3.2.2  手写数字识别软件系统的模块构成    3.2.3  数字图像模板库的建立及管理    3.2.4  数字图像模板库的修改和添加    3.2.5  手写数字图像识别    3.2.6  手写数字识别软件与其他软件的信息交流  3.3  基于模板分类器的肝脏B超图像自动诊断系统工程软件设计    3.3.1  肝脏B超图像纹理分析    3.3.2  肝脏B超图像纹理计算    3.3.3  肝脏B超图像自动诊断系统的软件设计  3.4  基于模板分类器的轴承表面缺陷识别系统工程软件设计    3.4.1  轴承表面缺陷图像分析    3.4.2  表面缺陷图像的一般几何特征提取    3.4.3  表面缺陷图像的矩特征提取    3.4.4  轴承表面缺陷识别系统的软件设计第4章  贝叶斯分类法  4.1  贝叶斯决策概述    4.1.1  贝叶斯决策的一般概念    4.1.2  贝叶斯定理  4.2  基于贝叶斯的手写数字识别系统软件设计    4.2.1  基于贝叶斯的手写数字识别系统的软件设计步骤    4.2.2  基于贝叶斯的手写数字识别系统的软件实现第5章  几何分类器  5.1  几何分类器的基本概念  5.2  判别函数分类器    5.2.1  判别函数的种类    5.2.2  线性判别函数  5.3  几何分类器的设计    5.3.1  线性分类器的设计    5.3.2  LMSE分类法在手写数字识别中的程序设计    5.3.3  LMSE分类法在肝脏纹理分类识别中的程序设计    5.3.4  Fisher分类准则    5.3.5  基于Fisher的手写数字分类算法的程序实现第6章  图像分割与特征生成  6.1  图像分割的基本概念  6.2  特征生成及特征匹配    6.2.1  颜色特征    6.2.2  形状特征    6.2.3  纹理特征    6.2.4  空间关系特征    6.2.5  特征和分类    6.2.6  样本特征归一化  6.3  图形形状分类与计数系统的工程软件设计    6.3.1  图形形状分类与计数系统的设计框架    6.3.2  图形形状各特征值的定义与计算    6.3.3  基于一般几何特征值的综合分析与统计    6.3.4  光栅图像识别与矢量图形转换  6.4  基于链码运算的细胞分割和计数系统的工程软件设计    6.4.1  医学图像细胞分割的各种方法与应用    6.4.2  基于链码运算和其他技术的细胞分割技术的比较和应用    6.4.3  基于链码运算的细胞分割和计数系统的软件设计第7章  神经网络分类器  7.1  神经网络的基本概念  7.2  神经网络的理论分析    7.2.1  神经元模型    7.2.2  BP网络的学习算法    7.2.3  BP网络的设计    7.2.4  一般性BP网络的不足与改进  7.3  基于BP神经网络的手写数字识别系统软件设计    7.3.1  字符特征选择与提取的实现    7.3.2  基于神经元网络的手写数字识别程序实现  7.4  基于神经网络的肝脏B超图像自动诊断与识别系统软件设计    7.4.1  B超图像识别BP网络的拓扑结构    7.4.2  B超图像识别BP网络的输出编码    7.4.3  B超图像识别BP网络的参数选择第8章  聚类分析  8.1  聚类分析的一般概念    8.1.1  系统聚类    8.1.2  分解聚类    8.1.3  动态聚类    8.1.4  模糊聚类  8.2  基于均值聚类车牌定位和字符识别系统工程软件设计    8.2.1  基于强制聚类中心的均值聚类技术的车牌定位技术    8.2.2  车牌字符综合特征的选择和识别    8.2.3  基于均值聚类的细胞统计系统工程软件设计参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数字图像模式识别工程软件设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>價值主張年代
第一部Canvas
價值主張圖：設計、測試、建立與管理產品和服務的策略管理工具，可以與商業模式圖充分整合
第二部Design
設計：協助設計價值主張的技術
第三部Test
測試：藉著決定測試項目，降低新價值主張的風險與不確定性，並評量計劃的進展
第四部Evolve
演進：隨著組織不斷演進，以價值主張圖與商業模式圖做為組織的共同語言，持續精進
第五部Afterword
後記：提供價值主張設計的相關名詞說明，並介紹本書的製作過程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>價值主張年代
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>互联网+顶层商业系统
目录
互联网+顶层商业系统	1
前言	1
目录	2
第1章  巨变时代的转型：互联网时代的商业与管理重构	7
1.1  互联网精神：重构传统商业与管理的“颠覆者”	7
1.1.1  互联网精神的表象：互联网时代的权力弱化	7
1.1.2  互联网精神的本质：互联网权力强化循环体系	10
1.1.3  互联网精神的背后：后权力时代知识型转折	13
1.2  商业重构：互联网时代的价值链变革与融合	14
1.2.1  价值链变革：从传统价值链到价值闭环的转变	15
1.2.2  价值链融合：打破边界，商业发展趋于零边际成本	17
1.2.3  商业重构的背后：人性的回归与管理的突破	19
1.3  管理重构：互联网时代的组织进化与管理变革	20
1.3.1  人才管理重构：组织与员工间的“共享与双赢”	22
1.3.2  战略管理重构：多方参与、共生演化、技术联盟	23
1.3.3  企业文化重构：新型组织文化、价值体系的诞生	24
1.3.4  领导力重构：去权威化、泛中心化、价值多元化	25
1.3.5  组织管理重构：由科层管理体制实现组织扁平化	26
1.3.6  产品与营销重构：从以产品为中心到以客户为中心	28
第2章  互联网+顶层商业系统：实现盈利增收的创新商业模式	34
2.1  商业模式的三维解读：“术、法、道”	34
2.1.1  商业模式的内涵：价值创造与收益获取的组织运作系统	34
2.1.2  商业模式之“术”：商业模式的4个导向因素	36
2.1.3  商业模式之“法”：各要素高效协同的商业系统	38
2.1.4  商业模式之“道”：实现价值共创、基业长青的生态系统	41
2.2  商业模式顶层设计：实现企业盈利增收的5大商业模式	43
2.2.1  免费模式：互联网时代最赚钱的商业模式	43
2.2.2  连锁化模式：连锁经营的盈利复制模式	45
2.2.3  直销化模式：实现企业“裂变”增长的经营模式	49
2.2.4  金融化模式：利用金融杠杆效应，实现收益最大化	54
2.2.5  国际化模式：全球化时代的国际化经营模式	56
2.3  海尔模式的启示：以自主经营体为基础的人单合一管理	60
2.3.1  “以自主经营体为基础的人单合一管理”模式的内涵	61
2.3.2  自主经营体：市场拉动的价值创造网络	65
2.3.3  “人单合一”模式的优势及商业模式创新	67
2.3.4  海尔模式的启示：传统企业如何管理模式的转型升级？	69
第3章  大转型：“互联网+”时代，传统企业的转型与进化	72
3.1  产业转型：“互联网+”新常态下，传统产业模式的转型升级	72
3.1.1  互联网+农业：传统农业传播模式转型	73
3.1.2  互联网+制造：传统制造业模式转型	75
3.1.3  互联网+电信：传统电信行业模式转型	76
3.1.4  互联网+零售：传统零售业模式转型	78
3.2  传统企业痛与变：传统企业如何实现互联网化？	79
3.2.1  失败案例：千寻网、大货栈、邮礼网	79
3.2.2  原因总结：传统企业互联网化失败的4个因素	80
3.2.3  成功经验：互联网企业的商业模式进化路径	81
3.2.4  策略指导：传统企业互联网化的5项原则	83
3.3  互联网巨变时代，老板到底怎么做？	86
3.3.1  具备清晰明确的经营理论	86
3.3.2  为不确定性进行规划	88
3.3.3  企业经营的5个致命点	88
3.3.4  成为企业信息的“搜集者”	90
第4章  平台战略：从传统的竞争思维转化为合作思维	92
4.1  平台战略：构建多方共赢互利的平台生态圈	92
4.1.1  平台战略：互联网时代传统企业的必然选择	92
4.1.2  平台战略的本质：构建多方共赢的平台生态圈	93
4.2  平台模式的“马太效应”：企业由小变大的成长模式	97
4.2.1  赢家通吃：成就行业巨头的最佳商业模式	97
4.2.2  流量聚合：聚拢用户，打造巨大的利润池	99
4.2.3  信息透明：开放共享、合作共赢的获利模式	100
4.3  平台案例：如何构建一家平台型企业？	101
4.3.1  维络城：以电子信息实物化来提高竞争力	101
4.3.2  传化物流：构建多维立体化的物流服务平台	103
4.3.3  联想PC+：开创共赢开放的“PC+”时代	104
4.3.4  蚂蚁短租：通过小项目撑起大平台	106
4.3.5  诚品书店：利用平台模式经营书店	108
第5章  生态型企业：构建自我修复、自我进化的生态系统	109
5.1  什么是“生态型企业”？	109
5.1.1  生态型企业的基本特征	109
5.1.2  生态型企业的3个类型	110
5.2  商业生态系统与生态系统参与者	112
5.2.1  商业生态系统的2大机制：共赢与多样性	112
5.2.2  如何理解“共赢与多样性”？	114
5.2.3  商业生态系统越庞大越好？	118
5.2.4  商业系统的组织者or参与者？	119
5.3  企业生态模式：互联网时代的商业模式创新	120
5.3.1  延伸产业价值链：提升企业竞争优势	120
5.3.2  信息高效共享：提升企业整体协调能力	121
5.3.3  用户至上VS组织无边界：引领企业价值创新	123
5.3.4  增强用户黏性，满足顾客的个性化需求	124
5.3.5  增强动态平衡能力，实现自我循环的生态系统	125
5.4  如何构建自我修复、自我进化的生态型企业？	128
5.4.1  生态型企业的4大要素及10大视角	128
5.4.2  生态型企业与外部生态系统	130
5.4.3  生态型企业与内部生态系统	134
第6章  资本运作：发挥资本优势，实现企业的裂变式增长	138
6.1  资本运作的内涵及分类	138
6.1.1  扩张型资本运作	138
6.1.2  收缩型资本运作	140
6.2  品牌资本运作与管理：资本运营与品牌资产的跨界整合	143
6.2.1  品牌资本模式下，如何对品牌资产进行良性管理？	144
6.2.2  品牌资本模式下，资本运作应当遵循的4大原则	146
6.3  资产裂变 ：借助资本运作，实现企业价值最大化	148
6.3.1  企业资本运作的3个“最大化”	148
6.3.2  企业资本运作案例：海尔、TCL、德隆	149
6.3.3  民营企业资本运作的6大风险	152
6.3.4  现金流管理：优化企业现金流的6项策略	153
6.4  中小企业资本运作：动因、模式与战略选择	158
6.4.1  中小企业资本运作的4个动因	158
6.4.2  中小企业资本运作的3大模式	160
6.4.3  中小企业资本运作的3大战略选择	163
6.5  互联网企业资本运作：资本热潮中的坚守与突破	165
6.5.1  资本运作的积极作用：推动互联网企业转型升级	165
6.5.2  资本运作的负面作用：阻碍互联网企业的创新能力	166
6.5.3  坚守与突破：提升创新能力，积极向移动互联网转型	168
第7章  投融资战略：实现企业资源、资金、资产和资本的高效配置与整合	170
7.1  企业项目投资的选择与决策	170
7.1.1  制定企业投资战略	170
7.1.2  投资项目的选择策略	171
7.1.3  投资项目的可行性研究	174
7.1.4  项目投资决策	178
7.2  企业并购操作流程实战	179
7.2.1  企业并购的概念	179
7.2.2  企业并购操作流程实战	179
7.3  小微企业融资难问题及对策	184
7.3.1  小微企业融资难问题日益凸显	184
7.3.2  小微企业融资难的表现形式	185
7.3.3  小微企业融资难的实质	187
7.3.4  小微企业应对融资难的7点对策	189
7.4  看不见的“软黄金”：企业无形资产管理、运营及评估	190
7.4.1  无形资产管理变革的5大趋势	191
7.4.2  无形资产管理对企业的重要性	194
7.4.3  无形资产管理的3种运营策略	196
7.4.4  企业如何有效经营无形资产？	199
7.4.5  强化企业无形资产管理的5个途径	202
7.5  轻资产模式：以最小化的成本投入获得利润最大化	204
7.5.1  轻资产模式的理论基础	204
7.5.2  轻资产模式的财务战略	206
7.5.3  企业案例：苹果、海澜之家	207
7.5.4  案例分析：苹果与海澜之家的轻资产模式对比	209
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>互联网+顶层商业系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>领域驱动设计
目 录
第一部分 运用领域模型
第1章 消化知识 5
1.1 有效建模的要素 9
1.2 知识消化 10
1.3 持续学习 11
1.4 知识丰富的设计 12
1.5 深层模型 15
第2章 交流与语言的使用 16
2.1 模式：UBIQUITOUS LANGUAGE 16
2.2 “大声地”建模 21
2.3 一个团队，一种语言 22
2.4 文档和图 24
2.4.1 书面设计文档 25
2.4.2 完全依赖可执行代码的情况 27
2.5 解释性模型 27
第3章 绑定模型和实现 29
3.1 模式：MODEL-DRIVEN DESIGN 30
3.2 建模范式和工具支持 32
3.3 揭示主旨：为什么模型对用户至关重要 38
3.4 模式：HANDS-ON MODELER 39
第二部分 模型驱动设计的构造块
第4章 分离领域 43
4.1 模式：LAYERED ARCHITECTURE 43
4.1.1 将各层关联起来 46
4.1.2 架构框架 47
4.2 领域层是模型的精髓 48
4.3 模式：THE SMART UI“反模式” 48
4.4 其他分离方式 50
第5章 软件中所表示的模型 51
5.1 关联 52
5.2 模式：ENTITY（又称为REFERENCE OBJECT） 56
5.2.1 ENTITY建模 59
5.2.2 设计标识操作 60
5.3 模式：VALUE OBJECT 62
5.3.1 设计VALUE OBJECT 64
5.3.2 设计包含VALUE OBJECT的关联 67
5.4 模式：SERVICE 67
5.4.1 SERVICE与孤立的领域层 69
5.4.2 粒度 70
5.4.3 对SERVICE的访问 70
5.5 模式：ＭODULE（也称为PACKAGE） 71
5.5.1 敏捷的MODULE 72
5.5.2 通过基础设施打包时存在的隐患 73
5.6 建模范式 75
5.6.1 对象范式流行的原因 76
5.6.2 对象世界中的非对象 77
5.6.3 在混合范式中坚持使用MODEL-DRIVEN DESIGN 78
第6章 领域对象的生命周期 80
6.1 模式：AGGREGATE 81
6.2 模式：FACTORY 89
6.2.1 选择FACTORY及其应用位置 91
6.2.2 有些情况下只需使用构造函数 93
6.2.3 接口的设计 94
6.2.4 固定规则的相关逻辑应放置在哪里 94
6.2.5 ENTITY FACTORY与VALUE OBJECT FACTORY 95
6.2.6 重建已存储的对象 95
6.3 模式：REPOSITORY 97
6.3.1 REPOSITORY的查询 101
6.3.2 客户代码可以忽略REPOSITORY的实现，但开发人员不能忽略 102
6.3.3 REPOSITORY的实现 103
6.3.4 在框架内工作 104
6.3.5 REPOSITORY与FACTORY的关系 104
6.4 为关系数据库设计对象 106
第7章 使用语言：一个扩展的示例 108
7.1 货物运输系统简介 108
7.2 隔离领域：引入应用层 110
7.3 将ENTITY和VALUE OBJECT区别开 110
7.4 设计运输领域中的关联 112
7.5 AGGREGATE边界 113
7.6 选择REPOSITORY 113
7.7 场景走查 115
7.7.1 应用程序特性举例：更改Cargo的目的地 115
7.7.2 应用程序特性举例：重复业务 116
7.8 对象的创建 116
7.8.1 Cargo的FACTORY和构造函数 116
7.8.2 添加Handling Event 117
7.9 停一下，重构：Cargo AGGREGATE 的另一种设计 118
7.10 运输模型中的ＭODULE 120
7.11 引入新特性：配额检查 122
7.11.1 连接两个系统 123
7.11.2 进一步完善模型：划分业务 124
7.11.3 性能优化 125
7.12 小结 126
第三部分 通过重构来加深理解
第8章 突破 131
8.1 一个关于突破的故事 131
8.1.1 华而不实的模型 132
8.1.2 突破 133
8.1.3 更深层模型 135
8.1.4 冷静决策 137
8.1.5 成果 138
8.2 机遇 138
8.3 关注根本 138
8.4 后记：越来越多的新理解 139
第9章 将隐式概念转变为显式概念 140
9.1 概念挖掘 140
9.1.1 倾听语言 140
9.1.2 检查不足之处 144
9.1.3 思考矛盾之处 148
9.1.4 查阅书籍 148
9.1.5 尝试，再尝试 150
9.2 如何为那些不太明显的概念建模 150
9.2.1 显式的约束 151
9.2.2 将过程建模为领域对象 153
9.2.3 模式：SPECIFICATION 154
9.2.4 SPECIFICATION的应用和实现 156
第10章 柔 性 设 计 168
10.1 模式：INTENTION-REVEALING
INTERFACES 169
10.2 模式：SIDE-EFFECT-FREE FUNCTION 173
10.3 模式：ASSERTION 177
10.4 模式：CONCEPTUAL CONTOUR 181
10.5 模式：STANDALONE CLASS 184
10.6 模式：CLOSURE OF OPERATION 186
10.7 声明式设计 188
10.8 声明式设计风格 190
10.9 切入问题的角度 197
10.9.1 分割子领域 197
10.9.2 尽可能利用已有的形式 198
第11章 应用分析模式 206
第12章 将设计模式应用于模型 217
12.1 模式：STRATEGY（也称为POLICY） 218
12.2 模式：COMPOSITE 221
12.3 为什么没有介绍FLYWEIGHT 226
第13章 通过重构得到更深层的理解 227
13.1 开始重构 227
13.2 探索团队 227
13.3 借鉴先前的经验 228
13.4 针对开发人员的设计 229
13.5 重构的时机 229
13.6 危机就是机遇 230
第四部分 战略设计
第14章 保持模型的完整性 233
14.1 模式：BOUNDED CONTEXT 235
14.2 模式：CONTINUOUS INTEGRATION 239
14.3 模式：CONTEXT MAP 241
14.3.1 测试CONTEXT的边界 247
14.3.2 CONTEXT MAP的组织和文档化 247
14.4 BOUNDED CONTEXT之间的关系 248
14.5 模式：SHARED KERNEL 248
14.6 模式：CUSTOMER/SUPPLIER DEVELOPMENT TEAM 250
14.7 模式：CONFORMIST 253
14.8 模式：ANTICORRUPTION LAYER 255
14.8.1 设计ANTICORRUPTION LAYER的接口 256
14.8.2 实现ANTICORRUPTION LAYER 256
14.8.3 一个关于防御的故事 259
14.9 模式：SEPARATE WAY 260
14.10 模式：OPEN HOST SERVICE 261
14.11 模式：PUBLISHED LANGUAGE 262
14.12 “大象”的统一 264
14.13 选择你的模型上下文策略 267
14.13.1 团队决策或更高层决策 268
14.13.2 置身上下文中 268
14.13.3 转换边界 268
14.13.4 接受那些我们无法更改的事物：描述外部系统 269
14.13.5 与外部系统的关系 269
14.13.6 设计中的系统 270
14.13.7 用不同模型满足特殊需要 270
14.13.8 部署 271
14.13.9 权衡 271
14.13.10 当项目正在进行时 272
14.14 转换 272
14.14.1 合并CONTEXT：SEPARATE WAY →SHARED KERNEL 273
14.14.2 合并CONTEXT：SHARED KERNEL→CONTINUOUS INTEGRATION 274
14.14.3 逐步淘汰遗留系统 275
14.14.4 OPEN HOST SERVICE→PUBLISHED LANGUAGE 276
第15章 精炼 277
15.1 模式：CORE DOMAIN 278
15.1.1 选择核心 280
15.1.2 工作的分配 280
15.2 精炼的逐步提升 281
15.3 模式：GENERIC SUBDOMAIN 282
15.3.1 通用不等于可重用 286
15.3.2 项目风险管理 287
15.4 模式：DOMAIN VISION STATEMENT 287
15.5 模式：HIGHLIGHTED CORE 289
15.5.1 精炼文档 289
15.5.2 标明CORE 290
15.5.3 把精炼文档作为过程工具 291
15.6 模式：COHESIVE MECHANISM 292
15.6.1 GENERIC SUBDOMAIN与COHESIVE MECHANISM的比较 293
15.6.2 MECHANISM是CORE DOMAIN一部分 294
15.7 通过精炼得到声明式风格 294
15.8 模式：SEGREGATED CORE 295
15.8.1 创建SEGREGATED CORE的代价 296
15.8.2 不断发展演变的团队决策 296
15.9 模式：ABSTRACT CORE 301
15.10 深层模型精炼 302
15.11 选择重构目标 302
第16章 大型结构 303
16.1 模式：EVOLVING ORDER 306
16.2 模式：SYSTEM METAPHOR 308
16.3 模式：RESPONSIBILITY LAYER 309
16.4 模式：KNOWLEDGE LEVEL 321
16.5 模式：PLUGGABLE COMPONENT FRAMEWORK 328
16.6 结构应该有一种什么样的约束 332
16.7 通过重构得到更适当的结构 333
16.7.1 ZUI小化 333
16.7.2 沟通和自律 334
16.7.3 通过重构得到柔性设计 334
16.7.4 通过精炼可以减轻负担 334
第17章 领域驱动设计的综合运用 336
17.1 把大型结构与BOUNDED CONTEXT结合起来使用 336
17.2 将大型结构与精炼结合起来使用 339
17.3 首先评估 339
17.4 由谁制定策略 341
17.4.1 从应用程序开发自动得出的结构 341
17.4.2 以客户为中心的架构团队 341
17.5 制定战略设计决策的6个要点 342
17.5.1 技术框架同样如此 344
17.5.2 注意总体规划 345
结束语
附录 351
术语表 354
参考文献 357
图片说明 359
索引 360
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>领域驱动设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>如何设计优质慕课
01 什么是慕课
从远程教育到慕课 // 3
慕课课程的类型 // 17
02 如何构建慕课
从传统课堂到慕课 // 29
慕课课程的创建团队 // 32
慕课运行步骤 // 39
资源需求 // 45
后期构建工作 // 49
慕课构建的工作量 // 52
慕课构建的费用 // 61
03慕课的受众和目的
慕课的受众 // 73
慕课的合理使用 // 77
慕课学习及指导 // 90
04慕课的开发和融资
慕课的优点及经济收益 // 101
慕课的融资问题 // 108
05慕课和高等教育
慕课和大学 // 120
大学里的慕课及“ 教学革命” // 123
大学真的已穷途末路了吗 // 128
慕课和终身教育 // 133
06未来，慕课将何去何从
“ 慕课” 还是“ 不慕课” // 143
慕课开发的动机和受众 // 148
如何推动支持慕课的开发 // 154
如何支持慕课的使用者 // 158
数字化学习工作室 // 160
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>如何设计优质慕课
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件团队模式设计
译者序序第1部分&nbsp; 预备行动第1章&nbsp; 预备行动的要素&nbsp;71.1&nbsp; 超越距离&nbsp;71.2&nbsp; 预备行动协议&nbsp;71.3&nbsp; 退出行动协议&nbsp;81.4&nbsp; 省略协议&nbsp;81.5&nbsp; 沟通&nbsp;81.6&nbsp; 有问题的行为&nbsp;81.7&nbsp; 与预备行动协同的模式&nbsp;9

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件团队模式设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向对象分析与设计
第1部分 概念
第1章 复杂性 2
1.1 复杂系统的结构 2
1.1.1 个人计算机的结构 3
1.1.2 植物和动物的结构 3
1.1.3 物质的结构 4
1.1.4 社会机构的结构 4
1.2 软件固有的复杂性 5
1.2.1 定义软件复杂性 5
1.2.2 为什么软件在本质上是复杂的 5
1.3 复杂系统的5个属性 8
1.3.1 层次结构 8
1.3.2 相对本原 8
1.3.3 分离关注 9
1.3.4 共同模式 9
1.3.5 稳定的中间形式 9
1.4 有组织和无组织的复杂性 10
1.4.1 复杂系统的规范形式 10
1.4.2 处理复杂性时人的能力的局限 12
1.5 从混沌到有序 12
1.5.1 分解的作用 13
1.5.2 抽象的作用 16
1.5.3 层次结构的作用 16
1.6 复杂系统的设计 17
1.6.1 作为科学和艺术的工程 17
1.6.2 设计的含义 17
1.7 小结 19
第2章 对象模型 20
2.1 对象模型的演进 20
2.1.1 程序设计语言的换代 20
2.1.2 第一代和第二代早期程序设计语言的拓扑结构 22
2.1.3 第二代后期和第三代早期程序设计语言的结构 23
2.1.4 第三代后期程序设计语言的结构 23
2.1.5 基于对象和面向对象的程序设计语言的结构 24
2.2 对象模型基础 26
2.2.1 面向对象编程 29
2.2.2 面向对象设计 29
2.2.3 面向对象分析 30
2.3 对象模型要素 30
2.3.1 抽象的意义 31
2.3.2 封装的意义 35
2.3.3 模块化的意义 38
2.3.4 层次结构的意义 41
2.3.5 类型的意义 46
2.3.6 并发的意义 47
2.3.7 持久的意义 49
2.4 应用对象模型 51
2.4.1 对象模型的好处 51
2.4.2 开放式问题 52
2.5 小结 52
第3章 类与对象 53
3.1 对象的本质 53
3.1.1 什么是对象，什么不是对象 53
3.1.2 状态 55
3.1.3 行为 57
3.1.4 标识符 60
3.2 对象之间的关系 62
3.2.1 链接 62
3.2.2 聚合 64
3.3 类的本质 65
3.3.1 什么是类，什么不是类 65
3.3.2 接口和实现 66
3.3.3 类的生命周期 68
3.4 类之间的关系 68
3.4.1 关联 69
3.4.2 继承 70
3.4.3 聚合 78
3.4.4 依赖关系 79
3.5 类与对象的互动 79
3.5.1 类与对象的关系 79
3.5.2 类与对象在分析和设计中的角色 79
3.6 创建高品质的类与对象 80
3.6.1 评判一种抽象的品质 80
3.6.2 选择操作 81
3.6.3 选择关系 82
3.6.4 选择实现 83
3.7 小结 84
第4章 分类 85
4.1 正确分类的重要性 85
4.1.1 分类的困难 86
4.1.2 分类的增量和迭代本质 87
4.2 确定类和对象 88
4.2.1 经典方法和现代方法 89
4.2.2 面向对象分析 92
4.3 关键抽象与机制 97
4.3.1 确定关键抽象 97
4.3.2 识别机制 99
4.4 小结 101
第2部分 方法
第5章 表示法 104
5.1 统一建模语言 104
5.1.1 简单历史回顾 104
5.1.2 模型与多重视图 105
5.1.3 图分类 105
5.1.4 在实践中使用图 107
5.1.5 概念模型.逻辑模型和物理模型 108
5.1.6 工具的角色 108
5.1.7 面向对象开发的产品 108
5.1.8 规模上的伸缩 109
5.1.9 UML的语法和语义 109
5.1.10 UML2.0信息资源 110
5.2 包图 110
5.2.1 基本概念：包表示法 110
5.2.2 基本概念：元素的可见性 111
5.2.3 基本概念：依赖关系 111
5.2.4 基本概念：包图 113
5.2.5 高级概念：导入和访问 114
5.3 组件图 117
5.3.1 基本概念：组件表示法 117
5.3.2 基本概念：组件图 118
5.3.3 基本概念：组件接口 119
5.3.4 基本概念：组件实现 121
5.3.5 高级概念：组件的内部结构 122
5.4 部署图 123
5.4.1 基本概念：工件表示法 123
5.4.2 基本概念：节点表示法 124
5.4.3 基本概念：部署图 124
5.5 用例图 126
5.5.1 基本概念：执行者 126
5.5.2 基本概念：用例 127
5.5.3 基本概念：用例图 127
5.5.4 高级概念：[[include]]和[[extend]]关系 129
5.5.5 高级概念：泛化 133
5.6 活动图 133
5.6.1 基本概念：动作 134
5.6.2 基本概念：开始和停止 134
5.6.3 基本概念：判断节点和合并节点 134
5.6.4 基本概念：分区 135
5.6.5 高级概念：分叉.结合和并发 135
5.6.6 高级概念：对象流 138
5.6.7 高级概念：其他元素 138
5.7 类图 138
5.7.1 基本概念：类表示法 138
5.7.2 基本概念：类关系 140
5.7.3 高级概念：模板(参数化)类 142
5.7.4 高级概念：可见性 143
5.7.5 高级概念：关联端名称和限定符 144
5.7.6 高级概念：约束 145
5.7.7 高级概念：关联类和注解 148
5.8 序列图 149
5.8.1 基本概念：对象与交互 149
5.8.2 基本概念：生命线与消息 149
5.8.3 高级概念：销毁事件 151
5.8.4 高级概念：执行说明 151
5.8.5 高级概念：交互使用 153
5.8.6 高级概念：控制结构 153
5.9 交互概述图 155
5.9.1 基本概念：框 155
5.9.2 基本概念：控制流元素 155
5.9.3 基本概念：交互图元素 156
5.10 组合结构图 157
5.10.1 基本概念：组合结构的部分 157
5.10.2 基本概念：组合结构的部分与接口 157
5.10.3 基本概念：组合结构连接器 158
5.10.4 高级概念：协作.. 158
5.11 状态机图 159
5.11.1 基本概念：初始状态.最终状态和简单状态 160
5.11.2 基本概念：转换与事件 160
5.11.3 高级概念：状态活动——入口活动.执行活动和出口活动 162
5.11.4 高级概念：控制转换 162
5.11.5 高级概念：复合状态与嵌套状态 163
5.11.6 高级概念：并发与控制 165
5.11.7 高级概念：子状态机状态 168
5.11.8 高级概念：其他状态机图元素 169
5.12 时间图 170
5.12.1 基本概念：更多相同之处 170
5.12.2 基本概念：布局 170
5.12.3 基本概念：事件 171
5.12.4 基本概念：约束 171
5.12.5 高级概念：另一种表示形式 172
5.12.6 高级概念：事件与消息 172
5.13 对象图 173
5.13.1 基本概念：对象 173
5.13.2 基本概念：对象关系 173
5.13.3 高级概念：端点名称和限定符 174
5.14 通信图 175
5.14.1 基本概念：对象.链接和消息 175
5.14.2 基本概念：顺序表达式 176
5.14.3 高级概念：消息与同步 177
5.14.4 高级概念：迭代子句和警戒条件 178
5.15 小结 179
第6章 过程 181
6.1 首要原则 181
6.1.1 成功项目的特征 181
6.1.2 追求理性的开发过程 184
6.2 宏观过程：软件开发生命周期 186
6.2.1 概述 187
6.2.2 宏观过程的内容维：科目 188
6.2.3 宏观过程的时间维：里程碑和阶段 190
6.2.4 宏观过程的时间维：迭代 195
6.2.5 发行计划 196
6.3 微观过程：分析与设计过程 198
6.3.1 概述 198
6.3.2 抽象层次 199
6.3.3 活动 200
6.3.4 产品 201
6.3.5 微观过程与抽象层次 203
6.3.6 识别元素 205
6.3.7 确定元素间的协作 208
6.3.8 确定元素间的关系 211
6.3.9 详细确定元素的语义 213
6.4 小结 216
第7章 实战 217
7.1 管理和计划 217
7.1.1 风险管理 218
7.1.2 任务计划 218
7.1.3 开发评审 219
7.2 人员配备 220
7.2.1 资源配置 220
7.2.2 开发团队角色 221
7.3 发布版本管理 223
7.3.1 配置管理和版本控制 223
7.3.2 集成 224
7.3.3 测试 224
7.4 复用 225
7.4.1 复用的元素 225
7.4.2 建立复用制度 225
7.5 质量保证和度量 226
7.5.1 软件质量 226
7.5.2 面向对象度量 226
7.6 文档化 229
7.6.1 开发遗产 229
7.6.2 文档化的内容 229
7.7 工具 230
7.7.1 工具种类 230
7.7.2 组织上的意义 231
7.8 特殊主题 231
7.8.1 领域特定问题 231
7.8.2 采纳面向对象技术 232
7.9 面向对象开发的好处和风险 233
7.9.1 面向对象开发的好处 233
7.9.2 面向对象开发的风险 233
7.10 小结 235
第3部分 应用
第8章 系统架构——基于卫星的导航 238
8.1 先启 238
8.1.1 卫星导航系统的需求 239
8.1.2 定义问题的边界 240
8.1.3 决定使命用例 243
8.1.4 决定系统用例 245
8.2 精化 248
8.2.1 开发一个好的架构 248
8.2.2 定义架构开发活动 248
8.2.3 验证所建议的系统架构 249
8.2.4 分配非功能需求和阐明接口 255
8.2.5 规定系统架构及其部署 257
8.2.6 分解系统架构 259
8.3 构造 265
8.4 后移交 265
8.4.1 添加新的功能 265
8.4.2 改变目标硬件 266
第9章 控制系统——交通管理 267
9.1 先启 268
9.1.1 列车交通管理系统的需求 268
9.1.2 决定系统用例 270
9.2 精化 273
9.2.1 分析系统功能 274
9.2.2 定义TTMS架构 277
9.2.3 从系统工程到硬件和软件工程 279
9.2.4 关键抽象和机制 281
9.3 构造 282
9.3.1 消息传送 283
9.3.2 列车日程计划 285
9.3.3 显示信息 288
9.3.4 传感器数据采集 289
9.3.5 发布版本管理 289
9.3.6 系统架构 290
9.3.7 子系统规格 291
9.4 后移交 293
第10章 人工智能——密码分析 294
10.1 先启 295
10.1.1 密码分析需求 295
10.1.2 定义问题的边界 296
10.1.3 黑板框架的架构 297
10.1.4 知识源的分析 299
10.2 精化 299
10.2.1 黑板对象 300
10.2.2 依赖和认定 301
10.3 构造 303
10.3.1 设计黑板对象 304
10.3.2 设计知识源 308
10.3.3 设计控制器 313
10.3.4 集成黑板框架 314
10.3.5 添加新的知识源 317
10.4 后移交 318
10.4.1 系统增强 318
10.4.2 改变需求 320
第11章 数据采集——气象监测站 321
11.1 先启 321
11.1.1 气象监测站需求 321
11.1.2 定义问题的边界 322
11.1.3 场景 330
11.2 精化 331
11.2.1 气象监测系统用例 331
11.2.2 架构框架 338
11.3 构造 340
11.3.1 帧机制 340
11.3.2 发布计划 343
11.3.3 传感器机制 344
11.3.4 显示机制 346
11.3.5 用户界面机制 346
11.4 后移交 349
第12章 Web应用——休假跟踪系统 350
12.1 先启 350
12.1.1 需求 350
12.1.2 用例模型 352
12.2 精化 353
12.2.1 部署视图 354
12.2.2 逻辑视图 355
12.2.3 进程视图 357
12.2.4 实现视图 359
12.2.5 用例视图 359
12.3 构造 362
12.3.1 用户体验模型 362
12.3.2 分析和设计模型 364
12.3.3 实体 372
12.3.4 控制器 379
12.3.5 Web页面和用户界面 380
12.4 移交和后移交 384
附录A 面向对象编程语言 386
A.1 语言进化 386
A.2 Smalltalk 389
A.2.1 概述 390
A.2.2 例子 390
A.2.3 参考文献 393
A.3 C++ 393
A.3.1 概述 394
A.3.2 例子 394
A.3.3 参考文献 397
A.4 Java 397
A.4.1 概述 398
A.4.2 例子 399
A.4.3 参考文献 402
附录B 进一步阅读 403
注解 409
术语表 430
分类书目 438
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向对象分析与设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>商业模式创新设计路线图
第一章 互联网 + 商业模式创新时代 / 001
第一节 中国企业发展经历的四个阶段 / 002
一、中国企业发展的四个阶段及特点 / 002
二、中国经济转型升级势在必行 / 003
第二节 中国企业传统的商业模式 / 006
一、举步维艰的传统商业模式 / 006
二、互联网时代的到来 / 008
第三节 战略失控 / 012
一、互联网时代传统企业所面临的共性难题 / 012
二、传统企业生存越来越困难 / 017
三、行业饱和、微利时代已经来临 / 018
四、微利时代的企业特征 / 019
五、市场已经从“增量竞争”转化到了“存量竞争” / 020
六、企业进入“互联网 + 商业模式创新”时代 / 021
案例分析：世界 500 强企业的商业模式创新思维 / 022
第二章 商业模式创新的本质 / 027
第一节 商业模式构成逻辑及创新系统 / 028
一、传统商业模式的基本逻辑 / 028
二、创新商业模式的定义 / 029
三、创新商业模式的六大特点 / 030
四、商业模式创新的五个步骤 / 031
五、您的企业属于哪种商业模式 / 032
第二节 企业经营的本质 / 034
一、客户价值创造是企业经营的本质 / 034
二、利润是企业经营的限制因素 / 034
第三节 客户价值深度剖析 / 038
一、客户价值公式 / 038
二、客户价值是一个相对值 / 039
三、客户价值提升的六个维度 / 040
四、客户价值分析 / 041
案例分析：海底捞——火锅店卖的是服务 / 045
案例分析：西南航空——“公交车”航空 / 050
第三章 互联网时代的创新之道 / 053
第一节 企业创新的三个层次 / 054
一、互联网时代的企业创新之道 / 054
二、商业模式颠覆式创新 / 055
三、中国企业缺乏创新的原因 / 058
四、传统企业“互联网 +”的改造流程 / 060
第二节 企业创新与战略重构 / 063
一、企业创新解决的是价值创造问题 / 063
二、战略重构的目的是形成新的经营形态 / 064
三、战略重构的时机与企业成长阶段 / 065
第三节 大数据与企业战略 / 068
一、什么是大数据 / 068
二、大数据与商业应用 / 069
三、大数据到底有多大 / 071
四、大数据时代的商业机会 / 071
五、华尔街的数据财富 / 073
六、微信红包背后的大数据金融 / 073
案例分析：去哪儿网的大数据营销 / 075
案例分析：“疯狂”的三只松鼠 / 079
第四章 企业成长性检测 / 085
第一节 你的企业有投资价值吗——巴菲特的“相马术”/ 086
一、巴菲特的投资哲学 / 086
二、巴菲特的投资原则 / 089
第二节 企业成长检测模型 / 090
一、企业成长性的关键因素 / 090
二、生产企业的传统商业模式 / 091
第三节 商业模式创新的误区 / 093
一、商业模式创新解决的是企业的根本问题 / 093
二、商业模式创新常见的问题 / 094
案例分析：汇付天下的供应链金融 / 095
第五章 构建正向的经营逻辑 / 099
第一节 你的企业是在“卖驴”还是在“抽奖”/ 100
一、传统经营逻辑与创新经营逻辑 / 100
二、战略重构与商业模式创新实现的价值 / 101
第二节 伪经营逻辑 / 102
一、伪经营逻辑与伪商业模式 / 102
二、商业模式创新失败的原因是逻辑起点错误 / 102
第三节 正向经营逻辑 / 103
一、创新逻辑以客户未被满足的精准需求为起点 / 103
二、与众不同的价值创造意识 / 104
案例分析：图书经销商的颠覆创新——“专业客户经理 +
精准数据库”/ 105
案例分析：以物换物的互联网“伪逻辑”/ 111
第六章 基于平台的战略重构与开放式创新 / 115
第一节 平台战略 / 116
一、什么是平台战略 / 116
二、基于平台战略的生态系统 / 118
第二节 战略重构与开放式创新 / 119
一、你的企业未来“更封闭”还是“更开放” / 119
二、互联网时代，企业战略重构的三大方向 / 120
三、互联网时代，企业开放式创新的五大基因 / 121
四、互联网时代的企业：无边界、网络化、平台化、免费化 / 122
第三节 整合资源 / 129
一、你的企业是“农夫式创新”还是“厨师式创新” / 129
二、企业整合创新的三种方式 / 131
三、乔布斯的创新力 / 133
案例分析 ：途家，通过互联网“借房”出租 / 134
第七章 无边界竞争 / 141
第一节 打破企业边界重构战略 / 142
一、互联网正在重塑企业边界 / 142
二、企业竞争的四种类型 / 143
三、打破边界重构战略导图 / 144
四、无边界竞争的内涵 / 145
第二节 跨界融合 / 149
一、融合与渗透 / 149
二、新产业的兴起与新经济的出现 / 150
三、跨界融合的五种方式 / 152
第三节 互联网正在消失 / 154
一、所有行业都将被互联网渗透 / 154
二、光懂“互联网”不懂“商业模式”一样会失败 / 155
案例分析：互联网抢滩汽车后服务市场 / 157
案例分析：南京零号线——打造城市电子商务基础设施和
商业生态系统 / 162
第八章 应对不确定的未来 / 167
第一节 何为真正的“互联网 +”/ 168
一、“互联网 +”的内涵 / 168
二、“互联网 +”需要经历的三个阶段 / 170
三、“互联网 +”的渗透率 / 171
四、传统产业互联网化呈现“逆向”态势 / 172
五、我国正由消费互联网向产业互联网转变 / 174
六、产业互联网时代到来 / 174
七、产业互联网的基础是宽带网络、大数据及云计算 / 176
八、产业互联网实现的核心是商业模式创新 / 176
九、产业互联网实现的关键是供应链管理与供应链金融 / 177
十、不是所有企业都懂“互联网 +” / 178
十一、认清互联网本质，警惕互联网泡沫的再次出现 / 179
第二节 打造竞争力群组 / 180
一、“互联网 +”企业的核心竞争力 / 180
二、竞争平衡 / 182
三、打造企业“前瞻性竞争力” / 184
四、竞争力也要“与时俱进” / 186
五、培育核心竞争力的五大误区 / 187
第三节 构建生态创新系统 / 190
一、企业的生态创新系统 / 190
二、商业模式构建的五个要素 / 192
三、四种典型的战略 / 193
四、构建新型的管理组织 / 197
案例分析：被移动互联网“吞噬”的维络城 / 200
案例分析：互联网家具的“黑马”——林氏木业 / 204
参考文献 / 208
后记 / 210
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>商业模式创新设计路线图
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>建筑设计的新商业模式
第一章 时代变革
起点
两场“战争”
移动互联网
“互联网+”
新的设计工具
BIM的困境
第二章 建筑之“伤”
标准化
流水线
甲方
下游行业
线性运转
审美差异
实用与美观
时间成本
产品之争
向工业产品学习
第三章 回归原则
小米的启示
评价的意义
线上与线下
影响力
“4P”理论
商业模式
平台模式
第四章 六种融合
三大分类
设计内核
前端与后端
融合之一：建筑在线接单平台
融合之二：建筑信息汇集平台
融合之三：云端模型与素材库
融合之四：建筑在线教育平台
融合之五：智能家装平台
融合之六：移动端的建筑应用
第五章 复兴乡建：另一个边界与平台
各个时代的建筑师
新的准备
乡村研究
乡村主体：乡民
平台与跨边效应
平台价值机制
第六章 挑战者
超越想象
“弯曲”的价值链
数据
自主生成
参考文献
后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>建筑设计的新商业模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>居住模式与跨世纪住宅设计
前言
绪论
第一部分  理论方法篇
居住实态调查的方法和理论（小林秀树）
中国城市小康住宅研究中居住实态调查之所获（藤田忍）
居住实态调查的特点及其在中国的适应性（林建平）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>居住模式与跨世纪住宅设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Expert One-on-One J2EE Development without EJB中文版
第1章 为什么要“j2ee without ejb”
聚光灯下的ejb
j2ee还剩什么？
站在十字路口的j2ee
前行的路
主旋律
轻量级框架和容器
我们还应该使用ejb吗？
小结
第2章 目标
生产率
问题
传统j2ee方案解决生产率问题的办法
提升生产率更好的办法
oo
业务需求的重要性
经验过程的重要性
小结
第3章 各种架构
架构性构件
.业务服务层
向外部暴露业务对象
数据访问层，或eis层
j2ee架构
两种ejb架构
两种非ejb架构
j2ee架构实例
“经典的”j2ee远程ejb架构
本地ejb架构
特制的非ejb架构
“轻量级容器架构”：示例应用系统
确定是否采用应用服务器
小结
第4章 简单性的红利
复杂性的代价
在j2ee应用系统中，导致复杂性产生的原因
导致复杂性的架构性原因
导致复杂性的文化性原因：一个依靠复杂性为生的产业
复杂到什么地步就是过度了？
简单还是幼稚？
刚刚够好就行吗？
变化的趋势
总结
第5章 ejb，五年间
炒作和经验
ejb和j2ee行业
实践中的ejb
一个过时的组件模型
java语言的进步
.net的挑战
web service
敏捷方法学的兴起
关于ejb目标的混淆
从未出现的组件市场
方兴未艾的新范式：aop
ejb, 我们真正需要什么？为什么无状态session bean如此流行？
声明性事务管理
远程调用
集群
线程管理
ejb实例池
资源池
安全
业务对象管理
总结：ejb的服务
ejb，我们不想要什么？
容器的锁定
丑陋的结构，泛滥的类
部署描述文件的地狱
类加载器的地狱
测试
ejb的滥用
复杂的编程模型
简单的事情会变得困难
“让开发人员忽略企业应用的复杂性”，这个目标现实吗？
生产率的损失
可移植性的问题
ejb能浴火重生吗？
工具支持
ejb 3.0
神话与谬论
jee == ejb
使用ejb的可疑论据
继续前进
moving forward
选择是否使用ejb
传统的知识
今天的选择
后ejb时代的舆论
标准，创新，和开源
小结
第6章 轻量级容器与控制反转
轻量级容器
什么是轻量级容器？
我们到底为什么需要容器？
轻量级容器 vs. ejb容器
ejb的好处
管理业务对象
接口与实现的分离
ejb：不完善的解决方案
控制反转
ioc实现策略
ioc容器
ioc容器间的移植
对代码风格、测试以及开发过程的影响
代码风格
可测试性
开发过程
使用企业级服务
小结
第7章 spring框架简介
来历与动机
一个分层的应用框架
基础构建模块
j2ee之上的spring
web应用中的spring
核心bean工厂
基础接口
通过xml组装bean
非xml格式的bean声明
组装应用对象
自动装配和依赖检查
构造子决议
生命周期回调
复杂的属性值
资源设置
典型的java/j2ee资源访问
bean容器中的资源声明
工厂bean
spring应用上下文
生命周期回调
信息源
文件资源
bean factory 后处理
小结
第8章 基于aop概念的声明性中间件
aop 101
动机
j2ee中的aop
定义
历史
作为aop子集的ejb
aop实现策略
动态代理
动态字节码生成
java代码生成
使用定制的类加载器
语言扩展
aop实现
aspectj
aspectwerkz
jboss4
spring
nanning
aop联盟
aop设计问题
aop的危险性
aop设计的建议
随意点菜的j2ee
spring中的aop实践
使用proxyfactorybean
便利的factorybean
自动代理
编程用法
使用源码级元数据提供aop之上的抽象
.net范例
概念级元数据 vs. 实现级元数据
编程访问上下文信息
spring范例
ejb 3.0
编程风格的暗含意味
前后一致的命名规范
避免依赖aop基础设施
受控异常和增强
参考资料
书籍
论文
文章和在线资源
小结
第9章 事务管理
上层（high-level）事务管理
传统的j2ee事务管理
j2ee容器作为事务协调器
人见人爱的cmt
直接使用jta
插曲：远程事务传播
轻量级事务基础设施
spring framework的事务管理
事务声明
编程式事务处理
声明式事务管理
事务管理策略
选择j2ee服务器的提示
小结
第10章 持久化
常见持久化策略
持久化模式概览
流行的j2ee数据访问解决方案
选择一种持久化策略
透明持久化和领域对象的行为
java持久化技术简史
java o/r映射解决方案的缓慢成长
entity bean的败笔
实践中的数据访问技术
资源管理
jdbc
ibatis sql映射
jdo
hibernate
数据访问对象（dao）模式
业务对象与数据访问对象
dao和透明持久化
数据访问对象的种类
dao设计中的问题
dao基础设施的问题
使用spring框架进行数据访问
通用的数据访问异常
再论业务对象与数据访问对象的关系
jdbc
ibatis sql映射
jdo
hibernate
小结
第11章 远程调用
经典的j2se远程方案：rmi
访问和暴露rmi服务
用rmi调用器实现透明远程调用
经典的j2ee远程机制：ejb
通信协议
状态管理
访问远程ejb
部署远程ejb
基于wsdl的web services：jax-rpc
访问web services
servlet和ejb端点
轻量级远程方案：hessian和burlap
访问和暴露hessian和burlap服务
小结
第12章 替换其它的ejb服务
线程管理
线程神话
ejb线程模型
ejb实例池
何时需要实例池？
何时不需要实例池
ejb线程机制和缓冲池的替代方案
线程模型
实例池概述
声明性安全
ejb安全模型
ejb模型的缺陷
借助aop的声明式安全
jms和消息驱动bean
小结
第13章 web层设计
目标和体系结构的讨论
web层设计目标
用servlet和jsp定制的mvc
融入整体架构
请求驱动的web mvc框架
struts 1.1
webwork2
spring的web mvc框架
适宜的视图技术
web mvc的其它实现方式
portals和portlets
事件驱动的web mvc框架
小论asp.net
总结
第14章 单元测试与可测试性
为何测试很重要？
单元测试的目标
确保可测试性
编程风格
如何让你的代码难于测试
来自标准库的难题
提高可测试性的技巧
依赖倒置
aop
单元测试技巧
替换
模仿对象
编写有效测试
测试驱动开发（tdd）
好处
对tdd的反对意见
tdd实践
学习tdd
案例研究：spring的经验
测试spring应用程序
对pojo进行测试
spring的抽象带来的好处
何时需要依赖spring api
使用替换配置进行测试
覆盖率分析和其他测试工具
测试生成器
覆盖分析工具
突变测试工具
资源
小结
第15章 性能与可伸缩性
定义
设置清晰的目标
体系结构的选择：影响性能和可伸缩性的关键因素
对象分布、集群和农场
数据访问
其他体系结构方面的问题
不同实现的选择
摆脱ejb服务设施对性能的影响
结果总结
摆脱ejb服务设施对性能的影响
缓存的代码优化
调优和部署
jvm
应用服务器
框架配置
数据库配置
一种循证的性能策略
基准测试
采样（profiling）
诊断
资源
小结
第16章 示例应用系统
pet store（宠物店）业务需求
ibatis jpetstore 3.1
中间层
远程调用机制
可改进的空间
spring jpetstore
中间层
数据访问层
web层
远程机制
编译和部署
war部署中的一些问题
部署spring jpetstore
小结
第17章 结语
回顾
前行
为你的应用选择最佳架构
轻量级容器架构
标准关键词
指导方针
编程风格
控制反转（ioc）和依赖注入
aop
测试
写在最后
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Expert One-on-One J2EE Development without EJB中文版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>会计核算模式与财务系统设计
第一章&nbsp;&nbsp;企业会计核算模式概论
&nbsp;&nbsp;第一节&nbsp;&nbsp;企业会计模式的基本涵义
&nbsp;&nbsp;第二节&nbsp;&nbsp;企业会计核算模式设计的原则
&nbsp;&nbsp;&nbsp;&nbsp;一、合规性原则
&nbsp;&nbsp;&nbsp;&nbsp;二、实用性原则
&nbsp;&nbsp;&nb

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>会计核算模式与财务系统设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>农村电商新思维--农业创新营销模式设计
第一章 互联网 +农业营销的核心
第一节． 互联网+ 农业带来的营销变革
第二节． 互联网+ 农业营销的特点
第三节． 互联网+ 农业．营销的核心
第二章 互联网 +农产品打造之路
第一节　互联网产品打造的思维系统
第二节　爆款产品打造之道
第三节． 品质思维让生鲜产品极致
第四节　定位网货打造地域特色产品
第五节　深加工农产品打造
第六节　超级大单品打造
第三章 互联网+品牌农业之道
第一节　品牌建设基本方法
第二节　品牌定位之道
第三节　品牌内容之道
第四节　品牌传播之道
目录Contents
农村电商新思维
第五节　品牌运营之道
第五节　品牌品质之道
第六节． 品牌的包装之道
第四章 互联网 +农业创新营销的风口
第一节． 农产品电商营销的主要模式
第三节． 为农之道
第四节． 为商之道
第五节． 跨界合作之道
第六节． 创新营销模式
第五章 互联网+农业新红利之社交电商
第一节． 社交电商、农特产微商爆发的基础
第二节． 如何抓住社交电商的机会？
第三节． 社交电商的主要形式
第四节． 社交电商平台
第五节． 社交电商团队打造
第六节． 做好社交电商必须解决的问题
第七节． 社交电商的营销之道
第八节． 社交电商的培训体系
第九节． 社交电商技巧篇：
第六章 互联网 +农村电商面面观
第一节． 县域电商典型模式
第二节． 电商扶贫新路径
第三节． 公益农业的探索
第四节． 农村电商人才培育
农村电商新思维
第七章 生鲜电商破局之路
第一节． 生鲜电商的现状
第二节． 生鲜电商的坑
第三节． 生鲜电商的破局
第八章 互联网 + 供应链新蓝海
第一节． 供应链系统
第二节． 标准化+服务 +供应链管理是核心
第三节． 互联网+ 品牌供应链打造模式
第四节． 区域超级大单品供应链
第五节． 落地配如何落地
第六节． 平台与软件的选择
第九章 互联网+重构农业产业链
第一节　互联网+ 农业产业链模式
第二节　深加工有深度
第三节　农旅结合新格局
第十章 互联网+生态农业之路
第一节． 东西方典型的生态农业模式
第二节． 中国生态农业产业链
第三节． 生态农业创新营销
第四节． 生态农业创业之道
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>农村电商新思维--农业创新营销模式设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Ruby元编程
目录
前言 vii
致谢 ix
引言 xi
“元”这个字眼 xii
关于本书 xix
关于你 xxii
第1部分 Ruby元编程 1
第1章 星期一：对象模型 3
1.1 跟Bill在一起的星期一 3
1.2 打开类 4
1.3 类的真相 9
1.4 小测验：缺失的连接线 21
1.5 调用一个方法时发生了什么 23
1.6 小测验：混乱的模块 32
1.7 对象模型小结 35
第2章 星期二：方法 37
2.1 一个重复代码的问题 38
2.2 动态方法 40
2.3 method_missing()方法 48
2.4 小测验：狩猎Bug 59
2.5 关于method_missing()方法的更多内容 61
第3章 星期三：代码块 69
3.1 怎样度过驼峰日 70
3.2 小测验：Ruby的#符号 71
3.3 闭包 74
3.4 instance_eval() 83
3.5 可调用对象 86
3.6 编写一种领域专属语言 94
3.7 小测验：更好的领域专属语言 96
第4章 星期四：类定义 101
4.1 类定义揭秘 102
4.2 小测验：Taboo类 109
4.3 单件方法 110
4.4 Eigenclass 116
4.5 小测验：模块的麻烦 129
4.6 别名 131
4.7 小测验：打破数学规律 135
第5章 星期五：编写代码的代码 139
5.1 带路 139
5.2 Kernel#eval 142
5.3 小测验：校验过的属性（第一步） 152
5.4 小测验：校验过的属性（第二步） 155
5.5 小测验：校验过的属性（第三步） 157
5.6 小测验：校验过的属性（第四步） 158
5.7 钩子方法 159
5.8 小测验：校验过的属性（第五步） 165
第6章 尾声 167
第2部分“Rails中的元编程” 169
第7章 ActiveRecord的设计 171
7.1 准备旅程 172
7.2 ActiveRecord的设计 174
7.3 经验教训 183
第8章 深入ActiveRecord 187
8.1 动态属性 187
8.2 动态查找器 195
8.3 经验教训 200
第9章 安全元编程 205
9.1 元编程的测试 205
9.2 化解猴子补丁 213
9.3 经验教训 218
第三部分 附录 221
附录A 常见惯用法 223
A.1 拟态方法 223
A.2 空指针保护 226
A.3 关于方法参数的技巧 227
A.4 Self Yield 231
A.5 Symbol#to_proc()方法 232
附录B 领域专属语言 235
B.1 关于领域专属语言 235
B.2 内部和外部领域专属语言 237
B.3 领域专属语言和元编程 238
附录C 法术手册 239
C.1 法术集 239
附录D 参考书目 251
索引 253
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Ruby元编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>商业模式转换定制方案
第一章  商业模式转换：企业成长的源泉
一、什么是商业模式  003
二、传统的商业模式  009
三、新型商业模式的创新  013
四、商业模式转换的重点  019
五、商业模式转换的四大源泉  024
第二章  商业模式转换七步骤
第一步 发展趋势  031
第二步 客户定位  035
第三步 业务系统  046
第四步 创利模式  054
第五步 降低成本  062
第六步 自我复制  067
第七步 关键资能  073
第三章 商业模式转换的五个方向
一、财富方向  081
二、用户方向  083
三、人性方向  084
四、数据方向  086
五、政策方向  088
第四章  商业模式转换制胜的要素
一、客户至上：创新客户模式  093
二、渠道铺路：创新渠道模式  096
三、产品为王：创新产品模式  100
四、运营必胜：创新运营模式  103
五、经营为基：创新经营模式  107
六、管理之道：创新管理模式  110
第五章  商业模式创新案例
案例一、米兰春天：复合品牌营销商业模式 117
案例二、麦当劳：快餐店背后的地产王国  121
案例三、沃尔玛：物流至上的“区域集中模式”  125
案例四、携程：旅游资源整合模式  129
案例五、eBay：“C2C 电子商务平台”  133
案例六、优视科技：由入口到平台  136
第六章  互联网时代下的商业模式创新
一、所有的行业都在被互联网“吞噬”  141
二、平台商业模式  144
三、品牌模式  148
四、O2O 商业模式  154
五、C2M 商业模式  160
六、物流商业模式  165
七、双模模式  169
八、免费模式  174
第七章 互联网模式与传统产业的融合
一、众筹模式：融资产业互联网  183
二、乐视：开创企业用众筹营销之先河  186
三、余额宝：金融产业互联网  191
四、小米：手机产业互联网  196
五、万达电商：房地产产业互联网  201
六、“三马”模式：保险产业互联网  206
七、淘宝：零售产业互联网  210
八、江小白：酒业产业互联网  214
九、凡客诚品：服装产业互联网  219
十、中石油：中国石油化工移动互联网平台  225
十一、特斯拉：“互联网汽车”带来汽车产业革命  232
十二、苏宁 / 海尔：电器产业互联网  237
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>商业模式转换定制方案
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业应用架构模式
模式列表
译者序
前言
引言
第一部分 表述
第1章 分层
第2章 组织领域逻辑
第3章 映射到关系数据库
第4章 Web表现层
第5章 并发
第6章 会话状态
第7章 分布策略
第8章 通盘考虑
第二部分 模式
……
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业应用架构模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>A管理模式
第一章岗位职能
一、岗位名称

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>A管理模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>金融资产管理公司的模式选择与运作设计
序
1. 引言：中国商业银行的不良资产
1. 1中国国有商业银行不良资产的形成与分析
1. 2处置商业银行不良资产的方式概述
1. 3金融资产管理公司与商业银行不良资产的处置
1. 4中国金融不良资产重组的

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>金融资产管理公司的模式选择与运作设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大气数值模式的设计
前言符号一览表第一章 大气数值模

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大气数值模式的设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>新课程的教学设计思路与教学模式
第一章  新课程的教学设计概述
一 现代教学设计的操作框架
1 现代教学设计的基本涵义
2 现代教学设计的指导思想
3 现代教学设计的运作程序
二 新课程对教学设计提出的要求
1 充分体现新课程的基本理念
2 整体把握教学活动的结构
3 突出创新精神与实践能力的培养
4 根据学科特点和知识类型设计教学

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>新课程的教学设计思路与教学模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>机械设计基础
序
前言
绪论1
单元1静力学基础5
任务1绘制构件的受力图5
任务2绘制平面汇交力系受力图14
任务3绘制平面力偶系受力图19
任务4绘制平面任意力系受力图26
单元2材料力学基础32
任务1拉伸与压缩强度计算32
任务2剪切与挤压强度计算39
任务3圆轴扭转强度计算43
任务4直梁弯曲强度计算51
单元3平面连杆机构60
任务1绘制平面机构运动简图60
任务2平面机构自由度的计算64
任务3认识铰链四杆机构69
任务4认识铰链四杆机构的基本性质73
任务5认识铰链四杆机构的演化79
任务6平面四杆机构的设计83
单元4凸轮机构88
任务1认识凸轮机构88
任务2认识从动件常用的运动规律91
任务3设计凸轮轮廓94单元5其他常用机构100
任务1认识变速机构100
任务2认识棘轮机构103
任务3认识槽轮机构107
任务4实践课题——自行车飞轮的拆装109
单元6齿轮传动112
任务1认识齿轮传动112
任务2直齿圆柱齿轮传动的计算116
任务3设计直齿圆柱齿轮119
任务4斜齿圆柱齿轮传动的计算124
任务5设计斜齿圆柱齿轮127
任务6认识齿轮的材料及失效形式131
任务7认识齿轮的结构和润滑方式136
任务8实践课题——齿轮模数的计算139
单元7蜗杆传动142
任务1认识蜗杆传动142
任务2蜗杆传动的热平衡计算147
单元8轮系153
任务1定轴轮系传动比的计算153
任务2周转轮系传动比的计算161
任务3认识减速器165
单元9摩擦轮传动和挠性件传动172
任务1认识摩擦轮传动172
任务2设计平带传动176
任务3认识V带传动181
任务4设计V带传动187
任务5认识链传动195
任务6设计链传动203
任务7实践课题——V带传动的安装与张紧209
单元10联接212
任务1认识键联接212
任务2平键联接的设计219
任务3认识销联接223
任务4认识联轴器226
任务5认识离合器、制动器232
任务6实践课题——轴上齿轮的拆装237
任务7实践课题——联轴器的拆装239
单元11螺纹联接与螺旋传动241
任务1认识螺纹联接241
任务2螺栓强度计算249
任务3普通螺旋传动的计算254
任务4差动螺旋传动的计算257
单元12轴262
任务1认识轴262
任务2设计轴的结构266
任务3轴的强度计算271
单元13轴承278
任务1认识滑动轴承278
任务2认识滚动轴承283
任务3滚动轴承寿命计算及组合设计291
任务4实践课题——滚动轴承的拆装297
任务5实践课题——减速器的拆装299
参考文献302
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>机械设计基础
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>楼盘销售示范区
艺术人文式体验
黄山悦榕庄
Banyan Tree Resort, Huangshan
福州融侨•观山府
Majestic Mansion, Fuzhou
西安金辉天鹅湾
Kamfei Swan Bay, Xi’an
西安万科金色悦城
Vanke Joying Golden City, Xi’an
南京金色半山
Vanke Great Mansion, Nanjing
西安万科大明宫
Vanke Daming Palace, Xi’an
广州万科东荟城
Vanke Donghui City, Guangzhou
绍兴景瑞望府
Jingrui Dignity Mansion, Shaoxing
广州万科欧泊
Vanke Opalus, Guangzhou
上海万科海上传奇
Vanke Legend of Shanghai, Shanghai
平湖万孚尊园
Vanfu Royal Palace, Pinghu
西安中建开元•壹号
CSCES New Times，Xi’an
无锡长泰国际社区
Chamtime International Town, Wuxi
隐居式体验
合肥绿地内森庄园
Manor of Nathan, Hefei
湖州景瑞望府
Jingrui Dignity Mansion, Huzhou
现代时尚式体验
南昌绿地未来城
Greenland Future City, Nanchang
重庆星耀天地
Galaxy, Chongqing
台北臻盛传诚
The Heritage, Taipei
北京翼之城
Air City, Beijing
休闲慢活式体验
厦门海峡国际社区
Straits International Community, Xiamen
东莞万科松湖中心
Vanke Songshan Lake Center, Dongguan
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>楼盘销售示范区
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>外观设计法律保护模式研究
第1章　引　言001
11　研究背景与问题001
12　研究思路及意义003
13　国内外研究现状004
131　国外研究现状004
132　国内研究现状008
14　逻辑结构及篇章安排011
15　研究方法013
151　历史研究法013
152　比较研究法013
153　实证研究法013
第2章　外观设计概论014
21　外观设计的演变与发展014
211　艺术与实用的分离标准014
212　设计的工业化标准017
213　外观设计的现代演绎021
22　外观设计的法律保护025
221　外观设计保护的起源025
222　外观设计的国际保护027
23　外观设计的特性032
231　外观设计的法律特性：工业产权还是艺术财产? 033
232　外观设计的经济意义：技术与市场之间的桥梁036
233　外观设计的政策导向：利益的博弈结局038
234　外观设计的社会功效：综合因素作用的结果042
24　本章小结043
第3章　我国外观设计保护的发展及问题045
31　早期的保护045
32　现代的演变048
321　制度的建立(1984) 048
322　基本原则的确定(1993) 051
323　完整体系的建立(2001) 053
33　全面修改的开始057
331　授权标准的提高057
332　侵权规则的确立059
333　司法判例的指导063
34　存在的问题及原因065
3 41　法律体系的完善066
342　“双轨制”模式的弊端067
343　前沿问题的关注与研究068
35　本章小结070
第4章　外观设计可专利性分析071
41　专利模式下的外观设计保护071
42　外观设计的专利化进程072
421　专利保护的起源072
422　立法的偏差077
423　混乱的司法实践082
43　外观设计专利化的困境及成因085
431　“新颖性”与“新颖点测试” 085
432　难以适用的“创造性(非显而易见性)”标准091
433　功能性理论的扭曲097
434　高昂的保护成本103
44　外观设计专利保护的新发展104
441　“非显而易见性”标准的修正104
442　Egyptian案的意义107
443　模糊的司法态度110
45　本章小结113
第5章　著作权法视野下的外观设计115
51　著作权法的扩张115
511　著作权的理论基础115
512　“艺术统一性”原则的提出117
513　《伯尔尼公约》的确定120
514　美国版权保护的历程122
515　我国对实用艺术作品的保护127
52　外观设计著作权保护的路径129
521　著作权与工业产权的分野130
522　物理上的分离测试法132
523　观念上的分离测试法134
524　分离测试理论的意义139
53　实用艺术作品的保护及问题142
531　独创性的认定142
532　侵权判定的规则144
533　与相关概念的区分147
54　本章小结149
第6章　商标意义下的外观设计保护151
61　外观设计与商标的重叠151
611　商业性标识与商业性外观151
612　我国的实践154
62　外观设计商标保护的条件157
621　显著性的体现157
622　知名度的具备159
623　非功能性的要求160
63　外观设计商标保护的障碍163
631　保护客体的差异163
632　立法宗旨的区别165
633　保护模式的不同166
64　本章小结167
第7章　外观设计独立保护模式构建———整体构想169
71　独立保护的原因169
711　外观设计的定位169
712　现有模式的问题172
713　独立保护的可行性175
72　独立保护的渊源178
721　早期的独立保护思想178
722　美国的尝试与反思180
723　我国独立保护的思考184
73　独立保护的经验186
731　欧盟的独立保护186
732　美国的专门立法190
74　独立保护的新动向———以美国时尚设计立法为例192
741　美国时尚设计立法概况192
742　时尚设计独立保护的问题194
743　对我国的启示197
75　本章小结198
第8章　外观设计独立保护模式构建———制度规划199
81　保护范围的界定：功能性理论的应用199
811　功能性理论的内涵200
812　功能性理论适用的现状201
813　功能性理论的理解205
82　判定主体的选择：合理的认知水平207
821　一般消费者的能力208
822　判定主体的界定210
83　授权标准的把握：创造性标准的解释213
831　“创造性”标准的内涵213
832　与“新颖性”标准的协调215
833　设计空间概念的适用217
84　侵权判定的体系：不同模式的比较221
841　判定模式的现状221
842　“混淆模式”的问题223
843　“创新模式”的困境224
844　判定模式的选择227
85　本章小结231
参考文献232
后　记243
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>外观设计法律保护模式研究
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>理解为先模式/当代前沿教学设计译丛/梦山书系
图表目录单元教学设计指南引言模块1：理解为先模式基本思想理解乃教育目的什么是理解优质设计即“逆向”设计避免单元规划中的两大典型误区反思优秀的学习设计设计标准参考文献模块2：理解为先模式模板阶段一：明确预期学习结果标准和其他既定目标阶段二：确定恰当评估办法阶段三：规划相关教学过程设计标准理解为先模式应用前后对比案例案例单元参考文献模块3：从哪里开始设计结果Vs过程设计定位参考文献模块4：开发初步的单元草稿阶段一——预期结果是什么预期的技能结果长期的理解性目标如何影响短期的内容教学和评估询问目的的问题阶段二——什么样的证据可以证明达到了单元目标理解=自我提示评估=可靠的证据，而不只是形式阶段三——基于目标和证据，如何实现这些结果逆向设计的一致性：“两个问题”测试自我评估——回顾模块4的标准参考文献模块5：不同类型的学习目标阶段一——预期学习结果阶段二和阶段三有哪些相应内容真正理解与貌似理解迁移：是与不是自我评估——回顾模块5的标准重温营养单元参考文献模块6：基本问题与理解核心观点与模板基本问题非基本（但对教师很重要的）问题目的重于形式基本问题与小学生基本问题与教授技能理解框架理解与老生常谈理解与技能自我评估——回顾模块6的标准完善营养单元参考文献模块7：确定理解的证据和开发评估任务理解的证据对迁移作出评估理解的六个维度运用六个维度误区提示为迁移而教意味着为熟练而评估教材评估自我评估——回顾模块7的标准营养单元的再改进参考文献模块8：为理解而学编码学习计划走向理解通过挑战性质疑来促成理解技能教学和为理解而教学会迁移教科书的角色提示学生运用AMT的必要性自我评估——回顾模块8的标准营养单元的回顾参考文献结束语走出单元设计的25个误区——精炼单元设计改善学习效果引言阶段一  设计单元目标的误区误区1课堂活动目标不明确误区2片面强调知识覆盖面误区3单元设计应试化倾向误区4单元目标不聚焦误区5单元缺乏基于理解的目标误区6单元目标之间联系不明确误区7缺乏核心问题误区8混淆目的和手段误区9混淆知识目标和技能目标阶段二  确定评估办法的误区误区10评估缺乏效度误区11评估缺乏信度误区12表现性任务不真实误区13表现性任务繁冗低效误区14表现性任务统一化误区15评估标准或量规无效阶段三  落实学习计划的误区误区16单元设计与目标不相符误区17单元设计缺乏预评估误区18单元设计未能预估学习错误误区19单元缺乏动态的形成性评估误区20单元计划未含必要的调整时间误区21单元设计太单一刻板误区22单元设计无法促进学生迁移误区23单元设计没有考虑学生多元差异误区24单元设计未能提升学生自适应能力误区25单元设计背离目标或评估参考文献理解为先模式主要图书和重要网站资料信息作者简介译后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>理解为先模式/当代前沿教学设计译丛/梦山书系
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>结构化并行程序设计
译者序
前言
写在前面
第1章　导论 1
1.1　并行思维 2
1.2　性能 3
1.3　动机：无处不在的并行 6
1.3.1　硬件发展推进并行化 6
1.3.2　并行化的历史趋势 8
1.3.3　显式并行编程的需求 12
1.4　基于模式的结构化编程 15
1.5　并行编程模型 16
1.5.1　理想特征 16
1.5.2　用抽象代替具体 17
1.5.3　规则数据并行 18
1.5.4　可组合性 21
1.5.5　功能可移植性 21
1.5.6　性能可移植性 22
1.5.7　安全性、确定性和可维护性 22
1.5.8　编程模型概述 23
1.5.9　何时使用模型 28
1.6　本书的结构 29
1.7　小结 29
第2章　背景知识 31
2.1　名词和符号 31
2.2　策略 31
2.3　机制 33
2.4　计算机模型 35
2.4.1　计算机模型概述 35
2.4.2　影响性能的关键因素 39
2.4.3　Flynn分类法 41
2.4.4　革新 42
2.5　性能理论 43
2.5.1　延迟和吞吐量 44
2.5.2　加速比、效率和可扩展性 44
2.5.3　功耗 45
2.5.4　Amdahl定律 46
2.5.5　Gustafson-Barsis定律 48
2.5.6　工作量–跨度模型 49
2.5.7　渐近复杂度 51
2.5.8　渐近加速比和渐近效率 52
2.5.9　Little公式 53
2.6　并行陷阱 54
2.6.1　竞态条件 54
2.6.2　互斥和锁 55
2.6.3　死锁 56
2.6.4　扩展性抑制 57
2.6.5　局部性不足 57
2.6.6　负载不均衡 58
2.6.7　额外开销 58
2.7　小结 59
第一部分　模式
第3章　模式概述 62
3.1　嵌套模式 63
3.2　结构化串行控制流模式 64
3.2.1　序列 64
3.2.2　选择 65
3.2.3　迭代 66
3.2.4　递归 68
3.3　并行控制模式 68
3.3.1　Fork-Join 68
3.3.2　映射 68
3.3.3　模板 69
3.3.4　归约 70
3.3.5　扫描 71
3.3.6　递推 73
3.4　串行数据管理模式 74
3.4.1　随机读写 74
3.4.2　栈分配 74
3.4.3　堆分配 75
3.4.4　闭包 75
3.4.5　对象 75
3.5　并行数据管理模式 76
3.5.1　打包 76
3.5.2　流水线 76
3.5.3　几何分解 77
3.5.4　聚合 78
3.5.5　散发 78
3.6　其他并行模式 79
3.6.1　超标量序列 79
3.6.2　期货 80
3.6.3　投机选择 80
3.6.4　工作堆 81
3.6.5　搜索 81
3.6.6　切片 81
3.6.7　展开 81
3.6.8　分类归约 82
3.6.9　项图重写 83
3.7　非确定性模式 83
3.7.1　分支限界 83
3.7.2　事务 84
3.8　编程模型对模式的支持 84
3.8.1　Cilk Plus 86
3.8.2　线程构建块 87
3.8.3　OpenMP 88
3.8.4　阵列构建块 89
3.8.5　OpenCL 90
3.9　小结 91
第4章　映射 92
4.1　概述 93
4.2　带缩放系数的向量加法 94
4.2.1　问题描述 94
4.2.2　串行实现 95
4.2.3　TBB实现 96
4.2.4　Cilk Plus实现 96
4.2.5　使用数组符号的Cilk Plus实现 97
4.2.6　OpenMP实现 97
4.2.7　使用向量操作的ArBB实现 97
4.2.8　使用元素函数的ArBB实现 98
4.2.9　OpenCL实现 99
4.3　芒德布罗分形图 100
4.3.1　问题描述 100
4.3.2　串行实现 100
4.3.3　TBB实现 101
4.3.4　Cilk Plus实现 101
4.3.5　使用数组符号的Cilk Plus实现 101
4.3.6　OpenMP实现 103
4.3.7　ArBB实现 103
4.3.8　OpenCL实现 104
4.4　映射的序列和序列的映射 105
4.5　并行模型的对比 107
4.6　相关模式 107
4.6.1　模板 107
4.6.2　工作堆 108
4.6.3　分治 108
4.7　小结 108
第5章　集合 109
5.1　归约 109
5.1.1　计算重排序 110
5.1.2　向量化 111
5.1.3　分块 112
5.1.4　精度 113
5.1.5　实现 113
5.2　映射和归约的融合 114
5.2.1　TBB中的显式融合 115
5.2.2　Cilk Plus中的显式融合 115
5.2.3　ArBB中的自动融合 115
5.3　点积 115
5.3.1　问题描述 115
5.3.2　串行实现 116
5.3.3　SEE内联函数实现 116
5.3.4　TBB实现 117
5.3.5　Cilk Plus实现 119
5.3.6　OpenMP实现 120
5.3.7　ArBB实现 121
5.4　扫描 122
5.4.1　Cilk Plus 123
5.4.2　TBB 124
5.4.3　ArBB 124
5.4.4　OpenMP 124
5.5　映射和扫描的融合 127
5.6　积分 127
5.6.1　问题描述 128
5.6.2　串行实现 128
5.6.3　Cilk Plus实现 130
5.6.4　OpenMP实现 130
5.6.5　TBB实现 131
5.6.6　ArBB实现 132
5.7　小结 134
第6章　数据重组 135
6.1　聚合 135
6.1.1　常规聚合 135
6.1.2　移位 137
6.1.3　拉合 137
6.2　散发 138
6.2.1　原子散发 139
6.2.2　排列散发 139
6.2.3　归并散发 139
6.2.4　优先散发 140
6.3　将散发转换为聚合 140
6.4　打包 141
6.5　映射和打包的融合 142
6.6　几何分解和分区 143
6.7　结构的数组和数组的结构 145
6.8　小结 148
第7章　模板和递推 149
7.1　模板 149
7.2　用移位实现模板 151
7.3　针对缓存的分块式模板 151
7.4　模板通信优化 152
7.5　递推 153
7.6　小结 155
第8章　Fork-Join 156
8.1　定义 156
8.2　编程模型对Fork-Join的支持 157
8.2.1　Cilk Plus对Fork-Join的支持 158
8.2.2　TBB对Fork-Join的支持 159
8.2.3　OpenMP对Fork-Join的支持 159
8.3　映射的递归实现 160
8.4　基本情形的选择 162
8.5　负载均衡 163
8.6　并行分治的复杂度 165
8.7　Karatsuba多项式乘法 167
8.8　缓存局部性和缓存参数无关算法 170
8.9　快速排序 172
8.9.1　Cilk Plus快速排序 174
8.9.2　TBB快速排序 175
8.9.3　快速排序的工作量和跨度 178
8.10　归约和超对象 178
8.11　用Fork-Join实现扫描 181
8.12　在递推中使用Fork-Join 185
8.12.1　分析 188
8.12.2　平面Fork-Join 188
8.13　小结 188
第9章　流水线 189
9.1　基本流水线 189
9.2　有并行阶段的流水线 190
9.3　流水线的实现 191
9.4　编程模型对流水线的支持 192
9.4.1　TBB中的流水线 192
9.4.2　Cilk Plus中的流水线 193
9.5　更多通用的拓扑结构 195
9.6　强制并行性与可选并行性 196
9.7　小结 196
第二部分　示例
第10章　地震正演模拟 198
10.1　背景 198
10.2　模板的计算 199
10.3　缓存对运算强度的影响 200
10.4　使用时空分块提高运算强度 202
10.5　Cilk Plus代码 203
10.6　ArBB实现 206
10.7　小结 207
第11章　K均值聚类 208
11.1　算法 208
11.2　K均值的Cilk Plus实现 209
11.3　K均值的TBB实现 212
11.4　小结 216
第12章　Bzip2数据压缩 217
12.1　Bzip2算法 217
12.2　三段流水线的TBB实现 218
12.3　四段流水线的TBB实现 221
12.4　三段流水线的Cilk Plus实现 221
12.5　小结 222
第13章　归并排序 223
13.1　并行归并 223
13.1.1　并行归并的TBB实现 225
13.1.2　并行归并的工作量和跨度 225
13.2　并行归并排序 226
13.3　小结 227
第14章　样本排序 228
14.1　总体结构 228
14.2　选取分箱数量 229
14.3　分箱 229
14.4　再打包和子排序 231
14.5　样本排序的性能分析 232
14.6　写给C++高手 232
14.7　小结 233
第15章　Cholesky因式分解 234
15.1　Fortran规范 234
15.2　递归Cholesky分解 235
15.3　三角矩阵求解 236
15.4　对称秩校正 238
15.5　时间用在哪里 239
15.6　小结 239
附录
附录A　拓展阅读 242
附录B　Cilk Plus 244
附录C　TBB 259
附录D　C++11 269
附录E　术语表 273
参考文献 291
索引 296
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>结构化并行程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>商业模式设计时代
目录
推荐序一
推荐序二
前言
第1章　关于商业模式工具书
1.1   商业模式为什么需要视觉化表达  2
1.2   什么是商业模式  6
1.3   关于魏朱六要素的基础知识介绍  10
1.4   商业模式的演进  18
1.5   六要素常用工具图表  27
1.6   为什么需要自己动手？每个工具安排练习的目的  31
第2章　开始动手梳理自己企业的1.0模式
2.1   定位与业务系统：交易五线图  33
2.2   盈利模式的展现：收支方式图与收支来源PM图  56
2.3   企业的关键资源/能力：资源/能力表  79
2.4   现金流的梳理：现金流结构图  93
2.5   企业现状的完整呈现：魏朱六要素商业模式画布  101
第3章　常见模式的业务系统展现
3.1   商业模式的设计演进  107
3.2   不同行业存在相同模式  114
3.3   单边平台：企业平台化  121
3.4   双边/多边平台：创造生态系统  127
3.5   免费模式  136
3.6   加盟连锁店模式  153
3.7   分享经济模式  164
3.8   其他知名企业的模式  172
第4章　初步运用六要素创新商业模式
4.1   四种创新商业模式的维度空间  182
4.2   广角境看生态，看外部环境，画出企业生态图  188
后记  209
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>商业模式设计时代
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>创新驱动的设计管理模式转型
第一章 转型问题的缘起
第一节 研究背景与意义
一、创新重要性的凸现
二、设计管理在创新中的重要价值
三、设计管理的危机与机遇
四、设计管理转型的必然
第二节 研究对象与概念阐释
一、设计管理
二、类型、模式及转型
三、创意驱动、创造驱动和创新驱动
第三节 研究方法与路径
一、文献研究法
二、案例分析法
三、模型分析法
四、实证性分析
第四节 研究逻辑与论文框架
第二章 转型问题及文献综述
第一节 设计转型问题综述
一、设计的科学化
二、从设计到设计思维的转变
三、设计研究模式转变
第二节 设计管理模式转型问题综述
一、设计在商业中的价值
二、设计与管理的关系
三、战略重心向以用户为中心转移
四、设计推动组织变革的问题
五、品牌设计管理的问题
六、知识生产角度的设计管理问题
七、设计领导力和教育问题
第三节 存在问题与机会
本章小结
第三章 设计管理模式分析
第一节 人为事物关系模型
一、人为事物理论
二、人为事物关系模型
三、模型原理及相关阐释
第二节 广义用户观
一、用户研究中的“用户”
二、“以用户为中心”理论
三、“狭义用户”与“广义用户”
第三节 价值通道理论
一、相关理论回顾
二、价值定位与挖掘
三、价值通道分析
四、四个维度的价值系统
第四节 三种设计管理模式的假设
一、创意驱动模式
二、创造驱动模式
三、创新驱动模式
本章小结
第四章 设计管理模式转型
第一节 创意驱动向创造驱动的转型
一、转型的历史性阐述
二、隐含的逻辑
第二节 创造驱动向创新驱动的转型
一、转型的案例性分析
二、内在逻辑
第三节 并行而非替代
一、创意驱动模式的存在
二、创造驱动模式的存在
本章小结
第五章 以家具业为例的实证性分析
第一节 模式类型相应特征分析
一、创意驱动模式的企业类型
二、创造驱动模式的企业类型
三、创新驱动模式的企业类型
第二节 模式类型相对优越性分析
一、体现在企业规模和增速上
二、体现在产业影响力上
三、体现在社会影响力上
第三节 模式转型路径分析
一、从创意向创新转型
二、从创造向创新转型
本章小结
第六章 模式转型的困境与机遇
第一节 困境
第二节 对设计行业的影响
第三节 对初创企业的影响
第四节 对中小型企业创新的影响
第五节 对大型企业创新的影响
第六节 对社会创新的影响
第七节 对设计管理教育的影响
本章小结
第七章 结论
第一节 发现与成果
第二节 不足与展望
参考文献
附 录
后 记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>创新驱动的设计管理模式转型
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>A管理模式
第一章岗位职能
一、岗位名称

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>A管理模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>模式识别与图像处理并行计算机系统设计
第一篇  引
论
第一章  模式识别与图像处理 PRIP
1. 1  PRIP简介
1. 2  图像处理技术
1. 3  模式识别方法
1. 3. 1  统计识别方法

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>模式识别与图像处理并行计算机系统设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>中国县域经济推进中现代农业建设模式设计
第一篇  主报告第1章  几个有关概念和基本理论问题  1．1  县域经济  1．2  农业  1．3  传统农业  1．4  现代农业第2章  中国县域经济推进中现代农业建设的意义  2．1  建设现代农业是落实科学发展观，构建和谐社会的需要  2．2  建设现代农业是强化农业基础地位的需要  2．3  建设现代农业是破解“三农”问题，增加农民收入的需要  2．4  建设现代农业是加快推进新农村建设的需要  2．5  建设现代农业是县域经济全面、协调、健康、可持续发展的需要第3章  中国县域经济推进中农业发展的现状    3．1  良种普及，效益提升  3．2  结构调整，特色凸现  3．3  农地减少，压力渐增  3．4  重点转移，隐患萌生第4章  中国县域经济推进中现代农业建设的制约因素及其原因剖析  4．1  我国现代化进程中的农业现代化  4．2  市场经济转型对中国现代农业建设的制约及其原因  4．3  城市化、工业化对中国现代农业建设的制约及其原因  4．4  技术、组织、制度对我国现代农业建设的制约及其原因  4．5  突破制约因素，加快现代农业建设的相关对策第5章  中国县域经济推进中现代农业建设的可行模式  5．1  现代农业建设模式设计的原则与方法  5．2  中国现代农业的主要类型、模式  5．3  模式设计的基础原形及改造设计第6章  中国县域经济推进中现代农业建设的基本对策  6．1  农民知识化  6．2  农业企业化  6．3  土地集约化  6．4  布局优质化  6．5  服务社会化  6．6  产品名优化  6．7  市场国际化  6．8  环境生态化  6．9  管理智能化  6．10  政府高效化第二篇  子报告  子报告1：寿光市现代农业发展的道路与模式  子报告2：莱州市农业现代化进程评价体系与推进战略研究  子报告3：莱州市县域农业科技发展的实践与启示  子报告4：山东省加快转变农业发展方式问题研究  子报告5：现代农业发展的“昆山之路”    子报告6：中国特色现代食用茵产业与高效循环农业系统参考文献后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>中国县域经济推进中现代农业建设模式设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>建筑美学与室内软装——孙宝宏模式系统设计
第一章 设计理论
第一节 黄金律
第二节 构图的整体感
第三节 色彩构图要素
第四节 设计理论在建筑和室内设计中的应用
第五节 室内软装与建筑元素的关系
第二章 自然主义
第一节 风格总述
第二节 案例分析
案例一 英伦印象
案例二 外景走进室内
案例三 乡土芬芳
案例四 永恒的色彩
案例五 午后奶茶
案例六 大自然的邂逅
第三章 新古典主义
第一节 风格总述
第二节 案例分析
案例一 泰晤士河的深度
案例二 法兰西的荣耀
案例三 大理石的诗
案例四 自然与古典的交织
案例五 东方神韵
案例六 遗梦江南
第四章 新都市主义
第一节 风格总述
第二节 案例分析
案例一 都市协奏曲
案例二 威尼斯之梦
案例三 北欧假日
案例四 现代回眸
案例五 优雅与精致
案例六 数字时代
.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>建筑美学与室内软装——孙宝宏模式系统设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>下一波商業創新模式
好評推薦
序
緒論
讀者導覽
第一章    充滿藝術感的創意
何謂策略式創意
傳統的策略式管理
策略式創意
何處進行：找出機會
如何進行：雕琢你的機會
如何贏：創造價值
何謂商業設計型思考
商業設計型思考的5大原則
蓄勢待發
第二章    發掘你的嶄新成長機會
瞭解你的客戶與非客戶
客戶與非客戶
瞭解客戶的需求、期望與選擇
找出消費的障礙與不滿意度的原因
啟發: 美國卡地纳健康集團（Cardinal Health）
啟發: 瑞士哈里斯蘭登醫療集團（Klinik Hirslanden）
如何瞭解你的客戶與非客戶
蒐集資訊
好好觀察並創造主題
將發現所得變成真知灼見
啟發: 漣漪效應」（The Ripple Effect）
練習:品牌角色（擬人化）測繪
練習: 製作訪談指南
練習: 客戶旅程測繪
練習: 製作觀察摘要
瞭解你的企業
啟發: 資源與能力
啟發: 凱薩宮酒店（Caesars Palace）
資源火花：測繪與評估資源時的4大面向
瞭解你的企業的方法
練習：測繪你的資源
練習：測繪你的生態系統
制訂你的成長計畫
機會藝術的成長樣態
演化式成長
突破式成長
突破的問題
建構你的成長機會
決策制訂
決策制訂策略的種類
練習：制訂你的成長計畫大綱
練習：探究你的機會洞察力
練習：選擇你的機會
將機會視覺化
運用說故事和視覺化的框架
練習：將你的機會視覺化
第三章    雕琢你的策略
策略裡的元素
設計你商品
產品
服務
消費者的經驗
啟發:喜利得集團（Hilti Group）
提供火花：設計新商品的10個方法
練習: 提供腦力激盪
練習: 設計你的商品
塑造你的商業模式
靜態的觀點
動態的觀點
策略的觀點
執行的觀點
我們對商業模式的定義
商業模式的組成元素
練習
參考資料
順序
角色
測試商業模式
啟發: 伊麥（Eden McCallum）策略顧問公司
啟發: 瑞士哈里斯蘭登醫療集團（Klinik Hirslanden）
商業模式的火花：設計商業新模式的8個方法
練習: 將目前的商業模式視覺化
練習: 設計你的商業新模式
練習: 翻轉你假設的商業模式
建構你的獲利模式
獲利金流
定價機制
付款機制
啟發: 基爾希傳媒控股(ProSiebenSat.1)
啟發: Fahrenheit 212顧問公司
啟發: 826瓦倫西亞（826Valencia）
必須考慮的商業模式火花
練習: 獲利模式卡片分類
設定你的策略: 創造價值
創造價值
消費者的價值
企業的價值
生態的價值
啟發摘要: 公司的價值主張
練習: 設定你的策略
將你的策略視覺化
最後附註: 雕琢你的策略
練習: 視覺化你的策略
第四章    推出你的業務長紅新事業
業務長紅新事業的三階段
1.啟動階段: 驗證你的機會並測試你的策略
驗證與測試的3大步驟
如何驗證你的引導
練習呈現你的驗證資料
內部觀察
田野觀察
刺激
訪談
研究
小規模的實驗
可探索的額外資源
練習:測試甚麼
練習:如何測試
學習你的引導
達成勝利
面臨挑戰
獲得洞察力
2.    演進階段
啟發:基爾希傳媒控股 (ProSiebenSat.1)
啟發: Fahrenheit 212顧問公司
練習: 啟動、停止、改革、持續
練習: 設計接下來的步驟
將你的成長計劃視覺化
練習: 將你的成長計劃視覺化
3.    擴散階段
操作上的挑戰
塑造清楚的角色與責任歸屬
建立充滿分享、傾聽、同心協力、有實驗精神、互相扶持的組織文化
再擴大規模的計劃與執行進程中採取全面制度化
擬訂計畫並採用嚴格但一般性的檢討與修正流程
創造一種清楚簡單的方法來追蹤與評量你的進展
第五章    專精此道: 企業設計式思考
何謂企業設計式思考?
企業設計式思考的基礎
程序和方法
企業設計式思考的原則
1.保持以人為本
2.用視覺式思考講故事
3.同心協力
4.透過主動重複追求進步
5.常保整體觀
啟發: 甲骨文
啟發: ExactTarget
嶄新工作方式
啟發: 微軟
作者介紹
致謝
附註
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>下一波商業創新模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>网络与新媒体应用模式
第一章网络与新媒体概述
第一节“网络与新媒体”的概念辨析和层次模型
一、网络与新媒体的概念辨析
二、网络与新媒体的层次模型
第二节网络与新媒体的应用载体——万维网
一、万维网1.0时代
二、万维网2.0时代
三、万维网3.0——语义网
第三节网络与新媒体的基础设施
一、互联网
二、移动互联网
三、物联网
第四节网络与新媒体应用的计算模式——云计算
一、云计算的基本原理
二、云计算的变革性影响
第五节网络与新媒体应用的数据环境——大数据
一、大数据概述
二、大数据分析的关键技术
三、大数据带来的主要挑战
四、发展现状
第二章网络与新媒体的应用模式理论
第一节应用模式的概念
第二节应用模式的设计理论
一、原子理论
二、原子应用模式的描述模型
第三节应用模式的体系结构
一、用户需求层次结构
二、原子模式体系结构
第四节应用模式创新设计的原则和方法
一、设计原则
二、设计方法
第三章网络与新媒体的信息获取应用模式
第一节网络新闻模式
一、概述
二、原子模式一：位置新闻模式
三、原子模式二：兴趣新闻模式
四、原子模式三：数据新闻模式
第二节搜索引擎模式
一、概述
二、基本原理
第三节信息聚合模式
一、概述
二、基本原理
三、运营战略
第四节知识分享模式
一、概述
二、原子模式一：威客模式
三、原子模式二：维客模式
四、原子模式三：问答模式
第五节案例分析
一、兴趣新闻应用：Flipboard
二、离线阅读应用：Pocket
三、移动信息聚合应用：网易云阅读
第四章网络与新媒体的电子商务应用模式
第一节电子商务应用模式概述
一、基本概念
二、发展现状和趋势
三、原子模式类型
第二节B2B应用模式
一、概述
二、基本原理
第三节B2C应用模式
一、概述
二、基本原理
第四节020应用模式
一、概述
二、基本原理
第五节案例分析
一、O2O电子商务应用：Jetsetter
二、第三方消费点评应用：大众点评网
第五章网络与新媒体的交流互动应用模式
第一节即时通信模式
一、概述
二、原子模式一：即时消息模式
三、原子模式二：移动聊天模式
第二节个人空间模式
一、概述
二、原子模式一：微博客
三、原子模式二：轻博客
第三节社交网络服务（SNS）模式
一、概述
二、原子模式一：实名社交模式
三、原子模式二：位置社交模式
四、原子模式三：私密社交模式
五、原子模式五：阅后即焚社交模式
第四节案例分析
一、移动聊天应用：WhatsApp
二、虚拟世界社交网络应用：“第二人生”（SecondLife）
三、图片社交网络应用：“品趣志”（Pinterest）
四、位置社交网络应用：Foursquare
第六章网络与新媒体的娱乐应用模式
第一节网络游戏模式
一、概述
二、原子模式一：动作游戏模式
三、原子模式二：角色扮演游戏模式
四、原子模式三：冒险游戏模式
五、原子模式四：模拟游戏模式
六、原子模式五：益智类游戏模式
第二节网络视频应用模式
一、概述
二、原子模式一：视频平台模式
三、原子模式二：视频分享模式
第三节案例分析
一、免费硬核游戏应用：《亚瑟王国：北方之战》
二、儿童游戏应用：摩尔庄园
三、弹幕视频分享应用：哔哩哔哩
第七章网络与新媒体的应用形态战略
第一节应用（APP）形态概述
一、原生应用（NativeAPP）
二、页面应用（WebAPP）
第二节“HTML5”原理概述
一、“HTML5”简介
二、“HTML5"的新增元素
三、“HTML5”的新功能和新特性
第三节基于“HTML5”的应用形态战略
一、“HTML5”的应用现状
二、应用产品形态的战略选择
三、混合应用（HybridApp）：未来的产品形态
第八章网络与新媒体的应用入口战略
第一节应用商店
一、应用商店概述
二、应用商店发展现状和趋势
第二节浏览器
一、浏览器概述
二、浏览器的发展现状
三、浏览器的发展趋势
四、案例分析
第九章网络与新媒体的应用开放战略
第一节开放平台概述
一、开放平台的内涵
二、开放平台的目标和意义
三、开放平台的影响因素
四、开放平台的发展现状
第二节开放平台的内容战略
一、开放客户和产品数据
二、开放功能和服务
三、开放应用程序接口（APD和源代码
第三节开放平台的主要模式
一、应用视角的平台模式类型
二、运营主体视角的平台模式类型
后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>网络与新媒体应用模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java与模式
第一部分
第1章 模式的简史和形而上学
……
第二部分
第3章 软件的可维护性与可复用性
……
第三部分
第12章 简单工厂（Simple Factory）模式
……
第四部分
第22章 适配器（Adapter模式）
……
第五部分
第34章 不变（Immutable）模式
……
附录A 设计模式一览表
附录B UML图标及其Java实现一览表
附录C 中英术语对照表

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java与模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>互联网创业核心技术：构建可伸缩的web应用
1 核心概念  1
什么是伸缩性  2
从单一服务器到全球用户的 Web 架构演化  4
单一服务器  5
使用更强的服务器：垂直伸缩  6
服务分离  10
内容分发网络：静态内容的伸缩性  12
分散访问流量：水平伸缩  13
服务全球用户的伸缩性架构  16
数据中心基础设施架构概览  18
前端  19
Web 应用层  20
Web 服务层  20
附加组件  21
数据持久层  21
数据中心基础架构  22
应用架构概览  23
前端  24
Web 服务  25
支撑技术  29
小结  30
2 软件设计原则  31
简单  31
隐藏复杂与构建抽象  32
避免过度设计  33
尝试测试驱动开发  34
从软件设计的简化范例中学习  35
低耦合  36
促进低耦合  37
避免不必要的耦合  39
低耦合范式  40
不要重复自己（DRY）  41
复制粘贴代码  42
基于约定编程  43
画架构图  46
用例图  49
类图  50
模块图  51
单一职责  52
改善单一职责  52
单一职责的例子  53
开闭原则  53
依赖注入  55
控制反转（IOC）  57
为伸缩而设计  59
增加副本  60
功能分割  62
数据分片  63
自愈设计  65
小结  67
3 构建前端层  69
状态管理  70
管理 HTTP 会话  73
管理文件  77
管理其他类型的状态  80
可伸缩的前端组件  83
DNS  84
负载均衡器  85
Web 服务器  92
缓存  93
自动伸缩  94
部署案例  96
AWS 场景  97
私有数据中心  98
小结  101
4  Web 服务  102
Web 服务设计  102
Web 服务作为一种备用表示层  103
API 优先方式  105
务实的方式  107
Web 服务类型  108
以功能为中心的服务  109
以资源为中心的服务  111
伸缩 REST Web 服务  115
保持服务无状态  115
缓存服务响应  121
功能分割  124
小结  127
5  数据存储层  129
MySQL 伸缩性  130
复制  130
数据分区（分片）  142
NoSQL 伸缩性  157
最终一致性  160
快速恢复增加可用性  164
Cassandra 拓扑结构  166
小结  170
6  缓存  171
缓存命中率  171
基于 HTTP 的缓存  173
HTTP 缓存头  174
HTTP 缓存技术类型  179
伸缩 HTTP 缓存  185
缓存应用对象  188
对象缓存的一般类型  189
伸缩对象缓存  194
缓存的经验法则  198
缓存整个调用栈  198
用户间缓存重用  199
从哪儿开始使用缓存？  201
缓存失效的困难  201
小结  203
7  异步处理  204
核心概念  204
同步处理的例子  205
异步处理的例子  208
购物类比  211
消息队列  213
消息生产者  214
消息代理  215
消息消费者  216
消息协议  220
消息基础设施  221
消息队列的好处  224
实现异步处理  225
更好的伸缩性  226
平衡流量峰值  227
失败隔离和自我修复  228
解耦  229
消息队列相关的挑战  230
消息无序  230
消息重新入队列  233
竞态条件可能性增大  233
复杂度风险  234
消息队列有关的反模式  235
将消息队列当作 TCP 套接字  235
将消息队列当作数据库  235
耦合消息生产者和消费者  235
缺少坏消息处理  236
消息平台快速比较与选择  237
亚马逊简单队列服务  237
RabbitMQ  240
ActiveMQ  242
最后的比较说明  243
事件驱动架构介绍  245
请求/响应交互  246
直接队列交互  247
事件驱动交互  247
小结  250
8  数据搜索  252
索引介绍  252
数据建模  260
NoSQL 数据建模  260
宽列数据存储的例子  264
搜索引擎  271
搜索引擎介绍  272
使用专用搜索引擎  274
小结  275
9  伸缩性的其他维度  277
自动化实现生产力可伸缩  278
测试  278
构建与部署  280
监控与报警  285
日志聚合  289
个人可伸缩  291
加班不是一种伸缩性方案  291
自我管理  293
伸缩敏捷团队  300
增加人手  300
流程与创新  301
团结的文化  302
小结  303
A  推荐阅读  304
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>互联网创业核心技术：构建可伸缩的web应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaScript模式
前言
第1章 简介
模式
JavaScript：基本概念
ECMAScript 5
JSLint
Console
第2章 基本技巧
编写可维护的代码
尽量少用全局变量
for循环
for-in循环
不要增加内置的原型
switch模式
避免使用隐式类型转换
使用parseInt()的数值约定
编码约定
命名约定
编写注释
编写API文档
编写可读性强的代码
同行互查
在正式发布时精简代码
运行JSLint
小结
第3章 字面量和构造函数
对象字面量
自定义构造函数
强制使用new的模式
数组字面量
JSON
正则表达式字面量
基本值类型包装器
错误对象
小结
第4章 函数
背景
回调模式
返回函数
自定义函数
即时函数
即时对象初始化
初始化时分支
函数属性——备忘模式
配置对象
Curry
小结
第5章 对象创建模式
命名空间模式
声明依赖关系
私有属性和方法
模块模式
沙箱模式
静态成员
对象常量
链模式
method()方法
小结
第6章 代码复用模式
传统与现代继承模式的比较
使用类式继承时的预期结果
类式继承模式#1——默认模式
类式继承模式#2——借用构造函数
类式继承模式#3——借用和设置原型
类式继承模式#4——共享原型
类式继承模式#5——临时构造函数
Klass
原型继承
通过复制属性实现继承
借用方法
小结
第7章 设计模式
单体模式
工厂模式
迭代器模式
装饰者模式
策略模式
外观模式
代理模式
中介者模式
观察者模式
小结
第8章 DOM和浏览器模式
关注分离
DOM脚本
事件
长期运行脚本
远程脚本
配置JavaScript
载入策略
小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaScript模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计思维
簡介
如何獲取書中最重要的信息
思考階段
設計進程
第一階段——定義
第二階段——調研
第三階段——構思
第四階段——打樣
第五階段——精選
第六階段——實施
第七階段——總結
項目實例
調研
確定設計動機
搜集信息
目標群體
抽樣和反饋
構思
基本設計方向
構思的主題
靈感和參考
頭腦風暴法
價值
包容性
草圖
設計提案
改進
圖像
符號
借鑒
幽默
比擬
視覺隱喻
修飾
文字
文字和語言
字體的「面孔」
造型
比例
顏色
打樣
開發設計
「樣品」的分類
設計語彙
實施
規格
材料
精加工
媒體
尺寸
系列∕連續性
術語表
結語
致謝
聯繫方式
平面設計師的道德標準
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计思维
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入PHP：面向对象、模式与实践（第3版）
第一部分 介 绍
第1 章  PHP：设计与管理　　2
1.1  问题　　2
1.2  PHP 和其他语言　　3
1.3  关于本书　　5
1.3.1  对象　　　5
1.3.2   模式　　　5
1.3.3  实践　　　6
1.3.4  第3 版新增内容　　7
1.4  小结　　　7
第二部分  对 象
第2 章  PHP 与对象　　10
2.1  PHP 对象的偶然成功　　　10
2.1.1  最初：PHP/FI 　　10
2.1.2  语法糖：PHP 3　　10
2.1.3  一场静悄悄的革命：PHP 4　　11
2.1.4  拥抱改变：PHP 5　　 12
2.2  走向未来：PHP 6　　　13
2.3  拥护和疑虑：关于对象的争辩　　 13
2.4  小结　　　14
第3 章  对象基础　　　15
3.1  类和对象　　　15
3.1.1  编写第一个类　　15
3.1.2  第一个对象（或两个） 　　 16
3.2  设置类中的属性　　17
3.3  使用方法　　19
3.4  参数和类型　　21
3.4.1  基本类型　　22
3.4.2  获得提示：对象类型　　 24
3.5  继承　　26
3.5.1  继承问题　　26
3.5.2  使用继承　　30
3.5.3  public、private、protected：管理类的访问　　35
3.6  小结　　　 39
第4 章  高级特性　　 40
4.1  静态方法和属性　　40
4.2  常量属性　　43
4.3  抽象类　　44
4.4  接口　　46
4.5  延迟静态绑定：static 关键字　　 47
4.6  错误处理　　50
4.7  Final 类和方法　　56
4.8  使用拦截器　　57
4.9  析构方法　　 61
4.10  使用__clone()复制对象　　62
4.11  定义对象的字符串值　　64
4.12  回调、匿名函数和闭包　　 65
4.13  小结　　　69
第5 章  对象工具　　70
5.1  PHP 和包　　70
5.1.1  PHP 包和命名空间　　 70
5.1.2  自动加载　　78
5.2  类函数和对象函数　　79
5.2.1  查找类　　80
5.2.2  了解对象或类　　81
5.2.3  了解类中的方法　　 82
5.2.4  了解类属性　　 83
5.2.5  了解继承　　83
5.2.6  方法调用　　84
5.3  反射API　　85
5.3.1  入门　　85
5.3.2  开始行动　　86
5.3.3  检查类　　88
5.3.4  检查方法　　 89
5.3.5  检查方法参数　　 91
5.3.6  使用反射API　　　92
5.4  小结　　95
第6 章  对象与设计　　 96
6.1  代码设计的定义　　96
6.2  面向对象设计和过程式编程　　 97
6.2.1  职责　　100
6.2.2  内聚　　100
6.2.3  耦合　　101
6.2.4  正交　　101
6.3  选择类　　　101
6.4  多态　　　102
6.5  封装　　　 104
6.6  忘记细节　　105
6.7 4  个方向标　　105
6.7.1  代码重复　　106
6.7.2  类知道的太多　　106
6.7.3  万能的类　　 106
6.7.4  条件语句　　　106
6.8  UML　　106
6.8.1  类图　　 107
6.8.2  时序图　　111
6.9  小结　　　112
第三部分  模 式
第7 章  什么是设计模式？为何使用它们　　　114
7.1  什么是设计模式　　114
7.2  设计模式概览　　116
7.2.1  命名　　116
7.2.2  问题　　116
7.2.3  解决方案　　117
7.2.4  效果　　 117
7.3  《设计模式》格式　　117
7.4  为什么使用设计模式　　118
7.4.1  一个设计模式定义了一个问题 　　118
7.4.2  一个设计模式定义了一个解决方案　　118
7.4.3  设计模式是语言无关的 　　118
7.4.4  模式定义了一组词汇　　 118
7.4.5  模式是经过测试的　　 119
7.4.6  模式是为协作而设计的　　 119
7.4.7  设计模式促进良好设计　　 119
7.5  PHP 与设计模式　　120
7.6  小结　　120
第8 章  模式原则　　121
8.1  模式的启示　　121
8.2  组合与继承　　122
8.2.1  问题　　122
8.2.2  使用组合　　124
8.3  解耦　　127
8.3.1  问题　　127
8.3.2  降低耦合　　128
8.4  针对接口编程，而不是针对实现编程　　130
8.5  变化的概念　　131
8.6  父子关系　　132
8.7  模式　　132
8.7.1  用于生成对象的模式　　 133
8.7.2  用于组织对象和类的模式　　 133
8.7.3  面向任务的模式　　 133
8.7.4  企业模式　　133
8.7.5  数据库模式　　133
8.8  小结　　　 133
第9 章  生成对象　　134
9.1  生成对象的问题和解决方法　　 134
9.2  单例模式　　　138
9.2.1  问题　　　 138
9.2.2  实现　　 139
9.2.3  结果　　 141
9.3  工厂方法模式　　141
9.3.1  问题　　141
9.3.2  实现　　143
9.3.3  结果　　145
9.4  抽象工厂模式　　146
9.4.1  问题　　146
9.4.2  实现　　 147
9.4.3  结果　　148
9.4.4  原型模式　　150
9.4.5  问题　　150
9.4.6  实现　　151
9.5  某些模式的骗术　　153
9.6  小结　　154
第10 章  让面向对象编程更加灵活的模式　　155
10.1   构造可灵活创建对象的类　　 155
10.2  组合模式　　155
10.2.1  问题　　 156
10.2.2  实现　　158
10.2.3  效果　　161
10.2.4  组合模式小结　　164
10.3  装饰模式　　165
10.3.1  问题　　165
10.3.2  实现　　 167
10.3.3  效果　　170
10.4  外观模式　　 170
10.4.1  问题　　170
10.4.2  实现　　172
10.4.3  效果　　172
10.5  小结　　 173
第11 章  执行及描述任务　　174
11.1  解释器模式　　174
11.1.1  问题　　174
11.1.2  实现　　175
11.1.3  解释器的问题　　 182
11.2  策略模式　　183
11.2.1  问题　　 183
11.2.2  实现　　184
11.3  观察者模式　　187
11.4  访问者模式　　194
11.4.1  问题　　194
11.4.2  实现　　195
11.4.3  访问者模式的问题　　 199
11.5  命令模式　　200
11.5.1  问题　　200
11.5.2  实现　　 200
11.6  小结　　 204
第12 章  企业模式　　 205
12.1  架构概述　　205
12.1.1  模式　　 205
12.1.2  应用程序和层　　 206
12.2  企业架构之外的基础模式　　 208
12.2.1  注册表　　 208
12.2.2  实现　　209
12.3  表现层　　217
12.3.1  前端控制器　　 217
12.3.2  应用控制器　　227
12.3.3  页面控制器　　237
12.3.4  模板视图和视图助手　　 242
12.4  业务逻辑层　　 245
12.4.1  事务脚本　　245
12.4.2  领域模型　　249
12.5  小结　　252
第13 章  数据库模式　　253
13.1  数据层　　 253
13.2  数据映射器　　253
13.2.1  问题　　254
13.2.2  实现　　254
13.2.3  效果　　 265
13.3  标识映射　　266
13.3.1  问题　　266
13.3.2  实现　　266
13.3.3  效果　　269
13.4  工作单元　　 269
13.4.1  问题　　 269
13.4.2  实现　　270
13.4.3  效果　　274
13.4.4  延迟加载　　 274
13.4.5  问题　　274
13.4.6  实现　　 274
13.4.7  效果　　276
13.5  领域对象工厂　　276
13.5.1  问题　　276
13.5.2  实现　　277
13.5.3  效果　　278
13.6  标识对象　　279
13.6.1  问题　　279
13.6.2  实现　　 280
13.6.3  效果　　285
13.7  选择工厂和更新工厂模式　　 285
13.7.1  问题　　 285
13.7.2  实现　　285
13.7.3  效果　　288
13.8  数据映射器中剩下些什么　　 289
13.9  小结　　291
第四部分  实 践
第14 章  良好和糟糕的实践　　 294
14.1  超越代码　　294
14.2  借一个轮子　　295
14.3  合作愉快　　296
14.4  为你的代码插上双翼　　 297
14.5  文档　　　297
14.6  测试　　　 298
14.7  持续集成　　　299
14.8  小结　　　 300
第15 章  PEAR 和Pyrus　　　301
15.1  什么是PEAR　　　 301
15.2  了解Pyrus　　　302
15.3  安装PEAR 包　　　303
15.4  使用PEAR 包　　　306
15.5  创建自己的PEAR 包　　 311
15.5.1  package.xml　　　 311
15.5.2  package.xml 的组成　　 312
15.5.3  contents 元素　　 313
15.5.4  依赖　　　316
15.5.5  使用phprelease 进行灵活的自定义安装　　317
15.5.6  准备发布包　　　 318
15.5.7  创建自己的PEAR 频道　　 318
15.6  小结　　323
第16 章 用phpDocumentor 生成文档　　 324
16.1  为什么要使用文档　　　 324
16.2  安装　　325
16.3  生成文档　　　325
16.4  DocBlock 注释　　　 327
16.5  类的文档　　　 328
16.6  文件的文档　　　 330
16.7  属性的文档　　　 330
16.8  方法的文档　　　331
16.9  在文档中创建链接　　333
16.10  小结　　335
第17 章  使用Subversion 进行版本控制　　336
17.1  为什么要使用版本控制　　 336
17.2  获得Subversion 　　337
17.3  配置Subversion 代码库　　 338
17.4  开始项目　　　339
17.5  更新和提交　　 341
17.6  增加和删除文件及目录　　 344
17.6.1  添加文件　　344
17.6.2  删除文件　　345
17.6.3  添加目录　　345
17.6.4  删除目录　　345
17.7  标记和导出项目　　 345
17.7.1  标记项目　　 345
17.7.2  导出项目　　346
17.8  创建项目分支　　347
17.9  小结　　350
第18 章  使用PHPUnit 进行测试　　 351
18.1  功能测试与单元测试　　 351
18.2  手工测试　　352
18.3  引入PHPUnit　　 354
18.3.1  创建测试用例　　354
18.3.2  断言方法　　 355
18.3.3   测试异常　　356
18.3.4  运行测试套件　　357
18.3.5  约束　　358
18.3.6  模拟与桩　　360
18.3.7  失败是成功之母　　 362
18.4  编写Web 测试　　365
18.4.1  为测试重构Web 应用 　　366
18.4.2  简单的Web 测试　　 368
18.4.3  Selenium 　　370
18.5  警告　　　 374
18.6  小结　　　376
第19 章  用Phing 实现项目的自动构建　　 377
19.1  什么是Phing　　 377
19.2  获取和安装Phing　　　 378
19.3  编写build 文档　　　378
19.3.1  目标　　　380
19.3.2  属性　　　382
19.3.3  类型　　　387
19.3.4  任务　　　391
19.4  小结　　 394
第五部分  结 论
第20 章  持续集成　　 396
20.1  什么是持续集成　　396
20.2  CruiseControl 和phpUnderControl   　404
20.2.1  安装CruiseControl　　 404
20.2.2  安装phpUnderControl  　　406
20.2.3  安装项目　　 408
20.3  小结　　418
第21 章  对象、模式与实践　　 419
21.1  对象　　419
21.1.1  选择　　420
21.1.2  封装和委托　　420
21.1.3  解耦　　 420
21.1.4  复用性　　 421
21.1.5   美学　　421
21.2  模式　　421
21.2.1  模式给我们带来了什么 　　422
21.2.2  模式和设计原则　　 422
21.3  实践　　 424
21.3.1  测试　　424
21.3.2  文档　　 424
21.3.3  版本控制　　425
21.3.4  自动构建　　 425
21.3.5  持续集成　　425
21.3.6  我们还遗漏了什么　　 425
21.4  小结　　 426
第六部分  附 录
附录A  参考文献　　428
附录B  简单的解析器　　431
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入PHP：面向对象、模式与实践（第3版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入浅出面向对象分析与设计（中文版）
介绍1  伟大软件由此开始：良好应用程序的基石2  给客户所需之物：收集需求3  山可移，此情永不渝……现在，情况有变：需求变更4  将你的软件带进现实世界：分析5  第一部分：诸行无常——良好的设计  插曲：OO大灾难  第二部分：给你的软件30分钟的伸展操——灵活的软件6  “我的名字是Art Vandelay”：解决真正的大问题7  为混乱带来次序：架构8  原创性被高估：设计原则9  软件终究为客户服务：重复与测试10  组合在一起：OOA&D生命周期  附录1：本书遗珠  附录2：欢迎光临对象村
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入浅出面向对象分析与设计（中文版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入PHP
第一部分 介绍
第1章 PHP：设计与管理 2
1.1 问题 2
1.2 PHP和其他语言 3
1.3 关于本书 5
1.3.1 对象 5
1.3.2 模式 5
1.3.3 实践 6
1.3.4 本书第2版中的新内容 7
1.4 小结 7
第二部分 对象
第2章 PHP与对象 10
2.1 PHP对象的偶然成功 10
2.1.1 最初：PHP/FI 10
2.1.2 语法糖：PHP 3 10
2.1.3 一场静悄悄的革命：PHP 4 11
2.1.4 拥抱改变：PHP 5 12
2.2 走向未来：PHP 6 12
2.3 拥护和疑虑：关于对象的争辩 13
2.4 小结 13
第3章 对象基础 14
3.1 类和对象 14
3.1.1 编写第一个类 14
3.1.2 第一个对象（或两个） 15
3.2 设置类中的属性 15
3.3 使用方法 18
3.4 参数和类型 20
3.4.1 基本类型 20
3.4.2 获得提示：对象类型 23
3.5 继承 24
3.5.1 继承问题 24
3.5.2 使用继承 28
3.5.3 public、private、protected：管理类的访问 32
3.6 小结 35
第4章 高级特性 36
4.1 静态方法和属性 36
4.2 常量属性 39
4.3 抽象类 39
4.4 接口 41
4.5 错误处理 43
4.6 Final类和方法 48
4.7 使用拦截器 49
4.8 析构方法 53
4.9 使用__clone()复制对象 54
4.10 定义对象的字符串值 56
4.11 小结 57
第5章 对象工具 58
5.1 PHP和包 58
5.1.1 PHP和命名空间 60
5.1.2 包含路径 62
5.1.3 自动加载 63
5.2 类函数和对象函数 64
5.2.1 查找类 64
5.2.2 了解对象或类 65
5.2.3 了解类中的方法 66
5.2.4 了解类属性 67
5.2.5 了解继承 67
5.2.6 方法调用 68
5.3 反射API 69
5.3.1 入门 69
5.3.2 开始行动 69
5.3.3 检查类 71
5.3.4 检查方法 72
5.3.5 检查方法参数 74
5.3.6 使用反射API 75
5.4 小结 78
第6章 对象与设计 79
6.1 代码设计的定义 79
6.2 面向对象设计和过程式编程 80
6.2.1 职责 83
6.2.2 内聚 83
6.2.3 耦合 83
6.2.4 正交 84
6.3 选择类 84
6.4 多态 85
6.5 封装 86
6.6 忘记细节 87
6.7 四个方向标 88
6.7.1 代码重复 88
6.7.2 类知道的太多 88
6.7.3 万能的类 88
6.7.4 条件语句 89
6.8 UML 89
6.8.1 类图 89
6.8.2 时序图 94
6.9 小结 95
第三部分 模式
第7章 什么是设计模式？为何使用它们 98
7.1 什么是设计模式 98
7.2 设计模式概览 100
7.2.1 命名 100
7.2.2 问题 100
7.2.3 解决方案 101
7.2.4 效果 101
7.3 《设计模式》格式 101
7.4 为什么使用设计模式 102
7.4.1 一个设计模式定义了一个问题 102
7.4.2 一个设计模式定义了一个解决方案 102
7.4.3 设计模式是语言无关的 102
7.4.4 模式定义了一组词汇 102
7.4.5 模式是经过测试的 103
7.4.6 模式是为协作而设计的 103
7.4.7 设计模式促进良好设计 103
7.5 PHP与设计模式 103
7.6 小结 104
第8章 模式原则 105
8.1 模式的启示 105
8.2 组合与继承 106
8.2.1 问题 106
8.2.2 使用组合 108
8.3 解耦 110
8.3.1 问题 110
8.3.2 降低耦合 111
8.4 针对接口编程，而不是针对实现编程 112
8.5 变化的概念 113
8.6 父子关系 113
8.7 模式 114
8.7.1 用于生成对象的模式 114
8.7.2 用于组织对象和类的模式 114
8.7.3 面向任务的模式 114
8.7.4 企业模式 114
8.7.5 数据库模式 114
8.8 小结 115
第9章 生成对象 116
9.1 生成对象的问题和解决方法 116
9.2 单例模式 119
9.2.1 问题 120
9.2.2 实现 120
9.2.3 结果 122
9.3 工厂方法模式 122
9.3.1 问题 122
9.3.2 实现 125
9.3.3 结果 126
9.4 抽象工厂模式 127
9.4.1 问题 127
9.4.2 实现 128
9.4.3 结果 129
9.4.4 原型模式 131
9.4.5 问题 132
9.4.6 实现 133
9.5 某些模式的骗术 134
9.6 小结 136
第10章 让面向对象编程更加灵活的模式 137
10.1 构造可灵活创建对象的类 137
10.2 组合模式 137
10.2.1 问题 138
10.2.2 实现 139
10.2.3 效果 143
10.2.4 组合模式小结 146
10.3 装饰模式 146
10.3.1 问题 146
10.3.2 实现 148
10.3.3 效果 151
10.4 外观模式 151
10.4.1 问题 152
10.4.2 实现 153
10.4.3 效果 153
10.5 小结 154
第11章 执行及描述任务 155
11.1 解释器模式 155
11.1.1 问题 155
11.1.2 实现 156
11.1.3 解释器的问题 162
11.2 策略模式 163
11.2.1 问题 163
11.2.2 实现 164
11.3 观察者模式 167
11.4 访问者模式 173
11.4.1 问题 174
11.4.2 实现 175
11.4.3 访问者模式的问题 178
11.5 命令模式 179
11.5.1 问题 179
11.5.2 实现 179
11.6 小结 183
第12章 企业模式 184
12.1 架构概述 184
12.1.1 模式 184
12.1.2 应用程序和层 185
12.2 企业架构之外的基础模式 187
12.2.1 注册表 187
12.2.2 实现 188
12.3 表现层 196
12.3.1 前端控制器 196
12.3.2 应用控制器 205
12.3.3 页面控制器 214
12.3.4 模板视图和视图助手 218
12.4 业务逻辑层 220
12.4.1 事务脚本 221
12.4.2 领域模型 225
12.5 小结 227
第13章 数据库模式 228
13.1 数据层 228
13.2 数据映射器 228
13.2.1 问题 229
13.2.2 实现 229
13.2.3 效果 239
13.3 标识映射 239
13.3.1 问题 240
13.3.2 实现 240
13.3.3 效果 242
13.4 工作单元 243
13.4.1 问题 243
13.4.2 实现 243
13.4.3 效果 246
13.4.4 延迟加载 247
13.4.5 问题 247
13.4.6 实现 247
13.4.7 效果 249
13.5 领域对象工厂 249
13.5.1 问题 249
13.5.2 实现 249
13.5.3 效果 250
13.6 标识对象 252
13.6.1 问题 252
13.6.2 实现 252
13.6.3 效果 256
13.7 选择工厂和更新工厂模式 257
13.7.1 问题 257
13.7.2 实现 257
13.7.3 效果 259
13.8 数据映射器中剩下些什么 260
13.9 小结 262
第四部分 实践
第14章 良好和糟糕的实践 264
14.1 超越代码 264
14.2 借一个轮子 264
14.3 合作愉快 266
14.4 为你的代码插上双翼 267
14.5 文档 267
14.6 测试 268
14.7 小结 269
第15章 PEAR 270
15.1 什么是PEAR 270
15.2 安装PEAR包 271
15.3 使用PEAR包 273
15.4 创建自己的PEAR包 278
15.4.1 package.xml 278
15.4.2 package.xml的组成元素 278
15.4.3 contents元素 279
15.4.4 依赖 282
15.4.5 使用phprelease进行灵活的自定义安装 283
15.4.6 发布包 284
15.4.7 创建自己的PEAR频道 284
15.5 小结 288
第16章 用phpDocumentor生成文档 289
16.1 为什么要使用文档 289
16.2 安装 290
16.3 生成文档 290
16.4 DocBlock注释 292
16.5 类的文档 293
16.6 文件的文档 294
16.7 属性的文档 295
16.8 方法的文档 296
16.9 在文档中创建链接 297
16.10 小结 300
第17章 使用CVS进行版本控制 301
17.1 为什么要使用版本控制 301
17.2 获得CVS 302
17.3 配置CVS代码库 303
17.3.1 创建代码库 303
17.3.2 配置客户端 304
17.3.3 在多台机器上运行CVS 304
17.4 开始项目 305
17.5 更新和提交 307
17.6 增加和删除文件及目录 309
17.6.1 添加文件 309
17.6.2 删除文件 310
17.6.3 添加目录 310
17.6.4 添加二进制文件 311
17.6.5 删除目录 311
17.7 标记和导出项目 312
17.7.1 标记项目 313
17.7.2 通过标签获取项目代码 313
17.7.3 导出项目 314
17.8 创建项目分支 314
17.9 小结 317
第18章 使用PHPUnit进行测试 318
18.1 功能测试与单元测试 318
18.2 手工测试 319
18.3 引入PHPUnit 321
18.3.1 创建测试用例 321
18.3.2 断言方法 322
18.3.3 测试异常 323
18.3.4 运行测试套件 324
18.3.5 约束 326
18.3.6 模拟与桩 328
18.3.7 失败是成功之母 331
18.4 警告 333
18.5 小结 335
第19章 用Phing实现项目的自动 构建 336
19.1 什么是Phing 336
19.2 获取和安装Phing 337
19.3 编写build文档 337
19.3.1 目标 339
19.3.2 属性 340
19.3.3 类型 345
19.3.4 任务 348
19.4 小结 352
第五部分 结论
第20章 对象、模式与实践 354
20.1 对象 354
20.1.1 选择 355
20.1.2 封装和委托 355
20.1.3 解耦 355
20.1.4 复用性 356
20.1.5 美学 356
20.2 模式 356
20.2.1 模式给我们带来了什么 357
20.2.2 模式和设计原则 357
20.3 实践 359
20.3.1 测试 359
20.3.2 文档 359
20.3.3 版本控制 360
20.3.4 自动构建 360
20.3.5 我们还遗漏了什么 360
20.4 小结 361
第六部分 附录
附录A 参考文献 364
附录B 简单的解析器 366
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入PHP
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向模式的软件架构 卷4：分布式计算的模式语言
第一部分　概念
第1章　模式与模式语言 2
1.1　模式 2
1.2　模式内幕 3
1.2.1　问题的环境 3
1.2.2　驱动因素：所有模式的核心 4
1.2.3　解决方案与结果 4
1.2.4　模式命名 4
1.2.5　模式表现形式概述 5
1.3　模式的关系 5
1.3.1　模式的互补 5
1.3.2　模式的组合 6
1.3.3　模式故事 6
1.3.4　模式序列 7
1.4　模式语言 7
1.4.1　从模式序列到模式语言 7
1.4.2　展现和使用模式语言 7
1.5　模式的连接 8
第2章　分布式系统 9
2.1　分布式的优点 9
2.2　分布式的挑战 11
2.3　用以支持分布式的技术 12
2.3.1　分布式对象计算中间件 13
2.3.2　组件中间件 14
2.3.3　发布/订阅中间件和面向消息的中间件 15
2.3.4　面向服务架构和Web服务 16
2.4　中间件技术的局限性 17
第3章　模式语言 18
3.1　意图、范畴和对象 18
3.2　起源 18
3.3　结构和内容 19
3.4　模式的表现 24
3.5　实际应用 26
第二部分　模式故事
第4章　仓库管理流程控制 33
4.1　系统范畴 33
4.2　仓库管理流程控制 34
第5章　基线架构 37
5.1　架构环境 37
5.2　划分大泥球 38
5.3　层次分解 38
5.4　访问领域对象功能 40
5.5　网络桥接 41
5.6　分离用户界面 43
5.7　功能分布 45
5.8　支持并发的领域对象访问 47
5.9　获得可扩展的并发性 48
5.10　将面向对象与关系型数据库连接起来 49
5.11　领域对象的运行时配置 50
5.12　基线架构总结 51
第6章　通信中间件 54
6.1　分布式系统的中间件架构 54
6.2　对中间件的内部设计进行结构化 57
6.3　封装底层系统机制 58
6.4　分离ORB核心事件 59
6.5　ORB连接管理 61
6.6　提高ORB的可伸缩性 63
6.7　实现同步请求队列 65
6.8　可互换的内部ORB机制 66
6.9　管理ORB策略 68
6.10　ORB动态配置 69
6.11　通信中间件总结 71
第7章　仓库拓扑 74
7.1　仓库拓扑基线 74
7.2　表现层次化的存储结构 74
7.3　存储结构导航 77
7.4　存储属性建模 78
7.5　不同的存储单元行为 79
7.6　实现全局功能 81
7.7　遍历仓库拓扑 81
7.8　支持控制流扩展 83
7.9　连接数据库 84
7.10　维护内存中的存储单元数据 85
7.11　配置仓库拓扑 86
7.12　细述显式接口 88
7.13　仓库拓扑总结 89
第8章　模式故事背后的故事 91
第三部分　模式语言
第9章　从混沌到结构 97
9.1　Domain Model** 106
9.2　Layers** 108
9.3　Model-View-Controller** 109
9.4　Presentation-Abstraction-Control 111
9.5　Microkernel** 113
9.6　Reflection* 114
9.7　Pipes and Filters** 116
9.8　Shared Repository** 117
9.9　Blackboard 119
9.10　Domain Object** 121
第10章　分布式基础设施 123
10.1　Messaging** 129
10.2　Message Channel** 130
10.3　Message Endpoint** 132
10.4　Message Translator** 133
10.5　Message Router** 134
10.6　Publisher-Subscriber** 135
10.7　Broker** 137
10.8　Client Proxy** 139
10.9　Requestor** 140
10.10　Invoker** 142
10.11　Client Request Handler** 143
10.12　Server Request Handler** 144
第11章　事件分离和分发 147
11.1　Reactor** 150
11.2　Proactor* 152
11.3　Acceptor-Connector** 154
11.4　Asynchronous Completion Token** 155
第12章　接口划分 157
12.1　Explicit Interface** 163
12.2　Extension Interface** 165
12.3　Introspective Interface** 166
12.4　Dynamic Invocation Interface* 167
12.5　Proxy** 169
12.6　Business Delegate** 170
12.7　Facade** 171
12.8　Combined Method** 172
12.9　Iterator** 173
12.10　Enumeration Methond** 174
12.11　Batch Method** 175
第13章　组件划分 177
13.1　Encapsulated Implementation** 181
13.2　Whole-Part** 183
13.3　Composite** 185
13.4　Master-Slave** 186
13.5　Half-Object plus Protocol** 188
13.6　Replicated Component Group** 189
第14章　应用控制 191
14.1　Page Controller** 196
14.2　Front Controller** 197
14.3　Application Controller** 198
14.4　Command Processor** 199
14.5　Template View** 200
14.6　Transform View** 201
14.7　Firewall Proxy** 202
14.8　Authorization** 204
第15章　并发 206
15.1　Half-Sync/Half-Async** 209
15.2　Leader/Followers** 211
15.3　Active Object** 212
15.4　Monitor Object** 214
第16章　同步 216
16.1　Guarded Suspension** 221
16.2　Future** 223
16.3　Thread-Safe Interface* 224
16.4　Double-Checked Locking 225
16.5　Strategized Locking** 226
16.6　Scoped Locking** 227
16.7　Thread-Specific Storage 228
16.8　Copied Value** 230
16.9　Immutable Value** 231
第17章　对象间的交互 233
17.1　Observer** 237
17.2　Double Dispatch ** 238
17.3　Mediator* 239
17.4　Command** 240
17.5　Memento** 242
17.6　Context Object** 243
17.7　Data Transfer Object** 244
17.8　Message** 245
第18章　适配与扩展 247
18.1　Bridge** 255
18.2　Object Adapter** 256
18.3　Chain of Responsibility* 257
18.4　Interpreter 258
18.5　Interceptor** 260
18.6　Visitor** 261
18.7　Decorator 262
18.8　Execute-Around Object** 264
18.9　Template Method* 265
18.10　Strategy** 266
18.11　Null Object** 267
18.12　Wrapper Facade** 269
18.13　Declarative Component Configuration* 270
第19章　模态行为 272
19.1　Objects for States* 274
19.2　Methods for States* 275
19.3　Collections for States* 276
第20章　资源管理 278
20.1　Container* 288
20.2　Component Configurator* 289
20.3　Object Manager** 291
20.4　Lookup** 292
20.5　Virtual Proxy** 294
20.6　Lifecycle Callback** 295
20.7　Task Coordinator* 296
20.8　Resource Pool** 298
20.9　Resource Cache** 299
20.10　Lazy Acquisition** 300
20.11　Eager Acquisition** 301
20.12　Partial Acquisition* 303
20.13　Activator** 304
20.14　Evictor** 305
20.15　Leasing** 306
20.16　Automated Garbage Collection** 307
20.17　Counting Handles** 309
20.18　Abstract Factory** 311
20.19　Builder* 312
20.20　Factory Method** 313
20.21　Disposal Method** 314
第21章　数据库访问 316
21.1　Database Access Layer** 318
21.2　Data Mapper** 320
21.3　Row Data Gateway** 321
21.4　Table Data Gateway ** 323
21.5　Active Record 324
第22章　最后的思考 326
术语表 327
参考书目 340
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向模式的软件架构 卷4：分布式计算的模式语言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向模式的软件架构 第1卷
目 　录
第1章 　模式　　1
1.1 　模式是什么　　1
1.2 　模式之所以为模式　　5
1.3 　模式类型　　7
1.3.1 　架构模式　　8
1.3.2 　设计模式　　8
1.3.3 　成例　　9
1.3.4 　模式分类在软件开发中的用途　　10
1.4 　模式之间的关系　　1
1.5 　模式的描述　　13
1.6 　模式与软件架构　　5
1.6.1 　作为思维构件的模式　　15
1.6.2 　打造异质架构　　16
1.6.3 　模式与方法　　16
1.6.4 　实现模式　　6
1.7 　总结　　17
第2章 　架构模式　　18
2.1 　导言　　18
2.2 　从混乱到有序　　19
2.2.1 　Layers 模式　　21
2.2.2 　Pipes and Filters 模式　　34
2.2.3 　Blackboard 模式　　46
2.3 　分布式系统　　62
2.4 　交互式系统　　78
2.4.1 　Model-View-Controller 模式　　79
2.4.2 　Presentation-Abstraction-Control 模式　　93
2.5 　可适应系统　　109
2.5.1 　Microkernel 模式　　110
2.5.2 　Reflection 模式　　124
第3章 　设计模式　　143
3.1 　导言　　143
3.2 　结构分解模式　　144
3.3 　工作组织模式　　157
3.4 　访问控制　　169
3.5 　管理模式　　178
3.5.1 　Command Processor 模式　　179
3.5.2 　View Handler 模式　　188
3.6 　通信模式　　198
3.6.1 　Forwarder-Receiver 模式　　199
3.6.2 　Client-Dispatcher-Server 模式　　209
3.6.3 　Publisher-Subscriber 模式　　219
第4章 　成例　　223
4.1 　导言　　223
4.2 　成例的用途　　224
4.3 　成例与风格　　224
4.4 　到哪里去寻找成例　　226
第5章 　模式系统　　233
5.1 　模式系统是什么　　233
5.2 　模式分类　　235
5.2.1 　模式类别　　235
5.2.2 　问题类别　　235
5.2.3 　分类方案　　236
5.2.4 　比较　　237
5.3 　选择模式　　238
5.4 　作为实现指南的模式系统　　239
5.5 　模式系统的演化　　241
5.5.1 　模式描述的演化　　242
5.5.2 　创意写作工坊式审阅　　242
5.5.3 　模式发掘　　243
5.5.4 　添加新模式　　243
5.5.5 　删除过时的模式　　244
5.5.6 　扩展组织方案　　244
5.6 　总结　　246
第6章 　模式与软件架构　　247
6.1 　导言　　247
6.1.1 　软件架构　　247
6.1.2 　组件　　248
6.1.3 　关系　　249
6.1.4 　视图　　250
6.1.5 　功能特征和非功能特征　　251
6.1.6 　软件设计　　251
6.1.7 　小结　　252
6.2 　软件架构中的模式　　252
6.2.1 　开发方法　　253
6.2.2 　开发流程　　253
6.2.3 　架构风格　　254
6.2.4 　框架　　255
6.3 　软件架构支持技术　　256
6.3.1 　抽象　　256
6.3.2 　封装　　257
6.3.3 　信息隐藏　　257
6.3.4 　模块化　　257
6.3.5 　分离关注点　　257
6.3.6 　耦合与内聚　　258
6.3.7 　充分、完整、简单　　258
6.3.8 　策略与实现分离　　258
6.3.9 　接口与实现分离　　259
6.3.10 　单个引用点　　259
6.3.11 　分而治之　　259
6.3.12 　小结　　259
6.4 　软件架构的非功能特征　　260
6.4.1 　可修改性　　260
6.4.2 　互操作性　　261
6.4.3 　效率　　262
6.4.4 　可靠性　　262
6.4.5 　可测试性　　262
6.4.6 　可重用性　　263
6.5 　总结　　264
第7章 　模式界　　265
7.1 　起源　　265
7.2 　领军人物及其成果　　266
7.3 　模式界　　267
第8章 　模式的发展方向　　269
8.1 　模式挖掘　　269
8.1.1 　软件架构模式　　269
8.1.2 　组织模式　　270
8.1.3 　领域特定的模式　　270
8.1.4 　模式语言　　271
8.2 　模式的组织和模式索引　　271
8.3 　方法和工具　　272
8.4 　算法、数据结构和模式　　273
8.5 　模式的规范化　　273
8.6 　结语　　274
表示法　　275
术语表　　279
参考文献　　284
索引　　296
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向模式的软件架构 第1卷
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>领域驱动设计精粹
第1章  DDD对我而言  1
DDD很难掌握吗  2
优秀设计、糟糕设计和有效设计  3
战略设计  8
战术设计  9
学习过程与知识提炼  10
让我们开始吧!  11
第2章  运用限界上下文与通用语言进行战略设计  13
领域专家和业务驱动  20
案例分析  24
战略设计是必要的根基  28
在质疑中统一  32
发展通用语言  38
应用场景  42
如何持续  45
架构  46
本章小结  50
第3章  运用子域进行战略设计  51
什么是子域  52
子域类型  53
应对复杂性  54
本章小结  56
第4章  运用上下文映射进行战略设计  57
映射的种类  60
合作关系  60
共享内核  61
客户—供应商  62
跟随者  63
防腐层  64
开放主机服务  65
已发布语言  65
各行其道  66
大泥球  67
善用上下文映射  69
基于SOAP的RPC  70
RESTful HTTP  72
消息机制  74
上下文映射示例  79
本章小结  83
第5章  运用聚合进行战术设计  85
为什么使用它  86
聚合的经验法则  91
规则一：在聚合边界内保护业务规则不变性  92
规则二：聚合要设计得小巧  93
规则三：只能通过标识符引用其他聚合  95
规则四：利用最终一致性更新其他聚合  96
建立聚合模型  99
慎重选择抽象级别  104
大小适中的聚合  106
可测试的单元  108
本章小结  108
第6章  运用领域事件进行战术设计  111
设计、实现并运用领域事件  113
事件溯源  119
本章小结  121
第7章  加速和管理工具  123
事件风暴  124
其他工具  134
在敏捷项目中管理DDD  135
运用SWOT分析法  137
建模Spike和建模债务  139
任务识别与工作量估算  140
限制建模时间  143
如何实施  144
和领域专家打交道  145
本章小结  147
参考文献  148
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>领域驱动设计精粹
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Ruby元编程（第2版）
第一部分  Ruby元编程 1
第1章  元这个字眼 3
1.1  鬼城与自由市场 3
1.2  程序员Bob的故事 4
1.3  元编程和Ruby 7
第2章  星期一：对象模型 11
2.1  打开类 11
2.2  类的真相 16
2.3  小测验：缺失的连接线 26
2.4  调用方法时发生了什么？ 27
2.5  小测验：混乱的模块 39
2.6  对象模型小结 42
第3章  星期二：方法 45
3.1  代码繁复的问题 46
3.2  动态方法 48
3.3  method_missing方法 55
3.4  小测验：消灭Bug 64
3.5  白板类 66
3.6  小结 69
第4章  星期三：代码块 73
4.1  学习代码块 73
4.2  小测验：Ruby的#符号 75
4.3  代码块是闭包 77
4.4  instance_eval方法 84
4.5  可调用对象 88
4.6  编写领域专属语言（DSL） 96
4.7  小测验：改良的DSL 98
4.8  小结 102
第5章  星期四：类定义 105
5.1  揭秘类定义 106
5.2  小测验：Taboo类 112
5.3  单件方法 113
5.4  单件类 118
5.5  小测验：模块的麻烦 129
5.6  方法包装器 131
5.7  小测验：打破数学规律 136
5.8  小结 137
第6章  星期五：编写代码的代码 139
6.1  通向周末的编程之路 139
6.2  Kernel#eval方法 141
6.3  小测验：校验过的属性（第一步） 150
6.4  小测验：校验过的属性（第二步） 153
6.5  小测验：校验过的属性（第三步） 154
6.6  小测验：校验过的属性（第四步） 156
6.7  钩子方法 157
6.8  小测验：校验过的属性（第五步） 161
6.9  小结 162
第7章  尾声 163
第二部分  Rails中的元编程 165
第8章  准备Rails之旅 167
8.1  Ruby on Rails 167
8.2  安装Rails 168
8.3  Rails源代码 168
第9章  Active Record的设计 171
9.1  简短的Active Record示例 171
9.2  Active Record的组成 172
9.3  经验之谈 176
第10章  Active Support的Concern模块 179
10.1  Concern模块出现之前 179
10.2  ActiveSupport::Concern模块 183
10.3  经验之谈 188
第11章  alias_method_chain方法沉浮录 189
11.1  alias_method_chain方法的兴起 189
11.2  alias_method_chain方法的衰亡 193
11.3  经验之谈 196
第12章  属性方法的发展 199
12.1  属性方法实战 199
12.2  属性方法的发展史 200
12.3  经验之谈 210
第13章  最后的思考 213
元编程不过是编程 213
第三部分  附录 215
附录A  常见惯用法 217
A.1  拟态方法 217
A.2  空指针保护 219
A.3  Self Yield 222
A.4  Symbol#to_proc方法 224
附录B  领域专属语言 227
B.1  关于领域专属语言 227
B.2  内部和外部领域专属语言 229
B.3  领域专属语言和元编程 230
附录C  法术手册 231
索引 243
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Ruby元编程（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>游戏编程模式
第1篇　概述
第1章　架构，性能和游戏　3
1．1　什么是软件架构　3
1．1．1　什么是好的软件架构　3
1．1．2　你如何做出改变　4
1．1．3　我们如何从解耦中受益　5
1．2　有什么代价　5
1．3　性能和速度　6
1．4　坏代码中的好代码　7
1．5　寻求平衡　8
1．6　简单性　9
1．7　准备出发　9
第2篇　再探设计模式
第2章　命令模式　13
2．1　配置输入　14
2．2　关于角色的说明　16
2．3　撤销和重做　18
2．4　类风格化还是函数风格化　21
2．5　参考　22
第3章　享元模式　23
3．1　森林之树　23
3．2　一千个实例　25
3．3　享元模式　26
3．4　扎根之地　26
3．5　性能表现如何　30
3．6　参考　31
第4章　观察者模式　33
4．1　解锁成就　33
4．2　这一切是怎么工作的　34
4．2．1　观察者　35
4．2．2　被观察者　35
4．2．3　可被观察的物理模块　37
4．3　它太慢了　38
4．4　太多的动态内存分配　39
4．4．1　链式观察者　39
4．4．2　链表节点池　42
4．5　余下的问题　43
4．5．1　销毁被观察者和观察者　43
4．5．2　不用担心，我们有GC　44
4．5．3　接下来呢　44
4．6　观察者模式的现状　45
4．7　观察者模式的未来　46
第5章　原型模式　47
5．1　原型设计模式　47
5．1．1　原型模式效果如何　50
5．1．2　生成器函数　51
5．1．3　模板　51
5．1．4　头等公民类型（First-class types）　52
5．2　原型语言范式　52
5．2．1　Self 语言　53
5．2．2　结果如何　54
5．2．3　JavaScript如何　55
5．3　原型数据建模　57
第6章　单例模式　61
6．1　单例模式　61
6．1．1　确保一个类只有一个实例　61
6．1．2　提供一个全局指针以访问唯一实例　62
6．2　使用情境　63
6．3　后悔使用单例的原因　65
6．3．1　它是一个全局变量　65
6．3．2　它是个画蛇添足的解决方案　66
6．3．3　延迟初始化剥离了你的控制　67
6．4　那么我们该怎么做　68
6．4．1　看你究竟是否需要类　68
6．4．2　将类限制为单一实例　70
6．4．3　为实例提供便捷的访问方式　71
6．5　剩下的问题　73
第7章　状态模式　75
7．1　我们曾经相遇过　75
7．2　救星：有限状态机　78
7．3　枚举和分支　79
7．4　状态模式　82
7．4．1　一个状态接口　82
7．4．2　为每一个状态定义一个类　83
7．4．3　状态委托　84
7．5　状态对象应该放在哪里呢　84
7．5．1　静态状态　84
7．5．2　实例化状态　85
7．6　进入状态和退出状态的行为　86
7．7　有什么收获吗　88
7．8　并发状态机　88
7．9　层次状态机　89
7．10　下推自动机　91
7．11　现在知道它们有多有用了吧　92
第3篇　序列型模式
第8章　双缓冲　95
8．1　动机　95
8．1．1　计算机图形系统是如何工作的（概述）　95
8．1．2　第一幕，第一场　96
8．1．3　回到图形上　97
8．2　模式　98
8．3　使用情境　98
8．4　注意事项　98
8．4．1　交换本身需要时间　98
8．4．2　我们必须有两份缓冲区　99
8．5　示例代码　99
8．5．1　并非只针对图形　102
8．5．2　人工非智能　102
8．5．3　缓存这些巴掌　106
8．6　设计决策　107
8．6．1　缓冲区如何交换　107
8．6．2　缓冲区的粒度如何　109
8．7　参考　110
第9章　游戏循环　111
9．1　动机　111
9．1．1　CPU探秘　111
9．1．2　事件循环　112
9．1．3　时间之外的世界　113
9．1．4　秒的长短　113
9．2　模式　114
9．3　使用情境　114
9．4　使用须知　114
9．5　示例代码　115
9．5．1　跑，能跑多快就跑多快　115
9．5．2　小睡一会儿　115
9．5．3　小改动，大进步　116
9．5．4　把时间追回来　118
9．5．5　留在两帧之间　119
9．6　设计决策　120
9．6．1　谁来控制游戏循环，你还是平台　121
9．6．2　你如何解决能量耗损　121
9．6．3　如何控制游戏速度　122
9．7　参考　123
第10章　更新方法　125
10．1　动机　125
10．2　模式　127
10．3　使用情境　128
10．4　使用须知　128
10．4．1　将代码划分至单帧之中使其变得更加复杂　128
10．4．2　你需要在每帧结束前存储游戏状态以便下一帧继续　128
10．4．3　所有对象都在每帧进行模拟，但并非真正同步　129
10．4．4　在更新期间修改对象列表时必须谨慎　129
10．5　示例代码　130
10．5．1　子类化实体　132
10．5．2　定义实体　132
10．5．3　逝去的时间　135
10．6　设计决策　136
10．6．1　update方法依存于何类中　136
10．6．2　那些未被利用的对象该如何处理　137
10．7　参考　137
第4篇　行为型模式
第11章　字节码　141
11．1　动机　141
11．1．1　魔法大战　141
11．1．2　先数据后编码　142
11．1．3　解释器模式　142
11．1．4　虚拟机器码　145
11．2　字节码模式　145
11．3　使用情境　145
11．4　使用须知　146
11．4．1　你需要个前端界面　146
11．4．2　你会想念调试器的　147
11．5　示例　147
11．5．1　法术API　147
11．5．2　法术指令集　148
11．5．3　栈机　149
11．5．4　组合就能得到行为　153
11．5．5　一个虚拟机　155
11．5．6　语法转换工具　155
11．6　设计决策　157
11．6．1　指令如何访问堆栈　157
11．6．2　应该有哪些指令　158
11．6．3　值应当如何表示　158
11．6．4　如何生成字节码　161
11．7　参考　162
第12章　子类沙盒　163
12．1　动机　163
12．2　沙盒模式　165
12．3　使用情境　165
12．4　使用须知　165
12．5　示例　166
12．6　设计决策　168
12．6．1　需要提供什么操作　168
12．6．2　是直接提供函数，还是由包含它们的对象提供　169
12．6．3　基类如何获取其所需的状态　170
12．7　参考　173
第13章　类型对象　175
13．1　动机　175
13．1．1　经典的面向对象方案　175
13．1．2　一个类的类　177
13．2　类型对象模式　178
13．3　使用情境　179
13．4　使用须知　179
13．4．1　类型对象必须手动跟踪　179
13．4．2　为每个类型定义行为更困难　179
13．5　示例　180
13．5．1　构造函数：让类型对象更加像类型　181
13．5．2　通过继承共享数据　183
13．6　设计决策　185
13．6．1　类型对象应该封装还是暴露　186
13．6．2　持有类型对象如何创建　187
13．6．3　类型能否改变　187
13．6．4　支持何种类型的派生　188
13．7　参考　189
第5篇　解耦型模式
第14章　组件模式　193
14．1　动机　193
14．1．1　难题　194
14．1．2　解决难题　194
14．1．3　宽松的末端　194
14．1．4　捆绑在一起　195
14．2　模式　196
14．3　使用情境　196
14．4　注意事项　196
14．5　示例代码　197
14．5．1　一个庞大的类　197
14．5．2　分割域　198
14．5．3　分割其余部分　200
14．5．4　重构Bjorn　202
14．5．5　删掉Bjorn　204
14．6　设计决策　206
14．6．1　对象如何获得组件　206
14．6．2　组件之间如何传递信息　207
14．7　参考　210
第15章　事件队列　211
15．1　动机　211
15．1．1　用户图形界面的事件循环　211
15．1．2　中心事件总线　212
15．1．3　说些什么好呢　213
15．2　事件队列模式　215
15．3　使用情境　215
15．4　使用须知　215
15．4．1　中心事件队列是个全局变量　216
15．4．2　游戏世界的状态任你掌控　216
15．4．3　你会在反馈系统循环中绕圈子　216
15．5　示例代码　217
15．5．1　环状缓冲区　219
15．5．2　汇总请求　222
15．5．3　跨越线程　223
15．6　设计决策　224
15．6．1　入队的是什么　224
15．6．2　谁能从队列中读取　224
15．6．3　谁可以写入队列　225
15．6．4　队列中对象的生命周期是什么　226
15．7　参考　227
第16章　服务定位器　229
16．1　动机　229
16．2　服务定位器模式　230
16．3　使用情境　230
16．4　使用须知　231
16．4．1　服务必须被定位　231
16．4．2　服务不知道被谁定位　231
16．5　示例代码　231
16．5．1　服务　231
16．5．2　服务提供器　232
16．5．3　简单的定位器　232
16．5．4　空服务　233
16．5．5　日志装饰器　235
16．6　设计决策　236
16．6．1　服务是如何被定位的　236
16．6．2　当服务不能被定位时发生了什么　239
16．6．3　服务的作用域多大　240
16．7　其他参考　241
第6篇　优化型模式
第17章　数据局部性　245
17．1　动机　245
17．1．1　数据仓库　246
17．1．2　CPU的托盘　247
17．1．3　等下，数据即性能　248
17．2　数据局部性模式　249
17．3　使用情境　249
17．4　使用须知　250
17．5　示例代码　250
17．5．1　连续的数组　251
17．5．2　包装数据　255
17．5．3　热/冷分解　258
17．6　设计决策　260
17．6．1　你如何处理多态　260
17．6．2　游戏实体是如何定义的　261
17．7　参考　263
第18章　脏标记模式　265
18．1　动机　265
18．1．1　局部变换和世界变换　266
18．1．2　缓存世界变换　267
18．1．3　延时重算　268
18．2　脏标记模式　269
18．3　使用情境　269
18．4　使用须知　270
18．4．1　延时太长会有代价　270
18．4．2　必须保证每次状态改动时都设置脏标记　271
18．4．3　必须在内存中保存上次的衍生数据　271
18．5　示例代码　271
18．5．1　未优化的遍历　272
18．5．2　让我们“脏”起来　273
18．6　设计抉择　275
18．6．1　何时清除脏标记　275
18．6．2　脏标记追踪的粒度多大　276
18．7　参考　276
第19章　对象池　277
19．1　动机　277
19．1．1　碎片化的害处　277
19．1．2　二者兼顾　278
19．2　对象池模式　278
19．3　使用情境　279
19．4　使用须知　279
19．4．1　对象池可能在闲置的对象上浪费内存　279
19．4．2　任意时刻处于存活状态的对象数目恒定　279
19．4．3　每个对象的内存大小是固定的　280
19．4．4　重用对象不会被自动清理　281
19．4．5　未使用的对象将占用内存　281
19．5　示例代码　281
19．6　设计决策　287
19．6．1　对象是否被加入对象池　287
19．6．2　谁来初始化那些被重用的对象　288
19．7　参考　290
第20章　空间分区　291
20．1　动机　291
20．1．1　战场上的部队　291
20．1．2　绘制战线　292
20．2　空间分区模式　293
20．3　使用情境　293
20．4　使用须知　293
20．5　示例代码　293
20．5．1　一张方格纸　294
20．5．2　相连单位的网格　294
20．5．3　进入战场　296
20．5．4　刀光剑影的战斗　297
20．5．5　冲锋陷阵　298
20．5．6　近在咫尺，短兵相接　299
20．6　设计决策　302
20．6．1　分区是层级的还是扁平的　302
20．6．2　分区依赖于对象集合吗　302
20．6．3　对象只存储在分区中吗　304
20．7　参考　305
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>游戏编程模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Ruby原理剖析
1  分词与语法解析 3
1.1  词条：构成Ruby语言的单词 5
1.2  语法解析：Ruby如何理解代码 13
1.2.1  理解LALR解析算法 14
1.2.2  真实的Ruby语法规则 21
1.3  总结 31
2  编译 33
2.1  Ruby 1.8没有编译器 34
2.2  Ruby 1.9和Ruby 2.0引入了编译器 35
2.3  Ruby如何编译简单脚本 37
2.4  编译块调用 41
2.5  本地表 49
2.5.1  编译可选参数 52
2.5.2  编译关键字参数 53
2.6  总结 57
3  Ruby如何执行代码 59
3.1  YARV内部栈和Ruby调用栈 60
3.1.1  逐句查看Ruby如何执行简单脚本 62
3.1.2  执行块调用 65
3.2  访问Ruby变量的两种方式 72
3.2.1  本地变量访问 72
3.2.2  方法参数被看成本地变量 75
3.2.3  动态变量访问 76
3.3  总结 86
4  控制结构与方法调度 89
4.1  Ruby如何执行if语句 90
4.2  作用域之间的跳转 93
4.2.1  捕获表 94
4.2.2  捕获表的其他用途 96
4.3  send指令：Ruby最复杂的控制结构 99
4.3.1  方法查找和方法调度 99
4.3.2  Ruby方法的11种类型 100
4.4  调用普通Ruby方法 102
4.4.1  为普通Ruby方法准备参数 103
4.5  调用内建的Ruby方法 104
4.5.1  调用attr_reader和attr_writer 105
4.5.2  方法调度优化attr_reader和attr_writer 106
4.6  总结 110
5  对象与类 113
5.1  Ruby对象内部 114
5.1.1  检验klass和ivptr 115
5.1.2  观察同一个类的两个实例 117
5.1.3  基本类型对象 118
5.1.4  简单立即值完全不需要结构体 119
5.1.5  基本类型对象有实例变量吗 120
5.1.6  基本类型对象的实例变量保存在哪里 122
5.2  RClass结构体内部有什么 125
5.2.1  继承 128
5.2.2  类实例变量vs类变量 129
5.2.3  存取类变量 131
5.2.4  常量 134
5.2.5  真实的RClass结构体 135
5.3  总结 140
6  方法查找和常量查找 143
6.1  Ruby如何实现模块 145
6.1.1  模块是类 145
6.1.2  将模块include到类中 147
6.2  Ruby的方法查找算法 148
6.2.1  方法查找示例 149
6.2.2  方法查找算法实践 151
6.2.3  Ruby中的多继承 152
6.2.4  全局方法缓存 153
6.2.5  内联方法缓存 154
6.2.6  清空Ruby的方法缓存 155
6.2.7  在同一个类中include两个模块 155
6.2.8  在模块中include模块 157
6.2.9  Module#prepend 示例 158
6.2.10  Ruby如何实现Module#prepend 161
6.2.11  在已被include的模块中增加方法 164
6.2.12  在已被include的模块中include其他模块 164
6.2.13 “被include的类”与原始模块共享方法表 166
6.3  常量查找 168
6.3.1  在超类中查找常量 169
6.3.2  Ruby如何在父级命名空间中查找常量 170
6.4  Ruby中的词法作用域 171
6.4.1  为新类或模块创建常量 172
6.4.2  在父命名空间中使用词法作用域查找常量 173
6.4.3  Ruby的常量查找算法 175
6.4.4  Ruby真实的常量查找算法 177
6.5  总结 178
7  散列表：Ruby内部的主力军 181
7.1  Ruby中的散列表 182
7.1.1  在散列表中保存值 183
7.1.2  从散列表中检索值 185
7.2  散列表如何扩展以容纳更多的值 188
7.2.1  散列冲突 188
7.2.2  重新散列条目 189
7.3  Ruby如何实现散列函数 195
7.3.1  Ruby 2.0中的散列优化 202
7.4  总结 203
8  Ruby如何借鉴Lisp几十年前的理念 207
8.1  块: Ruby中的闭包 208
8.1.1  Ruby如何调用块 210
8.1.2  借用1975年的理念 212
8.2  Lambda和Proc：把函数当做一等公民 219
8.2.1  栈内存vs堆内存 220
8.2.2  深入探索Ruby如何保存字符串的值 220
8.2.3  Ruby如何创建Lambda 223
8.2.4  Ruby如何调用Lambda 226
8.2.5  Proc对象 227
8.2.6  在同一个作用域中多次调用lambda 232
8.3  总结 234
9  元编程 237
9.1  定义方法的多种方式 239
9.1.1  Ruby的普通方法定义过程 239
9.1.2  使用对象前缀定义类方法 241
9.1.3  使用新的词法作用域定义类方法 242
9.1.4  使用单类定义方法 244
9.1.5  在单类的词法作用域中定义方法 245
9.1.6  创建Refinement 246
9.1.7  使用Refinement 248
9.1.8  顶级作用域中的self 250
9.1.9  类作用域中的self 251
9.1.10  元类作用域中的self 252
9.1.11  类方法中的self 253
9.2  元编程与闭包：eval、instance_eval和binding 255
9.2.1  能写代码的代码 255
9.2.2  使用binding参数调用eval 257
9.2.3  instance_eval示例 259
9.2.4  Ruby闭包的另一个重点 260
9.2.5  instance_eval改变接收者的self 262
9.2.6  instance_eval为新的词法作用域创建单类 262
9.2.7  使用define_method 266
9.2.8  充当闭包的方法 266
9.3  总结 268
10  JRuby：基于JVM的Ruby 271
10.1  使用MRI和JRuby运行程序 272
10.1.1  JRuby如何解析和编译代码 274
10.1.2  JRuby如何执行代码 276
10.1.3  用Java类实现Ruby类 278
10.1.4  使用-J-XX:+PrintCompilation选项 281
10.1.5  JIT是否提升了JRuby程序的性能 283
10.2  JRuby和MRI中的字符串 284
10.2.1  JRuby和MRI如何保存字符串数据 284
10.2.2  写时复制 286
10.2.3  创建唯一且非共享的字符串 288
10.2.4  可视化写时复制 290
10.2.5  修改共享字符串更慢 291
10.3  总结 293
11  Rubinius：用Ruby实现的Ruby 295
11.1  Rubinius内核和虚拟机 296
11.1.1  词法分析和解析 298
11.1.2  使用Ruby编译Ruby 299
11.1.3  Rubinius字节码指令 300
11.1.4  Ruby和C++一起工作 302
11.1.5  使用C++对象实现Ruby对象 303
11.1.6  Rubinius中的（栈）回溯 305
11.2  Rubinius和MRI中的数组 307
11.2.1  MRI中的数组 307
11.2.2  Rubinius中的数组 309
11.2.3  阅读Array#shift源码 311
11.2.4  修改Array#shift方法 312
11.3  总结 315
12  MRI、JRuby、Rubinius垃圾回收 317
12.1  垃圾回收器解决三个问题 319
12.2  MRI中的垃圾回收: 标记与清除 320
12.2.1  空闲列表 320
12.2.2  标记 321
12.2.3  MRI如何标记存活对象 323
12.2.4  清除 323
12.2.5  延迟清除 324
12.2.6  标记-清除的缺点 325
12.2.7  观察MRI执行延迟清除 327
12.2.8  观察MRI执行全回收 328
12.2.9  解读GC分析报告 329
12.3  JRuby和Rubinius中的垃圾回收 332
12.4  复制垃圾回收 333
12.4.1  碰撞分配 333
12.4.2  半空间算法 334
12.4.3  伊甸堆 336
12.5  分代垃圾回收 337
12.5.1  弱代假说 337
12.5.2  为新生代使用半空间算法 338
12.5.3  晋升对象 338
12.5.4  成熟代对象垃圾回收 339
12.6  并发垃圾回收 341
12.6.1  当对象图改变时进行标记 341
12.6.2  三色标记 343
12.6.3  JVM中的三种垃圾收集器 344
12.6.4  触发主收集 347
12.7  延伸阅读 348
12.8  总结 349
索引 351
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Ruby原理剖析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向模式的软件架构 卷5
第0 章  尘埃落定　　1
0.1  渊源　　1
0.2  成功与失败　　 2
0.2.1  观察　　2
0.2.2  状态　　3
0.2.3  处方　　4
0.3  模式定义及解释　　5
0.4  深入理解模式　　11
第一部分  模式剖析
第1 章  问题之解决方案及其他　　15
1.1  问题之解决方案　　15
1.1.1  一个例子（1） 　　15
1.1.2  重现与良好　　16
1.2  流程和物件　　16
1.3  “好”的解决方案　　17
1.4  驱动力：模式之心脏　　19
1.4.1  一个例子（4） 　　19
1.4.2  dysfunctional、bad 还是anti 　　21
1.5  上下文　　22
1.5.1  一个例子（5） 　 23
1.5.2  上下文的一般性　　23
1.5.3  独立上下文　　24
1.5.4  一个例子（6） 　 25
1.6  一般性　　 25
1.7  一图胜（逊）千言　　 27
1.8  模式命名　　29
1.8.1  模式命名的语法分类　　30
1.8.2  字面命名还是隐喻　　 30
1.9  模式是循序渐进的　　 31
1.10  模式既是讲故事，又能发起对话　　33
1.11  模式不能代替思考　　 33
1.12  从“问题—解决方案”到模式　　34
第2 章  多种多样的模式实现　　35
2.1  是否存在一个通用的模型呢　　35
2.1.1  Observer 模式：快速回顾　　36
2.1.2  结构的变化与角色　　36
2.1.3  行为的变化　　37
2.1.4  内部差异　　38
2.1.5  语言及平台的差别　　39
2.1.6  领域、环境相关的变化　40
2.1.7  再论假设　　41
2.2  模式与框架　　42
2.2.1  工具和上下文环境　　44
2.2.2  两个框架的故事　　44
2.3  模式与形式主义　　47
2.4  通用性与特殊性　　48
第3 章  模式格式　　50
3.1  风格与实质　　50
3.2  格式的功能　　52
3.3  格式的元素　　53
3.4  细节　　55
3.4.1  案例　　56
3.4.2  图示　　57
3.4.3  <code>…</code> 　　57
3.5  鸟瞰图　　 58
3.5.1  从金字塔到托盘　　58
3.5.2  模式骨架　　58
3.5.3  总结意图　　60
3.5.4  模式抽象　　60
3.6  不同的格式　　60
3.6.1  演变　　61
3.6.2  选择　　62
3.7  风格与实质（Redux） 　　63
第二部分  模式之间的关系
第4 章  模式孤岛　　 67
4.1  模式的联系　　67
4.2  设计实验：将模式作为孤岛　　68
4.3  第二个设计实验：交织在一起的模式　　72
4.4  模式密度　　73
第5 章  模式的互补性　　 75
5.1  一个问题，多种解决方案　　75
5.2  互相竞争的模式　　76
5.2.1  以状态为例　　76
5.2.2  模式族　　79
5.2.3  迭代开发　　80
5.2.4  适配开发　　83
5.2.5  遵从康威定律　　84
5.2.6  与风格的设计对话　　86
5.3  互相合作的模式　　87
5.3.1  一个关于值的例子　　88
5.3.2  设计上的完善　　 88
5.4  模式结合　　89
5.4.1  再论迭代　　89
5.4.2  再论适配编程　　91
5.5  互补性：竞争、完善、结合　　92
第6 章  模式复合　　93
6.1  常见模式排列　　93
6.2  从元素到复合　　93
6.2.1  Pluggable Factory 　　94
6.2.2  Composite Command 的两种视角　　95
6.2.3  模式复合的格式　　 96
6.3  从补充到复合　　97
6.3.1  重申　　 97
6.3.2  适配　　 99
6.4  是元素还是组合　　100
6.4.1  组合的含义　　100
6.4.2  深入MVC　　101
6.5  复合分析与综合　　102
6.5.1  非设计模式的复合　　102
6.5.2  设计模式复合　　103
第7 章  模式序列　　104
7.1  模式讲述软件工程成功的故事　　104
7.2  模式故事　　105
7.2.1  一个小故事　　105
7.2.2  已经发表的故事　　107
7.3  从故事到序列　　108
7.4  模式的序列　　109
7.4.1  一个早期的例子　　110
7.4.2  模式序列既是流程也是物件　　110
7.4.3  再次回到以前提到的小故事　　111
7.5  回顾模式复合和模式互补　　112
7.5.1  重组　　112
7.5.2  再论Batch Iterator 　　113
7.5.3  再论Interpreter 　　　114
7.5.4  再论Align Architecture andOrganization 　　115
7.6  回到上下文的问题　　 116
7.6.1  定义上下文　　116
7.6.2  专用化与差异化　　118
7.7  模式间的联系　　118
第8 章  模式集合　　120
8.1  模式手册　　120
8.2  组织模式集合　　121
8.3  即时组织　　121
8.4  根据层次组织　　122
8.4.1  设计和架构　　122
8.4.2  惯用法　　 123
8.4.3  混合层次　　124
8.4.4  层次　　124
8.5  根据领域组织　　125
8.6  根据分区组织　　125
8.6.1  阶层架构　　126
8.6.2  分区　　126
8.7  根据意图组织　　126
8.7.1  根据意图划分POSA 的模式　　127
8.7.2  根据意图划分GoF 的模式　　128
8.7.3  根据意图划分DDD 模式　　128
8.7.4  反思模式意图　　128
8.8  组织模式集合（重奏）　　 128
8.9  问题框架　　 129
8.9.1  问题框架　　130
8.9.2  问题框架和模式的对比　　 131
8.9.3  问题框架与模式的组合　　 132
8.10  模式符号学　　132
8.11  模式集合与风格　　134
8.11.1  Unix 接口设计模式　　135
8.11.2  Web 2.0 设计模式　　136
8.11.3  风格与概念一致性　　137
8.12  走向模式语言　　138
第三部分  模式语言
第9 章  语言的元素　　141
9.1  使用模式进行设计　　 141
9.2  从模式故事和模式序列到模式语言　　 142
9.2.1  一个未完成的故事　　143
9.2.2  序列的组合　　145
第10 章  模式网络及其他　　147
10.1  模式网络　　147
10.2  流程与物件　　147
10.2.1  流程的迭代本质　　 148
10.2.2  具体的面向领域的引导　　152
10.3  单项最佳　　153
10.4  驱动力：模式语言之心脏　　155
10.5  模式上下文定义拓扑结构与架构风格　　 158
10.6  模式构成词汇，序列展示语法　　 159
10.7  通用性　　162
10.7.1  不同的模式序列　　162
10.7.2  模式的组合　　163
10.8  完整的语言胜过千幅图　　163
10.9  面向领域的命名帮助忆起模式语言　　164
10.10  模式语言展开对话并讲述很多故事　　165
10.11  路还很长　　165
10.12  模式语言对创造性智慧的回报　　167
10.13  从模式网络到模式语言　　 168
第11 章  亿万种不同的实现　　169
11.1  众口难调　　169
11.2  渐进式成长　　169
11.2.1  面向系统的、进化的设计方法　　170
11.2.2  渐进式成长和敏捷开发　　171
11.3  并没有排斥重构　　172
11.4  一次一个模式　　174
11.4.1  明白手头上的问题的关键　　 174
11.4.2  优先级驱动的设计决策　　175
11.4.3  模式集成先于模式实现　　175
11.5  基于角色的模式集成　　176
11.5.1  选择1：识别并且保持已经实现的角色　　176
11.5.2  选择2：识别并分离已经实现的角色　　177
11.5.3  选择3：将缺失角色分配给既有设计元素　　178
11.5.4  选择4：将缺失角色作为新设计元素来实现　　179
11.5.5  基于角色的模式集成和渐进式成长过程　　180
11.6  模式语言和参考架构　　180
11.7  模式语言与产品线架构　　181
11.8  从十亿个到一个……再到一些　　184
第12 章  模式语言的格式　　185
12.1  风格与本质　　185
12.2  格式的作用　　185
12.3  格式的元素　　186
12.3.1  展示全貌　　187
12.3.2  简洁与细节　　187
12.3.3  模式连接　　189
12.3.4  再说元素　　189
12.4  细节，细节，细节　　 190
12.4.1  模式语言的格式　　 190
12.4.2  鸟瞰图　　 190
12.4.3  展示顺序　　194
12.4.4  示例　　194
12.4.5  细节程度　　195
12.5  再论风格与本质　　 197
第13 章  模式与模式语言　　198
13.1  模式和模式语言：共性　　198
13.1.1  共同的核心属性　　198
13.1.2  共同的根源　　199
13.1.3  一个模式的模式语言　　199
13.2  模式与模式语言：区别　　200
13.2.1  模式和细节　　 200
13.2.2  模式语言和交互　　200
13.2.3  两个独立的世界　　201
13.3  模式“对”模式语言　　201
第14 章  从模式到人　　202
14.1  模式以人为本　　 202
14.1.1  模式价值体系　　 203
14.1.2  人类读者　　 204
14.2  对软件开发者的支持　　204
14.3  对软件使用者的支持　　206
14.3.1  用户界面　　206
14.3.2  用户需求　　206
14.3.3  交到用户手中　　207
14.4  对模式作者的支持　　 207
14.4.1  协同写作　　 207
14.4.2  作者研讨会　　208
14.4.3  牧放　　208
14.5  技术为人　　209
第15 章  模式的过去、现在和未来　　210
15.1  过去的3 年　　210
15.1.1  模式与模式语言　　 210
15.1.2  理论和概念　　212
15.1.3  重构与集成　　212
15.1.4  GoF　　 213
15.2  模式的现状　　213
15.3  模式的明天在哪里　　 214
15.3.1  模式与模式语言　　 214
15.3.2  理论和概念　　216
15.3.3  重构与集成　　216
15.3.4  支持其他的软件开发方法　　 216
15.3.5  对其他学科的影响　　217
15.3.6  其他学科对我们的影响　　217
15.4  简述模式的未来　　218
第16 章  万事如意　　219
模式概念总结　　 221
参考模式　　 225
参考文献　　238
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向模式的软件架构 卷5
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大规模C++程序设计
前言
译者序
第0章 引言
第1部分 基础知识
第1章 预备知识
第2章 基本规则
第2部分 物理设计概念
第3章 组件
第4章 物理层次结构
第5章 层次化
第6章 绝缘
第7章 包
第3部分 逻辑设计问题
第8章 构建一个组件
第9章 设计一个函数
第10章 实现一个对象
附录A 协议层次结构设计模式
附录B 实现一个与ANSI C兼容的C++接口
附录C 一个依赖提取器/分析器包
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大规模C++程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>J2EE核心模式
第一部分 模式和J2EE
第1章 导论
什么是J2EE
什么是模式
历史回顾
模式的定义
模式的分类
J2EE模式目录
演化过程
怎样使用J2EE模式目录
使用模式的益处
模式、框架和重用
小结
第2章 表现层设计考虑和不佳实践
表现层设计考虑
会话管理
控制客户端访问
验证
助手类属性—完整性和一致性
表现层不佳实践
多个视图中都包括控制代码
把表现层的数据结构暴露给业务层
把表现层数据结构暴露给业务领域对象
允许重复提交表单
把敏感资源暴露给客户端的直接访问
假定 <jsp:setProperty> 会重置Bean属性
创建出“胖控制器”
把视图助手当成scriplet使用
第3章 业务层设计考虑和不佳实践
业务层设计考虑
使用session bean
使用entity bean
缓存EJB的远程引用和句柄
业务层和集成层不佳实践
把对象模型直接映射为entity bean模型
把关系型模型直接映射为entity bean模型
把每个用例映射为一个session bean
通过Getter/Setter方法暴露EJB的所有属性
在客户端中包括服务寻址代码
把entity bean当成只读对象使用
把entity bean当成细粒度对象使用
存储entity-bean的整个从属对象拓扑结构
把EJB相关的异常暴露给非EJB客户端
使用entity bean finder方法返回大型结果集
客户端负责聚合来自业务组件的数据
把EJB用于长时间持续的事务
每次调用无状态session bean都要重建
对话状态
第4章 J2EE重构
表现层的重构
引入控制器
引入同步器令牌
隔离不同逻辑
对业务层隐藏表现细节
去除视图中的转换
对客户端隐藏资源
业务层和集成层的重构
用session bean包装entity bean
引入业务代表
合并session bean
减少entity bean之间的通信
将业务逻辑移至session bean
一般的重构
分离数据访问代码
按层重构系统架构
使用连接池
第二部分 J2EE模式目录
第5章 J2EE模式概览
什么是模式
发现模式
模式 vs. 策略
分层思路
J2EE模式
表现层模式
业务层模式
集成层模式
J2EE模式目录指南
术语
UML的使用
模式模板
J2EE模式关系
与现有其他模式的关系
模式路线图
小结
第6章 表现层模式
拦截过滤器
问题
约束
解决方案
效果
相关模式
前端控制器
问题
约束
解决方案
效果
相关模式
Context对象
问题
约束
解决方案
效果
相关模式
应用控制器
问题
约束
解决方案
效果
相关模式
视图助手
问题
约束
解决方案
效果
相关模式
复合视图
问题
约束
解决方案
效果
示例代码
相关模式
服务到工作者
问题
约束
解决方案
效果
示例代码
相关模式
分配器视图
问题
约束
解决方案
效果
示例代码
相关模式
第7章 业务层模式
业务代表
问题
约束
解决方案
效果
示例代码
相关模式
服务定位器
问题
约束
解决方案
效果
示例代码
相关模式
会话门面
问题
约束
解决方案
效果
示例代码
相关模式
应用服务
问题
约束
解决方案
效果
示例代码
相关模式
业务对象
问题
约束
解决方案
效果
示例代码
相关模式
复合实体
问题
约束
解决方案
效果
示例代码
相关模式
传输对象
问题
约束
解决方案
效果
示例代码
相关模式
传输对象组装器
问题
约束
解决方案
效果
示例代码
相关模式
值列表处理器
问题
约束
解决方案
效果
示例代码
相关模式
第8章 集成层模式
数据访问对象
问题
约束
解决方案
效果
相关模式
服务激活器
问题
约束
解决方案
效果
相关模式
业务领域存储
问题
约束
解决方案
效果
相关模式
Web Service中转
问题
约束
解决方案
效果
相关模式
尾声
Web Worker微架构纵览
工作流简介
Web Worker微架构
问题
约束
解决方案
效果
参考书目
Apache软件授权协议，1.1版
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>J2EE核心模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>俄勒冈实验
前言
第一章 有机秩序
第二章 参与
第三章 分片式发展
第四章 模式
第五章 诊断
第六章 协调
致谢
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>俄勒冈实验
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>简约之美
目录
第1 章 　引言　　1
1.1 　计算机出了什么问题？　　3
1.2 　程序究竟是什么？　　5
第2 章 　缺失的科学　　9
2.1 　程序员也是设计师　　12
2.2 　软件设计的科学　　13
2.3 　为什么不存在软件设计科学　　15
第3 章 　软件设计的推动力　　19
第4 章 　未来　　27
4.1 　软件设计的方程式　　29
4.1.1 　价值　　30
4.1.2 　成本　　31
4.1.3 　维护　　32
4.1.4 　完整的方程式　　33
4.1.5 　化简方程式　　33
4.1.6 　你需要什么，不需要什么　　34
4.2 　设计的质量　　36
4.3 　不可预测的结果　　37
第5 章 　变化　　41
5.1 　真实世界中程序的变化　　43
5.2 　软件设计的三大误区　　46
5.2.1 　编写不必要的代码　　46
5.2.2 　代码难以修改　　48
5.2.3 　过分追求通用　　51
5.3 　渐进式开发及设计　　53
第6 章 　缺陷与设计　　55
6.1 　如果这不是问题……　　57
6.2 　避免重复　　59
第7 章 　简洁　　61
7.1 　简洁与软件设计方程式　　65
7.2 　简洁是相对的　　65
7.3 　简洁到什么程度？　　67
7.4 　保持一致　　69
7.5 　可读性　　71
7.5.1 　命名　　72
7.5.2 　注释　　73
7.6 　简洁离不开设计　　74
第8 章 　复杂性　　77
8.1 　复杂性与软件的用途　　81
8.2 　糟糕的技术　　83
8.2.1 　生存潜力　　83
8.2.2 　互通性　　84
8.2.3 　对品质的重视　　84
8.2.4 　其他原因　　85
8.3 　复杂性及错误的解决方案　　85
8.4 　复杂问题　　86
8.5 　应对复杂性　　87
8.5.1 　把某个部分变简单　　89
8.5.2 　不可解决的复杂性　　90
8.6 　推倒重来　　90
第9 章 　测试　　93
附录A 　软件设计的规则　　97
附录B 　事实、规则、条例、定义　　101
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>简约之美
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>建筑的永恒之道
永恒之道
第1章 永恒之道
质
第2章 无名特质
第3章 生机勃勃
第4章 事件模式
第5章 空间模式
第6章 有活力的模式
第7章 有活力模式的复合
第8章 特质本身
门
第9章 花与种子
第10章 我们的模式语言
第11章 我们的模式语言（续）
第12章 语言的创造力
第13章 语言的瓦解
第14章 可共享的模式
第15章 模式的真实
第16章 语言的结构
第17章 城市共同语言的演化
道
第18章 语言的发生力
第19章 空间的分化
第20章 每次一个模式
第21章 建筑的形成
第22章 建筑组团的形成
第23章 建造的过程
第24章 修整的过程
第25章 城市的缓慢出现
第26章 其超时代的特征
道之核心
第27章 道之核心
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>建筑的永恒之道
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>敏捷软件开发
第一部分　敏捷开发
第1章　敏捷实践
1.1　敏捷联盟
1.1.1　人和交互重于过程和工具
1.1.2　可以工作的软件重于面面俱到的文档
1.1.3　客户合作重于合同谈判
1.1.4　随时应对变化重于遵循计划
1.2　原则
1.3　结论
1.4　参考文献
第2章　极限编程概述
2.1　极限编程实践
2.1.1　完整团队
2.1.2　用户故事
2.1.3　短交付周期
2.1.4　验收测试
2.1.5　结对编程
2.1.6　测试驱动开发
2.1.7　集体所有权
2.1.8　持续集成
2.1.9　可持续的开发速度
2.1.10　开放的工作空间
2.1.11　计划游戏
2.1.12　简单设计
2.1.13　重构
2.1.14　隐喻
2.2　结论
2.3　参考文献
第3章　计划
3.1　初始探索
3.2　发布计划
3.3　迭代计划
3.4　定义“完成”
3.5　任务计划
3.6　迭代
3.7　跟踪
3.8　结论
3.9　参考文献
第4章　测试
4.1　测试驱动开发
4.1.1　测试优先设计的例子
4.1.2　测试促使模块之间隔离
4.1.3　意外获得的解耦合
4.2　验收测试
4.3　意外获得的构架
4.4　结论
4.5　参考文献
第5章　重构
5.1　素数产生程序：一个简单的重构示例
5.1.1　单元测试
5.1.2　重构
5.1.3　最后审视
5.2　结论
5.3　参考文献
第6章　一次编程实践
6.1　保龄球比赛
6.2　结论
第二部分　敏捷设计
第7章　什么是敏捷设计
7.1　设计臭味
7.1.1　设计臭味——腐化软件的气味
7.1.2　僵化性
7.1.3　脆弱性
7.1.4　顽固性
7.1.5　粘滞性
7.1.6　不必要的复杂性
7.1.7　不必要的重复
7.1.8　晦涩性
7.2　软件为何会腐化
7.3　Copy程序
7.3.1　熟悉的场景
7.3.2　Copy程序的敏捷设计
7.4　结论
7.5　参考文献
第8章　SRP：单一职责原则
8.1　定义职责
8.2　分离耦合的职责
8.3　持久化
8.4　结论
8.5　参考文献
第9章　OCP：开放－封闭原则
9.1　OCP概述
9.2　Shape应用程序
9.2.1　违反OCP
9.2.2　遵循OCP
9.2.3　预测变化和“贴切的”结构
9.2.4　放置吊钩
9.2.5　使用抽象获得显式封闭
9.2.6　使用“数据驱动”的方法获取封闭性
9.3　结论
9.4　参考文献
第10章　LSP：Liskov替换原则
10.1　违反LSP的情形
10.1.1　简单例子
10.1.2　更微妙的违反情形
10.1.3　实际的例子
10.2　用提取公共部分的方法代替继承
10.3　启发式规则和习惯用法
10.4　结论
10.5　参考文献
第11章　DIP：依赖倒置原则
11.1　层次化
11.1.1　倒置的接口所有权
11.1.2　依赖于抽象
11.2　简单的DIP示例
11.3　熔炉示例
11.4　结论
11.5　参考文献
第12章　ISP：接口隔离原则
12.1　接口污染
12.2　分离客户就是分离接口
12.3　类接口与对象接口
12.3.1　使用委托分离接口
12.3.2　使用多重继承分离接口
12.4　ATM用户界面的例子
12.5　结论
12.6　参考文献
第13章　C#程序员UML概观
13.1　类图
13.2　对象图
13.3　顺序图
13.4　协作图
13.5　状态图
13.6　结论
13.7　参考文献
第14章　使用UML
14.1　为什么建模
14.1.1　为什么构建软件模型
14.1.2　编码前应该构建面面俱到的设计吗
14.2　有效使用UML
14.2.1　与他人交流
14.2.2　脉络图
14.2.3　项目结束文档
14.2.4　要保留的和要丢弃的
14.3　迭代式改进
14.3.1　行为优先
14.3.2　检查结构
14.3.3　想象代码
14.3.4　图的演化
14.4　何时以及如何绘制图示
14.4.1　何时要画图，何时不要画图
14.4.2　CASE 工具
14.4.3　那么，文档呢
14.5　结论
第15章　状态图
15.1　基础知识
15.1.1　特定事件
15.1.2　超状态
15.1.3　初始伪状态和结束伪状态
15.2　使用FSM图示
15.3　结论
第16章　对象图
16.1　即时快照
16.2　主动对象
16.3　结论
第17章　用例
17.1　编写用例
17.1.1　备选流程
17.1.2　其他东西呢
17.2　用例图
17.3　结论
17.4　参考文献
第18章　顺序图
18.1　基础知识
18.1.1　对象、生命线、消息及其他
18.1.2　创建和析构
18.1.3　简单循环
18.1.4　时机和场合
18.2　高级概念
18.2.1　循环和条件
18.2.2　耗费时间的消息
18.2.3　异步消息
18.2.4　多线程
18.2.5　主动对象
18.2.6　向接口发送消息
18.3　结论
第19章　类图
19.1　基础知识
19.1.1　类
19.1.2　关联
19.1.3　继承
19.2　类图示例
19.3　细节
19.3.1　类衍型
19.3.2　抽象类
19.3.3　属性
19.3.4　聚集
19.3.5　组合
19.3.6　多重性
19.3.7　关联衍型
19.3.8　内嵌类
19.3.9　关联类
19.3.10　关联修饰符
19.4　结论
19.5　参考文献
第20章　咖啡的启示
20.1　Mark IV型专用咖啡机
20.1.1　规格说明书
20.1.2　常见的丑陋方案
20.1.3　虚构的抽象
20.1.4　改进方案
20.1.5　实现抽象模型
20.1.6　这个设计的好处
20.2　面向对象过度设计
20.3　参考文献
第三部分　薪水支付案例研究
第21章　COMMAND模式和ACTIVE OBJECT模式：多功能与多任务
21.1　简单的Command
21.2　事务
21.2.1　实体上解耦和时间上解耦
21.2.2　时间上解耦
21.3　Undo()方法
21.4　ACTIVE OBJECT模式
21.5　结论
21.6　参考文献
第22章　TEMPLATE METHOD模式和STRATEGY模式：继承和委托
22.1　TEMPLATE METHOD模式
22.1.1　滥用模式
22.1.2　冒泡排序
22.2　STRATEGY模式
22.3　结论
22.4　参考文献
第23章　FACADE模式和MEDIATOR模式
23.1　FACADE模式
23.2　MEDIATOR模式
23.3　结论
23.4　参考文献
第24章　SINGLETON模式和MONOSTATE模式
24.1　SINGLETON模式
24.1.1　SINGLETON模式的好处
24.1.2　SINGLETON模式的代价
24.1.3　运用SINGLETON模式
24.2　MONOSTATE模式
24.2.1　MONOSTATE模式的好处
24.2.2　MONOSTATE模式的代价
24.2.3　运用MONOSTATE模式
24.3　结论
24.4　参考文献
第25章　NULL OBJECT模式
25.1　描述
25.2　结论
25.3　参考文献
第26章　薪水支付案例研究：第一次迭代开始
26.1　初步的规格说明
26.2　基于用例分析
26.2.1　增加新雇员
26.2.2　删除雇员
26.2.3　登记考勤卡
26.2.4　登记销售凭条
26.2.5　登记工会服务费
26.2.6　更改雇员明细
26.2.7　发薪日
26.3　反思：找出底层的抽象
26.3.1　雇员支付类别抽象
26.3.2　支付时间表抽象
26.3.3　支付方式
26.3.4　从属关系
26.4　结论
26.5　参考文献
第27章　薪水支付案例研究：实现
27.1　事务
27.1.1　增加雇员
27.1.2　删除雇员
27.1.3　考勤卡、销售凭条以及服务费用
27.1.4　更改雇员属性
27.1.5　犯了什么晕
27.1.6　支付雇员薪水
27.1.7　支付领月薪的雇员薪水
27.1.8　支付钟点工薪水
27.2　主程序
27.3　数据库
27.4　结论
27.5　关于本章
27.6　参考文献
第四部分　打包薪水支付系统
第28章　包和组件的设计原则
28.1　包和组件
28.2　组件的内聚性原则：粒度
28.2.1　重用—发布等价原则
28.2.2　共同重用原则
28.2.3　共同封闭原则
28.2.4　组件内聚性总结
28.3　组件的耦合性原则：稳定性
28.3.1　无环依赖原则
28.3.2　稳定依赖原则
28.3.3　稳定抽象原则
28.4　结论
第29章　FACTORY模式
29.1　依赖问题
29.2　静态类型与动态类型
29.3　可替换的工厂
29.4　对测试支架使用对象工厂
29.5　工厂的重要性
29.6　结论
29.7　参考文献
第30章　薪水支付案例研究：包分析
30.1　组件结构和符号
30.2　应用CCP
30.3　应用REP
30.4　耦合和封装
30.5　度量
30.6　度量薪水支付应用程序
30.6.1　对象工厂
30.6.2　重新思考内聚的边界
30.7　最终的包结构
30.8　结论
30.9　参考文献
第31章　COMPOSITE模式
31.1　组合命令
31.2　多重性还是非多重性
31.3　结论
第32章　OBSERVER——演化至模式
32.1　数字时钟
32.2　OBSERVER模式
32.2.1　模型
32.2.2　面向对象设计原则的运用
32.3　结论
32.4　参考文献
第33章　ABSTRACT SERVER模式、 ADAPTER模式和BRIDGE模式
33.1　ABSTRACT SERVER模式
33.2　ADAPTER模式
33.2.1　类形式的ADAPTER模式
33.2.2　调制解调器问题、适配器以及LSP
33.3　BRIDGE模式
33.4　结论
33.5　参考文献
第34章　PROXY模式和GATEWAY模式：管理第三方API
34.1　PROXY模式
34.1.1　实现PROXY模式
34.1.2　小结
34.2　数据库、中间件以及其他第三方接口
34.3　TABLE DATA GATEWAY
34.3.1　测试和内存TDG
34.3.2　测试DbGateWay
34.4　可以用于数据库的其他模式
34.5　结论
34.6　参考文献
第35章　VISITOR模式
35.1　VISITOR模式
35.2　ACYCLIC VISITOR模式
35.3　DECORATOR模式
35.4　EXTENSION OBJECT模式
35.5　结论
35.6　参考文献
第36章　STATE模式
36.1　嵌套switch/case语句
36.1.1　内部作用域的状态变量
36.1.2　测试动作
36.1.3　代价和收益
36.2　迁移表
36.2.1　使用表解释
36.2.2　代价和收益
36.3　STATE模式
36.3.1　STATE模式和 STRATEGY模式
36.3.2　代价和收益
36.4　状态机编译器
36.4.1　SMC生成的Turnstile.cs以及其他支持文件
36.4.2　代价和收益
36.5　状态机应用的场合
36.5.1　作为GUI中的高层应用策略
36.5.2　GUI交互控制器
36.5.3　分布式处理
36.6　结论
36.7　参考文献
第37章　薪水支付案例研究：数据库
37.1　构建数据库
37.2　一个代码设计缺陷
37.3　增加雇员
37.4　事务
37.5　加载Employee对象
37.6　还有什么工作
第38章　薪水支付系统用户界面：Model-View-Presenter
38.1　界面
38.2　实现
38.3　构建窗口
38.4　Payroll窗口
38.5　真面目
38.6　结论
38.7　参考文献
附录A　双公司记
Rufus公司：“日落”项目
Rupert工业公司：“朝晖”项目
附录B　什么是软件
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>敏捷软件开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>城市设计新理论
序言
第一部分 理论
1 整体发展的思路
2 总法则
3 城市发展的七条细则
第二部分 实验
第三部分 评估
致谢
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>城市设计新理论
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分析模式
第一章  绪论
第一部分  分析模式
第二章  责任模式
第三章  观察和测量模式
第四章  针对公司财务的观察模式
第五章  引用对象
第六章  库存与账务
第七章  使用财务模型
第八章  计划
第九章  交易
第十章  派生合同
第十一章  交易包
第二部分  支持模式
第十二章  信息系统的分层构架
第十三章  应用外观
第十四章  类型模型的模式――设计模板
第十五章  关联模式
第十六章  后记
第三部分  附录
附录A  技术和符号
附录B  模式列表
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分析模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>反模式
**部分　反模式绪论
第1章　模式与反模式简介　3
1.1　反模式就是揭露假象　3
1.2　反模式的概念　6
1.3　反模式的由来　7
1.4　本书组织结构　10
第2章　反模式参考模型　11
2.1　视角　13
2.2　根源　14
2.2.1　匆忙　14
2.2.2　漠然　15
2.2.3　思想狭隘　16
2.2.4　懒惰　16
2.2.5　贪婪　17
2.2.6　无知　18
2.2.7　自负　18
2.3　原力　19
2.4　软件设计层次模型　25
2.4.1　对象层　28
2.4.2　微架构层　28
2.4.3　框架层　28
2.4.4　应用层　29
2.4.5　系统层　29
2.4.6　企业层　31
2.4.7　全球层　32
2.4.8　设计层次小结　32
2.5　架构规模和原力　33
第3章　模式和反模式的模板　35
3.1　退化形式　35
3.2　Alexander形式　36
3.3　*小化模板(微型模式)　36
3.4　小型模式模板　36
3.4.1　归纳式小型模式　37
3.4.2　演绎式小型模式　37
3.5　正式模板　37
3.5.1　GoF模板　37
3.5.2　模式系统模板　38
3.6　对设计模式模板的反思　38
3.7　反模式模板　39
3.7.1　伪反模式模板　40
3.7.2　小型反模式　40
3.8　完整的反模式模板　40
第4章　对使用反模式的建议　43
4.1　机能不良环境　43
4.2　反模式与变化　44
4.3　编写新反模式　45
4.4　小结　46
第二部分　反模式
第5章　软件开发性反模式　49
5.1　软件重构　49
5.2　开发性反模式摘要　50
5.3　The Blob(胖球)　52
5.3.1　背景　52
5.3.2　一般形式　53
5.3.3　症状和后果　54
5.3.4　典型原因　54
5.3.5　已知例外　55
5.3.6　重构方案　55
5.3.7　变化　58
5.3.8　对其他视角和规模的适用性　59
5.3.9　示例　59
5.4　Lava Flow(岩浆流)　62
5.4.1　背景　62
5.4.2　一般形式　63
5.4.3　症状和后果　65
5.4.4　典型原因　65
5.4.5　已知例外　66
5.4.6　重构方案　66
5.4.7　示例　66
5.4.8　相关解决方案　67
5.4.9　对其他视角和规模的适用性　67
5.5　Functional Decomposition(功能分解)　69
5.5.1　背景　69
5.5.2　一般形式　69
5.5.3　症状和后果　69
5.5.4　典型原因　70
5.5.5　已知例外　70
5.5.6　重构方案　70
5.5.7　示例　71
5.5.8　相关解决方案　72
5.5.9　对其他视角和规模的适用性　72
5.6　Poltergeist(恶作剧鬼)　73
5.6.1　背景　73
5.6.2　一般形式　73
5.6.3　症状和后果　74
5.6.4　典型原因　75
5.6.5　已知例外　75
5.6.6　重构方案　75
5.6.7　示例　75
5.6.8　相关解决方案　76
5.6.9　对其他视角和规模的适用性　76
5.7　Golden Hammer(金锤)　78
5.7.1　背景　78
5.7.2　一般形式　79
5.7.3　症状和后果　79
5.7.4　典型原因　79
5.7.5　已知例外　79
5.7.6　重构方案　80
5.7.7　变化　81
5.7.8　示例　81
5.7.9　相关方案　81
5.8　Spaghetti Code(面条代码)　83
5.8.1　背景　83
5.8.2　一般形式　83
5.8.3　症状和后果　83
5.8.4　典型原因　84
5.8.5　已知例外　84
5.8.6　重构方案　84
5.8.7　示例　86
5.8.8　相关解决方案　89
5.9　Cut-And-Paste Programming(剪贴编程)　92
5.9.1　背景　92
5.9.2　一般形式　92
5.9.3　症状和后果　92
5.9.4　典型原因　93
5.9.5　已知例外　93
5.9.6　重构方案　93
5.9.7　示例　94
5.9.8　相关解决方案　95
第6章　软件架构性反模式　97
6.1　架构性反模式摘要　98
6.2　Stovepipe Enterprise(烟囱企业)　100
6.2.1　背景　100
6.2.2　一般形式　100
6.2.3　症状和后果　101
6.2.4　典型原因　101
6.2.5　已知例外　101
6.2.6　重构方案　102
6.2.7　示例　105
6.2.8　相关解决方案　106
6.2.9　对其他视角和规模的适用性　107
6.3　Stovepipe System(烟囱系统)　108
6.3.1　背景　108
6.3.2　一般形式　108
6.3.3　症状和后果　109
6.3.4　典型原因　109
6.3.5　已知例外　109
6.3.6　重构方案　109
6.3.7　示例　110
6.3.8　相关解决方案　112
6.3.9　对其他视角和规模的适用性　112
6.4　Vendor Lock-In(供应商锁定)　113
6.4.1　背景　113
6.4.2　一般形式　114
6.4.3　症状和后果　114
6.4.4　典型原因　114
6.4.5　已知例外　115
6.4.6　重构方案　115
6.4.7　变化　116
6.4.8　示例　117
6.4.9　相关解决方案　117
6.4.10　对其他视角和规模的适用性　117
6.5　Architecture By Implication(实现主导架构)　120
6.5.1　背景　120
6.5.2　一般形式　120
6.5.3　症状和后果　121
6.5.4　典型原因　121
6.5.5　已知例外　121
6.5.6　重构方案　122
6.5.7　变化　123
6.5.8　示例　123
6.5.9　相关解决方案　124
6.5.10　对其他视角和规模的适用性　124
6.6　Design By Committee(委员会设计)　126
6.6.1　背景　126
6.6.2　一般形式　126
6.6.3　症状和后果　126
6.6.4　典型原因　127
6.6.5　已知例外　127
6.6.6　重构方案　127
6.6.7　变化　129
6.6.8　示例　129
6.6.9　相关解决方案、模式和反模式　131
6.6.10　对其他视角和规模的适用性　132
6.7　Reinvent The Wheel(重新发明轮子)　134
6.7.1　背景　134
6.7.2　一般形式　134
6.7.3　症状和后果　135
6.7.4　典型原因　135
6.7.5　已知例外　135
6.7.6　重构方案　135
6.7.7　变化　136
6.7.8　示例　137
6.7.9　相关解决方案　139
6.7.10　对其他视角和规模的适用性　139
第7章　软件项目管理性反模式　141
7.1　管理角色的转变　141
7.2　管理性反模式摘要　142
7.3　Analysis Paralysis(分析瘫痪)　145
7.3.1　背景　145
7.3.2　一般形式　145
7.3.3　症状和后果　146
7.3.4　典型原因　146
7.3.5　已知例外　147
7.3.6　重构方案　147
7.4　Death By Planning(规划致死)　149
7.4.1　背景　149
7.4.2　一般形式　149
7.4.3　症状和后果　151
7.4.4　典型原因　152
7.4.5　已知例外　152
7.4.6　重构方案　152
7.4.7　变化　154
7.4.8　示例　156
7.4.9　相关解决方案　157
7.4.10　对其他视角和规模的适用性　158
7.5　Corncob(玉米棒子)　159
7.5.1　背景　159
7.5.2　一般形式　159
7.5.3　症状和后果　159
7.5.4　典型原因　160
7.5.5　已知例外　160
7.5.6　重构方案　160
7.5.7　变化　161
7.5.8　示例　163
7.5.9　相关解决方案　163
7.5.10　对其他视角和规模的适用性　163
7.6　Irrational Management(非理性管理)　165
7.6.1　背景　165
7.6.2　一般形式　165
7.6.3　症状和后果　166
7.6.4　典型原因　166
7.6.5　已知例外　166
7.6.6　重构方案　166
7.6.7　变化　169
7.6.8　示例　169
7.7　Project Mismanagement(项目管理不善)　172
7.7.1　背景　172
7.7.2　一般形式　172
7.7.3　症状和后果　173
7.7.4　典型原因　173
7.7.5　已知例外　173
7.7.6　重构方案　173
7.7.7　变化　174
7.7.8　示例　175
7.7.9　相关解决方案　176
第三部分　结论和资源
附录A　反模式大纲　181
附录B　反模式术语表　187
附录C　缩略语　191
附录D　参考文献　193
索引　199
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>反模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++ API设计
目 录

第1章　API简介　　1
1.1 　什么是API　　1
1.1.1 　契约和承包人　　2
1.1.2 　C++中的API　　3
1.2 　API设计上有什么不同　　4
1.3 　为什么使用API　　5
1.3.1 　更健壮的代码　　6
1.3.2 　代码复用　　6
1.3.3 　并行开发　　8
1.4 　何时应当避免使用API　　9
1.5 　API示例　　10
1.5.1 　API层次　　10
1.5.2 　真实示例　　12
1.6 　文件格式和网络协议　　13
1.7 　关于本书　　15
第2章　特征　　17
2.1 　问题域建模　　17
2.1.1 　提供良好的抽象　　17
2.1.2 　关键对象的建模　　19
2.2 　隐藏实现细节　　20
2.2.1 　物理隐藏：声明与定义　　20
2.2.2 　逻辑隐藏：封装　　22
2.2.3 　隐藏成员变量　　23
2.2.4 　隐藏实现方法　　26
2.2.5 　隐藏实现类　　28
2.3 　最小完备性　　29
2.3.1 　不要过度承诺　　29
2.3.2 　谨慎添加虚函数　　30
2.3.3 　便捷API　　31
2.4 　易用性　　33
2.4.1 　可发现性　　34
2.4.2 　不易误用　　34
2.4.3 　一致性　　36
2.4.4 　正交　　38
2.4.5 　健壮的资源分配　　40
2.4.6 　平台独立　　43
2.5 　松耦合　　44
2.5.1 　仅通过名字耦合　　45
2.5.2 　降低类耦合　　45
2.5.3 　刻意的冗余　　47
2.5.4 　管理器类　　48
2.5.5 　回调、观察者和通知　　50
2.6 　稳定的、文档详细且经过测试的API　　53
第3章　模式　　54
3.1 　Pimpl惯用法　　55
3.1.1 　使用Pimpl　　56
3.1.2 　复制语义　　59
3.1.3 　Pimpl与智能指针　　60
3.1.4 　Pimpl的优点　　61
3.1.5 　Pimpl的缺点　　62
3.1.6 　C语言的不透明指针　　62
3.2 　单例　　64
3.2.1 　在C++中实现单例　　64
3.2.2 　使单例线程安全　　66
3.2.3 　单例与依赖注入　　68
3.2.4 　单例与单一状态　　69
3.2.5 　单例与会话状态　　71
3.3 　工厂模式　　71
3.3.1 　抽象基类　　72
3.3.2 　工厂示例　　73
3.3.3 　扩展工厂示例　　74
3.4 　API包装器模式　　76
3.4.1 　代理模式　　76
3.4.2 　适配器模式　　79
3.4.3 　外观模式　　81
3.5 　观察者模式　　83
3.5.1 　MVC架构　　83
3.5.2 　实现观察者模式　　84
3.5.3 　推与拉观察者　　87
第4章　设计　　88
4.1 　良好设计的例子　　89
4.1.1 　积累技术债　　89
4.1.2 　偿还技术债　　90
4.1.3 　为长期而设计　　91
4.2 　收集功能性需求　　92
4.2.1 　什么是功能性需求　　93
4.2.2 　功能性需求举例　　94
4.2.3 　维护需求　　94
4.3 　创建用例　　95
4.3.1 　开发用例　　95
4.3.2 　用例模板　　95
4.3.3 　编写高质量用例　　96
4.3.4 　 需求与敏捷开发　　98
4.4 　API设计的元素　　100
4.5 　架构设计　　102
4.5.1 　架构的开发　　103
4.5.2 　架构的约束　　104
4.5.3 　识别主要抽象　　105
4.5.4 　创造关键对象　　106
4.5.5 　架构模式　　109
4.5.6 　架构的交流　　110
4.6 　类的设计　　111
4.6.1 　面向对象概念　　112
4.6.2 　类设计选项　　113
4.6.3 　使用继承　　113
4.6.4 　Liskov替换原则　　115
4.6.5 　开放?封闭原则　　118
4.6.6 　迪米特法则　　119
4.6.7 　类的命名　　120
4.7 　函数设计　　121
4.7.1 　函数设计选项　　121
4.7.2 　函数命名　　122
4.7.3 　函数参数　　123
4.7.4 　错误处理　　125
第5章　风格　　129
5.1 　纯C API　　129
5.1.1 　ANSI C特性　　130
5.1.2 　ANSI C API的优点　　132
5.1.3 　使用ANSI C编写API　　132
5.1.4 　从C++中调用C函数　　134
5.1.5 　案例研究：FMOD C API　　135
5.2 　面向对象的C++ API　　136
5.2.1 　面向对象API的优点　　136
5.2.2 　面向对象API的缺点　　136
5.2.3 　案例研究：FMOD C++ API　　137
5.3 　基于模板的API　　138
5.3.1 　基于模板的API示例　　138
5.3.2 　模板与宏　　139
5.3.3 　基于模板的API的优点　　140
5.3.4 　基于模板的API的缺点　　141
5.4 　数据驱动型API　　141
5.4.1 　数据驱动型Web服务　　142
5.4.2 　数据驱动型API的优点　　143
5.4.3 　数据驱动API的缺点　　144
5.4.4 　支持可变参数列表　　144
5.4.5 　案例研究：FMOD数据驱动型API　　147
第6章　C++用法　　149
6.1 　命名空间　　149
6.2 　构造函数和赋值　　150
6.2.1 　控制编译器生成的函数　　152
6.2.2 　定义构造函数和赋值操作符　　153
6.2.3 　explicit关键字　　154
6.3 　const正确性　　155
6.3.1 　方法的const正确性　　155
6.3.2 　参数的const正确性　　157
6.3.3 　返回值的const正确性　　157
6.4 　模板　　158
6.4.1 　模板术语　　158
6.4.2 　隐式实例化API设计　　160
6.4.3 　显式实例化API设计　　162
6.5 　操作符重载　　164
6.5.1 　可重载的操作符　　164
6.5.2 　自由操作符与成员操作符　　165
6.5.3 　为类添加操作符　　166
6.5.4 　操作符语法　　168
6.5.5 　转换操作符　　170
6.6 　函数参数　　171
6.6.1 　指针与引用参数　　171
6.6.2 　默认参数　　172
6.7 　避免使用#define定义常量　　173
6.8 　避免使用友元　　175
6.9 　导出符号　　176
6.10 　编码规范　　179
第7章　性能　　181
7.1 　通过const引用传递输入参数　　182
7.2 　最小化#include依赖　　184
7.2.1 　避免“无所不包型”头文件　　184
7.2.2 　前置声明　　184
7.2.3 　冗余的#include警戒语句　　186
7.3 　声明常量　　188
7.4 　初始化列表　　190
7.5 　内存优化　　192
7.6 　除非需要，勿用内联　　196
7.7 　写时复制　　198
7.8 　迭代元素　　202
7.8.1 　迭代器　　202
7.8.2 　随机访问　　203
7.8.3 　数组引用　　204
7.9 　性能分析　　205
7.9.1 　时效性分析　　205
7.9.2 　基于内存的分析　　207
7.9.3 　多线程分析　　208
第8章　版本控制　　209
8.1 　版本号　　209
8.1.1 　版本号的意义　　209
8.1.2 　小众的编号方案　　210
8.1.3 　提供API的版本信息　　211
8.2 　软件分支策略　　213
8.2.1 　分支策略　　213
8.2.2 　分支方针　　213
8.2.3 　API和并行分支　　214
8.2.4 　文件格式和并行发布产品　　215
8.3 　API的生命周期　　216
8.4 　兼容性级别　　217
8.4.1 　向后兼容性　　217
8.4.2 　功能兼容性　　218
8.4.3 　源代码兼容性　　218
8.4.4 　二进制兼容性　　219
8.4.5 　向前兼容性　　221
8.5 　怎样维护向后兼容性　　222
8.5.1 　添加功能　　222
8.5.2 　修改功能　　223
8.5.3 　弃用功能　　224
8.5.4 　移除功能　　226
8.6 　API审查　　226
8.6.1 　API审查的目的　　226
8.6.2 　API预发布审查　　227
8.6.3 　API预提交审查　　228
第9章　文档　　230
9.1 　编写文档的理由　　230
9.1.1 　定义行为　　230
9.1.2 　为接口契约编写文档　　232
9.1.3 　告知行为的改变　　233
9.1.4 　文档涉及的内容　　234
9.2 　文档的类型　　236
9.2.1 　自动生成的API文档　　237
9.2.2 　概述文档　　237
9.2.3 　示例和教程　　238
9.2.4 　发布说明　　238
9.2.5 　 授权信息　　239
9.3 　文档可用性　　241
9.4 　使用Doxygen　　242
9.4.1 　配置文件　　242
9.4.2 　注释风格和命令　　242
9.4.3 　API注释　　243
9.4.4 　文件注释　　245
9.4.5 　类注释　　245
9.4.6 　方法注释　　246
9.4.7 　枚举注释　　247
9.4.8 　带有文档的示例头文件　　247
第10章　测试　　250
10.1 　编写测试的理由　　250
10.2 　API测试的类型　　252
10.2.1 　单元测试　　253
10.2.2 　集成测试　　255
10.2.3 　性能测试　　257
10.3 　编写良好的测试　　259
10.3.1 　良好测试的特征　　259
10.3.2 　测试对象　　260
10.3.3 　关注测试工作量　　261
10.3.4 　与QA一起工作　　261
10.4 　编写可测试的代码　　262
10.4.1 　测试驱动开发　　262
10.4.2 　桩对象和模拟对象　　264
10.4.3 　测试私有代码　　267
10.4.4 　使用断言　　269
10.4.5 　契约编程　　270
10.4.6 　记录并重放功能　　272
10.4.7 　支持国际化　　273
10.5 　自动化测试工具　　273
10.5.1 　自动化测试框架　　274
10.5.2 　代码覆盖率　　277
10.5.3 　缺陷跟踪系统　　279
10.5.4 　持续构建系统　　280
第11章　脚本化　　282
11.1 　添加脚本绑定　　282
11.1.1 　扩充或嵌入　　282
11.1.2 　脚本化的优点　　283
11.1.3 　语言兼容性问题　　284
11.1.4 　跨越语言障碍　　285
11.2 　脚本绑定技术　　286
11.2.1 　Boost Python　　286
11.2.2 　SWIG　　286
11.2.3 　Python-SIP　　287
11.2.4 　COM自动化　　287
11.2.5 　CORBA　　288
11.3 　使用Boost Python添加Python绑定　　289
11.3.1 　构建Boost Python　　290
11.3.2 　使用Boost Python包装C++ API　　290
11.3.3 　构造函数　　292
11.3.4 　扩充Python API　　293
11.3.5 　C++中的继承　　295
11.3.6 　跨语言多态　　296
11.3.7 　支持迭代器　　298
11.3.8 　综合应用　　298
11.4 　使用SWIG添加Ruby绑定　　300
11.4.1 　使用SWIG包装C++ API　　301
11.4.2 　调整Ruby API　　303
11.4.3 　构造函数　　304
11.4.4 　扩充Ruby API　　304
11.4.5 　C++中的继承　　305
11.4.6 　跨语言多态　　307
11.4.7 　综合应用　　307
第12章　可扩展性　　310
12.1 　通过插件扩展　　310
12.1.1 　插件模型概览　　311
12.1.2 　插件系统设计问题　　313
12.1.3 　以C++实现插件　　314
12.1.4 　插件API　　315
12.1.5 　插件示例　　317
12.1.6 　插件管理器　　318
12.1.7 　插件版本控制　　321
12.2 　通过继承扩展　　322
12.2.1 　添加功能　　322
12.2.2 　修改功能　　323
12.2.3 　继承与STL　　324
12.2.4 　继承与枚举　　325
12.2.5 　访问者模式　　326
12.2.6 　禁止子类化　　331
12.3 　通过模板扩展　　332
12.3.1 　基于策略的模板　　332
12.3.2 　奇特的递归模板模式　　334
附录A 　库　　336
参考文献　　351
索引　　355
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++ API设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>元素模式
目   录
第1章  设计模式介绍        1
1.1  部落神话和部落智慧        5
1.2  艺术还是科学        9
1.2.1  生搬硬套地对待模式        9
1.2.2  模式和实现语言的相关性讨论        10
1.2.3  从神话到科学        12
第2章  元素模式        13
2.1  背景        14
2.2  定位、动机和方法        17
2.2.1  解析装饰器        18
2.2.2  纵身兔穴        21
2.2.3  语境        31
2.2.4  设计空间        34
2.3  核心 EDP        44
2.4  结论        45
第3章  模式实例记法        47
3.1  基本原理        47
3.2  PIN 箱        51
3.2.1  简易 PIN 箱        52
3.2.2  标准 PIN 箱        54
3.2.3  扩展 PIN 箱        58
3.2.4  堆叠 PIN 箱与多重性        61
3.2.5  剥离和合并        65
3.3  结论        69
第4章  EDP的运用        71
4.1  模式的组成        71 同位素        76
4.2  改造装饰器        81
4.3  重构        96
4.4  大局观        108
4.5  为什么需要阅读附录         114
4.6  高级主题        115
4.6.1  重点文档与培训        115
4.6.2  指标        116
4.6.3  程序化分析        119
4.7  结论        119
第5章  EDP编目        121
创建对象        123 检索        132 继承        136 抽象接口        145 委托        151 重定向        157 集聚        165 xvi
递归        171 归复方法        178 扩展方法        187 委托型集聚        193 重定向型递归        199 信托型委托        206 信托型重定向        215 表亲信托型委托        222 表亲信托型重定向        229
第6章  中间模式结构        237
实现方法        239 检索型创建        243 检索型共享        248 对象标识符        253 对象递归        260
第7章  GoF设计模式成分解析        269
7.1  创建型模式        270
7.1.1  抽象工厂        270
7.1.2  工厂方法        274
7.2  结构型模式        278
7.2.1  装饰器        278
7.2.2  代理        282
7.3  行为型模式        284
7.3.1  职责链        284
7.3.2  模板方法        286
7.4  结论        291
附录  ρ演算        293
A.1  依赖运算符        294
A.2  传递律和同位素        297
A.3  相似性        298
A.4  EDP 形式化        299
A.5  组合及化简规则        303
A.6  模式实例记法和角色        306
A.7  EDP 定义        307
A.7.1  创建对象        307
A.7.2  检索        308
A.7.3  继承        310
A.7.4  抽象接口        310
A.7.5  委托        311
A.7.6  重定向        312
A.7.7  集聚        312
A.7.8  递归        313
A.7.9  归复方法        313
A.7.10  扩展方法        314
A.7.11  委托型集聚        315
A.7.12  重定向型递归        315
A.7.13  信托型委托        316
A.7.14  信托型重定向        317
A.7.15  表亲信托型委托        318
A.7.16  表亲信托型重定向        319
A.8  中间模式定义        320
A.8.1  实现方法        320
A.8.2  检索型创建        321
A.8.3  检索型共享        322
A.8.4  对象标识符        323
A.8.5  对象递归        324
A.9  GoF 设计模式定义        325
A9.1  抽象工厂        325
A9.2  工厂方法        326
A9.3  装饰器        328
A9.4  代理        329
A9.5  职责链        330
A9.6  模板方法        331
参考文献        333

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>元素模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>重构
Chapter 1：Refactoring，a First Example 重构，第一个例子
The Starting Point 起点
The First Step in Refactoring 重构第一步
Decomposing and Redistributing the Statement Method 分解并重组slalemenl方法
Replacing the Conditional Logic on Price Code with Polymorphism 用多态代替价格条件逻辑代码
Final Thoughts 结语
Chapter 2：Principles in Refactoring 重构原则
Defining Refactoring 何谓重构
Why Should You Refactor? 为何重构
When Should You Refactor? 何时重构
What Do I Tell My Manager? 怎样说服经理
Problems with Refactoring 重构的问题
Refactoring and Design 重构与设计
Refactoring and Performance 重构与性能
Where Did Refactoring Come From? 重构的起源
Chapter 3：Bad Smells in Code(by Kent Beck and Martin Fowler) 代码坏昧
Duplicated Code 重复代码
Long Method 过长方法
Large Class 过长类
Long Parameter List 过长参数列表
Divergent Change 发散式变化
Shotgun Surgery 霰弹式修改
Feature Envy 特性依恋
Data Clumps 数据泥团
Primitive Obsession 基本类型偏执
Switch Statements switch语句
Parallel Inheritance Hierarchies 平行继承体系
Lazy Class 冗余类
Speculative Generality 理论上的一般性
Temporary Field 临时字段
Message Chains 消息链
Middle Man 中间人
Inappropriate Intimacy 过度亲密
Alternative Classes with Different Interfaces 接口不同的等效类
Incomplete Library Class 不完整的库类
Data Class 数据类
Refused Bequest 拒绝继承
Comments 注释过多
Chapter 4：Building Tests 构建测试
The Value of Self-testing Code 自测试代码的重要性
The JUnit Testing Framework Junit测试框架
Adding More Tests 添加更多测试
Chapter 5：Toward a Catalog of Refactorings 重构目录
Format of the Refactorings 重构描述的格式
Finding References 寻找引用
How Mature Are These Refactorings? 这些重构的成熟度如何
Chapter 6：Composing Methods 组合方法
Extract Method 提取方法
Inline Method 内联方法
Inline Temp 内联临时变量
*Replace Temp with Query 用查询方法代替临时变量
Introduce Explaining Variable 引入解释性变量
Split Temporary Variable 分离临时变量
*Remove Assignments to Parameters 去除参数赋值
Replace Method with Method Object 用方法对象代替方法
Substitute Algorithm 替换算法
Chapter 7：Moving Features Between Objects 在对象之间移动特性
*Move Method 移动方法
Move Field 移动字段
Extract Class 提取类
Inline Class 内联类
Hide Delegate 隐藏委托类
Remove Middle Man 去除中间人
Introduce Foreign Method 引入外加方法
*Introduce Local Extension 引入本地扩展类
Chapter 8：Organizing Data 组织数据
Self Encapsulate Field 自封装字段
Replace Data Value with Object 用对象代替数据值
Change Value to Reference 将值对象改为引用对象
Change Reference to Value 将引用对象改为值对象
Replace Array with Object 用对象代替数组
Duplicate Observed Data 重复被观察数据
*Change Unidirectional Associationto Bidirectional 将单向关联改为双向
Change Bidirectional Association to Unidirectional 将双向关联改为单向
*Replace Magic Number with Symbolic Constant 用字面常量代替魔数
Encapsulate Field 封装字段
Encapsulate Collection 封装集合
Replace Record with Data Class 用数据类代替记录
*ReplaceType Code with Class 用类代替类型码
Replace Type Code with Subclasses 用子类代替类型码
Replace Type Code with State/Strategy用State/Strategy 代替类型码
Replace Subclass with Fields 用字段代替子类
Chapter 9：Simplifying Conditional Expressions 简化条件语句
Decompose Conditional 分解条件语句
Consolidate Conditional Expression 合并条件语句
Consolidate Duplicate Conditional Fragments 合并重复的条件片段
Remove Control Flag 去除控制标志
Replace Nested Conditional with Guard Clauses 用守卫语句代替嵌套条件语句
Replace Conditional with Polymorphism 用多态代替条件语句　　Introduce Null Object 引入Null对象
Introduce Assertion 引入断言
Chapter 10：Making Method Calls Simpler 简化方法调用
Rename Method 重命名方法
Add Parameter 添加参数
Remove Parameter 去除参数
Separate query from Modifier 将查询方法与修改方法分离
Parameterize Method 参数化方法
Replace Parameter with Explicit Methods 用显式方法代替参数
Preserve Whole Object 保持对象完整
Replace Parameter with Method 用方法代替参数
Introduce Parameter Object 引入参数对象
Remove Setting Method 去除设置方法
Hide Method 隐藏方法
Replace Constructor with Factory Method 用工厂方法代替构造器
Encapsulate Downcast 封装向下转型
Replace Error Code with Exception 用异常代替错误码
Replace Exception with Test 用测试代替异常
Chapter 11：Dealing with Generalization 处理泛化关系
Pull Up Field 上移字段
Pull UP Method 上移方法
Pull Up Constructor Body 上移构造器主体
Push Down Method 下移方法
Push Down Field 下移字段
Extract Subclass 提取子类
Extract Superclass 提取超类
Extract Interface 提取接口
Collapse Hierarchy 合并继承层次
Form Template Method 形成Template Method
Replace Inheritance with Delegation 用委托代替继承
Replace Delegation with Inheritance 用继承代替委托5
Chapter 12：Big Refactorings(by Kent Beck and Martin Fowler) 大型重构
Tease Apart Inheritance 分解继承层次
Convert Procedural Design to Objects 将过程式设计转换为面向对象
Separate Domain from Presentation 将领域逻辑与表现分离
Extract Hierarchy 提取继承层次
Chapter 13：Refactoring，Reuse，and Reality(by William Opdyke) 重构，复用与现实
A Reality Check 现实的检验
Whv Are Developers Reluctant to Refactor Their Programs？ 开发人员为何不愿重构程序
A Reality Check(Revisited) 再谈现实的检验
Resources and References for Refactoring 重构的资源和参考文献
Implications Regarding Software Reuse and Technology Transfer 对软件复用与技术传播的意义
A Final Note 结语
References 参考文献
Chapter 14：Refactoring Tools(by Don Roberts and John Brant) 重构工具
Refactoring with a Tool 使用工具重构
Technical Criteria for a Refactoring Tool 重构工具的技术标准
Practical Criteria for a Refactoring Tool 重构工具的实用标准
Wrap Up 结语
Chapter 15：Putting It All Together(by Kent Beck) 集大成
References参考文献
List of Soundbites 要点列表
Updates 更新内容
Index 索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>重构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>敏捷软件开发
第一部分 敏捷开发
第1章　敏捷实践	3
1.1 敏捷联盟	4
1.1.1 人和交互重于过程和工具	4
1.1.2 可以工作的软件重于面面
俱到的文档	5
1.1.3 客户合作重于合同谈判	5
1.1.4 随时应对变化重于遵循计划	6
1.2 原则	6
1.3 结论	8
1.4 参考文献	8
第2章　极限编程概述	9
2.1 极限编程实践	9
2.1.1 完整团队	9
2.1.2 用户故事	10
2.1.3 短交付周期	10
2.1.4 验收测试	10
2.1.5 结对编程	11
2.1.6 测试驱动开发	11
2.1.7 集体所有	12
2.1.8 持续集成	12
2.1.9 可持续的开发速度	12
2.1.10 开放的工作空间	13
2.1.11 计划游戏	13
2.1.12 简单设计	13
2.1.13 重构	14
2.1.14 隐喻	14
2.2 结论	15
2.3 参考文献	15
第3章　计划	16
3.1 初始探索	17
3.2 发布计划	17
3.3 迭代计划	18
3.4 定义“完成”	18
3.5 任务计划	18
3.6 迭代	19
3.7 跟踪	19
3.8 结论	20
3.9 参考文献	21
第4章　测试	22
4.1 测试驱动开发	22
4.1.1 优先设计测试的例子	23
4.1.2 测试促使模块之间隔离	24
4.1.3 意外获得的解耦合	25
4.2 验收测试	26
4.3 意外获得的构架	27
4.4 结论	27
4.5 参考文献	28
第5章　重构	29
5.1 素数产生程序：一个简单的重构示例	30
5.1.1 单元测试	31
5.1.2 重构	32
5.1.3 最后审视	35
5.2 结论	38
5.3 参考文献	39
第6章　一次编程实践	40
6.1 保龄球比赛	40
6.2 结论	75
第二部分 敏捷设计
第7章 什么是敏捷设计	81
7.1 设计臭味	81
7.1.1 设计臭味——腐化软件的气味	82
7.1.2 僵化性	82
7.1.3 脆弱性	82
7.1.4 顽固性	82
7.1.5 粘滞性	82
7.1.6 不必要的复杂性	83
7.1.7 不必要的重复	83
7.1.8 晦涩性	83
7.2 软件为何会腐化	84
7.3 Copy程序	84
7.3.1 熟悉的场景	84
7.3.2 Copy程序的敏捷设计	87
7.4 结论	88
7.5 参考文献	88
第8章　SRP：单一职责原则	89
8.1 定义职责	90
8.2 分离耦合的职责	91
8.3 持久化	92
8.4 结论	92
8.5 参考文献	92
第9章　OCP：开放－封闭原则	93
9.1 OCP概述	94
9.2 Shape应用程序	95
9.2.1 违反OCP	95
9.2.2 遵循OCP	97
9.2.3 预测变化和“贴切的”结构	98
9.2.4 放置吊钩	99
9.2.5 使用抽象获得显式封闭	99
9.2.6 使用“数据驱动”的方法获取封闭性	100
9.3 结论	101
9.4 参考文献	101
第10章　LSP：Liskov替换原则	102
10.1 违反LSP的情形	103
10.1.1 简单例子	103
10.1.2 更微妙的违反情形	104
10.1.3 实际的例子	108
10.2 用提取公共部分的方法代替继承	111
10.3 启发式规则和习惯用法	113
10.4 结论	114
10.5 参考文献	114
第11章　DIP：依赖倒置原则	115
11.1 层次化	116
11.1.1 倒置的接口所有权	117
11.1.2 依赖于抽象	117
11.2 简单的DIP示例	117
11.3 熔炉示例	119
11.4 结论	121
11.5 参考文献	121
第12章　ISP：接口隔离原则	122
12.1 接口污染	122
12.2 分离客户就是分离接口	123
12.3 类接口与对象接口	124
12.3.1 使用委托分离接口	124
12.3.2 使用多重继承分离接口	125
12.4 ATM用户界面的例子	126
12.5 结论	131
12.6 参考文献	131
第13章　写给C#程序员的UML概述	132
13.1 类图	134
13.2 对象图	135
13.3 顺序图	136
13.4 协作图	136
13.5 状态图	137
13.6 结论	137
13.7 参考文献	137
第14章　使用UML	138
14.1 为什么建模	138
14.1.1 为什么构建软件模型	139
14.1.2 编码前应该构建面面俱到的设计吗	139
14.2 有效使用UML	139
14.2.1 与他人交流	139
14.2.2 脉络图	141
14.2.3 项目结束文档	142
14.2.4 要保留的和要丢弃的	142
14.3 迭代式改进	143
14.3.1 行为优先	143
14.3.2 检查结构	144
14.3.3 想象代码	146
14.3.4 图的演化	147
14.4 何时以及如何绘制图示	147
14.4.1 何时要画图，何时不要画图	147
14.4.2 CASE 工具	148
14.4.3 那么，文档呢	149
14.5 结论	149
第15章　状态图	150
15.1 基础知识	150
15.1.1 特定事件	151
15.1.2 超状态	152
15.1.3 初始伪状态和结束伪状态	153
15.2 使用FSM图示	153
15.3 结论	154
第16章　对象图	155
16.1 即时快照	155
16.2 主动对象	156
16.3 结论	159
第17章　用例	160
17.1 编写用例	160
17.1.1 备选流程	161
17.1.2 其他东西呢	161
17.2 用例图	162
17.3 结论	162
17.4 参考文献	162
第18章　顺序图	163
18.1 基础知识	163
18.1.1 对象、生命线、消息及其他	164
18.1.2 创建和析构	164
18.1.3 简单循环	165
18.1.4 时机和场合	166
18.2 高级概念	168
18.2.1 循环和条件	168
18.2.2 耗费时间的消息	169
18.2.3 异步消息	171
18.2.4 多线程	174
18.2.5 主动对象	175
18.2.6 向接口发送消息	175
18.3 结论	175
第19章　类图	177
19.1 基础知识	177
19.1.1 类	177
19.1.2 关联	178
19.1.3 继承	179
19.2 类图示例	180
19.3 细节	181
19.3.1 类衍型	181
19.3.2 抽象类	182
19.3.3 属性	183
19.3.4 聚集	183
19.3.5 组合	184
19.3.6 多重性	185
19.3.7 关联衍型	186
19.3.8 内嵌类	187
19.3.9 关联类	187
19.3.10 关联修饰符	187
19.4 结论	188
19.5 参考文献	188
第20章　咖啡的启示	189
20.1 Mark IV型专用咖啡机	189
20.1.1 规格说明书	190
20.1.2 常见的丑陋方案	192
20.1.3 虚构的抽象	193
20.1.4 改进方案	194
20.1.5 实现抽象模型	198
20.1.6 这个设计的好处	209
20.2 面向对象过度设计	214
20.3 参考文献	214
第三部分 薪水支付案例研究
第21章　COMMAND模式和ACTIVE OBJECT模式：多功能与多任务	219
21.1 简单的Command	220
21.2 事务	221
21.2.1 实体上解耦和时间上解耦	222
21.2.2 时间上解耦	223
21.3 Undo()方法	223
21.4 ACTIVE OBJECT模式	224
21.5 结论	227
21.6 参考文献	228
第22章　TEMPLATE METHOD模式和STRATEGY模式：继承和委托	229
22.1 TEMPLATE METHOD模式	230
22.1.1 滥用模式	232
22.1.2 冒泡排序	232
22.2 STRATEGY模式	235
22.3 结论	239
22.4 参考文献	239
第23章　FACADE模式和MEDIATOR模式	240
23.1 FACADE模式	240
23.2 MEDIATOR模式	241
23.3 结论	243
23.4 参考文献	243
第24章　SINGLETON模式和MONOSTATE模式	244
24.1 SINGLETON模式	245
24.1.1 SINGLETON模式的好处	246
24.1.2 SINGLETON模式的代价	246
24.1.3 运用SINGLETON模式	246
24.2 MONOSTATE模式	247
24.2.1 MONOSTATE模式的好处	249
24.2.2 MONOSTATE模式的代价	249
24.2.3 运用MONOSTATE模式	249
24.3 结论	253
24.4 参考文献	253
第25章　NULL OBJECT模式	254
25.1 描述	254
25.2 结论	256
25.3 参考文献	256
第26章　薪水支付案例研究：第一次迭代开始	257
26.1 初步的规格说明	257
26.2 基于用例分析	258
26.2.1 增加新雇员	259
26.2.2 删除雇员	260
26.2.3 登记考勤卡	260
26.2.4 登记销售凭条	260
26.2.5 登记工会服务费	261
26.2.6 更改雇员明细	261
26.2.7 发薪日	263
26.3 反思：找出底层的抽象	264
26.3.1 雇员支付类别抽象	264
26.3.2 支付时间表抽象	265
26.3.3 支付方式	266
26.3.4 从属关系	266
26.4 结论	266
26.5 参考文献	267
第27章　薪水支付案例研究：实现	268
27.1 事务	268
27.1.1 增加雇员	269
27.1.2 删除雇员	273
27.1.3 考勤卡、销售凭条以及服务费用	274
27.1.4 更改雇员属性	280
27.1.5 犯了什么晕	287
27.1.6 支付雇员薪水	290
27.1.7 支付领月薪的雇员薪水	292
27.1.8 支付钟点工薪水	294
27.2 主程序	302
27.3 数据库	303
27.4 结论	304
27.5 关于本章	304
27.6 参考文献	305
第四部分 打包薪水支付系统
第28章　包和组件的设计原则	308
28.1 包和组件	308
28.2 组件的内聚性原则：粒度	309
28.2.1 重用—发布等价原则	309
28.2.2 共同重用原则	310
28.2.3 共同封闭原则	311
28.2.4 组件内聚性总结	311
28.3 组件的耦合性原则：稳定性	311
28.3.1 无环依赖原则	311
28.3.2 稳定依赖原则	316
28.3.3 稳定抽象原则	319
28.4 结论	322
第29章　FACTORY模式	323
29.1 依赖问题	325
29.2 静态类型与动态类型	326
29.3 可替换的工厂	326
29.4 对测试支架使用对象工厂	327
29.5 工厂的重要性	328
29.6 结论	329
29.7 参考文献	329
第30章　薪水支付案例研究：包分析	330
30.1 组件结构和符号	330
30.2 应用CCP	332
30.3 应用REP	333
30.4 耦合和封装	335
30.5 度量	336
30.6 度量薪水支付应用程序	337
30.6.1 对象工厂	340
30.6.2 重新思考内聚的边界	342
30.7 最终的包结构	342
30.8 结论	345
30.9 参考文献	345
第31章　COMPOSITE模式	346
31.1 组合命令	347
31.2 多重性还是非多重性	348
31.3 结论	348
第32章　OBSERVER——演化至模式	349
32.1 数字时钟	350
32.2 OBSERVER模式	365
32.2.1 模型	365
32.2.2 面向对象设计原则的运用	366
32.3 结论	366
32.4 参考文献	367
第33章　ABSTRACT SERVER模式、 ADAPTER模式和BRIDGE模式	368
33.1 ABSTRACT SERVER模式	369
33.2 ADAPTER模式	370
33.2.1 类形式的ADAPTER模式	370
33.2.2 调制解调器问题、适配器以及LSP	370
33.3 BRIDGE模式	374
33.4 结论	375
33.5 参考文献	376
第34章　PROXY模式和GATEWAY模式：管理第三方API	377
34.1 PROXY模式	377
34.1.1 实现PROXY模式	381
34.1.2 小结	391
34.2 数据库、中间件以及其他第三方接口	392
34.3 TABLE DATA GATEWAY	394
34.3.1 测试和内存TDG	399
34.3.2 测试DbGateWay	400
34.4 可以用于数据库的其他模式	403
34.5 结论	404
34.6 参考文献	404
第35章　VISITOR模式	405
35.1 VISITOR模式	406
35.2 ACYCLIC VISITOR模式	409
35.3 DECORATOR模式	418
35.4 EXTENSION OBJECT模式	423
35.5 结论	432
35.6 参考文献	432
第36章　STATE模式	433
36.1 嵌套switch/case语句	434
36.1.1 内部作用域的状态变量	436
36.1.2 测试动作	436
36.1.3 代价和收益	436
36.2 迁移表	437
36.2.1 使用表解释	437
36.2.2 代价和收益	438
36.3 STATE模式	439
36.3.1 STATE模式和 STRATEGY模式	441
36.3.2 代价和收益	442
36.4 状态机编译器	442
36.4.1 SMC生成的Turnstile.cs以及其他支持文件	443
36.4.2 代价和收益	448
36.5 状态机应用的场合	448
36.5.1 作为GUI中的高层应用策略	448
36.5.2 GUI交互控制器	450
36.5.3 分布式处理	450
36.6 结论	451
36.7 参考文献	451
第37章　薪水支付案例研究：数据库	452
37.1 构建数据库	452
37.2 一个代码设计缺陷	453
37.3 增加雇员	455
37.4 事务	464
37.5 加载Employee对象	468
37.6 还有什么工作	478
第38章　薪水支付系统用户界面：Model-View-Presenter	479
38.1 界面	480
38.2 实现	481
38.3 构建窗口	489
38.4 Payroll窗口	495
38.5 真面目	504
38.6 结论	505
38.7 参考文献	505
附录A 双公司记	506
Rufus公司：“日落”项目	506
Rupert工业公司：“朝阳”项目	506
附录B 什么是软件	516
索引	524
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>敏捷软件开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向模式的软件架构. 第2卷
目　录

第1章　并发与联网对象　　1
1.1 　驱动因素　　1
1.2 　并发与联网软件面临的挑战　　4
1.2.1 　挑战1：服务访问与配置　　6
1.2.2 　挑战2：事件处理　　9
1.2.3 　挑战3：并发　　11
1.2.4 　挑战4：同步　　13
1.2.5 　联网软件的其他挑战　　14
1.3 　案例研究：设计一个并发的Web服务器程序　　16
1.3.1 　JAWS框架概况　　17
1.3.2 　使用模式解决JAWS中常见的设计挑战　　18
1.3.3 　封装底层的操作系统API　　19
1.3.4 　将事件分离与连接管理同协议处理分离　　20
1.3.5 　通过多线程按比例提升服务器程序的性能　　21
1.3.6 　实现同步请求队列　　23
1.3.7 　最小化服务器程序的线程开销　　24
1.3.8 　有效利用异步I/O　　25
1.3.9 　增强服务器程序的可配置性　　27
1.3.10 　其他用于实现JAWS的模式　　28
1.4 　小结　　29
第2章　服务访问和配置模式　　31
2.1 　Wrapper Facade　　32
2.2 　Component Configurator　　51
2.3 　Interceptor　　73
2.4 　Extension Interface　　95
第3章　事件处理模式　　119
3.1 　Reactor　　120
3.2 　Proactor　　146
3.3 　Asynchronous Completion Token　　178
3.4 　Acceptor-Connector　　195
第4章　同步模式　　223
4.1 　Scoped Locking　　224
4.2 　Strategized Locking　　230
4.3 　Thread-Safe Interface　　238
4.4 　Double-Checked Locking Optimization　　244
第5章　并发模式　　253
5.1 　Active Object模式　　254
5.2 　Monitor Object模式　　275
5.3 　Half-Sync/Half-Async模式　　292
5.4 　Leader/Followers模式　　306
5.5 　Thread-Specific Storage模式　　324
第6章　模式的综合运用　　345
6.1 　从单个模式到模式语言　　345
6.1.1 　没有模式是一座孤岛　　345
6.1.2 　模式语言的形成　　347
6.2 　面向中间件和应用程序的模式语言　　348
6.2.1 　模式语言的细节　　348
6.2.2 　模式语言之我见　　355
6.3 　并发与联网之余　　356
6.3.1 　图形用户接口　　356
6.3.2 　组件　　357
6.3.3 　通用编程　　357
6.4 　模式语言与模式系统　　358
第7章　模式的过去、现在及未来　　361
7.1 　过去四年中模式的发展　　361
7.1.1 　模式　　361
7.1.2 　模式系统和模式语言　　362
7.1.3 　方法和工具　　363
7.1.4 　算法和数据结构　　363
7.1.5 　模式的形式化　　363
7.2 　模式的发展现状　　364
7.3 　模式的未来发展趋势　　365
7.3.1 　模式　　365
7.3.2 　模式语言　　367
7.3.3 　经验报告、方法与工具　　368
7.3.4 　模式文档　　368
7.3.5 　模式与模式语言的形式化　　369
7.3.6 　软件开发流程与组织　　369
7.3.7 　教育　　369
7.3.8 　我们的长期愿景　　370
7.4 　关于预测未来的最后一点想法　　370
第8章　结束语　　372
8.1 　术语表　　373
8.2 　符号　　385
8.2.1 　类－职责－协作者卡片　　385
8.2.2 　UML类图　　385
8.2.3 　UML时序图　　386
8.2.4 　UML 状态图　　388
参考文献　　390
索引　　414

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向模式的软件架构. 第2卷
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>UML和模式应用（原书第2版）
第一部分  绪论
第一章  面向对象分析和设计
第二章  迭代开发和统一过程
第三章  案例研究：NextGen POS系统
第二部分  初始
第四章  初识
第五章  理解需求
第六章  用例模型：写出实际语境中的需求
第七章  识别其他需求
第八章  从初识到细化
第三部分  细化迭代1
第九章  用例模型：绘制系统顺序图
第十章  领域模型：可视化概念
第十一章  领域模型：添加关联
第十二章  领域模型：添加属性
第十三章  用例模型：用操作契约增加细节
第十四章  迭代中的从需求到设计
第十五章  交互图表示法
第十六章  GRASP：根据职责设计对象
第十七章  设计模型：GRASP模式与用例实现
第十八章  设计模型：决定可见性
第十九章  设计模型：创建设计类图
第二十章  实现模型：将设计映射成代码
第四部分  细化迭代2
第二十一章  迭代2和其需求
第二十二章  GRASP：更多的职责分配模型
第二十三章  用GoF设计模式设计用列实现
第五部分  细化迭代3
第二十四章  迭代3和其需求
第二十五章  建立用例的关系
第二十六章  泛化建模
第二十七章  精化领域模型
第二十八章  增加新的SSD和契约
第二十九章  在状态图中为行为建模
第三十章  应用模式设计逻辑构架
第三十一章  组织模型包的设计和实现
第三十二章  构架分析和SAD的介绍
第三十三章  使用对象和模式设计更多用例的实现
第三十四章  使用模式设计持久化框架
第六部分  特殊专题
第三十五章  绘图及其工具
第三十六章  迭代设计和项目有关问题的介绍
第三十七章  关于迭代开发和UP的注释
第三十八章  更多的UML表示法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>UML和模式应用（原书第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>重构与模式
第1章　本书的写作缘由　1
1.1　过度设计　1
1.2　模式万灵丹　2
1.3　设计不足　2
1.4　测试驱动开发和持续重构　3
1.5　重构与模式　5
1.6　演进式设计　6
第2章　重构　7
2.1　何谓重构　7
2.2　重构的动机　8
2.3　众目睽睽　9
2.4　可读性好的代码　10
2.5　保持清晰　11
2.6　循序渐进　11
2.7　设计欠账　12
2.8　演变出新的架构　13
2.9　复合重构与测试驱动的重构　13
2.10　复合重构的优点　15
2.11　重构工具　15
第3章　模式　17
3.1　何谓模式　17
3.2　模式痴迷　18
3.3　实现模式的方式不止一种　20
3.4　通过重构实现、趋向和去除模式　22
3.5　模式是否会使代码更加复杂　24
3.6　模式知识　25
3.7　使用模式的预先设计　26
第4章　代码坏味　28
4.1　重复代码(Duplicated Code)　30
4.2　过长函数(Long Method)　30
4.3　条件逻辑太复杂(Conditional Complexity)　31
4.4　基本类型偏执(Primitive Obsession)　32
4.5　不恰当的暴露(Indecent Exposure)　32
4.6　解决方案蔓延(Solution Sprawl)　33
4.7　异曲同工的类(Alternative Classes with Different Interfaces)　33
4.8　冗赘类(Lazy Class)　33
4.9　过大的类(Large Class)　33
4.10　分支语句(Switch Statement)　34
4.11　组合爆炸(Combinatorial Explosion)　34
4.12　怪异解决方案(Oddball Solution)　34
第5章　模式导向的重构目录　36
5.1　重构的格式　36
5.2　本目录中引用的项目　37
5.2.1　XML Builder　38
5.2.2　HTML Parser　38
5.2.3　贷款风险计算程序　39
5.3　起点　39
5.4　学习顺序　39
第6章　创建　41
6.1　用Creation Method替换构造函数　43
6.1.1　动机　43
6.1.2　做法　45
6.1.3　示例　45
6.1.4　变体　49
6.2　将创建知识搬移到Factory　51
6.2.1　动机　51
6.2.2　做法　54
6.2.3　示例　55
6.3　用Factory封装类　60
6.3.1　动机　60
6.3.2　做法　61
6.3.3　示例　62
6.3.4　变体　65
6.4　用Factory Method引入多态创建　67
6.4.1　动机　67
6.4.2　做法　68
6.4.3　示例　70
6.5　用Builder封装Composite　74
6.5.1　做法　76
6.5.2　示例　77
6.5.3　变体　87
6.6　内联Singleton　90
6.6.1　动机　90
6.6.2　做法　92
6.6.3　示例　93
第7章　简化　96
7.1　组合方法　97
7.1.1　动机　97
7.1.2　做法　99
7.1.3　示例　99
7.2　用Strategy替换条件逻辑　102
7.2.1　动机　102
7.2.2　做法　104
7.2.3　示例　105
7.3　将装饰功能搬移到Decorator　115
7.3.1　动机　115
7.3.2　做法　118
7.3.3　示例　119
7.4　用State替换状态改变条件语句　133
7.4.1　动机　133
7.4.2　做法　134
7.4.3　示例　135
7.5　用Composite替换隐含树　143
7.5.1　动机　143
7.5.2　做法　146
7.5.3　示例　147
7.6　用Command替换条件调度程序　155
7.6.1　动机　155
7.6.2　做法　157
7.6.3　示例　158
第8章　泛化　164
8.1　形成Template Method　165
8.1.1　动机　166
8.1.2　做法　167
8.1.3　示例　167
8.2　提取Composite　172
8.2.1　动机　172
8.2.2　做法　173
8.2.3　示例　174
8.3　用Composite替换一/多之分　180
8.3.1　动机　180
8.3.2　做法　182
8.3.3　示例　183
8.4　用Observer替换硬编码的通知　190
8.4.1　动机　190
8.4.2　做法　191
8.4.3　示例　192
8.5　通过Adapter统一接口　199
8.5.1　动机　199
8.5.2　做法　200
8.5.3　示例　201
8.6　提取Adapter　208
8.6.1　动机　208
8.6.2　做法　210
8.6.3　示例　210
8.6.4　变体　216
8.7　用Interpreter替换隐式语言　217
8.7.1　动机　217
8.7.2　做法　219
8.7.3　示例　220
第9章　保护　230
9.1　用类替换类型代码　231
9.1.1　动机　231
9.1.2　做法　233
9.1.3　示例　234
9.2　用Singleton限制实例化　240
9.2.1　动机　240
9.2.2　做法　241
9.2.3　示例　241
9.3　引入Null Object　244
9.3.1　动机　244
9.3.2　做法　246
9.3.3　示例　247
第10章　聚集操作　252
10.1　将聚集操作搬移到Collecting Parameter　253
10.1.1　动机　253
10.1.2　做法　254
10.1.3　示例　255
10.2　将聚集操作搬移到Visitor　259
10.2.1　动机　259
10.2.2　做法　263
10.2.3　示例　267
第11章　实用重构　274
11.1　链构造函数　275
11.1.1　动机　275
11.1.2　做法　276
11.1.3　示例　276
11.2　统一接口　278
11.2.1　动机　278
11.2.2　做法　279
11.2.3　示例　279
11.3　提取参数　280
11.3.1　动机　280
11.3.2　做法　280
11.3.3　示例　281
跋　282
参考文献　283
索引　286
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>重构与模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Ajax模式与最佳实践
关于作者.
关于技术评论员
致谢
简介
第1章 ajax导言
一图胜千言
另一个ajax的例子
ajax体系架构基础
比较ajax与其他软件类型
一些最后的思考
第2章 ajax的具体细节
为缺乏耐心的人解释ajax
xmlhttprequest的细节
使用工厂模式
发送异步请求
将xmlht中request投入实际使用
一些最后的思考
第3章 内容分块模式
意图
动机
适用性
相关模式
体系架构
实现
模式要点
第4章 缓存控制器模式
意图
动机
适用性
相关模式
架构
实现
模式要点
第5章 置换模式
意图
动机
适用性
相关模式
体系架构
实现
模式要点
第6章 解耦导航模式
意图
动机..
适用性
相关模式
架构
实现
模式要点
第7章 表现变形模式
意图
动机
适用性
相关模式
体系架构
实现
模式要点
第8章 持久通信模式
意图
动机
适用性
相关模式
架构
实现
模式要点
第9章 状态导航模式
意图
动机
适用性
相关模式
架构
实现
模式要点
第10章 无限数据模式
意图
动机
适用性
相关模式
架构
实现
模式要点
第11章 基于rest的mvc模式
意图
动机
适用性
相关模式
架构
实现
模式要点
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Ajax模式与最佳实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>重构与模式
第1章  本书的写作缘由  1  1.1  过度设计  1  1.2  模式万灵丹  2  1.3  设计不足  2  1.4  测试驱动开发和持续重构  3  1.5  重构与模式  5  1.6  演进式设计  6第2章  重构  7  2.1  何谓重构  7  2.2  重构的动机  8  2.3  众目睽睽  9  2.4  可读性好的代码  10  2.5  保持清晰  11  2.6  循序渐进  11  2.7  设计欠账  12  2.8  演变出新的架构  13  2.9  复合重构与测试驱动的重构  13  2.10  复合重构的优点  15  2.11  重构工具  15第3章  模式  17  3.1  何谓模式  17  3.2  模式痴迷  18  3.3  实现模式的方式不止一种  20  3.4  通过重构实现、趋向和去除模式  22  3.5  模式是否会使代码更加复杂  24  3.6  模式知识  25  3.7  使用模式的预先设计  26第4章  代码坏味  28  4.1  重复代码(Duplicated Code)  30  4.2  过长函数(Long Method)  30  4.3  条件逻辑太复杂(Conditional Complexity)  31  4.4  基本类型偏执(Primitive Obsession)  32  4.5  不恰当的暴露(Indecent Exposure)  32  4.6  解决方案蔓延(Solution Sprawl)  33  4.7  异曲同工的类(Alternative Classes with Different Interfaces)  33  4.8  冗赘类(Lazy Class)  33  4.9  过大的类(Large Class)  33  4.10  分支语句(Switch Statement)  34  4.11  组合爆炸(Combinatorial Explosion)  34  4.12  怪异解决方案(Oddball Solution)  34第5章  模式导向的重构目录  36  5.1  重构的格式  36  5.2  本目录中引用的项目  37    5.2.1  XML Builder  38    5.2.2  HTML Parser  38    5.2.3  贷款风险计算程序  39  5.3  起点  39  5.4  学习顺序  39第6章  创建  41  6.1  用Creation Method替换构造函数  43    6.1.1  动机  43    6.1.2  做法  45    6.1.3  示例  45    6.1.4  变体  49  6.2  将创建知识搬移到Factory  51    6.2.1  动机  51    6.2.2  做法  54    6.2.3  示例  55  6.3  用Factory封装类  60    6.3.1  动机  60    6.3.2  做法  61    6.3.3  示例  62    6.3.4  变体  65  6.4  用Factory Method引入多态创建  67    6.4.1  动机  67    6.4.2  做法  68    6.4.3  示例  70  6.5  用Builder封装Composite  74    6.5.1  做法  76    6.5.2  示例  77    6.5.3  变体  87  6.6  内联Singleton  90    6.6.1  动机  90    6.6.2  做法  92    6.6.3  示例  93第7章  简化  96  7.1  组合方法  97    7.1.1  动机  97    7.1.2  做法  99    7.1.3  示例  99  7.2  用Strategy替换条件逻辑  102    7.2.1  动机  102    7.2.2  做法  104    7.2.3  示例  105  7.3  将装饰功能搬移到Decorator  115    7.3.1  动机  115    7.3.2  做法  118    7.3.3  示例  119  7.4  用State替换状态改变条件语句  133    7.4.1  动机  133    7.4.2  做法  134    7.4.3  示例  135  7.5  用Composite替换隐含树  143    7.5.1  动机  143    7.5.2  做法  146    7.5.3  示例  147  7.6  用Command替换条件调度程序  155    7.6.1  动机  155    7.6.2  做法  157    7.6.3  示例  158第8章  泛化  164  8.1  形成Template Method  165    8.1.1  动机  166    8.1.2  做法  167    8.1.3  示例  167  8.2  提取Composite  172    8.2.1  动机  172    8.2.2  做法  173    8.2.3  示例  174  8.3  用Composite替换一/多之分  180    8.3.1  动机  180    8.3.2  做法  182    8.3.3  示例  183  8.4  用Observer替换硬编码的通知  190    8.4.1  动机  190    8.4.2  做法  191    8.4.3  示例  192  8.5  通过Adapter统一接口  199    8.5.1  动机  199    8.5.2  做法  200    8.5.3  示例  201  8.6  提取Adapter  208    8.6.1  动机  208    8.6.2  做法  210    8.6.3  示例  210    8.6.4  变体  216  8.7  用Interpreter替换隐式语言  217    8.7.1  动机  217    8.7.2  做法  219    8.7.3  示例  220第9章  保护  230  9.1  用类替换类型代码  231    9.1.1  动机  231    9.1.2  做法  233    9.1.3  示例  234  9.2  用Singleton限制实例化  240    9.2.1  动机  240    9.2.2  做法  241    9.2.3  示例  241  9.3  引入Null Object  244    9.3.1  动机  244    9.3.2  做法  246    9.3.3  示例  247第10章  聚集操作  252  10.1  将聚集操作搬移到Collecting Parameter  253    10.1.1  动机  253    10.1.2  做法  254    10.1.3  示例  255  10.2  将聚集操作搬移到Visitor  259    10.2.1  动机  259    10.2.2  做法  263    10.2.3  示例  267第11章  实用重构  274  11.1  链构造函数  275    11.1.1  动机  275    11.1.2  做法  276    11.1.3  示例  276  11.2  统一接口  278    11.2.1  动机  278    11.2.2  做法  279    11.2.3  示例  279  11.3  提取参数  280    11.3.1  动机  280    11.3.2  做法  280    11.3.3  示例  281跋  282参考文献  283索引  286
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>重构与模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>模式的乐趣
第一章 最初的思考：个人笔记
第二章 模式简介
第三章 面向对象概述
第四章 产品配置器
第五章 汉堡店101
第六章 编程语言和模式
第七章 模式和系统开发
第八章 模式和系统的发展(维护)
第九章 最后的思考
附录A 产品代码
附录B “汉堡店”代码
附录C “黑杰克”代码
参考文献

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>模式的乐趣
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向模式的软件架构，卷3
目 录
第1章 　绪论　　1
1.1 　资源管理概述　　2
1.2 　资源管理的范畴　　4
1.3 　模式的用途　　5
1.4 　资源管理模式　　6
1.5 　相关成果　　7
1.6 　模式描述模板　　10
第2章 　资源获取　　11
2.1 　Lookup模式　　12
2.2 　Lazy Acquisition模式　　23
2.3 　Eager Acquisition模式　　33
2.4 　Partial Acquisition模式　　43
第3章 　资源生命周期　　53
3.1 　Caching模式　　54
3.2 　Pooling模式　　63
3.3 　Coordinator模式　　73
3.4 　Resource Lifecycle Manager模式　　84
第4章 　资源释放　　97
4.1 　Leasing模式　　97
4.2 　Evictor模式　　111
第5章 　资源管理模式应用指南　　120
第6章 　案例研究：自组网　　122
6.1 　概述　　122
6.2 　动机　　123
6.3 　解决方案　　124
第7章 　案例研究：移动网络　　129
7.1 　概述　　129
7.2 　动机　　132
7.3 　解决方案　　132
7.3.1 　基站的架构　　133
7.3.2 　基站的功能规范　　134
7.3.3 　OMC的架构　　138
7.3.4 　OMC的功能规范　　139
第8章 　模式的过去、现在和将来　　145
8.1 　最近4年的概况　　145
8.1.1 　模式　　145
8.1.2 　模式语言　　147
8.1.3 　经验报告、方法和工具　　148
8.1.4 　模式汇编　　148
8.1.5 　模式和模式语言的正式化　　148
8.2 　模式的现状　　148
8.3 　模式将走向何方　　149
8.3.1 　模式和模式语言　　149
8.3.2 　理论和概念　　151
8.3.3 　重构和集成　　151
8.3.4 　四人组　　152
8.4 　对预测的简单说明　　152
第9章 　结语　　153
引用的模式　　155
表示法　　159
参考文献　　164
模式索引　　176
索引　　178
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向模式的软件架构，卷3
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统架构设计师教程
第1章 绪论
第2章 计算机与网络基础知识
第3章 信息系统基础知识
第4章 系统开发基础知识
第5章 软件架构设计
第6章 UML建模与架构文档化
第7章 设计模式
第8章 XML技术
第9章 面向构件的软件设计
第10章 构件平台与典型架构
第11章 信息安全技术
第12章 系统安全架构设计
第13章 系统的可靠性设计
第14章 基于ODP的架构师实践
第15章 架构师的管理实践
第16章 层次式架构设计
第17章 企业集成架构设计
第18章 面向方面的编程
第19章 嵌入式系统设计
第20章 面向服务的架构
第21章 案例研究
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统架构设计师教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大规模c++程序设计
译者序
前　言
第0章　概述 1
0.1　从C到C++ 1
0.2　使用C++开发大型项目 2
0.3　重用 9
0.4　质量 10
0.5　软件开发工具 12
0.6　小结 12
第一部分　基 础 知 识
第1章　预备知识 15
1.1　多文件C++程序 15
1.2　typedef声明 22
1.3　断言语句 22
1.4　编程风格 23
1.5　迭代器 28
1.6　逻辑设计表示法 34
1.7　继承与分层 40
1.8　最小化 41
1.9　小结 42
第2章　基本规则 44
2.1　概述 44
2.2　成员数据访问 45
2.3　全局名字空间 48
2.4　包含卫哨 56
2.5　冗余包含卫哨 58
2.6　文档 61
2.7　标识符命名规则 63
2.8　小结 64
第二部分　物理设计概念
第3章　组件 69
3.1　组件与类 69
3.2　物理设计规则 75
3.3　依赖关系 83
3.4　隐含依赖 86
3.5　提取实际的依赖 91
3.6　友元关系 93
3.7　小结 99
第4章　物理层 101
4.1　软件测试的一个比喻 101
4.2　一个复杂的子系统 102
4.3　测试“好”接口的难度 105
4.4　可测性设计 107
4.5　隔离测试 109
4.6　非循环物理依赖 111
4.7　层次编号 112
4.8　分层和增量测试 117
4.9　测试一个复杂子系统 121
4.10　可测性与测试 122
4.11　循环物理依赖 123
4.12　累积组件依赖 124
4.13　物理设计质量 128
4.14　小结 132
第5章　层次化 134
5.1　循环物理依赖的一些来源 134
5.2　升级 142
5.3　降级 149
5.4　不透明指针 158
5.5　哑数据 164
5.6　冗余 171
5.7　回调方法 175
5.8　管理者类 184
5.9　分解 187
5.10　升级封装 199
5.11　小结 208
第6章　隔离 209
6.1　从封装到隔离 210
6.2　C++结构和编译时耦合 214
6.3　局部隔离技术 223
6.4　整体的隔离技术 249
6.5　过程接口 275
6.6　隔离或不隔离 288
6.7　小结 304
第7章　包 306
7.1　从组件到包 306
7.2　注册包前缀 312
7.3　包层次化 319
7.4　包隔离 323
7.5　包群 325
7.6　发布过程 328
7.7　main程序 335
7.8　启动 341
7.9　小结 351
第三部分　逻辑设计问题
第8章　组件架构 355
8.1　抽象和组件 355
8.2　组件接口设计 356
8.3　封装程度 359
8.4　辅助实现类 368
8.5　小结 372
第9章　函数设计 374
9.1　函数接口说明 374
9.2　在接口中使用的基本类型 406
9.3　特殊情况函数 415
9.4　小结 421
第10章　对象实现 425
10.1　成员数据 425
10.2　函数定义 430
10.3　内存管理 439
10.4　在大型项目中使用C++模板 466
10.5　小结 477
附录A　协议层设计模式 480
附录B　实现一个与ANSI C兼容的C++接口 501
附录C　一个依赖提取器包／分析器包 509
附录D　快速参考 531
参考文献 546
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大规模c++程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++代码设计与重用
第1章  重用性介绍
1. l  什么是重用性
1. 1. 1  提取代码来作为重用
1. 1. 2  可重用代码的基本特性
1. 2  重用的神话
1. 3  重用的障碍

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++代码设计与重用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大话重构
第一部分　基础篇
第1章　重构：改变既有代码的一剂良药　　2
1.1 　什么是系统重构　　2
1.2 　在保险索上走钢丝　　3
1.3 　大布局与小步快跑　　5
1.4 　软件修改的四种动机　　6
1.5 　一个真实的谎言　　9
第2章　重构方法工具箱　　10
2.1 　重构是一系列的等量变换——第一次HelloWorld重构　　10
2.2 　盘点我们的重构工具箱——对HelloWorld抽取类和接口　　13
第3章　小步快跑的开发模式　　19
3.1 　大布局你伤不起　　19
3.2 　小设计而不是大布局　　20
3.3 　小步快跑是这样玩的——HelloWorld重构完成　　22
第4章　保险索下的系统重构　　30
4.1 　你不能没有保险索　　30
4.2 　自动化测试——想说爱你不容易　　31
4.3 　我们是这样自动化测试的——JUnit下的HelloWorldTest　　33
4.4 　采用Mock技术完成测试　　37
第二部分　实践篇
第5章　第一步：从分解大函数开始　　44
5.1 　超级大函数——软件退化的重灾区　　44
5.2 　抽取方法的实践　　51
5.3 　最常见的问题　　54
第6章　第二步：拆分大对象　　57
6.1 　大对象的演化过程　　57
6.2 　大对象的拆分过程——抽取类与职责驱动设计　　60
6.3 　单一职责原则（SRP）与对象拆分　　61
6.4 　合久必分，分久必合——类的归并　　63
第7章　第三步：提高代码复用率　　66
7.1 　顺序编程的烦恼　　66
7.2 　代码重复与DRY原则　　67
7.3 　提高代码复用的方法　　69
7.3.1 　当重复代码存在于同一对象中时——抽取方法　　69
7.3.2 　当重复代码存在于不同对象中时——抽取类　　71
7.3.3 　不同对象中复用代码的另一种方法——封装成实体类　　72
7.3.4 　当代码所在类具有某种并列关系时——抽取父类　　75
7.3.5 　当出现继承泛滥时——将继承转换为组合　　76
7.3.6 　当重复代码被割裂成碎片时——继承结合模板模式　　78
7.4 　代码重复的检查工具　　79
第8章　第四步：发现程序可扩展点　　80
8.1 　开放?封闭原则与可扩展点设计　　81
8.2 　过程的扩展与放置钩子——运用模板模式增加可扩展点　　85
8.3 　面向切面的可扩展设计　　89
8.4 　其他可扩展设计　　93
第9章　第五步：降低程序依赖度　　98
9.1 　接口、实现与工厂模式　　98
9.1.1 　彻底理解工厂模式和依赖反转原则　　98
9.1.2 　工厂模式在重构中的实际运用　　102
9.2 　外部接口与适配器模式——与外部系统解耦　　106
9.3 　继承的泛滥与桥接模式　　109
9.4 　方法的解耦与策略模式　　112
9.5 　过程的解耦与命令模式　　116
9.6 　透明的功能扩展与设计——组合模式与装饰者模式　　119
第10章　第六步：我们开始分层了　　128
10.1 　什么才是我们需要的分层　　128
10.2 　怎样才能拥抱需求的变化　　131
10.3 　贫血模型与充血模型　　136
10.4 　我们怎样面对技术的变革　　139
第11章　一次完整的重构过程　　143
11.1 　第一步：分解大函数　　143
11.2 　第二步：拆分大对象　　145
11.3 　第三步：提高复用率　　147
11.4 　第四步：发现扩展点　　148
11.5 　第五步：降低依赖度　　151
11.6 　第六步：分层　　151
11.7 　第七步：领域驱动设计　　153
第三部分　进阶篇
第12章　什么时候重构　　156
12.1 　重构是一种习惯　　156
12.2 　重构让程序可读　　158
12.3 　重构，才好复用　　159
12.4 　先重构，再扩展　　161
12.5 　变更任务紧急时，又该如何重构　　163
第13章　测试驱动开发　　166
13.1 　测试驱动开发（TDD）vs.后测试开发（TAD）　　167
13.2 　测试驱动开发与重构　　170
13.3 　遗留系统怎样开展TDD　　178
第14章　全面的升级任务　　182
14.1 　计划式设计vs.演进式设计　　182
14.2 　风险驱动设计　　184
14.3 　制定系统重构计划　　188
第15章　我们怎样拥抱变化　　190
15.1 　领域才是软件系统的“心”——工资软件的三次设计演变　　190
15.2 　领域模型分析方法　　197
15.3 　原文分析法　　199
15.4 　领域驱动设计——使用领域模型与客户一起设计　　203
15.5 　在遗留系统中的应用　　209
第16章　测试的困境　　213
16.1 　重构初期的困局　　213
16.2 　解耦与自动化测试　　215
16.3 　开发人员，还是测试人员　　219
16.4 　建立自动化测试体系　　223
第17章　系统重构的评价　　225
17.1 　评价软件质量的指标　　225
17.2 　怎样评价软件质量呢　　228
结束语：重构改变了世界　　233
附录　　235
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大话重构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>重构
chapter 1 refactoring, a first example（新增批注共21条） 1
the starting point 2
the first step in refactoring 9
decomposing and redistributing the statement method 10
replacing the conditional logic on price code with polymorphism 30
final thoughts 41
chapter 2 principles in refactoring（新增批注共11条） 43
defining refactoring 43
why should you refactor? 45
when should you refactor? 48
what do i tell my manager? 51
problems with refactoring 53
refactoring and design 57
refactoring and performance 60
where did refactoring come from? 61
chapter 3 bad smells in code (by kent beck and martin fowler)
（新增批注共17条） 65
duplicated code 66
long method 67
large class 70
.long parameter list 71
divergent change 73
shotgun surgery 74
feature envy 74
data clumps 75
primitive obsession 76
switch statements 76
parallel inheritance hierarchies 77
lazy class 77
speculative generality 78
temporary field 78
message chains 79
middle man 81
inappropriate intimacy 82
alternative classes with different interfaces 82
incomplete library class 83
data class 83
refused bequest 84
comments 84
chapter 4 building tests（新增批注共2条） 87
the value of self．testing code 87
the junit testing framework 89
adding more tests 97
chapter 5 toward a catalog of refactorings
（新增批注共1条） 103
format of the refactorings 103
finding references 105
how mature are these refactorings? 106
chapter 6 composing methods（新增批注共9条） 109
extract method 110
inline method 117
inline temp 118
replace temp with query 119
introduce explaining variable 124
split temporary variable 128
remove assignments to parameters 130
replace method with method object 134
substitute algorithm 137
chapter 7 moving features between objects
（新增批注共12条） 139
move method 139
move field 144
extract class 147
inline class 151
hide delegate 153
remove middle man 156
introduce foreign method 158
introduce local extension 160
chapter 8 organizing data（新增批注共9条） 167
self encapsulate field 168
replace data value with object 172
change value to reference 175
change reference to value 179
replace array with object 181
duplicate observed data 186
change unidirectional association to bidirectional 194
change bidirectional association to unidirectional 197
replace magic number with symbolic constant 200
encapsulate field 201
encapsulate collection 202
replace record with data class 211
replace type code with class 211
replace type code with subclasses 217
replace type code with state/strategy 220
replace subclass with fields 225
chapter 9 simplifying conditional expressions
（新增批注共6条） 229
decompose conditional 229
consolidate conditional expression 231
consolidate duplicate conditional fragments 234
remove contr01 flag 236
replace nested conditional with guard clauses 240
replace conditional with polymorphism 245
introduce null object 249
introduce assertion 258
chapter 10 making method calls simpler（新增批注共14条） 263
rename method 264
add parameter 266
remove parameter 267
separate query from modifier 269
parameterize method 273
replace parameter with explicit methods 277
preserve whole object 280
replace parameter with method 283
introduce parameter object 286
remove setting method 293
hide method 296
replace constructor with factory method 297
encapsulate downcast 301
replace error code with exception 303
replace exception with test 308
chapter 11 dealing with generalization（新增批注共6条） 313
pull up field 313
pull up method 315
pull up constructor body 317
push down method 320
push down field 321
extract subclass 322
extract superclass 327
extract interface 331
collapse hierarchy 334
form template method 335
replace inheritance with delegation 342
replace delegation with inheritance 345
chapter 12 big refactorings (by kent beck and martin fowler)
（新增批注共11条） 349
tease apart inheritance 351
convert procedural design to objects 358
separate domain from presentation 363
extract hierarchy 367
chapter 13 refactoring, reuse, and reality (by william opdyke)
（新增批注共8条） 373
a reality check 374
why are developers reluctant to refactor their programs? 375
a reality check (revisited) 388
resources and references for refactoring 389
implications regarding software reuse and technology transfer 390
a final note 391
references 391
chapter 14 refactoring tools (by don roberts and john brant) 395
refactoring with a tool 395
technical criteria for a refactoring tool 397
practical criteria for a refactoring tool 399
wrap up 401
chapter 15 putting it all together (by kent beck)
（新增批注共2条） 403
references 407
list of soundbites 411
index 413
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>重构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向对象葵花宝典：思想、技巧与实践
第1部分  面向对象基础	1
第1章  面向对象概述	3
1.1  程序设计思想的发展	3
1.2  面向对象语言的发展历史	6
1.3  面向过程	8
1.4  面向对象	9
1.5  为什么要面向对象	11
1.6  面向对象的应用范围	12
1.7  面向对象的迷思	13
1.7.1  面向对象会导致性能降低？	13
1.7.2  面向对象语言=面向对象编程？	14
1.8  小结	16
第2章  面向对象理论	17
2.1  类	17
2.2  对象	23
2.3  接口	26
2.4  抽象类	31
2.5  抽象	32
2.6  三大核心特征	34
2.6.1  封装	34
2.6.2  继承	44
2.6.3  多态	46
2.7  小结	50
第2部分  面向对象实战	53
第3章  面向对象分析和设计全流程概述	55
第4章  需求模型	57
4.1  需求详解	57
4.2  需求的重要性	59
4.3  需求分析	60
4.3.1  需求分析的目的	60
4.3.2  需求分析的方法	63
4.4  用例方法	69
4.4.1  用例的具体写法	70
4.4.2  要画图吗	74
4.5  功能	75
4.6  用例图的陷阱	78
4.7  SSD	79
4.8  FAQ	81
4.9  小结	82
第5章  领域模型	84
5.1  领域建模三字经	84
5.2  找名词	85
5.3  加属性	87
5.4  连关系	88
5.5  FAQ	89
5.6  小结	90
第6章  设计模型	91
6.1  设计模型总览	91
6.2  类模型	92
6.2.1  第一步（照猫画虎）：领域类映射	93
6.2.2  第二步（精雕细琢）：应用设计原则和设计模式	101
6.2.3  第三步（照本宣科）：拆分辅助类	105
6.3  动态模型	106
6.3.1  模型分类	106
6.3.2  建模实践	108
6.3.3  建模技巧	110
6.4  小结	111
第7章  实现模型	112
7.1  编程语言的差异性	112
7.2  C++	113
7.2.1  类	113
7.2.2  访问控制	114
7.2.3  继承	117
7.2.4  多态	126
7.2.5  抽象类	130
7.2.6  接口	135
7.3  Java	136
7.3.1  类	137
7.3.2  访问控制	138
7.3.3  继承	142
7.3.4  多态	144
7.3.5  抽象类	146
7.3.6  接口	150
7.4  小结	152
第3部分  面向对象技巧	153
第8章  设计原则	155
8.1  内聚	155
8.1.1  内聚究竟是什么	155
8.1.2  内聚的分类	157
8.2  耦合	168
8.2.1  耦合究竟是什么	168
8.2.2  耦合的分类	169
8.3  高内聚低耦合	180
8.4  类设计原则	188
8.4.1  SRP	188
8.4.2  OCP	191
8.4.3  LSP	193
8.4.4  ISP	197
8.4.5  DIP	202
8.4.6  如何应用设计原则	209
8.4.7  NOP	210
8.5  小结	211
第9章  设计模式	212
9.1  设计模式简介	212
9.2  设计模式只是一把锤子	213
9.3  设计模式之道	214
9.3.1  知易行难——设计模式应用的问题	214
9.3.2  拨云见日——寻找设计模式之道	215
9.3.3  庖丁解牛——解析设计模式之道	217
9.3.4  举一反三——活学活用设计模式之道	218
9.4  原则VS模式	219
9.5  模式详解	225
9.5.1  Prototype模式	226
9.5.2  Decorator模式	238
9.5.3  Facade模式	250
9.5.4  Observer模式	264
9.6  小结	274
第10章  UML	275
10.1  UML简介	275
10.2  UML只是语言	275
10.3  UML应用	277
10.4  需求分析阶段	278
10.4.1  用例图	278
10.4.2  用例图的关系	281
10.5  设计阶段	284
10.5.1  类图	284
10.5.2  类关系图	288
10.5.3  动态图	305
10.5.4  结构图	318
10.6  部署阶段	320
10.7  小结	322
第4部分  面向对象架构设计	325
第11章  面向对象架构设计基础	327
11.1  什么是架构	327
11.2  面向对象的架构设计	329
11.3  小结	330
第12章  面向对象架构设计流程	332
12.1  架构设计总体思想	332
12.2  业务架构	333
12.2.1  全新的业务系统	333
12.2.2  已有架构优化	335
12.2.3  业务架构实例：京西商城	336
12.3  领域架构	337
12.4  软件架构	338
12.4.1  第一步：照猫画虎	338
12.4.2  第二步：按图索骥	340
12.4.3  第三步：深思熟虑	342
12.5  小结	344
第13章  面向对象架构设计技巧	345
13.1  架构设计原则	345
13.1.1  客户需求优先原则	345
13.1.2  适当超前原则	347
13.2  架构设计屠龙刀	350
13.2.1  “拆”与“合”	350
13.2.2  “拆”的常见手段	352
13.2.3  “合”的常见手段	362
13.3  优秀架构师特质：创新	366
13.4  小结	367
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向对象葵花宝典：思想、技巧与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Delphi面向对象编程思想
前言
第1章 建立面向对象的新思维
1 导论
2 面向对象的基本概念
……
第2章 Delphi对象模型
第3章 理解对象
第4章 使用对象
第5章 深入多态
第6章 剖析接口
第7章 研究封装
第8章 实现界面和业务的分离
第9章 深入浅出VCL(上)
第10章 深入浅出VCL(下)
附录A ModelMaker使用指南
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Delphi面向对象编程思想
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++网络编程.卷1-运用ACE和模式消除复杂性
第0章 设计课题、中间件方案、ace
0.1 网络应用面临的挑战
0.2 网络应用的设计空间
0.3 面向对象中间件方案
0.4 ace工具包概览
0.5 示例：一个网络日志服务程序
0.6 小结
第1篇 面向对象网络编程
第1章 通信设计空间
1.1 无连接协议与面向连接协议
1.2 同步及异步消息交换
1.3 消息传递与共享内存
1.4 小结
第2章 socket api概述
2.1 操作系统ipc机制概述
2.2 socket api
2.3 socket api的局限性
2.4 小结
第3章 ace socket wrapper facade
3.1 概述
. 3.2 ace_addr类和ace_inet addr类
3.3 ace_ipc_sap类
3.4 ace_sock类
3.5 ace_sock_connector类
3.6 ace_sock_10类和ace_sock_stream类
3.7 ace_sock_acceptor类
3.8 小结
第4章 网络日志服务程序的实现
4.1 概述
4.2 ace_message_block类
4.3 ace_inputcdr类和ace_outputcdr类
4.4 日志服务器的初始版本
4.5 客户程序
4.6 小结
第2篇 并发式面向对象网络编程
第5章 并发设计空间
5.1 循环、并发及反应式服务器
5.2 进程与线程
5.3 进程／线程创建策略
5.4 用户、核心及混合线程模型
5.5 分时及实时调度级别
5.6 “基于任务”与“基于消息”的体系
5.7 小结
第6章 操作系统并发机制概述
6.1 同步事件多路分离
6.2 多进程机制
6.3 多线程机制
6.4 同步机制
6.5 os并发机制的局限性
6.6 小结
第7章 ace同步事件多路分离wrapper facade
7.1 概述
7.2 ace hanolle_set类
7.3 ace_handle_set_iterator类
7.4 ace：：select()方法
7.5 小结
第8章 ace进程wrapper facade
8.1 概述
8.2 ace_process类
8.3 ace_process_options类
8.4 ace_process_manager类
8.5 小结
第9章 ace线程wrapper facade
9.1 概述
9.2 ace_thread_manager类
9.3 ace_sched_params类
9.4 ace_tss类
9.5 小结
第10章 ace同步wrapper facade
10.1 概述
10.2 ace_guard类
10.3 ace互斥体类
10.4 ace readers／writer lock类
10.5 ace信号量类
10.6 ace条件变量类
10.7 小结
附录a ace c++wrapper facade的设计原则
a.1 概述
a.2 通过wrapper facade增强类型安全性
a.3 简化常见情形
a.4 通过继承结构提高设计的清晰性和可扩充性
a.5 尽可能地隐藏平台间的差异
a.6 针对效率实施优化
a.7 小结
附录b ace的过去、现在和将来
b.1 ace的演变
b.2 未来之路
b.3 结束语
术语表
参考文献
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++网络编程.卷1-运用ACE和模式消除复杂性
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ACE技术内幕
前   言
第1章   概述 / 1
1.1   模式与框架 / 1
1.1.1   模式 / 1
1.1.2   框架 / 2
1.1.3   模式与框架的关系 / 3
1.2   ACE框架 / 3
1.3   关于本书 / 7
1.3.1   本书的内容 / 7
1.3.2   源代码的表示 / 8
1.3.3   测试组网 / 9
1.3.4   几个常用术语 / 9
1.4   ACE Socket封装器 / 9
1.4.1   示例分析 / 10
1.4.2   Socket IPC分析 / 13
1.4.3   ACE_SOCK_Acceptor类的分析 / 15
1.4.4   ACE_SOCK_Connector类的分析 / 19
1.5   进一步学习 / 23
1.6   总结 / 23
第2章   Reactor框架 / 24
2.1   Reactor构架模式 / 24
2.2   Reactor框架概述 / 26
2.3   Reactor框架应用示例 / 27
2.3.1   I/O事件处理器的实现 / 27
2.3.2   Accept事件处理器的实现 / 31
2.3.3   main函数 / 34
2.4   事件处理器接口实现 / 35
2.4.1   事件处理器接口的构造与析构 / 38
2.4.2   事件处理器接口的使用规范 / 38
2.5    Reactor管理器的设计分析 / 39
2.5.1   Reactor管理器接口分析 / 40
2.5.2   Bridge设计模式接口 / 44
2.5.3   ACE_Select_Reactor_Impl类的分析 / 45
2.5.4   ACE_Select_Reactor_T类的分析 / 46
2.6   I/O事件调度的分析 / 47
2.6.1   I/O事件调度集的设计 / 47
2.6.2   调度集操作函数的分析 / 50
2.6.3   I /O事件处理器仓库的分析 / 53
2.6.4   I/O事件注册流程的分析 / 59
2.6.5   I/O事件调度流程的分析 / 61
2.6.6   I/O事件删除流程的分析 / 70
2.7   信号量事件调度的分析 / 71
2.7.1   信号量事件管理器的分析 / 71
2.7.2   Reactor管理器中的信号量事件处理 / 77
2.7.3   信号量事件删除流程的分析 / 78
2.8   定时器事件调度的分析 / 79
2.8.1   定时器事件管理器的分析 / 80
2.8.2   定时器事件注册流程的分析 / 93
2.8.3   定时器事件调度流程的分析 / 94
2.8.4   定时器事件删除流程的分析 / 95
2.9   Notify事件调度的分析 / 96
2.9.1   Notify事件管理器的分析 / 97
2.9.2   Notify事件注册流程的分析 / 105
2.9.3   Notify事件调度流程的分析 / 106
2.10   进一步学习 / 107
2.11   总结 / 107
第3章   Service Configurator框架 / 108
3.1   Component Configurator构架模式 / 108
3.2   Configurator框架概述 / 109
3.3   Configurator框架应用示例1 / 111
3.3.1   配置文件 / 111
3.3.2   可配置组件 / 111
3.3.3   main函数 / 113
3.4   ACE动态库接口封装的分析 / 114
3.5   配置组件接口的分析 / 115
3.6   组件工厂函数的分析 / 117
3.7   组件配置器设计的分析 / 119
3.7.1   组件配置器控制接口的分析 / 119
3.7.2   组件配置器实现的分析 / 128
3.7.3   语法分析器的分析 / 138
3.8   动态库符号定位的分析 / 141
3.8.1   ACE_Location_Node类分析 / 142
3.8.2   ACE_Object_Node类的分析 / 143
3.8.3   ACE_Function_Node类的分析 / 144
3.9   配置组件仓库的分析 / 147
3.9.1   find函数 / 148
3.9.2   remove函数 / 149
3.9.3   suspend函数 / 150
3.9.4   resume函数 / 150
3.10   配置组件类型的分析 / 151
3.10.1   ACE_Service_Type类 / 152
3.10.2   ACE_Service_Type_Impl类 / 153
3.10.3   ACE_Service_Object_Type类 / 154
3.10.4   ACE_Service_Type_Factory类 / 154
3.11   指令解析功能的分析 / 156
3.12   配置文件解析流程的分析 / 157
3.13   Configurator框架应用示例2 / 160
3.13.1   可配置组件 / 160
3.13.2   配置文件 / 161
3.13.3   配置文件解析流程的分析 / 162
3.14   配置改变 / 162
3.15   Configurator框架应用示例3 / 162
3.15.1   静态配置组件 / 163
3.15.2   配置文件 / 165
3.15.3   静态配置组件分析 / 166
3.16   进一步学习 / 169
3.17   总结 / 169
第4章   Task框架 / 170
4.1   Task框架概述 / 170
4.2   Task框架应用示例 / 171
4.2.1   生产者 / 171
4.2.2   消费者 / 173
4.2.3   main函数 / 174
4.3   ACE消息队列实现分析 / 175
4.3.1   数据块结构分析 / 176
4.3.2   消息块结构的分析 / 180
4.3.3   消息队列实现的分析 / 182
4.4   ACE多线程编程 / 185
4.4.1   线程的创建 / 186
4.4.2   线程的运行 / 189
4.4.3   线程的退出 / 191
4.4.4   线程等待 / 195
4.5   Task框架接口的分析 / 198
4.5.1   ACE_Task_Base类 / 199
4.5.2   ACE_Task类 / 200
4.6   Active Object设计模式 / 201
4.6.1   模式概述 / 201
4.6.2   应用示例 / 203
4.6.3   ACE_Future和ACE_Future_Rep类 / 207
4.7   进一步学习 / 210
4.8   总结 / 210
第5章   Acceptor_Connector框架 / 211
5.1   Acceptor_Connector构架模式 / 211
5.2   Acceptor_Connector框架概述 / 212
5.3   Acceptor_Connector框架应用示例 / 213
5.3.1   open函数 / 214
5.3.2   handle_input函数 / 214
5.3.3   handle_close函数 / 215
5.3.4   main函数 / 215
5.4   服务处理器接口的分析 / 216
5.4.1   open函数 / 217
5.4.2   handle_close函数 / 218
5.4.3   close函数 / 219
5.4.4   shutdown函数 / 219
5.5   Acceptor设计的分析 / 220
5.5.1   ACE_Acceptor类 / 220
5.5.2   open函数 / 221
5.5.3   handle_input函数 / 222
5.5.4   handle_close函数 / 224
5.6   Connector设计的分析 / 225
5.6.1   ACE_Connector类 / 226
5.6.2   阻塞模式连接的分析 / 226
5.6.3   非阻塞模式连接的分析 / 229
5.7   进一步学习 / 236
5.8   总结 / 236
第6章   Proactor框架 / 237
6.1   Proactor构架模式 / 237
6.2   Proactor框架概述 / 239
6.3   Proactor框架应用示例 / 240
6.3.1   I/O事件完成处理器的实现 / 240
6.3.2   异步Acceptor的实现 / 245
6.3.3   main函数 / 245
6.4   事件完成处理器接口的分析 / 246
6.5   Proactor管理器的设计分析 / 247
6.5.1   Proactor管理器接口的分析 / 248
6.5.2   Bridge设计模式接口 / 252
6.5.3   ACE_POSIX_Proactor接口分析 / 252
6.6   异步操作初始化器和操作结果分析 / 253
6.6.1   公共接口介绍 / 256
6.6.2   ACE_POSIX_Asynch_Operation类 / 256
6.6.3   ACE_POSIX_Asynch_Result类 / 258
6.6.4   ACE_POSIX_Asynch_Read_Stream_Result类 / 261
6.6.5   ACE_POSIX_Asynch_Read_Stream类 / 263
6.7   ACE_POSIX_AIOCB_Proactor管理器实现的分析 / 265
6.7.1   构造函数 / 267
6.7.2   start_aio函数 / 268
6.7.3   handle_events_i函数 / 271
6.7.4   find_completed_aio函数 / 274
6.7.5   start_deferred_aio函数 / 275
6.7.6   application_specific_code函数 / 277
6.8   异步非I/O事件调度的分析 / 278
6.8.1   ACE_AIOCB_Notify_Pipe_Manager类 / 278
6.8.2   post_completion函数 / 281
6.8.3   putq_result函数 / 282
6.8.4   process_result_queue函数 / 283
6.9   定时器事件调度的分析 / 283
6.9.1   定时器事件操作结果的分析 / 284
6.9.2   定时器管理器实现的分析 / 285
6.10   网络连接之accept事件调度的分析 / 290
6.10.1   Reactor任务分析 / 292
6.10.2   异步Acceptor分析 / 293
6.10.3   ACE_POSIX_Asynch_Accept类 / 294
6.10.4   ACE_POSIX_Asynch_Accept_Result类 / 300
6.10.5   ACE_Asynch_Acceptor类 / 302
6.11   Proactor框架的调度分析 / 311
6.11.1   调度函数分析 / 311
6.11.2   退出调度分析 / 311
6.12   进一步学习 / 313
6.13   总结 / 313
第7章   Streams框架 / 314
7.1   管道和过滤器构架模式 / 314
7.2   Streams框架的概述 / 315
7.2.1   ACE_Task类 / 315
7.2.2   put函数 / 316
7.2.3   put_next函数 / 316
7.3   Streams框架应用示例 / 317
7.3.1   Logrec_Reader类 / 317
7.3.2   Logrec_Timer类 / 318
7.3.3   Logrec_Suffix类 / 319
7.3.4   Logrec_Writer类 / 319
7.3.5   main函数 / 320
7.4   ACE_Module类的分析 / 322
7.4.1   open函数 / 323
7.4.2   link函数 / 324
7.4.3   ACE_Module的关闭 / 325
7.5   ACE_Stream类的分析 / 326
7.5.1   构造函数 / 326
7.5.2   open函数 / 327
7.5.3   push函数 / 329
7.5.4   close函数 / 330
7.6   进一步学习 / 331
7.7   总结 / 331
参考文献 / 332
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ACE技术内幕
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计思维
编者介绍　　001
第一章　应对范式转换的态度　　005
村山齐
强烈的好奇心——研究是为了探求谜底与真相　　007
以往理论体系的漏洞与崩塌　　013
观测与实验设备　　019
核心人物与观测数据的魅力　　024
“游击战”式的日本科研　　029
宇宙观测趋势与昴星团望远镜　　032
知识与设计1——知识界的企业家　　037
第二章　从多样性中寻求普遍性　　041
难波成任
坚持“从多样性中探寻普遍性”的方向　　043
植原体的全基因组测序　　049
中立、自由的思考环境　　055
小蚂蚁的秩序　　059
高附加值研究的战略意义　　062
基因重组技术的局限性　　066
难以分割的万物　　071
知识与设计2——现代社会与科学技术　　075
第三章　重构矛盾的开放性　　079
江崎浩
如何实现“社会基础结构”的开放化，使其富有创新性？　　081
长远的目光与方案　　087
大学动物园　　091
市场的研究与推广　　094
战略与战术　　097
《黑客帝国》与《攻壳机动队》的时代　　103
总而言之，在模拟模式中是没有意外新发现的，对吧？　　105
知识与设计3——互联网的本质　　106
第四章　失败的合理性背景　　109
小野塚知二
劳动——技术与人类的交汇点。　　111
合理性选择中的失败　　116
第一次世界大战前夕欧洲的爱国主义　　123
英国工业为何会衰退　　129
自由市场是否最有效　　132
知识与设计4——认识“新的无知”　　137
第五章　将失败转化为创造的战略　　141
井上将行
分子结构的语言与语法　　143
研究的动力　　145
研究领域需要基于经验法则　　151
自我纠正能力是科学最迷人的地方　　156
研究人员的能力　　163
知识与设计5——药物开发与社会体系　　169
译者跋　　172

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计思维
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Ext JS权威指南
前　言
第1章　Ext JS 4开发入门 / 1
1.1　学习Ext JS必需的基础知识 / 1
1.2　JSON概述 / 3
1.2.1　认识JSON /  3
1.2.2　JSON的结构 / 3
1.2.3　JSON的例子 / 4
1.2.4　在JavaScript中使用JSON / 4
1.2.5　在.NET中使用JSON / 8
1.2.6　在Java中使用JSON / 12
1.2.7　更多有关JSON的信息 / 15
1.3　Ext JS 4概述 / 15
1.4　Ext JS的开发工具的获取、安装与配置介绍 / 18
1.4.1　Ext Designer / 18
1.4.2　在Visual Studio中实现智能提示 / 23
1.4.3　Spket / 28
1.4.4　在Eclipse中实现智能提示 / 32
1.5　如何获得帮助 / 32
1.6　本章小结 / 33
第2章　从“Hello World”开始 / 34
2.1　获取Ext JS 4 / 34
2.2　配置使用Ext JS库 / 35
2.3　编写“Hello World”程序 / 37
2.4　关于Ext.onReady  / 38
2.5　关于Ext.BLANK_IMAGE_URL / 40
2.6　关于字体 / 42
2.7　Ext JS 4语法 / 42
2.8　本地化 / 60
2.9　为本书示例准备一个模板 / 60
2.10　本章小结 / 61
第3章　调试工具及技巧 / 62
3.1　使用Firebug进行调试 / 62
3.2　在IE中调试 / 76
3.2.1　使用Debugbar和Companion.js调试 / 76
3.2.2　使用IEtester测试 / 80
3.2.3　在IE 8或IE 9中调试 / 83
3.3　在Chrome中调试 / 84
3.4　调试工具的总结 / 84
3.5　调试技巧 / 85
3.6　本章小结 / 89
第4章　Ext JS的基础架构 / 90
4.1　Ext JS框架的命名空间：Ext / 90
4.1.1　概述 / 90
4.1.2　apply和applyIf方法 / 90
4.1.3　不推荐的extend方法 / 92
4.1.4　数据及其类型检测 / 95
4.1.5　其他的基础方法 / 99
4.2　为框架顺利运行提供支持 / 107
4.2.1　平台检测工具：Ext.is / 107
4.2.2　当前运行环境检测工具：Ext.supports / 109
4.3　Ext JS的静态方法 / 112
4.3.1　概述 / 112
4.3.2　Ext.Object中的静态方法 / 113
4.3.3　Ext.Function中的静态方法 / 120
4.3.4　Ext.Array中的静态方法 / 127
4.3.5　Ext.Error中的静态方法 / 133
4.4　深入了解类的创建及管理 / 135
4.4.1　开始创建类 / 135
4.4.2　创建类的类：Ext.Class / 137
4.4.3　所有继承类的基类：Ext.Base / 151
4.4.4　实现动态加载：Ext.Loader / 151
4.4.5　管理类的类：Ext.ClassManager / 159
4.4.6　类创建的总结 / 161
4.5　动态加载的路径设置 / 163
4.6　综合实例：页面计算器 / 165
4.7　本章小结 / 169
第5章　Ext JS的事件及其应用 / 170
5.1　概述 / 170
5.2　浏览器事件 / 170
5.2.1　绑定浏览器事件的过程：Ext.EventManager / 170
5.2.2　封装浏览器事件：Ext.EventObject / 179
5.2.3　移除浏览器事件 / 181
5.3　内部事件 / 184
5.3.1　内部事件对象：Ext.util.Event / 184
5.3.2　为组件添加事件接口：Ext.util.Observable / 188
5.3.3　为组件绑定事件 / 189
5.3.4　内部事件的触发过程 / 192
5.3.5　移除事件 / 194
5.4　特定功能的事件对象 / 196
5.4.1　延时任务：Ext.util.DelayedTask / 196
5.4.2　一般任务：Ext.util.TaskRunner与Ext.TaskManager / 198
5.4.3　封装好的单击事件：Ext.util.ClickRepeater / 200
5.5　键盘事件 / 201
5.5.1　为元素绑定键盘事件：Ext.util.KeyMap / 201
5.5.2　键盘导航：Ext.util.KeyNav / 204
5.6　综合实例：股票数据的实时更新 / 205
5.7　本章小结 / 214
第6章　选择器与DOM操作 / 215
6.1　Ext JS的选择器：Ext.DomQuery / 215
6.1.1　选择器的作用 / 215
6.1.2　使用Ext.query选择页面元素 / 215
6.1.3　基本选择符 / 223
6.1.4　属性选择符 / 229
6.1.5　CSS属性值选择符 / 234
6.1.6　伪类选择符 / 235
6.1.7　扩展选择器 / 248
6.1.8　Ext.DomQuery的使用方法 / 249
6.1.9　Ext JS选择器的总结 / 252
6.2　获取单一元素：Ext.dom.Element / 252
6.2.1　从错误开始 / 252
6.2.2　使用Ext.get获取元素 / 253
6.2.3　使用Ext.fly获取元素 / 256
6.2.4　使用Ext.getDom获取元素 / 257
6.2.5　获取元素的总结 / 258
6.3　元素生成器：Ext.dom.Helper / 258
6.3.1　概述 / 258
6.3.2　使用createHtml或markup方法生成HTML代码 / 258
6.3.3　使用createDOM方法生成DOM对象 / 261
6.3.4　使用createTemplate方法创建模板 / 263
6.3.5　Helper对象的使用方法 / 263
6.4　元素的操作 / 273
6.5　获取元素集合：Ext.CompositeElementLite与Ext.CompositeElement / 277
6.5.1　使用Ext.select获取元素集合 / 277
6.5.2　Ext.dom.CompositeElement与Ext.dom.CompositeElementLite的区别 / 279
6.5.3　操作元素集合 / 279
6.6　综合实例：可折叠的面板Accordion / 280
6.7　本章小结 / 283
第7章　数据交互 / 284
7.1　数据交互基础 / 284
7.1.1　Ajax概述 / 284
7.1.2　封装Ajax：Ext.data.Connection与Ext.Ajax / 284
7.1.3　使用Ajax / 291
7.1.4　跨域获取数据：Ext.data.JsonP / 295
7.1.5　为Element对象提供加载功能：Ext.ElementLoader / 295
7.1.6　为组件提供加载功能：Ext.ComponentLoader / 296
7.2　代理 / 299
7.2.1　代理概述 / 299
7.2.2　基本的代理：Ext.data.proxy.Proxy / 300
7.2.3　进行批量操作：Ext.data.Batch与Ext.data.Operation / 303
7.2.4　服务器端代理：Ext.data.proxy.Server / 305
7.2.5　使用Ajax处理数据的代理：Ext.data.proxy.Ajax与Ext.data.proxy.Rest / 308
7.2.6　跨域处理数据的代理：Ext.data.proxy.JsonP / 312
7.2.7　为Ext.Direct服务的代理：Ext.data.proxy.Direct / 312
7.2.8　客户端代理：Ext.data.proxy.Client / 314
7.2.9　从变量中提取数据的代理：Ext.data.proxy.Memory / 314
7.2.10　使用浏览器存储的代理：Ext.data.WebStorageProxy、Ext.data. SessionStorageProxy和Ext.data.proxy.LocalStorage / 314
7.3　读取和格式化数据 / 315
7.3.1　概述 / 315
7.3.2　数据的转换过程：Ext.data.reader.Xml、Ext.data.reader.Json和Ext.data.reader.Array / 315
7.3.3　Reader对象的配置项 / 321
7.3.4　格式化提交数据：Ext.data.writer.Writer、Ext.data.writer.JSON和Ext.data. writer.Xml / 322
7.3.5　Writer对象的配置项 / 325
7.4　数据模型 / 326
7.4.1　概述 / 326
7.4.2　数据类型及排序类型：Ext.data.Types与Ext.data.SortTypes / 326
7.4.3　数据模型的骨架——字段：Ext.data.Field / 330
7.4.4　数据集：Ext.util.AbstractMixedCollection与Ext.util.MixedCollection / 330
7.4.5　数据验证及错误处理：Ext.data.validations与Ext.data.Errors / 332
7.4.6　模型的关系：Ext.data.Association、Ext.data.HasManyAssociation和Ext.data.BelongsToAssociation / 334
7.4.7　管理数据模型：Ext.AbstractManager与Ext.ModelManager / 336
7.4.8　定义数据模型：Ext.data.Model / 336
7.4.9　数据模型的定义过程 / 337
7.4.10　数据模型的创建 / 340
7.4.11　数据模型的配置项、属性和方法 / 343
7.5　Store / 344
7.5.1　概述 / 344
7.5.2　Store对象的实例化过程 / 345
7.5.3　TreeStore对象的实例化过程 / 348
7.5.4　Ext.data.Store加载数据的方法 / 350
7.5.5　Ext.data.TreeStore加载数据的方法 / 354
7.5.6　Store的配置项 / 358
7.5.7　Store的分页 / 359
7.5.8　Store的排序：Ext.util.Sorter与Ext.util.Sortable / 360
7.5.9　Store的过滤：Ext.util.Filter / 363
7.5.10　Store的分组：Ext.util.Grouper / 363
7.5.11　树节点：Ext.data.NodeInterface与Ext.data.Tree / 364
7.5.12　Store的方法 / 366
7.5.13　Store的事件 / 368
7.5.14　Store管理器：Ext.data.StoreManager / 369
7.6　综合实例 / 369
7.6.1　远程读取JSON数据 / 369
7.6.2　读取XML数据 / 378
7.6.3　Store的数据操作 / 379
7.7　本章小结 / 384
第8章　模板与组件基础 / 385
8.1　模板 / 385
8.1.1　模板概述 / 385
8.1.2　Ext.Template的创建与编译 / 385
8.1.3　格式化输出数据：Ext.String、Ext.Number、Ext.Date和Ext.util.Format / 389
8.1.4　超级模板：Ext.XTemplate（包括Ext.XTemplateParser和Ext.XTemplateCompiler） / 393
8.1.5　模板的方法 / 396
8.2　组件的基础知识 / 396
8.2.1　概述 / 396
8.2.2　组件类的整体架构 / 397
8.2.3　布局类的整体架构 / 402
8.2.4　组件的创建流程 / 403
8.2.5　常用的组件配置项、属性、方法和事件 / 415
8.3　为组件添加功能 / 418
8.3.1　为元素添加阴影：Ext.Shadow与Ext.ShadowPool / 418
8.3.2　为组件提供阴影和shim功能：Ext.Layer / 419
8.3.3　让组件实现浮动功能：Ext.util.Floating / 420
8.3.4　记录组件状态：Ext.state.Stateful / 420
8.3.5　实现调整大小功能：Ext.resizer.Resizer与Ext.resizer.ResizeTracker / 420
8.3.6　为组件提供拖动功能：Ext.util.ComponentDragger / 421
8.3.7　为组件实现动画功能：Ext.util.Animate / 422
8.3.8　其他的组件辅助功能类 / 423
8.4　组件的管理 / 423
8.4.1　组件管理及查询：Ext.ComponentManager与Ext.ComponentQuery / 423
8.4.2　焦点管理：Ext.FocusManager / 424
8.4.3　z-order管理：Ext.ZindexManager与Ext.WindowManager / 425
8.4.4　状态管理：Ext.state.Manager、Ext.state.Provider、Ext.state.Local-StorageProvider和Ext.state.CookieProvider / 426
8.5　综合实例 / 426
8.5.1　使用子模板 / 426
8.5.2　递归调用模板 / 428
8.6　本章小结 / 429
第9章　容器、面板、布局和视图 / 430
9.1　容器与布局的关系  / 430
9.2　容器 / 431
9.2.1　容器的创建过程：Ext.container.AbstractContainer与Ext.container.Container / 431
9.2.2　 Ext.container.AbstractContainer和Ext.container.Container的配置项、属性、方法和事件 / 434
9.2.3　将body元素作为容器：Ext.container.Viewport / 435
9.3　面板 / 436
9.3.1　面板的结构 / 436
9.3.2　构件的放置：dockedItems / 438
9.3.3　面板标题栏构件：Ext.panel.Header与Ext.panel.Tool / 438
9.3.4　记录和恢复面板属性：Ext.util.Memento / 439
9.3.5　面板常用的配置项、方法和事件 / 439
9.4　布局 / 441
9.4.1　布局概述 / 441
9.4.2　布局的运行流程：Ext.layout.Layout / 441
9.4.3　容器类布局基类：Ext.layout.container.Container / 442
9.4.4　盒子布局、垂直布局与水平布局：Ext.layout.container.Box、Ext.layout.container.VBox与Ext.layout.container.HBox / 442
9.4.5　为盒子模型提供调整大小的功能：Ext.resizer.Splitter / 445
9.4.6　手风琴布局：Ext.layout.container.Accordion / 447
9.4.7　锚固布局：Ext.layout.container.Anchor / 448
9.4.8　绝对定位布局：Ext.layout.container.Absolute / 450
9.4.9　边框布局：Ext.layout.container.Border / 451
9.4.10　自动布局：Ext.layout.container.Auto / 453
9.4.11　表格布局：Ext.layout.container.Table / 454
9.4.12　列布局：Ext.layout.container.Column / 455
9.4.13　自适应布局：Ext.layout.container.AbstractFit与Ext.layout.container.Fit / 456
9.4.14　卡片布局：Ext.layout.container.AbstractCard与Ext.layout.container.Card / 456
9.5　标签面板 / 458
9.5.1　标签面板的构成及其运行流程：Ext.tab.Panel、Ext.tab.Bar与Ext.tab.Tab / 458
9.5.2　标签面板的配置项、属性、方法和事件 / 462
9.5.3　使用标签页 / 463
9.5.4　可重用的标签页 / 465
9.6　视图与选择模型 / 465
9.6.1　视图与选择模型概述 / 465
9.6.2　视图的运行流程：Ext.view.AbstractView与Ext.view.View / 466
9.6.3　选择模型的工作流程 / 475
9.6.4　选择模型的配置项、属性、方法和事件 / 480
9.6.5　视图的配置项、属性、方法和事件 / 482
9.6.6　使用视图 / 484
9.7　页面布局设计 / 491
9.8　综合实例 / 492
9.8.1　布局设计实例：仿Eclipse界面 / 492
9.8.2　在单页面应用中使用卡片布局实现“页面”切换 / 496
9.9　本章小结 / 498
第10章　重构后的Grid / 500
10.1　Grid的基类及其构成 / 500
10.1.1　概述 / 500
10.1.2　表格面板的运行流程：Ext.panel.Table / 500
10.1.3　表格视图的运行流程：Ext.view.Table与Ext.view.TableChunker / 505
10.1.4　列标题容器的运行流程：Ext.grid.header.Container / 508
10.1.5　列标题的运行流程：Ext.grid.column.Column / 510
10.1.6　虚拟滚动条的工作原理：Ext.grid.PagingScroller / 511
10.1.7　锁定列的运行流程：Ext.grid.Lockable与Ext.grid.LockingView / 516
10.2　使用Grid / 520
10.2.1　最简单的Grid / 520
10.2.2　列的配置项 / 521
10.2.3　自定义单元格的显示格式 / 523
10.2.4　通过列对象定义单元格的显示格式 / 525
10.2.5　设置行的背景颜色 / 532
10.2.6　列标题的分组 / 533
10.2.7　使用锁定列 / 534
10.2.8　Grid的配置项、属性、方法和事件 / 535
10.3　Grid的附加功能 / 537
10.3.1　概述 / 537
10.3.2　附加功能基类：Ext.grid.featrue.Featrue / 537
10.3.3　为行添加附加信息：Ext.grid.featrue.RowBody / 538
10.3.4　数据汇总功能：Ext.grid.featrue.AbstractSummary与Ext.grid.featrue. Summary / 539
10.3.5　分组功能：Ext.grid.featrue.Grouping / 543
10.3.6　分组汇总功能：Ext.grid.featrue.GroupingSummary / 545
10.4　可编辑的Grid / 546
10.4.1　概述 / 546
10.4.2　Grid实现可编辑功能的运行流程：Ext.grid.plugin.Editing / 547
10.4.3　单元格编辑的运行流程：Ext.grid.plugin.CellEditing、Ext.grid.CellEditor与Ext.Editor / 550
10.4.4　行编辑的运行流程：Ext.grid.plugin.RowEditing与Ext.grid.RowEditor / 556
10.4.5　在Grid中使用单元格编辑模式 / 561
10.4.6　在Grid中使用行编辑模式 / 562
10.4.7　Grid编辑插件的配置项、属性、方法和事件 / 563
10.5　关于列表视图：ListView / 564
10.6　属性Grid / 564
10.6.1　概述 / 564
10.6.2　使用属性Grid / 564
10.6.3　自定义编辑组件 / 565
10.6.4　PropertyGrid的配置项、属性、方法和事件 / 566
10.7　综合实例 / 567
10.7.1　使用不同选择模型的Grid以及设置默认选择行 / 567
10.7.2　Grid的本地排序和过滤 / 569
10.7.3　使用分页工具条（PagingToolbar）实现远程分页、排序和过滤 / 570
10.7.4　使用分页滚动条（PagingScroller）实现远程分页、排序和过滤 / 574
10.7.5　使用CellEditing实现数据的增删改 / 578
10.7.6　使用RowEditing实现数据的增删改 / 587
10.7.7　主从表的显示 / 589
10.8　本章小结 / 595
第11章　与Grid同源的树 / 597
11.1　树的构成 / 597
11.1.1　概述 / 597
11.1.2　树面板的运行流程：Ext.tree.Panel / 597
11.1.3　TreeStore的运行流程：Ext.data.TreeStore / 600
11.1.4　TreeColumn的运行流程：Ext.tree.Column / 602
11.1.5　视图的运行流程：Ext.tree.View与Ext.data.NodeStore / 602
11.1.6　树的选择模型：Ext.selection.TreeModel / 603
11.2　树的使用 / 603
11.2.1　一个最简单的树 / 603
11.2.2　树节点的默认字段 / 603
11.2.3　为树节点添加附加字段 / 604
11.2.4　显示多列数据（TreeGrid效果） / 605
11.2.5　在树中使用复选框 / 605
11.2.6　树的配置项、属性、方法和事件 / 607
11.3　综合实例 / 608
11.3.1　树的远程加载 / 608
11.3.2　树的动态加载及节点维护 / 610
11.3.3　XML树及节点维护 / 617
11.3.4　使用树动态控制Grid的显示 / 622
11.4　本章小结 / 625
第12章　表单 / 626
12.1　表单的构成及操作 / 626
12.1.1　表单面板的运行流程：Ext.form.Panel与Ext.form.FieldAncestor / 626
12.1.2　表单面板的配置项、属性、方法和事件 / 628
12.1.3　表单的管理：Ext.form.Basic / 629
12.1.4　BasicForm的配置项、属性、方法和事件 / 635
12.1.5　表单的操作：Ext.form.action.Action / 636
12.1.6　加载操作的运行流程：Ext.form.action.Load与Ext.form.action.DirectLoad / 637
12.1.7　提交操作的运行流程：Ext.form.action.Submit、Ext.form.action.DirectSubmit与Ext.form.action.StandardSubmit / 641
12.1.8　字段的构成 / 643
12.1.9　BaseField的配置项、属性、方法和事件 / 643
12.1.10　常用的验证函数：Ext.form.field.VTypes / 647
12.2　使用字段 / 647
12.3　使用Trigger类字段 / 664
12.3.1　具有单击功能的字段：Ext.form.field.Trigger / 664
12.3.2　实现微调功能的Spinner字段 / 665
12.3.3　使用NumberField字段 / 666
12.3.4　下拉选择类字段的基类：Ext.form.field.Picker / 667
12.3.5　使用DateField字段 / 667
12.3.6　使用TimeField字段 / 669
12.4　使用ComboBox字段 / 669
12.4.1　概述 / 669
12.4.2　BoundList对象的运行流程 / 670
12.4.3　ComboBox字段的配置项、属性、方法和事件 / 671
12.4.4　最简单的ComboBox / 672
12.4.5　自定义列表显示格式的ComboBox / 673
12.4.6　动态调整ComboBox的列表数据 / 674
12.4.7　实现ComboBox的联动 / 676
12.4.8　使用ComboBox的查询功能 / 684
12.4.9　设置ComboBox的默认值 / 688
12.5　表单的验证和加载数据 / 690
12.5.1　表单的验证及错误显示方式 / 690
12.5.2　为表单加载数据 / 695
12.6　在表单中使用布局 / 701
12.6.1　分列显示表单的字段 / 701
12.6.2　使用Fieldset作为列容器 / 703
12.6.3　使用两列布局加HtmlEditor的表单 / 704
12.6.4　在表单中使用标签页 / 705
12.7　综合实例：实现Products表的管理功能 / 706
12.8　本章小结 / 715
第13章　窗口 / 716
13.1　窗口：Ext.window.Window. / 716
13.1.1　窗口的构成 / 716
13.1.2　窗口的配置项、属性、方法和事件 / 716
13.1.3　使用窗口 / 718
13.1.4　在窗口内使用布局 / 719
13.2　信息提示窗口：Ext.window.MessageBox / 720
13.2.1　概述 / 720
13.2.2　信息提示窗口的构成 / 720
13.2.3　使用信息提示窗口 / 722
13.2.4　信息提示窗口按钮的本地化 / 723
13.2.5　使用alert方法 / 724
13.2.6　使用confirm方法 / 724
13.2.7　使用progress方法 / 725
13.2.8　使用prompt方法 / 726
13.2.9　使用wait方法 / 727
13.2.10　使用信息提示窗口要注意的问题 / 727
13.3　综合实例：实现登录窗口 / 729
13.4　本章小结 / 733
第14章　按钮、菜单与工具条 / 734
14.1　按钮 / 734
14.1.1　按钮的构成：Ext.button.Button / 734
14.1.2　按钮的配置项、属性、方法和事件 / 734
14.1.3　使用按钮 / 736
14.1.4　带分割线的按钮：Ext.button.Split / 737
14.1.5　多状态按钮：Ext.button.Cycle / 737
14.1.6　按钮组：Ext.container.ButtonGroup / 738
14.2　菜单及菜单项 / 739
14.2.1　Ext JS的菜单（Menu对象）是什么 / 739
14.2.2　菜单管理器：Ext.menu.Manager / 740
14.2.3　菜单项：Ext.menu.Item / 740
14.2.4　可复选的菜单项：Ext.menu.CheckItem / 741
14.2.5　菜单分隔条：Ext.menu.Separator / 741
14.2.6　颜色选择器菜单：Ext.menu.ColorPicker / 742
14.2.7　日期选择菜单：Ext.menu.DatePicker / 742
14.2.8　使用菜单 / 742
14.3　工具栏及工具栏组件 / 743
14.3.1　工具栏：Ext.toolbar.Toolbar / 743
14.3.2　非交互式工具栏条目的基类：Ext.toolbar.Item / 743
14.3.3　文本项：Ext.toolbar.TextItem / 744
14.3.4　填充项：Ext.toolbar.Fill / 744
14.3.5　工具栏分隔条：Ext.toolbar.Separator / 744
14.3.6　空白项：Ext.toolbar.Spacer / 744
14.3.7　分页工具栏：Ext.toolbar.Paging / 744
14.3.8　使用工具栏 / 747
14.4　使用Ext.Action / 747
14.4.1　概述 / 747
14.4.2　Action对象配置项和方法 / 748
14.4.3　使用示例 / 748
14.5　综合实例：在Grid中使用右键菜单 / 750
14.6　本章小结 / 752
第15章　图形与图表 / 753
15.1　基础知识 / 753
15.1.1　SVG简介 / 753
15.1.2　VML简介 / 754
15.2　图形介绍 / 755
15.2.1　概述 / 755
15.2.2　画布的工作流程：Ext.draw.Component / 755
15.2.3　图形引擎及接口：Ext.draw.Surface、Ext.draw.engine.Svg和Ext.draw.engine.Vml / 757
15.2.4　画笔：Ext.draw.Sprite / 760
15.2.5　图层：Ext.draw.CompositeSprite / 760
15.2.6　调色板：Ext.draw.Color / 760
15.2.7　辅助对象：Ext.draw.Draw与Ext.draw.Matrix / 760
15.3　使用图形功能 / 760
15.3.1　简单的开始 / 760
15.3.2　DrawComponent对象的配置项、属性、方法和事件 / 761
15.3.3　Surface对象的配置项、属性、方法和事件 / 761
15.3.4　DrawSprite对象的配置项、属性、方法和事件 / 762
15.3.5　CompositeSprite对象的配置项、属性、方法和事件 / 763
15.3.6　使用基本图形 / 764
15.3.7　使用图片 / 765
15.3.8　使用路径 / 766
15.3.9　移动、旋转和缩放图形 / 767
15.3.10　使用渐变效果 / 770
15.3.11　使用图层 / 771
15.4　图表介绍 / 772
15.4.1　概述 / 772
15.4.2　图表的工作流程 / 773
15.5　使用图表 / 776
15.5.1　从一个简单例子开始 / 776
15.5.2　坐标轴的配置项 / 777
15.5.3　Series对象的配置项、属性、方法和事件 / 779
15.5.4　折线图的配置项 / 780
15.5.5　显示多个折线图及使用图例 / 782
15.5.6　使用面积图 / 783
15.5.7　简单条形图（Bar和Column Chart）及使用标签（Label对象） / 785
15.5.8　堆积条形图 / 787
15.5.9　分组条形图 / 788
15.5.10　自定义条形颜色 / 789
15.5.11　使用散点图 / 789
15.5.12　使用饼图 / 791
15.5.13　自定义饼块颜色 / 792
15.5.14　使用表盘图 / 792
15.5.15　使用雷达图 / 795
15.5.16　使用时间轴 / 796
15.5.17　实现实时动态的图表 / 797
15.5.18　使用组合图 / 800
15.5.19　在图表中使用背景 / 801
15.5.20　在图表中自定义主题 / 803
15.6　本章小结 / 805
第16章　其他组件及实用功能 / 806
16.1　其他组件 / 806
16.2　使用滑块 / 812
16.3　使用提示信息 / 814
16.4　实用功能 / 822
16.5　本章小结 / 826
第17章　可简化通信的Ext.Direct / 827
17.1　准备工作 / 827
17.2　Ext.Direct的工作原理及构成 / 827
17.2.1　工作原理 / 827
17.2.2　Ext.Direct的构成 / 828
17.2.3　RemotingProvider对象的具体工作流程 / 829
17.2.4　PollingProvider对象的具体工作流程 / 838
17.3　配置Ext.Direct的使用环境 / 839
17.3.1　概述 / 839
17.3.2　.NET环境的配置 / 839
17.3.3　Java环境的配置 / 842
17.4　使用Ext.Direct / 846
17.4.1　概述 / 846
17.4.2　使用DirectProxy及进行CURD操作 / 846
17.4.3　使用Ext.Direct实现树的动态加载及节点维护 / 854
17.4.4　使用DirectLoad为表单加载数据 / 858
17.4.5　使用DirectSubmit提交表单及使用Session / 863
17.4.6　使用Ext.Direct上传文件 / 866
17.4.7　使用PollingProvider对象 / 868
17.4.8　错误处理 / 871
17.5　本章小结 / 872
第18章　动画功能 / 873
18.1　动画功能的构成及工作流程 / 873
18.1.1　概述 / 873
18.1.2　动画功能的工作流程：Ext.fx.Anim / 874
18.1.3　分步动画的工作流程：Ext.fx.Animator / 877
18.2　使用动画 / 880
18.2.1　由最简单的动画开始 / 880
18.2.2　过渡效果使用的功能函数介绍 / 880
18.2.3　使用分步动画 / 882
18.2.4　注意的问题 / 883
18.3　在Element对象中使用动画 / 883
18.4　本章小结 / 888
第19章　拖放功能 / 889
19.1　拖放功能的构成及工作流程 / 889
19.1.1　概述 / 889
19.1.2　DragDropManager对象的工作流程 / 891
19.1.3　注册节点：Ext.dd.Registry / 893
19.1.4　一般拖动功能的工作流程：Ext.dd.DD / 894
19.1.5　DragSource对象的工作流程 / 897
19.1.6　DropTarget对象的工作流程 / 898
19.1.7　DragZone对象的工作流程 / 899
19.1.8　DropZone对象的工作流程 / 899
19.2　使用拖放功能 / 899
19.2.1　最简单的拖动效果 / 899
19.2.2　使用DragSource对象与DropTarget对象 / 900
19.2.3　使用DragZone对象与DropZone对象（使用Registry对象） / 902
19.2.4　使用DragZone对象与DropZone对象（不使用Registry对象） / 903
19.2.5　通过拖动实现节点排序 / 904
19.2.6　使用GridViewDropZonePlugin插件 / 905
19.2.7　使用TreeViewDragDropPlugin插件 / 907
19.2.8　关于Grid和Tree拖动后的数据保存问题 / 910
19.3　本章小结 / 910
第20章　扩展与插件 / 911
20.1　扩展与插件的区别 / 911
20.2　扩展与插件如何选择 / 911
20.3　如何编写扩展 / 911
20.3.1　命名空间 / 911
20.3.2　定义扩展 / 912
20.3.3　定义别名 / 912
20.3.4　定义备用名 / 912
20.3.5　要求加载的类：requires与uses / 912
20.3.6　混入功能 / 913
20.3.7　构造函数与initComponent方法 / 913
20.3.8　静态属性和方法与单件模式 / 913
20.3.9　可自动生成set和get方法的属性与initConfig方法 / 914
20.3.10　在扩展中常用的方法 / 914
20.3.11　编写扩展：TreeComboBox / 914
20.4　如何编写插件 / 920
20.4.1　概述 / 920
20.4.2　AbstractPlugin对象 / 921
20.4.3　插件的别名 / 921
20.4.4　编写插件：RowColor / 922
20.5　扩展和插件介绍 / 923
20.5.1　概述 / 923
20.5.2　本地分页代理：Ext.ux.data.PagingMemoryProxy / 923
20.5.3　标签滚动菜单：Ext.ux.TabScrollerMenu / 925
20.5.4　编辑器TinyMCE / 926
20.6　本章小结 / 928
第21章　主题开发 / 929
21.1　准备工作 / 929
21.1.1　安装Ruby / 929
21.1.2　安装Compass / 930
21.1.3　SASS介绍 / 931
21.2　为Ext JS 4创建新主题 / 933
21.2.1　概述 / 933
21.2.2　目录结构 / 933
21.2.3　修改配置 / 933
21.2.4　编译 / 935
21.2.5　测试主题 / 935
21.3　通过ui配置项设置组件样式 / 937
21.4　本章小结 / 937
第22章　MVC应用架构 / 938
22.1　MVC应用架构的构成及工作流程 / 938
22.1.1　构成 / 938
22.1.2　控制器的工作流程：Ext.app.Controller / 938
22.1.3　Application对象的工作流程 / 940
22.2　一步一步实现MVC框架 / 942
22.2.1　概述 / 942
22.2.2　创建目录 / 942
22.2.3　创建首页 / 942
22.2.4　创建启动脚本：app.js / 943
22.2.5　定义登录对话框 / 944
22.2.6　创建应用脚本：Application.js / 948
22.2.7　创建Viewport视图 / 949
22.2.8　菜单视图及控制器 / 950
22.2.9　实现订单管理 / 952
22.2.10　实现产品管理 / 958
22.2.11　示例效果 / 969
22.3　本章小结 / 970
附录　简写类名与Ext JS类名对照表 / 971
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Ext JS权威指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>敏捷软件开发
《敏捷软件开发：原则、模式与实践(c#版·修订版)》
第一部分　敏捷开发
第1章　敏捷实践　3
1.1　敏捷联盟　4
1.1.1　人和交互重于过程和工具　4
1.1.2　可以工作的软件重于面面俱到的文档　5
1.1.3　客户合作重于合同谈判　5
1.1.4　随时应对变化重于遵循计划　6
1.2　原则　6
1.3　结论　8
1.4　参考文献　8
第2章　极限编程概述　9
2.1　极限编程实践　9
2.1.1　完整团队　9
2.1.2　用户故事　10
2.1.3　短交付周期　10
2.1.4　验收测试　10
2.1.5　结对编程　11
2.1.6　测试驱动开发　11
2.1.7　集体所有　12
.2.1.8　持续集成　12
2.1.9　可持续的开发速度　12
2.1.10　开放的工作空间　13
2.1.11　计划游戏　13
2.1.12　简单设计　13
2.1.13　重构　14
2.1.14　隐喻　14
2.2　结论　15
2.3　参考文献　15
第3章　计划　16
3.1　初始探索　17
3.2　发布计划　17
3.3　迭代计划　18
3.4　定义“完成”　18
3.5　任务计划　18
3.6　迭代　19
3.7　跟踪　19
3.8　结论　20
3.9　参考文献　21
第4章　测试　22
4.1　测试驱动开发　22
4.1.1　优先设计测试的例子　23
4.1.2　测试促使模块之间隔离　24
4.1.3　意外获得的解耦合　25
4.2　验收测试　26
4.3　意外获得的构架　27
4.4　结论　27
4.5　参考文献　28
第5章　重构　29
5.1　素数产生程序：一个简单的重构示例　30
5.1.1　单元测试　31
5.1.2　重构　32
5.1.3　最后审视　35
5.2　结论　38
5.3　参考文献　39
第6章　一次编程实践　40
6.1　保龄球比赛　40
6.2　结论　75
第二部分　敏捷设计
第7章　什么是敏捷设计　81
7.1　设计臭味　81
7.1.1　设计臭味——腐化软件的气味　82
7.1.2　僵化性　82
7.1.3　脆弱性　82
7.1.4　顽固性　82
7.1.5　粘滞性　82
7.1.6　不必要的复杂性　83
7.1.7　不必要的重复　83
7.1.8　晦涩性　83
7.2　软件为何会腐化　84
7.3　copy程序　84
7.3.1　熟悉的场景　84
7.3.2　copy程序的敏捷设计　87
7.4　结论　88
7.5　参考文献　88
第8章　srp：单一职责原则　89
8.1　定义职责　90
8.2　分离耦合的职责　91
8.3　持久化　92
8.4　结论　92
8.5　参考文献　92
第9章　ocp：开放-封闭原则　93
9.1　ocp概述　94
9.2　shape应用程序　95
9.2.1　违反ocp　95
9.2.2　遵循ocp　97
9.2.3　预测变化和“贴切的”结构　98
9.2.4　放置吊钩　99
9.2.5　使用抽象获得显式封闭　99
9.2.6　使用“数据驱动”的方法获取封闭性　100
9.3　结论　101
9.4　参考文献　101
第10章　lsp：liskov替换原则　102
10.1　违反lsp的情形　103
10.1.1　简单例子　103
10.1.2　更微妙的违反情形　104
10.1.3　实际的例子　108
10.2　用提取公共部分的方法代替继承　111
10.3　启发式规则和习惯用法　113
10.4　结论　114
10.5　参考文献　114
第11章　dip：依赖倒置原则　115
11.1　层次化　116
11.1.1　倒置的接口所有权　117
11.1.2　依赖于抽象　117
11.2　简单的dip示例　117
11.3　熔炉示例　119
11.4　结论　121
11.5　参考文献　121
第12章　isp：接口隔离原则　122
12.1　接口污染　122
12.2　分离客户就是分离接口　123
12.3　类接口与对象接口　124
12.3.1　使用委托分离接口　124
12.3.2　使用多重继承分离接口　125
12.4　atm用户界面的例子　126
12.5　结论　131
12.6　参考文献　131
第13章　写给c#程序员的uml概述　132
13.1　类图　134
13.2　对象图　135
13.3　顺序图　136
13.4　协作图　136
13.5　状态图　137
13.6　结论　137
13.7　参考文献　137
第14章　使用uml　138
14.1　为什么建模　138
14.1.1　为什么构建软件模型　139
14.1.2　编码前应该构建面面俱到的设计吗　139
14.2　有效使用uml　139
14.2.1　与他人交流　139
14.2.2　脉络图　141
14.2.3　项目结束文档　142
14.2.4　要保留的和要丢弃的　142
14.3　迭代式改进　143
14.3.1　行为优先　143
14.3.2　检查结构　144
14.3.3　想象代码　146
14.3.4　图的演化　147
14.4　何时以及如何绘制图示　147
14.4.1　何时要画图，何时不要画图　147
14.4.2　case 工具　148
14.4.3　那么，文档呢　149
14.5　结论　149
第15章　状态图　150
15.1　基础知识　150
15.1.1　特定事件　151
15.1.2　超状态　152
15.1.3　初始伪状态和结束伪状态　153
15.2　使用fsm图示　153
15.3　结论　154
第16章　对象图　155
16.1　即时快照　155
16.2　主动对象　156
16.3　结论　159
第17章　用例　160
17.1　编写用例　160
17.1.1　备选流程　161
17.1.2　其他东西呢　161
17.2　用例图　162
17.3　结论　162
17.4　参考文献　162
第18章　顺序图　163
18.1　基础知识　163
18.1.1　对象、生命线、消息及其他　164
18.1.2　创建和析构　164
18.1.3　简单循环　165
18.1.4　时机和场合　166
18.2　高级概念　168
18.2.1　循环和条件　168
18.2.2　耗费时间的消息　169
18.2.3　异步消息　171
18.2.4　多线程　174
18.2.5　主动对象　175
18.2.6　向接口发送消息　175
18.3　结论　175
第19章　类图　177
19.1　基础知识　177
19.1.1　类　177
19.1.2　关联　178
19.1.3　继承　179
19.2　类图示例　180
19.3　细节　181
19.3.1　类衍型　181
19.3.2　抽象类　182
19.3.3　属性　183
19.3.4　聚集　183
19.3.5　组合　184
19.3.6　多重性　185
19.3.7　关联衍型　186
19.3.8　内嵌类　187
19.3.9　关联类　187
19.3.10　关联修饰符　187
19.4　结论　188
19.5　参考文献　188
第20章　咖啡的启示　189
20.1　mark iv型专用咖啡机　189
20.1.1　规格说明书　190
20.1.2　常见的丑陋方案　192
20.1.3　虚构的抽象　193
20.1.4　改进方案　194
20.1.5　实现抽象模型　198
20.1.6　这个设计的好处　209
20.2　面向对象过度设计　214
20.3　参考文献　214
第三部分　薪水支付案例研究
第21章　command模式和active object模式：多功能与多任务　219
21.1　简单的command　220
21.2　事务　221
21.2.1　实体上解耦和时间上解耦　222
21.2.2　时间上解耦　223
21.3　undo()方法　223
21.4　active object模式　224
21.5　结论　227
21.6　参考文献　228
第22章　template method模式和strategy模式：继承和委托　229
22.1　template method模式　230
22.1.1　滥用模式　232
22.1.2　冒泡排序　232
22.2　strategy模式　235
22.3　结论　239
22.4　参考文献　239
第23章　facade模式和mediator模式　240
23.1　facade模式　240
23.2　mediator模式　241
23.3　结论　243
23.4　参考文献　243
第24章　singleton模式和monostate模式　244
24.1　singleton模式　245
24.1.1　singleton模式的好处　246
24.1.2　singleton模式的代价　246
24.1.3　运用singleton模式　246
24.2　monostate模式　247
24.2.1　monostate模式的好处　249
24.2.2　monostate模式的代价　249
24.2.3　运用monostate模式　249
24.3　结论　253
24.4　参考文献　253
第25章　null object模式　254
25.1　描述　254
25.2　结论　256
25.3　参考文献　256
第26章　薪水支付案例研究：第一次迭代开始　257
26.1　初步的规格说明　257
26.2　基于用例分析　258
26.2.1　增加新雇员　259
26.2.2　删除雇员　260
26.2.3　登记考勤卡　260
26.2.4　登记销售凭条　260
26.2.5　登记工会服务费　261
26.2.6　更改雇员明细　261
26.2.7　发薪日　263
26.3　反思：找出底层的抽象　264
26.3.1　雇员支付类别抽象　264
26.3.2　支付时间表抽象　265
26.3.3　支付方式　266
26.3.4　从属关系　266
26.4　结论　266
26.5　参考文献　267
第27章　薪水支付案例研究：实现　268
27.1　事务　268
27.1.1　增加雇员　269
27.1.2　删除雇员　273
27.1.3　考勤卡、销售凭条以及服务费用　274
27.1.4　更改雇员属性　280
27.1.5　犯了什么晕　287
27.1.6　支付雇员薪水　290
27.1.7　支付领月薪的雇员薪水　292
27.1.8　支付钟点工薪水　294
27.2　主程序　302
27.3　数据库　303
27.4　结论　304
27.5　关于本章　304
27.6　参考文献　305
第四部分　打包薪水支付系统
第28章　包和组件的设计原则　308
28.1　包和组件　308
28.2　组件的内聚性原则：粒度　309
28.2.1　重用-发布等价原则　309
28.2.2　共同重用原则　310
28.2.3　共同封闭原则　311
28.2.4　组件内聚性总结　311
28.3　组件的耦合性原则：稳定性　311
28.3.1　无环依赖原则　311
28.3.2　稳定依赖原则　316
28.3.3　稳定抽象原则　319
28.4　结论　322
第29章　factory模式　323
29.1　依赖问题　325
29.2　静态类型与动态类型　326
29.3　可替换的工厂　326
29.4　对测试支架使用对象工厂　327
29.5　工厂的重要性　328
29.6　结论　329
29.7　参考文献　329
第30章　薪水支付案例研究：包分析　330
30.1　组件结构和符号　330
30.2　应用ccp　332
30.3　应用rep　333
30.4　耦合和封装　335
30.5　度量　336
30.6　度量薪水支付应用程序　337
30.6.1　对象工厂　340
30.6.2　重新思考内聚的边界　342
30.7　最终的包结构　342
30.8　结论　345
30.9　参考文献　345
第31章　composite模式　346
31.1　组合命令　347
31.2　多重性还是非多重性　348
31.3　结论　348
第32章　observer——演化至模式　349
32.1　数字时钟　350
32.2　observer模式　365
32.2.1　模型　365
32.2.2　面向对象设计原则的运用　366
32.3　结论　366
32.4　参考文献　367
第33章　abstract server模式、 adapter模式和bridge模式　368
33.1　abstract server模式　369
33.2　adapter模式　370
33.2.1　类形式的adapter模式　370
33.2.2　调制解调器问题、适配器以及lsp　370
33.3　bridge模式　374
33.4　结论　375
33.5　参考文献　376
第34章　proxy模式和gateway模式：管理第三方api　377
34.1　proxy模式　377
34.1.1　实现proxy模式　381
34.1.2　小结　391
34.2　数据库、中间件以及其他第三方接口　392
34.3　table data gateway　394
34.3.1　测试和内存tdg　399
34.3.2　测试dbgateway　400
34.4　可以用于数据库的其他模式　403
34.5　结论　404
34.6　参考文献　404
第35章　visitor模式　405
35.1　visitor模式　406
35.2　acyclic visitor模式　409
35.3　decorator模式　418
35.4　extension object模式　423
35.5　结论　432
35.6　参考文献　432
第36章　state模式　433
36.1　嵌套switch/case语句　434
36.1.1　内部作用域的状态变量　436
36.1.2　测试动作　436
36.1.3　代价和收益　436
36.2　迁移表　437
36.2.1　使用表解释　437
36.2.2　代价和收益　438
36.3　state模式　439
36.3.1　state模式和strategy模式　441
36.3.2　代价和收益　442
36.4　状态机编译器　442
36.4.1　smc生成的turnstile.cs以及其他支持文件　443
36.4.2　代价和收益　448
36.5　状态机应用的场合　448
36.5.1　作为gui中的高层应用策略　448
36.5.2　gui交互控制器　450
36.5.3　分布式处理　450
36.6　结论　451
36.7　参考文献　451
第37章　薪水支付案例研究：数据库　452
37.1　构建数据库　452
37.2　一个代码设计缺陷　453
37.3　增加雇员　455
37.4　事务　464
37.5　加载employee对象　468
37.6　还有什么工作　478
第38章　薪水支付系统用户界面：model-view-presenter　479
38.1　界面　480
38.2　实现　481
38.3　构建窗口　489
38.4　payroll窗口　495
38.5　真面目　504
38.6　结论　505
38.7　参考文献　505
附录a　双公司记　506
rufus公司：“日落”项目　506
rupert工业公司：“朝阳”项目　506
附录b　什么是软件　516
索引　524
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>敏捷软件开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计原本
I Models of Designing  1
Chapter 1  The Design Question（新增评注19条）  3
Chapter 2  How Engineers Think of Design—The Rational Model（新增评注10条）  13
Chapter 3  What’s Wrong with This Model?（新增评注29条）  21
Chapter 4  Requirements, Sin, and Contracts（新增评注12条）  39
Chapter 5  What Are Better Design Process Models?（新增评注13条）  51
II Collaboration and Telecollaboration（新增评注1条）  61
Chapter 6  Collaboration in Design（新增评注42条）  63
Chapter 7  Telecollaboration（新增评注16条）  89
III Design Perspectives  103
Chapter 8  Rationalism versus Empiricism in Design（新增评注11条）  105
Chapter 9  User Models—Better Wrong than Vague（新增评注8条）  113
Chapter 10  Inches, Ounces, Bits, Dollars—The Budgeted Resource（新增评注10条）  119
Chapter 11  Constraints Are Friends（新增评注16条）  127
Chapter 12  Esthetics and Style in Technical Design（新增评注26条）  139
Chapter 13  Exemplars in Design（新增评注26条）  153
Chapter 14  How Expert Designers Go Wrong（新增评注18条）  167
Chapter 15  The Divorce of Design（新增评注13条）  175
Chapter 16  Representing Designs’ Trajectories and Rationales（新增评注28条）  185
IV  A Computer Scientist’s Dream System for Designing Houses  201
Chapter 17  A Computer Scientist’s Dream System for Designing Houses—Mind to Machine（新增评注35条）  203
Chapter 18  A Computer Scientist’s Dream System for Designing Houses—Machine to Mind（新增评注17条）  219
V  Great Designers  229
Chapter 19  Great Designs Come from Great Designers（新增评注27条）  231
Chapter 20  Where Do Great Designers Come From?（新增评注28条）  243
VI  Trips through Design Spaces: Case Studies（新增评注1条）  257
Chapter 21  Case Study: Beach House “View/360”（新增评注19条）  259
Chapter 22  Case Study: House Wing Addition（新增评注14条）  279
Chapter 23  Case Study: Kitchen Remodeling（新增评注10条）  297
Chapter 24  Case Study: System/360 Architecture（新增评注18条）  313
Chapter 25  Case Study: IBM Operating System/360（新增评注14条）  331
Chapter 26  Case Study: Book Design of Computer Architecture: Concepts and Evolution（新增评注7条）  347
Chapter 27  Case Study: A Joint Computer Center Organization: Triangle Universities Computation Center（新增评注11条）  355
Chapter 28  Recommended Reading（新增评注8条）  367
Acknowledgments  371
Bibliography  375
People Index  393
Subject Index  401
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计原本
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Framework的设计与应用
第1章 设计模式与开发模式
第2章 .NET Framework 2.0概论
第3章 ADO.NET 2.0
第4章 Windows Forms
第5章 .NET Remoting
第6章 Framework架构
第7章 Configuration Framework
第8章 Plug-ln Framework
第9章 Cache Framework
第10章 Business Logic Framework
第11章 Factory Framework
第12章 Data Connection Framework
第13章 Settings Framework
第14章 设计Domain Application Framework
第15章 来实现吧，小型进销存系统
第16章 UI的设计
第17章 报表
第18章 回顾与展望
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Framework的设计与应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Delphi模式编程
第一部分  模式编程原理
第一章  模式概述
第二章  Delphi的模式编程机制
第三章  模式编程法则
第二部分  创建型模式编程
第四章  工厂方法模式
第五章  抽象工厂模式
第六章  建造者模式
第七章  单例模式
第八章  原型模式
第三部分  结构型模式编程
第九章  适配器模式
第十章  桥接模式
第十一章  合成模式
第十二章  装饰者模式
第十三章  门面模式
第十四章  享元模式
第十五站 代理模式
第四部分  行为型模式编程
第十六章  责任链模式
第十七章  命令模式
第十八章  解释器模式
第十九章  迭代子模式
第二十章  中介者模式
第二十一章  备忘录模式
第二十二章  观察者模式
第二十三章  状态模式
第二十四章  策略模式
第二十五章  模板方法模式
第二十六章  访问者模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Delphi模式编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>PHP框架高级编程
目录
第1章 Symfony、CakePHP和Zend Framework简介 1
1.1 Web应用程序框架的定义及其用法 1
1.1.1 框架与库 2
1.1.2 使用框架的时机 3
1.1.3 PHP与其他编程语言 4
1.2 开源PHP Web框架 5
1.2.1 公众关注的框架对比 5
1.2.2 3种框架概述 7
1.2.3 其他框架 9
1.3 Web框架中的设计模式 13
1.3.1 设计模式的定义 13
1.3.2 模型-视图-控制器作为主要的结构设计模式 14
1.3.3 其他设计模式概述 15
第2章 框架入门 27
2.1 配置要求 27
2.1.1 XAMPP 28
2.1.2 Apache 31
2.1.3 数据库 32
2.1.4 PEAR 33
2.1.5 Subversion(SVN) 34
2.1.6 安装概述 34
2.2 安装 35
2.2.1 Symfony 35
2.2.2 CakePHP 37
2.2.3 Zend Framework 38
2.3 配置 39
2.3.1 Symfony 39
2.3.2 CakePHP 39
2.3.3 Zend Framework 40
2.4 Hello World应用程序 40
2.4.1 Symfony 40
2.4.2 CakePHP 42
2.4.3 Zend Framework 43
2.5 结构 45
2.5.1 Symfony 45
2.5.2 CakePHP 47
2.5.3 Zend Framework 48
2.6 IDE支持 49
2.6.1 NetBeans 50
2.6.2 Eclipse 50
2.6.3 Zend Studio 51
第3章 使用数据库 53
3.1 对象关系映射 53
3.1.1 对象关系阻抗误配 54
3.1.2 Propel 56
3.1.3 Doctrine 56
3.1.4 CakePHP的ORM 57
3.1.5 Zend_Db 57
3.1.6 其他ORM解决方案 59
3.2 数据库配置 59
3.2.1 开放数据库互连(ODBC) 60
3.2.2 SQLite 60
3.2.3 PostgreSQL 62
3.2.4 MySQL 63
3.2.5 Microsoft SQL Server 65
3.2.6 Oracle 68
3.2.7 DB2 69
3.3 与数据库通信 70
3.3.1 模式 71
3.3.2 固件 76
3.3.3 命令行接口 80
第4章 使用3种框架的第一个应用程序 85
4.1 设计 85
4.2 Symfony 87
4.2.1 项目 87
4.2.2 模型 88
4.2.3 控制器 88
4.2.4 视图 91
4.3 CakePHP 96
4.3.1 项目 96
4.3.2 模型 97
4.3.3 控制器 98
4.3.4 视图 100
4.4 Zend Framework 105
4.4.1 项目 105
4.4.2 模型 106
4.4.3 控制器 113
4.4.4 视图 118
第5章 窗体 125
5.1 字段验证 125
5.1.1 窗体验证的运行过程 126
5.1.2 Symfony 128
5.1.3 CakePHP 133
5.1.4 Zend Framework 136
5.2 定制窗体 138
5.2.1 Symfony 139
5.2.2 CakePHP 149
5.2.3 Zend Framework 154
5.3 使用Captcha防止接收垃圾邮件 163
5.3.1 问题 163
5.3.2 解决方案 165
第6章 邮件 175
6.1 创建邮件应用程序 175
6.1.1 发送邮件的方法和Web服务器 176
6.1.2 PHP配置 176
6.1.3 SMTP服务器配置 177
6.2 SwiftMailer 178
6.2.1 Symfony 178
6.2.2 CakePHP 184
6.2.3 Zend Framework 187
6.3 CakePHP的邮件组件 189
6.3.1 发送简单的电子邮件 190
6.3.2 发送HTML电子邮件 191
6.3.3 添加附件 191
6.3.4 抄送 192
6.3.5 远程SMTP服务器 192
6.3.6 安全连接 192
6.3.7 小结 193
6.4 Zend邮件程序 194
6.4.1 发送简单的电子邮件 194
6.4.2 发送HTML电子邮件 194
6.4.3 添加附件 195
6.4.4 抄送 195
6.4.5 远程SMTP服务器 196
6.4.6 安全连接 196
6.4.7 小结 197
6.5 PHPMailer 197
6.5.1 Symfony 198
6.5.2 CakePHP 198
6.5.3 Zend Framework 199
第7章 搜索 203
7.1 问题 203
7.1.1 全文本搜索 204
7.1.2 索引 204
7.1.3 搜索查询 205
7.2 解决方案 206
7.2.1 Sphinx 206
7.2.2 Lucene 213
7.2.3 Google Custom Search 218
第8章 安全 221
8.1 设置安全连接 221
8.1.1 问题 222
8.1.2 配置Web服务器 223
8.1.3 Symfony 226
8.1.4 CakePHP 228
8.1.5 Zend Framework 228
8.2 保护配置文件窗体免受XSS
和注入攻击 229
8.2.1 问题 229
8.2.2 解决方案 231
8.3 CSRF 234
8.3.1 问题 234
8.3.2 解决方案 235
第9章 模板 239
9.1 使用辅助类和Lightbox创建简单的图像库 239
9.1.1 表示层辅助类 241
9.1.2 Lightbox 242
9.1.3 Symfony 242
9.1.4 CakePHP 245
9.1.5 Zend Framework 247
9.2 在Web框架中使用模板引擎 249
9.2.1 Smarty 250
9.2.2 Dwoo 255
9.2.3 Twig 258
9.3 其他增件模板引擎概述 260
9.3.1 Template Blocks 260
9.3.2 Open Power Template (OPT) 261
9.3.3 TinyButStrong 262
9.3.4 Rain TPL 264
9.3.5 Savant 265
第10章 AJAX 269
10.1 AJAX简介 270
10.2 自动完成 272
10.2.1 Symfony 272
10.2.2 CakePHP 274
10.2.3 Zend Framework 277
10.3 动态弹出窗口 283
10.3.1 Symfony 283
10.3.2 CakePHP 288
10.3.3 Zend Framework 291
10.4 与AJAX用户聊天 293
10.4.1 Symfony 294
10.4.2 CakePHP 297
10.4.3 Zend Framework 300
第11章 创建插件 305
11.1 Symfony 305
11.1.1 插件结构 306
11.1.2 开发插件 306
11.1.3 测试插件 308
11.2 CakePHP 309
11.2.1 插件结构 309
11.2.2 开发插件 310
11.2.3 测试插件 312
11.3 Zend Framework 313
第12章 Web服务 315
12.1 REST风格的新闻阅读 315
12.1.1 REST的工作原理 316
12.1.2 Symfony 317
12.1.3 CakePHP 320
12.1.4 Zend Framework 323
12.2 在电子商务应用程序中应用SOAP Web服务 329
12.2.1 为PHP安装SOAP扩展 330
12.2.2 使用soapUI进行测试 330
12.2.3 SOAP和REST之间的不同 330
12.2.4 Symfony 331
12.2.5 CakePHP 337
12.2.6 Zend Framework 340
第13章 后端 343
13.1 Symfony 343
13.1.1 Doctrine管理模块 344
13.1.2 Apostrophe 346
13.1.3 Diem 347
13.2 CakePHP 349
13.2.1 Croogo 349
13.2.2 Wildflower 351
13.3 Zend Framework 352
13.3.1 TomatoCMS 352
13.3.2 Pimcore 352
13.3.3 Digitalus CMS 354
13.4 功能总结 355
第14章 国际化 357
14.1 国际化的定义 357
14.2 Symfony 358
14.2.1 配置 358
14.2.2 模板 359
14.2.3 窗体 363
14.2.4 为i18n使用数据库 364
14.2.5 增件 365
14.3 CakePHP 366
14.3.1 配置 366
14.3.2 模板 367
14.3.3 窗体 369
14.3.4 为i18n使用数据库 370
14.3.5 增件 374
14.4 Zend Framework 374
14.4.1 配置 374
14.4.2 转换 376
14.4.3 窗体 376
14.4.4 为i18n使用数据库 378
14.4.5 增件 378
第15章 测试 379
15.1 测试简介 379
15.1.1 如何开始测试 380
15.1.2 测试用例、测试套件和测试覆盖率 380
15.1.3 测试的种类 381
15.1.4 何时结束测试 384
15.1.5 bug是我们的朋友 385
15.1.6 固件 387
15.1.7 仿制品 387
15.1.8 测试驱动的开发 388
15.1.9 测试框架 389
15.2 使用功能测试进行黑盒注册窗体测试 391
15.2.1 问题 392
15.2.2 解决方案 392
15.3 使用Selenium实现CMS测试自动化 397
15.3.1 安装Selenium IDE 397
15.3.2 安装Selenium Remote Control 398
15.3.3 问题 399
15.3.4 解决方案 400
15.4 邮件单元测试 407
15.4.1 问题 407
15.4.2 解决方案 409
第16章 用户管理 415
16.1 基本用户管理 415
16.1.1 RBAC和ACL 415
16.1.2 Symfony 417
16.1.3 CakePHP 426
16.1.4 Zend Framework 431
16.2 使用LDAP实现确定用户 435
16.2.1 需求 435
16.2.2 LDAP的运行原理 437
16.2.3 准备LDAP 437
16.2.4 LDAP配置 438
16.2.5 解决方案 451
第17章 性能 459
17.1 使用JMeter进行压力测试、负载测试和性能测试 459
17.2 基准测试 463
17.2.1 Hello World 463
17.2.2 简单的CRUD应用程序 464
17.3 开发速度 464
第18章 总结 465
18.1 功能 465
18.1.1 Symfony 465
18.1.2 CakePHP 467
18.1.3 Zend Framework 467
18.1.4 功能表 468
18.2 获胜者是… 469
附录A Web资源 471
附录B CodeIgniter、Lithium和Agavi
的代码示例 477
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>PHP框架高级编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>领域驱动设计C# 2008实现
第1章 介绍项目：SmartGA系统　1.1 问题　1.2 设计　　1.2.1 可靠性和可得性　　1.2.2 伸缩性　　1.2.3 可维护性　　1.2.4 富客户应用功能　　1.2.5 离线可得　　1.2.6 Web访问　　1.2.7 智能安装和自动更新功能　　1.2.8 附加客户设备支持　1.3 解决方案　　1.3.1 满足可靠性、可得性、伸缩性、离线可得和附加客户设备支持需求　　1.3.2 满足可维护性需求　　1.3.3 满足富客户应用功能需求　　1.3.4 满足Web访问需求　　1.3.5 满足智能安装和自动更新功能需求　1.4 总结第2章 设计分层架构　2.1 问题　2.2 设计　　2.2.1 设计Visual Studio解决方案　　2.2.2 设计基础设施层　2.3 解决方案　　2.3.1 实现Visual Studio解决方案　　2.3.2 实现架构层　2.4 总结第3章 管理项目　3.1 问题　3.2 设计　　3.2.1 设计领域模型　　3.2.2 定义项目聚合　　3.2.3 定义聚合边界　　3.2.4 设计仓储　　3.2.5 编写单元测试　3.3 解决方案　　3.3.1 Project类　　3.3.2 实现仓储　　3.3.3 实现服务类　　3.3.4 实现项目信息视图模型　　3.3.5 实现项目信息视图　3.4 总结第4章 公司和联系人　4.1 问题　4.2 设计　　4.2.1 设计领域模型　　4.2.2 定义Company聚合和Contact聚合　　4.2.3 定义聚合边界　　4.2.4 设计仓储　　4.2.5 编写单元测试　4.3 解决方案　　4.3.1 Company类　　4.3.2 Contact类　　4.3.3 ProjectContact类　　4.3.4 实现仓储　　4.3.5 实现服务类　　4.3.6 Company视图模型　　4.3.7 Company视图　　4.3.8 项目联系人视图模型　　4.3.9 项目联系人视图　4.4 总结第5章 递交传送　5.1 问题　5.2 设计　　5.2.1 设计领域模型　　5.2.2 定义Submittal聚合　　5.2.3 定义聚合边界　　5.2.4 设计仓储　　5.2.5 编写单元测试　5.3 解决方案　　5.3.1 实现Submittal仓储　　5.3.2 实现Submittal服务类　　5.3.3 Submittal视图模型　　5.3.4 Submittal视图　5.4 总结第6章 信息请求　6.1 问题　6.2 设计　　6.2.1 设计领域模型　　6.2.2 定义RFI聚合　　6.2.3 定义聚合边界　　6.2.4 设计仓储　　6.2.5 编写单元测试　6.3 解决方案　　6.3.1 实现RFI仓储　　6.3.2 实现RFI服务类　　6.3.3 RFI视图模型类　　6.3.4 RFI视图　6.4 总结第7章 提案请求　7.1 问题　7.2 设计　　7.2.1 设计领域模型　　7.2.2 设计提案请求聚合　　7.2.3 定义聚合边界　　7.2.4 设计仓储　　7.2.5 编写单元测试　7.3 解决方案　　7.3.1 提案请求类的私有字段和构造器　　7.3.2 ProposalRequest属性　　7.3.3 Validate方法　　7.3.4 实现提案请求仓储　　7.3.5 实现提案请求服务类　　7.3.6 提案请求视图模型类　　7.3.7 提案请求视图　7.4 总结第8章更改单  8.1 问题  8.2 设计    8.2.1 设计领域模型    8.2.2 设计更改单聚合    8.2.3 定义聚合边界    8.2.4 设计仓储    8.2.5 编写单元测试  8.3 解决方案    8.3.1 实现更改单仓储    8.3.2 实现更改单服务类    8.3.3 更改单视图模型类    8.3.4 更改单视图  8.4 总结第9章 施工更改指令  9.1 问题  9.2 设计    9.2.1 设计领域模型    9.2.2 设计施工更改指令聚合    9.2.3 定义聚合边界    9.2.4 设计仓储    9.2.5 编写单元测试  9.3 解决方案    9.3.1 施工更改指令类的私有字段和构造器    9.3.2 实现施工更改指令仓储    9.3.3 实现施工更改指令服务类    9.3.4 施工更改指令视图模型类    9.3.5 施工更改指令视图  9.4 总结第10章 和服务器同步  10.1 问题  10.2 设计    10.2.1 重新设计工作单元    10.2.2 设计同步    10.2.3 编写单元测试  10.3 解决方案    10.3.1 工作单元重构    10.3.2 和Synchronizer类同步  10.4 总结第11章 客户会员管理系统  11.1 问题  11.2 设计    11.2.1 密码安全    11.2.2 设计客户会员管理系统  11.3 解决方案    11.3.1 客户会员管理系统领域模型类    11.3.2 客户会员管理系统单元测试  11.4 总结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>领域驱动设计C# 2008实现
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual C++并行编程实战
目录回到顶部↑《visual c++并行编程实战》
译者序
推荐序一
推荐序二
前言 1
致谢 7
第1章　引言 9
1.1　潜在并行化的重要意义 10
1.2　分解、协调、可扩展性共享 11
1.2.1　理解任务 12
1.2.2　协调任务 13
1.2.3　可扩展性数据共享 13
1.2.4　设计方法 14
1.3　选择正确的设计模式 15
1.4　关于术语 16
1.5　并行的局限 16
1.6　一些建议 18
1.7　练习题 19
1.8　更多资源 19
第2章　并行循环 21
.2.1　基本用法 22
2.1.1　并行版的for循环 22
2.1.2　parallel_for_each 23
2.1.3　期望为何 24
2.2　实例示范 26
2.2.1　串行版的credit review 26
2.2.2　parallel_for_each版的credit review 27
2.2.3　性能对比 27
2.3　模式变体 28
2.3.1　提前退出循环 28
2.3.2　异常处理 29
2.3.3　小型循环体的特殊处理 29
2.3.4　并行度控制 30
2.4　反面模式 31
2.4.1　隐性循环体依赖 31
2.4.2　少量迭代的小循环体 31
2.4.3　重复输入性枚举 32
2.4.4　基于协同性阻塞的交叉调度 32
2.5　相关模式 32
2.6　练习题 32
2.7　补充阅读 33
第3章　并行任务 35
3.1　基本用法 36
3.2　实例示范 38
3.3　模式变体 39
3.3.1　基于协同性阻塞的任务协调 40
3.3.2　取消一个任务组 42
3.3.3　异常处理 44
3.3.4　预测性执行 44
3.4　反面模式 46
3.4.1　闭包中的变量捕获 46
3.4.2　计划外的取消状态传递 47
3.4.3　同步化成本 48
3.5　设计注意事项 48
3.5.1　任务组调用约定 48
3.5.2　任务与线程 48
3.5.3　如何调度任务 49
3.5.4　结构化任务组及任务处理 49
3.5.5　轻量级任务 50
3.6　练习题 50
3.7　补充阅读 50
第4章　并行聚合 53
4.1　基本用法 54
4.2　实例示范 57
4.3　模式变体 63
4.3.1　基于小型循环体的考虑 63
4.3.2　combinable对象的其他用处 63
4.4　设计注意事项 63
4.5　相关模式 65
4.6　练习题 65
4.7　补充阅读 66
第5章　future 69
5.1　基本用法 71
5.2　实例示范：adatum金融仪表盘 73
5.2.1　业务对象 74
5.2.2　分析引擎 75
5.3　模式变体 78
5.3.1　取消future对象 78
5.3.2　消除瓶颈 78
5.3.3　在运行时修改任务图 79
5.4　设计注意事项 79
5.4.1　分解到future对象中去 79
5.4.2　函数式风格 79
5.5　相关模式 80
5.5.1　管道模式 80
5.5.2　master/worker模式 80
5.5.3　动态任务并行化模式 80
5.5.4　离散事件模式 80
5.6　练习题 81
第6章　动态任务并行化 83
6.1　基本用法 83
6.2　实例示范 84
6.3　模式变体 87
6.3.1　非空while循环体的并行化 87
6.3.2　在挂起等待环境中添加任务 89
6.4　练习题 90
6.5　补充阅读 90
第7章　管道 93
7.1　消息块类型概述 94
7.2　基本用法 94
7.3　实例示范 101
7.3.1　串行化的图形处理 101
7.3.2　图形管道 102
7.3.3　性能特征 104
7.4　模式变体 106
7.4.1　异步管道 106
7.4.2　管道中的取消操作 109
7.4.3　管道中的异常处理 110
7.4.4　多生产者作用下的负载平衡 111
7.4.5　管道与流的关系 114
7.5　反面模式 114
7.5.1　在管道各阶段之间进行大量的数据拷贝 114
7.5.2　管道阶段中的工作量过小 114
7.5.3　在消息传递时忘记使用隔离技术 114
7.5.4　无限期的等待 114
7.5.5　无限制的队列增长 115
7.5.6　更多信息 115
7.6　设计注意事项 115
7.7　关联模式 116
7.8　练习题 116
7.9　补充阅读 116
附录a　任务调度器与资源管理器 117
附录b　并行应用程序的调试与分析 139
附录c　技术总览 153
术语表 157
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual C++并行编程实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Mashup模式
译者序
前言
第1章 理解mashup(混搭)模式
1.1 介绍
1.2 Web 2.0
1.3 Enterprise 2.0
1.4 mashup的诞生
1.5 mashup的类型
1.6 从Web获取数据
1.7 长尾
1.8 满足用户要求
1.9 mashup和企业门户网站
1.10 mashup与面向服务的架构
1.11 mashup与EAI/EII
1.12 mashup与软件服务化
1.13 mashup与用户
1.14 模式入门
1.15 脆弱的因素
1.16 mashup的未来
第2章 mashup模式术语
2.1 介绍
2.2 语义
2.3 结构
2.4 UML在哪里
2.5 小结
第3章 核心活动
3.1 介绍
3.2 对开放标准的支持
3.3 数据提取
3.3.1 你是否确切知道你想找的是什么
3.3.2 你是否要挖掘动态更新的页面
3.3.3 内容中是否有二进制格式的文件
3.3.4 能否访问另一种数据视图
3.4 数据输入
3.5 数据可视化
3.6 调度与监视
3.7 剪裁
3.8 转换与充实
3.9 动作
3.10 发布与推广
3.11 组装画布
3.12 小结
第4章 收割模式
4.1 介绍
4.2 警告器
4.2.1 问题
4.2.2 解决方案
4.3 API使能器
4.3.1 问题
4.3.2 解决方案
4.4 竞争分析
4.4.1 问题
4.4.2 解决方案
4.5 无数猴子
4.5.1 问题
4.5.2 解决方案
4.6 领先指标
4.6.1 问题
4.6.2 解决方案
4.7 现实挖掘
4.7.1 问题
4.7.2 解决方案
4.8 声誉管理
4.8.1 问题
4.8.2 解决方案
4.9 时间序列
4.9.1 问题
4.9.2 解决方案
第5章 增强模式
5.1 介绍
5.2 可访问性
5.2.1 问题
5.2.2 解决方案
5.3 源工厂..
5.3.1 问题
5.3.2 解决方案
5.4 战地医生
5.4.1 问题
5.4.2 解决方案
5.5 大众分类使能器
5.5.1 问题
5.5.2 解决方案
5.6 脆弱程度减轻器
5.6.1 问题
5.6.2 解决方案
5.7 智能建议
5.7.1 问题
5.7.2 解决方案
5.8 超级搜索
5.8.1 问题
5.8.2 解决方案
5.9 翻译
5.9.1 问题
5.9.2 解决方案
5.10 有用性增强器
5.10.1 问题
5.10.2 解决方案
5.11 工作流
5.11.1 问题
5.11.2 解决方案
第6章 组装模式
6.1 介绍
6.2 交流与协作
6.2.1 问题
6.2.2 解决方案
6.3 内容聚合
6.3.1 问题
6.3.2 解决方案
6.4 内容集成
6.4.1 问题
6.4.2 解决方案
6.5 分布式向下钻取
6.5.1 问题
6.5.2 解决方案
6.6 紧急响应
6.6.1 问题
6.6.2 解决方案
6.7 过滤器
6.7.1 问题
6.7.2 解决方案
6.8 位置映射
6.8.1 问题
6.8.2 解决方案
6.9 碎片
6.9.1 问题
6.9.2 解决方案
第7章 管理模式
7.1 介绍
7.2 内容移植
7.2.1 问题
7.2.2 解决方案
7.3 仪表板
7.3.1 问题
7.3.2 解决方案
7.4 门户使能器
7.4.1 问题
7.4.2 解决方案
7.5 快速概念验证
7.5.1 问题
7.5.2 解决方案
7.6 单点登录
7.6.1 问题
7.6.2 解决方案
7.7 构件使能器
7.7.1 问题
7.7.2 解决方案
第8章 测试模式
8.1 介绍
8.2 审计
8.2.1 问题
8.2.2 解决方案
8.3 负载测试
8.3.1 问题
8.3.2 解决方案
8.4 回归测试
8.4.1 问题
8.4.2 解决方案
第9章 反模式
9.1 介绍
9.2 瘦窗口
9.2.1 问题
9.2.2 草率的解决方案
9.2.3 诱人之处
9.2.4 纠正
9.3 喝海水
9.3.1 问题
9.3.2 草率的解决方案
9.3.3 诱人之处
9.3.4 纠正
9.4 惯偷
9.4.1 问题
9.4.2 草率的解决方案
9.4.3 诱人之处
9.4.4 纠正
9.5 影子集成
9.5.1 问题
9.5.2 草率的解决方案
9.5.3 诱人之处
9.5.4 纠正
9.6 肮脏的洗衣店
9.6.1 问题
9.6.2 草率的解决方案
9.6.3 诱人之处
9.6.4 纠正
9.7 打开和服
9.7.1 问题
9.7.2 草率的解决方案
9.7.3 诱人之处
9.7.4 纠正
9.8 昙花一现
9.8.1 问题
9.8.2 草率的解决方案
9.8.3 诱人之处
9.8.4 纠正
9.9 恶意的搭便车者
9.9.1 问题
9.9.2 草率的解决方案
9.9.3 诱人之处
9.9.4 纠正
第10章 最后总结
10.1 介绍
10.2 混搭二进制类型
10.3 安全性
10.3.1 阻止mashup
10.3.2 使mashup安全
10.4 结论
附录 企业案例研究
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Mashup模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>全栈应用开发：精益实践
第 0章 绪论： Web应用开发周期 1
0.1  Web应用的生命周期  2
0.2  遗留系统与新架构  3
0.3  技术选型与验证  4
0.4  搭建构建系统 5
0.5  迭代 6
0.6  Web应用开发步骤  7
0.7  小结 9
第 1部分 准备阶段
第 1章 基础知识 12
1.1  搭建开发环境  13
1.1.1  基本要素  13
1.1.2  常用效率工具及其在不同操作系统下的安装  14
1.1.3  搭建开发环境  22
1.1.4  开发工具  23
1.2  版本控制  27
1.2.1  Git初入  28
1.2.2  Git工作流  30
1.3  任务拆分  32
1.3.1  一本书的任务拆分  32
1.3.2  一个功能的任务拆分  33
1.4  小结. 35
第 2章 最小可行化应用36
2.1  最小可行化产品 37
2.2  最小可行化 Web应用 41
2.2.1  使用 Bootstrap模板 41
2.2.2  完善原型  46
2.2.3  简单上线  47
2.3  精益与敏捷软件开发  52
2.3.1  敏捷软件开发  52
2.3.2  精益 56
2.4  小结. 58
第 3章 技术选型与业务59
3.1  技术选型  61
3.1.1  后端选型  63
3.1.2  数据持久化 67
3.1.3  前端选型： UI框架 71
3.2   Django  72
3.2.1  Django简介  72
3.2.2  安装 Django  74
3.2.3  创建项目  77
3.3  从真实世界到代码 83
3.3.1  模型、领域、抽象  84
3.3.2  前后端分离 88
3.4  小结. 90
第 4章 构建系统及其工作流 92
4.1  构建流  93
4.1.1  搭建开发环境  96
4.1.2  准备生产环境  98
4.2  打造后端构建系统 100
4.2.1  使用 Fabric搭建构建系统 101
4.2.2  软件包管理 107
4.3  小结109
第 2部分 编码到上线
第 5章 编码 112
5.1  创建首页应用114
5.1.1  生成首页应用 115
5.1.2  编写第一个测试 122
5.1.3  使用 Selenium进行功能测试124
5.1.4  如何编写测试 128
5.2  创建博客应用134
5.2.1  创建应用与博客管理134
5.2.2  在页面上显示博客141
5.3  数据与 Web应用开发150
5.3.1  管理数据151
5.3.2  显示数据151
5.4  小结152
第 6章 上线 155
6.1  手动部署 156
6.1.1  操作系统与服务器软件 157
6.1.2  第一次部署应用 162
6.1.3  配置管理176
6.2  自动化部署178
6.2.1  使用 Fabric自动化部署 179
6.2.2  探索更优雅的方案185
6.3  隔离与运行环境 187
6.4  小结199
第 7章 数据分析和性能优化 200
7.1  网站监测与分析 203
7.1.1  Google Analytics203
7.1.2  自建监测和分析服务212
7.2  性能分析及优化 214
7.2.1  前端优化：用 PageSpeed工具分析和优化 215
7.2.2  后台优化：使用应用性能管理工具223
7.2.3  使用 New Relic进行优化225
7.2.4  缓存初入230
7.3  小结234
第 8章 持续集成与持续交付 236
8.1  持续集成与 Jenkins237
8.1.1  工具选择与 Pipeline设计 239
8.1.2  Jenkins搭建持续集成 244
8.1.3  使用 Jenkinsfile简化流程 252
8.2  持续交付与持续部署初探255
8.2.1  持续交付256
8.2.2  持续部署初探 260
8.3  小结261
第 9章 移动 Web与混合应用263
9.1  移动 Web与单页面应用 264
9.1.1  单页面应用入门 266
9.1.2  API设计与框架选型272
9.2  创建移动应用277
9.2.1  使用 Ionic 2创建应用 278
9.2.2  更新首页293
9.3  实现博客应用开发 297
9.3.1  创建博客 API297
9.3.2  创建详情页和列表页302
9.4  用户登录与博客创建 309
9.4.1  使用 JWT实现登录 310
9.4.2  测试和发布应用 323
9.5  小结325
第 3部分 增量性优化
第 10章 遗留代码与重构 328
10.1遗留系统 330
10.1.1 什么是遗留系统 330
10.1.2 遗留系统改造334
10.2易读的代码与重构336
10.2.1 命名337
10.2.2 一次只做一件事 339
10.2.3 减少重复代码340
10.2.3 排版342
10.2.4 重构343
10.3小结346
第 11章增长与新架构348
11.1增长350
11.1.1增长：回顾与改变 350
11.1.2增长：技能学习与构建索引354
11.2设计新架构 357
11.3小结363
附 录
附录 A如何学习新的技术 366
附录 B 安装 Piwik 372
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>全栈应用开发：精益实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>UML与Rational Rose 2002从入门到精通
第1章  UML简介
第2章  Rose之游
第3章  业务模型
第4章  使用案例与角色
第5章  对象交互
第6章  类与包
第7章  属性与操作
第8章  关系
第9章  对象行为
第10章  Component视图
第11章  Deployment视图
第12章  用Rational Rose生成代码和逆向转出工程代码简介
第13章  C++与Visual C++代码生成和逆向转出工程代码
第14章  Java代码生成与逆向转出工程代码
……
附录  UML入门
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>UML与Rational Rose 2002从入门到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>妙解Hibernate 3.x
1 初探Hibernate
1.1 Hibernate？据说……
1.2 从简化JDBC实际操作的角度来看Hibernate
1.3 从体现“面向对象思想”的角度来看Hibernate
1.4 主线任务与支线任务
2 Hibernate，一个更好的JDBC
2.1 增、删、改、查，扎马步一样的基本功
2.2 配置——Hibernate的灵魂
2.3 Hibernate对于主键生成的火力支援
2.4 原生SQL的查询
2.5 关于配置文件的更多细节
2.6 题外话——Value Object不等于域对象
2.7 问题与讨论
3 把软件做软—浅谈面向对象思想、分析模式/设计模式、域模型
3.1 面向对象基本概念
3.2 OOAD
3.3 分析模式
3.4 设计模式
3.5 平台方面的落实
3.6 从“Think in Data”到“Think in Object”
3.7 问题与讨论
4 开启对象和关系型数据库的一扇门——静态结构的解决之道
4.1 实体类型（Entity Type）与值类型（Value Type）
4.2 实体类型（Entity Type）的一对多
4.3 实体类型（Entity Type）的多对多
4.4 实体类型（Entity Type）的一对一
4.5 值类型（Value Type）的一对多
4.6 排序处理（Value Type）
4.7 值类型（Value Type）的Component
4.8 为中间Table加入额外的信息
4.9 继承
4.10 关于复合主键的对应（mapping）话题
5 开启对象和关系型数据库的一扇门——动态行为的解决之道
5.1 对象的生命周期
5.2 持久化环境（Persistent Context）
5.3 detached对象的标识（identity/equality）
5.4 运用detached对象的问题
5.5 进一步掌握持久化环境（Persistent Context）
5.6 问题与讨论
6 事务！事务！！事务
6.1 事务二三事
6.2 理论的实践——当Hibernate遇上事务
6.3 问题与讨论
7 更有效地使用Hibernate
7.1 让你的持久化机制产生级联效应（Transitive Persistence）
7.2 大量数据的处理——Bulk&Batch
7.3 延迟加载 v.s. 预加载
7.4 关于缓存
7.5 单发？三发点射？全自动？回归原始SQL的调优
7.6 问题与讨论
8 Hibernate的两把查询利器—HQL ＆ Criteria API
8.1 HQL
8.1.1 基本功
8.1.2 参数绑定
8.1.3 查询条件
8.1.4 Join
8.1.5 HQL的预加载
8.1.6 Group By … Having
8.1.7 子查询（Subquery）与关联子查询（Correlated Subquery）
8.2 Criteria API
8.2.1 基本功
8.2.2 Join与预加载
8.2.3 子查询
8.2.4 转换器（Transformer）
8.2.5 Aggregation & Grouping
8.2.6 多重查询
8.3 更多HQL和Criteria API的高级使用技巧
8.4 问题与讨论
9 查漏补缺—更多的Hibernate应用
9.1 过滤器（Filter）
9.2 不寻常的Mapping
9.2.1 Formula的应用
9.2.2 将两个Table对应到一个类
9.2.3 Join Table的再应用
9.3 Conversation
9.4 使用Hibernate的Type System实现Martin Fowler的Quantity分析模式
9.5 触发器（trigger）的后遗症
9.6 拦截Hibernate（Interception）
9.7 动态模型（Dynamic Model）
9.8 Blob和Clob
9.9 SQL生成定制化、调用存储过程（stored procedure）
9.10 问题与讨论
10 实战演练
10.1 4/6/6（D-day）·奥马哈海滩
10.2 实现Hibernate的基础架构（infrastructure）
10.3 Spring Framework诺曼底大空降
10.4 问题与讨论
11 向Annotation迈进
11.1 基本功
11.2 结构的对应
11.3 其他
附录A 关于随书光盘的使用
附录B 让Hibernate动起来
附录C Hibernate的辅助开发工具
附录D JUnit
附录E DBUnit
附录F Hibernate的数据采集
附录G 参考资料
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>妙解Hibernate 3.x
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++网络编程（卷2）
"第1章　用于网络编程的面向对象的框架  1
1.1  面向对象的框架综述   1
1.2  软件开发与复用技术的比较  4
1.2.1  框架与类库之间的比较  4
1.2.2  框架与组件之间的比较  6
1.2.3  框架与模式之间的比较  8
1.2.4  框架与模型集成式计算之间的比较  10
1.3  在网络编程中应用框架   12
1.4  漫游ACE框架  14
1.4.1  ACE综述  14
1.4.2  ACE框架概要  15
1.5  示例：网络日志服务  19
1.6  小结  21
第2章　服务以及配置的设计空间   22
2.1  服务以及服务器设计空间   23
2.1.1  短持续时间服务与长持续时间服务   23
2.1.2  内部服务与外部服务   24
2.1.3  有状态服务与无状态服务   25
2.1.4  分层式/模块化服务与整体式服务  26
2.1.5  单服务服务器与多服务服务器  28
2.1.6  一次性服务器与持续式服务器  31
2.2  设计空间的配置  32
2.2.1  静态命名与动态命名  32
2.2.2  静态链接与动态链接  33
2.2.3  静态配置与动态配置  34
2.3  小结  36
第3章　ACE Reactor框架   37
3.1  综述   37
3.2  ACE_Time_Value类  40
3.3  ACE_Event_Handler类  44
3.4  ACE定时器队列类   58
3.5  ACE_Reactor类  67
3.6  小结  82
第4章　ACE Reactor实现  84
4.1  综述  84
4.2  ACE_Select_Reactor类  86
4.3  ACE_TP_Reactor类  95
4.4  ACE_WFMO_Reactor类  99
4.5  小结  110
第5章　ACE Service Configurator框架  112
5.1  综述   112
5.2  ACE_Service_Object类  115
5.3  ACE_Service_Repository类   123
5.4  ACE_Service_Config类  134
5.5  小结  149
第6章　ACE Task框架  151
6.1  综述  151
6.2  ACE_Message_Queue类  153
6.3  ACE_Task类  178
6.4  小结  196
第7章　ACE Acceptor-Connector框架  197
7.1  综述   197
7.2  ACE_Svc_Handler类  200
7.3  ACE_Acceptor类  209
7.4  ACE_Connector类   220
7.5  小结   246
第8章　ACE Proactor框架   247
8.1  综述   247
8.2  异步I/O工厂类   251
8.3  ACE_Handler类   259
8.4  前摄式Acceptor-Connector类   266
8.5  ACE_Proactor类    274
8.6  小结    283
第9章　ACE Streams框架    284
9.1  综述    284
9.2  ACE_Module类   286
9.3  ACE_Stream类   300
9.4  小结  304
术语表  305
参考文献  319"
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++网络编程（卷2）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>新技术的商业化--从创意到市场
译者序
前言
第1章  从创意到市场的技术商业化的过程
1. 1  技术商业化过程的5个关键子过程及其衔接
1. 2  商业化循环的整合——有效适时地衔接各个子过程
1. 3  全过程的特征

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>新技术的商业化--从创意到市场
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Maya白金手册1 基础
第1章 Maya概述第2章 创作第一个动画第3章 Maya基础操作第4章 Maya界面详解第5章 公共菜单详解第6章 Maya软件设置第7章 Maya动画项目流程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Maya白金手册1 基础
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件开发方式
第1章 引言
第2章 面向对象――初学者要理解的概念
第3章 分析
第4章 设计
第5章 UML基础
附录A 术语表
附录B 参考文献
附录C UML框图
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件开发方式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>UML 2.2面向对象分析与设计
案例A1  Agate公司案例研究——
简介	1
A1.1  Agate公司介绍	1
A1.2  现有计算机系统	2
A1.3  使用当前系统的业务活动	2
A1.4  需求总结	3
案例B1  FoodCo公司案例研究——
简介	5
B1.1  FoodCo公司介绍	5
B1.2  现如今的FoodCo公司	8
B1.3  建议	11
第1章  信息系统	13
1.1  介绍	13
1.2  信息系统的历史	14
1.3  信息系统现状	16
1.4  何为系统	17
1.4.1  系统思考	18
1.4.2  系统思考的益处	21
1.4.3  信息系统发展过程中
的系统	26
1.5  信息与信息系统	27
1.5.1  信息	27
1.5.2  组织中信息系统的工作	27
1.5.3  信息技术	29
1.6  成功战略	30
1.6.1  确认商业战略	30
1.6.2  信息系统的贡献	31
1.6.3  信息系统和信息技术战略	31
1.7  本章小结	33
问题回顾	33
案例研究、练习和项目	33
拓展阅读	34
第2章  信息系统开发面临的挑战	35
2.1  介绍	35
2.2  挑战	36
2.2.1  终端用户的视角	37
2.2.2  客户的视角	39
2.2.3  开发者的视角	41
2.3  出错的原因	42
2.3.1  质量问题	43
2.3.2  生产率问题	45
2.4  道德层面	46
2.4.1  项目内的道德问题	47
2.4.2  更为广泛的道德问题	48
2.5  失败的代价	49
2.6  本章小结	50
问题回顾	50
案例研究、练习和项目	50
拓展阅读	51
第3章  面对挑战	52
3.1  介绍	52
3.2  问题响应	54
3.2.1  质量问题	54
3.2.2  安装和运行问题	55
3.2.3  生产率问题	56
3.3  项目的生命周期	57
3.3.1  瀑布型生命周期模型	58
3.3.2  原型	60
3.3.3  迭代和增量型开发	62
3.4  方法论	62
3.4.1  统一软件开发过程	63
3.4.2  敏捷方法	64
3.5  信息系统开发管理	65
3.6  用户参与	67
3.7  软件开发工具	68
3.7.1  模型和技术支持	68
3.7.2  软件构建	70
3.7.3  使用软件开发工具的益处
和困难	71
3.8  本章小结	71
问题回顾	71
案例研究、练习和项目	72
拓展阅读	72
第4章  面向对象	73
4.1  介绍	73
4.2  基本概念	73
4.2.1  对象	74
4.2.2  类和对象	75
4.2.3  类成员	76
4.2.4  一般化和特殊化	78
4.2.5  封装、信息隐藏和消息
传递	82
4.2.6  多态	84
4.2.7  对象状态	85
4.3  面向对象的起源	86
4.4  当前的面向对象语言	88
4.5  本章小结	89
问题回顾	90
案例研究、练习和项目	90
拓展阅读	91
第5章  建模的概念	92
5.1  介绍	92
5.2  模型和图	92
5.2.1  模型的含义	93
5.2.2  图	94
5.2.3  模型和图的区别	96
5.2.4  UML中的模型	97
5.2.5  开发模型	98
5.3  绘制活动图	99
5.3.1  活动图的目的	99
5.3.2  活动图的标记法	100
5.4  开发过程	103
5.4.1  基本原则	104
5.4.2  主要活动	105
5.5  本章小结	109
问题回顾	109
案例研究、练习和项目	110
拓展阅读	110
第6章  需求获取	111
6.1  介绍	111
6.2  用户需求	111
6.2.1  当前系统	112
6.2.2  新的需求	113
6.3  事实发现技术	114
6.3.1  背景阅读	114
6.3.2  访谈	115
6.3.3  观察	117
6.3.4  文档抽样	118
6.3.5  调查问卷	119
6.3.6  记住上述技术	121
6.3.7  其他技术	122
6.4  用户参与	122
6.5  文档需求	123
6.6  用例	125
6.6.1  目的	125
6.6.2  标记法	126
6.6.3  使用原型支持用例	130
6.6.4  CASE工具支持	131
6.6.5  使用用例图的业务
模型	131
6.6.6  测试和用例	132
6.7  需求获取和建模	132
6.8  本章小结	133
问题回顾	135
案例研究、练习和项目	135
拓展阅读	136
案例A2  Agate公司案例研究——
需求模型	138
A2.1  介绍	138
A2.2  需求列表	138
A2.3  执行者和用例	139
A2.4  术语表	144
A2.5  最初架构	144
A2.6  需求建模活动	145
第7章  需求分析	147
7.1  介绍	147
7.2  分析模型	148
7.2.1  分析模型和其他模型
的区别	148
7.2.2  好的分析	149
7.3  分析类图：概念和标记法	150
7.3.1  类和对象	150
7.3.2  特性	151
7.3.3  特性和状态	152
7.3.4  实例之间的链接	153
7.3.5  类之间的关联	154
7.3.6  关联和状态	154
7.3.7  多重性	155
7.3.8  操作	156
7.3.9  操作和状态	158
7.3.10  分析类图的稳定性	158
7.4  用例实现	159
7.5  绘制类图	161
7.5.1  健壮性分析	161
7.5.2  分析类stereotype	161
7.5.3  确认类	164
7.5.4  从通信图到类图	168
7.5.5  查找对象和类的其他
方法	169
7.5.6  添加和定位特性	173
7.5.7  添加关联	175
7.5.8  确定多重性	175
7.5.9  寻找操作	175
7.5.10  初始操作分配	175
7.6  CRC卡	176
7.7  整合分析类图	178
7.8  本章小结	179
问题回顾	179
案例研究、练习和项目	180
拓展阅读	183
案例A3  Agate公司案例研究——
需求分析	184
A3.1  介绍	184
A3.2  用例实现	184
A3.3  整合分析类图	189
A3.4  需求分析活动	189
第8章  完善需求模型	191
8.1  介绍	191
8.2  软件和规范重用	192
8.2.1  为何重用	192
8.2.2  难以重用的原因	192
8.2.3  面向对象对重用的贡献	193
8.3  进一步向结构中添加内容	195
8.3.1  寻找和建模一般化	195
8.3.2  寻找和建模组合	199
8.3.3  组合或聚集与一般化
的合并	200
8.3.4  组织分析模型——包
和依赖关系	201
8.4  重用软件组件	202
8.4.1  组件的UML标记法	203
8.4.2  基于组件的开发	204
8.4.3  组件建模实例	205
8.5  软件开发模式	207
8.5.1  模式的起源	207
8.5.2  什么是软件模式	208
8.5.3  分析模式	209
8.6  本章小结	211
问题回顾	211
案例研究、练习和项目	211
拓展阅读	212
第9章  对象交互	213
9.1  介绍	213
9.2  对象交互和协作	214
9.3  交互顺序图	215
9.3.1  基本概念和标记法	216
9.3.2  管理顺序图	223
9.3.3  分支	226
9.3.4  延续	227
9.3.5  异步消息	227
9.3.6  时间约束	228
9.3.7  实时系统和并发的建模	229
9.3.8  准备顺序图的指导原则	230
9.4  通信图	230
9.4.1  基本概念和标记法	231
9.4.2  通信图中的信息标签	232
9.5  交互概览图	234
9.6  时序图	236
9.7  模型一致性	237
9.8  本章小结	238
问题回顾	238
案例研究、练习和项目	238
拓展阅读	239
第10章  规范对象操作	240
10.1  介绍	240
10.2  操作规范的角色	241
10.3  合同	242
10.4  描述操作逻辑	243
10.4.1  非算法型方法	243
10.4.2  算法型方法	246
10.5  对象约束语言	251
10.6  创建操作规范	253
10.7  本章小结	255
问题回顾	255
案例研究、练习和项目	256
拓展阅读	256
第11章  规范控制	257
11.1  介绍	257
11.2  状态和事件	258
11.3  基本标记法	259
11.4  深度标记法	264
11.4.1  组合状态	264
11.4.2  并发状态	265
11.4.3  进入和退出伪状态	267
11.4.4  交叉和选择伪状态	268
11.4.5  历史伪状态	268
11.4.6  状态机的特殊化	269
11.5  准备状态机	269
11.5.1  行为型方法	270
11.5.2  生命周期方法	273
11.6  协议型和行为型状态机	273
11.7  一致性检查	274
11.8  质量准则	274
11.9  本章小结	275
问题回顾	275
案例研究、练习和项目	276
拓展阅读	276
案例A4  Agate公司案例研究——
深入分析	277
A4.1  介绍	277
A4.2  顺序图	277
A4.3  状态机	278
A4.4  操作规范	280
A4.5  对类图的进一步修订	281
A4.6  需求分析的深入活动	283
第12章  设计	285
12.1  介绍	285
12.2  设计和分析有何不同	285
12.2.1  设计	286
12.2.2  迭代型生命周期中
的设计	287
12.3  逻辑设计和物理设计	287
12.4  系统设计和详细设计	289
12.4.1  系统设计	290
12.4.2  详细设计	290
12.5  设计的质量和目标	290
12.5.1  目标和约束	291
12.5.2  设计折中	294
12.5.3  设计中的可衡量目标	295
12.6  本章小结	296
问题回顾	296
案例研究、练习和项目	297
拓展阅读	297
第13章  系统架构	298
13.1  介绍	298
13.2  架构的含义	299
13.3  生成架构模型的原因	301
13.4  对系统架构的影响	302
13.4.1  现有系统	303
13.4.2  企业级架构	304
13.4.3  技术参考架构	305
13.5  架构风格	305
13.5.1  子系统	306
13.5.2  分层和分区	307
13.5.3  MVC架构	311
13.5.4  分布式系统架构	314
13.5.5  架构和开发的组织
结构	316
13.6  并发	317
13.7  处理器分配	318
13.8  系统设计标准	319
13.8.1  数据库设计	319
13.8.2  用户界面设计标准	319
13.8.3  构建准则	319
13.9  Agate软件架构	320
13.10  本章小结	321
问题回顾	322
案例研究、练习和项目	322
拓展阅读	322
第14章  详细设计	324
14.1  介绍	324
14.2  在面向对象的详细设计中
添加的内容	325
14.3  特性和操作规范	325
14.3.1  特性的数据类型	325
14.3.2  派生特性	326
14.3.3  主操作	327
14.3.4  操作签名	328
14.3.5  可见性	329
14.4  将特性和操作归入类中	331
14.4.1  分配职责	331
14.4.2  接口	332
14.4.3  耦合和内聚	333
14.4.4  Liskov替换原则	336
14.5  设计关联	336
14.5.1  一对一关联	337
14.5.2  一对多关联	338
14.5.3  多对多关联	340
14.5.4  保持类最小	341
14.6  完整性约束	342
14.6.1  引用完整性	342
14.6.2  依赖约束	343
14.6.3  域完整性	344
14.7  设计操作算法	344
14.8  本章小结	345
问题回顾	345
案例研究、练习和项目	346
拓展阅读	346
第15章  设计模式	347
15.1  介绍	347
15.2  软件开发模式	348
15.2.1  框架	348
15.2.2  模式目录和语言	348
15.2.3  软件开发原则和模式	348
15.2.4  模式和非功能性需求	349
15.3  文档模式——模式模板	349
15.3.1  模板内容	349
15.3.2  模板的其他方面	350
15.4  设计模式	350
15.4.1  设计模式的类型	350
15.4.2  创建型模式	351
15.4.3  结构型模式	355
15.4.4  行为型模式	359
15.5  如何使用设计模式	363
15.6  使用模式的优缺点	364
15.7  本章小结	365
问题回顾	365
案例研究、练习和项目	365
拓展阅读	365
第16章  人机交互	367
16.1  介绍	367
16.2  用户界面	368
16.2.1  什么是用户界面	368
16.2.2  对话隐喻	368
16.2.3  直接操纵隐喻	370
16.2.4  良好对话的特征	372
16.2.5  风格指导	374
16.3  用户界面设计方法	375
16.3.1  非正式方法和正式
方法	375
16.3.2  实现可使用性	381
16.4  标准和合法需求	382
16.5  本章小结	383
问题回顾	384
案例研究、练习和项目	384
拓展阅读	384
第17章  设计边界类	386
17.1  介绍	386
17.2  表示层结构	387
17.3  为用户界面建立原型	388
17.4  设计类	390
17.5  使用顺序图设计交互	393
17.6  类图回顾	399
17.7  用户界面设计模式	400
17.8  使用状态机建模界面	402
17.9  本章小结	408
问题回顾	409
案例研究、练习和项目	409
拓展阅读	409
第18章  数据管理设计	411
18.1  介绍	411
18.2  持久性	412
18.2.1  持久性需求	412
18.2.2  存储机制概述	412
18.2.3  持久性架构	413
18.3  文件系统	415
18.3.1  文件和记录结构	415
18.3.2  文件的组织方式	416
18.3.3  文件访问	416
18.3.4  文件类型	419
18.3.5  文件使用示例	420
18.4  数据库管理系统	421
18.4.1  文件和数据库	421
18.4.2  数据库的类型	423
18.5  设计关系型数据库管理
系统	425
18.5.1  关系型数据库	425
18.5.2  数据建模和规范化	426
18.5.3  将类映射为表	430
18.6  设计对象数据库管理系统	432
18.7  分布式数据库	436
18.8  数据管理类设计	438
18.8.1  分层结构	438
18.8.2  PersistentObject超类	439
18.8.3  数据库代管者框架	441
18.8.4  使用数据管理产品
或框架	445
18.9  本章小结	447
问题回顾	447
案例研究、练习和项目	447
拓展阅读	448
案例A5  Agate公司案例——简介	449
A5.1  介绍	449
A5.2  架构	449
A5.3  用例示例	450
A5.4  类图	451
A5.5  顺序图	455
A5.6  数据库设计	458
A5.7  状态机	459
A5.8  设计活动	460
第19章  实现	461
19.1  介绍	461
19.2  软件实现	462
19.2.1  软件工具	462
19.2.2  编程和文档标准	464
19.3  组件图	465
19.4  部署图	467
19.5  软件测试	469
19.5.1  由谁执行测试	469
19.5.2  测试内容	470
19.5.3  测试文档	472
19.6  数据转换	473
19.7  用户文档和培训	474
19.7.1  用户手册	474
19.7.2  用户培训	474
19.8  实现策略	475
19.9  评审和维护	476
19.9.1  下一步骤	476
19.9.2  评审过程和评估报告	477
19.9.3  维护活动	478
19.10  本章小结	480
问题回顾	480
案例研究、练习和项目	481
拓展阅读	481
第20章  软件重用	482
20.1  介绍	482
20.2  为什么要进行重用	482
20.2.1  项目的选择	484
20.2.2  组织的结构	485
20.2.3  重用合适的单元	486
20.2.4  组件标准	487
20.3  为重用规划策略	489
20.3.1  选择视角法	489
20.3.2  RSEB	490
20.4  商用组件	491
20.5  案例研究示例	493
20.6  Web服务	499
20.7  本章小结	501
问题回顾	501
案例研究、练习和项目	501
拓展阅读	502
第21章  软件开发过程	503
21.1  介绍	503
21.2  过程、方法和方法论	504
21.2.1  方法论	504
21.2.2  为何使用方法论	506
21.3  统一软件开发过程	506
21.4  动态系统开发方法	510
21.4.1  Atern生命周期	511
21.4.2  DSDM Atern技术	513
21.4.3  DSDM中的项目选择	514
21.5  Scrum	514
21.6  极限编程	516
21.7  选择方法论时的考虑	517
21.8  硬性与软性方法论	519
21.9  本章小结	521
问题回顾	521
案例研究、练习和项目	522
拓展阅读	522
附录A  标记法汇总	523
附录B 部分解决方案和答案指导	531
术语表	540
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>UML 2.2面向对象分析与设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Android程序设计
理论篇1
第1章 android概述2
1.1 移动设备开发平台4
1.1.1 移动信息设备系统4
1.1.2 开放手机联盟6
1.1.3 oms简介8
1.2 android简介8
1.2.1 android的历史8
1.2.2 android的优缺点9
1.2.3 android平台的技术架构10
1.3 android应用程序构成12
1.3.1 活动（activity）13
1.3.2 意图（intent）13
1.3.3 服务（service）13
1.3.4 内容提供器（content provider）14
1.4 第一个android应用14
小结20
练习20
第2章 活动（activity）22
.2.1 activity概述24
2.1.1 activity生命周期24
2.1.2 activity示例27
2.2 android中的资源使用30
2.2.1 字符串资源31
2.2.2 图片资源34
小结35
练习36
第3章 用户界面37
3.1 用户界面元素分类39
3.1.1 视图组件（view）39
3.1.2 视图容器组件（viewgroup）40
3.1.3 布局管理（layout）40
3.2 事件处理机制41
3.3 布局管理（layout）45
3.3.1 线性布局（linearlayout）45
3.3.2 相对布局（relativelayout）47
3.3.3 表格布局（tablelayout）48
3.3.4 绝对布局（absolutelayout）50
3.4 常用widget组件52
3.4.1 widget组件通用属性52
3.4.2 文本框（textview）52
3.4.3 编辑框（edittext）53
3.4.4 复选框（checkbox）53
3.4.5 单选按钮组（radiogroup）54
3.4.6 下拉列表（spinner）54
3.4.7 图片视图（imageview）60
3.4.8 滚动视图（scrollview）61
3.4.9 网格视图（gridview）62
3.4.10 列表视图（listview）63
3.5 菜单64
3.5.1 选项菜单（option menu）64
3.5.2 上下文菜单（context menu）65
3.6 对话框和提示信息（toast）69
3.6.1 对话框69
3.6.2 提示信息（toast）71
小结73
练习73
第4章 意图（intent）74
4.1 intent概述76
4.1.1 intent组成属性76
4.1.2 intent启动79
4.2 intent消息传递83
4.3 intent filter87
4.3.1 [intent-filter]元素88
4.3.2 intentfilter类91
4.4 广播接收intent91
4.4.1 广播和接收intent机制91
4.4.2 广播intent示例94
4.5 设置activity许可96
小结99
练习99
第5章 android后台服务（service）101
5.1 service简介103
5.2 实现service103
5.2.1 创建service类104
5.2.2 启动和绑定service105
5.2.3 停止service107
5.2.4 service示例108
5.3 android系统服务112
小结117
练习117
第6章 数据存储119
6.1 数据存储简介121
6.2 preference存储数据121
6.2.1 访问preference的api121
6.2.2 preference应用123
6.3 file存储数据127
6.3.1 文件操作128
6.3.2 file应用128
6.4 sqlite存储数据131
6.4.1 sqlite简介132
6.4.2 sqlite数据库操作132
6.4.3 sqliteopenhelper138
6.5 数据共享content provider143
6.5.1 contentprovider144
6.5.2 contentresolver145
6.5.3 contentprovider应用147
小结150
练习150
第7章 网络通信151
7.1 网络通信简介153
7.2 socket通信153
7.2.1 socket和serversocket153
7.2.2 socket应用155
7.3 http网络编程161
7.3.1 httpurlconnection161
7.3.2 httpclient165
7.4 webkit167
7.4.1 webkit介绍167
7.4.2 webview视图组件169
小结171
练习171
第8章 android特色开发173
8.1 电话功能175
8.1.1 电话功能结构175
8.1.2 sms应用176
8.2 传感器183
8.2.1 传感器简介183
8.2.2 传感器应用185
8.3 地图与定位187
8.3.1 google map简介187
8.3.2 gps187
8.4 搜索194
8.4.1 android搜索引擎api195
8.4.2 搜索步骤196
8.4.3 搜索示例198
小结201
练习202
实践篇203
实践1 android概述204
实践指导204
实践1.g.1204
实践1.g.2211
实践1.g.3214
知识拓展215
1. android网上资源215
2. android与java me的区别216
拓展练习217
练习1.e.1217
实践2 活动（activity）218
实践指导218
实践2.g.1218
实践2.g.2219
实践2.g.3221
知识拓展222
1. 使用颜色和尺寸资源222
2. 使用xml资源225
拓展练习227
练习2.e.1227
练习2.e.2227
实践3 用户界面228
实践指导228
实践3.g.1228
实践3.g.2235
知识拓展239
1. 自动完成文本框239
2. 时间相关的控件241
3. 进度条243
4. 拖动条246
5. 图片切换效果249
6. 进度对话框252
拓展练习255
练习3.e.1255
练习3.e.2255
练习3.e.3255
实践4 意图（intent）256
实践指导256
实践4.g.1256
实践4.g.2258
实践4.g.3276
知识拓展287
使用intent访问android系统功能287
拓展练习288
练习4.e.1288
实践5 后台服务（service）289
实践指导289
实践5.g.1289
知识拓展295
1. 播放音频、视频295
2. 录制音频、视频300
3. 照相304
拓展练习307
练习5.e.1307
实践6 数据存储308
实践指导308
实践6.g.1308
实践6.g.2310
实践6.g.3313
实践6.g.4317
参考解决方案317
知识拓展323
1. 制作动画323
2. 绘制图形329
拓展练习332
练习6.e.1332
实践7 网络通信333
实践指导333
实践7.g.1333
实践7.g.2351
实践7.g.3353
实践7.g.4357
实践7.g.5358
实践7.g.6365
实践7.g.7368
知识拓展370
1. wi-fi简介370
2. 蓝牙371
拓展练习372
练习7.e.1372
附录a widget列表373
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Android程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Joomla! 2.5素人架站計畫
第1章 您好，為您介紹 Joomla!
第2章 那麼，來架設 Joomla! 吧
第3章 Joomla! 的表與裡
第4章 建構Joomla!，從內容開始
第5章 Joomla! 網站選單與首頁運作
第6章 Joomla! 的強大能量：擴充套件
第7章 Joomla! 內建元件
第8章 Joomla! 內建模組
第9章 Joomla! 內建外掛
第10章 Joomla! 的佈景主題
第11章 Joomla! 的會員機制
第12章 前進最深處：Joomla! 系統管理
第13章 擴充套件示範：相片藝廊、下載中心、文件呈現、Google 地圖應用
第14章 擴充套件示範：編輯器、檔案管理、留言板、文章回應
第15章 進階操作：多語言、中文化、行動化、SEO
第16章 進階操作：使用外部網站資源
第17章 用Joomla! 製作網站的建議
附錄
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Joomla! 2.5素人架站計畫
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件架构与模式
第1章 面向对象设计的原理 1
1.1 程序的可读性、正确性和
可扩展性 2
1.1.1 可读性 2
1.1.2 正确性 2
1.1.3 可扩展性 3
1.2 封装、抽象和信息隐藏 3
1.3 关注点分离和单一职责
原则 4
1.4 接口隔离原则 6
1.5 松耦合 6
1.6 里氏代换原则 7
1.7 契约式设计 9
1.7.1 断言 9
1.7.2 覆写要遵守契约 11
1.8 开闭原则 13
1.9 依赖倒置原则和控制反转 18
1.9.1 依赖倒置原则 18
1.9.2 控制反转 19
1.10 对象生成过程中减少
?依赖性 21
?1.10.1 依赖查找 22
?1.10.2 依赖注入 26
1.11 总结 28
1.12 练习 29
第2章 软件架构 30
2.1 软件架构概念 31
2.2 软件架构的质量 32
2.3 参考架构、架构模式和设计
模式 33
2.4 软件架构概念的任务和前景 34
2.4.1 系统中的分析任务 34
2.4.2 系统中的结构设计
任务 35
2.4.3 观察软件架构的
角度 37
2.4.4 软件架构的原型 37
2.5 软件架构师对一个项目的
意义 37
2.5.1 软件架构师的技术
能力 38
2.5.2 软件架构师的沟通
能力 38
2.5.3 构造软件架构过程中
的决定 39
2.6 总结 40
2.7 练习 41
第3章 软件设计的模式 42
3.1 模式的使用 43
3.2 模式的属性和它的设计 44
3.3 架构模式、设计模式和惯用
法的界限 44
3.4 描述设计模式和架构模式的
模板 46
3.5 总结 47
3.6 练习 47
第4章 面向对象设计模式 48
4.1 设计模式的分类 48
4.2 设计模式的概述 49
4.2.1 结构模式 49
4.2.2 行为模式 50
4.2.3 创建型模式 51
4.2.4 设计模式指南 51
4.3 结构模式中的适配器模式 51
4.3.1 名称/其他可用的
名称 51
4.3.2 问题 51
4.3.3 解决方法 52
4.3.4 评价 57
4.3.5 使用范围 58
4.3.6 类似的模式 58
4.4 结构模式中的桥梁模式 58
4.4.1 名称/其他可用的
名称 58
4.4.2 问题 58
4.4.3 解决方法 59
4.4.4 评价 66
4.4.5 使用范围 67
4.4.6 类似的模式 67
4.5 结构模式中的装饰模式 67
4.5.1 名称/其他可用的
名称 67
4.5.2 问题 67
4.5.3 解决方法 68
4.5.4 评价 76
4.5.5 使用范围 77
4.5.6 类似的模式 80
4.6 结构模式中的外观模式 81
4.6.1 名称/其他可用的
名称 81
4.6.2 问题 81
4.6.3 解决方法 81
4.6.4 评价 86
4.6.5 使用范围 86
4.6.6 类似的模式 86
4.7 结构模式中的组合模式 87
4.7.1 名称/其他可用的
名称 87
4.7.2 问题 87
4.7.3 解决方法 87
4.7.4 评价 95
4.7.5 使用范围 95
4.7.6 类似的模型 97
4.8 结构模式中的代理模式 97
4.8.1 名称/其他可用的
名称 97
4.8.2 问题 98
4.8.3 解决方法 98
4.8.4 评价 102
4.8.5 使用范围 102
4.8.6 类似的模式 103
4.9 行为模式中的模板方法
模式 104
4.9.1 名称/其他可用的
名称 104
4.9.2 问题 104
4.9.3 解决方法 104
4.9.4 使用范围 108
4.9.5 评价 109
4.9.6 类似的模式 109
4.10 行为模式中的命令模式 109
4.10.1 名称/其他可用的
?名称 109
4.10.2 问题 109
4.10.3 解决方法 110
4.10.4 评价 115
4.10.5 使用范围 116
4.10.6 类似的模式 116
4.11 行为模式中的观察者模式 117
4.11.1 名称/其他可用的
?名称 117
4.11.2 问题 117
4.11.3 解决方法 117
4.11.4 评价 124
4.11.5 使用范围 124
4.11.6 类似的模式 125
4.12 行为模式中的策略模式 125
4.12.1 名称/其他可用的
??名称 125
4.12.2 问题 125
4.12.3 解决方法 125
4.12.4 使用范围 129
4.12.5 评价 129
4.12.6 类似的模式 130
4.13 行为模式中的中间者
?模式 130
4.13.1 名称/其他可用的
??名称 130
4.13.2 问题 131
4.13.3 解决方法 131
4.13.4 评价 138
4.13.5 使用范围 138
4.13.6 类似的模式 138
4.14 行为模式中的状态模式 139
4.14.1 名称/其他可用的
??名称 139
4.14.2 问题 139
4.14.3 解决方法 139
4.14.4 使用范围 146
4.14.5 评价 146
4.14.6 类似的模式 146
4.15 行为模式中的角色模式 147
4.15.1 名称/其他可用的
??名称 147
4.15.2 问题 147
4.15.3 解决方法 148
4.15.4 评价 155
4.15.5 使用范围 155
4.15.6 类似的模式 156
4.16 行为模式中的拜访者模式 156
4.16.1 名称/其他可用的
??名称 156
4.16.2 问题 156
4.16.3 解决方法 156
4.16.4 评价 169
4.16.5 使用范围 170
4.16.6 类似的模式 171
4.17 行为模式中的迭代器模式 171
4.17.1 名称/其他可用的
??名称 171
4.17.2 问题 171
4.17.3 解决方法 171
4.17.4 评价 178
4.17.5 使用范围 178
4.17.6 类似的模式 180
4.18 创建型模式中的工厂
??方法 180
4.18.1 名称/其他可用的
??名称 180
4.18.2 问题 180
4.18.3 解决方法 181
4.18.4 评价 185
4.18.5 使用范围 185
4.18.6 类似的模式 186
4.19 创建型模式中的抽象工厂
??模式 186
4.19.1 名称/其他可用的
??名称 186
4.19.2 问题 186
4.19.3 解决方法 186
4.19.4 评价 195
4.19.5 使用范围 195
4.19.6 类似的模式 196
4.20 创建型模式中的单例模式 196
4.20.1 名称/其他可用的
??名称 196
4.20.2 问题 196
4.20.3 解决方法 196
4.20.4 评价 204
4.20.5 使用范围 204
4.20.6 类似的模式 204
4.21 创建型模式中的对象池
??模式 204
4.21.1 名称/其他可用的
??名称 204
4.21.2 问题 205
4.21.3 解决方法 205
4.21.4 评价 210
4.21.5 使用范围 211
4.21.6 类似的模式 211
4.22 总结 211
4.23 练习 213
第5章 架构模式 216
5.1 分层架构模式 217
5.1.1 名称/其他可用的
名称 217
5.1.2 问题 217
5.1.3 解决方法 217
5.1.4 评价 219
5.1.5 使用范围 220
5.1.6 类似的模式 226
5.2 管道和过滤器架构模式 226
5.2.1 名称/其他可用的
名称 226
5.2.2 问题 226
5.2.3 解决方法 227
5.2.4 评价 232
5.2.5 使用范围 232
5.2.6 类似的模式 234
5.3 插件架构模式 235
5.4 中介模式 245
5.5 面向服务的架构模式 267
5.6 模型-视图-控制器架构模式 291
5.7 总结 307
5.8 练习 308
参考文献 310
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件架构与模式
