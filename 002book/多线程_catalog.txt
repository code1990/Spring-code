>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux多线程服务端编程
第1 部分C++ 多线程系统编程1
第1章 线程安全的对象生命期管理3
1.1 当析构函数遇到多线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.1 线程安全的定义. . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.1.2 MutexLock 与MutexLockGuard . . . . . . . . . . . . . . . . . . . . 4
1.1.3 一个线程安全的Counter 示例. . . . . . . . . . . . . . . . . . . . 4
1.2 对象的创建很简单. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.3 销毁太难. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.3.1 mutex 不是办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.3.2 作为数据成员的mutex 不能保护析构. . . . . . . . . . . . . . . 8
1.4 线程安全的Observer 有多难. . . . . . . . . . . . . . . . . . . . . . . . . 8
1.5 原始指针有何不妥. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
1.6 神器shared_ptr/weak_ptr . . . . . . . . . . . . . . . . . . . . . . . . . . 13
1.7 插曲：系统地避免各种指针错误. . . . . . . . . . . . . . . . . . . . . . . 14
1.8 应用到Observer 上. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
1.9 再论shared_ptr 的线程安全. . . . . . . . . . . . . . . . . . . . . . . . . 17
1.10 shared_ptr 技术与陷阱. . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
1.11 对象池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
1.11.1 enable_shared_from_this . . . . . . . . . . . . . . . . . . . . . . 23
1.11.2 弱回调. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
1.12 替代方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
1.13 心得与小结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
1.14 Observer 之谬. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
第2章 线程同步精要31
2.1 互斥器（mutex） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2.1.1 只使用非递归的mutex . . . . . . . . . . . . . . . . . . . . . . . . 33
2.1.2 死锁. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
2.2 条件变量（condition variable） . . . . . . . . . . . . . . . . . . . . . . . 40
2.3 不要用读写锁和信号量. . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
2.4 封装MutexLock、MutexLockGuard、Condition . . . . . . . . . . . . . . 44
2.5 线程安全的Singleton 实现. . . . . . . . . . . . . . . . . . . . . . . . . . 48
2.6 sleep(3) 不是同步原语. . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
2.7 归纳与总结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
2.8 借shared_ptr 实现copy-on-write . . . . . . . . . . . . . . . . . . . . . . 52
第3章 多线程服务器的适用场合与常用编程模型59
3.1 进程与线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
3.2 单线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 61
3.3 多线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 62
3.3.1 one loop per thread . . . . . . . . . . . . . . . . . . . . . . . . . . 62
3.3.2 线程池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
3.3.3 推荐模式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
3.4 进程间通信只用TCP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
3.5 多线程服务器的适用场合. . . . . . . . . . . . . . . . . . . . . . . . . . . 67
3.5.1 必须用单线程的场合. . . . . . . . . . . . . . . . . . . . . . . . . 69
3.5.2 单线程程序的优缺点. . . . . . . . . . . . . . . . . . . . . . . . . 70
3.5.3 适用多线程程序的场景. . . . . . . . . . . . . . . . . . . . . . . . 71
3.6 “多线程服务器的适用场合”例释与答疑. . . . . . . . . . . . . . . . . . 74
第4章 C++ 多线程系统编程精要83
4.1 基本线程原语的选用. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
4.2 C/C++ 系统库的线程安全性. . . . . . . . . . . . . . . . . . . . . . . . . 85
4.3 Linux 上的线程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
4.4 线程的创建与销毁的守则. . . . . . . . . . . . . . . . . . . . . . . . . . . 91
4.4.1 pthread_cancel 与C++ . . . . . . . . . . . . . . . . . . . . . . . 94
4.4.2 exit(3) 在C++ 中不是线程安全的. . . . . . . . . . . . . . . . . 94
4.5 善用__thread 关键字. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
4.6 多线程与IO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
4.7 用RAII 包装文件描述符. . . . . . . . . . . . . . . . . . . . . . . . . . . 99
4.8 RAII 与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
4.9 多线程与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
4.10 多线程与signal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
4.11 Linux 新增系统调用的启示. . . . . . . . . . . . . . . . . . . . . . . . . . 105
第5章 高效的多线程日志107
5.1 功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
5.2 性能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
5.3 多线程异步日志. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
5.4 其他方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
第2部分 muduo 网络库123
第6章 muduo 网络库简介125
6.1 由来. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
6.2 安装. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
6.3 目录结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
6.3.1 代码结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
6.3.2 例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
6.3.3 线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
6.4 使用教程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
6.4.1 TCP 网络编程本质论. . . . . . . . . . . . . . . . . . . . . . . . . 136
6.4.2 echo 服务的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . 138
6.4.3 七步实现finger 服务. . . . . . . . . . . . . . . . . . . . . . . . . 140
6.5 性能评测. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
6.5.1 muduo 与Boost.Asio、libevent2 的吞吐量对比. . . . . . . . . . 145
6.5.2 击鼓传花：对比muduo 与libevent2 的事件处理效率. . . . . . 148
6.5.3 muduo 与Nginx 的吞吐量对比. . . . . . . . . . . . . . . . . . . 153
6.5.4 muduo 与ZeroMQ 的延迟对比. . . . . . . . . . . . . . . . . . . 156
6.6 详解muduo 多线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 157
6.6.1 数独求解服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
6.6.2 常见的并发网络服务程序设计方案. . . . . . . . . . . . . . . . . 160
第7章 muduo 编程示例177
7.1 五个简单TCP 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
7.2 文件传输. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
7.3 Boost.Asio 的聊天服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . 194
7.3.1 TCP 分包. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
7.3.2 消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
7.3.3 编解码器LengthHeaderCodec . . . . . . . . . . . . . . . . . . . . 197
7.3.4 服务端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
7.3.5 客户端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200
7.4 muduo Buffer 类的设计与使用. . . . . . . . . . . . . . . . . . . . . . . 204
7.4.1 muduo 的IO 模型. . . . . . . . . . . . . . . . . . . . . . . . . . 204
7.4.2 为什么non-blocking 网络编程中应用层buffer 是必需的. . . . 205
7.4.3 Buffer 的功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . 207
7.4.4 Buffer 的数据结构. . . . . . . . . . . . . . . . . . . . . . . . . . 209
7.4.5 Buffer 的操作. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211
7.4.6 其他设计方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
7.4.7 性能是不是问题. . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
7.5 一种自动反射消息类型的Google Protobuf 网络传输方案. . . . . . . . 220
7.5.1 网络编程中使用Protobuf 的两个先决条件. . . . . . . . . . . . . 220
7.5.2 根据type name 反射自动创建Message 对象. . . . . . . . . . . . 221
7.5.3 Protobuf 传输格式. . . . . . . . . . . . . . . . . . . . . . . . . . 226
7.6 在muduo 中实现Protobuf 编解码器与消息分发器. . . . . . . . . . . . 228
7.6.1 什么是编解码器（codec） . . . . . . . . . . . . . . . . . . . . . . 229
7.6.2 实现ProtobufCodec . . . . . . . . . . . . . . . . . . . . . . . . . 232
7.6.3 消息分发器（dispatcher）有什么用. . . . . . . . . . . . . . . . 232
7.6.4 ProtobufCodec 与ProtobufDispatcher 的综合运用. . . . . . . 233
7.6.5 ProtobufDispatcher 的两种实现. . . . . . . . . . . . . . . . . . 234
7.6.6 ProtobufCodec 和ProtobufDispatcher 有何意义. . . . . . . . . 236
7.7 限制服务器的最大并发连接数. . . . . . . . . . . . . . . . . . . . . . . . 237
7.7.1 为什么要限制并发连接数. . . . . . . . . . . . . . . . . . . . . . 237
7.7.2 在muduo 中限制并发连接数. . . . . . . . . . . . . . . . . . . . 238
7.8 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240
7.8.1 程序中的时间. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240
7.8.2 Linux 时间函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . 241
7.8.3 muduo 的定时器接口. . . . . . . . . . . . . . . . . . . . . . . . . 242
7.8.4 Boost.Asio Timer 示例. . . . . . . . . . . . . . . . . . . . . . . . 243
7.8.5 Java Netty 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . 245
7.9 测量两台机器的网络延迟和时间差. . . . . . . . . . . . . . . . . . . . . 248
7.10 用timing wheel 踢掉空闲连接. . . . . . . . . . . . . . . . . . . . . . . . 250
7.10.1 timing wheel 原理. . . . . . . . . . . . . . . . . . . . . . . . . . 251
7.10.2 代码实现与改进. . . . . . . . . . . . . . . . . . . . . . . . . . . . 254
7.11 简单的消息广播服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257
7.12 “串并转换”连接服务器及其自动化测试. . . . . . . . . . . . . . . . . . 260
7.13 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264
7.13.1 TCP 中继器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264
7.13.2 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . 267
7.13.3 N : 1 与1 : N 连接转发. . . . . . . . . . . . . . . . . . . . . . . . 267
7.14 短址服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267
7.15 与其他库集成. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268
7.15.1 UDNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
7.15.2 c-ares DNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272
7.15.3 curl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273
7.15.4 更多. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275
第8章 muduo 网络库设计与实现277
8.0 什么都不做的EventLoop . . . . . . . . . . . . . . . . . . . . . . . . . . . 277
8.1 Reactor 的关键结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
8.1.1 Channel class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
8.1.2 Poller class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283
8.1.3 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 287
8.2 TimerQueue 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290
8.2.1 TimerQueue class . . . . . . . . . . . . . . . . . . . . . . . . . . . 290
8.2.2 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 292
8.3 EventLoop::runInLoop() 函数. . . . . . . . . . . . . . . . . . . . . . . . 293
8.3.1 提高TimerQueue 的线程安全性. . . . . . . . . . . . . . . . . . . 296
8.3.2 EventLoopThread class . . . . . . . . . . . . . . . . . . . . . . . . 297
8.4 实现TCP 网络库. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
8.5 TcpServer 接受新连接. . . . . . . . . . . . . . . . . . . . . . . . . . . . 303
8.5.1 TcpServer class . . . . . . . . . . . . . . . . . . . . . . . . . . . . 304
8.5.2 TcpConnection class . . . . . . . . . . . . . . . . . . . . . . . . . 305
8.6 TcpConnection 断开连接. . . . . . . . . . . . . . . . . . . . . . . . . . . 308
8.7 Buffer 读取数据. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313
8.7.1 TcpConnection 使用Buffer 作为输入缓冲. . . . . . . . . . . . . 314
8.7.2 Buffer::readFd() . . . . . . . . . . . . . . . . . . . . . . . . . . 315
8.8 TcpConnection 发送数据. . . . . . . . . . . . . . . . . . . . . . . . . . . 316
8.9 完善TcpConnection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320
8.9.1 SIGPIPE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321
8.9.2 TCP No Delay 和TCP keepalive . . . . . . . . . . . . . . . . . . 321
8.9.3 WriteCompleteCallback 和HighWaterMarkCallback . . . . . . . 322
8.10 多线程TcpServer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324
8.11 Connector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327
8.12 TcpClient . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332
8.13 epoll . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333
8.14 测试程序一览. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 336
第3部分 工程实践经验谈337
第9章 分布式系统工程实践339
9.1 我们在技术浪潮中的位置. . . . . . . . . . . . . . . . . . . . . . . . . . . 341
9.1.1 分布式系统的本质困难. . . . . . . . . . . . . . . . . . . . . . . . 343
9.1.2 分布式系统是个险恶的问题. . . . . . . . . . . . . . . . . . . . . 344
9.2 分布式系统的可靠性浅说. . . . . . . . . . . . . . . . . . . . . . . . . . . 349
9.2.1 分布式系统的软件不要求7  24 可靠. . . . . . . . . . . . . . . . 352
9.2.2 “能随时重启进程”作为程序设计目标. . . . . . . . . . . . . . . 354
9.3 分布式系统中心跳协议的设计. . . . . . . . . . . . . . . . . . . . . . . . 356
9.4 分布式系统中的进程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . 360
9.4.1 错误做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361
9.4.2 正确做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 362
9.4.3 TCP 协议的启示. . . . . . . . . . . . . . . . . . . . . . . . . . . . 363
9.5 构建易于维护的分布式程序. . . . . . . . . . . . . . . . . . . . . . . . . 364
9.6 为系统演化做准备. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367
9.6.1 可扩展的消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . 368
9.6.2 反面教材：ICE 的消息打包格式. . . . . . . . . . . . . . . . . . . 369
9.7 分布式程序的自动化回归测试. . . . . . . . . . . . . . . . . . . . . . . . 370
9.7.1 单元测试的能与不能. . . . . . . . . . . . . . . . . . . . . . . . . 370
9.7.2 分布式系统测试的要点. . . . . . . . . . . . . . . . . . . . . . . . 373
9.7.3 分布式系统的抽象观点. . . . . . . . . . . . . . . . . . . . . . . . 374
9.7.4 一种自动化的回归测试方案. . . . . . . . . . . . . . . . . . . . . 375
9.7.5 其他用处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379
9.8 分布式系统部署、监控与进程管理的几重境界. . . . . . . . . . . . . . . 380
9.8.1 境界1：全手工操作. . . . . . . . . . . . . . . . . . . . . . . . . 382
9.8.2 境界2：使用零散的自动化脚本和第三方组件. . . . . . . . . . . 383
9.8.3 境界3：自制机群管理系统，集中化配置. . . . . . . . . . . . . 386
9.8.4 境界4：机群管理与naming service 结合. . . . . . . . . . . . . 389
第10章 C++ 编译链接模型精要391
10.1 C 语言的编译模型及其成因. . . . . . . . . . . . . . . . . . . . . . . . . 394
10.1.1 为什么C 语言需要预处理. . . . . . . . . . . . . . . . . . . . . . 395
10.1.2 C 语言的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 398
10.2 C++ 的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399
10.2.1 单遍编译. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399
10.2.2 前向声明. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 402
10.3 C++ 链接（linking） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 404
10.3.1 函数重载. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 406
10.3.2 inline 函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407
10.3.3 模板. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409
10.3.4 虚函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 414
10.4 工程项目中头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . 415
10.4.1 头文件的害处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 416
10.4.2 头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . . . 417
10.5 工程项目中库文件的组织原则. . . . . . . . . . . . . . . . . . . . . . . . 418
10.5.1 动态库是有害的. . . . . . . . . . . . . . . . . . . . . . . . . . . . 423
10.5.2 静态库也好不到哪儿去. . . . . . . . . . . . . . . . . . . . . . . . 424
10.5.3 源码编译是王道. . . . . . . . . . . . . . . . . . . . . . . . . . . . 428
第11章 反思C++ 面向对象与虚函数429
11.1 朴实的C++ 设计. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429
11.2 程序库的二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . . . . 431
11.2.1 什么是二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . 432
11.2.2 有哪些情况会破坏库的ABI . . . . . . . . . . . . . . . . . . . . . 433
11.2.3 哪些做法多半是安全的. . . . . . . . . . . . . . . . . . . . . . . . 435
11.2.4 反面教材：COM . . . . . . . . . . . . . . . . . . . . . . . . . . . 435
11.2.5 解决办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436
11.3 避免使用虚函数作为库的接口. . . . . . . . . . . . . . . . . . . . . . . . 436
11.3.1 C++ 程序库的作者的生存环境. . . . . . . . . . . . . . . . . . . . 437
11.3.2 虚函数作为库的接口的两大用途. . . . . . . . . . . . . . . . . . 438
11.3.3 虚函数作为接口的弊端. . . . . . . . . . . . . . . . . . . . . . . . 439
11.3.4 假如Linux 系统调用以COM 接口方式实现. . . . . . . . . . . . 442
11.3.5 Java 是如何应对的. . . . . . . . . . . . . . . . . . . . . . . . . . 443
11.4 动态库接口的推荐做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 443
11.5 以boost::function 和boost::bind 取代虚函数. . . . . . . . . . . . . 447
11.5.1 基本用途. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 450
11.5.2 对程序库的影响. . . . . . . . . . . . . . . . . . . . . . . . . . . . 451
11.5.3 对面向对象程序设计的影响. . . . . . . . . . . . . . . . . . . . . 453
11.6 iostream 的用途与局限. . . . . . . . . . . . . . . . . . . . . . . . . . . . 457
11.6.1 stdio 格式化输入输出的缺点. . . . . . . . . . . . . . . . . . . . . 457
11.6.2 iostream 的设计初衷. . . . . . . . . . . . . . . . . . . . . . . . . 461
11.6.3 iostream 与标准库其他组件的交互. . . . . . . . . . . . . . . . . 463
11.6.4 iostream 在使用方面的缺点. . . . . . . . . . . . . . . . . . . . . 464
11.6.5 iostream 在设计方面的缺点. . . . . . . . . . . . . . . . . . . . . 468
11.6.6 一个300 行的memory buffer output stream . . . . . . . . . . . 476
11.6.7 现实的C++ 程序如何做文件IO . . . . . . . . . . . . . . . . . . . 480
11.7 值语义与数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482
11.7.1 什么是值语义. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482
11.7.2 值语义与生命期. . . . . . . . . . . . . . . . . . . . . . . . . . . . 483
11.7.3 值语义与标准库. . . . . . . . . . . . . . . . . . . . . . . . . . . . 488
11.7.4 值语义与C++ 语言. . . . . . . . . . . . . . . . . . . . . . . . . . 488
11.7.5 什么是数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . 490
11.7.6 数据抽象所需的语言设施. . . . . . . . . . . . . . . . . . . . . . 493
11.7.7 数据抽象的例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . 495
第12章 C++ 经验谈501
12.1 用异或来交换变量是错误的. . . . . . . . . . . . . . . . . . . . . . . . . 501
12.1.1 编译器会分别生成什么代码. . . . . . . . . . . . . . . . . . . . . 503
12.1.2 为什么短的代码不一定快. . . . . . . . . . . . . . . . . . . . . . 505
12.2 不要重载全局::operator new() . . . . . . . . . . . . . . . . . . . . . . 507
12.2.1 内存管理的基本要求. . . . . . . . . . . . . . . . . . . . . . . . . 507
12.2.2 重载::operator new() 的理由. . . . . . . . . . . . . . . . . . . 508
12.2.3 ::operator new() 的两种重载方式. . . . . . . . . . . . . . . . . 508
12.2.4 现实的开发环境. . . . . . . . . . . . . . . . . . . . . . . . . . . . 509
12.2.5 重载::operator new() 的困境. . . . . . . . . . . . . . . . . . . 510
12.2.6 解决办法：替换malloc() . . . . . . . . . . . . . . . . . . . . . . 512
12.2.7 为单独的class 重载::operator new() 有问题吗. . . . . . . . . 513
12.2.8 有必要自行定制内存分配器吗. . . . . . . . . . . . . . . . . . . . 513
12.3 带符号整数的除法与余数. . . . . . . . . . . . . . . . . . . . . . . . . . . 514
12.3.1 语言标准怎么说. . . . . . . . . . . . . . . . . . . . . . . . . . . . 515
12.3.2 C/C++ 编译器的表现. . . . . . . . . . . . . . . . . . . . . . . . . 516
12.3.3 其他语言的规定. . . . . . . . . . . . . . . . . . . . . . . . . . . . 516
12.3.4 脚本语言解释器代码. . . . . . . . . . . . . . . . . . . . . . . . . 517
12.3.5 硬件实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521
12.4 在单元测试中mock 系统调用. . . . . . . . . . . . . . . . . . . . . . . . 522
12.4.1 系统函数的依赖注入. . . . . . . . . . . . . . . . . . . . . . . . . 522
12.4.2 链接期垫片（link seam） . . . . . . . . . . . . . . . . . . . . . . 524
12.5 慎用匿名namespace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 526
12.5.1 C 语言的static 关键字的两种用法. . . . . . . . . . . . . . . . . 526
12.5.2 C++ 语言的static 关键字的四种用法. . . . . . . . . . . . . . . . 526
12.5.3 匿名namespace 的不利之处. . . . . . . . . . . . . . . . . . . . . 527
12.5.4 替代办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529
12.6 采用有利于版本管理的代码格式. . . . . . . . . . . . . . . . . . . . . . . 529
12.6.1 对diff 友好的代码格式. . . . . . . . . . . . . . . . . . . . . . . . 530
12.6.2 对grep 友好的代码风格. . . . . . . . . . . . . . . . . . . . . . . 537
12.6.3 一切为了效率. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 538
12.7 再探std::string . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539
12.7.1 直接拷贝（eager copy） . . . . . . . . . . . . . . . . . . . . . . . 540
12.7.2 写时复制（copy-on-write） . . . . . . . . . . . . . . . . . . . . . 542
12.7.3 短字符串优化（SSO） . . . . . . . . . . . . . . . . . . . . . . . . 543
12.8 用STL algorithm 轻松解决几道算法面试题. . . . . . . . . . . . . . . . 546
12.8.1 用next_permutation() 生成排列与组合. . . . . . . . . . . . . . 546
12.8.2 用unique() 去除连续重复空白. . . . . . . . . . . . . . . . . . . 548
12.8.3 用{make,push,pop}_heap() 实现多路归并. . . . . . . . . . . . 549
12.8.4 用partition() 实现“重排数组，让奇数位于偶数前面” . . . . 553
12.8.5 用lower_bound() 查找IP 地址所属的城市. . . . . . . . . . . . . 554
第4 部分附录559
附录A 谈一谈网络编程学习经验561
附录B 从《C++ Primer（第4 版）》入手学习C++ 579
附录C 关于Boost 的看法591
附录D 关于TCP 并发连接的几个思考题与试验593
参考文献599
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux多线程服务端编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程核心技术
前 言
第1章 Java多线程技能，
1.1 进程和多线程的概念及线程的优点
1.2 使用多线程
1.2.1 继承Thread类
1.2.2 实现Runnable接口
1.2.3 实例变量与线程安全
1.2.4 留意i——与System.out.println（）的异常
1.3 currentThread（）方法
1.4 isAlive（）方法
1.5 sleep（）方法
1.6 getId（）方法
1.7 停止线程
1.7.1 停止不了的线程
1.7.2 判断线程是否是停止状态
1.7.3 能停止的线程——异常法
1.7.4 在沉睡中停止
1.7.5 能停止的线程——暴力停止
1.7.6 方法stop（）与java.lang.ThreadDeath异常
1.7.7 释放锁的不良后果
1.7.8 使用return停止线程
1.8 暂停线程
1.8.1 suspend与resume方法的使用
1.8.2 suspend与resume方法的缺点——独占
1.8.3 suspend与resume方法的缺点——不同步
1.9 yield方法
1.10 线程的优先级
1.10.1 线程优先级的继承特性
1.10.2 优先级具有规则性
1.10.3 优先级具有随机性
1.10.4 看谁运行得快
1.11 守护线程
1.12 本章小结
第2章 对象及变量的并发访问
2.1 synchronized同步方法
2.1.1 方法内的变量为线程安全
2.1.2 实例变量非线程安全
2.1.3 多个对象多个锁
2.1.4 synchronized方法与锁对象
2.1.5 脏读
2.1.6 synchronized锁重入
2.1.7 出现异常，锁自动释放
2.1.8 同步不具有继承性
2.2 synchronized同步语句块
2.2.1 synchronized方法的弊端
2.2.2 synchronized同步代码块的使用
2.2.3 用同步代码块解决同步方法的弊端
2.2.4 一半异步，一半同步
2.2.5 synchronized代码块间的同步性
2.2.6 验证同步synchronized（this）代码块是锁定当前对象的
2.2.7 将任意对象作为对象监视器
2.2.8 细化验证3个结论
2.2.9 静态同步synchronized方法与synchronized（class）代码块
2.2.10 数据类型String的常量池特性
2.2.11 同步synchronized方法无限等待与解决
2.2.12 多线程的死锁
2.2.13 内置类与静态内置类
2.2.14 内置类与同步：实验1
2.2.15 内置类与同步：实验2
2.2.16 锁对象的改变
2.3 volatile关键字
2.3.1 关键字volatile与死循环
2.3.2 解决同步死循环
2.3.3 解决异步死循环
2.3.4 volatile非原子的特性
2.3.5 使用原子类进行i++操作
2.3.6 原子类也并不完全安全
2.3.7 synchronized代码块有volatile同步的功能
2.4 本章总结
第3章 线程间通信
3.1 等待/通知机制
3.1.1 不使用等待/通知机制实现线程间通信
3.1.2 什么是等待/通知机制
3.1.3 等待/通知机制的实现
3.1.4 方法wait（）锁释放与notify（）锁不释放
3.1.5 当interrupt方法遇到wait方法
3.1.6 只通知一个线程
3.1.7 唤醒所有线程
3.1.8 方法wait（long）的使用
3.1.9 通知过早
3.1.10 等待wait的条件发生变化
3.1.11 生产者/消费者模式实现
3.1.12 通过管道进行线程间通信：字节流
3.1.13 通过管道进行线程间通信：字符流
3.1.14 实战：等待/通知之交叉备份
3.2 方法join的使用
3.2.1 学习方法join前的铺垫
3.2.2 用join（）方法来解决
3.2.3 方法join与异常
3.2.4 方法join（long）的使用
3.2.5 方法join（long）与sleep（long）的区别
3.2.6 方法join（）后面的代码提前运行：出现意外
3.2.7 方法join（）后面的代码提前运行：解释意外
3.3 类ThreadLocal的使用
3.3.1 方法get（）与null
3.3.2 验证线程变量的隔离性
3.3.3 解决get（）返回null问题
3.3.4 再次验证线程变量的隔离性
3.4 类InheritableThreadLocal的使用
3.4.1 值继承
3.4.2 值继承再修改
3.5 本章总结
第4章 Lock的使用
4.1 使用ReentrantLock类
4.1.1 使用ReentrantLock实现同步：测试1
4.1.2 使用ReentrantLock实现同步：测试2
4.1.3 使用Condition实现等待/通知错误用法与解决
4.1.4 正确使用Condition实现等待/通知
4.1.5 使用多个Condition实现通知部分线程：错误用法
4.1.6 使用多个Condition实现通知部分线程：正确用法
4.1.7 实现生产者/消费者模式：一对一交替打印
4.1.8 实现生产者/消费者模式：多对多交替打印
4.1.9 公平锁与非公平锁
4.1.10 方法getHoldCount（）、getQueueLength（）和getWaitQueueLength（）的测试
4.1.11 方法hasQueuedThread（）、hasQueuedThreads（）和hasWaiters（）的测试
4.1.12 方法isFair（）、isHeldByCurrentThread（）和isLocked（）的测试
4.1.13 方法lockInterruptibly（）、tryLock（）和tryLock（long timeout，TimeUnit unit）的测试
4.1.14 方法awaitUninterruptibly（）的使用
4.1.15 方法awaitUntil（）的使用
4.1.16 使用Condition实现顺序执行
4.2 使用ReentrantReadWriteLock类
4.2.1 类ReentrantReadWriteLock的使用：读读共享
4.2.2 类ReentrantReadWriteLock的使用：写写互斥
4.2.3 类ReentrantReadWriteLock的使用：读写互斥
4.2.4 类ReentrantReadWriteLock的使用：写读互斥
4.3 本章总结
第5章 定时器Timer
5.1 定时器Timer的使用
5.1.1 方法schedule（TimerTask task， Date time）的测试
5.1.2 方法schedule（TimerTask task， Date firstTime， long period）的测试
5.1.3 方法schedule（TimerTask task， long delay）的测试
5.1.4 方法schedule（TimerTask task， long delay， long period）的测试
5.1.5 方法scheduleAtFixedRate（TimerTask task， Date firstTime， long period）的测试
5.2 本章总结
第6章 单例模式与多线程
6.1 立即加载/"饿汉模式"
6.2 延迟加载/"懒汉模式"
6.3 使用静态内置类实现单例模式
6.4 序列化与反序列化的单例模式实现
6.5 使用static代码块实现单例模式
6.6 使用enum枚举数据类型实现单例模式
6.7 完善使用enum枚举实现单例模式
6.8 本章总结
第7章 拾遗增补
7.1 线程的状态
7.1.1 验证NEW、RUNNABLE和TERMINATED
7.1.2 验证TIMED_WAITING
7.1.3 验证BLOCKED
7.1.4 验证WAITING
7.2 线程组
7.2.1 线程对象关联线程组：1级关联
7.2.2 线程对象关联线程组：多级关联
7.2.3 线程组自动归属特性
7.2.4 获取根线程组
7.2.5 线程组里加线程组
7.2.6 组内的线程批量停止
7.2.7 递归与非递归取得组内对象
7.3 使线程具有有序性
7.4 SimpleDateFormat非线程安全
7.4.1 出现异常
7.4.2 解决异常方法1
7.4.3 解决异常方法2
7.5 线程中出现异常的处理
7.6 线程组内处理异常
7.7 线程异常处理的传递
7.8 本章总结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程核心技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程实战指南（设计模式篇）
1章  Java多线程编程实战基础	1
1.1  无处不在的线程	1
1.2  线程的创建与运行	2
1.3  线程的状态与上下文切换	5
1.4  线程的监视	7
1.5  原子性、内存可见性和重排序——重新认识synchronized和volatile	10
1.6  线程的优势和风险	11
1.7  多线程编程常用术语	13
第2章  设计模式简介	17
2.1  设计模式及其作用	17
2.2  多线程设计模式简介	20
2.3  设计模式的描述	21
第3章  Immutable Object（不可变对象）模式	23
3.1  Immutable Object模式简介	23
3.2  Immutable Object模式的架构	25
3.3  Immutable Object模式实战案例	27
3.4  Immutable Object模式的评价与实现考量	31
3.5  Immutable Object模式的可复用实现代码	32
3.6  Java标准库实例	32
3.7  相关模式	34
3.7.1  Thread Specific Storage模式（第10章）	34
3.7.2  Serial Thread Confinement模式（第11章）	34
3.8  参考资源	34
第4章  Guarded Suspension（保护性暂挂）模式	35
4.1  Guarded Suspension模式简介	35
4.2  Guarded Suspension模式的架构	35
4.3  Guarded Suspension模式实战案例解析	39
4.4  Guarded Suspension模式的评价与实现考量	45
4.4.1  内存可见性和锁泄漏（Lock Leak）	46
4.4.2  线程过早被唤醒	46
4.4.3  嵌套监视器锁死	47
4.5  Guarded Suspension模式的可复用实现代码	50
4.6  Java标准库实例	50
4.7  相关模式	51
4.7.1  Promise模式（第6章）	51
4.7.2  Producer-Consumer模式（第7章）	51
4.8  参考资源	51
第5章  Two-phase Termination（两阶段终止）模式	52
5.1  Two-phase Termination模式简介	52
5.2  Two-phase Termination模式的架构	53
5.3  Two-phase Termination模式实战案例	56
5.4  Two-phase Termination模式的评价与实现考量	63
5.4.1  线程停止标志	63
5.4.2  生产者-消费者问题中的线程停止	64
5.4.3  隐藏而非暴露可停止的线程	65
5.5  Two-phase Termination模式的可复用实现代码	65
5.6  Java标准库实例	66
5.7  相关模式	66
5.7.1  Producer-Consumer模式（第7章）	66
5.7.2  Master-Slave模式（第12章）	66
5.8  参考资源	66
第6章  Promise（承诺）模式	67
6.1  Promise模式简介	67
6.2  Promise模式的架构	68
6.3  Promise模式实战案例解析	70
6.4  Promise模式的评价与实现考量	74
6.4.1  异步方法的异常处理	75
6.4.2  轮询（Polling）	75
6.4.3  异步任务的执行	75
6.5  Promise模式的可复用实现代码	77
6.6  Java标准库实例	77
6.7  相关模式	78
6.7.1  Guarded Suspension模式（第4章）	78
6.7.2  Active Object模式（第8章）	78
6.7.3  Master-Slave模式（第12章）	78
6.7.4  Factory Method模式	78
6.8  参考资源	79
第7章  Producer-Consumer（生产者/消费者）模式	80
7.1  Producer-Consumer模式简介	80
7.2  Producer-Consumer模式的架构	80
7.3  Producer-Consumer模式实战案例解析	83
7.4  Producer-Consumer模式的评价与实现考量	87
7.4.1  通道积压	87
7.4.2  工作窃取算法	88
7.4.3  线程的停止	92
7.4.4  高性能高可靠性的Producer-Consumer模式实现	92
7.5  Producer-Consumer模式的可复用实现代码	92
7.6  Java标准库实例	93
7.7  相关模式	93
7.7.1  Guarded Suspension模式（第4章）	93
7.7.2  Thread Pool模式（第9章）	93
7.8  参考资源	93
第8章  Active Object（主动对象）模式	94
8.1  Active Object模式简介	94
8.2  Active Object模式的架构	95
8.3  Active Object模式实战案例解析	98
8.4  Active Object模式的评价与实现考量	105
8.4.1  错误隔离	107
8.4.2  缓冲区监控	108
8.4.3  缓冲区饱和处理策略	108
8.4.4  Scheduler空闲工作者线程清理	109
8.5  Active Object模式的可复用实现代码	109
8.6  Java标准库实例	111
8.7  相关模式	112
8.7.1  Promise模式（第6章）	112
8.7.2  Producer-Consumer模式（第7章）	112
8.8  参考资源	112
第9章  Thread Pool（线程池）模式	113
9.1  Thread Pool模式简介	113
9.2  Thread Pool模式的架构	114
9.3  Thread Pool模式实战案例解析	116
9.4  Thread Pool模式的评价与实现考量	117
9.4.1  工作队列的选择	118
9.4.2  线程池大小调校	119
9.4.3  线程池监控	121
9.4.4  线程泄漏	122
9.4.5  可靠性与线程池饱和处理策略	122
9.4.6  死锁	125
9.4.7  线程池空闲线程清理	126
9.5  Thread Pool模式的可复用实现代码	127
9.6  Java标准库实例	127
9.7  相关模式	127
9.7.1  Two-phase Termination模式（第5章）	127
9.7.2  Promise模式（第6章）	127
9.7.3  Producer-Consumer模式（第7章）	127
9.8  参考资源	128
第10章  Thread Specific Storage（线程特有存储）模式	129
10.1  Thread Specific Storage模式简介	129
10.2  Thread Specific Storage模式的架构	131
10.3  Thread Specific Storage模式实战案例解析	133
10.4  Thread Specific Storage模式的评价与实现考量	135
10.4.1  线程池环境下使用Thread Specific Storage模式	138
10.4.2  内存泄漏与伪内存泄漏	139
10.5  Thread Specific Storage模式的可复用实现代码	145
10.6  Java标准库实例	146
10.7  相关模式	146
10.7.1  Immutable Object模式（第3章）	146
10.7.2  Proxy（代理）模式	146
10.7.3  Singleton（单例）模式	146
10.8  参考资源	147
第11章  Serial Thread Confinement（串行线程封闭）模式	148
11.1  Serial Thread Confinement模式简介	148
11.2  Serial Thread Confinement模式的架构	148
11.3  Serial Thread Confinement模式实战案例解析	151
11.4  Serial Thread Confinement模式的评价与实现考量	155
11.4.1  任务的处理结果	155
11.5  Serial Thread Confinement模式的可复用实现代码	156
11.6  Java标准库实例	160
11.7  相关模式	160
11.7.1  Immutable Object模式（第3章）	160
11.7.2  Promise模式（第6章）	160
11.7.3  Producer-Consumer模式（第7章）	160
11.7.4  Thread Specific Storage（线程特有存储）模式 （第10章）	161
11.8  参考资源	161
第12章  Master-Slave（主仆）模式	162
12.1  Master-Slave模式简介	162
12.2  Master-Slave模式的架构	162
12.3  Master-Slave模式实战案例解析	164
12.4  Master-Slave模式的评价与实现考量	171
12.4.1  子任务的处理结果的收集	172
12.4.2  Slave参与者实例的负载均衡与工作窃取	173
12.4.3  可靠性与异常处理	173
12.4.4  Slave线程的停止	174
12.5  Master-Slave模式的可复用实现代码	174
12.6  Java标准库实例	186
12.7  相关模式	186
12.7.1  Two-phase Termination模式（第5章）	186
12.7.2  Promise模式（第6章）	186
12.7.3  Strategy（策略）模式	186
12.7.4  Template（模板）模式	186
12.7.5  Factory Method（工厂方法）模式	186
12.8  参考资源	187
第13章  Pipeline（流水线）模式	188
13.1  Pipeline模式简介	188
13.2  Pipeline模式的架构	189
13.3  Pipeline模式实战案例解析	194
13.4  Pipeline模式的评价与实现考量	208
13.4.1  Pipeline的深度	209
13.4.2  基于线程池的Pipe	209
13.4.3  错误处理	212
13.4.4  可配置的Pipeline	212
13.5  Pipeline模式的可复用实现代码	212
13.6  Java标准库实例	222
13.7  相关模式	222
13.7.1  Serial Thread Confinement模式（第11章）	222
13.7.2  Master-Slave模式（第12章）	222
13.7.3  Composite模式	223
13.8  参考资源	223
第14章  Half-sync/Half-async（半同步/半异步）模式	224
14.1  Half-sync/Half-async模式简介	224
14.2  Half-sync/Half-async模式的架构	224
14.3  Half-sync/Half-async模式实战案例解析	226
14.4  Half-sync/Half-async模式的评价与实现考量	234
14.4.1  队列积压	235
14.4.2  避免同步层处理过慢	235
14.5  Half-sync/Half-async模式的可复用实现代码	236
14.6  Java标准库实例	240
14.7  相关模式	240
14.7.1  Two-phase Termination模式（第5章）	240
14.7.2  Producer-Consumer模式（第7章）	241
14.7.3  Active Object模式（第8章）	241
14.7.4  Thread Pool模式（第9章）	241
14.8  参考资源	241
第15章  模式语言	242
15.1  模式与模式间的联系	242
15.2  mmutable Object（不可变对象）模式	244
15.3  Guarded Suspension（保护性暂挂）模式	244
15.4  Two-phase Termination（两阶段终止）模式	245
15.5  Promise（承诺）模式	246
15.6  Producer-Consumer（生产者/消费者）模式	247
15.7  Active Object（主动对象）模式	248
15.8  Thread Pool（线程池）模式	249
15.9  Thread Specific Storage（线程特有存储）模式	250
15.10  Serial Thread Confinement（串行线程封闭）模式	251
15.11  Master-Slave（主仆）模式	252
15.12  Pipeline（流水线）模式	253
15.13  Half-sync/Half-async（半同步/半异步）模式	254
附录  本书常用UML图指南	255
A.1  UML简介	255
A.2  类图（Class Diagram）	256
A.1.1  类的属性、方法和立体型（Stereotype）	256
A.1.2  类与类之间的关系	258
A.3  序列图（Sequence Diagram）	261
参考文献	263
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程实战指南（设计模式篇）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图解Java多线程设计模式
序章1　Java线程　　1
I1.1　Java线程　　2
I1.2　何谓线程　　2
明为跟踪处理流程，实为跟踪线程　　2
单线程程序　　3
多线程程序　　4
Thread类的run方法和start方法　　5
I1.3　线程的启动　　9
线程的启动（1）——利用Thread类的子类　　9
线程的启动（2）——利用Runnable接口　　10
I1.4　线程的暂停　　12
I1.5　线程的互斥处理　　13
synchronized方法　　14
synchronized代码块　　17
I1.6　线程的协作　　18
等待队列——线程休息室　　19
wait方法——将线程放入等待队列　　19
notify方法——从等待队列中取出线程　　21
notifyAll方法——从等待队列中取出所有线程　　23
wait、notify、notifyAll是Object类的方法　　24
I1.7　线程的状态迁移　　24
I1.8　线程相关的其他话题　　26
I1.9　本章所学知识　　26
I1.10　　练习题　　26
序章2　多线程程序的评价标准　　31
I2.1　多线程程序的评价标准　　32
安全性——不损坏对象　　32
生存性——必要的处理能够被执行　　32
可复用性——类可重复利用　　33
性能——能快速、大批量地执行处理　　33
评价标准总结　　33
I2.2　本章所学知识　　34
I2.3　练习题　　34
第1章　　Single Threaded Execution模式——能通过这座桥的只有一个人　　35
1.1　Single Threaded Execution模式　　36
1.2　示例程序1：不使用Single Threaded Execution模式的程序　　36
Main类　　37
非线程安全的Gate类　　37
UserThread类　　38
执行起来看看……出错了　　39
为什么会出错呢　　40
1.3　示例程序2：使用Single Threaded Execution模式的程序　　41
线程安全的Gate类　　41
synchronized的作用　　42
1.4　Single Threaded Execution模式中的登场角色　　43
1.5　拓展思路的要点　　44
何时使用（可使用Single Threaded Execution模式的情况）　　44
生存性与死锁　　45
可复用性和继承反常　　46
临界区的大小和性能　　46
1.6　相关的设计模式　　47
Guarded Suspension模式　　47
Read-Write Lock模式　　47
Immutable模式　　47
Thread-Specific Storage模式　　48
1.7　延伸阅读1：关于synchronized　　48
synchronized语法与Before/After模式　　48
synchronized在保护着什么　　49
该以什么单位来保护呢　　50
使用哪个锁保护　　50
原子操作　　51
long与double的操作不是原子的　　51
1.8　延伸阅读2：java.util.concurrent包和计数信号量　　52
计数信号量和Semaphore类　　52
使用Semaphore类的示例程序　　52
1.9　本章所学知识　　55
1.10　　练习题　　55
第2章　　Immutable模式——想破坏也破坏不了　　61
2.1　Immutable模式　　62
2.2　示例程序　　62
使用Immutable模式的Person类　　62
Main类　　63
PrintPersonThread类　　63
2.3　Immutable模式中的登场角色　　65
2.4　拓展思路的要点　　66
何时使用（可使用Immutable模式的情况）　　66
考虑成对的mutable类和immutable类 [性能]　　66
为了确保不可变性 [可复用性]　　67
标准类库中用到的Immutable模式　　67
2.5　相关的设计模式　　69
Single Threaded Execution模式　　69
Read-Write Lock模式　　69
Flyweight模式　　69
2.6　延伸阅读1：final　　69
final的含义　　69
2.7　延伸阅读2：集合类与多线程　　71
示例1：非线程安全的java.util.ArrayList类　　71
示例2：利用Collections.synchronizedList方法所进行的同步　　74
示例3：使用copy-on-write的java.util.concurrent.CopyOnWriteArrayList类　　75
2.8　本章所学知识　　76
2.9　练习题　　77
第3章　　Guarded Suspension模式——等我准备好哦　　81
3.1　Guarded Suspension模式　　82
3.2　示例程序　　82
Request类　　83
RequestQueue类　　84
ClientThread类　　85
ServerThread类　　85
Main类　　86
java.util.Queue与java.util.LinkedList的操作　　87
getRequest详解　　87
putRequest详解　　89
synchronized的含义　　89
wait与锁　　89
3.3　Guarded Suspension模式中的登场角色　　90
3.4　拓展思路的要点　　91
附加条件的synchronized　　91
多线程版本的if　　91
忘记改变状态与生存性　　91
wait与notify/notifyAll的责任 [可复用性]　　91
各种称呼　　91
使用java.util.concurrent.LinkedBlockingQueue的示例程序　　93
3.5　相关的设计模式　　94
Single Threaded Execution模式　　94
Balking模式　　94
Producer-Consumer模式　　94
Future模式　　94
3.6　本章所学知识　　95
3.7　练习题　　95
第4章　　Balking模式——不需要就算了　　99
4.1　Balking模式　　100
4.2　示例程序　　100
Data类　　100
SaverThread类　　102
ChangerThread类　　102
Main类　　103
4.3　Balking模式中的登场角色　　105
4.4　拓展思路的要点　　106
何时使用（可使用Balking模式的情况）　　106
balk结果的表示方式　　107
4.5　相关的设计模式　　107
Guarded Suspension模式　　107
Observer模式　　107
4.6　延伸阅读：超时　　108
Balking模式和Guarded Suspension模式之间　　108
wait何时终止呢　　108
guarded timed的实现（使用wait）　　109
synchronized中没有超时，也不能中断　　110
java.util.concurrent中的超时　　111
4.7　本章所学知识　　111
4.8　练习题　　112
第5章　　Producer-Consumer模式——我来做，你来用　　115
5.1　Producer-Consumer模式　　116
5.2　示例程序　　116
Main类　　116
MakerThread类　　117
EaterThread类　　118
Table类　　118
解读put方法　　120
解读take方法　　121
5.3　Producer-Consumer模式中的登场角色　　122
5.4　拓展思路的要点　　123
守护安全性的Channel角色（可复用性）　　123
不可以直接传递吗　　124
Channel角色的剩余空间所导致的问题　　124
以什么顺序传递Data角色呢　　125
“存在中间角色”的意义　　125
Consumer角色只有一个时会怎么样呢　　126
5.5　相关的设计模式　　126
Mediator模式　　126
Worker Thread模式　　126
Command模式　　126
Strategy模式　　127
5.6　延伸阅读1：理解InterruptedException异常　　127
可能会花费时间，但可以取消　　127
加了throws InterruptedException的方法　　127
sleep方法和interrupt方法　　128
wait方法和interrupt方法　　128
join方法和interrupt方法　　129
interrupt方法只是改变中断状态　　129
isInterrupted方法——检查中断状态　　130
Thread.interrupted方法——检查并清除中断状态　　130
不可以使用Thread类的stop方法　　130
5.7　延伸阅读2：java.util.concurrent包和Producer-Consumer模式　　131
java.util.concurrent包中的队列　　131
使用java.util.concurrent.ArrayBlockingQueue的示例程序　　132
使用java.util.concurrent.Exchanger类交换缓冲区　　133
5.8　本章所学知识　　136
5.9　练习题　　137
第6章　　Read-Write Lock模式——大家一起读没问题，但读的时候不要写哦　　141
6.1　Read-Write Lock模式　　142
6.2　示例程序　　142
Main类　　143
Data类　　143
WriterThread类　　146
ReaderThread类　　146
ReadWriteLock类　　147
执行起来看看　　149
守护条件的确认　　150
6.3　Read-Write Lock模式中的登场角色　　151
6.4　拓展思路的要点　　153
利用“读取”操作的线程之间不会冲突的特性来提高程序性能　　153
适合读取操作繁重时　　153
适合读取频率比写入频率高时　　153
锁的含义　　153
6.5　相关的设计模式　　154
Immutable模式　　154
Single Threaded Execution模式　　154
Guarded Suspension模式　　154
Before/After模式　　154
Strategized Locking模式　　154
6.6　延伸阅读：java.util.concurrent.locks包和Read-Write Lock模式　　154
java.util.concurrent.locks包　　154
使用java.util.concurrent.locks的示例程序　　155
6.7　本章所学知识　　156
6.8　练习题　　157
第7章　　Thread-Per-Message模式——这项工作就交给你了　　163
7.1　Thread-Per-Message模式　　164
7.2　示例程序　　164
Main类　　164
Host类　　165
Helper类　　166
7.3　Thread-Per-Message模式中的登场角色　　168
7.4　拓展思路的要点　　169
提高响应性，缩短延迟时间　　169
适用于操作顺序没有要求时　　169
适用于不需要返回值时　　169
应用于服务器　　169
调用方法＋启动线程→发送消息　　170
7.5　相关的设计模式　　170
Future模式　　170
Worker Thread模式　　170
7.6　延伸阅读1：进程与线程　　171
7.7　延伸阅读2：java.util.concurrent包和Thread-Per-Message模式　　171
java.lang.Thread类　　171
java.lang.Runnable接口　　172
java.util.concurrent.ThreadFactory接口　　173
java.util.concurrent.Executors类获取的ThreadFactory　　174
java.util.concurrent.Executor接口　　175
java.util.concurrent.ExecutorService接口　　176
java.util.concurrent.ScheduledExecutorService类　　177
总结　　178
7.8　本章所学知识　　180
7.9　练习题　　180
第8章　　Worker Thread模式——工作没来就一直等，工作来了就干活　　187
8.1　Worker Thread模式　　188
8.2　示例程序　　188
Main类　　189
ClientThread类　　190
Request类　　190
Channel类　　191
WorkerThread类　　192
8.3　Worker Thread模式中的登场角色　　193
8.4　拓展思路的要点　　195
提高吞吐量　　195
容量控制　　195
调用与执行的分离　　196
Runnable接口的意义　　197
多态的Request角色　　198
独自一人的Worker角色　　199
8.5　相关的设计模式　　199
Producer-Consumer模式　　199
Thread-Per-Message模式　　199
Command模式　　199
Future模式　　199
Flyweight模式　　199
Thread-Specific Storage模式　　200
Active Ojbect模式　　200
8.6　延伸阅读1：Swing事件分发线程　　200
什么是事件分发线程　　200
事件分发线程只有一个　　200
事件分发线程调用监听器　　201
注册监听器的意义　　201
事件分发线程也负责绘制界面　　201
javax.swing.SwingUtilities类　　202
Swing的单线程规则　　203
8.7　延伸阅读2：java.util.concurrent包和Worker Thread模式　　204
ThreadPoolExecutor类　　204
通过java.util.concurrent包创建线程池　　205
8.8　本章所学知识　　207
8.9　练习题　　208
第9章　　Future模式——先给您提货单　　211
9.1　Future模式　　212
9.2　示例程序　　212
Main类　　214
Host类　　214
Data接口　　215
FutureData类　　216
RealData类　　217
9.3　Future模式中的登场角色　　218
9.4　拓展思路的要点　　219
吞吐量会提高吗　　219
异步方法调用的“返回值”　　220
“准备返回值”和“使用返回值”的分离　　220
变种——不让主线程久等的Future角色　　220
变种——会发生变化的Future角色　　221
谁会在意多线程呢？“可复用性”　　221
回调与Future模式　　221
9.5　相关的设计模式　　222
Thread-Per-Message模式　　222
Builder模式　　222
Proxy模式　　222
Guarded Suspension模式　　222
Balking模式　　222
9.6　延伸阅读：java.util.concurrent包与Future模式　　222
java.util.concurrent包　　222
使用了java.util.concurrent包的示例程序　　223
9.7　本章所学知识　　226
9.8　练习题　　226
第10章　　Two-Phase Termination模式——先收拾房间再睡觉　　231
10.1　Two-Phase Termination模式　　232
10.2　示例程序　　233
CountupThread类　　234
Main类　　236
10.3　Two-Phase Termination模式中的登场角色　　237
10.4　拓展思路的要点　　238
不能使用Thread类的stop方法　　238
仅仅检查标志是不够的　　239
仅仅检查中断状态是不够的　　239
在长时间处理前检查终止请求　　239
join方法和isAlive方法　　240
java.util.concurrent.ExecutorService接口与Two-Phase Termination模式　　240
要捕获程序整体的终止时　　241
优雅地终止线程　　243
10.5　相关的设计模式　　243
Before/After模式　　243
Multiphase Cancellation模式　　243
Multi-Phase Startup模式　　244
Balking模式　　244
10.6　延伸阅读1：中断状态与InterruptedException异常的相互转换　　244
中断状态→InterruptedException异常的转换　　244
InterruptedException异常→中断状态的转换　　245
InterruptedException异常→InterruptedException异常的转换　　245
10.7　延伸阅读2：java.util.concurrent包与线程同步　　246
java.util.concurrent.CountDownLatch类　　246
java.util.concurrent.CyclicBarrier类　　249
10.8　本章所学知识　　253
10.9　练习题　　253
第11章　　Thread-Specific Storage模式——一个线程一个储物柜　　263
11.1　Thread-Specific Storage模式　　264
11.2　关于java.lang.ThreadLocal类　　264
java.lang.ThreadLocal就是储物间　　264
java.lang.ThreadLocal与泛型　　265
11.3　示例程序1：不使用Thread-Specific Storage模式的示例　　265
Log类　　266
Main类　　266
11.4　示例程序2：使用了Thread-Specific Storage模式的示例　　267
线程特有的TSLog类　　268
Log类　　269
ClientThread类　　270
Main类　　271
11.5　Thread-Specific Storage模式中的登场角色　　272
11.6　拓展思路的要点　　274
局部变量与java.lang.ThreadLocal类　　274
保存线程特有的信息的位置　　275
不必担心其他线程访问　　275
吞吐量的提高很大程序上取决于实现方式　　276
上下文的危险性　　276
11.7　相关的设计模式　　277
Singleton模式　　277
Worker Thread模式　　277
Single Threaded Execution模式　　277
Proxy模式　　277
11.8　延伸阅读：基于角色与基于任务　　277
主体与客体　　277
基于角色的考虑方式　　278
基于任务的考虑方式　　278
实际上两种方式是综合在一起的　　279
11.9　本章所学知识　　279
11.10　　练习题　　280
第12章　　Active Object模式——接收异步消息的主动对象　　283
12.1　Active Object模式　　284
12.2　示例程序1　284
调用方：Main类　　287
调用方：MakerClientThread类　　288
调用方：DisplayClientThread类　　289
主动对象方：ActiveObject接口　　289
主动对象方：ActiveObjectFactory类　　290
主动对象方：Proxy类　　290
主动对象方：SchedulerThread类　　291
主动对象方：ActivationQueue类　　292
主动对象方：MethodRequest类　　293
主动对象方：MakeStringRequest类　　294
主动对象方：DisplayStringRequest类　　295
主动对象方：Result类　　295
主动对象方：FutureResult类　　296
主动对象方：RealResult类　　296
主动对象方：Servant类　　297
示例程序1的运行　　297
12.3　ActiveObject模式中的登场角色　　298
12.4　拓展思路的要点　　304
到底做了些什么事情　　304
运用模式时需要考虑问题的粒度　　304
关于并发性　　304
增加方法　　305
Scheduler角色的作用　　305
主动对象之间的交互　　306
通往分布式——从跨越线程界线变为跨越计算机界线　　306
12.5　相关的设计模式　　306
Producer-Consumer模式　　306
Future模式　　307
Worker Thread模式　　307
Thread-Specific Storage模式　　307
12.6　延伸阅读：java.util.concurrent包与Active Object模式　　307
类与接口　　307
调用方：Main类　　309
调用方：MakerClientThread类　　309
调用方：DisplayClientThread类　　310
主动对象方：ActiveObject接口　　311
主动对象方：ActiveObjectFactory类　　311
主动对象：ActiveObjectImpl类　　312
示例程序2的运行　　313
12.7　本章所学知识　　314
12.8　练习题　　315
第13章　　总结——多线程编程的模式语言　　321
13.1　多线程编程的模式语言　　322
模式与模式语言　　322
13.2　Single Threaded Execution模式
——能通过这座桥的只有一个人　　323
13.3　Immutable模式
——想破坏也破坏不了　　324
13.4　Guarded Suspension模式
——等我准备好哦　　325
13.5　Balking模式
——不需要就算了　　326
13.6　Producer-Consumer模式
——我来做，你来用　　327
13.7　Read-Write Lock模式
——大家一起读没问题，但读的时候不要写哦　　328
13.8　Thread-Per-Message模式
——这项工作就交给你了　　329
13.9　Worker Thread模式
——工作没来就一直等，工作来了就干活　　330
13.10　　Future模式
——先给您提货单　　330
13.11　Two-Phase Termination模式
——先收拾房间再睡觉　　331
13.12　Thread-Specific Storage模式
——一个线程一个储物柜　　332
13.13　Active Object模式
——接收异步消息的主动对象　　333
13.14　写在最后　　335
附录　　337
附录A　习题解答　　338
附录B　Java内存模型　　447
附录C　Java线程的优先级　　467
附录D　线程相关的主要API　　469
附录E　java.util.concurrent包　　475
附录F　示例程序的运行步骤　　483
附录G　参考文献　　485
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图解Java多线程设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程实战指南（核心篇）
第一部分  多线程编程基础
第1章  走近Java世界中的线程	2
1.1  进程、线程与任务	2
1.2  多线程编程简介	4
1.2.1  什么是多线程编程	4
1.2.2  为什么使用多线程	4
1.3  Java线程API简介	5
1.3.1  线程的创建、启动与运行	5
1.3.2  Runnable接口	9
1.3.3  线程属性	12
1.3.4  Thread类的常用方法	14
1.3.5  Thread类的一些废弃方法	16
1.4  无处不在的线程	17
1.5  线程的层次关系	19
1.6  线程的生命周期状态	21
1.7  线程的监视	22
1.8  多线程编程简单运用实例	26
*1.9  多线程编程的优势和风险	27
1.10  本章小结	29
第2章  多线程编程的目标与挑战	31
2.1  串行、并发与并行	31
2.2  竞态	33
2.2.1  二维表分析法：解释竞态的结果	37
2.2.2  竞态的模式与竞态产生的条件	39
2.3  线程安全性	42
2.4  原子性	43
2.5  可见性	49
2.6  有序性	56
2.6.1  重排序的概念	56
2.6.2  指令重排序	57
2.6.3  存储子系统重排序	63
2.6.4  貌似串行语义	66
2.6.5  保证内存访问的顺序性	68
2.7  上下文切换	69
2.7.1  上下文切换及其产生原因	69
2.7.2  上下文切换的分类及具体诱因	70
2.7.3  上下文切换的开销和测量	71
2.8  线程的活性故障	73
2.9  资源争用与调度	74
2.10  本章小结	77
第3章  Java线程同步机制	80
3.1  线程同步机制简介	80
3.2  锁概述	81
3.2.1  锁的作用	82
3.2.2  与锁相关的几个概念	84
3.2.3  锁的开销及其可能导致的问题	86
3.3  内部锁：synchronized关键字	86
3.4  显式锁：Lock接口	89
3.4.1  显式锁的调度	91
3.4.2  显式锁与内部锁的比较	92
3.4.3  内部锁还是显式锁：锁的选用	95
*3.4.4  改进型锁：读写锁	95
3.5  锁的适用场景	99
3.6  线程同步机制的底层助手：内存屏障	99
*3.7  锁与重排序	102
3.8  轻量级同步机制：volatile关键字	105
3.8.1  volatile的作用	105
3.8.2  volatile变量的开销	111
3.8.3  volatile的典型应用场景与实战案例	111
3.9  实践：正确实现看似简单的单例模式	120
3.10  CAS与原子变量	126
3.10.1  CAS	127
3.10.2  原子操作工具：原子变量类	129
3.11  对象的发布与逸出	135
3.11.1  对象的初始化安全：重访final与static	137
3.11.2  安全发布与逸出	142
3.12  本章小结	143
第4章  牛刀小试：玩转线程	148
4.1  挖掘可并发点	148
4.2  新战场上的老武器：分而治之	148
4.3  基于数据的分割实现并发化	149
4.4  基于任务的分割实现并发化	158
4.4.1  按任务的资源消耗属性分割	159
4.4.2  实战案例的启发	169
4.4.3  按处理步骤分割	171
4.5  合理设置线程数	172
4.5.1  Amdahl's定律	172
4.5.2  线程数设置的原则	173
4.6  本章小结	177
第5章  线程间协作	179
5.1  等待与通知：wait/notify	179
5.1.1  wait/notify的作用与用法	180
5.1.2  wait/notify的开销及问题	188
5.1.3  Object.notify()/notifyAll()的选用	191
*5.1.4  wait/notify与Thread.join()	191
5.2  Java条件变量	192
5.3  倒计时协调器：CountDownLatch	198
5.4  栅栏（CyclicBarrier）	203
5.5  生产者—消费者模式	210
5.5.1  阻塞队列	213
5.5.2  限购：流量控制与信号量（Semaphore）	216
*5.5.3  管道：线程间的直接输出与输入	218
5.5.4  一手交钱，一手交货：双缓冲与Exchanger	221
5.5.5  一个还是一批：产品的粒度	223
5.5.6  再探线程与任务之间的关系	224
5.6  对不起，打扰一下：线程中断机制	225
5.7  线程停止：看似简单，实则不然	228
5.7.1  生产者—消费者模式中的线程停止	233
5.7.2  实践：Web应用中的线程停止	233
5.8  本章小结	236
第6章  保障线程安全的设计技术	240
*6.1  Java运行时存储空间	240
6.2  大公无私：无状态对象	243
6.3  以“不变”应万变：不可变对象	248
6.4  我有我地盘：线程特有对象	254
6.4.1  线程特有对象可能导致的问题及其规避	258
6.4.2  线程特有对象的典型应用场景	264
6.5  装饰器模式	265
6.6  并发集合	267
6.7  本章小结	270
第7章  线程的活性故障	273
7.1  鹬蚌相争：死锁	273
7.1.1  死锁的检测	274
7.1.2  死锁产生的条件与规避	283
7.1.3  死锁的恢复	296
7.2  沉睡不醒的睡美人：锁死	301
7.2.1  信号丢失锁死	301
7.2.2  嵌套监视器锁死	301
7.3  巧妇难为无米之炊：线程饥饿	307
7.4  屡战屡败，屡败屡战：活锁	307
7.5  本章小结	308
第8章  线程管理	310
8.1  线程组	310
8.2  可靠性：线程的未捕获异常与监控	311
8.3  有组织有纪律：线程工厂	316
8.4  线程的暂挂与恢复	318
8.5  线程的高效利用：线程池	320
8.5.1  任务的处理结果、异常处理与取消	326
8.5.2  线程池监控	329
8.5.3  线程池死锁	330
8.5.4  工作者线程的异常终止	330
8.6  本章小结	331
第9章  Java异步编程	333
9.1  同步计算与异步计算	333
9.2  Java Executor框架	336
9.2.1  实用工具类Executors	337
9.2.2  异步任务的批量执行：CompletionService	339
9.3  异步计算助手：FutureTask	344
9.3.1  实践：实现XML文档的异步解析	345
9.3.2  可重复执行的异步任务	349
9.4  计划任务	352
9.5  本章小结	358
第10章  Java多线程程序的调试与测试	360
10.1  多线程程序的调试技巧	360
10.1.1  使用监视点	360
10.1.2  设置暂挂策略	361
10.2  多线程程序的测试	363
10.2.1  可测试性	364
10.2.2  静态检查工具：FindBugs	369
10.2.3  多线程程序的代码复审	370
10.2.4  多线程程序的单元测试：JCStress	372
10.3  本章小结	375
第二部分  多线程编程进阶
第11章  多线程编程的硬件基础与Java内存模型	378
11.1  填补处理器与内存之间的鸿沟：高速缓存	378
11.2  数据世界的交通规则：缓存一致性协议	382
11.3  硬件缓冲区：写缓冲器与无效化队列	386
11.3.1  存储转发	388
11.3.2  再探内存重排序	388
11.3.3  再探可见性	391
11.4  基本内存屏障	392
11.5  Java同步机制与内存屏障	395
11.5.1  volatile关键字的实现	395
11.5.2  synchronized关键字的实现	397
11.5.3  Java虚拟机对内存屏障使用的优化	398
11.5.4  final关键字的实现	398
11.6  Java内存模型	399
11.6.1  什么是Java内存模型	400
11.6.2  happen(s)-before关系	401
11.6.3  再探对象的安全发布	407
11.6.4  JSR 133	411
11.7  共享变量与性能	411
11.8  本章小结	411
第12章  Java多线程程序的性能调校	415
12.1  Java虚拟机对内部锁的优化	415
12.1.1  锁消除	415
12.1.2  锁粗化	417
12.1.3  偏向锁	419
12.1.4  适应性锁	420
12.2  优化对锁的使用	421
12.2.1  锁的开销与锁争用监视	421
12.2.2  使用可参数化锁	424
12.2.3  减小临界区的长度	428
12.2.4  减小锁的粒度	432
12.2.5  考虑锁的替代品	438
12.3  减少系统内耗：上下文切换	438
12.4  多线程编程的“三十六计”：多线程设计模式	440
12.5  性能的隐形杀手：伪共享	441
12.5.1  Java对象内存布局	442
12.5.2  伪共享的侦测与消除	445
12.6  本章小结	454
Web参考资源	457
参考文献	463
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程实战指南（核心篇）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>POSIX多线程程序设计
序言
第1章 概述
1.1 舀水的程序员
1.2 术语定义
1.3 异步编程是直观的
1.4 关于本书的实例
1.5 异步编程举例

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>POSIX多线程程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程与Socket：实战微服务框架
第1章  多线程基础
1.1  多线程的概念
1.1.1  进程与线程
1.1.2  并发与并行
1.1.3  线程状态
1.2  Thread线程类
1.2.1  基本用法与思考
1.2.2  常用方法介绍
1.2.3  wait和sleep的区别
1.2.4  sleep和yield的区别
1.3  Runnable接口
1.4  线程池
1.4.1  Executors
1.4.2  ExecutorService
1.4.3  ThreadPoolExecutor
1.4.4  基本用法与思考
1.5  Callable与Future
1.6  线程安全与效率
1.6.1  什么是线程安全
1.6.2  线程同步
1.6.3  饥饿与公平
1.6.4  锁与死锁
1.6.5  线程中断
1.7  编程进阶
1.7.1  volatile关键字
1.7.2  synchronized关键字
1.7.3  wait/notify/notifyAll
1.7.4  CAS操作
1.7.5  atomic包
1.7.6  Lock自旋锁
1.7.7  Condition条件变量
1.7.8  线程安全容器
1.7.9  ThreadLocal类
1.7.10  CountDownLatch计数器
1.7.11  CyclicBarrier栅栏
1.7.12  Semaphore信号量
1.7.13  fork/join框架
第2章  Socket基础
2.1  TCP与Socket
2.2  TCP的通信过程
2.2.1  基本过程
2.2.2  建立连接
2.2.3  全双工异步通信
2.2.4  断开连接
2.2.5  优雅地断开
2.2.6  半……连接
2.3  通信方式
2.3.1  长连接与短连接
2.3.2  线程模型
2.3.3  拆包与组包
2.3.4  断包与粘包
2.3.5  数据包的结构
2.4  BIO
2.4.1  典型编程模型
2.4.2  关键API概述
2.4.3  字符流传输
2.4.4  字节流传输
2.4.5  传输多笔数据
2.5  NIO
2.5.1  NIO简介
2.5.2  Buffer
2.5.3  Channel
2.5.4  Selector
2.5.5  Scatter/Gather
2.5.6  Pipe
2.5.7  内存映像文件
2.5.8  文件传输示例
2.5.9  “聊天室”示例
2.6  AIO
2.6.1  AIO简介
2.6.2  关键API概述
2.6.3  示例代码
第3章  Spring与Spring Cloud
3.1  Spring简介
3.2  IoC容器
3.2.1  IoC的概念
3.2.2  Spring中的bean
3.2.3  XML配置方式
3.2.4  注解配置方式
3.2.5  用Java类来配置
3.2.6  BeanFactory与FactoryBean
3.2.7  ApplicationContext与ApplicationContextAware
3.2.8  动态注册bean配置
3.2.9  ApplicationListener与容器事件
3.3  bean的基本配置
3.3.1  scope属性
3.3.2  parent与abstract
3.3.3  factory-bean与factory-method
3.3.4  bean的初始化与释放
3.4  依赖注入
3.4.1  setter注入
3.4.2  工厂方式注入
3.4.3  构造器注入
3.4.4  注解注入
3.5  Spring Boot
3.5.1  快速创建工程
3.5.2  编码与测试
3.5.3  打包部署
3.5.4  辅助开发工具
3.5.5  监控功能
3.6  Spring Cloud
3.6.1  Spring Cloud简介
3.6.2  架构设计
3.6.3  创建应用
3.6.4  服务的注册与发现
3.6.5  服务配置
3.6.6  Ribbon负载均衡
3.6.7  Feign服务调用
3.6.8  Hystrix
3.6.9  Zuul服务路由
3.6.10  服务监控
第4章  动态代理
4.1  代理模式
4.2  静态代理
4.3  类的装载
4.4  Java反射
4.5  JDK动态代理
4.6  CGLIB动态代理
4.7  Java Compiler API
4.8  Javassist动态代理
第5章  对象序列化
5.1  什么是序列化
5.2  Java序列化
5.2.1  基本用法
5.2.2  关于serialVersionUID
5.2.3  自定义序列化
5.2.4  封装实现代码
5.3  Hessian序列化
5.4  Kryo序列化
5.5  FST序列化
5.6  其他序列化组件
5.7  集成与扩展
5.7.1  优雅地集成
5.7.2  使用Java SPI
5.7.3  使用Spring
第6章  框架设计
6.1  总体结构
6.1.1  逻辑架构
6.1.2  框架设计概述
6.1.3  RPC原理
6.1.4  工程结构
6.1.5  依赖的jar包
6.1.6  主要的类
6.2  初始化过程
6.2.1  Spring配置
6.2.2  应用节点的启动
6.2.3  Web容器的启动
6.2.4  RpcCore的初始化
6.2.5  RpcContext的初始化
6.3  服务的暴露
6.3.1  服务暴露配置
6.3.2  方法配置与ID
6.3.3  内置的服务方法
6.3.4  服务提供方本地调用器
6.3.5  服务提供方代理生成器
6.3.6  注册要暴露的服务
6.4  服务的引用
6.4.1  服务引用配置
6.4.2  本地引用工厂类
6.4.3  注册本地引用工厂
6.4.4  本地引用与方法ID
6.5  服务的注册与发现
6.5.1  注册表集合
6.5.2  注册表的同步
6.5.3  注册表的解析
6.5.4  提交注册表
6.5.5  注册表推送
6.5.6  注册表检查
6.6  优雅地停机
6.6.1  停机的过程
6.6.2  停机钩子
6.6.3  监听Web容器的关闭
6.6.4  RpcCore的关闭
6.6.5  停机通知的处理
第7章  方法调用
7.1  方法调用类型
7.2  同步调用
7.2.1  同步调用的时序
7.2.2  同步调用的发起
7.2.3  负载均衡
7.2.4  指定服务提供者
7.2.5  失败转移
7.2.6  发送调用请求
7.2.7  处理调用请求
7.2.8  处理调用响应
7.3  异步调用
7.3.1  异步调用的时序
7.3.2  异步调用的发起
7.3.3  异步调用的执行
7.3.4  方法调用对象
7.4  同步/异步通知
7.5  异步回调
7.6  广播调用与广播通知
7.6.1  广播示例
7.6.2  广播代码
第8章  通信层实现
8.1  Socket通信框架
8.1.1  Netty与Mina
8.1.2  为什么要自己写
8.1.3  是NIO还是AIO
8.1.4  设计思路
8.1.5  实际结构
8.2  通信协议
8.2.1  传输对象
8.2.2  数据包结构
8.2.3  拆包与发送
8.2.4  接收并组包
8.3  连接的建立
8.3.1  工作模型
8.3.2  开始监听
8.3.3  发起连接
8.3.4  绑定连接
8.3.5  断线检测
第9章  性能测试与调优
9.1  性能调优概述
9.1.1  性能指标
9.1.2  性能瓶颈
9.1.3  环境因素
9.2  压力测试
9.2.1  测试方法
9.2.2  场景设计
9.2.3  测试环境
9.2.4  Dubbo配置
9.2.5  测试程序
9.3  线程池调优
9.3.1  调整线程池的大小
9.3.2  选择合适的队列
9.3.3  线程的管理逻辑
9.3.4  选择拒绝策略
9.4  优化线程同步
9.4.1  减少上下文切换
9.4.2  避免线程滥用
9.4.3  避免过多的锁
9.4.4  synchronized VS Lock
9.4.5  缩小锁的范围和粒度
9.4.6  线程分析工具
9.5  JVM调优
9.5.1  堆与栈
9.5.2  JVM内存的分代
9.5.3  GC分类
9.5.4  GC算法
9.5.5  分代GC
9.5.6  对象的引用
9.5.7  内存大小设置
9.5.8  内存调优工具
9.6  其他优化内容
9.6.1  避免使用反射
9.6.2  对象池
9.6.3  缓冲区队列
9.6.4  使用直接内存
9.6.5  缓存其他对象
9.6.6  协调与平衡
第10章  服务治理
10.1  服务治理概述
10.1.1  什么是服务治理
10.1.2  服务治理架构
10.1.3  服务治理接口
10.2  服务的定义
10.2.1  服务识别
10.2.2  接口定义
10.2.3  版本管理
10.2.4  协议适配
10.2.5  服务设计
10.2.6  服务的实现
10.2.7  依赖关系管理
10.3  服务的部署
10.3.1  服务的部署方式
10.3.2  自动化部署
10.3.3  服务的热部署
10.4  注册与发现
10.4.1  WSDL与UDDI
10.4.2  ZooKeeper的方案
10.4.3  Eureka的方案
10.4.4  Consul的方案
10.4.5  etcd的方案
10.4.6  注册中心集成方案
10.5  服务的控制
10.5.1  服务状态
10.5.2  服务控制
10.5.3  服务开关
10.5.4  服务模拟
10.5.5  黑白名单
10.5.6  “踢除”服务提供者
10.6  监控与限流
10.6.1  TPS监控与限流
10.6.2  响应时间的监控
10.6.3  调用链的监控
10.6.4  资源监控
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程与Socket：实战微服务框架
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Objective-C高级编程
第1章 自动引用计数　　1
1.1 　什么是自动引用计数　　2
1.2 　内存管理/引用计数　　2
1.2.1 　概要　　2
1.2.2 　内存管理的思考方式　　5
1.2.3 　alloc/retain/release/dealloc实现　　13
1.2.4 　苹果的实现　　17
1.2.5 　autorelease　　20
1.2.6 　autorelease实现　　24
1.2.7 　苹果的实现　　26
1.3 　ARC规则　　29
1.3.1 　概要　　29
1.3.2 　内存管理的思考方式　　30
1.3.3 　所有权修饰符　　30
1.3.4 　规则　　50
1.3.5 　属性　　62
1.3.6 　数组　　63
1.4 　ARC的实现　　65
1.4.1 　__strong修饰符　　65
1.4.2 　__weak修饰符　　67
1.4.3 　__autoreleasing修饰符　　75
1.4.4 　引用计数　　76
第2章 Blocks　　79
2.1 　Blocks概要　　80
2.1.1 　什么是Blocks　　80
2.2 　Blocks模式　　83
2.2.1 　Block语法　　83
2.2.2 　Block类型变量　　85
2.2.3 　截获自动变量值　　88
2.2.4 　__block说明符　　88
2.2.5 　截获的自动变量　　89
2.3 　Blocks的实现　　91
2.3.1 　Block的实质　　91
2.3.2 　截获自动变量值　　99
2.3.3 　__block说明符　　102
2.3.4 　Block存储域　　108
2.3.5 　__block变量存储域　　117
2.3.6 　截获对象　　121
2.3.7 　__block变量和对象　　126
2.3.8 　Block循环引用　　128
2.3.9 　copy/release　　134
第3章 Grand Central Dispatch　　137
3.1 　Grand Central Dispatch（GCD）概要　　138
3.1.1 　什么是GCD　　138
3.1.2 　多线程编程　　140
3.2 　GCD的API　　144
3.2.1 　Dispatch Queue　　144
3.2.2 　dispatch_queue_create　　147
3.2.3 　Main Dispatch Queue/Global Dispatch Queue　　150
3.2.4 　dispatch_set_target_queue　　153
3.2.5 　dispatch_after　　154
3.2.6 　Dispatch Group　　155
3.2.7 　dispatch_barrier_async　　157
3.2.8 　dispatch_sync　　160
3.2.9 　dispatch_apply　　161
3.2.10 　dispatch_suspend / dispatch_resume　　163
3.2.11 　Dispatch Semaphore　　164
3.2.12 　dispatch_once　　166
3.2.13 　Dispatch I/O　　167
3.3 　GCD实现　　169
3.3.1 　Dispatch Queue　　169
3.3.2 　Dispatch Source　　171
附录A 　ARC、Blocks、GCD使用范例　　176
附录B 　参考资料　　182
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Objective-C高级编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>网络编程新冲浪Java2.0网络・多线程编程实例教程（含CD）
目录
第一篇Java语言初步
第1章概述．
1．1Java的历史
1．1．l什么是Java
l．1．2Java带来的影响
l．l．3Java语言的应用前景
1．2Java语言的特点
1．2．1Java是简单的．
1．2．2Java是面向对象的
1．2．3Java是静态类型的
1．2．4JaVa是编译型的
1．2．5Java是体系结构中立的
1．2．6Java是健全的
1．2．7Java是小巧的
1．2．8Java是多线程的
1．2．9Java是可收集无用的存储单元的
1．2．10Java是快速的
1．2．11Java是安全的
1．3几种Java语言的开发工具简介
1．3．1Java如何进行布局管理
1．3．2Java Workshop 2．0
1．3．3JBuilder 1.0
1．3．4VisalAge for Java Enterprise Version 1.0
1．3．5Visual Cafe for Java Database Development Edition 2.0
1．4对Java语言的常见误解
1．4．IJava是HTML的扩充
1．4．2Java是一种很容易学会的编程语言
1．4．3Java是一个简单的编程环境
1．4．4Java将成为所有平台的统一编程语
1．4．5Java是解释型的，它对于特殊平台的重要应用太慢了
l。4．6所有的Java程序都在Web页中运行
1．4．7Java消除了CGI编程的需要
1．4．8Java将彻底改变客户／服务器计算
1．4．9使用Java，用户可以用500美元的Internet设备来代替计算机
1．4．10Java将允许放弃基于部件的计算模式
1．5简单的Java程序
第2章Java程序设计基础
2．1定义常量
2．1．1常量
2．1．2整型常量
2．1．3实型常量
2．l．4字符型常量
2．1．5字符串型常量
2．2定义变量
2．2．1变量
2．2．2整型变量
2．2．3实型变量
2．2．4字符型变量
2．2．5布尔型变量
2．2．6各类数值型数据间的混合运算
2．3运算符和表达式
2．3．1算术运算符
2．3．2关系运算符
2．3．3布尔逻辑运算符
2．3．4位运算符
2．3．5赋值运算符
2．3．6条件运算符
2．3．7表达式
2．4Java流程控制

2．4．1分支语句
2．4．2循环语句
第3章Java面向对象程序设计
3．1面向对象的基本概念
3．1．1对象
3．1．2消息
3．1．3类
3．2对象及对象的使用
3．1．1创建对象
3．2．2引用对象
3．2．3撤消对象
3．3类的定义及实现
3．3．1类说明
3．3．2类体
3．4方法的定义和实现
3．4．l方法的说明
3．4．2方法体
3．4．3构造子
3．4．4析构子
3．5重用技术
3．5．1继承
3．5．2界面
第4章数组与字符串
4．l数组
4．1．1数组的声明及初始化
4．1．2数组的引用
4．1．3多维数组
4．2字符串
4．2．l不可变字符串
4．2．2可变字符串
第5章Java的输入与输出流
5．1InputStream类
5．1．1read()方法
5．1．2available()方法
5．1．3close()方法
5．l．4可标记流
5．1．5skip()方法
5．2OutputStream类
5．2．1write()方法
5．2．2flush()方法
5．2．3close()方法
5．3字节数组的输入输出（I／O）
5．3．1ByteArrayInputStream类
5．3．2ByteArrayInputStream类
5．3．3StringBufferInputStream类
5．4文件输入输出（I／O）
5．4．1File类
5．4．2FileDescriptor类
5．4．3FileInputStream类
5．4．4FileOutputStream类
5．5过滤I／O
5．5．1FilterInputStream类
5．5．2FilterOuputStream类
5．5．3缓冲I/O
5．5．4数据I/O
5．5．5管道I/O
5．6随机访问文件
5．6．1创建随机访问文件
5．6．2访问信息
5．6．3增加信息
5．6．4追加信息例子
5．7StreamTokenizer类
5．8URL输入流
第二篇　IBM VisualAge For Java 3.0程序设计
第6章VisuaAge　for　Java IDE介绍
6．1安装IBM VisualAge for Java
6．1．l运行安装之前
6．1．2安装步骤
6．2建立你的第一个Java小程序
6．2．1创建Java小程序
6．2．2测试Java小程序
6．3VisualAge for JavaIDE概述

6．3．1IDE简介
6．3．2重要概念
6．4测览VisualAge for Java IDE
6．4．1工作台窗口
6．4．2浏览器
6．4．3VisualAge for Java IDE中的符号
与快捷键
6．4．4定制VisualAgeforJavaIDE
6．4．5IDE失效或工作区毁坏
6．4．6Applctat览器
6．4．7查找程序元素
6．4．8在IDE中打印
6．4．9访问上下文敏感API帮助
6．4．10使用快速启动窗口
6．4．11生成类的HTML文档
第7章在IDE中开发应用程序
7．l创建程序和程序元素
7．1．1创建项目
7．1．2创建包
7．1．3Java小程序与Java应用程序
7．1．4生成类
7．1．5生成方法存根
7．1．6创建接口
7．1．7创建方法
7．1．8创建字段
7．1．9生成字段存取方法
7．1．10编写与格式化源代码
7．1．11从资源库向工作区添加项目和包
7．1．12从资源库向工作区添加类和方法
7．1．13更换工作区的修订版
7．1．14动态装入外部类
7．1．15从文件系统导入文件
7．1．16从另一个资源库中导入
7．1．17在项目中包含资源文件
7．2修改程序元素
7．2．1保存更改的代码
7．2．2存储工作区
7．2．3编译代码
7．2．4查找和修正问题
7．2．5版本化程序元素
7．2．6创建开放修订版
7．2．7从工作区删除程序元素
7．2．8复制或移动程序元素
7．2．9重命名程序元素
7．2．10比较两个程序元素
7．2．11比较程序元素的修订版
7．2．12合并类或接日的修订版．
7．3在代码片段编辑测试窗中组织用户思路
7．3．1代码片段编辑测试窗
7．3．2实验代码片段
7．4管理资源库
7．4．1备份资源库
7．4．2从资源库中删除程序元素
7．4．3恢复程序元素
7．4．4压缩资源库
第8章运行和调试程序
8．1运行程序
8．1．l在IDE中运行Applet
8．1．2在IDE中运行应用程序
8．1．3对Applet作运行时更改
8．2调试程序
8．2．1在开发周期中用集成调试器调试
8．2．2手工启动集成调试器
8．2．3挂起、恢复和终止线程
8．2．4在源代码中设置断点
8．2．5配置并设置断点条件
8．2．6在外部类中设置断点
8．2．7选择调试器要捕获的异常
8．2．8清除并且禁止断点
8．2．9检查并修改变量值
8．2．10单步跟踪方法
8．2．11调试过程中修改代码
8．2．12在集成调试器中求值表达式
8．2．13单步执行时监视一个表达式的值
8．2．14生成类跟踪
8．2．15设置调试器选项
8．3导出代码
8．3．1导出代码
8．3．2导出字节码
8．3．3导出资源文件
8．3．4调试导出
8．3．5导出到另一个资源库
第9章异常处理
9．1异常的概念
9．1．1采用新的出错处理机制
9．1．2异常
9．2异常处理
9．2．1try／catch块
9．2．2finally块
9．2．3try／catch／finally组合使用
9．3异常类的层次
9．3．l运行异常
9．3．2非运行异常
9．4激反异
9．5创建自己的异常
9．5．1定义一个新的异常类
9．5．2创建程序中的异常
第10章Java网络编程
10．l网络基础
10．1．l计算机网络的概念、特点及功能
10．1．2网络协议简介
10．1．3IP地址
10．2用InetAddress类进行Internet寻址
10．2．1java．net包
10．2．2用InetAddress类进行Internet寻址
10．3用UM类访问网络资源
10．3．l什么是URL
10．3．2URL类的创建与地址查询
10．3．3用URL类访问资源
10．3．4URL Connection类
10．3．5AppletContext类
10．4Java的Socket通讯机制
10．4．1Socket类
10．4．2有连接通讯方式的客户／服务器应用工作模式
10．5Java的数据报通讯机制
10．5．1数据报简介
10．5．2数据报方式的通讯过程
10．5．3数据报的创建
10．6网络安全措施
10．6．1网络安全与SecurityManager类
10．6．2覆盖Security Manager类中的检验方法
10．6．3安装新的SecurityManager类对象
第11章多线程程序设计
11．1线程相关概念
11．2Java线程的创建
11．2．l继承Thread父类
11．2．2实现hanable接日
11．3线程状态与线程控制
11．4线程组
11‘5线程优先级和线程调度
11．6线程同步和死锁
第12章图形用户界面构件
12．1抽象窗口工具集AWT简介
12．2GUI标准构件的使用方法
12．2．1Component类提供的方法
12．2．2添加构件到容器中
12．2．3改变构件的外观行为
12．3事件处理机制
12．3．l键盘事件
12．3．2鼠标事件
12．3．3动作（Action）事件
12．3．4其他事件
12．4创建用户界面
12，4．1按钮（Button）
12．4．2检查盒（Checkbox）
12．4．3选择框（Choice）
12．4．4标签（Label）
12．4．5列表（List）
12．4．6滚动条（Scrollbar）
12．4．7文本输入域（TextField ＆TextArea）
12．4．8框架（Frame）
12．4．9对话框（Dialog）
12．5布局控制

12．5．1流控制（FlowLayout）
12．5．2边界控制（BorderLayout）
12．5．3栅格控制（GridLayout）
12．5．4卡片控制（CardLayout）
12．5．5栅格包控制（GridBagLayout）
12．6创建和使用菜单．
12．6．1菜单（Menu）简介
12．6．2菜单的创建步骤
12．6．3菜单的事件处理
12．6．4菜单实例
第13章图形和图像
13．1应用components类作图
13．2应用Graphics类
13．2．1颜色
13．2．2作图方法
13．2．3设置大小
13．3处理图像
13．3．l应用MediaTracker
13．3．2创建脱屏图像板面
13．3．3producer和consumer


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>网络编程新冲浪Java2.0网络・多线程编程实例教程（含CD）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程核心技术（第2版）
前言
第1章　Java多线程技能1
1.1　进程和多线程概述1
1.2　使用多线程5
1.2.1　继承Thread类5
1.2.2　使用常见命令分析线程的信息8
1.2.3　线程随机性的展现11
1.2.4　执行start()的顺序不代表执行run()的顺序12
1.2.5　实现Runnable接口13
1.2.6　使用Runnable接口实现多线程的优点14
1.2.7　实现Runnable接口与继承Thread类的内部流程16
1.2.8　实例变量共享造成的非线程安全问题与解决方案17
1.2.9　Servlet技术造成的非线程安全问题与解决方案21
1.2.10　留意i--与System.out.println()出现的非线程安全问题24
1.3　currentThread()方法26
1.4　isAlive()方法29
1.5　sleep(long millis)方法31
1.6　sleep(long millis, int nanos)方法33
1.7　StackTraceElement[] getStackTrace()方法33
1.8　static void dumpStack()方法35
1.9　static Map<Thread, StackTrace-Element[]> getAllStackTraces()方法36
1.10　getId()方法38
1.11　停止线程38
1.11.1　停止不了的线程39
1.11.2　判断线程是否为停止状态41
1.11.3　能停止的线程—异常法43
1.11.4　在sleep状态下停止线程47
1.11.5　用stop()方法暴力停止线程49
1.11.6　stop()方法与java.lang.ThreadDeath异常51
1.11.7　使用stop()释放锁给数据造成不一致的结果52
1.11.8　使用“return;”语句停止线程的缺点与解决方案54
1.12　暂停线程57
1.12.1　suspend()方法与resume()方法的使用57
1.12.2　suspend()方法与resume()方法的缺点—独占58
1.12.3　suspend()方法与resume()方法的缺点—数据不完整62
1.13　yield()方法63
1.14　线程的优先级64
1.14.1　线程优先级的继承特性65
1.14.2　优先级的规律性66
1.14.3　优先级的随机性68
1.14.4　优先级对线程运行速度的影响70
1.15　守护线程71
1.16　本章小结73
第2章　对象及变量的并发访问74
2.1　synchronized同步方法74
2.1.1　方法内的变量为线程安全74
2.1.2　实例变量非线程安全问题与解决方案77
2.1.3　同步synchronized在字节码指令中的原理80
2.1.4　多个对象多个锁81
2.1.5　将synchronized方法与对象作为锁84
2.1.6　脏读89
2.1.7　synchronized锁重入91
2.1.8　锁重入支持继承的环境93
2.1.9　出现异常，锁自动释放94
2.1.10　重写方法不使用synchronized96
2.1.11　public static boolean holdsLock(Object obj)方法的使用99
2.2　synchronized同步语句块99
2.2.1　synchronized方法的弊端99
2.2.2　synchronized同步代码块的使用102
2.2.3　用同步代码块解决同步方法的弊端104
2.2.4　一半异步，一半同步105
2.2.5　synchronized代码块间的同步性108
2.2.6　println()方法也是同步的110
2.2.7　验证同步synchronized(this)代码块是锁定当前对象的110
2.2.8　将任意对象作为锁113
2.2.9　多个锁就是异步执行116
2.2.10　验证方法被调用是随机的118
2.2.11　不同步导致的逻辑错误及其解决方法121
2.2.12　细化验证3个结论124
2.2.13　类Class的单例性129
2.2.14　静态同步synchronized方法与synchronized(class)代码块130
2.2.15　同步syn static方法可以对类的所有对象实例起作用135
2.2.16　同步syn(class)代码块可以对类的所有对象实例起作用137
2.2.17　String常量池特性与同步相关的问题与解决方案138
2.2.18　同步synchronized方法无限等待问题与解决方案141
2.2.19　多线程的死锁143
2.2.20　内置类与静态内置类146
2.2.21　内置类与同步：实验1149
2.2.22　内置类与同步：实验2151
2.2.23　锁对象改变导致异步执行153
2.2.24　锁对象不改变依然同步执行156
2.2.25　同步写法案例比较158
2.3　volatile关键字159
2.3.1　可见性的测试159
2.3.2　原子性的测试168
2.3.3　禁止代码重排序的测试176
2.4　本章小结187
第3章　线程间通信188
3.1　wait/notify机制188
3.1.1　不使用wait/notify机制实现线程间通信188
3.1.2　wait/notify机制191
3.1.3　wait/notify机制的原理192
3.1.4　wait()方法的基本使用192
3.1.5　完整实现wait/notify机制194
3.1.6　使用wait/notify机制实现list.size()等于5时的线程销毁195
3.1.7　对业务代码进行封装198
3.1.8　线程状态的切换201
3.1.9　wait()方法：立即释放锁202
3.1.10　sleep()方法：不释放锁203
3.1.11　notify()方法：不立即释放锁204
3.1.12　interrupt()方法遇到wait()方法206
3.1.13　notify()方法：只通知一个线程208
3.1.14　notifyAll()方法：通知所有线程211
3.1.15　wait(long)方法的基本使用212
3.1.16　wait(long)方法自动向下运行需要重新持有锁214
3.1.17　通知过早问题与解决方法217
3.1.18　wait条件发生变化与使用while的必要性220
3.1.19　生产者/消费者模式的实现224
3.1.20　通过管道进行线程间通信—字节流250
3.1.21　通过管道进行线程间通信—字符流253
3.1.22　实现wait/notify的交叉备份256
3.2　join()方法的使用259
3.2.1　学习join()方法前的铺垫259
3.2.2　join()方法和interrupt()方法出现异常261
3.2.3　join(long)方法的使用263
3.2.4　join(long)方法与sleep(long)方法的区别264
3.2.5　join()方法后面的代码提前运行—出现意外 268
3.2.6　join()方法后面的代码提前运行—解释意外270
3.2.7　join(long millis, int nanos)方法的使用273
3.3　类ThreadLocal的使用273
3.3.1　get()方法与null274
3.3.2　类ThreadLocal存取数据流程分析275
3.3.3　验证线程变量的隔离性277
3.3.4　解决get()方法返回null的问题282
3.3.5　验证重写initialValue()方法的隔离性283
3.4　类InheritableThreadLocal的使用284
3.4.1　类ThreadLocal不能实现值继承285
3.4.2　使用InheritableThreadLocal体现值继承特性286
3.4.3　值继承特性在源代码中的执行流程288
3.4.4　父线程有最新的值，子线程仍是旧值291
3.4.5　子线程有最新的值，父线程仍是旧值293
3.4.6　子线程可以感应对象属性值的变化294
3.4.7　重写childValue()方法实现对继承的值进行加工297
3.5　本章小结298
第4章　Lock对象的使用299
4.1　使用ReentrantLock类299
4.1.1　使用ReentrantLock实现同步299
4.1.2　验证多代码块间的同步性301
4.1.3　await()方法的错误用法与更正304
4.1.4　使用await()和signal()实现wait/notify机制307
4.1.5　await()方法暂停线程运行的原理309
4.1.6　通知部分线程—错误用法312
4.1.7　通知部分线程—正确用法314
4.1.8　实现生产者/消费者模式一对一交替输出317
4.1.9　实现生产者/消费者模式多对多交替输出319
4.1.10　公平锁与非公平锁321
4.1.11　public int getHoldCount()方法的使用324
4.1.12　public final int getQueue Length()方法的使用325
4.1.13　public int getWaitQueue-Length (Condition condition)方法的使用327
4.1.14　public final boolean has-QueuedThread (Thread thread)方法的使用328
4.1.15　public final boolean has-QueuedThreads()方法的使用329
4.1.16　public boolean hasWaiters (Con-dition condition)方法的使用331
4.1.17　public final boolean isFair()方法的使用332
4.1.18　public boolean isHeldBy-CurrentThread()方法的使用333
4.1.19　public boolean isLocked()方法的使用334
4.1.20　public void lockInterruptibly()方法的使用335
4.1.21　public boolean tryLock()方法的使用336
4.1.22　public boolean tryLock (long timeout, TimeUnit unit)方法的使用338
4.1.23　public boolean await (long time, TimeUnit unit)方法的使用339
4.1.24　public long awaitNanos(long nanosTimeout)方法的使用341
4.1.25　public boolean awaitUntil(Date deadline)方法的使用342
4.1.26　public void awaitUninterru-ptibly()方法的使用344
4.1.27　实现线程按顺序执行业务346
4.2　使用ReentrantReadWriteLock类349
4.2.1　ReentrantLock类的缺点349
4.2.2　ReentrantReadWriteLock类的使用—读读共享351
4.2.3　ReentrantReadWriteLock类的使用—写写互斥352
4.2.4　ReentrantReadWriteLock类的使用—读写互斥352
4.2.5　ReentrantReadWriteLock类的使用—写读互斥354
4.3　本章小结355
第5章　定时器Timer356
5.1　定时器Timer的使用356
5.1.1　schedule(TimerTask task, Datetime)方法的测试356
5.1.2　schedule(TimerTask task, Date firstTime, long period)方法的测试366
5.1.3　schedule(TimerTask task, long delay)方法的测试374
5.1.4　schedule(TimerTask task, long delay, long period)方法的测试374
5.1.5　scheduleAtFixedRate (TimerTask task, Date firstTime, long period)方法的测试375
5.2　本章小结384
第6章　单例模式与多线程385
6.1　立即加载/饿汉模式385
6.2　延迟加载/懒汉模式387
6.2.1　延迟加载/懒汉模式解析387
6.2.2　延迟加载/懒汉模式的缺点388
6.2.3　延迟加载/懒汉模式的解决方案390
6.3　使用静态内置类实现单例模式399
6.4　序列化与反序列化的单例模式实现400
6.5　使用static代码块实现单例模式402
6.6　使用enum枚举数据类型实现单例模式404
6.7　完善使用enum枚举数据类型实现单例模式405
6.8　本章小结407
第7章　拾遗增补408
7.1　线程的状态408
7.1.1　验证NEW、RUNNABLE和TERMINATED410
7.1.2　验证TIMED_WAITING411
7.1.3　验证BLOCKED412
7.1.4　验证WAITING414
7.2　线程组415
7.2.1　线程对象关联线程组：一级关联416
7.2.2　线程对象关联线程组：多级关联417
7.2.3　线程组自动归属特性418
7.2.4　获取根线程组419
7.2.5　线程组中加线程组420
7.2.6　组内的线程批量停止421
7.2.7　递归取得与非递归取得组内对象422
7.3　Thread.activeCount()方法的使用423
7.4　Thread.enumerate(Thread tarray[])方法的使用423
7.5　再次实现线程执行有序性424
7.6　SimpleDateFormat非线程安全426
7.6.1　出现异常426
7.6.2　解决异常的方法1428
7.6.3　解决异常的方法2430
7.7　线程中出现异常的处理431
7.7.1　线程出现异常的默认行为431
7.7.2　使用setUncaughtException-Handler()方法进行异常处理432
7.7.3　使用setDefaultUncaughtExce-ptionHandler()方法进行异常处理433
7.8　线程组内处理异常434
7.9　线程异常处理的优先性437
7.10　本章小结442
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程核心技术（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#多线程编程实战(原书第2版)
译者序
前言
本书内容
准备事项
读者对象
下载示例代码
第1章 线程基础
1.1 简介
1.2 使用C#创建线程
1.3 暂停线程
1.4 线程等待
1.5 终止线程
1.6 检测线程状态
1.7 线程优先级
1.8 前台线程和后台线程
1.9 向线程传递参数
1.10 使用C#中的lock关键字
1.11 使用Monitor类锁定资源

1.12 处理异常
第2章 线程同步
2.1 简介

2.2 执行基本的原子操作

2.3 使用Mutex类

2.4 使用SemaphoreSlim类

2.5 使用AutoResetEvent类

2.6 使用ManualResetEventSlim类

2.7 使用CountDownEvent类

2.8 使用Barrier类

2.9 使用ReaderWriterLockSlim类

2.10 使用SpinWait类
第3章 使用线程池
3.1 简介
3.2 在线程池中调用委托
3.3 向线程池中放入异步操作
3.4 线程池与并行度
3.5 实现一个取消选项

3.6 在线程池中使用等待事件处理器及超时

3.7 使用计时器

3.8 使用BackgroundWorker组件
第4章 使用任务并行库
4.1 简介

4.2 创建任务

4.3 使用任务执行基本的操作

4.4 组合任务

4.5 将APM模式转换为任务

4.6 将EAP模式转换为任务

4.7 实现取消选项

4.8 处理任务中的异常

4.9 并行运行任务

4.10 使用TaskScheduler配置任务的执行
第5章 使用C#6.0
5.1 简介

5.2 使用await操作符获取异步任务结果

5.3 在lambda表达式中使用await操作符

5.4 对连续的异步任务使用await操作符

5.5 对并行执行的异步任务使用await操作符

5.6 处理异步操作中的异常

5.7 避免使用捕获的同步上下文

5.8 使用async void方法

5.9 设计一个自定义的awaitable类型

5.10 对动态类型使用await
第6章 使用并发集合
6.1 简介

6.2 使用ConcurrentDictionary

6.3 使用ConcurrentQueue实现异步处理

6.4 改变ConcurrentStack异步处理顺序

6.5 使用ConcurrentBag创建一个可扩展的爬虫

6.6 使用BlockingCollection进行异步处理
第7章 使用PLINQ
7.1 简介

7.2 使用Parallel类

7.3 并行化LINQ查询

7.4 调整PLINQ查询的参数

7.5 处理PLINQ查询中的异常

7.6 管理PLINQ查询中的数据分区

7.7 为PLINQ查询创建一个自定义的聚合器
第8章 使用Reactive Extensions
8.1 简介

8.2 将普通集合转换为异步的可观察集合

8.3 编写自定义的可观察对象

8.3.1 准备工作

8.3.2 实现方式

8.3.3 工作原理

8.4 使用Subject

8.5 创建可观察的对象

8.6 对可观察的集合使用LINQ查询

8.7 使用Rx创建异步操作
第9章 使用异步I/O
9.1 简介

9.2 异步地使用文件

9.3 编写一个异步的HTTP服务器和客户端

9.4 异步操作数据库

9.5 异步调用WCF服务
第10章 并行编程模式
10.1 简介

10.2 实现惰性求值的共享状态

10.3 使用BlockingCollection实现并行管道

10.4 使用TPL数据流实现并行管道

10.5 使用PLINQ实现Map/Reduce模式
第11章 更多信息
11.1 简介
11.2 在通用Windows平台应用中使用计时器

11.3 在通常的应用程序中使用WinRT

11.4 在通用Windows平台应用中使用BackgroundTask

11.5 在OS X上运行.NET内核应用程序

11.6 在Ubuntu Linux上运行.NET内核应用程序
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#多线程编程实战(原书第2版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程实战指南：设计模式篇（第2版）
第1章  Java多线程编程实战基础  1
1.1  无处不在的线程  1
1.2  线程的创建与运行  3
1.3  线程的状态与上下文切换  5
1.4  对线程的监视  8
1.5  原子性、内存可见性和重排序——重新认识synchronized
和volatile  11
1.6  多线程编程的优势和风险  13
1.7  多线程编程常用术语  14
第2章  设计模式简介  19
2.1  设计模式及其作用  19
2.2  多线程设计模式简介  22
2.3  设计模式的描述  23
第3章  Immutable Object（不可变对象）模式  25
3.1  Immutable Object模式简介  25
3.2  Immutable Object模式的架构  27
3.3  Immutable Object模式实战案例解析  29
3.4  Immutable Object模式的评价与实现考量  33
3.4.1  适用场景  33
3.4.2  对垃圾回收（Garbage Collection）的影响  34
3.4.3  使用等效或者近似的不可变对象  35
3.4.4  防御性复制  35
3.5  Immutable Object模式的可复用实现代码  35
3.6  Java标准库实例  35
3.7  相关模式  37
3.7.1  Thread Specific Storage模式（第10章）  37
3.7.2  Serial Thread Confinement模式（第11章）  37
3.8  参考资源  38
第4章  Guarded Suspension（保护性暂挂）模式  39
4.1  Guarded Suspension模式简介  39
4.2  Guarded Suspension模式的架构  39
4.3  Guarded Suspension模式实战案例解析  43
4.4  Guarded Suspension模式的评价与实现考量  50
4.4.1  内存可见性和锁泄漏（Lock Leak）  51
4.4.2  线程被过早地唤醒  52
4.4.3  嵌套监视器锁死  53
4.5  Guarded Suspension模式的可复用实现代码  56
4.6  Java标准库实例  56
4.7  相关模式  56
4.7.1  Promise模式（第6章）  57
4.7.2  Producer-Consumer模式（第7章）  57
4.8  参考资源  57
第5章  Two-phase Termination（两阶段终止）模式  58
5.1  Two-phase Termination模式简介  58
5.2  Two-phase Termination模式的架构  59
5.3  Two-phase Termination模式实战案例解析  61
5.4  Two-phase Termination模式的评价与实现考量  70
5.4.1  线程停止标志  71
5.4.2  生产者/消费者问题中的线程停止  71
5.4.3  隐藏而非暴露可停止线程  73
5.5  Two-phase Termination模式的可复用实现代码  73
5.6  Java标准库实例  73
5.7  相关模式  74
5.7.1  Producer-Consumer模式（第7章）  74
5.7.2  Master-Slave模式（第12章）  74
5.8  参考资源  74
第6章  Promise（承诺）模式  75
6.1  Promise模式简介  75
6.2  Promise模式的架构  75
6.3  Promise模式实战案例解析  78
6.4  Promise模式的评价与实现考量  81
6.4.1  异步方法的异常处理  82
6.4.2  轮询  82
6.4.3  异步任务的执行  83
6.5  Promise模式的可复用实现代码  84
6.6  Java标准库实例  85
6.7  相关模式  85
6.7.1  Guarded Suspension模式（第4章）  85
6.7.2  Active Object模式（第8章）  86
6.7.3  Master-Slave模式（第12章）  86
6.7.4  Factory Method（工厂方法）模式  86
6.8  参考资源  86
第7章  Producer-Consumer（生产者/消费者）模式  87
7.1  Producer-Consumer模式简介  87
7.2  Producer-Consumer模式的架构  87
7.3  Producer-Consumer模式实战案例解析  90
7.4  Producer-Consumer模式的评价与实现考量  93
7.4.1  产品的粒度  94
7.4.2  通道积压  94
7.4.3  非阻塞式反压与Reactive Streams规范  96
7.4.4  工作窃取算法  97
7.4.5  线程的停止  101
7.4.6  高性能、高可靠性的Producer-Consumer模式实现  101
7.5  Producer-Consumer模式的可复用实现代码  102
7.6  Java标准库实例  102
7.7  相关模式  102
7.7.1  Guarded Suspension模式（第4章）  102
7.7.2  Thread Pool模式（第9章）  103
7.8  参考资源  103
第8章  Active Object（主动对象）模式  104
8.1  Active Object模式简介  104
8.2  Active Object模式的架构  105
8.3  Active Object模式实战案例解析  108
8.4  Active Object模式的评价与实现考量  115
8.4.1  错误隔离  117
8.4.2  缓冲区监控  118
8.4.3  缓冲区饱和处理策略  118
8.4.4  Scheduler空闲工作者线程清理  119
8.5  Active Object模式的可复用实现代码  119
8.6  Java标准库实例  123
8.7  相关模式  123
8.7.1  Promise模式（第6章）  123
8.7.2  Producer-Consumer模式（第7章）  123
8.8  参考资源  124
第9章  Thread Pool（线程池）模式  125
9.1  Thread Pool模式简介  125
9.2  Thread Pool模式的架构  126
9.3  Thread Pool模式实战案例解析  128
9.4  Thread Pool模式的评价与实现考量  130
9.4.1  工作队列的选择  131
9.4.2  线程池大小调校  132
9.4.3  线程池监控  134
9.4.4  线程泄漏  135
9.4.5  可靠性与线程池饱和处理策略  135
9.4.6  死锁  138
9.4.7  线程池空闲线程清理  139
9.5  Thread Pool模式的可复用实现代码  140
9.6  Java标准库实例  140
9.7  相关模式  140
9.7.1  Two-phase Termination模式（第5章）  140
9.7.2  Promise模式（第6章）  141
9.7.3  Producer-Consumer模式（第7章）  141
9.8  参考资源  141
第10章  Thread Specific Storage（线程特有存储）模式  142
10.1  Thread Specific Storage模式简介  142
10.2  Thread Specific Storage模式的架构  144
10.3  Thread Specific Storage模式实战案例解析  146
10.4  Thread Specific Storage模式的评价与实现考量  149
10.4.1  在线程池环境下使用Thread Specific Storage模式  153
10.4.2  内存泄漏与伪内存泄漏  153
10.5  Thread Specific Storage模式的可复用实现代码  161
10.6  Java标准库实例  161
10.7  相关模式  162
10.7.1  Immutable Object模式（第3章）  162
10.7.2  Proxy（代理）模式  162
10.7.3  Singleton（单例）模式  162
10.8  参考资源  162
第11章  Serial Thread Confinement（串行线程封闭）模式  163
11.1  Serial Thread Confinement模式简介  163
11.2  Serial Thread Confinement模式的架构  163
11.3  Serial Thread Confinement模式实战案例解析  166
11.4  Serial Thread Confinement模式的评价与实现考量  170
11.5  Serial Thread Confinement模式的可复用实现代码  171
11.6  Java标准库实例  176
11.7  相关模式  177
11.7.1  Immutable Object模式（第3章）  177
11.7.2  Promise模式（第6章）  177
11.7.3  Producer-Consumer模式（第7章）  177
11.7.4  Thread Specific Storage模式（第10章）  177
11.8  参考资源  177
第12章  Master-Slave（主仆）模式  178
12.1  Master-Slave模式简介  178
12.2  Master-Slave模式的架构  178
12.3  Master-Slave模式实战案例解析  180
12.4  Master-Slave模式的评价与实现考量  187
12.4.1  子任务处理结果的收集  188
12.4.2  Slave参与者实例的负载均衡与工作窃取  189
12.4.3  可靠性与异常处理  190
12.4.4  Slave线程的停止  190
12.5  Master-Slave模式的可复用实现代码  190
12.6  Java标准库实例  204
12.7  相关模式  204
12.7.1  Two-phase Termination模式（第5章）  204
12.7.2  Promise模式（第6章）  204
12.7.3  Strategy（策略）模式  204
12.7.4  Template（模板）模式  205
12.7.5  Factory Method（工厂方法）模式  205
12.8  参考资源  205
第13章  Pipeline（流水线）模式  206
13.1  Pipeline模式简介  206
13.2  Pipeline模式的架构  207
13.3  Pipeline模式实战案例解析  212
13.4  Pipeline模式的评价与实现考量  219
13.4.1  Pipeline的深度  220
13.4.2  基于线程池的Pipe  220
13.4.3  错误处理  223
13.4.4  可配置的Pipeline  224
13.5  Pipeline模式的可复用实现代码  224
13.6  Java标准库实例  236
13.7  相关模式  236
13.7.1  Serial Thread Confinement模式（第11章）  236
13.7.2  Master-Slave模式（第12章）  237
13.7.3  Composite模式  237
13.8  参考资源  237
第14章  Half-sync/Half-async（半同步/半异步）模式  238
14.1  Half-sync/Half-async模式简介  238
14.2  Half-sync/Half-async模式的架构  238
14.3  Half-sync/Half-async模式实战案例解析  240
14.4  Half-sync/Half-async模式的评价与实现考量  249
14.4.1  队列积压  250
14.4.2  避免同步任务层处理过慢  251
14.5  Half-sync/Half-async模式的可复用实现代码  251
14.6  Java标准库实例  256
14.7  相关模式  256
14.7.1  Two-phase Termination模式（第5章）  256
14.7.2  Producer-Consumer模式（第7章）  256
14.7.3  Active Object模式（第8章）  256
14.7.4  Thread Pool模式（第9章）  257
14.8  参考资源  257
第15章  模式语言  258
15.1  设计模式之间的联系  258
15.2  Immutable Object模式  260
15.3  Guarded Suspension模式  261
15.4  Two-phase Termination模式  262
15.5  Promise模式  263
15.6  Producer-Consumer模式  264
15.7  Active Object模式  265
15.8  Thread Pool模式  266
15.9  Thread Specific Storage模式  267
15.10  Serial Thread Confinement模式  268
15.11  Master-Slave模式  269
15.12  Pipeline模式  270
15.13  Half-sync/Half-async模式  271
附录A  本书常用UML图指南  272
参考文献  281
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程实战指南：设计模式篇（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java高并发编程详解
推荐序一
推荐序二
推荐序三
推荐序四
前言
第一部分 多线程基础
第1章 快速认识线程 3
1.1 线程的介绍 3
1.2 快速创建并启动一个线程 3
1.2.1 尝试并行运行 4
1.2.2 并发运行交替输出 5
1.2.3 使用Jconsole观察线程 6
1.3 线程的生命周期详解 7
1.3.1 线程的NEW状态 8
1.3.2 线程的RUNNABLE状态 8
1.3.3 线程的 RUNNING状态 8
1.3.4 线程的BLOCKED状态 8
1.3.5 线程的TERMINATED状态 9
1.4 线程的start方法剖析：模板设计模式在Thread中的应用 9
1.4.1 Thread start方法源码分析以及注意事项 9
1.4.2 模板设计模式在Thread中的应用 11
1.4.3 Thread模拟营业大厅叫号机程序 13
1.5 Runnable接口的引入以及策略模式在Thread中的使用 16
1.5.1 Runnable的职责 16
1.5.2 策略模式在Thread中的应用 16
1.5.3 模拟营业大厅叫号机程序 18
1.6 本章总结 19
第2章 深入理解Thread构造函数 20
2.1 线程的命名 20
2.1.1 线程的默认命名 21
2.1.2 命名线程 21
2.1.3 修改线程的名字 22
2.2 线程的父子关系 22
2.3 Thread与ThreadGroup 23
2.4 Thread与Runnable 24
2.5 Thread与JVM虚拟机栈 25
2.5.1 Thread与Stacksize 25
2.5.2 JVM内存结构 27
2.5.3 Thread与虚拟机栈 30
2.6 守护线程 33
2.6.1 什么是守护线程 33
2.6.2 守护线程的作用 34
2.7 本章总结 34
第3章 Thread API的详细介绍 35
3.1 线程sleep 35
3.1.1 sleep方法介绍 35
3.1.2 使用TimeUnit替代Thread.sleep 36
3.2 线程yield 37
3.2.1 yield方法介绍 37
3.2.2 yield和sleep 37
3.3 设置线程的优先级 38
3.3.1 线程优先级介绍 38
3.3.2 线程优先级源码分析 39
3.3.3 关于优先级的一些总结 40
3.4 获取线程ID 40
3.5 获取当前线程 41
3.6 设置线程上下文类加载器 41
3.7 线程interrupt 42
3.7.1 interrupt 42
3.7.2 isInterrupted 43
3.7.3 interrupted 45
3.7.4 interrupt注意事项 46
3.8 线程join 47
3.8.1 线程join方法详解 48
3.8.2 join方法结合实战 50
3.9 如何关闭一个线程 53
3.9.1 正常关闭 54
3.9.2 异常退出 56
3.9.3 进程假死 56
3.10 本章总结 58
第4章 线程安全与数据同步 59
4.1 数据同步 59
4.1.1 数据不一致问题的引入 59
4.1.2 数据不一致问题原因分析 61
4.2 初识 synchronized关键字 62
4.2.1 什么是synchronized 63
4.2.2 synchronized关键字的用法 63
4.3 深入synchronized关键字 65
4.3.1 线程堆栈分析 65
4.3.2 JVM指令分析 67
4.3.3 使用synchronized需要注意的问题 70
4.4 This Monitor和Class Monitor的详细介绍 72
4.4.1 this monitor 72
4.4.2 class monitor 74
4.5 程序死锁的原因以及如何诊断 77
4.5.1 程序死锁 77
4.5.2 程序死锁举例 77
4.5.3 死锁诊断 80
4.6 本章总结 81
第5章 线程间通信 82
5.1 同步阻塞与异步非阻塞 82
5.1.1 同步阻塞消息处理 82
5.1.2 异步非阻塞消息处理 83
5.2 单线程间通信 84
5.2.1 初识wait和notify 84
5.2.2 wait和notify方法详解 87
5.2.3 关于wait和notify的注意事项 89
5.2.4 wait和sleep 90
5.3 多线程间通信 90
5.3.1 生产者消费者 90
5.3.2 线程休息室wait set 93
5.4 自定义显式锁BooleanLock 94
5.4.1 synchronized关键字的缺陷 94
5.4.2 显式锁BooleanLock 95
5.5 本章总结 104
第6章 ThreadGroup详细讲解 105
6.1 ThreadGroup与Thread 105
6.2 创建ThreadGroup 105
6.3 复制Thread数组和ThreadGroup数组 106
6.3.1 复制Thread数组 106
6.3.2 复制ThreadGroup数组 109
6.4 ThreadGroup操作 109
6.4.1 ThreadGroup的基本操作 110
6.4.2 ThreadGroup的interrupt 113
6.4.3 ThreadGroup的destroy 114
6.4.4 守护ThreadGroup 115
6.5 本章总结 116
第7章 Hook线程以及捕获线程执行异常 117
7.1 获取线程运行时异常 117
7.1.1 UncaughtExceptionHandler的介绍 117
7.1.2 UncaughtExceptionHandler实例 118
7.1.3 UncaughtExceptionHandler源码分析 119
7.2 注入钩子线程 121
7.2.1 Hook线程介绍 121
7.2.2 Hook线程实战 122
7.2.3 Hook线程应用场景以及注意事项 124
7.3 本章总结 124
第8章 线程池原理以及自定义线程池 125
8.1 线程池原理 125
8.2 线程池实现 126
8.2.1 线程池接口定义 127
8.2.2 线程池详细实现 131
8.3 线程池的应用 139
8.4 本章总结 142
第二部分 Java ClassLoader
第9章 类的加载过程 144
9.1 类的加载过程简介 144
9.2 类的主动使用和被动使用 145
9.3 类的加载过程详解 148
9.3.1 类的加载阶段 148
9.3.2 类的连接阶段 149
9.3.3 类的初始化阶段 154
9.4 本章总结 156
第10章 JVM类加载器 158
10.1 JVM内置三大类加载器 158
10.1.1 根类加载器介绍 159
10.1.2 扩展类加载器介绍 159
10.1.3 系统类加载器介绍 160
10.2 自定义类加载器 161
10.2.1 自定义类加载器，问候世界 161
10.2.2 双亲委托机制详细介绍 165
10.2.3 破坏双亲委托机制 167
10.2.4 类加载器命名空间、运行时包、类的卸载等 170
10.3 本章总结 175
第11章 线程上下文类加载器 177
11.1 为什么需要线程上下文类加载器 177
11.2 数据库驱动的初始化源码分析 178
11.3 本章总结 180
第三部分 深入理解volatile关键字
第12章 volatile关键字的介绍 182
12.1 初识volatile关键字 182
12.2 机器硬件CPU 184
12.2.1 CPU Cache模型 184
12.2.2 CPU缓存一致性问题 186
12.3 Java内存模型 187
12.4 本章总结 188
第13章 深入volatile关键字 189
13.1 并发编程的三个重要特性 189
13.1.1 原子性 189
13.1.2 可见性 190
13.1.3 有序性 190
13.2 JMM如何保证三大特性 191
13.2.1 JMM与原子性 192
13.2.2 JMM与可见性 193
13.2.3 JMM与有序性 194
13.3 volatile关键字深入解析 195
13.3.1 volatile关键字的语义 195
13.3.2 volatile的原理和实现机制 197
13.3.3 volatile的使用场景 198
13.3.4 volatile和synchronized 199
13.4 本章总结 200
第14章 7种单例设计模式的设计 201
14.1 饿汉式 201
14.2 懒汉式 202
14.3 懒汉式+同步方法 203
14.4 Double-Check 204
14.5 Volatile+Double-Check 206
14.6 Holder方式 206
14.7 枚举方式 207
14.8 本章总结 208
第四部分 多线程设计架构模式
第15章 监控任务的生命周期 212
15.1 场景描述 212
15.2 当观察者模式遇到Thread 212
15.2.1 接口定义 212
15.2.2 ObservableThread实现 215
15.3 本章总结 217
15.3.1 测试运行 217
15.3.2 关键点总结 219
第16章 Single Thread Execution设计模式 220
16.1 机场过安检 220
16.1.1 非线程安全 221
16.1.2 问题分析 223
16.1.3 线程安全 225
16.2 吃面问题 225
16.2.1 吃面引起的死锁 226
16.2.2 解决吃面引起的死锁问题 228
16.2.3 哲学家吃面 229
16.3 本章总结 230
第17章 读写锁分离设计模式 231
17.1 场景描述 231
17.2 读写分离程序设计 232
17.2.1 接口定义 232
17.2.2 程序实现 234
17.3 读写锁的使用 239
17.4 本章总结 242
第18章 不可变对象设计模式 244
18.1 线程安全性 244
18.2 不可变对象的设计 244
18.2.1 非线程安全的累加器 245
18.2.2 方法同步增加线程安全性 247
18.2.3 不可变的累加器对象设计 248
18.3 本章总结 249
第19章 Future设计模式 251
19.1 先给你一张凭据 251
19.2 Future设计模式实现 251
19.2.1 接口定义 252
19.2.2 程序实现 253
19.3 Future的使用以及技巧总结 256
19.4 增强FutureService使其支持回调 257
19.5 本章总结 258
第20章 Guarded Suspension设计模式 259
20.1 什么是Guarded Suspension设计模式 259
20.2 Guarded Suspension的示例 259
20.3 本章总结 261
第21章 线程上下文设计模式 262
21.1 什么是上下文 262
21.2 线程上下文设计 263
21.3 ThreadLocal详解 264
21.3.1 ThreadLocal的使用场景及注意事项 265
21.3.2 ThreadLocal的方法详解及源码分析 265
21.3.3 ThreadLocal的内存泄漏问题分析 270
21.4 使用ThreadLocal设计线程上下文 274
21.5 本章总结 276
第22章 Balking设计模式 277
22.1 什么是Balking设计 277
22.2 Balking模式之文档编辑 278
22.2.1 Document 278
22.2.2 AutoSaveThread 280
22.2.3 DocumentEditThread 281
22.3 本章总结 283
第23章 Latch设计模式 284
23.1 什么是Latch 284
23.2 CountDownLatch程序实现 285
23.2.1 无限等待的Latch 285
23.2.2 有超时设置的Latch 289
23.3 本章总结 291
第24章 Thread-Per-Message设计模式 293
24.1 什么是Thread-Per-Message模式 293
24.2 每个任务一个线程 293
24.3 多用户的网络聊天 296
24.3.1 服务端程序 296
24.3.2 响应客户端连接的Handler 297
24.3.3 聊天程序测试 299
24.4 本章总结 300
第25章 Two Phase Termination设计模式 301
25.1 什么是Two Phase Termination模式 301
25.2 Two Phase Termination的示例 302
25.2.1 线程停止的Two Phase Termination 302
25.2.2 进程关闭的Two Phase Termination 303
25.3 知识扩展 304
25.3.1 Strong Reference及LRUCache 304
25.3.2 Soft Reference及SoftLRUCache 308
25.3.3 Weak Reference 311
25.3.4 Phantom Reference 312
25.4 本章总结 314
第26章 Worker-Thread设计模式 315
26.1 什么是Worker-Thread模式 315
26.2 Worker-Thread模式实现 315
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java高并发编程详解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Windows环境下的多线程编程原理与应用
第一章 概述
1 进程与线程概念
……
第二章 面向对象技术与C++语言概述
1 面向对象技术概述
……
第三章 Windows环境中的多线程实现
1 Win32 API中的基本线程函数
……
第四章 线程间通信概述
1 线程之间通信的方法
……
第五章 互斥及其应用
1 互斥的实现算法
……
第六章 临界段及其应用
1 临界段的概念
……
第七章 事件及其应用
1 事件的基本概念
……
第八章 信号量及其应用
第九章 附加论题
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Windows环境下的多线程编程原理与应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual C++6.0高级编程技术-MFC与多线程篇
第1章 按扭控件
1.1 CButton类和CBitmapButton类
  1.1.1 CButton类与CBitmapButton类的类声明
  1.1.2 CButton类与CBitmapButton类的类方法
  1.1.3 CButton类与CBitmapButton类的按钮样式
  1.1.4 CButton类与CBitmapButton类的创建与使用
1.2 设计特殊效果按钮
  1.2.1设计一个圆形按钮
  1.2.2设计一个三角形按钮
  1.2.3设计一个包含图形和文本的按钮
1.3 程序实例
1.4小结
第2章 下拉列表框控件
2.1设计一个CComboBox颜色拾取器
2.2扩展CComboColorPicker
2.3程序实例
2.4小结

第３章 编辑控件
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual C++6.0高级编程技术-MFC与多线程篇
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java并发编程实战
对本书的赞誉
译者序
前　言
第1章　简介1
1.1　并发简史1
1.2　线程的优势2
1.2.1　发挥多处理器的强大能力2
1.2.2　建模的简单性3
1.2.3　异步事件的简化处理3
1.2.4　响应更灵敏的用户界面4
1.3　线程带来的风险4
1.3.1　安全性问题5
1.3.2　活跃性问题7
1.3.3　性能问题7
1.4　线程无处不在7
第一部分　基础知识
第2章　线程安全性11
2.1　什么是线程安全性13
2.2　原子性14
2.2.1　竞态条件15
2.2.2　示例：延迟初始化中的竞态条件16
2.2.3　复合操作17
2.3　加锁机制18
2.3.1　内置锁20
2.3.2　重入21
2.4　用锁来保护状态22
2.5　活跃性与性能23
第3章　对象的共享27
3.1　可见性27
3.1.1　失效数据28
3.1.2　非原子的64位操作29
3.1.3　加锁与可见性30
3.1.4　Volatile变量 30
3.2　发布与逸出32
3.3　线程封闭35
3.3.1　Ad-hoc线程封闭35
3.3.2　栈封闭36
3.3.3　ThreadLocal类37
3.4　不变性38
3.4.1　Final域39
3.4.2　示例：使用Volatile类型来发布不可变对象40
3.5　安全发布41
3.5.1　不正确的发布：正确的对象被破坏42
3.5.2 　不可变对象与初始化安全性42
3.5.3　安全发布的常用模式43
3.5.4　事实不可变对象44
3.5.5　可变对象44
3.5.6　安全地共享对象44
第4章　对象的组合46
4.1　设计线程安全的类46
4.1.1　收集同步需求47
4.1.2　依赖状态的操作48
4.1.3　状态的所有权48
4.2　实例封闭49
4.2.1　Java监视器模式51
4.2.2　示例：车辆追踪51
4.3　线程安全性的委托53
4.3.1　示例：基于委托的车辆追踪器54
4.3.2　独立的状态变量55
4.3.3　当委托失效时56
4.3.4　发布底层的状态变量57
4.3.5　示例：发布状态的车辆追踪器58
4.4　在现有的线程安全类中添加功能59
4.4.1　客户端加锁机制60
4.4.2　组合62
4.5　将同步策略文档化62
第5章　基础构建模块66
5.1　同步容器类66
5.1.1　同步容器类的问题66
5.1.2　迭代器与Concurrent-ModificationException68
5.1.3　隐藏迭代器69
5.2　并发容器70
5.2.1　ConcurrentHashMap71
5.2.2　额外的原子Map操作72
5.2.3　CopyOnWriteArrayList72
5.3　阻塞队列和生产者-消费者模式73
5.3.1　示例：桌面搜索75
5.3.2　串行线程封闭76
5.3.3　双端队列与工作密取77
5.4　阻塞方法与中断方法77
5.5　同步工具类78
5.5.1　闭锁79
5.5.2　FutureTask80
5.5.3　信号量82
5.5.4　栅栏83
5.6　构建高效且可伸缩的结果缓存85
第二部分　结构化并发应用程序
第6章　任务执行93
6.1　在线程中执行任务93
6.1.1　串行地执行任务94
6.1.2　显式地为任务创建线程94
6.1.3　无限制创建线程的不足95
6.2　Executor框架96
6.2.1　示例：基于Executor的Web服务器97
6.2.2　执行策略98
6.2.3　线程池98
6.2.4　Executor的生命周期99
6.2.5　延迟任务与周期任务101
6.3　找出可利用的并行性102
6.3.1　示例：串行的页面渲染器102
6.3.2　携带结果的任务Callable与Future103
6.3.3　示例：使用Future实现页面渲染器104
6.3.4　在异构任务并行化中存在的局限106
6.3.5　CompletionService:Executor与BlockingQueue106
6.3.6　示例：使用CompletionService实现页面渲染器107
6.3.7　为任务设置时限108
6.3.8　示例：旅行预定门户网站109
第7章　取消与关闭111
7.1　任务取消111
7.1.1　中断113
7.1.2　中断策略116
7.1.3　响应中断117
7.1.4　示例：计时运行118
7.1.5　通过Future来实现取消120
7.1.6　处理不可中断的阻塞121
7.1.7　采用newTaskFor来封装非标准的取消122
7.2　停止基于线程的服务124
7.2.1　示例：日志服务124
7.2.2　关闭ExecutorService127
7.2.3　“毒丸”对象128
7.2.4　示例：只执行一次的服务129
7.2.5　shutdownNow的局限性130
7.3　处理非正常的线程终止132
7.4　JVM关闭135
7.4.1　关闭钩子135
7.4.2　守护线程136
7.4.3　终结器136
第8章　线程池的使用138
8.1　在任务与执行策略之间的隐性耦合138
8.1.1　线程饥饿死锁139
8.1.2　运行时间较长的任务140
8.2　设置线程池的大小140
8.3　配置ThreadPoolExecutor141
8.3.1　线程的创建与销毁142
8.3.2　管理队列任务142
8.3.3　饱和策略144
8.3.4　线程工厂146
8.3.5　在调用构造函数后再定制ThreadPoolExecutor147
8.4　扩展 ThreadPoolExecutor148
8.5　递归算法的并行化149
第9章　图形用户界面应用程序156
9.1　为什么GUI是单线程的156
9.1.1　串行事件处理157
9.1.2　Swing中的线程封闭机制158
9.2　短时间的GUI任务160
9.3　长时间的GUI任务161
9.3.1　取消162
9.3.2　进度标识和完成标识163
9.3.3　SwingWorker165
9.4　共享数据模型165
9.4.1　线程安全的数据模型166
9.4.2　分解数据模型166
9.5　其他形式的单线程子系统167
第三部分　活跃性、性能与测试
第10章　避免活跃性危险169
10.1　死锁169
10.1.1　锁顺序死锁170
10.1.2　动态的锁顺序死锁171
10.1.3　在协作对象之间发生的死锁174
10.1.4　开放调用175
10.1.5　资源死锁177
10.2　死锁的避免与诊断178
10.2.1　支持定时的锁178
10.2.2　通过线程转储信息来分析死锁178
10.3　其他活跃性危险180
10.3.1　饥饿180
10.3.2　糟糕的响应性181
10.3.3　活锁181
第11章　性能与可伸缩性183
11.1　对性能的思考183
11.1.1　性能与可伸缩性184
11.1.2　评估各种性能权衡因素185
11.2　Amdahl定律186
11.2.1　示例：在各种框架中隐藏的串行部分188
11.2.2　Amdahl定律的应用189
11.3　线程引入的开销189
11.3.1　上下文切换190
11.3.2　内存同步190
11.3.3　阻塞192
11.4　减少锁的竞争192
11.4.1　缩小锁的范围（“快进快出”）193
11.4.2　减小锁的粒度195
11.4.3　锁分段196
11.4.4　避免热点域197
11.4.5　一些替代独占锁的方法198
11.4.6　监测CPU的利用率199
11.4.7　向对象池说“不”200
11.5　示例：比较Map的性能200
11.6　减少上下文切换的开销201
第12章　并发程序的测试204
12.1　正确性测试205
12.1.1　基本的单元测试206
12.1.2　对阻塞操作的测试207
12.1.3　安全性测试208
12.1.4　资源管理的测试212
12.1.5　使用回调213
12.1.6　产生更多的交替操作214
12.2　性能测试215
12.2.1　在PutTakeTest中增加计时功能215
12.2.2　多种算法的比较217
12.2.3　响应性衡量218
12.3　避免性能测试的陷阱220
12.3.1　垃圾回收220
12.3.2　动态编译220
12.3.3　对代码路径的不真实采样222
12.3.4　不真实的竞争程度222
12.3.5　无用代码的消除223
12.4　其他的测试方法224
12.4.1　代码审查224
12.4.2　静态分析工具224
12.4.3　面向方面的测试技术226
12.4.4　分析与监测工具226
第四部分　高级主题
第13章　显式锁227
13.1　Lock与 ReentrantLock227
13.1.1　轮询锁与定时锁228
13.1.2　可中断的锁获取操作230
13.1.3　非块结构的加锁231
13.2　性能考虑因素231
13.3　公平性232
13.4　在synchronized和ReentrantLock之间进行选择234
13.5　读-写锁235
第14章　构建自定义的同步工具238
14.1　状态依赖性的管理238
14.1.1　示例：将前提条件的失败传递给调用者240
14.1.2　示例：通过轮询与休眠来实现简单的阻塞241
14.1.3　条件队列243
14.2　使用条件队列244
14.2.1　条件谓词244
14.2.2　过早唤醒245
14.2.3　丢失的信号246
14.2.4　通知247
14.2.5　示例：阀门类248
14.2.6　子类的安全问题249
14.2.7　封装条件队列250
14.2.8　入口协议与出口协议250
14.3　显式的Condition对象251
14.4　Synchronizer剖析253
14.5　AbstractQueuedSynchronizer254
14.6　java.util.concurrent同步器类中的 AQS257
14.6.1　ReentrantLock257
14.6.2　Semaphore与CountDownLatch258
14.6.3　FutureTask259
14.6.4　ReentrantReadWriteLock259
第15章　原子变量与非阻塞同步机制261
15.1　锁的劣势261
15.2　硬件对并发的支持262
15.2.1　比较并交换263
15.2.2　非阻塞的计数器264
15.2.3　JVM对CAS的支持265
15.3　原子变量类265
15.3.1　原子变量是一种“更好的volatile”266
15.3.2　性能比较：锁与原子变量267
15.4　非阻塞算法270
15.4.1　非阻塞的栈270
15.4.2　非阻塞的链表272
15.4.3　原子的域更新器274
15.4.4　ABA问题275
第16章　Java内存模型277
16.1　什么是内存模型，为什么需要它277
16.1.1　平台的内存模型278
16.1.2　重排序278
16.1.3　Java内存模型简介280
16.1.4　借助同步281
16.2　发布283
16.2.1　不安全的发布283
16.2.2　安全的发布284
16.2.3　安全初始化模式284
16.2.4　双重检查加锁286
16.3　初始化过程中的安全性287
附录A　并发性标注289
参考文献291
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java并发编程实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java并发编程的艺术
前　言
第1章　并发编程的挑战 1
1.1　上下文切换 1
1.1.1　多线程一定快吗 1
1.1.2　测试上下文切换次数和时长 3
1.1.3　如何减少上下文切换 3
1.1.4　减少上下文切换实战 4
1.2　死锁 5
1.3　资源限制的挑战 6
1.4　本章小结 7
第2章　Java并发机制的底层实现原理 8
2.1　volatile的应用 8
2.2　synchronized的实现原理与应用 11
2.2.1　Java对象头 12
2.2.2　锁的升级与对比 13
2.3　原子操作的实现原理 16
2.4　本章小结 20
第3章　Java内存模型 21
3.1　Java内存模型的基础 21
3.1.1　并发编程模型的两个关键问题 21
3.1.2　Java内存模型的抽象结构 22
3.1.3　从源代码到指令序列的重排序 23
3.1.4　并发编程模型的分类 24
3.1.5　happens-before简介 26
3.2　重排序 27
3.2.1　数据依赖性 28
3.2.2　as-if-serial语义 28
3.2.3　程序顺序规则 29
3.2.4　重排序对多线程的影响 29
3.3　顺序一致性 31
3.3.1　数据竞争与顺序一致性 31
3.3.2　顺序一致性内存模型 32
3.3.3　同步程序的顺序一致性效果 34
3.3.4　未同步程序的执行特性 35
3.4　volatile的内存语义 38
3.4.1　volatile的特性 38
3.4.2　volatile写-读建立的happens-before关系 39
3.4.3　volatile写-读的内存语义 40
3.4.4　volatile内存语义的实现 42
3.4.5　JSR-133为什么要增强volatile的内存语义 46
3.5　锁的内存语义 47
3.5.1　锁的释放-获取建立的
happens-before关系 47
3.5.2　锁的释放和获取的内存语义 48
3.5.3　锁内存语义的实现 50
3.5.4　concurrent包的实现 54
3.6　final域的内存语义 55
3.6.1　final域的重排序规则 55
3.6.2　写final域的重排序规则 56
3.6.3　读final域的重排序规则 57
3.6.4　final域为引用类型 58
3.6.5　为什么final引用不能从构造函数内“溢出” 59
3.6.6　final语义在处理器中的实现 61
3.6.7　JSR-133为什么要增强f?inal的语义 62
3.7　happens-before 62
3.7.1　JMM的设计 62
3.7.2　happens-before的定义 64
3.7.3　happens-before规则 65
3.8　双重检查锁定与延迟初始化 67
3.8.1　双重检查锁定的由来 67
3.8.2　问题的根源 69
3.8.3　基于volatile的解决方案 71
3.8.4　基于类初始化的解决方案 72
3.9　Java内存模型综述 78
3.9.1　处理器的内存模型 78
3.9.2　各种内存模型之间的关系 80
3.9.3　JMM的内存可见性保证 80
3.9.4　JSR-133对旧内存模型的修补 81
3.10　本章小结 82
第4章　Java并发编程基础 83
4.1　线程简介 83
4.1.1　什么是线程 83
4.1.2　为什么要使用多线程 84
4.1.3　线程优先级 85
4.1.4　线程的状态 87
4.1.5　Daemon线程 90
4.2　启动和终止线程 91
4.2.1　构造线程 91
4.2.2　启动线程 92
4.2.3　理解中断 92
4.2.4　过期的suspend()、resume()和stop() 93
4.2.5　安全地终止线程 95
4.3　线程间通信 96
4.3.1　volatile和synchronized关键字 96
4.3.2　等待/通知机制 98
4.3.3　等待/通知的经典范式 101
4.3.4　管道输入/输出流 102
4.3.5　Thread.join()的使用 103
4.3.6　ThreadLocal的使用 105
4.4　线程应用实例 106
4.4.1　等待超时模式 106
4.4.2　一个简单的数据库连接池示例 106
4.4.3　线程池技术及其示例 110
4.4.4　一个基于线程池技术的简单Web服务器 114
4.5　本章小结 118
第5章　Java中的锁 119
5.1　Lock接口 119
5.2　队列同步器 121
5.2.1　队列同步器的接口与示例 121
5.2.2　队列同步器的实现分析 124
5.3　重入锁 136
5.4　读写锁 140
5.4.1　读写锁的接口与示例 141
5.4.2　读写锁的实现分析 142
5.5　LockSupport工具 146
5.6　Condition接口 147
5.6.1　Condition接口与示例 148
5.6.2　Condition的实现分析 150
5.7　本章小结 154
第6章　Java并发容器和框架 155
6.1　ConcurrentHashMap的实现原理与使用 155
6.1.1　为什么要使用ConcurrentHashMap 155
6.1.2　ConcurrentHashMap的结构 156
6.1.3　ConcurrentHashMap的初始化 157
6.1.4　定位Segment 159
6.1.5　ConcurrentHashMap的操作 160
6.2　ConcurrentLinkedQueue 161
6.2.1　ConcurrentLinkedQueue的结构 162
6.2.2　入队列 162
6.2.3　出队列 165
6.3　Java中的阻塞队列 167
6.3.1　什么是阻塞队列 167
6.3.2　Java里的阻塞队列 168
6.3.3　阻塞队列的实现原理 172
6.4　Fork/Join框架 175
6.4.1　什么是Fork/Join框架 175
6.4.2　工作窃取算法 176
6.4.3　Fork/Join框架的设计 177
6.4.4　使用Fork/Join框架 177
6.4.5　Fork/Join框架的异常处理 179
6.4.6　Fork/Join框架的实现原理 179
6.5　本章小结 181
第7章　Java中的13个原子操作类 182
7.1　原子更新基本类型类 182
7.2　原子更新数组 184
7.3　原子更新引用类型 185
7.4　原子更新字段类 187
7.5　本章小结 188
第8章　Java中的并发工具类 189
8.1　等待多线程完成的CountDownLatch 189
8.2　同步屏障CyclicBarrier 191
8.2.1　CyclicBarrier简介 191
8.2.2　CyclicBarrier的应用场景 193
8.2.3　CyclicBarrier和CountDownLatch的区别 195
8.3　控制并发线程数的Semaphore 196
8.4　线程间交换数据的Exchanger 198
8.5　本章小结 199
第9章　Java中的线程池 200
9.1　线程池的实现原理 200
9.2　线程池的使用 203
9.2.1　线程池的创建 203
9.2.2　向线程池提交任务 205
9.2.3　关闭线程池 205
9.2.4　合理地配置线程池 206
9.2.5　线程池的监控 206
9.3　本章小结 207
第10章　Executor框架 208
10.1　Executor框架简介 208
10.1.1　Executor框架的两级调度模型 208
10.1.2　Executor框架的结构与成员 208
10.2　ThreadPoolExecutor详解 213
10.2.1　FixedThreadPool详解 213
10.2.2　SingleThreadExecutor详解 214
10.2.3　CachedThreadPool详解 215
10.3　ScheduledThreadPoolExecutor详解 217
10.3.1　ScheduledThreadPoolExecutor的运行机制 217
10.3.2　ScheduledThreadPoolExecutor的实现 218
10.4　FutureTask详解 221
10.4.1　FutureTask简介 222
10.4.2　FutureTask的使用 222
10.4.3　FutureTask的实现 224
10.5　本章小结 227
第11章　Java并发编程实践 228
11.1　生产者和消费者模式 228
11.1.1　生产者消费者模式实战 229
11.1.2　多生产者和多消费者场景 231
11.1.3　线程池与生产消费者模式 234
11.2　线上问题定位 234
11.3　性能测试 236
11.4　异步任务池 238
11.5　本章小结 240
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java并发编程的艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA并发编程实践
目录
代码清单
序
第1章 介绍
1.1 并发的（非常）简短历史
1.2 线程的优点
1.3 线程的风险
1.4 线程无处不在
第1部分 基础
第2章 线程安全
2.1 什么是线程安全性
2.2 原子性
2.3 锁
2.4 用锁来保护状态
2.5 活跃度与性能
第3章 共享对象
3.1 可见性
3.2 发布和逸出
3.3 线程封闭
3.4 不可变性
3.5 安全发布
第4章 组合对象
4.1 设计线程安全的类
4.2 实例限制
4.3 委托线程安全
4.4 向已有的线程安全类添加功能
4.5 同步策略的文档化
第5章 构建块
5.1 同步容器
5.2 发容器
5.3 阻塞队列和生产者一消费者模式
5.4 阻塞和可中断的方法
5.5 Synchronizer
5.6 为计算结果建立高效、可伸缩的高速缓存
第2部分 构建并发应用程序
第6章 任务执行
6.1 在线程中执行任务
6.2 Executor 框架
6.3 寻找可强化的并行性
第7章 取消和关闭
7.1 任务取消
7.2 停止基于线程的服务
7.3 处理反常的线程终止
7.4 JVM关闭
第8章 应用线程池
8.1 任务与执行策略问的隐性耦合
8.2 定制线程池的大小
8.3 配置ThreadPoolExecutor
8.4 扩展ThreadPoolExecutor
8.5 并行递归算法
第9章 GUI应用程序
9.1 为什么GUI是单线程化的
9.2 短期的GUI任务
9.3 耗时GUI任务
9.4 共享数据模型
9.5 其他形式的单线程子系统
第3部分 活跃度，性能和测试
第10章 避免活跃度危险
第11章 性能和可伸缩性
第12章 测试并发程序
第4部分 高级主题
第13章 显示锁
第14章 构建自定义的同步工具
第15章 原子变量与非阻塞同步机制
第16章 Java存储模型
附录A 同步Annotation
参考文献
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA并发编程实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++并发编程实战
目录
第1章 你好，C++并发世界 1
1.1 什么是并发 2
1.1.1 计算机系统中的并发 2
1.1.2 并发的途径 3
1.2 为什么使用并发 5
1.2.1 为了划分关注点而使用并发 5
1.2.2 为了性能而使用并发 6
1.2.3 什么时候不使用并发 7
1.3 在C++中使用并发和多线程 8
1.3.1 C++多线程历程 8
1.3.2 新标准中的并发支持 9
1.3.3 C++线程库的效率 9
1.3.4 平台相关的工具 10
1.4 开始入门 11
1.5 小结 12
第2章 管理线程 13
2.1 基本线程管理 13
2.1.1 启动线程 14
2.1.2 等待线程完成 16
2.1.3 在异常环境下的等待 17
2.1.4 在后台运行线程 19
2.2 传递参数给线程函数 20
2.3 转移线程的所有权 23
2.4 在运行时选择线程数量 26
2.5 标识线程 28
2.6 小结 29
第3章 在线程间共享数据 31
3.1 线程之间共享数据的问题 32
3.1.1 竞争条件 33
3.1.2 避免有问题的竞争条件 34
3.2 用互斥元保护共享数据 35
3.2.1 使用C++中的互斥元 35
3.2.2 为保护共享数据精心组织代码 36
3.2.3 发现接口中固有的竞争条件 38
3.2.4 死锁：问题和解决方案 44
3.2.5 避免死锁的进一步指南 46
3.2.6 用std::unique_lock灵活锁定 51
3.2.7 在作用域之间转移锁的所有权 52
3.2.8 锁定在恰当的粒度 54
3.3 用于共享数据保护的替代工具 56
3.3.1 在初始化时保护共享数据 56
3.3.2 保护很少更新的数据结构 59
3.3.3 递归锁 61
3.4 小结 62
第4章 同步并发操作 63
4.1 等待事件或其他条件 63
4.1.1 用条件变量等待条件 65
4.1.2 使用条件变量建立一个线程安全队列 67
4.2 使用future等待一次性事件 71
4.2.1 从后台任务中返回值 72
4.2.2 将任务与future相关联 74
4.2.3 生成(std::)promise 77
4.2.4 为future保存异常 79
4.2.5 等待自多个线程 80
4.3 有时间限制的等待 82
4.3.1 时钟 83
4.3.2 时间段 84
4.3.3 时间点 85
4.3.4 接受超时的函数 86
4.4 使用操作同步来简化代码 88
4.4.1 带有future的函数式编程 88
4.4.2 具有消息传递的同步操作 92
4.5 小结 96
第5章 C++内存模型和原子类型上操作 97
5.1 内存模型基础 98
5.1.1 对象和内存位置 98
5.1.2 对象、内存位置以及并发 99
5.1.3 修改顺序 100
5.2 C++中的原子操作及类型 100
5.2.1 标准原子类型 101
5.2.2 std::atomic_flag上的操作 103
5.2.3 基于std::atomicbool的操作 105
5.2.4 std::atomicT*上的操作：指针算术运算 107
5.2.5 标准原子整型的操作 108
5.2.6 std::atomic初级类模板 109
5.2.7 原子操作的自由函数 111
5.3 同步操作和强制顺序 112
5.3.1 synchronizes-with关系 114
5.3.2 happens-before关系 114
5.3.3 原子操作的内存顺序 116
5.3.4 释放序列和synchronizes-with 133
5.3.5 屏障 135
5.3.6 用原子操作排序非原子操作 137
5.4 小结 138
第6章 设计基于锁的并发数据结构 140
6.1 为并发设计的含义是什么 141
6.2 基于锁的并发数据结构 142
6.2.1 使用锁的线程安全栈 142
6.2.2 使用锁和条件变量的线程安全队列 145
6.2.3 使用细粒度锁和条件变量的线程安全队列 149
6.3 设计更复杂的基于锁的数据结构 160
6.3.1 编写一个使用锁的线程安全查找表 160
6.3.2 编写一个使用锁的线程安全链表 165
6.4 小结 169
第7章 设计无锁的并发数据结构 170
7.1 定义和结果 171
7.1.1 非阻塞数据结构的类型 171
7.1.2 无锁数据结构 172
7.1.3 无等待的数据结构 172
7.1.4 无锁数据结构的优点与缺点 172
7.2 无锁数据结构的例子 173
7.2.1 编写不用锁的线程安全栈 174
7.2.2 停止恼人的泄漏：在无锁数据结构中管理内存 178
7.2.3 用风险指针检测不能被回收的结点 182
7.2.4 使用引用计数检测结点 189
7.2.5 将内存模型应用至无锁栈 194
7.2.6 编写不用锁的线程安全队列 198
7.3 编写无锁数据结构的准则 209
7.3.1 准则：使用std::memory_order_seq_cst作为原型 210
7.3.2 准则：使用无锁内存回收模式 210
7.3.3 准则：当心ABA问题 210
7.3.4 准则：识别忙于等待的循环以及辅助其他线程 211
7.4 小结 211
第8章 设计并发代码 213
8.1 在线程间划分工作的技术 214
8.1.1 处理开始前在线程间划分数据 214
8.1.2 递归地划分数据 215
8.1.3 以任务类型划分工作 219
8.2 影响并发代码性能的因素 222
8.2.1 有多少个处理器 222
8.2.2 数据竞争和乒乓缓存 223
8.2.3 假共享 225
8.2.4 数据应该多紧密 225
8.2.5 过度订阅和过多的任务切换 226
8.3 为多线程性能设计数据结构 226
8.3.1 为复杂操作划分数组元素 227
8.3.2 其他数据结构中的数据访问方式 228
8.4 为并发设计时的额外考虑 230
8.4.1 并行算法中的异常安全 230
8.4.2 可扩展性和阿姆达尔定律 237
8.4.3 用多线程隐藏延迟 238
8.4.4 用并发提高响应性 239
8.5 在实践中设计并发代码 241
8.5.1 std::for_each的并行实现 241
8.5.2 std::find的并行实现 243
8.5.3 std::partial_sum的并行实现 248
8.6 总结 256
第9章 高级线程管理 258
9.1 线程池 259
9.1.1 最简单的线程池 259
9.1.2 等待提交给线程池的任务 261
9.1.3 等待其他任务的任务 265
9.1.4 避免工作队列上的竞争 267
9.1.5 工作窃取 269
9.2 中断线程 273
9.2.1 启动和中断另一个线程 274
9.2.2 检测一个线程是否被中断 275
9.2.3 中断等待条件变量 276
9.2.4 中断在std::condition_variable_ any上的等待 279
9.2.5 中断其他阻塞调用 281
9.2.6 处理中断 281
9.2.7 在应用退出时中断后台任务 282
9.3 总结 284
第10章 多线程应用的测试与调试 285
10.1 并发相关错误的类型 285
10.1.1 不必要的阻塞 286
10.1.2 竞争条件 286
10.2 定位并发相关的错误的技巧 288
10.2.1 审阅代码以定位潜在的错误 288
10.2.2 通过测试定位并发相关的错误 290
10.2.3 可测试性设计 291
10.2.4 多线程测试技术 292
10.2.5 构建多线程的测试代码 295
10.2.6 测试多线程代码的性能 297
10.3 总结 298
附录A 附录A C++11部分
语言特性简明
参考 299
附录B 并发类库
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++并发编程实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>并发的艺术
译者序
前言
第1章 并行让程序运行得更快
1.1 你可能会想到的一些问题
1.2 采用线程化方法的4个步骤
1.3 并行算法的背景知识
1.4 共享内存编程与分布式内存编程的比较
1.5 本书采用的并发编程方法
第2章 是否采用并发
2.1 并发算法的设计模型
2.2 哪些算法不能并行
第3章 算法正确性证明与性能衡量
3.1 并行算法的验证
3.2 示例：临界区问题
3.3 性能测试（程序的执行情况如何）
3.4 硬件并行性的发展历史
第4章 多线程程序设计中的8条简单原则
4.1 规则1：找出真正独立的运算
4.2 规则2：在尽可能高的层次上实现并发
4.3 规则3：尽早考虑通过增加处理器核的数量来获得可伸缩性
4.4 规则4：尽可能使用线程安全的库
4.5 规则5：使用正确的多线程模型
4.6 规则6：永远不要假设程序会按照某种特定的顺序执行
4.7 规则7：尽可能使用线程局部存储或者与特定数据相关的锁
4.8 规则8：要敢于对代码进行修改以获得更好的并发性
第5章 线程化库
5.1 隐式线程化
5.2 显式线程化
5.3 还剩下哪些内容没有介绍
5.4 特定领域的库
第6章 并行求和与前缀求和
6.1 并行求和
6.2 前缀求和
6.3 选择
6.4 最后的思考
第7章 映射归约
7.1 并发映射运算
7.2 并发归约运算
7.3 映射归约的应用
7.4 将映射归约作为一般性并发
第8章 排序
8.1 冒泡排序
8.2 奇偶换位排序
8.3 希尔排序
8.4 快速排序
8.5 基数排序
第9章 搜索
9.1 未排序的数据序列
9.2 二分搜索
第10章 图算法
10.1 深度优先搜索
10.2 最短路径问题
10.3 最小生成树
第11章 线程化工具
11.1 调试器
11.2 性能工具
11.3 还剩下什么内容没有介绍
11.4 再接再厉
术语表
封面说明
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>并发的艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java线程
前言
第一章 Thread导论
Java术语
关于范例
为何要用Thread？
总结
第二章 Thread的创建与管理
什么是Thread？
创建Thread
Thread的生命周期
两种停止Thfead的方式
Runnable工nterface
Thread与对象
总结
第三章 数据同步
Synchronized关键字
Volatile关键字
更多RaceCOnd“iOn的讨论
明确的 (explicit)Locking
Lock Scope
选择Locking机制
Nested Lock
死锁
Lock公平 (Fairness)
总结
第四章 Thread NOtification
等待与通知
条件变量
总结
第五章 极简同步技巧
能避免同步吗？
Atomic变量
Thread局部变量
总结
第六章 高级同步议题
同步术语
J2SE 5.0中加入的同步Class
防止死锁
死锁检测
Lock饥饿
总结
第七章 Thread与Swing
Swing Threading的限制
事件派发Thread的处理
使用invokeLater()与invokeAndWait()
长时间运行的事件回调
总结
第八章 Thread与Collection Class
Collection Class的概述
同步与Collection Class
生产者/肖费者模式
使用CollectionClass
总结
第九章 Thread调度
Thread调度的概述
以Thread优先级来调度
常见Threading的实现
总结
第十章 Thread Pool
为何要用Thread Pool？
Executor
使用Thread Pool
Queue与大小
创建Thread
Callable Task与Future结果
单一Thread化的访问
总结
第十一章 Task的调度
Task调度的概述
java.util.Timer Class
javax.Swing.Timer Class
SCheduledThreadPoolExecutor Class
总结
第十二章 Thread与I／O
传统的I／O服务器
新的I／O服务器
被中断的I／O
总结
第十三章 各种Thread议题
Thread Group
Thread与Java安全性
Daemon Thread
Thread与C1ass的力口载
Thread与异常处理
Thread、Stack、 内存的使用
总结
第十四章 Thread性能
性能的概述
同步的Collection
Atomic变量与有竞争的同步
Thread的创建与Thread Pool
总结
第十五章 多处理器计算机的并行化循环
对单一Threaded程序的并行化
多处理器扩大(scaling)
总结
附录 被撤换的Threading功能
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java线程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Windows并发编程指南
对本书的赞誉
译着序
序
前言
致谢
作者简介
第一部分 概念
第1章 概述
1.1 为什么需要并发
1.2 程序架构与并发
1.3 并行的层次
1.4 为什么不需要并发
1.5 小结
延伸阅读
第2章 同步与时间
2.1 程序状态的管理
2.1.1 共享状态与私有状态的区分
2.1.2 状态机与时间
2.1.3 独立性
2.1.4 不变性
2.2 同步：种类与实现技术
2.2.1 数据同步
2.2.2 协作与控制同步
2.3 小结
延伸阅读
第二部分 机制
第3章 线程
3.1 从高层面上来看线程
3.1.1 Windows线程是什么
3.1.2 CLR线程是什么
3.1.3 显式线程操作及其替代方法
3.2 线程的诞生与消亡
3.2.1 线程的创建
3.2.2 线程终止
3.2.3 DllMain
3.2.4 线程局部存储
3.3 小结
延伸阅读
第4章 线程的高级内容
4.1 线程的状态
4.1.1 用户态线程栈
4.1.2 内部数据结构（KTHREAD、ETHREAD和TEB）
4.1.3 上下文
4.2 线程的创建过程与终止过程
4.2.1 线程创建的具体流程
4.2.2 线程终止的具体流程
4.3 线程调度
4.3.1 线程的状态
4.3.2 优先级
4.3.3 时间片
4.3.4 优先级与时间片调整
4.3.5 睡眠与退让
4.3.6 挂起
4.3.7 关联性：优先在某个CPU上运行
4.4 小结
延伸阅读
第5章 Windows内核同步机制
5.1 基础知识：触发和等待
5.1.1 为什么要使用内核对象
5.1.2 在非托管代码中执行等待操作
5.1.3 托管代码
5.1.4 异步过程调用
5.2 内核对象的使用
5.2.1 互斥体
5.2.2 信号量
5.2.3 互斥体/信号量使用示例：阻塞/有界的队列
5.2.4 自动重置事件和手动重置事件
5.2.5 等待定时器
5.2.6 触发对象与自动等待
5.2.7 内核对象的调试
5.3 小结
延伸阅读
第6章 数据同步与控制同步
6.1 互斥
6.1.1 Win32临界区
6.1.2 CLR锁
6.2 读/写锁（RWL）
6.2.1 WindowsVista中的轻量级读/写锁
6.2.2.NEI框架中的轻量级读/写锁
6.2.3.NET框架中原来的读/写锁
6.3 条件变量
6.3.1 WindowsVista条件变量
6.3.2.NET框架的Monitor
6.3.3 被守护区域
6.4 小结
延伸阅读
第7章 线程池
7.1 线程池的基本知识
7.1.1 三种方式：WindowsVista、Windows遗留代码以及CLR
7.1.2 通用功能
7.2 Windows线程池
7.2.1 WindowsVista线程池
7.2.2 遗留的Win32线程池
7.3 CLR线程池
7.3.1 工作项
7.3.2 I/O完成端口
7.3.3 定时器
7.3.4 注册等待
7.3.5 记住（再次提醒）：你并不拥有这些线程
7.3.6 线程池的线程管理
7.3.7 调试
7.3.8 案例分析：优先级分层以及在线程池之上的隔离性
7.4 在使用线程池时的性能
7.5 小结
延伸阅读
第8章 异步编程模型
8.1 异步编程模型（APM）
8.1.1 汇集：四种方式
8.1.2 实现IAsyncResult
8.1.3 在.NET框架的哪些地方使用了APM
8.1.4 ASP.NET异步页
8.2 基于事件的异步模式
8.2.1 基础知识
8.2.2 支持取消
8.2.3 支持进度报告以及增量结果
8.2.4 在.NET框架的哪些地方将使用EAP
8.3 小结
延伸阅读
第9章 纤程
9.1 纤程简介优点与缺点
9.2 纤程的使用
9.2.1 创建新的纤程
9.2.2 将线程转换为纤程
9.2.3 判断线程是否为纤程
9.2.4 纤程间的切换
9.2.5 删除纤程
9.2.6 切换当前线程的示例
9.3 与纤程相关的其他主题
9.3.1 纤程局部存储
9.3.2 线程关联性
9.3.3 案例分析：纤程与CLR
9.4 构建用户态的调度器
9.4.1 实现
9.4.2 关于栈阻塞与无栈阻塞
9.5 小结
延伸阅读
第三部分 技术
第10章 内存模型与无锁编程
10.1 内存加载与存储等操作的重新排序
10.1.1 实际运行的顺序并非总是编写的顺序
10.1.2 将临界域作为栅栏
10.1.3 数据依赖性及其对重排的影响
10.2 硬件原子性
10.2.1 普通加载指令和存储指令的原子性
10.2.2 互锁操作
10.3 内存一致性模型
10.3.1 硬件内存模型
10.3.2 内存栅栏
10.3.3.NET内存模型
10.3.4 无锁编程
10.4 低锁代码的示例
10.4.1 延迟初始化与双重检查锁定
10.4.2 无阻塞栈和ABA问题
10.4.3 重新回顾Dekker的算法
10.5 小结
延伸阅读
第11章 并发的危害
11.1 正确性危害
11.1.1 数据竞争
11.1.2 递归与重入
11.1.3 锁与进程关闭
11.2 活跃性危害
11.2.1 死锁
11.2.2 遗失的唤醒
11.2.3 活锁
11.2.4 锁护送效应
11.2.5 “蜂拥”现象
11.2.6 两步舞
11.2.7 优先级反转与饥饿
11.3 小结
延伸阅读
第12章 并行容器
12.1 细粒度锁定
12.1.1 数组
12.1.2 FIFO队列
12.1.3 链表
12.1.4 字典（散列表）
12.2 无锁
12.2.1 无锁FIFO队列
12.2.2 工作密迁队列
12.3 协作式容器
12.3.1 生产者/消费者数据结构
12.3.2 通过栅栏来分阶段计算
12.4 小结
延伸阅读
第13章 数据并行与任务并行
13.1 数据并行
13.2 任务并行
13.2.1 分支/合并算法
13.2.2 数据流并行（Future抽象与Promise抽象）
13.2.3 递归
13.2.4 流水线
13.2.5 查找
13.3 基于消息的并行
13.4 一些共同问题
13.4.1 并发的异常
13.4.2 取消
13.5 小结
延伸阅读
第14章 性能与可伸缩性
14.1 并行硬件架构
14.1.1 SMP、CMP与HT
14.1.2 超标量执行
14.1.3 内存的层次结构
14.1.4 Visual Studio中的性能分析工具
14.2 加速比：并行代码与串行代码
14.2.1 决定“采用并行”
14.2.2 测量并行带来的性能提升
14.2.3 Amdahl定律
12.2.4 关键路径以及负载不均衡
14.2.5 垃圾收集与可伸缩性
14.3 自旋等待
14.3.1 如何在Windows上正确地自旋
14.3.2 纯自旋锁
14.3.3 Mellor-Crummey-Scott（MCS）锁
14.4 小结
延伸阅读
第四部分 系统
第15章 输入与输出
15.1 重叠I/O
15.1.1 重叠对象
15.1.2 Win32异步：I/O
15.1.3 .NET框架的异步I/O
15.2 I/O取消
15.2.1 当前线程的异步I/O取消
15.2.2 其他线程上的同步I/O取消
15.2.3 任意线程的异步I/O取消
15.3 小结
延伸阅读
第16章 图形用户界面
16.1 GUI线程模型
16.1.1 单线程套间（STA）
16.1.2 响应度：它是什么
16.2.NET异步GUI功能
16.2.1.NET的GUI框架
16.2.2 同步上下文
16.2.3 异步操作
16.2.4 一个方便的类：BackgroundWorker
16.3 小结
延伸阅读
第五部分 附录
附录A 为.NET并发程序设计可重用的库
附录B .NET的并行扩展
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Windows并发编程指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机并发编程
译者序
前言
第1章 并发的威力与风险 1
1.1 线程：程序的执行流程 1
1.2 并发的威力 1
1.3 并发的风险 4
1.4 小结 9
第一部分 并发策略
第2章 分工原则 11
2.1 从顺序到并发 11
2.2 在IO密集型应用程序中使用并发技术 13
2.3 并发方法对IO密集型应用程序的加速效果 19
2.4 在计算密集型应用程序中使用并发技术 20
2.5 并发方法对于计算密集型应用程序的加速效果 25
2.6 有效的并发策略 26
2.7 小结 27
第3章 设计方法 28
3.1 处理状态 28
3.2 探寻设计选项 29
3.3 共享可变性设计 29
3.4 隔离可变性设计 30
3.5 纯粹不可变性设计 30
3.6 持久的/不可变的数据结构 31
3.7 选择一种设计方法 34
3.8 小结 34
第二部分 现代Java/JDK并发模型
第4章 可扩展性和线程安全 37
4.1 用ExecutorService管理线程 37
4.2 使线程协作 38
4.3 数据交换 47
4.4 Java 7 Fork-Join API 49
4.5 可扩展集合类 51
4.6 Lock和Synchronized 54
4.7 小结 58
第5章 驯服共享可变性 59
5.1 共享可变性 != Public 59
5.2 定位并发问题 59
5.3 保持不变式 61
5.4 管理好资源 62
5.5 保证可见性 64
5.6 增强并发性 65
5.7 保证原子性 67
5.8 小结 70
第三部分 软件事务内存
第6章 软件事务内存导论 71
6.1 同步与并发水火不容 71
6.2 对象模型的缺陷 72
6.3 将实体与状态分离 73
6.4 软件事务内存 74
6.5 STM中的事务 77
6.6 用STM实现并发 77
6.7 用Akka/Multiverse STM实现并发 82
6.8 创建事务 84
6.9 创建嵌套事务 90
6.10 配置Akka事务 97
6.11 阻塞事务—有意识地等待 100
6.12 提交和回滚事件 103
6.13 集合与事务 106
6.14 处理写偏斜异常 110
6.15 STM的局限性 112
6.16 小结 116
第7章 在Clojure、Groovy、Java、JRuby和Scala中使用STM 117
7.1 Clojure STM 117
7.2 Groovy集成 118
7.3 Java集成 122
7.4 JRuby集成 124
7.5 Scala中的可选方案 130
7.6 小结 133
第四部分 基于角色的并发模型
第8章 讨喜的隔离可变性 135
8.1 用角色实现隔离可变性 136
8.2 角色的特性 137
8.3 创建角色 138
8.4 收发消息 144
8.5 同时使用多个角色 148
8.6 多角色协作 152
8.7 使用类型化角色 159
8.8 类型化角色和murmurs 163
8.9 混合使用角色和STM 169
8.10 使用transactor 169
8.11 调和类型化角色 176
8.12 远程角色 182
8.13 基于角色模型的局限性 184
8.14 小结 184
第9章 在Groovy、Java、JRuby和Scala中使用角色 186
9.1 在Groovy中使用GPars提供的角色实现 186
9.2 在Java中使用Akka提供的角色实现 199
9.3 在JRuby中使用Akka提供的Actor实现 199
9.4 在Scala中使用角色 202
9.5 小结 202
第五部分 后记
第10章 并发编程之禅 205
10.1 慎重选择 205
10.2 并发：程序员指南 206
10.3 并发：架构师指南 207
10.4 明智地进行选择 208
附录1 Clojure agent 210
附录2 一些网络资源 214
参考文献 216
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机并发编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>多处理器编程的艺术
出版者的话
译者序
前言
教学建议
第1章   引言	1
1.1   共享对象和同步	2
1.2   生活实例	4
1.2.1   互斥特性	6
1.2.2   道德	7
1.3   生产者-消费者问题	7
1.4   读者-写者问题	9
1.5   并行的困境	9
1.6   并行程序设计	11
1.7   本章注释	11
1.8   习题	11
第一部分   原       理
第2章   互斥	14
2.1   时间	14
2.2   临界区	14
2.3   双线程解决方案	16
2.3.1   LockOne类	16
2.3.2   LockTwo类	17
2.3.3   Peterson锁	18
2.4   过滤锁	19
2.5   公平性	21
2.6   Bakery算法	21
2.7   有界时间戳	23
2.8   存储单元数量的下界	25
2.9   本章注释	27
2.10   习题	28
第3章   并发对象	31
3.1   并发性与正确性	31
3.2   顺序对象	33
3.3   静态一致性	34
3.4   顺序一致性	35
3.5   可线性化性	38
3.5.1   可线性化点	38
3.5.2   评析	38
3.6   形式化定义	38
3.6.1   可线性化性	39
3.6.2   可线性化性的复合性	40
3.6.3   非阻塞特性	40
3.7   演进条件	41
3.8   Java存储器模型	43
3.8.1   锁和同步块	44
3.8.2   volatile域	44
3.8.3   final域	44
3.9   评析	45
3.10   本章注释	46
3.11   习题	46
第4章   共享存储器基础	50
4.1   寄存器空间	50
4.2   寄存器构造	54
4.2.1   MRSW安全寄存器	55
4.2.2   MRSW规则布尔寄存器	55
4.2.3   M-值MRSW规则寄存器	56
4.2.4   SRSW原子寄存器	57
4.2.5   MRSW原子寄存器	59
4.2.6   MRMW原子寄存器	60
4.3   原子快照	62
4.3.1   无障碍快照	63
4.3.2   无等待快照	64
4.3.3   正确性证明	66
4.4   本章注释	67
4.5   习题	67
第5章   同步原子操作的相对能力	70
5.1   一致数	70
5.2   原子寄存器	72
5.3   一致性协议	74
5.4   FIFO队列	74
5.5   多重赋值对象	77
5.6   读-改-写操作	79
5.7   Common2 RMW操作	80
5.8   compareAndSet()操作	81
5.9   本章注释	82
5.10   习题	83
第6章   一致性的通用性	87
6.1   引言	87
6.2   通用性	88
6.3   一种通用的无锁构造	88
6.4   一种通用的无等待构造	91
6.5   本章注释	95
6.6   习题	95
第二部分   实      践
第7章   自旋锁与争用	98
7.1   实际问题	98
7.2   测试-设置锁	100
7.3   再论基于TAS的自旋锁	102
7.4   指数后退	102
7.5   队列锁	104
7.5.1   基于数组的锁	104
7.5.2   CLH队列锁	106
7.5.3   MCS队列锁	107
7.6   时限队列锁	110
7.7   复合锁	112
7.8   层次锁	118
7.8.1   层次后退锁	118
7.8.2   层次CLH队列锁	119
7.9   由一个锁管理所有的锁	123
7.10   本章注释	123
7.11   习题	124
第8章   管程和阻塞同步	126
8.1   引言	126
8.2   管程锁和条件	126
8.2.1   条件	127
8.2.2   唤醒丢失问题	130
8.3   读者-写者锁	131
8.3.1   简单的读者-写者锁	131
8.3.2   公平的读者-写者锁	132
8.4   我们的可重入锁	134
8.5   信号量	135
8.6   本章注释	136
8.7   习题	136
第9章   链表：锁的作用	139
9.1   引言	139
9.2   基于链表的集合	140
9.3   并发推理	141
9.4   粗粒度同步	142
9.5   细粒度同步	143
9.6   乐观同步	146
9.7   惰性同步	149
9.8   非阻塞同步	153
9.9   讨论	157
9.10   本章注释	157
9.11   习题	158
第10章   并行队列和ABA问题	159
10.1   引言	159
10.2   队列	160
10.3   部分有界队列	160
10.4   完全无界队列	163
10.5   无锁的无界队列	164
10.6   内存回收和ABA问题	166
10.7   双重数据结构	170
10.8   本章注释	172
10.9   习题	172
第11章   并发栈和消除	174
11.1   引言	174
11.2   无锁的无界栈	174
11.3   消除	176
11.4   后退消除栈	176
11.4.1   无锁交换机	177
11.4.2   消除数组	179
11.5   本章注释	181
11.6   习题	181
第12章   计数、排序和分布式协作	184
12.1   引言	184
12.2   共享计数	184
12.3   软件组合	185
12.3.1   概述	185
12.3.2   一个扩展实例	190
12.3.3   性能和健壮性	191
12.4   静态一致池和计数器	192
12.5   计数网	192
12.5.1   可计数网	193
12.5.2   双调计数网	194
12.5.3   性能和流水线	201
12.6   衍射树	201
12.7   并行排序	204
12.8   排序网	204
12.9   样本排序	207
12.10   分布式协作	208
12.11   本章注释	208
12.12   习题	209
第13章   并发哈希和固有并行	212
13.1   引言	212
13.2   封闭地址哈希集	213
13.2.1   粗粒度哈希集	214
13.2.2   空间分带哈希集	215
13.2.3   细粒度哈希集	217
13.3   无锁哈希集	219
13.3.1   递归有序划分	219
13.3.2   BucketList类	222
13.3.3   LockFreeHashSet<T>类	223
13.4   开放地址哈希集	225
13.4.1   Cuckoo哈希	225
13.4.2   并发Cuckoo哈希	226
13.4.3   空间分带的并发Cuckoo哈希	230
13.4.4   细粒度的并发Cuckoo哈希集	231
13.5   本章注释	233
13.6   习题	234
第14章   跳表和平衡查找	235
14.1   引言	235
14.2   顺序跳表	235
14.3   基于锁的并发跳表	236
14.3.1   简介	236
14.3.2   算法	238
14.4   无锁并发跳表	243
14.4.1   简介	243
14.4.2   算法细节	245
14.5   并发跳表	251
14.6   本章注释	251
14.7   习题	251
第15章   优先级队列	253
15.1   引言	253
15.2   基于数组的有界优先级队列	253
15.3   基于树的有界优先级队列	254
15.4   基于堆的无界优先级队列	256
15.4.1   顺序堆	256
15.4.2   并发堆	258
15.5   基于跳表的无界优先级队列	262
15.6   本章注释	264
15.7   习题	265
第16章   异步执行、调度和工作分配	266
16.1   引言	266
16.2   并行分析	271
16.3   多处理器的实际调度	273
16.4   工作分配	274
16.4.1   工作窃取	275
16.4.2   屈从和多道程序设计	275
16.5   工作窃取双端队列	276
16.5.1   有界工作窃取双端队列	276
16.5.2   无界工作窃取双端队列	279
16.5.3   工作平衡	282
16.6   本章注释	283
16.7   习题	284
第17章   障碍	287
17.1   引言	287
17.2   障碍实现	288
17.3   语义换向障碍	288
17.4   组合树障碍	289
17.5   静态树障碍	291
17.6   终止检测障碍	293
17.7   本章注释	295
17.8   习题	296
第18章   事务内存	302
18.1   引言	302
18.1.1   关于锁的问题	302
18.1.2   关于compareAndSet()的问题	303
18.1.3   关于复合性的问题	304
18.1.4   我们能做什么	305
18.2   事务和原子性	305
18.3   软事务内存	306
18.3.1   事务和事务线程	309
18.3.2   僵尸事务和一致性	310
18.3.3   原子对象	311
18.3.4   如何演进	311
18.3.5   争用管理器	312
18.3.6   原子对象的实现	314
18.3.7   无干扰原子对象	315
18.3.8   基于锁的原子对象	318
18.4   硬事务内存	323
18.4.1   缓存一致性	324
18.4.2   事务缓存一致性	324
18.4.3   改进	325
18.5   本章注释	325
18.6   习题	326
第三部分   附      录
附录A   软件基础	328
附录B   硬件基础	340
参考文献	350
索引	359
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>多处理器编程的艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>多核计算与程序设计
第1部分 基础知识
第1章	多核计算概述	2
1.1	多核CPU概述	2
1.1.1	多核计算将成为发展趋势	2
1.1.2	多核CPU硬件架构介绍	4
1.1.3	多核给程序员带来的机遇和挑战	6
1.2	多核编程会遇到那些问题	9
1.2.1	并发性问题	9
1.2.2	CPU饥饿问题	9
1.2.3	任务的分解与调度问题	10
1.2.4	加速比性能问题	11
1.2.5	节能环保问题	12
1.2.6	扩展性问题	13
1.3	多核编程与单核多线程编程的区别	13
1.3.1	锁竞争导致的串行化的区别	13
1.3.2	线程分解与执行的区别	15
1.3.3	CPU核负载平衡的区别	15
1.3.4	任务调度策略的区别	15
1.3.5	CPU Cache存取的区别（伪共享问题）	16
1.3.6	任务优先级抢占的区别	18
1.3.7	串行计算与并行及分布式计算的区别	19
1.4	多核编程与多机分布式编程的区别	19
1.4.1	共享存储与分布式存储的区别	19
1.4.2	分布式计算的区别	20
1.4.3	编程环境上的区别	20
1.5	加速比系数	20
1.5.1	阿姆达尔定律	20
1.5.2	Gustafson定律	22
1.5.3	阿姆达尔定律和Gustafson定律的等价性	24
1.5.4	Karp-Flatt度量	25
1.5.5	实际情况中影响加速比系数的因素	27
1.5.6	并行计算开销情况下的加速比	27
1.6	锁竞争问题及对加速比的影响	28
1.6.1	线程粒度因子与锁粒度因子	28
1.6.2	锁竞争的性能情况	30
1.6.3	集中式锁竞争中的加速比分析	31
1.6.4	随机锁竞争中的加速比分析	33
1.6.5	分布式锁竞争的加速比分析	36
1.6.6	无锁编程的加速比分析	40
1.7	负载平衡问题对加速比的影响	43
1.7.1	影响负载平衡的主要因素	43
1.7.2	负载平衡的评价指标	43
1.7.3	负载平衡情况下的加速比	44
1.8	 参考文献	                                                     44
第2章	多线程编程基础	2
2.1	多线程编程基本概念	2
2.1.1	线程	2
2.1.2	锁	3
2.1.3	各种系统中常用的锁操作及信号量操作函数	6
2.1.4	用C++实现锁的自动释放	8
2.1.5	原子操作	10
2.1.6	锁与原子操作的区别	14
2.1.7	有锁计算、无锁计算与本地计算的概念	15
2.2	各种锁性能比较	15
2.2.1	各种锁在单线程情况下的性能	15
2.2.2	各种锁在多线程集中式锁竞争情况下的性能	17
2.2.3	各种锁在多线程分布式锁竞争情况下的性能	19
2.3	读写锁算法	21
2.3.1	读写锁概念的引出	21
2.3.2	读写锁算法的分析和实现	22
2.3.3	读写锁的编码实现	23
2.4	多线程退出算法	25
2.4.1	单个子线程退出算法	25
2.4.2	多个线程访问共享资源时的退出	27
2.4.3	有锁的多线程资源释放退出算法实现	30
2.4.4	无锁的退出算法	32
2.4.5	多线程退出算法的使用	34
2.5	参考文献	35
第3章	OpenMP程序设计	3
3.1	OpenMP基本概念	3
3.1.1	fork/join并行执行模式的概念	3
3.1.2	内存模型	5
3.1.3	性能例子	6
3.1.4	编译器对OpenMP的支持	6
3.2	OpenMP编程模型	8
3.2.1	OpenMP编译指导语句格式	8
3.2.2	OpenMP主要命令	9
3.2.3	OpenMP主要子句	10
3.2.4	OpenMP主要库函数	10
3.3	线程创建与工作分摊	11
3.3.1	parallel命令	11
3.3.2	for和parallel for命令	13
3.3.3	if子句（条件执行并行）	17
3.3.4	动态设置并行循环的线程数量	17
3.3.5	循环并行化的问题	19
3.3.6	sections和section命令	21
3.3.7	single命令	23
3.3.8	master命令	24
3.4	数据处理	25
3.4.1	private子句	25
3.4.2	firstprivate子句	26
3.4.3	lastprivate子句	26
3.4.4	threadprivate子句	27
3.4.5	shared子句	28
3.4.6	default子句	28
3.4.7	reduction子句	29
3.4.8	copyin子句	30
3.4.9	copyprivate子句	31
3.5	任务调度	32
3.5.1	Schedule子句用法	33
3.5.2	静态调度(static)	33
3.5.3	动态调度(dynamic)	35
3.5.4	guided调度（guided）	36
3.5.5	runtime调度（rumtime）	37
3.5.6	任务调度与伪共享问题	37
3.6	线程间的同步	37
3.6.1	barrier命令	37
3.6.2	critical命令	38
3.6.3	atomic命令	39
3.6.4	ordered命令和子句	40
3.6.5	nowait子句	41
3.6.6	flush命令	42
3.7	OpenMP库函数详解	43
3.7.1	执行环境函数	43
3.7.2	锁操作函数	45
3.7.3	时间操作函数	47
3.8	OpenMP环境变量	47
3.8.1	OMP_DYNAMIC	47
3.8.2	OMP_NUM_THREADS	48
3.8.3	OMP_NESTED	48
3.8.4	OMP_SCHEDULE	48
3.9	OpenMP内部控制变量及相关流程	48
3.9.1	内部控制变量	48
3.9.2	任务调度流程	49
3.9.3	线程数量决定流程	50
3.10	参考文献：	52
第二部份 基础数据结构与算法
第4章	数组	1
4.1	栈	2
4.1.1	栈的基本概念	2
4.1.2	栈的编码实现	3
4.1.3	多线程栈的实现	6
4.2	对数组进行快速排序	8
4.2.1	排序算法介绍	8
4.2.2	串行快速排序基本思想	9
4.2.3	串行快速排序的代码实现	11
4.2.4	非递归的快速排序算法	12
4.2.5	快速排序算法的复杂度分析	16
4.3	对数组进行查找	17
4.3.1	顺序查找	17
4.3.2	二分查找	17
4.4	实例：用数组管理一个HOOK功能	19
4.4.1	单个函数的HOOK实现	19
4.4.2	多个函数的HOOK实现	20
4.4.3	HOOK功能的应用简介	25
4.4.4	HOOK使用的注意事项	25
4.5	参考文献	25
第5章	链表	2
5.1	单向链表	2
5.1.1	存储表示	2
5.1.2	接口设计	3
5.1.3	添加节点到链表头部	4
5.1.4	基本功能编码实现	6
5.2	单向链表的排序	13
5.2.1	插入排序	13
5.2.2	归并插入排序	15
5.3	双向链表	19
5.3.1	双向链表的基本概念	19
5.3.2	双向链表的设计	20
5.3.3	双向链表的操作接口	21
5.3.4	双向链表的编码实现	21
5.4	链表的逐个节点遍历	33
5.4.1	逐个节点遍历基本概念	33
5.4.2	逐个节点遍历编码实现	34
5.5	多线程遍历算法	35
5.5.1	多线程链表的设计和编码实现	35
5.5.2	多线程链表的4种遍历方案	38
5.5.3	多个线程同时遍历的情况	42
5.6	实例：使用链表管理短信息系统的CACHE	42
5.6.1	短信息系统的CACHE管理基本概念	42
5.6.2	短信息系统的发送和接收分析	43
5.6.3	短信息系统CACHE管理的编码实现	44
第6章	哈希表	1
6.1	哈希表	2
6.1.1	哈希表的基本概念	2
6.1.2	哈希表的索引方法	3
6.1.3	哈希表的冲突解决方法	5
6.1.4	哈希表基本操作的源代码	6
6.2	哈希链表	12
6.2.1	哈希表和数组、链表的效率比较	12
6.2.2	时间效率和空间效率的关系	13
6.2.3	哈希链表的基本概念	14
6.2.4	哈希链表的操作	14
6.2.5	哈希链表的编码实现	16
6.3	实例：WebServer的动态CACHE文件管理	24
6.3.1	WebServer的动态CACHE文件管理基本概念	24
6.3.2	CACHE文件管理功能的设计	25
6.3.3	CACHE文件管理功能的编码实现	26
6.4	参考文献	31
第7章	普通树与二叉树	2
7.1	普通树	2
7.1.1	普通树的描述方法	2
7.1.2	树的操作接口设计	2
7.1.3	树的遍历算法	3
7.1.4	树的编码实现	5
7.1.5	使用树的遍历算法来实现Xcopy功能	10
7.2	二叉树	12
7.2.1	二叉树的基本概念	12
7.2.2	二叉树的树梢及二叉树的高度	13
7.2.3	二叉树的描述方法	14
7.3	二叉排序树	14
7.3.1	二叉排序树的基本概念	14
7.3.2	二叉排序树的查找	15
7.3.3	二叉排序树的插入	16
7.3.4	二叉排序树的删除	18
7.3.5	二叉排序树的遍历	21
7.3.6	二叉排序树的旋转操作	22
第8章	AVL搜索树	2
8.1	AVL搜索树的基本概念	2
8.2	AVL搜索树的插入	3
8.2.1	插入操作需要考虑的问题	3
8.2.2	不存在不平衡节点的情况分析	4
8.2.3	不平衡A节点的情况分析	5
8.2.4	存在不平衡节点的四种情况分析	5
8.2.5	LL型不平衡情况的调整	7
8.2.6	LR型不平衡情况的调整	7
8.2.7	插入操作的伪代码描述	8
8.3	AVL搜索树的删除	11
8.3.1	A节点的确定	11
8.3.2	几种不平衡情况的分析	13
8.3.3	L0型调整分析	15
8.3.4	L-1型调整分析	15
8.3.5	L1型调整分析	16
8.3.6	删除操作的伪代码描述	17
8.4	负载平衡的AVL树	19
8.4.1	基本概念的引出	19
8.4.2	插入操作中负载因子的调整	19
8.4.3	删除操作中负载因子的调整	21
8.4.4	L0和L-1型调整分析	24
8.4.5	L1型调整分析	24
8.5	AVL树的源代码	25
8.5.1	数据结构定义	25
8.5.2	创建、释放、查找等操作	26
8.5.3	旋转操作函数	28
8.5.4	插入操作函数	30
8.5.5	删除操作函数	36
8.6	参考文献	43
第9章 复合二叉树 ……………………………………………………………………
9.1  哈希红黑树……………………………………………………………………
9.1.1  哈希红黑树的基本概念…………………………………………………
9.1.1  哈希红黑树的查找…………………………………………………
9.1.3  哈希红黑树的插入…………………………………………………
9.1.4  哈希红黑树的删除…………………………………………………
9.1.5  哈希红黑树的释放…………………………………………………
9.1.6  哈希红黑树的遍历…………………………………………………
9.1.7  哈希红黑树的编码实现…………………………………………………
9.1.8  哈希红黑树的效率分析…………………………………………………
9.2  哈希AVL树……………………………………………………………
9.2.1  哈希AVL树的基本概念…………………………………………………
9.2.2  哈希AVL树的查找…………………………………………………
9.2.3  哈希AVL树的插入…………………………………………………
9.2.4  哈希AVL树的删除…………………………………………………
9.2.5  哈希AVL树的释放…………………………………………………
9.2.6  哈希AVL树的遍历…………………………………………………
9.2.7  哈希AVL树的编码实现…………………………………………………
9.3  复合数据结构的分类……………………………………………………………
9.4  抗DoS/DdoS攻击的实例…………………………………………………
9.4.1  DoS/DdoS攻击的概念…………………………………………………
9.4.2  常见DoS/DdoS攻击手段及防范策略……………………………………
9.4.3  抗DoS/DdoS攻击的实现…………………………………………………
9.4.4  抗DoS/DdoS攻击的编码实现…………………………………………………
9.5  参考文献………………………………………………………………………
第3部分 并行计算
第10章	并行程序设计模式	1
10.1	基本概念	1
10.1.1	强并行计算与弱并行计算	1
10.1.2	并行程序设计模式的基本思路	2
10.2	模式数据分解模式	2
10.3	分治模式	3
10.3.1	子问题求解时的负载平衡问题	3
10.3.2	子问题的解的合并可能引起的串行化问题	4
10.4	流水线模式	4
10.5	任务并行模式	5
10.6	任务调度模式	6
10.6.1	任务图调度模式	6
10.6.2	动态任务调度模式	7
第11章	并行搜索	1
11.1	并行顺序搜索	1
11.1.1	并行搜索指定数据	2
11.1.2	并行搜索最大数	2
11.1.3	终止检测算法	4
11.2	串行Dijkstra最短路径搜索	9
11.2.1	Dijkstra最短路径算法的描述	9
11.2.2	Dijkstra最短路径算法的过程图解	9
11.2.3	伪代码描述	11
11.2.4	算法流程图	12
11.2.5	C/C++代码实现	14
11.3	并行最短路径算法	17
11.3.1	Dijkstra算法的并行化	17
11.3.2	并行Dijkstra算法的代码实现	18
11.3.3	其他并行最短路径算法的介绍和分析	22
11.4	参考文献	23
第12章	并行排序	2
12.1	并行排序概述	2
12.2	冒泡排序	2
12.2.1	串行冒泡排序	2
12.2.2	奇偶排序	4
12.3	快速排序	6
12.3.1	串行快速排序基本思想	6
12.3.2	串行快速排序的代码实现	9
12.3.3	快速排序并行化方法	10
12.3.4	开源项目mcstl中的并行快速排序	11
12.3.5	基于任务窃取的快速排序	11
12.4	并行归并排序	11
12.4.1	串行归并算法	11
12.4.2	Cole并行归并算法	12
12.4.3	并行快速归并排序	13
12.5	基数排序	13
12.5.1	串行链式基数排序	13
12.5.2	串行数组基数排序	15
12.5.3	一步到位的分层排序	18
12.5.4	负载平衡的并行基数排序	18
12.5.5	分区的并行基数排序	22
第13章	并行数值计算	1
13.1	多核并行数值计算面临的问题	1
13.1.1	Cache的命中率问题	1
13.1.2	伪共享问题	2
13.2	求和及前缀求和	4
13.3	矩阵相加	4
13.4	矩阵相乘	4
13.4.1	基本概念	4
13.4.2	串行算法	4
13.4.3	并行算法	5
13.5	矩阵向量相乘	6
13.6	并行随机数生成	6
13.7	参考文献	6
第4部分 共享资源分布式计算
第14章	分布式计算设计模式	2
14.1	基本概念	2
14.1.1	共享资源的计算分解	2
14.1.2	共享资源计算的负载均衡问题	2
14.1.3	共享资源计算的算法设计思路与方法	3
14.2	线程分组竞争模式	3
14.2.1	标准的线程分组竞争模式	4
14.2.2	线程分组竞争模式的变种	4
14.3	线程随机竞争模式	6
14.3.1	基本概念	6
14.3.2	加速比性能的保证	6
14.4	数据本地化模式	8
14.4.1	取得比单核多线程更好的性能	8
14.4.2	数据本地化模式	8
14.4.3	优缺点分析	10
14.5	分布式数据结构设计	11
14.5.1	复合数据结构设计方法	11
14.5.2	分布式数据结构设计	12
14.5.3	分布式数据结构主要问题	12
14.6	参考文献	12
第15章	分布式队列	2
15.1	串行队列	2
15.1.1	简单环形队列	2
15.1.2	STL中的Deque	2
15.1.3	动态环形队列	2
15.2	队列池	2
15.2.1	共享队列	2
15.2.2	消息队列	2
15.2.3	队列池	2
15.2.4	队列池的几种实现方案	6
15.2.5	队列池的使用实例	6
15.3	带本地计算的分布式队列	6
15.3.1	基本思想	6
15.3.2	本地化队列的实现	6
15.3.3	任务偷取队列的实现	6
15.3.4	分布式队列的实现	6
15.3.5	线程池CThreadPool的实现	6
15.3.6	线程池CThreadPool的代码实现	7
15.3.7	CDistributedQueue源代码	10
15.3.8	CDistributedQueue的使用实例	10
第16章	分布式查找	2
16.1	多核中查找的问题与主要思路	2
16.2	静态负载平衡的二级查找结构设计	4
16.2.1	二级查找结构设计	4
16.2.2	分布式哈希AVL树	7
16.2.3	分布式顺序AVL树	7
16.3	动态负载平衡的多级查找结构设计	7
16.3.1	分布式查找中的负载平衡问题	7
16.3.2	多级查找结构设计方法	10
16.3.3	多级查找表的查找算法	13
16.3.4	多级查找表的插入操作算法	14
16.3.5	多级查找表的删除操作算法	16
16.3.6	多级顺序表	18
16.3.7	多级索引AVL树	18
16.3.8	分布式哈希多级AVL树	18
16.3.9	分布式顺序多级AVL树	18
16.4	多核环境中查找算法的选用方法	18
16.5	动态WebCache设计实例	19
第17章	分布式内存管理	2
17.1	多核内存管理的基本思想	2
17.1.1	内存管理方面的需求	2
17.1.2	多核系统中的内存管理思路	3
17.2	等尺寸内存管理	4
17.2.1	Freelist内存管理基本概念	4
17.2.2	Freelist编码实现	6
17.2.3	FreeLists内存管理	9
17.3	Intel 开源项目TBB中的内存管理	12
17.3.1	伪共享问题	12
17.3.2	Cache对齐的内存管理	12
17.3.3	数据结构	14
17.3.4	将内存管理器映射到线程	16
17.3.5	分配和释放算法	19
17.3.6	线程退出时的内存回收	24
17.4	抢夺式内存管理算法	24
17.4.1	算法基本思想	24
17.4.2	碎片重组回收利用技术	26
17.4.3	抢夺式算法的详细算法流程	28
17.4.4	代码实现	31
17.5	伪共享问题的深入分析	47
17.5.1	内存释放时的伪共享问题	47
17.5.2	伪共享问题的概率分析	48
17.5.3	用户程序使用内存过程中的伪共享问题	50
17.5.4	分布式内存管理的进一步改进措施	51
17.6	参考文献	53
第5部分 任务分解与调度
第18章	任务图分解与调度	2
18.1	任务分解与调度的问题	2
18.1.1	使用OpenMP调度的问题	2
18.1.2	任务图调度模型	3
18.1.3	任务图调度算法简介	5
18.2	任务组调度算法	6
18.2.1	基本思路	6
18.2.2	任务组调度算法	7
18.2.3	算法流程图	11
18.2.4	数据结构与接口设计	13
18.2.5	代码实现	15
18.2.6	任务组调度的应用分析	21
18.2.7	误差下降调度算法	21
18.3	任务图调度算法	24
18.3.1	任务图的分层算法	24
18.3.2	分层算法过程图解	26
18.3.3	数据结构和接口设计	29
18.3.4	分层算法的代码实现	31
18.3.5	任务调度器的代码实现	33
18.3.6	实例：任务图调度器的使用	35
18.4	手工任务分解的原则和方法	37
18.4.1	任务间负载均衡的影响因素	37
18.4.2	任务分解原则和方法	38
18.5	参考文献	39
第19章	动态任务分解与调度	1
19.1	动态任务分解的两种类型	1
19.2	非嵌套型动态任务调度	2
19.2.1	网络服务器软件中的任务调度	2
19.2.2	使用分布式队列的调度方法	4
19.2.3	CTaskScheduler的设计	7
19.2.4	CTaskScheduler的代码实现	9
19.3	嵌套型动态任务调度	11
19.3.1	基本思想	11
19.3.2	CNestTaskScheduler的设计	11
19.3.3	CNestTaskScheduler的代码实现	13
19.3.4	CNestTaskScheduler使用方法	15
19.4	实例：用任务调度器实现parallel_for	15
19.5	参考文献	15
附录1	：Lock-Free编程基础	2
$1.1	Lock-Free编程基本概念和问题	2
$1.1.1	CAS原子操作	2
$1.1.2	ABA问题	3
$1.1.3	ABA问题的解决方法	5
$1.1.4	内存删除问题	6
$1.1.5	数据竞争问题	8
$1.2	Lock-Free的队列	8
$1.2.1	无锁队列的链式实现方法	8
$1.2.2	串行实现方法	10
$1.2.3	出队操作的Lock-Free实现	11
$1.2.4	进队操作的Lock-Free实现	13
$1.2.5	CLockFreeQueue的实现代码	14
$1.3	Lock-Free程序的问题分析	16
$1.4	参考文献	17
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>多核计算与程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 7并发编程实战手册
第1章 线程管理 1
1.1 简介 1
1.2 线程的创建和运行 2
1.3 线程信息的获取和设置 5
1.4 线程的中断 9
1.5 线程中断的控制 11
1.6 线程的休眠和恢复 15
1.7 等待线程的终止 17
1.8 守护线程的创建和运行 20
1.9 线程中不可控异常的处理 24
1.10 线程局部变量的使用 26
1.11 线程的分组 30
1.12 线程组中不可控异常的处理 34
1.13 使用工厂类创建线程 37
第2章 线程同步基础 41
2.1 简介 41
2.2 使用synchronized实现同步方法 42
2.3 使用非依赖属性实现同步 47
2.4 在同步代码中使用条件 53
2.5 使用锁实现同步 57
2.6 使用读写锁实现同步数据访问 61
2.7 修改锁的公平性 65
2.8 在锁中使用多条件(Multiple Condition) 69
第3章 线程同步辅助类 77
3.1 简介 77
3.2 资源的并发访问控制 78
3.3 资源的多副本的并发访问控制 83
3.4 等待多个并发事件的完成 87
3.5 在集合点的同步 91
3.6 并发阶段任务的运行 100
3.7 并发阶段任务中的阶段切换 109
3.8 并发任务间的数据交换 115
第4章 线程执行器 120
4.1 简介 120
4.2 创建线程执行器 121
4.3 创建固定大小的线程执行器 126
4.4 在执行器中执行任务并返回结果 129
4.5 运行多个任务并处理第一个结果 134
4.6 运行多个任务并处理所有结果 139
4.7 在执行器中延时执行任务 144
4.8 在执行器中周期性执行任务 147
4.9 在执行器中取消任务 151
4.10 在执行器中控制任务的完成 154
4.11 在执行器中分离任务的启动与结果的处理 158
4.12 处理在执行器中被拒绝的任务 164
第5章 Fork/Join框架 168
5.1 简介 168
5.2 创建Fork/Join线程池 170
5.3 合并任务的结果 178
5.4 异步运行任务 187
5.5 在任务中抛出异常 194
5.6 取消任务 199
第6章 并发集合 206
6.1 简介 206
6.2 使用非阻塞式线程安全列表 207
6.3 使用阻塞式线程安全列表 212
6.4 使用按优先级排序的阻塞式线程安全列表 215
6.5 使用带有延迟元素的线程安全列表 221
6.6 使用线程安全可遍历映射 226
6.7 生成并发随机数 231
6.8 使用原子变量 233
6.9 使用原子数组 237
第7章 定制并发类 242
7.1 简介 242
7.2 定制ThreadPoolExecutor类 243
7.3 实现基于优先级的Executor类 248
7.4 实现ThreadFactory接口生成定制线程 252
7.5 在Executor对象中使用ThreadFactory 257
7.6 定制运行在定时线程池中的任务 259
7.7 通过实现ThreadFactory接口为Fork/Join框架生成定制线程 267
7.8 定制运行在Fork/Join框架中的任务 273
7.9 实现定制Lock类 278
7.10 实现基于优先级的传输队列 284
7.11 实现自己的原子对象 294
第8章 测试并发应用程序 300
8.1 简介 300
8.2 监控Lock接口 301
8.3 监控Phaser类 305
8.4 监控执行器框架 309
8.5 监控Fork/Join池 312
8.6 输出高效的日志信息 317
8.7 使用FindBugs分析并发代码 323
8.8 配置Eclipse调试并发代码 327
8.9 配置NetBeans调试并发代码 330
8.10 使用MultithreadedTC测试并发代码 335
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 7并发编程实战手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>多核应用编程实战
第1章　硬件、进程和线程　　1
1.1 　计算机的内部结构　　1
1.2 　多核处理器的缘起　　3
1.2.1 　在单芯片上支持多线程　　4
1.2.2 　通过处理器核心流水线作业提高指令发出率　　8
1.2.3 　使用缓存保存最近使用的数据　　10
1.2.4 　用虚拟内存存储数据　　12
1.2.5 　从虚拟地址转换到物理地址　　13
1.3 　多处理器系统的特征　　14
1.4 　源代码到汇编语言的转换　　16
1.4.1 　32位与64位代码的性能　　18
1.4.2 　确保内存操作的正确顺序　　19
1.4.3 　进程和线程的差异　　21
1.5 　小结　　23
第2章　高性能编码　　24
2.1 　定义性能　　24
2.2 　了解算法复杂度　　25
2.2.1 　算法复杂度的示例　　26
2.2.2 　算法复杂度的重要性　　28
2.2.3 　谨慎运用算法复杂度　　30
2.3 　结构如何影响性能　　30
2.3.1 　在源代码和生成结构上权衡性能和便利性　　30
2.3.2 　利用库结构化应用程序　　33
2.3.3 　数据结构对性能的影响　　42
2.4 　编译器的作用　　47
2.4.1 　两种编译器优化　　48
2.4.2 　选择合适的编译器选项　　50
2.4.3 　如何用跨文件优化提高性能　　51
2.4.4 　使用配置文件反馈　　53
2.4.5 　潜在的指针别名会如何抑制编译器优化　　55
2.5 　通过分析确定占用时间的地方　　58
2.6 　怎样避免手动优化　　64
2.7 　从设计角度看性能　　64
2.8 　小结　　65
第3章　识别并行机会　　66
3.1 　使用多进程提高系统工作效率　　66
3.2 　多用户使用一个系统　　67
3.3 　通过整合提高机器工作效率　　68
3.3.1 　用容器隔离共享一个系统的应用程序　　69
3.3.2 　使用虚拟机监控程序托管多个操作系统　　69
3.4 　采用并行机制提高单个任务的性能　　71
3.4.1 　理解并行应用程序　　72
3.4.2 　并行如何影响算法的选择　　72
3.4.3 　Amdahl定律　　73
3.4.4 　确定最大实际线程数　　75
3.4.5 　同步成本怎样降低扩展性　　76
3.5 　并行模式　　78
3.5.1 　使用SIMD指令的数据并行　　78
3.5.2 　通过进程或线程实现并行化　　79
3.5.3 　多个独立任务　　79
3.5.4 　多个松散耦合的任务　　80
3.5.5 　相同任务的多个副本　　81
3.5.6 　单个任务拆分到多个线程　　82
3.5.7 　使用流水线任务完成某个事项　　82
3.5.8 　将工作分配给客户端和服务器　　83
3.5.9 　将责任划分给生产者和消费者　　84
3.5.10 　结合多种并行化策略　　85
3.6 　依赖关系对并行运行代码能力的影响　　85
3.6.1 　反依赖和输出依赖　　86
3.6.2 　通过推测打破依赖　　88
3.6.3 　关键路径　　91
3.7 　发现并行机会　　92
3.8 　小结　　93
第4章　同步和数据共享　　94
4.1 　数据争用　　94
4.1.1 　使用工具检测数据争用　　95
4.1.2 　避免数据争用　　98
4.2 　同步原语　　98
4.2.1 　互斥量和临界区　　98
4.2.2 　自旋锁　　99
4.2.3 　信号量　　100
4.2.4 　读写锁　　100
4.2.5 　屏障　　101
4.2.6 　原子操作和无锁代码　　102
4.3 　死锁和活锁　　103
4.4 　线程和进程间的通信　　104
4.4.1 　内存、共享内存和内存映射文件　　104
4.4.2 　条件变量　　105
4.4.3 　信号和事件　　107
4.4.4 　消息队列　　108
4.4.5 　命名管道　　108
4.4.6 　通过网络栈进行通信　　109
4.4.7 　线程之间共享数据的其他方法　　110
4.5 　存储线程私有数据　　110
4.6 　小结　　112
第5章　使用POSIX线程　　113
5.1 　创建线程　　113
5.1.1 　线程终止　　114
5.1.2 　用子线程接收和传递数据　　115
5.1.3 　分离线程　　116
5.1.4 　设置pthread的属性　　117
5.2 　编译多线程代码　　119
5.3 　进程终止　　121
5.4 　线程之间共享数据　　122
5.4.1 　使用互斥锁保护访问　　122
5.4.2 　互斥锁属性　　124
5.4.3 　使用自旋锁　　125
5.4.4 　读写锁　　127
5.4.5 　屏障　　129
5.4.6 　信号量　　130
5.4.7 　条件变量　　136
5.5 　变量和内存　　140
5.6 　多进程编程　　143
5.6.1 　在进程之间共享内存　　144
5.6.2 　在进程之间共享信号量　　147
5.6.3 　消息队列　　147
5.6.4 　管道和命名管道　　150
5.6.5 　使用信号与进程通信　　151
5.7 　套接字　　156
5.8 　可重入代码和编译器标志　　158
5.9 　小结　　160
第6章　Windows线程　　161
6.1 　创建Windows本机线程　　161
6.1.1 　终止线程　　165
6.1.2 　创建和重新启动挂起的线程　　167
6.1.3 　使用内核资源的句柄　　168
6.2 　同步和资源共享的方式　　168
6.2.1 　线程间需要同步的一个例子　　169
6.2.2 　保护对临界区代码的访问　　170
6.2.3 　用互斥量保护代码段　　172
6.2.4 　轻量级读写锁　　173
6.2.5 　信号量　　175
6.2.6 　条件变量　　177
6.2.7 　向其他线程或进程发出事件完成的信号　　178
6.3 　Windows中的宽字符串处理　　179
6.4 　创建进程　　180
6.4.1 　在进程之间共享内存　　182
6.4.2 　在子进程中继承句柄　　185
6.4.3 　互斥量命名及其在进程间的共享　　186
6.4.4 　用管道通信　　187
6.4.5 　用套接字进行通信　　190
6.5 　变量的原子更新　　193
6.6 　分配线程本地存储　　195
6.7 　设置线程的优先级　　197
6.8 　小结　　198
第7章　自动并行化和OpenMP　　199
7.1 　使用自动并行化产生并行代码　　199
7.1.1 　识别和并行约简　　203
7.1.2 　对包含调用的代码进行自动并行化　　204
7.1.3 　协助编译器实现代码的自动并行化　　206
7.2 　使用OpenMP生成并行应用程序　　208
7.2.1 　使用OpenMP并行化循环　　209
7.2.2 　OpenMP应用程序的运行时行为　　210
7.2.3 　OpenMP并行区域中的变量作用域　　210
7.2.4 　使用OpenMP并行化约简　　212
7.2.5 　在并行区域外访问私有数据　　212
7.2.6 　使用调度改进工作分配　　214
7.2.7 　用并行段完成独立工作　　217
7.2.8 　嵌套并行　　218
7.2.9 　使用OpenMP动态定义并行任务　　219
7.2.10 　保持数据对线程私有　　223
7.2.11 　控制OpenMP运行时环境　　225
7.2.12 　等待工作完成　　227
7.2.13 　限制执行代码区域的线程　　229
7.3 　确保并行区域的代码按顺序执行　　232
7.4 　折叠循环改进工作负荷均衡　　233
7.5 　强制实现内存一致性　　234
7.6 　并行化示例　　235
7.7 　小结　　239
第8章　手工编码的同步和共享　　240
8.1 　原子操作　　240
8.1.1 　用比较和交换指令构成更复杂的原子操作　　242
8.1.2 　强制实现内存排序以确保正确操作　　245
8.1.3 　编译器对内存排序指令的支持　　247
8.1.4 　编译器对操作的重新排序　　247
8.1.5 　易失变量　　251
8.2 　操作系统提供的原子操作　　251
8.3 　无锁算法　　254
8.3.1 　Dekker算法　　254
8.3.2 　带循环缓存的生产者/消费者　　256
8.3.3 　扩展到多个消费者或生产者　　259
8.3.4 　将生产者/消费者扩展到多个线程　　260
8.3.5 　更改生产者/消费者代码为使用原子操作　　266
8.3.6 　ABA问题　　268
8.4 　小结　　271
第9章　基于多核处理器的扩展　　272
9.1 　对应用程序扩展的限制　　272
9.1.1 　串行代码对性能的限制　　272
9.1.2 　超线性扩展　　275
9.1.3 　工作负荷不均衡　　276
9.1.4 　热锁　　277
9.1.5 　库代码扩展　　282
9.1.6 　工作量不足　　284
9.1.7 　算法限制　　286
9.2 　扩展的硬件限制　　288
9.2.1 　核心之间的带宽共享　　288
9.2.2 　伪共享　　290
9.2.3 　缓存冲突和容量　　293
9.2.4 　流水线资源匮乏　　297
9.3 　操作系统对扩展性的限制　　301
9.3.1 　过度订阅　　301
9.3.2 　使用处理器绑定改善内存局部性　　303
9.3.3 　优先级反转　　310
9.4 　多核处理器和扩展　　310
9.5 　小结　　311
第10章　其他并行技术　　312
10.1 　基于GPU的运算　　312
10.2 　语言扩展　　314
10.2.1 　线程构建模块　　314
10.2.2 　Cilk++　　317
10.2.3 　Grand Central Dispatch　　320
10.2.4 　为未来C和C++标准提议的可能功能　　321
10.2.5 　微软的C++/CLI　　324
10.3 　其他语言　　325
10.4 　集群技术　　327
10.4.1 　MPI　　328
10.4.2 　以MapReduce作为扩展策略　　331
10.4.3 　网格　　332
10.5 　事务性内存　　332
10.6 　向量化　　333
10.7 　小结　　334
第11章　结束语　　335
11.1 　编写并行应用程序　　335
11.1.1 　识别任务　　335
11.1.2 　估算性能提升　　336
11.1.3 　确定依赖关系　　336
11.1.4 　数据争用和互斥锁扩展限制　　336
11.1.5 　锁的粒度　　337
11.2 　多核处理器上的并行代码　　337
11.3 　并行化的未来　　339
参考文献　　340
索引　　342

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>多核应用编程实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#线程参考手册
第1章 定义线程
1.1 线程的定义
1.1.1 多任务
1.1.2 进程
1.1.3 线程
1.2 .NET和C#对线程的支持
1.2.1 System.Appdomai

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#线程参考手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java线程
前言
第一章 线程简介
java术语
线程概述
为什么要使用线程？
总结
第二章 java线程api
通过thread类创建线程
使用runable接口的线程
线程的生命周期
线程命名
访问线程
线程的启动、停止和连接
总结
第三章 同步技术
银行的例子
异步读取数据
.一个进行同步操作的类
同步块
嵌套锁
死锁
返回到银行的例子
同步静态方法
总结
第四章 等待和通知
返回到银行的例子
等待和通知
wait（）、notify（）和notifyall（）
wait（）和sleep（）
线程中断
静态方法（有关同步的细节）
总结
第五章 java线程编程的例子
数据结构和容器
简单的同步例子
一个网络服务器类
asyncinputstream类
使用tcpserver和asynclnputstream
总结
第六章 java线程调度
线程调度概述
何时调度是重要的
调度和线程优先级
常见的调度实现
本地调度支持
其他线程调度方法
总结
第七章 java线程调度例子
线程池
循环调度
作业调度
总结
第八章 和同步相关的高级主题
同步术语
预防死锁
锁饥饿
非线程安全的类
总结
第九章 多处理器机器上的并行化
单线程程序并行化
内层循环线程化
循环输出
多处理器扩展
总结
第十章 线程组
线程组概念
创建线程组
线程组方法
操作线程组
线程组、线程和安全
总结
附录一 其他主题
附录二 异常和错误
词汇表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java线程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java线程编程
第一部分  线
程
第1章  线程简介　3
1.1  什么是线程　4
1.2  为什么使用多线程　4
1.2.1  与用户的更佳交互　4
1.2.2  同步动作的模拟　5

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java线程编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入学习
第一章 简介
第二章 概念
第三章 基础
第四章 生存期 
第五章 作业调度
第六章 同步
第七章 复杂同步
第八章 TSD
第九章 取消
第十章 细节
第十一章 库
第十二章 设计
第十三章 RMI
第十四章 工具
第十五章 性能
……
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入学习
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>増補改訂版 Java言語で学ぶデザインパターン入門 マルチスレッド編
Java言語のスレッド
マルチスレッドプログラムの評価基準
Single Threaded Execution―この橋を渡れるのは、たった1人
Immutable―壊したくとも、壊せない
Guarded Suspension―用意できるまで、待っててね
Balking―必要なかったら、やめちゃおう
Producer‐Consumer―わたしが作り、あなたが使う
Read‐Write Lock―みんなで読んでもいいけれど、読んでる間は書いちゃだめ
Thread‐Per‐Message―この仕事、やっといてね
Worker Thread―仕事がくるまで待ち、仕事がきたら働く
Future―引換券を、お先にどうぞ
Two‐Phase Termination―あとかたづけしてから、おやすみなさい
Thread‐Specific Strage―スレッドごとのコインロッカー
Active Object―非同期メッセージを受け取る、能動的なオブジェクト
マルチスレッドプログラミングのパターン・ランゲージ
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>増補改訂版 Java言語で学ぶデザインパターン入門 マルチスレッド編
