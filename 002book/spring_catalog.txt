>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring实战（第4版）
第1部分　Spring的核心
第1章　Spring之旅　3
1.1　简化Java开发　4
1.1.1　激发POJO的潜能　5
1.1.2　依赖注入　5
1.1.3　应用切面　11
1.1.4　使用模板消除样板式代码　16
1.2　容纳你的Bean　18
1.2.1　使用应用上下文　19
1.2.2　bean的生命周期　20
1.3　俯瞰Spring风景线　21
1.3.1　Spring模块　22
1.3.2　Spring Portfolio　24
1.4　Spring的新功能　27
1.4.1　Spring 3.1新特性　27
1.4.2　Spring 3.2新特性　28
1.4.3　Spring 4.0新特性　30
1.5　小结　30
第2章　装配Bean　33
2.1　Spring配置的可选方案　34
2.2　自动化装配bean　35
2.2.1　创建可被发现的bean　35
2.2.2　为组件扫描的bean命名　38
2.2.3　设置组件扫描的基础包　39
2.2.4　通过为bean添加注解实现自动装配　40
2.2.5　验证自动装配　42
2.3　通过Java代码装配
bean　44
2.3.1　创建配置类　44
2.3.2　声明简单的bean　45
2.3.3　借助JavaConfig实现注入　46
2.4　通过XML装配bean　48
2.4.1　创建XML配置规范　48
2.4.2　声明一个简单的
[bean]　49
2.4.3　借助构造器注入初始化bean　50
2.4.4　设置属性　56
2.5　导入和混合配置　61
2.5.1　在JavaConfig中引用XML配置　61
2.5.2　在XML配置中引用JavaConfig　63
2.6　小结　65
第3章　高级装配　67
3.1　环境与profile　67
3.1.1　配置profile bean　69
3.1.2　激活profile　73
3.2　条件化的bean　75
3.3　处理自动装配的歧义性　78
3.3.1　标示首选的bean　79
3.3.2　限定自动装配的bean　80
3.4　bean的作用域　84
3.4.1　使用会话和请求作用域　86
3.4.2　在XML中声明作用域代理　88
3.5　运行时值注入　88
3.5.1　注入外部的值　89
3.5.2　使用Spring表达式语言进行装配　93
3.6　小结　99
第4章　面向切面的Spring　101
4.1　什么是面向切面编程？　102
4.1.1　定义AOP术语　103
4.1.2　Spring对AOP的支持　105
4.2　通过切点来选择连接点　107
4.2.1　编写切点　108
4.2.2　在切点中选择bean　109
4.3　使用注解创建切面　109
4.3.1　定义切面　110
4.3.2　创建环绕通知　114
4.3.3　处理通知中的参数　115
4.3.4　通过注解引入新功能　118
4.4　在XML中声明切面　120
4.4.1　声明前置和后置通知　122
4.4.2　声明环绕通知　124
4.4.3　为通知传递参数　125
4.4.4　通过切面引入新的功能　127
4.5　注入AspectJ切面　128
4.5　小结　131
第２部分　Web中的Spring
第5章　构建Spring Web应用程序　135
5.1　Spring MVC起步　136
5.1.1　跟踪Spring MVC的请求　136
5.1.2　搭建Spring MVC　138
5.1.3　Spittr应用简介　142
5.2　编写基本的控制器　143
5.2.1　测试控制器　145
5.2.2　定义类级别的请求处理　146
5.2.3　传递模型数据到视图中　147
5.3　接受请求的输入　153
5.3.1　处理查询参数　153
5.3.2　通过路径参数接受输入　155
5.4　处理表单　157
5.4.1　编写处理表单的控制器　160
5.4.2　校验表单　163
5.5　小结　166
第6章　渲染Web视图　167
6.1　理解视图解析　167
6.2　创建JSP视图　170
6.2.1　配置适用于JSP的视图解析器　170
6.2.2　使用Spring的JSP库　172
6.3　使用Apache Tiles视图定义布局　184
6.3.1　配置Tiles视图解析器　185
6.4　使用Thymeleaf　190
6.4.1　配置Thymeleaf视图解析器　190
6.4.2　定义Thymeleaf模板　192
6.5　小结　196
第7章　Spring MVC的高级技术　197
7.1　Spring MVC配置的替代方案　198
7.1.1　自定义DispatcherServlet配置　198
7.1.2　添加其他的Servlet和Filter　199
7.1.3　在web.xml中声明DispatcherServlet　201
7.2　处理multipart形式的数据　204
7.2.1　配置multipart解析器　205
7.2.2　处理multipart请求　208
7.3　处理异常　212
7.3.1　将异常映射为HTTP状态码　213
7.3.2　编写异常处理的方法　214
7.4　为控制器添加通知　216
7.5　跨重定向请求传递数据　217
7.5.1　通过URL模板进行重定向　218
7.5.2　使用flash属性　219
7.6　小结　221
第8章　使用Spring WebFlow　223
8.1　在Spring中配置Web　Flow　224
8.1.1　装配流程执行器　224
8.1.2　配置流程注册表　224
8.1.3　处理流程请求　225
8.2　流程的组件　226
8.2.1　状态　226
8.2.2　转移　230
8.2.3　流程数据　231
8.3　组合起来：披萨流程　232
8.3.1　定义基本流程　233
8.3.2　收集顾客信息　236
8.3.2　构建订单　242
8.3.2　支付　244
8.4　保护Web流程　246
8.5　小结　246
第9章　保护Web应用　249
9.1　Spring Security简介　250
9.1.1　理解Spring Security的模块　250
9.1.2　过滤Web请求　251
9.1.3　编写简单的安全性配置　252
9.2　选择查询用户详细信息的服务　255
9.2.1使用基于内存的用户存储　255
9.2.2　基于数据库表进行认证　257
9.2.3　基于LDAP进行认证　259
9.2.4　配置自定义的用户服务　263
9.3　拦截请求　265
9.3.1　使用Spring表达式进行安全保护　267
9.3.2　强制通道的安全性　269
9.3.3　防止跨站请求伪造　270
9.4　认证用户　271
9.4.1　添加自定义的登录页　272
9.4.2　启用HTTP Basic认证　274
9.4.3　启用Remember-me功能　274
9.4.4　退出　275
9.5　保护视图　276
9.5.1　使用Spring Security的JSP标签库　276
9.5.2　使用Thymeleaf的SpringSecurity方言　280
9.6　小结　281
第3部分　后端中的Spring
第10章　通过Spring和JDBC征服数据库　285
10.1　Spring的数据访问哲学　286
10.1.1　了解Spring的数据访问异常体系　287
10.1.2　数据访问模板化　289
10.2　配置数据源　291
10.2.1　使用JNDI数据源　292
10.2.2　使用数据源连接池　292
10.2.3　基于JDBC驱动的数据源　294
10.2.4　使用嵌入式的数据源　295
10.2.5　使用profile选择数据源　296
10.3　在Spring中使用
JDBC　298
10.3.1　应对失控的JDBC代码　299
10.3.2　使用JDBC模板　302
10.4　小结　307
第11章　使用对象-关系映射持久化数据　309
11.1　在Spring中集成Hibernate　310
11.1.1　声明Hibernate的Session工厂　311
11.1.2　构建不依赖于Spring的Hibernate代码　313
11.2　Spring与Java持久化API　315
11.2.1　配置实体管理器工厂　315
11.2.2　编写基于JPA的Repository　320
11.3　借助Spring Data实现自动化的JPA　Repository　322
11.3.1　定义查询方法　325
11.3.2　声明自定义查询　328
11.3.3　混合自定义的功能　329
11.4　小结　330
第12章　使用NoSQL数据库　333
12.1　使用MongoDB持久化文档数据　334
12.1.1　启用MongoDB　335
12.1.2　为模型添加注解，实现MongoDB持久化　338
12.1.3　使用MongoTemplate访问MongoDB　341
12.1.4　编写MongoDBRepository　342
12.2　使用Neo4j操作图数据　347
12.2.1　配置Spring DataNeo4j　347
12.2.2　使用注解标注图实体　350
12.2.3　使用Neo4jTemplate　353
12.2.4　创建自动化的Neo4j　Repository　354
12.3　使用Redis操作key-value数据　359
12.3.1　连接到Redis　359
12.3.2　使用RedisTemplate　360
12.3.3　使用key和value的序列化器　364
12.4　小结　365
第13章　缓存数据　367
13.1　启用对缓存的支持　368
13.1.1　配置缓存管理器　369
13.2　为方法添加注解以支持缓存　373
13.2.1　填充缓存　374
13.2.2　移除缓存条目　378
13.3　使用XML声明缓存　379
13.4　小结　383
第14章　保护方法应用　385
14.1　使用注解保护方法　386
14.1.1　使用@Secured注解限制方法调用　386
14.1.2　在Spring Security中使用
JSR-250的@RolesAllowed注解　387
14.2　使用表达式实现方法级别的安全性　388
14.2.1　表述方法访问规则　389
14.2.2　过滤方法的输入和输出　391
14.3　小结　395
第4部分　Spring集成
第15章　使用远程服务　399
15.1　Spring远程调用概览　400
15.2　使用RMI　402
15.2.1　导出RMI服务　403
15.2.2　装配RMI服务　405
15.3　使用Hessian和Burlap发布远程服务　407
15.3.1　使用Hessian和Burlap导出bean的功能　408
15.3.2　访问Hessian/Burlap服务　411
15.4　使用Spring的HttpInvoker　413
15.4.1　将bean导出为HTTP服务　413
15.4.2　通过HTTP访问服务　414
15.5　发布和使用Web服务　416
15.5.1　创建基于Spring的JAX-WS端点　416
15.5.2　在客户端代理JAX-WS服务　419
15.6　小结　421
第16章　使用Spring MVC创建REST API　423
16.1　了解REST　424
16.1.1　REST的基础知识　424
16.1.2　Spring是如何支持REST的　425
16.2　创建第一个REST端点　426
16.2.1　协商资源表述　428
16.2.2　使用HTTP信息转换器　433
16.3　提供资源之外的其他内容　438
16.3.1　发送错误信息到客户端　438
16.3.2　在响应中设置头部信息　443
16.4　编写REST客户端　445
16.4.1　了解RestTemplate的操作　446
16.4.2　GET资源　447
16.4.3　检索资源　448
16.4.4　抽取响应的元数据　449
16.4.5　PUT资源　450
16.4.6　DELETE资源　451
16.4.7　POST资源数据　452
16.4.8　在POST请求中获取响应对象　452
16.4.9　在POST请求后获取资源位置　453
16.4.10　交换资源　454
16.5　小结　456
第17章　Spring消息　457
17.1　异步消息简介　458
17.1.1　发送消息　459
17.1.2　评估异步消息的优点　461
17.2　使用JMS发送消息　463
17.2.1　在Spring中搭建消息代理　463
17.2.2　使用Spring的JMS模板　465
17.2.3　创建消息驱动的POJO　474
17.2.4　使用基于消息的RPC　477
17.3　使用AMQP实现消息功能　479
17.3.1　AMQP简介　480
17.3.2　配置Spring支持AMQP消息　481
17.3.3　使用RabbitTemplate发送消息　484
17.3.4　接收AMQP消息　486
17.4　小结　489
第18章　使用WebSocket和STOMP实现消息功能　491
18.1　使用Spring的低层级WebSocket　API　492
18.2　应对不支持WebSocket的场景　497
18.3　使用STOMP消息　500
18.3.1　启用STOMP消息功能　501
18.3.2　处理来自客户端的STOMP消息　504
18.3.3　发送消息到客户端　507
18.4　为目标用户发送消息　511
18.4.1　在控制器中处理用户的消息　512
18.4.2　为指定用户发送消息　514
18.5　处理消息异常　515
18.6　小结　516
第19章　使用Spring发送Email　517
19.1　配置Spring发送邮件　518
19.1.1　配置邮件发送器　518
19.1.2　装配和使用邮件发送器　520
19.2　构建丰富内容的Email消息　521
19.2.1　添加附件　521
19.2.2　发送富文本内容的Email　522
19.3　使用模板生成Email　524
19.3.1　使用Velocity构建Email消息　524
19.3.2　使用Thymeleaf构建Email消息　526
19.4　小结　528
第20章　使用JMX管理Spring　Bean　529
20.1　将Spring bean导出为MBean　530
20.1.1　通过名称暴露方法　533
20.1.2　使用接口定义MBean的操作和属性　535
20.1.3　使用注解驱动的MBean　536
20.1.4　处理MBean冲突　538
20.2　远程MBean　539
20.2.1　暴露远程MBean　539
20.2.2　访问远程MBean　540
20.2.3　代理MBean　542
20.3　处理通知　543
20.3.1　监听通知　544
20.4　小结　545
第21章　借助Spring Boot简化Spring开发　547
21.1　Spring Boot简介　548
21.1.1　添加Starter依赖　548
21.1.2　自动配置　552
21.1.3　Spring Boot CLI　552
21.1.4　Actuator　553
21.2　使用Spring Boot构建应用　553
21.2.1　处理请求　556
21.2.2　创建视图　558
21.2.3　添加静态内容　560
21.2.4　持久化数据　561
21.2.5　尝试运行　563
21.3　组合使用Groovy与SpringBoot　CLI　566
21.3.1　编写Groovy控制器　566
21.3.2　使用Groovy Repository实现数据持久化　569
21.3.3　运行Spring Boot CLI　570
21.4　通过Actuator获取了解应用内部状况　571
21.5　小结　574
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring实战（第4版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring揭秘
第一部分 掀起Spring的盖头来
第1章 Spring框架的由来 2
1.1 Spring之崛起 2
1.2 Spring框架概述 3
1.3 Spring大观园 5
1.4 小结 8
第二部分 Spring的IoC容器
第2章 IoC的基本概念 10
2.1 我们的理念是：让别人为你服务 10
2.2 手语，呼喊，还是心有灵犀 13
2.2.1 构造方法注入 13
2.2.2 setter方法注入 13
2.2.3 接口注入 14
2.2.4 三种注入方式的比较 15
2.3 IoC的附加值 15
2.4 小结 17
第3章 掌管大局的IoC Service Provider 18
3.1 IoC Service Provider的职责 18
3.2 运筹帷幄的秘密——IoC Service Provider如何管理对象间的依赖关系 19
3.2.1 直接编码方式 19
3.2.2 配置文件方式 20
3.2.3 元数据方式 21
3.3 小结 21
第4章 Spring的IoC容器之BeanFactory 22
4.1 拥有BeanFactory之后的生活 24
4.2 BeanFactory的对象注册与依赖绑定方式 26
4.2.1 直接编码方式 26
4.2.2 外部配置文件方式 28
4.2.3 注解方式 31
4.3 BeanFactory的XML之旅 33
4.3.1 beans和bean 33
4.3.2 孤孤单单一个人 35
4.3.3 Help Me， Help You 36
4.3.4 继承？我也会！ 50
4.3.5 bean的scope 51
4.3.6 工厂方法与FactoryBean 56
4.3.7 偷梁换柱之术 61
4.4 容器背后的秘密 66
4.4.1 “战略性观望” 66
4.4.2 插手“容器的启动” 67
4.4.3 了解bean的一生 74
4.5 小结 85
第5章 Spring IoC容器ApplicationContext 86
5.1 统一资源加载策略 86
5.1.1 Spring中的Resource 87
5.1.2 ResourceLoader，“更广义的URL” 88
5.1.3 ApplicationContext与ResourceLoader 91
5.2 国际化信息支持(I18n MessageSource) 97
5.2.1 Java SE提供的国际化支持 97
5.2.2 MessageSource与ApplicationContext 98
5.3 容器内部事件发布 102
5.3.1 自定义事件发布 102
5.3.2 Spring的容器内事件发布类结构分析 105
5.3.3 Spring容器内事件发布的应用 107
5.4 多配置模块加载的简化 109
5.5 小结 110
第6章 Spring IoC容器之扩展篇 111
6.1 Spring 2.5的基于注解的依赖注入 111
6.1.1 注解版的自动绑定(@Autowired) 111
6.1.2 @Autowired之外的选择——使用JSR250标注依赖注入关系 115
6.1.3 将革命进行得更彻底一些(class-path-scanning功能介绍) 116
6.2 Spring 3.0展望 119
6.3 小结 120
第三部分 Spring AOP框架
第7章 一起来看AOP 122
7.1 AOP的尴尬 124
7.2 AOP走向现实 125
7.2.1 静态AOP时代 125
7.2.2 动态AOP时代 126
7.3 Java平台上的AOP实现机制 126
7.3.1 动态代理 126
7.3.2 动态字节码增强 126
7.3.3 Java代码生成 127
7.3.4 自定义类加载器 127
7.3.5 AOL扩展 127
7.4 AOP国家的公民 128
7.4.1 Joinpoint 128
7.4.2 Pointcut 130
7.4.3 Advice 131
7.4.4 Aspect 133
7.4.5 织入和织入器 133
7.4.6 目标对象 133
7.5 小结 134
第8章 Spring AOP概述及其实现机制 135
8.1 Spring AOP概述 135
8.2 Spring AOP的实现机制 136
8.2.1 设计模式之代理模式 136
8.2.2 动态代理 139
8.2.3 动态字节码生成 141
8.3 小结 142
第9章 Spring AOP一世 143
9.1 Spring AOP中的Joinpoint 143
9.2 Spring AOP中的Pointcut 144
9.2.1 常见的Pointcut 146
9.2.2 扩展Pointcut(Customize Pointcut) 151
9.2.3 IoC容器中的Pointcut 152
9.3 Spring AOP中的Advice 153
9.3.1 per-class类型的Advice 153
9.3.2 per-instance类型的Advice 159
9.4 Spring AOP中的Aspect 163
9.4.1 PointcutAdvisor家族 164
9.4.2 IntroductionAdvisor分支 167
9.4.3 Ordered的作用 168
9.5 Spring AOP的织入 170
9.5.1 如何与ProxyFactory打交道 170
9.5.2 看清ProxyFactory的本质 175
9.5.3 容器中的织入器——ProxyFactoryBean 179
9.5.4 加快织入的自动化进程 185
9.6 TargetSource 190
9.6.1 可用的TargetSource实现类 191
9.6.2 自定义TargetSource 195
9.7 小结 197
第10章 Spring AOP二世 198
10.1 @AspectJ形式的Spring AOP 198
10.1.1 @AspectJ形式AOP使用之先睹为快 199
10.1.2 @AspectJ形式的Pointcut 201
10.1.3 @AspectJ形式的Advice 211
10.1.4 @AspectJ中的Aspect更多话题 220
10.2 基于Schema的AOP 223
10.2.1 基于Schema的AOP配置概览 223
10.2.2 向基于Schema的AOP迁移 225
10.2.3 @AspectJ到“基于Schema的AOP”迁移 227
10.3 小结 235
第11章 AOP应用案例 237
11.1 异常处理 237
11.1.1 Java异常处理 237
11.1.2 Fault Barrier 238
11.2 安全检查 239
11.3 缓存 240
11.4 小结 240
第12章 Spring AOP之扩展篇 241
12.1 有关公开当前调用的代理对象的探讨 241
12.1.1 问题的现象 241
12.1.2 原因的分析 242
12.1.3 解决方案 243
12.2 小结 245
第四部分 使用Spring访问数据
第13章 统一的数据访问异常层次体系 249
13.1 DAO模式的背景 249
13.2 梦想照进现实 251
13.3 发现问题，解决问题 252
13.4 不重新发明轮子 254
13.5 小结 257
第14章 JDBC API的最佳实践 258
14.1 基于Template的JDBC使用方式 258
14.1.1 JDBC的尴尬 258
14.1.2 JdbcTemplate的诞生 261
14.1.3 JdbcTemplate和它的兄弟们 274
14.1.4 Spring中的DataSource 296
14.1.5 JdbcDaoSupport 301
14.2 基于操作对象的JDBC使用方式 302
14.2.1 基于操作对象的查询 303
14.2.2 基于操作对象的更新 310
14.2.3 基于操作对象的存储过程调用 313
14.3 小结 316
第15章 Spring对各种ORM的集成 317
15.1 Spring对Hibernate的集成 318
15.1.1 旧日“冬眠”时光 318
15.1.2 “春天”里的“冬眠” 321
15.2 Spring对iBATIS的集成 329
15.2.1 iBATIS实践之“前生”篇 329
15.2.2 iBATIS实践之“今世”篇 331
15.3 Spring中对其他ORM方案的集成概述 337
15.3.1 Spring对JDO的集成 337
15.3.2 Spring对TopLink的集成 340
15.3.3 Spring对JPA的集成 341
15.4 小结 344
第16章 Spring数据访问之扩展篇 345
16.1 活用模板方法模式及Callback 345
16.1.1 FTPClientTemplate 345
16.1.2 HttpClientTemplate 349
16.2 数据访问中的多数据源 350
16.2.1 “主权独立”的多数据源 350
16.2.2 “合纵连横”的多数据源 352
16.2.3 结束语 354
16.3 Spring 3.0展望 356
16.4 小结 356
第五部分 事务管理
第17章 有关事务的楔子 358
17.1 认识事务本身 358
17.2 初识事务家族成员 360
17.3 小结 362
第18章 群雄逐鹿下的Java事务管理 363
18.1 Java平台的局部事务支持 363
18.2 Java平台的分布式事务支持 365
18.2.1 基于JTA的分布式事务管理 366
18.2.2 基于JCA的分布式事务管理 367
18.3 继续前行之前的反思 367
18.4 小结 369
第19章 Spring事务王国的架构 370
19.1 统一中原的过程 371
19.2 和平年代 376
19.2.1 TransactionDefinition 376
19.2.2 TransactionStatus 382
19.2.3 PlatformTransac-tionManager 382
19.3 小结 392
第20章 使用Spring进行事务管理 393
20.1 编程式事务管理 393
20.1.1 直接使用PlatformTran-sactionManager进行编程式事务管理 393
20.1.2 使用TransactionTemp-late进行编程式事务管理 394
20.1.3 编程创建基于Savepoint的嵌套事务 396
20.2 声明式事务管理 397
20.2.1 引子 397
20.2.2 XML元数据驱动的声明式事务 399
20.2.3 注解元数据驱动的声明式事务 410
20.3 小结 413
第21章 Spring事务管理之扩展篇 414
21.1 理解并活用ThreadLocal 414
21.1.1 理解ThreadLocal的存在背景 414
21.1.2 理解ThreadLocal的实现 415
21.1.3 ThreadLocal的应用场景 416
21.1.4 使用ThreadLocal管理多数据源切换的条件 417
21.2 谈Strategy模式在开发过程中的应用 420
21.3 Spring与JTA背后的奥秘 423
21.4 小结 427
第六部分 Spring的Web MVC框架
第22章 迈向Spring MVC的旅程 430
22.1 Servlet独行天下的时代 430
22.2 繁盛一时的JSP时代 433
22.3 Servlet与JSP的联盟 436
22.4 数英雄人物，还看今朝 438
22.5 小结 440
第23章 Spring MVC初体验 441
23.1 鸟瞰Spring MVC 442
23.2 实践出真知 446
23.2.1 Spring MVC应用的物理结构 447
23.2.2 按部就班地开始工作 451
23.3 小结 459
第24章 近距离接触Spring MVC主要角色 460
24.1 忙碌的协调人HandlerMapping 460
24.1.1 可用的HandlerMapping 461
24.1.2 HandlerMapping执行序列(Chain Of HandlerMapping) 463
24.2 我们的亲密伙伴Controller 464
24.2.1 AbstractController 465
24.2.2 MultiActionController 468
24.2.3 SimpleFormController 476
24.2.4 AbstractWizard-FormController 496
24.2.5 其他可用的Controller实现 503
24.3 ModelAndView 505
24.3.1 ModelAndView中的视图信息 505
24.3.2 ModelAndView中的模型数据 506
24.4 视图定位器ViewResolver 506
24.4.1 可用的ViewResolver实现类 507
24.4.2 ViewResolver查找序列(Chain Of ViewResolver) 511
24.5 各司其职的View 511
24.5.1 View实现原理回顾 512
24.5.2 可用的View实现类 515
24.5.3 自定义View实现 521
24.6 小结 523
第25章 认识更多Spring MVC家族成员 524
25.1 文件上传与MultipartResolver 525
25.1.1 使用MultipartResolver进行文件上传的简单分析 526
25.1.2 文件上传实践 527
25.2 Handler与HandlerAdaptor 530
25.2.1 问题的起源 530
25.2.2 深入了解Handler 531
25.2.3 近看HandlerAdaptor的奥秘 533
25.2.4 告知Handler与Handler-Adaptor的存在 535
25.3 框架内处理流程拦截与Handler-Interceptor 536
25.3.1 可用的Handler-Interceptor实现 537
25.3.2 自定义实现Handler-Interceptor 538
25.3.3 HandlerInterceptor寻根 540
25.3.4 HandlerInterceptor之外的选择 541
25.4 框架内的异常处理与Handler-ExceptionResolver 544
25.5 国际化视图与LocalResolver 548
25.5.1 可用的LocaleResolver 549
25.5.2 LocaleResolver的足迹 550
25.5.3 Locale的变更与LocaleChangeHandler 551
25.6 主题(Theme)与ThemeResolver 552
25.6.1 提供主题资源的ThemeSource 552
25.6.2 管理主题的ThemeResolver 554
25.6.3 切换主题的ThemeChange-Interceptor 555
25.7 小结 556
第26章 Spring MVC中基于注解的Controller 557
26.1 初识基于注解的Controller 557
26.2 基于注解的Controller原型分析 558
26.2.1 自定义用于基于注解的Contro-ller的HandlerMapping 558
26.2.2 自定义用于基于注解的Contro-ller的HandlerAdaptor 560
26.3 近看基于注解的Controller 563
26.3.1 声明基于注解的Controller 563
26.3.2 请求参数到方法参数的绑定 569
26.3.3 使用@ModelAttribute访问模型数据 572
26.3.4 通过@SessionAttribute管理Session数据 574
26.4 小结 576
第27章 Spring MVC之扩展篇 577
27.1 Spring MVC也Convention Over Configuration 577
27.1.1 Convention Over Configuration简介 577
27.1.2 Spring MVC中的Convention Over Configuration 578
27.2 Spring 3.0展望 581
27.3 小结 582
第七部分 Spring框架对J2EE服务的集成和支持
第28章 Spring框架内的JNDI支持 584
28.1 JNDI简单回顾 584
28.2 Spring框架内JNDI访问的基石——JndiTemplate 585
28.3 JNDI对象的依赖注入——JndiObjectFactoryBean 587
28.4 小结 588
第29章 Spring框架对JMS的集成 589
29.1 说说JMS的身世 589
29.2 使用JMS API进行应用开发的传统套路 590
29.3 Spring改进后的JMS实战格斗术 592
29.3.1 消息发送和同步接收 592
29.3.2 异步消息接收 601
29.3.3 JMS相关异常处理 607
29.3.4 框架内的事务管理支持 608
29.4 小结 609
第30章 使用Spring发送E-mail 610
30.1 思甜前，先忆苦 610
30.2 Spring的E-mail抽象层分析 612
30.2.1 直接创建邮件消息并发送 614
30.2.2 使用MimeMessage-Preparator发送邮件 615
30.3 Spring的E-mail支持在实际开发中的应用 616
30.4 小结 622
第31章 Spring中的任务调度和线程池支持 623
31.1 Spring与Quartz 623
31.1.1 初识Quartz 623
31.1.2 融入Spring大家庭的Quartz 626
31.2 Spring对JDK Timer的集成 631
31.2.1 JDK Timer小记 631
31.2.2 Spring集成后的JDK Timer 632
31.3 Executor的孪生兄弟TaskExecutor 634
31.3.1 可用的TaskExecutor 635
31.3.2 TaskExecutor使用实例 637
31.4 小结 639
第32章 Spring框架对J2EE服务的集成之扩展篇 640
32.1 MailMonitor的延伸 640
32.2 Spring 3.0展望 642
32.3 小结 642
第33章 Spring远程方案 643
33.1 从“对面交谈”到“千里传声” 643
33.2 Spring Remoting架构分析 645
33.2.1 Spring Remoting之远程访问异常体系 645
33.2.2 统一风格的远程服务公开与访问方式 646
33.3 Spring Remoting提供的远程服务支持 648
33.3.1 基于RMI的Remoting方案 648
33.3.2 基于HTTP的轻量级Remoting方案 651
33.3.3 基于Web服务的远程方案 655
33.3.4 基于JMS的远程方案 658
33.4 扩展Spring Remoting 660
33.5 Spring Remoting之扩展篇 663
33.5.1 拉开JMX演出的序幕 663
33.5.2 Spring 3.0展望 664
参考文献 665
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring揭秘
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring技术内幕（第2版）
前言
第1章　spring的设计理念和整体架构 / 1
1.1　spring的各个子项目 / 2
1.2　spring的设计目标 / 5
1.3　spring的整体架构 / 7
1.4　spring的应用场景 / 10
1.5　小结 / 12
第一部分　spring核心实现篇
第2章　spring framework的核心：ioc容器的实现 / 16
2.1　spring ioc容器概述 / 17
2.1.1　ioc容器和依赖反转模式 / 17
2.1.2　spring ioc的应用场景 / 18
2.2　ioc容器系列的设计与实现：beanfactory和applicationcontext / 19
2.2.1　spring的ioc容器系列 / 19
2.2.2　spring ioc容器的设计 / 21
2.3　ic容器的初始化过程 / 28
2.3.1　beandefinition的resource定位 / 29
2.3.2　beandefinition的载入和解析 / 37
2.3.3　beandefinition在ioc容器中的注册 / 52
.2.4　ioc容器的依赖注入 / 54
2.5　容器其他相关特性的设计与实现 / 75
2.5.1　applicationcontext和bean的初始化及销毁 / 75
2.5.2　lazy-init属性和预实例化 / 81
2.5.3　factorybean的实现 / 82
2.5.4　beanpostprocessor的实现 / 85
2.5.5　autowiring（自动依赖装配）的实现 / 88
2.5.6　bean的依赖检查 / 90
2.5.7　bean对ioc容器的感知 / 91
2.6　小结 / 92
第3章　spring aop的实现 / 94
3.1　spring aop概述 / 95
3.1.1　aop概念回顾 / 95
3.1.2　advice通知 / 98
3.1.3　pointcut切点 / 102
3.1.4　advisor通知器 / 105
3.2　spring aop的设计与实现 / 106
3.2.1　jvm的动态代理特性 / 106
3.2.2　spring aop的设计分析 / 108
3.2.3　spring aop的应用场景 / 108
3.3　建立aopproxy代理对象 / 109
3.3.1　设计原理 / 109
3.3.2　配置proxyfactorybean / 110
3.3.3　proxyfactorybean生成aopproxy代理对象 / 111
3.3.4　jdk生成aopproxy代理对象 / 116
3.3.5　cglib生成aopproxy代理对象 / 117
3.4　spring aop拦截器调用的实现 / 119
3.4.1　设计原理 / 119
3.4.2　jdkdynamicaopproxy的invoke拦截 / 120
3.4.3　cglib2aopproxy的intercept拦截 / 121
3.4.4　目标对象方法的调用 / 122
3.4.5　aop拦截器链的调用 / 123
3.4.6　配置通知器 / 124
3.4.7　advice通知的实现 / 129
3.4.8　proxyfactory实现aop / 136
3.5　spring aop的高级特性 / 138
3.6　小结 / 140
第二部分　spring组件实现篇
第4章　spring mvc与web环境 / 145
4.1　spring mvc概述 / 146
4.2　web环境中的spring mvc / 148
4.3　上下文在web容器中的启动 / 149
4.3.1　ioc容器启动的基本过程 / 149
4.3.2　web容器中的上下文设计 / 151
4.3.3　contextloader的设计与实现 / 154
4.4　spring mvc的设计与实现 / 158
4.4.1　spring mvc的应用场景 / 158
4.4.2　spring mvc设计概览 / 158
4.4.3　dispatcherservlet的启动和初始化 / 160
4.4.4　mvc处理http分发请求 / 166
4.5　spring mvc视图的呈现 / 178
4.5.1　dispatcherservlet视图呈现的设计 / 178
4.5.2　jsp视图的实现 / 182
4.5.3　excelview的实现 / 185
4.5.4　pdf视图的实现 / 187
4.6　小结 / 189
第5章　数据库操作组件的实现 / 191
5.1　spring jdbc的设计与实现 / 192
5.1.1　应用场景 / 192
5.1.2　设计概要 / 192
5.2　spring jdbc中模板类的设计与实现 / 193
5.2.1　设计原理 / 193
5.2.2　jdbctemplate的基本使用 / 193
5.2.3　jdbctemplate的execute实现 / 194
5.2.4　jdbctemplate的query实现 / 196
5.2.5　使用数据库connection / 197
5.3　spring jdbc中rdbms操作对象的实现 / 199
5.3.1　sqlquery的实现 / 200
5.3.2　sqlupdate的实现 / 204
5.3.3　sqlfunction / 206
5.4　spring orm的设计与实现 / 208
5.4.1　应用场景 / 208
5.4.2　设计概要 / 208
5.5　spring驱动hibernate的设计与实现 / 209
5.5.1　设计原理 / 210
5.5.2　hibernate的sessionfactory / 210
5.5.3　hibernatetemplate的实现 / 215
5.5.4　session的管理 / 219
5.6　spring驱动ibatis的设计与实现 / 222
5.6.1　设计原理 / 222
5.6.2　创建sqlmapclient / 222
5.6.3　sqlmapclienttemplate的实现 / 224
5.7　小结 / 227
第6章　spring事务处理的实现 / 228
6.1　spring与事务处理 / 229
6.2　spring事务处理的设计概览 / 229
6.3　spring事务处理的应用场景 / 230
6.4　spring声明式事务处理 / 231
6.4.1　设计原理与基本过程 / 231
6.4.2　实现分析 / 231
6.5　spring事务处理的设计与实现 / 241
6.5.1　spring事务处理的编程式使用 / 241
6.5.2　事务的创建 / 242
6.5.3　事务的挂起 / 249
6.5.4　事务的提交 / 251
6.5.5　事务的回滚 / 253
6.6　spring事务处理器的设计与实现 / 255
6.6.1　spring事务处理的应用场景 / 255
6.6.2　datasourcetransactionmanager的实现 / 256
6.6.3　hibernatetransactionmanager的实现 / 259
6.7　小结 / 265
第7章　spring远端调用的实现 / 267
7.1　spring远端调用的应用场景 / 268
7.2　spring远端调用的设计概览 / 268
7.3　spring远端调用的实现 / 271
7.3.1　spring http调用器的实现 / 271
7.3.2　spring hession/burlap的实现原理 / 282
7.3.3　spring rmi的实现 / 295
7.4　小结 / 302
第三部分　spring应用实现篇
第8章　安全框架acegi的设计与实现 / 307
8.1　spring acegi安全框架概述 / 308
8.1.1　概述 / 308
8.1.2　设计原理与基本实现过程 / 308
8.1.3　acegi的bean配置 / 309
8.2　配置spring acegi / 310
8.3　acegi的web过滤器实现 / 313
8.4　acegi验证器的实现 / 315
8.4.1　authenticationmanager的authenticate / 315
8.4.2　daoauthenticationprovider的实现 / 318
8.4.3　读取数据库用户信息 / 320
8.4.4　完成用户信息的对比验证 / 323
8.5　acegi授权器的实现 / 324
8.5.1　与web环境的接口filtersecurityinterceptor / 324
8.5.2　授权器的实现 / 327
8.5.3　投票器的实现 / 329
8.6　小结 / 330
第9章　spring dm模块的设计与实现 / 332
9.1　spring dm模块的应用场景 / 333
9.2　spring dm的应用过程 / 334
9.3　spring dm设计与实现 / 338
9.4　小结 / 348
第10章　spring flex的设计与实现 / 350
10.1　spring flex模块的应用场景 / 351
10.2　spring flex的应用过程 / 353
10.3　spring flex的设计与实现 / 355
10.4　小结 / 362
附录a　spring项目的源代码环境 / 363
附录b　构建spring项目的发布包 / 378
附录c　使用spring ide / 381
附录d　spring pet clinic应用实例 / 385
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring技术内幕（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot实战
第1章　入门　　1
1.1　Spring风云再起　　1
1.1.1　重新认识Spring　　2
1.1.2　Spring Boot精要　　3
1.1.3　Spring Boot不是什么　　6
1.2　Spring Boot入门　　6
1.2.1　安装Spring Boot CLI　　7
1.2.2　使用Spring Initializr初始化Spring Boot项目　　10
1.3　小结　　18
第2章　开发第一个应用程序　　19
2.1　运用Spring Boot　　19
2.1.1　查看初始化的Spring Boot新项目　　21
2.1.2　Spring Boot项目构建过程解析　　24
2.2　使用起步依赖　　27
2.2.1　指定基于功能的依赖　　28
2.2.2　覆盖起步依赖引入的传递依赖　　29
2.3　使用自动配置　　30
2.3.1　专注于应用程序功能　　31
2.3.2　运行应用程序　　36
2.3.3　刚刚发生了什么　　38
2.4　小结　　41
第3章　自定义配置　　42
3.1　覆盖Spring Boot自动配置　　42
3.1.1　保护应用程序　　43
3.1.2　创建自定义的安全配置　　44
3.1.3　掀开自动配置的神秘面纱　　48
3.2　通过属性文件外置配置　　49
3.2.1　自动配置微调　　50
3.2.2　应用程序Bean的配置外置　　55
3.2.3　使用Profile进行配置　　59
3.3　定制应用程序错误页面　　62
3.4　小结　　64
第4章　测试　　66
4.1　集成测试自动配置　　66
4.2　测试Web应用程序　　68
4.2.1　模拟Spring MVC　　69
4.2.2　测试Web安全　　72
4.3　测试运行中的应用程序　　74
4.3.1　用随机端口启动服务器　　75
4.3.2　使用Selenium测试HTML页面　　76
4.4　小结　　78
第5章　Groovy与Spring Boot CLI　　80
5.1　开发Spring Boot CLI应用程序　　80
5.1.1　设置CLI项目　　81
5.1.2　通过Groovy消除代码噪声　　81
5.1.3　发生了什么　　85
5.2　获取依赖　　86
5.2.1　覆盖默认依赖版本　　87
5.2.2　添加依赖仓库　　88
5.3　用CLI运行测试　　89
5.4　创建可部署的产物　　91
5.5　小结　　91
第6章　在Spring Boot中使用Grails　　93
6.1　使用GORM进行数据持久化　　93
6.2　使用Groovy Server Pages定义视图　　98
6.3　结合Spring Boot与Grails 3　　100
6.3.1　创建新的Grails项目　　100
6.3.2　定义领域模型　　103
6.3.3　开发Grails控制器　　104
6.3.4　创建视图　　105
6.4　小结　　107
第7章　深入Actuator　　108
7.1　揭秘Actuator的端点　　108
7.1.1　查看配置明细　　109
7.1.2　运行时度量　　115
7.1.3　关闭应用程序　　121
7.1.4　获取应用信息　　121
7.2　连接Actuator的远程shell　　122
7.2.1　查看autoconfig报告　　123
7.2.2　列出应用程序的Bean　　124
7.2.3　查看应用程序的度量信息　　124
7.2.4　调用Actuator端点　　125
7.3　通过JMX监控应用程序　　126
7.4　定制Actuator　　128
7.4.1　修改端点ID　　128
7.4.2　启用和禁用端点　　129
7.4.3　添加自定义度量信息　　129
7.4.4　创建自定义跟踪仓库　　132
7.4.5　插入自定义健康指示器　　134
7.5　保护Actuator端点　　136
7.6　小结　　138
第8章　部署Spring Boot应用程序　　139
8.1　衡量多种部署方式　　139
8.2　部署到应用服务器　　140
8.2.1　构建WAR文件　　141
8.2.2　创建生产Profile　　142
8.2.3　开启数据库迁移　　145
8.3　推上云端　　150
8.3.1　部署到Cloud Foundry　　150
8.3.2　部署到Heroku　　153
8.4　小结　　155
附录A　Spring Boot开发者工具　　157
附录B　Spring Boot起步依赖　　163
附录C　配置属性　　169
附录D　Spring Boot依赖　　202
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaEE开发的颠覆者
第一部分 点睛Spring 4.x
第1 章 Spring 基础 2
1.1 Spring 概述  2
1.1.1 Spring 的简史  2
1.1.2 Spring 概述  3
1.2 Spring 项目快速搭建 5
1.2.1 Maven 简介  6
1.2.2 Maven 安装  6
1.2.3 Maven 的pom.xml 7
1.2.4 Spring 项目的搭建  9
1.3 Spring 基础配置 17
1.3.1 依赖注入  18
1.3.2 Java 配置  21
1.3.3 AOP 24
第2 章 Spring 常用配置 30
2.1 Bean 的Scope  30
2.1.1 点睛 30
2.1.2 示例 31
2.2 Spring EL 和资源调用. 33
2.2.1 点睛 33
2.2.2 示例 33
2.3 Bean 的初始化和销毁 37
2.3.1 点睛 37
2.3.2 演示 38
2.4 Profile  40
2.4.1 点睛 40
2.4.2 演示 41
2.5 事件（Application Event）  44
2.5.1 点睛 44
2.5.2 示例 44
第3 章 Spring 高级话题 48
3.1 Spring Aware 48
3.1.1 点睛 48
3.1.2 示例 49
3.2 多线程  51
3.2.1 点睛 51
3.2.2 示例 51
3.3 计划任务 54
3.3.1 点睛 54
3.3.2 示例 54
3.4 条件注解@Conditional  56
3.4.1 点睛 56
3.4.2 示例 57
3.5 组合注解与元注解  60
3.5.1 点睛 60
3.5.2 示例 60
3.6 @Enable*注解的工作原理  63
3.6.1 第一类：直接导入配置类 63
3.6.2 第二类：依据条件选择配置类  64
3.6.3 第三类：动态注册Bean 65
3.7 测试  66
3.7.1 点睛 66
3.7.2 示例 67
第二部分 点睛Spring MVC 4.x
第4 章 Spring MVC 基础  72
4.1 Spring MVC 概述  73
4.2 Spring MVC 项目快速搭建 74
4.2.1 点睛 74
4.2.2 示例 74
4.3 Spring MVC 的常用注解  82
4.3.1 点睛 82
4.3.2 示例 83
4.4 Spring MVC 基本配置  87
4.4.1 静态资源映射  88
4.4.2 拦截器配置 89
4.4.3 @ControllerAdvice 91
4.4.4 其他配置  94
4.5 Spring MVC 的高级配置  98
4.5.1 文件上传配置  98
4.5.2 自定义HttpMessageConverter  101
4.5.3 服务器端推送技术  106
4.6 Spring MVC 的测试  113
4.6.1 点睛  113
4.6.2 示例  114
第三部分 实战Spring Boot
第5 章 Spring Boot 基础 122
5.1 Spring Boot 概述  122
5.1.1 什么是Spring Boot  122
5.1.2 Spring Boot 核心功能 122
5.1.3 Spring Boot 的优缺点 124
5.1.4 关于本书的Spring Boot 版本  124
5.2 Spring Boot 快速搭建  124
5.2.1 http://start.spring.io  124
5.2.2 Spring Tool Suite  127
5.2.3 IntelliJ IDEA  129
5.2.4 Spring Boot CLI 132
5.2.5 Maven 手工构建  134
5.2.6 简单演示  136
第6 章 Spring Boot 核心 138
6.1 基本配置  138
6.1.1 入口类和@SpringBootApplication 138
6.1.2 关闭特定的自动配置 139
6.1.3 定制Banner 139
6.1.4 Spring Boot 的配置文件  140
6.1.5 starter pom 141
6.1.6 使用xml 配置 143
6.2 外部配置  143
6.2.1 命令行参数配置  143
6.2.2 常规属性配置 144
6.2.3 类型安全的配置（基于properties）  145
6.3 日志配置  148
6.4 Profile 配置 148
实战  148
6.5 Spring Boot 运行原理  150
6.5.1 运作原理  153
6.5.2 核心注解  154
6.5.3 实例分析  157
6.5.4 实战  160
第7 章 Spring Boot 的Web 开发  170
7.1 Spring Boot 的Web 开发支持 170
7.2 Thymeleaf 模板引擎  171
7.2.1 Thymeleaf 基础知识  171
7.2.2 与Spring MVC 集成  174
7.2.3 Spring Boot 的Thymeleaf 支持  175
7.2.4 实战  177
7.3 Web 相关配置  182
7.3.1 Spring Boot 提供的自动配置 182
7.3.2 接管Spring Boot 的Web 配置  185
7.3.3 注册Servlet、Filter、Listener  186
7.4 Tomcat 配置  187
7.4.1 配置Tomcat 187
7.4.2 代码配置Tomcat  188
7.4.3 替换Tomcat 190
7.4.4 SSL 配置  191
7.5 Favicon 配置  196
7.5.1 默认的Favicon  196
7.5.2 关闭Favicon  196
7.5.3 设置自己的Favicon  197
7.6 WebSocket  197
7.6.1 什么是WebSocket  197
7.6.2 Spring Boot 提供的自动配置 197
7.6.3 实战  198
7.7 基于Bootstrap 和AngularJS 的现代Web 应用 212
7.7.1 Bootstrap  213
7.7.2 AngularJS  216
7.7.3 实战  222
第8 章 Spring Boot 的数据访问  233
8.1 引入Docker  237
8.1.1 Docker 的安装  238
8.1.2 Docker 常用命令及参数  242
8.1.3 下载本书所需的Docker 镜像  247
8.1.4 异常处理  247
8.2 Spring Data JPA  248
8.2.1 点睛Spring Data JPA  248
8.2.2 Spring Boot 的支持  258
8.2.3 实战  260
8.3 Spring Data REST  284
8.3.1 点睛Spring Data REST 284
8.3.2 Spring Boot 的支持  285
8.3.3 实战  286
8.4 声名式事务 297
8.4.1 Spring 的事务机制  297
8.4.2 声名式事务  298
8.4.3 注解事务行为 299
8.4.4 类级别使用@Transactional 300
8.4.5 Spring Data JPA 的事务支持  300
8.4.6 Spring Boot 的事务支持  302
8.4.7 实战  303
8.5 数据缓存Cache  309
8.5.1 Spring 缓存支持  309
8.5.2 Spring Boot 的支持  310
8.5.3 实战  312
8.5.4 切换缓存技术 319
8.6 非关系型数据库NoSQL 320
8.6.1 MongoDB  320
8.6.2 Redis 329
第9 章 Spring Boot 企业级开发  340
9.1 安全控制Spring Security  340
9.1.1 Spring Security 快速入门 340
9.1.2 Spring Boot 的支持  347
9.1.3 实战  348
9.2 批处理Spring Batch  362
9.2.1 Spring Batch 快速入门  362
9.2.2 Spring Boot 的支持  370
9.2.3 实战  371
9.3 异步消息  385
9.3.1 企业级消息代理  386
9.3.2 Spring 的支持 386
9.3.3 Spring Boot 的支持  386
9.3.4 JMS 实战  387
9.3.5 AMQP 实战 391
9.4 系统集成Spring Integration  395
9.4.1 Spring Integration 快速入门  395
9.4.2 Message  395
9.4.3 Channel  395
9.4.4 Message EndPoint 398
9.4.5 Spring Integration Java DSL  400
9.4.6 实战  400
第10 章 Spring Boot 开发部署与测试  407
10.1 开发的热部署 407
10.1.1 模板热部署  407
10.1.2 Spring Loaded  407
10.1.3 JRebel  409
10.1.4 spring-boot-devtools  413
10.2 常规部署  413
10.2.1 jar 形式 413
10.2.2 war 形式  417
10.3 云部署——基于Docker 的部署 419
10.3.1 Dockerfile  419
10.3.2 安装Docker  421
10.3.3 项目目录及文件 421
10.3.4 编译镜像 423
10.3.5 运行  424
10.4 Spring Boot 的测试  424
10.4.1 新建Spring Boot 项目 425
10.4.2 业务代码 425
10.4.3 测试用例 427
10.4.4 执行测试 429
第11 章 应用监控  431
11.1 http 431
11.1.1 新建Spring Boot 项目 432
11.1.2 测试端点 432
11.1.3 定制端点 439
11.1.4 自定义端点  440
11.1.5 自定义HealthIndicator  444
11.2 JMX  447
11.3 SSH  449
11.3.1 新建Spring Boot 项目 449
11.3.2 运行  449
11.3.3 常用命令 451
11.3.4 定制登录用户  452
11.3.5 扩展命令 452
第12 章 分布式系统开发  456
12.1 微服务、原生云应用 456
12.2 Spring Cloud 快速入门  457
12.2.1 配置服务 457
12.2.2 服务发现 457
12.2.3 路由网关 457
12.2.4 负载均衡 457
12.2.5 断路器  458
12.3 实战  458
12.3.1 项目构建 458
12.3.2 服务发现——Discovery（Eureka Server）  459
12.3.3 配置——Config（Config Server）  461
12.3.4 服务模块——Person 服务  463
12.3.5 服务模块——Some 服务  466
12.3.6 界面模块——UI（Ribbon,Feign） 468
12.3.7 断路器监控——Monitor（DashBoard） 473
12.3.8 运行  474
12.4 基于Docker 部署 478
12.4.1 Dockerfile 编写  478
12.4.2 Docker Compose 480
12.4.3 Docker-compose.yml 编写 481
12.4.4 运行  483
附录A 485
A.1 基于JHipster 的代码生成 485
A.2 常用应用属性配置列表 488
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaEE开发的颠覆者
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring技术内幕
本书赞誉
前言
致谢
第1章准备源代码环境 1
1.1安装JDK 1
1.2安装Eclipse 1
1.3安装辅助工具 2
1.4获取Spring源代码 8
1.5Spring源代码的组织结构 10
1.6小结 12
第一部分Spring核心实现篇
第2章Spring Framework的核心：IoC容器的实现 16
2.1Spring IoC容器概述 16
2.1.1IoC容器和依赖反转模式 16
2.1.2Spring的IoC容器系列 18
2.2IoC容器系列的实现：BeanFactory 和ApplicationContext 20
2.2.1BeanFactory对IoC容器的功能定义 20
2.2.2IoC容器XmlBeanFactory的工作原理 22
2.2.3ApplicationContext的特点 24
2.3IoC容器的初始化 25
2.3.1BeanDefinition的Resource定位 26
2.3.2BeanDefinition的载入和解析 33
2.3.3BeanDefinition在IoC容器中的注册 47
2.4IoC容器的依赖注入 49
2.5容器其他相关特性的实现 70
2.5.1lazy-init属性和预实例化 70
2.5.2FactoryBean的实现 73
2.5.3BeanPostProcessor的实现 75
2.5.4autowiring的实现原理 78
2.6小结 80
第3章Spring AOP的实现 82
3.1Spring AOP概述 82
3.1.1AOP概念回顾 82
3.1.2Advice通知 84
3.1.3Pointcut切点 88
3.1.4Advisor通知器 90
3.2建立AopProxy代理对象 92
3.2.1配置ProxyFactoryBean 92
3.2.2ProxyFactoryBean生成AopProxy 94
3.2.3JDK生成AopProxy代理对象 98
3.2.4CGLIB生成AopProxy代理对象 99
3.3Spring AOP拦截器调用的实现 101
3.3.1JdkDynamicAopProxy的invoke拦截 101
3.3.2Cglib2AopProxy的intercept拦截 103
3.3.3目标对象方法的调用 105
3.3.4AOP拦截器链的调用 105
3.3.5配置通知器 107
3.3.6Advice通知的实现 112
3.3.7ProxyFactory实现AOP 118
3.4Spring AOP的高级特性 120
3.5小结 121
第二部分Spring组件实现篇
第4章Spring MVC与Web环境.. 127
4.1概述 127
4.2Web环境中的Spring MVC 128
4.3IoC容器在Spring MVC中的启动 130
4.3.1Web容器中的上下文 130
4.3.2ContextLoader建立Web环境的根上下文 132
4.4Spring Web MVC的启动 136
4.4.1DispacherServlet概述 136
4.4.2DispacherServlet的启动和初始化 137
4.5Spring MVC的实现 141
4.5.1DispatcherSevlet的MVC初始化 141
4.5.2HandlerMapping的配置 143
4.5.3使用HandlerMapping完成请求的映射处理 148
4.5.4Spring MVC对HTTP请求的分发处理 150
4.6Spring MVC视图的呈现 155
4.6.1DispatcherServlet视图呈现概述 155
4.6.2JSP视图的实现 157
4.6.3ExcelView的实现 160
4.6.4PDF视图的实现 163
4.7小结 165
第5章数据库操作组件的实现 167
5.1Spring JDBC和Spring ORM概述 167
5.2Spring JDBC模板类的实现 167
5.2.1JdbcTeamplate的基本使用 167
5.2.2JdbcTemplate的execute实现 168
5.2.3JdbcTemplate的query实现 170
5.2.4使用数据库Connection 171
5.3Spring JDBC中RDBMS操作对象的实现 172
5.3.1SqlQuery的实现 173
5.3.2SqlUpdate的实现 177
5.3.3SqlFunction 178
5.4Spring驱动Hibernate的实现 179
5.4.1配置Hibernate的SessionFactory 180
5.4.2HibernateTemplate的实现 185
5.4.3Session的管理 187
5.5Spring驱动iBatis的实现 190
5.5.1创建SqlMapClient 190
5.5.2SqlMapClientTemplate的实现 192
5.6小结 194
第6章Spring事务处理的实现 196
6.1Spring与事务处理 196
6.2声明式事务处理的基本过程 196
6.2.1事务处理拦截器的配置 197
6.2.2事务处理配置的读入 200
6.3事务处理拦截器的实现 203
6.4事务处理的实现 206
6.4.1事务处理的编程式使用 206
6.4.2事务的创建 207
6.4.3事务的挂起 214
6.4.4事务的提交 215
6.4.5事务的回滚 218
6.5具体事务处理器的实现 219
6.5.1DataSourceTransactionManager的实现 219
6.5.2HibernateTransactionManager的实现 222
6.6小结 227
第7章Spring远端调用的 实现 230
7.1Spring远端调用概述 230
7.2Spring HTTP 调用器的实现原理 232
7.2.1配置HTTP调用器客户端 232
7.2.2HTTP调用器客户端的实现 232
7.2.3配置HTTP调用器远端服务器端 237
7.2.4HTTP调用器服务器端的实现 237
7.3Spring Hession/Burlap的实现 原理 241
7.3.1Hessian/Burlap客户端的配置 241
7.3.2Hessian客户端的实现 242
7.3.3Burlap客户端的实现 244
7.3.4Hessian/Burlap服务器端的配置 247
7.3.5Hessian服务器端的实现 247
7.3.6Burlap服务器端的实现 250
7.4Spring RMI的实现 252
7.4.1Spring RMI客户端的配置 252
7.4.2Spring RMI客户端的实现 253
7.4.3Spring RMI服务器端的配置 256
7.4.4Spring RMI服务器端的实现 257
7.5小结 259
第8章安全框架ACEGI的 实现 260
8.1Spring ACEGI安全框架概述 260
8.1.1概述 260
8.1.2使用Spring IDE 261
8.1.3ACEGI的Bean配置 263
8.2配置Spring ACEGI 264
8.3ACEGI的Web过滤器实现 267
8.4ACEGI验证器的实现 269
8.4.1AuthenticationManager的authenticate 269
8.4.2DaoAuthenticationProvider的实现 271
8.4.3读取数据库用户信息 273
8.4.4完成用户信息的对比验证 276
8.5ACEGI授权器的实现 277
8.5.1与Web环境的接口FilterSecurityInterceptor 277
8.5.2授权器的实现 280
8.5.3投票器的实现 282
8.6小结 283
第三部分Spring应用篇
第9章Spring petclinic应用实例 287
9.1petclinic概述 287
9.2部署环境及数据库 289
9.3petclinic的Bean配置 290
9.4petclinic的Web页面实现 291
9.5petclinic的领域对象实现 293
9.6petclinic数据库操作的实现 294
9.6.1使用JDBC的数据库操作 294
9.6.2使用Hibernate的数据库操作 295
9.6.3使用JPA的数据库操作 297
9.7小结 298
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring技术内幕
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
中文版序
引言
作者的话
致谢
一 明天的寓言
二 忍耐的义务
三 死神的特效药
四 地表水和地下海
五 土壤的王国
六 地球的绿色斗篷
七 不必要的大破坏
八 再也没有鸟儿歌唱
九 死亡的河流
一○ 无人幸免的天灾
一一 超越波吉亚家族的梦想
一二 人类的代价
一三 通过一扇狭小的窗户
一四 每四个中有一个
一五 大自然在反抗
一六 崩溃声隆隆
一七 另一条道路
附录
参考文献
译者后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务实战
第1章　基础知识	1
什么是微服务架构	1
-- 与单体系统的区别	1
-- 如何实施微服务	2
为什么选择Spring Cloud	6
Spring Cloud简介	7
版本说明	8
第2章　微服务构建：Spring Boot	11
框架简介	12
快速入门	13
-- 项目构建与解析	13
-- 实现RESTful API	17
配置详解	20
-- 配置文件	20
-- 自定义参数	22
-- 参数引用	22
-- 使用随机数	23
-- 命令行参数	23
-- 多环境配置	24
-- 加载顺序	25
监控与管理	26
-- 初识actuator	27
-- 原生端点	28
小结	38
第3章　服务治理：Spring Cloud Eureka	39
服务治理	39
-- Netflix Eureka	40
--搭建服务注册中心	41
--注册服务提供者	43
--高可用注册中心	46
--服务发现与消费	48
Eureka详解	51
--基础架构	52
--服务治理机制	52
--源码分析	56
配置详解	65
--服务注册类配置	65
--服务实例类配置	67
跨平台支持	71
第4章　客户端负载均衡：Spring Cloud Ribbon	73
客户端负载均衡	73
RestTemplate详解	75
-- GET请求	75
-- POST请求	77
-- PUT请求	79
-- DELETE请求	79
源码分析	80
-- 负载均衡器	91
-- 负载均衡策略	109
配置详解	123
--自动化配置	124
-- Camden版本对RibbonClient配置的优化	125
-- 参数配置	127
-- 与Eureka结合	127
重试机制	128
第5章　服务容错保护：Spring Cloud Hystrix	130
快速入门	131
原理分析	135
-- 工作流程	135
-- 断路器原理	144
-- 依赖隔离	148
使用详解	151
-- 创建请求命令	151
-- 定义服务降级	154
-- 异常处理	157
-- 命令名称、分组以及线程池划分	158
-- 请求缓存	159
-- 请求合并	166
属性详解	172
-- Command属性	174
-- collapser属性	184
-- threadPool属性	185
Hystrix仪表盘	187
Turbine集群监控	192
-- 构建监控聚合服务	192
-- 与消息代理结合	196
第6章　声明式服务调用：Spring Cloud Feign	199
快速入门	200
参数绑定	202
继承特性	205
Ribbon配置	209
全局配置	209
指定服务配置	209
重试机制	210
Hystrix配置	211
全局配置	211
禁用Hystrix	211
指定命令配置	212
服务降级配置	212
其他配置	214
第7章　API网关服务：Spring Cloud Zuul	217
快速入门	219
-- 构建网关	220
-- 请求路由	221
-- 请求过滤	223
路由详解	226
-- 传统路由配置	226
-- 服务路由配置	228
-- 服务路由的默认规则	229
-- 自定义路由映射规则	229
-- 路径匹配	230
-- 路由前缀	233
-- 本地跳转	234
--  Cookie与头信息	235
-- Hystrix和Ribbon支持	236
过滤器详解	238
-- 过滤器	238
-- 请求生命周期	239
-- 核心过滤器	240
-- 异常处理	244
-- 禁用过滤器	256
动态加载	257
-- 动态路由	257
-- 动态过滤器	261
第8章　分布式配置中心：Spring Cloud Config	267
快速入门	267
-- 构建配置中心	268
-- 配置规则详解	269
-- 客户端配置映射	272
服务端详解	274
-- 基础架构	274
-- Git配置仓库	276
-- SVN配置仓库	279
-- 本地仓库	279
-- 本地文件系统	279
-- 健康监测	280
-- 属性覆盖	281
-- 安全保护	281
-- 加密解密	282
-- 高可用配置	286
客户端详解	286
--  URI指定配置中心	287
-- 服务化配置中心	287
-- 失败快速响应与重试	290
-- 获取远程配置	292
-- 动态刷新配置	293
第9章　消息总线：Spring Cloud Bus	295
消息代理	295
RabbitMQ实现消息总线	296
-- 基本概念	297
-- 安装与使用	298
-- 快速入门	302
-- 整合Spring Cloud Bus	306
-- 原理分析	307
-- 指定刷新范围	308
-- 架构优化	309
-- RabbitMQ配置	310
Kafka实现消息总线	312
-- Kafka简介	312
-- 快速入门	313
--整合Spring Cloud Bus	315
-- Kafka配置	318
深入理解	318
-- 源码分析	320
-- 其他消息代理的支持	342
第10章　消息驱动的微服务：Spring Cloud Stream	344
快速入门	344
核心概念	349
-- 绑定器	350
-- 发布-订阅模式	351
-- 消费组	353
-- 消息分区	354
使用详解	355
-- 开启绑定功能	355
-- 绑定消息通道	356
-- 消息生产与消费	360
-- 响应式编程	366
-- 消费组与消息分区	368
-- 消息类型	370
绑定器详解	373
-- 绑定器SPI	373
-- 自动化配置	374
-- 多绑定器配置	374
--  RabbitMQ与Kafka绑定器	376
配置详解	376
-- 基础配置	377
-- 绑定通道配置	377
-- 绑定器配置	379
第11章　分布式服务跟踪：Spring Cloud Sleuth	386
快速入门	386
-- 准备工作	386
-- 实现跟踪	389
跟踪原理	390
抽样收集	392
与Logstash整合	394
与Zipkin整合	397
--  HTTP收集	398
-- 消息中间件收集	402
-- 收集原理	404
-- 数据存储	414
--  API接口	417
附录A　Starter POMs	419
后记	421
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring源码深度解析
第一部分　核心实现
第1章　Spring整体架构和环境搭建　2
1.1　Spring的整体架构　2
1.2　环境搭建　4
1.2.1　安装GitHub　4
1.2.2　安装Gradle　5
1.2.3　下载Spring　6
第2章　容器的基本实现　10
2.1　容器基本用法　10
2.2　功能分析　11
2.3　工程搭建　12
2.4　Spring的结构组成　13
2.4.1　beans包的层级结构　13
2.4.2　核心类介绍　13
2.5　容器的基础XmlBeanFactory　17
2.5.1　配置文件封装　18
2.5.2　加载Bean　21
2.6　获取XML的验证模式　24
2.6.1　DTD与XSD区别　24
2.6.2　验证模式的读取　26
2.7　获取Document　28
2.7.1　EntityResolver用法　29
2.8　解析及注册BeanDefinitions　31
2.8.1　profile属性的使用　32
2.8.2　解析并注册BeanDefinition　33
第3章　默认标签的解析　35
3.1　bean标签的解析及注册　35
3.1.1　解析BeanDefinition　37
3.1.2　AbstractBeanDefinition属性　55
3.1.3　解析默认标签中的自定义标签元素　58
3.1.4　注册解析的BeanDefinition　60
3.1.5　通知监听器解析及注册完成　63
3.2　alias标签的解析　63
3.3　import标签的解析　65
3.4　嵌入式beans标签的解析　67
第4章　自定义标签的解析　68
4.1　自定义标签使用　69
4.2　自定义标签解析　71
4.2.1　获取标签的命名空间　72
4.2.2　提取自定义标签处理器　72
4.2.3　标签解析　74
第5章　bean的加载　78
5.1　FactoryBean的使用　83
5.2　缓存中获取单例bean　85
5.3　从bean的实例中获取对象　86
5.4　获取单例　90
5.5　准备创建bean　92
5.5.1　处理ovverride属性　93
5.5.2　实例化的前置处理　94
5.6　循环依赖　96
5.6.1　什么是循环依赖　96
5.6.2　Spring如何解决循环依赖　96
5.7　创建bean　100
5.7.1　创建bean的实例　103
5.7.2　记录创建bean的ObjectFactory　112
5.7.3　属性注入　115
5.7.4　初始化bean　124
5.7.5　注册DisposableBean　128
第6章　容器的功能扩展　129
6.1　设置配置路径　130
6.2　扩展功能　130
6.3　环境准备　132
6.4　加载BeanFactory　133
6.4.1　定制BeanFactory　135
6.4.2　加载BeanDefinition　136
6.5　功能扩展　137
6.5.1　增加SPEL语言的支持　138
6.5.2　增加属性注册编辑器　139
6.5.3　添加ApplicationContext AwareProcessor处理器　144
6.5.4　设置忽略依赖　146
6.5.5　注册依赖　146
6.6　BeanFactory的后处理　146
6.6.1　激活注册的BeanFactory PostProcessor　147
6.6.2　注册BeanPostProcessor　153
6.6.3　初始化消息资源　156
6.6.4　初始化ApplicationEvent Multicaster　159
6.6.5　注册监听器　161
6.7　初始化非延迟加载单例　162
6.8　finishRefresh　165
第7章　AOP　167
7.1　动态AOP使用示例　167
7.2　动态AOP自定义标签　169
7.2.1　注册AnnotationAwareAspectJ AutoProxyCreator　170
7.3　创建AOP代理　173
7.3.1　获取增强器　176
7.3.2　寻找匹配的增强器　186
7.3.3　创建代理　187
7.4　静态AOP使用示例　201
7.5　创建AOP静态代理　203
7.5.1　Instrumentation使用　203
7.5.2　自定义标签　207
7.5.3　织入　209
第二部分　企业应用
第8章　数据库连接JDBC　214
8.1　Spring连接数据库程序实现(JDBC)　215
8.2　save/update功能的实现　217
8.2.1　基础方法execute　219
8.2.2　Update中的回调函数　223
8.3　query功能的实现　225
8.4　queryForObject　229
第9章　整合MyBatis　231
9.1　MyBatis独立使用　231
9.2　Spring整合MyBatis　235
9.3　源码分析　237
9.3.1　sqlSessionFactory创建　237
9.3.2　MapperFactoryBean的创建　241
9.3.3　MapperScannerConfigurer　244
第10章　事务　254
10.1　JDBC方式下的事务使用 示例　254
10.2　事务自定义标签　257
10.2.1　注册InfrastructureAdvisor AutoProxyCreator　257
10.2.2　获取对应class/method的增强器　261
10.3　事务增强器　269
10.3.1　创建事务　271
10.3.2　回滚处理　281
10.3.3　事务提交　287
第11章　SpringMVC　291
11.1　SpringMVC快速体验　291
11.2　ContextLoaderListener　295
11.2.1　ServletContextListener的使用　295
11.2.2　Spring中的ContextLoader Listener　296
11.3　DispatcherServlet　300
11.3.1　servlet的使用　301
11.3.2　DispatcherServlet的初始化　302
11.3.3　WebApplicationContext的初始化　304
11.4　DispatcherServlet的逻辑处理　320
11.4.1　MultipartContent类型的request处理　326
11.4.2　根据request信息寻找对应的Handler　327
11.4.3　没找到对应的Handler的错误处理　331
11.4.4　根据当前Handler寻找对应的HandlerAdapter　331
11.4.5　缓存处理　332
11.4.6　HandlerInterceptor的处理　333
11.4.7　逻辑处理　334
11.4.8　异常视图的处理　334
11.4.9　根据视图跳转页面　335
第12章　远程服务　340
12.1　RMI　340
12.1.1　使用示例　340
12.1.2　服务端实现　342
12.1.3　客户端实现　350
12.2　HttpInvoker　355
12.2.1　使用示例　356
12.2.2　服务端实现　357
12.2.3　客户端实现　361
第13章　Spring消息　367
13.1　JMS的独立使用　367
13.2　Spring整合ActiveMQ　369
13.3　源码分析　371
13.3.1　JmsTemplate　372
13.3.2　监听器容器　376
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring源码深度解析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring实战（第3版）
第一部分 Spring的核心
第1章 Spring之旅 2
1.1 简化Java开发 3
1.1.1 激发POJO的潜能 4
1.1.2 依赖注入 5
1.1.3 应用切面 9
1.1.4 使用模板消除样板式代码 13
1.2 容纳你的Bean 15
1.2.1 与应用上下文共事 16
1.2.2 Bean的生命周期 17
1.3 俯瞰Spring风景线 19
1.3.1 Spring模块 19
1.3.2 Spring Portfolio 22
1.4 Spring新功能 25
1.4.1 Spring 2.5新特性 26
1.4.2 Spring 3.0新特性 26
1.4.3 Spring Portfollo新特性 27
1.5 小结 28
第2章 装配Bean 29
2.1 声明Bean 30
2.1.1 创建Spring配置 30
2.1.2 声明一个简单Bean 31
2.1.3 通过构造器注入 33
2.1.4 Bean的作用域 37
2.1.5 初始化和销毁Bean 38
2.2 注入Bean属性 40
2.2.1 注入简单值 41
2.2.2 引用其他Bean 42
2.2.3 使用Spring的命名空间p装配属性 45
2.2.4 装配集合 46
2.2.5 装配空值 50
2.3 使用表达式装配 51
2.3.1 SpEL的基本原理 51
2.3.2 在SpEL值上执行操作 54
2.3.3 在SpEL中筛选集合 58
2.4 小结 62
第3章 最小化Spring XML配置 63
3.1 自动装配Bean属性 64
3.1.1 4种类型的自动装配 64
3.1.2 默认自动装配 68
3.1.3 混合使用自动装配和显式装配 68
3.2 使用注解装配 69
3.2.1 使用@Autowired 70
3.2.2 借助@Inject实现基于标准的自动装配 74
3.2.3 在注解注入中使用表达式 76
3.3 自动检测Bean 77
3.3.1 为自动检测标注Bean 78
3.3.2 过滤组件扫描 79
3.4 使用Spring基于Java的配置 80
3.4.1 创建基于Java的配置 80
3.4.2 定义一个配置类 81
3.4.3 声明一个简单的Bean 81
3.4.4 使用Spring的基于Java的配置进行注入 82
3.5 小结 83
第4章 面向切面的Spring 84
4.1 什么是面向切面编程 85
4.1.1 定义AOP术语 86
4.1.2 Spring对AOP的支持 88
4.2 使用切点选择连接点 90
4.2.1 编写切点 91
4.2.2 使用Spring的bean()指示器 92
4.3 在XML中声明切面 93
4.3.1 声明前置和后置通知 94
4.3.2 声明环绕通知 96
4.3.3 为通知传递参数 98
4.3.4 通过切面引入新功能 100
4.4 注解切面 102
4.4.1 注解环绕通知 104
4.4.2 传递参数给所标注的通知 105
4.4.3 标注引入 105
4.5 注入AspectJ切面 107
4.6 小结 109
第二部分 Spring应用程序的核心组件
第5章 征服数据库 112
5.1 Spring的数据访问哲学 113
5.1.1 了解Spring的数据访问异常体系 114
5.1.2 数据访问模板化 116
5.1.3 使用DAO支持类 118
5.2 配置数据源 119
5.2.1 使用JNDI数据源 119
5.2.2 使用数据源连接池 120
5.2.3 基于JDBC驱动的数据源 121
5.3 在Spring中使用JDBC 122
5.3.1 应对失控的JDBC代码 122
5.3.2 使用JDBC模板 125
5.4 在Spring中集成Hibernate 130
5.4.1 Hibernate概览 131
5.4.2 声明Hibernate的Session工厂 132
5.4.3 构建不依赖于Spring的Hibernate代码 134
5.5 Spring与Java持久化API 136
5.5.1 配置实体管理器工厂 136
5.5.2 编写基于JPA的DAO 140
5.6 小结 142
第6章 事务管理 144
6.1 理解事务 145
6.1.1 用4个词来表示事务 146
6.1.2 理解Spring对事务管理的支持 147
6.2 选择事务管理器 147
6.2.1 JDBC事务 149
6.2.2 Hibernate事务 149
6.2.3 Java持久化API事务 150
6.2.4 JTA(Java Transaction API)事务 151
6.3 在Spring中的编码事务 151
6.4 声明式事务 153
6.4.1 定义事务属性 154
6.4.2 在XML中定义事务 157
6.4.3 定义注解驱动的事务 159
6.5 小结 160
第7章 使用Spring MVC构建Web应用程序 162
7.1 Spring MVC起步 163
7.1.1 跟踪Spring MVC的请求 163
7.1.2 搭建Spring MVC 165
7.2 编写基本的控制器 166
7.2.1 配置注解驱动的Spring MVC 167
7.2.2 定义首页的控制器 168
7.2.3 解析视图 171
7.2.4 定义首页的视图 175
7.2.5 完成Spring应用上下文 177
7.3 处理控制器的输入 178
7.3.1 编写处理输入的控制器 179
7.3.2 渲染视图 181
7.4 处理表单 183
7.4.1 展现注册表单 183
7.4.2 处理表单输入 185
7.4.3 校验输入 187
7.5 处理文件上传 191
7.5.1 在表单上添加文件上传域 191
7.5.2 接收上传的文件 192
7.5.3 配置Spring支持文件上传 195
7.6 小结 196
第8章 使用Spring Web Flow 197
8.1 安装Spring Web Flow 198
8.1.1 在Spring中使用Web Flow 198
8.2 流程的组件 201
8.2.1 状态 201
8.2.2 转移 204
8.2.3 流程数据 205
8.3 组合起来：披萨流程 207
8.3.1 定义基本流程 207
8.3.2 收集顾客信息 211
8.3.3 构建订单 216
8.3.4 支付 219
8.4 保护Web流程 211
8.5 小结 221
第9章 保护Spring应用 223
9.1 Spring Security介绍 224
9.1.1 Spring Security起步 224
9.1.2 使用Spring Security配置命名空间 225
9.2 保护Web请求 226
9.2.1 代理Servlet过滤器 226
9.2.2 配置最小化的Web安全性 227
9.2.3 拦截请求 231
9.3 保护视图级别的元素 234
9.3.1 访问认证信息的细节 234
9.3.2 根据权限渲染 235
9.4 认证用户 237
9.4.1 配置内存用户存储库 238
9.4.2 基于数据库进行认证 239
9.4.3 基于LDAP进行认证 240
9.4.4 启用remember-me功能 244
9.5 保护方法调用 245
9.5.1 使用@Secured注解保护方法调用 245
9.5.2 使用JSR-250的@RolesAllowed注解 246
9.5.3 使用SpEL实现调用前后的安全性 246
9.5.4 声明方法级别的安全性切点 250
9.6 小结 251
第三部分 Spring集成
第10章 使用远程服务 254
10.1 Spring远程调用概览 255
10.2 使用RMI 257
10.2.1 发布一个RMI服务 257
10.2.2 装配RMI服务 260
10.3 使用Hessian和Burlap发布远程服务 262
10.3.1 使用Hessian和Burlap发布Bean的功能 263
10.3.2 访问Hessian/Burlap服务 266
10.4 使用Spring的HttpInvoker 267
10.4.1 将把Bean发布为HTTP服务 267
10.4.2 通过HTTP访问服务 269
10.5 发布和使用Web服务 270
10.5.1 创建JAX-WS端点 271
10.5.2 在客户端代理JAX-WS服务 275
10.6 小结 276
第11章 为Spring添加REST功能 277
11.1 了解REST 278
11.1.1 REST的基本原理 278
11.1.2 Spring是如何支持REST的 279
11.2 编写面向资源的控制器 279
11.2.1 剖析RESTless的控制器 280
11.2.2 处理RESTful URL 281
11.2.3 执行REST动作 284
11.3 表述资源 287
11.3.1 协商资源表述 287
11.3.2 使用HTTP信息转换器 290
11.4 编写REST客户端 293
11.4.1 了解RestTemplate的操作 295
11.4.2 GET资源 296
11.4.3 PUT资源 298
11.4.4 DELETE资源 300
11.4.5 POST资源数据 301
11.4.6 交换资源 303
11.5 提交RESTful表单 305
11.5.1 在JSP中渲染隐藏的方法域 306
11.5.2 发布真正的请求 307
11.6 小结 308
第12章 Spring消息 310
12.1 JMS简介 311
12.1.1 构建JMS 312
12.1.2 评估JMS的优点 314
12.2 在Spring中搭建消息代理 316
12.2.1 创建连接工厂 316
12.2.2 声明ActiveMQ消息目的地 317
12.3 使用Spring的JMS模板 318
12.3.1 处理失控的JMS代码 318
12.3.2 使用JMS模板 319
12.4 创建消息驱动的POJO 324
12.4.1 创建消息监听器 325
12.4.2 配置消息监听器 326
12.5 使用基于消息的RPC 327
12.5.1 使用Spring基于消息的RPC 328
12.5.2 使用Lingo实现异步RPC 330
12.6 小结 332
第13章 使用JMX管理Spring Bean 333
13.1 将Spring Bean导出为MBean 334
13.1.1 通过名称发布方法 337
13.1.2 使用接口定义MBean的操作和属性 339
13.1.3 使用注解驱动的MBean 340
13.1.4 处理MBean冲突 342
13.2 远程MBean 343
13.2.1 发布远程MBean 343
13.2.2 访问远程MBean 344
13.2.3 代理MBean 346
13.3 处理通知 347
13.3.1 监听通知 348
13.4 小结 349
第14章 其他Spring技巧 350
14.1 外部化配置 351
14.1.1 替换属性占位符 351
14.1.2 重写属性 354
14.1.3 加密外部属性 355
14.2 装配JNDI对象 357
14.2.1 JNDI的传统用法 357
14.2.2 装配JNDI对象 359
14.2.3 将EJB装配到Spring中 362
14.3 发送邮件 363
14.3.1 配置邮件发送器 363
14.3.2 构建邮件 365
14.4 调度和后台任务 370
14.4.1 声明调度方法 371
14.4.2 声明异步方法 372
14.5 小结 373
14.6 结束语 374
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring实战（第3版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring MVC学习指南
目录
第一章  Spring框架	1
1.1  XML配置文件	4
1.2  Spring控制反转容器的使用	4
1.2.3  通过构造器来创建一个bean实例	5
1.2.2  通过工厂方法来创建一个bean实例	5
1.2.3  Destroy Method的使用	6
1.2.4  向构造器传参	6
1.2.5  Setter方式依赖注入	7
1.2.3  构造器方式依赖注入	10
1.3  小结	10
第二章  模型2和MVC模式	11
2.1  模型1介绍	11
2.2  模型2介绍	11
2.3  模型2之Servlet控制器	13
2.3.1  Product类	15
2.3.2  ProductForm类	15
2.3.3  ControllerServlet类	16
2.3.4  视图	20
2.3.5  测试应用	22
2.4  解耦控制器代码	23
2.5  校验器	27
2.6  后端	32
2.7  本章小结	33
第三章  Spring MVC介绍	34
3.1  采用Spring MVC的好处	34
3.2  Spring MVC的DispatcherServlet	35
3.3  Controller接口	36
3.4  第一个Spring MVC应用	37
3.4.1  目录结构	37
3.4.2  部署描述符文件和Spring MVC配置文件	38
3.4.3  Controller	39
3.4.4  View	40
3.4.5  测试应用	42
3.5  View Resolver	43
3.6  本章小结	45
第四章  基于注解的控制器	46
4.1  Spring MVC注解类型	46
4.1.1  Controller注解类型	46
4.1.2  RequestMapping注解类型	47
4.2  编写请求处理方法	50
4.3  应用基于注解的控制器	52
4.3.1  目录结构	52
4.3.2  配置文件	52
4.3.3  Controller类	55
4.3.4  View	56
4.3.5  测试应用	57
4.4  应用@Autowired和@Service进行依赖注入	58
4.5  重定向和Flash属性	62
4.6  请求参数和路径变量	63
4.7  @ModelAttribute	66
4.8  小结	67
第五章  数据绑定和form标签库	68
5.1  数据绑定概览	68
5.2  form标签库	69
5.2.1  form标签	70
5.2.2  input标签	71
5.2.3  password标签	72
5.2.4  hidden标签	72
5.2.5  textarea标签	73
5.2.6  checkbox标签	73
5.2.7  radiobutton标签	74
5.2.8  checkboxes标签	74
5.2.9  radiobuttons标签	75
5.2.10  select标签	76
5.2.11  option标签	76
5.2.12  options标签	77
5.2.13  errors标签	77
5.3  数据绑定范例	78
5.3.1  目录结构	78
5.3.2  Domain类	78
5.3.3  Controller类	80
5.3.4  Service类	82
5.3.5  配置文件	85
5.3.6  视图	86
5.3.7  测试应用程序范例	88
5.4  小结	90
第六章  Converter和Formatter	91
6.1  converter	91
6.2  formatter	97
6.3  用registrar注册formatter	99
6.4  选择converter，还是formatter？	101
6.5  小结	101
第七章  验证器	102
7.1  验证概览	102
7.2  Spring验证器	103
7.3  ValidationUtils类	104
7.4  Spring的Validator范例	105
7.5  源文件	107
7.6  Controller类	107
7.7  测试验证器	109
7.8  JSR 303验证	110
7.9  JSR 303 Validator范例	112
7.10  小结	114
第八章  表达式语言（EL）	115
8.1  表达式语言（EL）的语法	115
8.1.1  关键字	116
8.1.2  [ ]和.运算符	116
8.1.3  取值规则	117
8.2  访问JavaBean	118
8.3  EL隐式对象	118
8.3.1  pageContext	119
8.4  使用其他EL运算符	122
8.4.1  算术运算符	122
8.3.3  关系运算符	123
8.4.2  逻辑运算符	123
8.4.3  关系运算符	123
8.4.4  empty运算符	124
8.5  如何在JSP 2.0及其更高版本中配置EL	124
8.5.1  实现免脚本的JSP页面	124
8.5.2  禁用EL计算	125
8.6  小结	126
第九章  JSTL	127
9.1  下载JSTL	127
9.2  JSTL库	127
9.3  一般行为	129
9.3.1  out标签	129
9.3.2  set标签	130
9.3.3  remove标签	132
9.4  条件行为	132
9.4.1  if标签	133
9.4.2  choose、when和otherwise标签	134
9.5  遍历行为	135
9.5.1  forEach标签	135
9.5.2  forTokens标签	143
9.6  与URL相关的行为	144
9.6.1  url标签	144
9.6.2  redirect标签	146
9.7  格式化行为	146
9.7.1  formatNumber标签	146
9.7.2  formatDate标签	149
9.7.3  timeZone标签	150
9.7.4  setTimeZone标签	152
9.7.5  parseNumber	152
9.7.6  parseDate标签	153
9.8  函数	155
9.8.1  contains函数	155
9.8.2  containsIgnoreCase函数	155
9.8.3  endsWith函数	156
9.8.4  escapeXml函数	156
9.8.5  indexOf函数	156
9.8.6  join函数	156
9.8.7  length函数	157
9.8.8  replace函数	157
9.8.9  split函数	157
9.8.10  startsWith函数	158
9.8.11  substring函数	158
9.8.12  substringAfter函数	158
9.8.13  substringBefore函数	158
9.8.14  toLowerCase函数	159
9.8.15  toUpperCase函数	159
9.8.16  trim函数	159
9.9  小结	159
第十章  国际化	160
10.1  语言区域	161
10.2  国际化Spring MVC应用程序	163
10.3  将文本元件隔离成属性文件	163
10.4  读取属性文件	165
10.5  告诉Spring MVC要使用哪个语言区域	166
10.6  使用message标签	167
10.7  范例	167
10.8  小结	173
第十一章  上传文件	174
11.1  客户端编程	174
11.2  MultipartFile接口	175
11.3  用Commons FileUpload上传文件	176
11.4  Domain类	177
11.5  控制器	178
11.6  配置文件	179
11.7  JSP页面	181
11.8  应用程序的测试	183
11.9  用Servlet 3及其更高版本上传文件	184
11.10  客户端上传	188
11.11  小结	196
第十二章  下载文件	197
12.1  文件下载概览	197
12.2  范例1：隐藏资源	198
12.3  范例2：防止交叉引用	202
12.4  小结	206
附录A  Tomcat	207
附录B  servlet	211
附录C  JavaServer Pages	236
附录D  部署描述符	258
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring MVC学习指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web高级编程
第Ⅰ部分 创建企业级应用程序
第1章 介绍Java EE平台 3
1.1 Java平台时间线 3
1.1.1 起始 3
1.1.2 企业级Java的诞生 4
1.1.3 Java SE和Java EE共同发展 5
1.1.4 了解最新的平台特性 7
1.1.5 持续发展 11
1.2 了解基本的Web应用程序结构 11
1.2.1 Servlet、过滤器、监听器和JSP 11
1.2.2 目录结构和WAR文件 12
1.2.3 部署描述符 13
1.2.4 类加载器架构 14
1.2.5 企业级应用程序归档文件 14
1.3 小结 15
第2章 使用Web容器 17
2.1 选择Web容器 17
2.1.1 Apache Tomcat 18
2.1.2 GlassFish 19
2.1.3 JBoss和WildFly 19
2.1.4 其他容器和应用服务器 20
2.1.5 本书使用Tomcat的原因 20
2.2 在个人计算机中安装Tomcat 21
2.2.1 将Tomcat安装为Windows服务 21
2.2.2 将Tomcat安装为命令行应用程序 21
2.2.3 配置自定义的JSP编译器 23
2.3 在Tomcat中部署和卸载应用程序 24
2.3.1 手动部署和卸载 24
2.3.2 使用Tomcat管理器 25
2.4 通过IDE调试Tomcat 26
2.4.1 使用IntelliJ IDEA 27
2.4.2 使用Eclipse 30
2.5 小结 34
第3章 创建第一个Servlet 35
3.1 创建Servlet类 36
3.1.1 选择要继承的Servlet类 36
3.1.2 使用初始化方法和销毁方法 38
3.2 配置可部署的Servlet 39
3.2.1 向描述符中添加Servlet 39
3.2.2 将Servlet映射到URL 40
3.2.3 运行和调试Servlet 42
3.3 了解doGet、doPost和其他方法 44
3.3.1 在service方法执行的过程中 44
3.3.2 使用HttpServletRequest 44
3.3.3 使用HttpServletResponse 47
3.4 使用参数和接受表单提交 49
3.5 使用初始化参数配置应用程序 53
3.5.1 使用上下文初始化参数 53
3.5.2 使用Servlet初始化参数 54
3.6 通过表单上传文件 56
3.6.1 介绍客户支持项目 56
3.6.2 配置Servlet支持文件上传 56
3.6.3 接受文件上传 59
3.7 编写多线程安全的应用程序 60
3.7.1 理解请求、线程和方法执行 60
3.7.2 保护共享资源 61
3.8 小结 62
第4章 使用JSP显示页面内容 63
4.1 使用
替代output.println("
") 64
4.1.1 使用JSP的原因 65
4.1.2 JSP在运行时的处理 66
4.2 创建第一个JSP 67
4.2.1 了解文件结构 67
4.2.2 指令、声明、脚本和表达式 69
4.2.3 注释代码 70
4.2.4 在JSP中导入类 71
4.2.5 使用指令 72
4.2.6 使用标签 75
4.3 在JSP中使用Java(以及不鼓励使用Java的原因) 76
4.3.1 使用JSP中隐式的变量 76
4.3.2 不应该在JSP中使用Java的原因 82
4.4 结合使用Servlet和JSP 82
4.4.1 配置部署描述符中的JSP属性 82
4.4.2 将Servlet中的请求转发给JSP 85
4.5 关于JSP文档(JSPX)的注意事项 89
4.6 小结 91
第5章 使用会话维持状态 93
5.1 需要会话的原因 93
5.1.1 维持状态 94
5.1.2 记住用户 94
5.1.3 启动应用程序工作流 94
5.2 使用会话cookie和URL重写 95
5.2.1 了解会话cookie 96
5.2.2 URL中的会话ID 98
5.2.3 会话的漏洞 100
5.3 在会话中存储数据 102
5.3.1 在部署描述符中配置会话 103
5.3.2 存储和获取数据 105
5.3.3 删除数据 109
5.3.4 在会话中存储更复杂的数据 111
5.4 使用会话 114
5.4.1 为客户支持应用程序添加登录功能 114
5.4.2 使用监听器检测会话的变化 118
5.4.3 维护活跃会话列表 120
5.5 将使用会话的应用程序群集化 124
5.5.1 在群集中使用会话ID 124
5.5.2 了解会话复制和故障恢复 126
5.6 小结 127
第6章 在JSP中使用表达式语言 129
6.1 了解表达式语言 129
6.1.1 表达式语言的用途 130
6.1.2 了解基本语法 130
6.1.3 添加EL表达式 132
6.2 使用EL语法 133
6.2.1 保留关键字 133
6.2.2 操作符优先级 134
6.2.3 对象属性和方法 139
6.2.4 EL函数 140
6.2.5 静态字段和方法访问 141
6.2.6 枚举 142
6.2.7 lambda表达式 142
6.2.8 集合 143
6.3 在EL表达式中使用作用域变量 144
6.3.1 使用隐式的EL作用域 145
6.3.2 使用隐式的EL变量 148
6.4 使用流API访问集合 151
6.4.1 了解中间操作 151
6.4.2 使用终结操作 153
6.4.3 使用流API 154
6.5 使用表达式语言替换Java代码 155
6.6 小结 157
第7章 使用Java标准标签库 159
7.1 JSP标签和JSTL简介 159
7.2 使用核心标签库(C命名空间) 163
7.2.1 163
7.2.2 164
7.2.3 165
7.2.4 、和 166
7.2.5 167
7.2.6 168
7.2.7 168
7.2.8 169
7.2.9 和 170
7.2.10 使用核心库标签 170
7.3 使用国际化和格式化标签库(FMT命名空间) 173
7.3.1 国际化和本地化组件 173
7.3.2 175
7.3.3 176
7.3.4 和 176
7.3.5 177
7.3.6 和 177
7.3.7 和 178
7.3.8 和 179
7.3.9 使用i18n和格式化库标签 180
7.4 使用数据库访问标签库(SQL命名空间) 182
7.5 使用XML处理标签库(X命名空间) 184
7.6 使用JSP标签替换Java代码 184
7.7 小结 186
第8章 编写自定义标签和函数库 189
8.1 了解TLD、标签文件和标签处理器 189
8.1.1 读取Java标准标签库TLD 190
8.1.2 比较JSP指令和标签文件指令 196
8.2 创建标签文件用作HTML模板 198
8.3 创建日期格式化标签处理器 199
8.4 创建EL函数简写字符串 203
8.5 使用自定义JSP标签替换Java代码 204
8.6 小结 210
第9章 使用过滤器改进应用程序 211
9.1 了解过滤器的目的 211
9.1.1 日志过滤器 212
9.1.2 验证过滤器 212
9.1.3 压缩和加密过滤器 212
9.1.4 错误处理过滤器 212
9.2 创建、声明和映射过滤器 213
9.2.1 了解过滤器链 213
9.2.2 映射到URL模式和Servlet名称 213
9.2.3 映射到不同的请求派发器类型 214
9.2.4 使用部署描述符 214
9.2.5 使用注解 215
9.2.6 使用编程式配置 215
9.3 过滤器排序 216
9.3.1 URL模式映射和Servlet名称映射 217
9.3.2 演示过滤器顺序 218
9.3.3 使用过滤器处理异步请求 220
9.4 调查过滤器的实际用例 224
9.4.1 添加简单的日志过滤器 225
9.4.2 使用过滤器压缩响应内容 226
9.5 使用过滤器简化认证 230
9.6 小结 231
第10章 在应用程序中使用WebSocket进行交互 233
10.1 演变：从AJAX到WEBSOCKET 234
10.1.1 问题：从服务器获得新数据到浏览器 234
10.1.2 解决方案1：频繁轮询 235
10.1.3 解决方案2：长轮询 236
10.1.4 解决方案3：分块编码 237
10.1.5 解决方案4：Applet和Adobe Flash 238
10.1.6 WebSocket：一种无人知道但已经存在的解决方案 239
10.2 了解WebSocket API 242
10.2.1 HTML5(JavaScript)客户端API 243
10.2.2 Java WebSocket API 245
10.3 使用WebSocket创建多人游戏 247
10.3.1 实现基本的三连棋游戏策略 247
10.3.2 创建服务器终端 248
10.3.3 编写JavaScript游戏控制台 252
10.3.4 WebSocket三连棋游戏试玩 256
10.4 在群集中使用WebSocket进行通信 257
10.4.1 使用两个Servlet实例模拟简单的群集 257
10.4.2 发送和接收二进制消息 259
10.4.3 测试模拟群集应用程序 261
10.5 在客户支持应用程序中添加"支持与客户聊天"功能 262
10.5.1 使用编码器和解码器转换消息 262
10.5.2 创建聊天服务器终端 264
10.5.3 编写JavaScript聊天应用程序 267
10.6 小结 269
第11章 使用日志监控应用程序 271
11.1 了解日志的概念 272
11.1.1 记录日志的原因 272
11.1.2 在日志中记录的内容 273
11.1.3 日志的写入方式 274
11.2 使用日志级别和分类 276
11.2.1 使用不同日志级别的原因 276
11.2.2 定义的日志级别 276
11.2.3 日志分类的工作方式 277
11.2.4 筛选的工作方式 277
11.3 选择日志框架 277
11.3.1 API和实现 278
11.3.2 性能 278
11.3.3 Apache Commons Logging和SLF4J 279
11.3.4 Log4j 2简介 280
11.4 在应用程序中集成日志 283
11.4.1 创建Log4j 2配置文件 284
11.4.2 在Web过滤器中使用鱼标签 287
11.4.3 在Java代码中编写日志语句 288
11.4.4 在JSP中使用日志标签库 290
11.4.5 客户支持应用程序中的日志 290
11.5 小结 291
第Ⅱ部分 添加Spring Framework
第12章 介绍Spring Framework 295
12.1 Spring Framework简介 296
12.1.1 反转控制和依赖注入 296
12.1.2 面向切面编程 297
12.1.3 数据访问和事务管理 297
12.1.4 应用程序消息 297
12.1.5 Web应用程序的模型-视图-控制器模式 298
12.2 使用Spring Framework的原因 298
12.2.1 逻辑代码分组 298
12.2.2 使用同一代码库的多个用户界面 298
12.3 了解应用上下文 299
12.4 启动Spring Framework 300
12.4.1 使用部署描述符启动Spring 301
12.4.2 在初始化器中使用编程的方式启动Spring 303
12.5 配置Spring Framework 306
12.5.1 创建XML配置 308
12.5.2 创建混合配置 310
12.5.3 使用@Configuration配置Spring 314
12.6 使用bean definition profile 318
12.6.1 了解profile的工作原理 319
12.6.2 考虑反模式和安全问题 321
12.7 小结 322
第13章 使用控制器替代Servlet 323
13.1 了解@RequestMapping 323
13.1.1 使用@RequestMapping特性
缩小请求匹配的范围 324
13.1.2 指定控制器方法参数 328
13.1.3 为控制器方法选择有效的返回类型 335
13.2 使用Spring Framework的模型和视图模式 337
13.2.1 使用显式的视图和视图名称 338
13.2.2 使用含有模型特性的隐式视图 340
13.2.3 返回响应实体 341
13.3 使用表单对象简化开发 346
13.3.1 在模型中添加表单对象 347
13.3.2 使用Spring Framework 标签 347
13.3.3 获得被提交的表单数据 349
13.4 更新客户支持应用程序 350
13.4.1 启用Multipart支持 350
13.4.2 将Servlet转换成Spring MVC控制器 351
13.4.3 创建自定义下载视图 352
13.5 小结 353
第14章 使用服务和仓库支持控制器 355
14.1 了解模型-视图-控制器模式与控制器-服务-仓库模式 355
14.1.1 识别程序逻辑的不同类型 356
14.1.2 使用仓库提供持久化逻辑 357
14.1.3 使用服务提供业务逻辑 357
14.1.4 使用控制器提供用户界面逻辑 358
14.2 使用根应用上下文替代Web应用上下文 359
14.2.1 在多用户界面中重用根应用上下文 359
14.2.2 将业务逻辑从控制器移动到服务 360
14.2.3 使用仓库存储数据 364
14.3 使用异步和计划执行改进服务 368
14.3.1 了解执行器和调度器 369
14.3.2 配置调度器和异步支持 369
14.3.3 创建和使用@Async方法 371
14.3.4 创建和使用@Scheduled方法 372
14.4 使用WebSocket实现逻辑层分离 373
14.4.1 在Spring应用上下文中添加由容器管理的对象 373
14.4.2 使用Spring WebSocket配置器 375
14.4.3 记住：WebSocket只是业务逻辑的另一个界面 376
14.5 小结 380
第15章 使用Spring Framework i18n国际化应用程序 381
15.1 使用Spring Framework i18n的原因 381
15.1.1 使国际化变得更容易 382
15.1.2 直接本地化错误消息 382
15.2 使用基本的国际化和本地化API 382
15.2.1 了解资源包和消息格式 383
15.2.2 使用消息源进行挽救 385
15.2.3 使用消息源国际化JSP 386
15.3 在Spring Framework中配置国际化 387
15.3.1 创建消息源 387
15.3.2 了解区域设置解析器 388
15.3.3 使用处理拦截器修改区域设置 390
15.3.4 提供一个用户Profile区域设置 390
15.3.5 包含时区支持 391
15.3.6 了解主题如何改进国际化 392
15.4 国际化代码 392
15.4.1 使用标签 393
15.4.2 以更干净的方式处理应用程序错误 395
15.4.3 更新客户支持应用程序 398
15.4.4 直接使用消息源 399
15.5 小结 402
第16章 使用JSR 349、Spring Framework和Hibernate Validator执行Bean验证 403
16.1 Bean验证的概念 404
16.1.1 使用Hibernate Validator的原因 405
16.1.2 了解注解元数据模型 406
16.1.3 使用Spring Framework实现Bean验证 406
16.2 在Spring Framework容器中配置验证 406
16.2.1 配置Spring验证Bean 407
16.2.2 创建错误代码本地化 409
16.2.3 使用方法验证Bean后处理器 410
16.2.4 在Spring MVC中使用相同的验证Bean 411
16.3 在Bean中添加约束验证注解 411
16.3.1 了解内建的约束注解 411
16.3.2 了解常见的约束特性 412
16.3.3 使用约束 413
16.3.4 使用@Valid实现递归验证 415
16.3.5 使用验证组 416
16.3.6 在编译时检查约束合法性 417
16.4 为方法验证配置Spring Bean 418
16.4.1 标注接口，而非实现 418
16.4.2 在方法参数上使用限制和递归验证 419
16.4.3 验证方法返回值 420
16.4.4 表示一个类是否适用于方法验证 420
16.4.5 在Spring MVC控制器中使用参数验证 421
16.4.6 为用户显示验证错误 423
16.5 编写自己的验证约束 425
16.5.1 在自定义限制中继承其他限制 425
16.5.2 创建限制验证器 426
16.5.3 了解限制验证器的生命周期 428
16.6 在客户支持应用程序中集成验证 429
16.7 小结 431
第17章 创建RESTful和SOAP Web服务 433
17.1 了解Web服务 433
17.1.1 最初的SOAP 434
17.1.2 RESTful Web服务提供了一种更简单的方式 435
17.2 在Spring MVC中配置RESTful Web服务 442
17.2.1 使用原型注解分离控制器 442
17.2.2 创建单独的Web和REST应用上下文 443
17.2.3 处理RESTful Web服务中的错误条件 446
17.2.4 将RESTful请求映射到控制器方法 449
17.2.5 使用索引终端改进发现机制 453
17.3 测试Web服务终端 454
17.3.1 选择测试工具 454
17.3.2 请求Web服务 455
17.4 使用Spring Web Service创建SOAP Web服务 457
17.4.1 编写契约优先的XSD和WSDL 458
17.4.2 添加SOAP派发器Servlet配置 460
17.4.3 创建SOAP终端 462
17.5 小结 465
第18章 使用消息传送和群集实现灵活性和可靠性 467
18.1 识别需要消息传送和群集的时机 467
18.1.1 应用程序消息传送的定义 468
18.1.2 群集的定义 470
18.1.3 消息传送和群集的协作方式 474
18.2 为应用程序添加消息传送支持 477
18.2.1 创建应用程序事件 477
18.2.2 订阅应用程序事件 478
18.2.3 发布应用程序事件 479
18.3 在群集中分布消息传送 481
18.3.1 更新事件以支持分布 482
18.3.2 创建并配置一个自定义事件多播器 483
18.3.3 使用WebSocket发送和接收事件 485
18.3.4 通过多播数据包发现节点 487
18.3.5 部署多个应用程序模拟群集 489
18.4 使用AMQP分布事件 490
18.4.1 配置AMQP代理 491
18.4.2 创建AMQP多播器 492
18.4.3 运行使用了AMQP的应用程序 494
18.5 小结 495
第Ⅲ部分 使用JPA和Hibernate ORM持久化数据
第19章 介绍Java Persistence API和 Hibernate ORM 499
19.1 数据持久化的定义 499
19.1.1 平面文件实体存储 500
19.1.2 结构化文件存储 500
19.1.3 关系数据库系统 501
19.1.4 面向对象数据库 501
19.1.5 无模式数据库系统 502
19.2 对象-关系映射的定义 502
19.2.1 了解持久化实体的问题 503
19.2.2 O/RM使实体持久化更简单 504
19.2.3 JPA提供了一种标准O/RM API 505
19.3 使用Hibernate ORM的原因 507
19.4 Hibernate ORM简介 507
19.4.1 使用Hibernate映射文件 507
19.4.2 了解会话API 509
19.4.3 从SessionFactory中获得会话 511
19.4.4 使用Spring Framework创建SessionFactory 512
19.5 准备关系数据库 513
19.5.1 安装MySQL和
MySQL Workbench 513
19.5.2 安装MySQL JDBC驱动 515
19.5.3 在Tomcat中创建连接资源 516
19.5.4 注意Maven依赖 517
19.6 小结 517
第20章 使用JPA注解将实体映射到表 519
20.1 使用简单实体 520
20.1.1 创建实体并将它映射到表 521
20.1.2 指示JPA使用实体字段的
方式 523
20.1.3 映射代理键 523
20.1.4 使用基本数据类型 529
20.1.5 指定列名和其他细节 532
20.2 创建和使用持久化单元 534
20.2.1 设计数据库表 534
20.2.2 了解持久化单元作用域 536
20.2.3 创建持久化配置 536
20.2.4 使用持久化API 539
20.3 映射复杂数据类型 543
20.3.1 使用枚举作为实体属性 543
20.3.2 了解JPA如何处理日期和时间 544
20.3.3 将大属性映射为CLOB和BLOB 546
20.4 小结 548
第21章 在Spring Framework仓库中使用JPA 549
21.1 使用Spring仓库和事务 550
21.1.1 了解事务范围 550
21.1.2 为事务和实体管理器使用线程 551
21.1.3 使用异常转换 552
21.2 在Spring Framework中配置持久化 553
21.2.1 查找数据源 553
21.2.2 在代码中创建持久化单元 554
21.2.3 创建事务管理 557
21.3 创建和使用JPA仓库 560
21.3.1 注入持久化单元 560
21.3.2 实现标准CRUD操作 561
21.3.3 为所有的实体创建一个基础仓库 563
21.3.4 在服务中标记事务范围 568
21.3.5 使用事务服务方法 572
21.4 在DTO和实体之间转换数据 573
21.4.1 为客户支持应用程序创建实体 574
21.4.2 使用BCrypt保护用户密码 578
21.4.3 在服务中将数据传输到实体中 579
21.5 小结 581
第22章 使用Spring Data JPA消除公式化的仓库 583
22.1 了解Spring Data的统一数据访问 584
22.1.1 避免代码重复 584
22.1.2 使用Stock仓库接口 587
22.1.3 为搜索实体创建查询方法 588
22.1.4 提供自定义方法实现 591
22.2 配置和创建Spring Data JPA仓库 594
22.2.1 启用仓库自动生成 595
22.2.2 编写和使用Spring Data
JPA接口 601
22.3 重构客户支持应用程序 603
22.3.1 转换现有仓库 603
22.3.2 在支持票据中添加评论 605
22.4 小结 609
第23章 使用JPA和Hibernate Search搜索数据 611
23.1 搜索介绍 612
23.1.1 了解索引的重要性 612
23.1.2 采取三种不同的方式 613
23.2 使用高级条件定位对象 614
23.2.1 创建复杂条件查询 614
23.2.2 在查询中使用OR 621
23.2.3 创建有用的索引改进性能 622
23.3 使用JPA的全文索引 623
23.3.1 在MySQL表中创建全文索引 624
23.3.2 创建和使用可搜索的仓库 625
23.3.3 使全文搜索可迁移 630
23.4 使用Apache Lucene和Hibernate Search索引任意数据 630
23.4.1 了解Lucene全文索引 631
23.4.2 使用索引元数据标注实体 632
23.4.3 结合使用Hibernate Search和JPA 634
23.5 小结 637
第24章 创建高级映射和自定义数据类型 639
24.1 JPA的相关内容 639
24.2 转换非标准数据类型 640
24.2.1 了解特性转换器 641
24.2.2 了解转换注解 642
24.2.3 创建和使用特性转换器 643
24.3 在实体中内嵌POJO 645
24.3.1 表示嵌套的类型 645
24.3.2 使属性成为可嵌入属性 645
24.3.3 覆盖可内嵌列列名 647
24.4 定义实体间的关系 648
24.4.1 了解一对一关系 648
24.4.2 使用一对多和多对一关系 650
24.4.3 创建多对多关系 653
24.5 处理其他常见的情况 654
24.5.1 使用修订和时间戳版本化实体 654
24.5.2 定义公共属性的抽象实体 655
24.5.3 映射基本的和内嵌的集合 656
24.5.4 持久化含有键值对的Map 659
24.5.5 在多个表中存储实体 660
24.6 创建编程式触发器 661
24.6.1 在CRUD操作之前或之后执行 661
24.6.2 使用实体监听器 663
24.7 简化客户支持应用程序 664
24.7.1 映射附件的集合 664
24.7.2 使用加载时织入延迟加载简单属性 666
24.8 小结 669
第Ⅳ部分 使用Spring Security保护应用程序
第25章 介绍Spring Security 673
25.1 认证的概念 673
25.1.1 集成认证 674
25.1.2 了解授权 682
25.2 选择Spring Security的原因 685
25.2.1 了解Spring Security基础 686
25.2.2 使用Spring Security的授权服务 686
25.2.3 配置Spring Security 687
25.3 小结 687
第26章 使用Spring Security验证用户 689
26.1 选择并配置认证提供者 690
26.1.1 配置用户细节提供者 690
26.1.2 使用LDAP和活动目录提供者 700
26.1.3 使用OpenID进行认证 703
26.1.4 remember-me认证 705
26.1.5 学习其他认证提供者 706
26.2 编写自己的认证提供者 707
26.2.1 以正确的顺序启动 707
26.2.2 创建和配置提供者 710
26.2.3 缓解跨站请求伪装攻击 715
26.3 小结 718
第27章 使用授权标签和注解 719
27.1 通过声明进行授权 719
27.1.1 在方法代码中检查权限 720
27.1.2 采用URL安全 722
27.1.3 使用注解声明权限 725
27.1.4 定义方法切点规则 732
27.2 了解授权决策 733
27.2.1 使用访问决策投票者 733
27.2.2 使用访问决策管理器 734
27.3 为对象安全创建访问控制列表 736
27.3.1 了解Spring Security的
ACL 736
27.3.2 配置访问控制列表 738
27.3.3 为实体填充ACL 740
27.4 在客户支持应用程序中添加授权 741
27.4.1 切换到自定义用户细节 742
27.4.2 保护服务方法 746
27.4.3 使用Spring Security的标签库 750
27.5 小结 751
第28章 使用OAuth保护RESTful Web服务 753
28.1 了解Web服务安全 754
28.1.1 比较Web GUI和Web服务安全 754
28.1.2 选择认证机制 754
28.2 介绍OAuth 756
28.2.1 了解关键参与者 756
28.2.2 起始：OAuth 1.0 757
28.2.3 标准：OAuth 1.0a 757
28.2.4 演化：OAuth 2.0 762
28.3 使用Spring Security OAuth 769
28.3.1 创建OAuth 2.0提供者 769
28.3.2 创建OAuth 2.0客户端 773
28.4 完成客户端支持应用程序 775
28.4.1 生成请求随机数和签名 776
28.4.2 实现客户端服务 777
28.4.3 实现随机数服务 780
28.4.4 实现令牌服务 782
28.4.5 自定义资源服务器过滤器 785
28.4.6 重新配置Spring Security 787
28.5 创建OAuth客户端应用程序 791
28.5.1 自定义REST模板 792
28.5.2 配置Spring Security OAuth客户端 793
28.5.3 使用REST模板 795
28.5.4 同时测试提供者和客户端 796
28.6 小结 797
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web高级编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Spring 4.x
第1篇 基础篇
第1章 Spring概述\t2
1．1 认识Spring\t2
1．2 关于SpringSource\t4
1．3 Spring带给我们什么\t5
1．4 Spring体系结构\t6
1．5 Spring对Java版本的要求\t8
1．6 Spring 4．0新特性\t8
1．6．1 全面支持Java 8．0\t9
1．6．2 核心容器的增强\t11
1．6．3 支持用Groovy定义Bean\t12
1．6．4 Web的增强\t12
1．6．5 支持WebSocket\t12
1．6．6 测试的增强\t13
1．6．7 其他\t13
1．7 Spring子项目\t13
1．8 如何获取Spring\t15
1．9 小结\t16
第2章 快速入门\t17
2．1 实例概述\t17
2．1．1 比Hello World更适用的实例\t18
2．1．2 实例功能简介\t18
2．2 环境准备\t20
2．2．1 构建工具Maven\t20
2．2．2 创建库表\t22
2．2．3 建立工程\t23
2．2．4 类包及Spring配置文件规划\t28
2．3 持久层\t29
2．3．1 建立领域对象\t29
2．3．2 UserDao\t30
2．3．3 LoginLogDao\t33
2．3．4 在Spring中装配DAO\t34
2．4 业务层\t35
2．4．1 UserService\t35
2．4．2 在Spring中装配Service\t37
2．4．3 单元测试\t38
2．5 展现层\t40
2．5．1 配置Spring MVC框架\t40
2．5．2 处理登录请求\t42
2．5．3 JSP视图页面\t44
2．6 运行Web应用\t46
2．7 小结\t48
第3章 Spring Boot\t49
3．1 Spring Boot概览\t49
3．1．1 Spring Boot发展背景\t50
3．1．2 Spring Boot特点\t50
3．1．3 Spring Boot启动器\t50
3．2 快速入门\t52
3．3 安装配置\t54
3．3．1 基于Maven环境配置\t54
3．3．2 基于Gradle环境配置\t56
3．3．3 基于Spring Boot CLI环境
配置\t57
3．3．4 代码包结构规划\t58
3．4 持久层\t59
3．4．1 初始化配置\t59
3．4．2 UserDao\t61
3．5 业务层\t62
3．6 展现层\t64
3．6．1 配置pom．xml依赖\t64
3．6．2 配置Spring MVC框架\t65
3．6．3 处理登录请求\t65
3．7 运维支持\t67
3．8 小结\t70
第2篇 核心篇
第4章 IoC容器\t72
4．1 IoC概述\t72
4．1．1 通过实例理解IoC的概念\t73
4．1．2 IoC的类型\t75
4．1．3 通过容器完成依赖关系的
注入\t77
4．2 相关Java基础知识\t78
4．2．1 简单实例\t78
4．2．2 类装载器ClassLoader\t80
4．2．3 Java反射机制\t83
4．3 资源访问利器\t85
4．3．1 资源抽象接口\t85
4．3．2 资源加载\t88
4．4 BeanFactory和ApplicationContext\t91
4．4．1 BeanFactory介绍\t92
4．4．2 ApplicationContext介绍\t94
4．4．3 父子容器\t103
4．5 Bean的生命周期\t103
4．5．1 BeanFactory中Bean的生命
周期\t103
4．5．2 ApplicationContext中Bean
的生命周期\t112
4．6 小结\t114
第5章 在IoC容器中装配Bean\t115
5．1 Spring配置概述\t116
5．1．1 Spring容器高层视图\t116
5．1．2 基于XML的配置\t117
5．2 Bean基本配置\t120
5．2．1 装配一个Bean\t120
5．2．2 Bean的命名\t120
5．3 依赖注入\t121
5．3．1 属性注入\t121
5．3．2 构造函数注入\t124
5．3．3 工厂方法注入\t128
5．3．4 选择注入方式的考量\t130
5．4 注入参数详解\t130
5．4．1 字面值\t130
5．4．2 引用其他Bean\t131
5．4．3 内部Bean\t133
5．4．4 null值\t133
5．4．5 级联属性\t134
5．4．6 集合类型属性\t134
5．4．7 简化配置方式\t138
5．4．8 自动装配\t141
5．5 方法注入\t142
5．5．1 lookup方法注入\t142
5．5．2 方法替换\t143
5．6 ＜bean＞之间的关系\t144
5．6．1 继承\t144
5．6．2 依赖\t145
5．6．3 引用\t146
5．7 整合多个配置文件\t147
5．8 Bean作用域\t148
5．8．1 singleton作用域\t148
5．8．2 prototype作用域\t149
5．8．3 与Web应用环境相关的Bean
作用域\t150
5．8．4 作用域依赖问题\t152
5．9 FactoryBean\t153
5．10 基于注解的配置\t155
5．10．1 使用注解定义Bean\t155
5．10．2 扫描注解定义的Bean\t156
5．10．3 自动装配Bean\t157
5．10．4 Bean作用范围及生命过程
方法\t162
5．11 基于Java类的配置\t164
5．11．1 使用Java类提供Bean定义
信息\t164
5．11．2 使用基于Java类的配置信息
启动Spring容器\t167
5．12 基于Groovy DSL的配置\t169
5．12．1 使用Groovy DSL提供Bean
定义信息\t169
5．12．2 使用GenericGroovyApplication
Context启动Spring容器\t171
5．13 通过编码方式动态添加Bean\t172
5．13．1 通过DefaultListableBean
Factory\t172
5．13．2 扩展自定义标签\t173
5．14 不同配置方式比较\t175
5．15 小结\t177
第6章 Spring容器高级主题\t178
6．1 Spring容器技术内幕\t178
6．1．1 内部工作机制\t179
6．1．2 BeanDefinition\t182
6．1．3 InstantiationStrategy\t183
6．1．4 BeanWrapper\t183
6．2 属性编辑器\t184
6．2．1 JavaBean的编辑器\t185
6．2．2 Spring默认属性编辑器\t188
6．2．3 自定义属性编辑器\t189
6．3 使用外部属性文件\t192
6．3．1 PropertyPlaceholderConfigurer
属性文件\t192
6．3．2 使用加密的属性文件\t195
6．3．3 属性文件自身的引用\t198
6．4 引用Bean的属性值\t199
6．5 国际化信息\t201
6．5．1 基础知识\t201
6．5．2 MessageSource\t206
6．5．3 容器级的国际化信息资源\t209
6．6 容器事件\t210
6．6．1 Spring事件类结构\t211
6．6．2 解构Spring事件体系的具体
实现\t213
6．6．3 一个实例\t214
6．7 小结\t215
第7章 Spring AOP基础\t216
7．1 AOP概述\t216
7．1．1 AOP到底是什么\t217
7．1．2 AOP术语\t219
7．1．3 AOP的实现者\t221
7．2 基础知识\t222
7．2．1 带有横切逻辑的实例\t222
7．2．2 JDK动态代理\t224
7．2．3 CGLib动态代理\t228
7．2．4 AOP联盟\t229
7．2．5 代理知识小结\t230
7．3 创建增强类\t230
7．3．1 增强类型\t230
7．3．2 前置增强\t231
7．3．3 后置增强\t235
7．3．4 环绕增强\t236
7．3．5 异常抛出增强\t237
7．3．6 引介增强\t239
7．4 创建切面\t243
7．4．1 切点类型\t243
7．4．2 切面类型\t244
7．4．3 静态普通方法名匹配切面\t246
7．4．4 静态正则表达式方法匹配
切面\t248
7．4．5 动态切面\t251
7．4．6 流程切面\t254
7．4．7 复合切点切面\t256
7．4．8 引介切面\t258
7．5 自动创建代理\t259
7．5．1 实现类介绍\t259
7．5．2 BeanNameAutoProxyCreator\t260
7．5．3 DefaultAdvisorAutoProxy
Creator\t261
7．5．4 AOP无法增强疑难问题
剖析\t262
7．6 小结\t267
第8章 基于@AspectJ和Schema的
AOP\t269
8．1 Spring对AOP的支持\t269
8．2 Java 5．0注解知识快速进阶\t270
8．2．1 了解注解\t270
8．2．2 一个简单的注解类\t271
8．2．3 使用注解\t272
8．2．4 访问注解\t273
8．3 着手使用@AspectJ\t274
8．3．1 使用前的准备\t275
8．3．2 一个简单的例子\t275
8．3．3 如何通过配置使用@AspectJ
切面\t277
8．4 @AspectJ语法基础\t278
8．4．1 切点表达式函数\t278
8．4．2 在函数入参中使用通配符\t279
8．4．3 逻辑运算符\t280
8．4．4 不同增强类型\t281
8．4．5 引介增强用法\t282
8．5 切点函数详解\t283
8．5．1 @annotation()\t284
8．5．2 execution()\t285
8．5．3 args()和@args()\t287
8．5．4 within()\t288
8．5．5 @within()和@target()\t289
8．5．6 target()和this()\t290
8．6 @AspectJ进阶\t291
8．6．1 切点复合运算\t292
8．6．2 命名切点\t292
8．6．3 增强织入的顺序\t294
8．6．4 访问连接点信息\t294
8．6．5 绑定连接点方法入参\t295
8．6．6 绑定代理对象\t297
8．6．7 绑定类注解对象\t298
8．6．8 绑定返回值\t299
8．6．9 绑定抛出的异常\t299
8．7 基于Schema配置切面\t300
8．7．1 一个简单切面的配置\t300
8．7．2 配置命名切点\t302
8．7．3 各种增强类型的配置\t303
8．7．4 绑定连接点信息\t305
8．7．5 Advisor配置\t306
8．8 混合切面类型\t307
8．8．1 混合使用各种切面类型\t308
8．8．2 各种切面类型总结\t308
8．9 其他\t309
8．9．1 JVM Class文件字节码转换
基础知识\t309
8．9．2 使用LTW织入切面\t311
8．10 小结\t314
第9章 Spring SpEL\t316
9．1 JVM动态语言\t316
9．2 SpEL表达式概述\t318
9．3 SpEL核心接口\t319
9．3．1 EvaluationContext接口\t320
9．3．2 SpEL编译器\t321
9．4 SpEL基础表达式\t323
9．4．1 文本字符解析\t323
9．4．2 对象属性解析\t323
9．4．3 数组、集合类型解析\t324
9．4．4 方法解析\t326
9．4．5 操作符解析\t327
9．4．6 安全导航操作符\t329
9．4．7 三元操作符\t330
9．4．8 Elvis操作符\t331
9．4．9 赋值、类型、构造器、变量\t332
9．4．10 集合过滤\t335
9．4．11 集合转换\t335
9．5 在Spring中使用SpEL\t336
9．5．1 基于XML的配置\t336
9．5．2 基于注解的配置\t337
9．6 小结\t338
第3篇 数据篇
第10章 Spring对DAO的支持\t340
10．1 Spring的DAO理念\t340
10．2 统一的异常体系\t341
10．2．1 Spring的DAO异常体系\t341
10．2．2 JDBC的异常转换器\t343
10．2．3 其他持久化技术的异常
转换器\t344
10．3 统一数据访问模板\t344
10．3．1 使用模板和回调机制\t345
10．3．2 Spring为不同持久化技术
所提供的模板类\t347
10．4 数据源\t348
10．4．1 配置一个数据源\t348
10．4．2 获取JNDI数据源\t352
10．4．3 Spring的数据源实现类\t353
10．5 小结\t353
第11章 Spring的事务管理\t355
11．1 数据库事务基础知识\t355
11．1．1 何为数据库事务\t356
11．1．2 数据并发的问题\t357
11．1．3 数据库锁机制\t359
11．1．4 事务隔离级别\t360
11．1．5 JDBC对事务的支持\t361
11．2 ThreadLocal基础知识\t362
11．2．1 ThreadLocal是什么\t363
11．2．2 ThreadLocal的接口方法\t363
11．2．3 一个TheadLocal实例\t364
11．2．4 与Thread同步机制的比较\t366
11．2．5 Spring使用ThreadLocal解决
线程安全问题\t366
11．3 Spring对事务管理的支持\t368
11．3．1 事务管理关键抽象\t369
11．3．2 Spring的事务管理器实现类\t371
11．3．3 事务同步管理器\t374
11．3．4 事务传播行为\t375
11．4 编程式的事务管理\t376
11．5 使用XML配置声明式事务\t377
11．5．1 一个将被实施事务增强的
服务接口\t379
11．5．2 使用原始的TransactionProxy
FactoryBean\t379
11．5．3 基于aop/tx命名空间的配置\t382
11．6 使用注解配置声明式事务\t385
11．6．1 使用@Transactional注解\t385
11．6．2 通过AspectJ LTW引入事务
切面\t389
11．7 集成特定的应用服务器\t390
11．7．1 BEA WebLogic\t390
11．7．2 WebSphere\t390
11．8 小结\t390
第12章 Spring的事务管理难点剖析\t392
12．1 DAO和事务管理的牵绊\t393
12．1．1 JDBC访问数据库\t393
12．1．2 Hibernate访问数据库\t395
12．2 应用分层的迷惑\t398
12．3 事务方法嵌套调用的迷茫\t401
12．3．1 Spring事务传播机制回顾\t401
12．3．2 相互嵌套的服务方法\t402
12．4 多线程的困惑\t405
12．4．1 Spring通过单实例化Bean
简化多线程问题\t405
12．4．2 启动独立线程调用事务
方法\t405
12．5 联合军种作战的混乱\t408
12．5．1 Spring事务管理器的应对\t408
12．5．2 Hibernate+Spring JDBC
混合框架的事务管理\t408
12．6 特殊方法成漏网之鱼\t412
12．6．1 哪些方法不能实施Spring
AOP事务\t412
12．6．2 事务增强遗漏实例\t413
12．7 数据连接泄露\t416
12．7．1 底层连接资源的访问问题\t416
12．7．2 Spring JDBC数据连接泄露\t417
12．7．3 事务环境下通过DataSource
Utils获取数据连接\t420
12．7．4 无事务环境下通过DataSource
Utils获取数据连接\t422
12．7．5 JdbcTemplate如何做到对连接
泄露的免疫\t424
12．7．6 使用TransactionAwareData
SourceProxy\t425
12．7．7 其他数据访问技术的等价类\t426
12．8 小结\t426
第13章 使用Spring JDBC访问
数据库\t428
13．1 使用Spring JDBC\t428
13．1．1 JdbcTemplate小试牛刀\t429
13．1．2 在DAO中使用Jdbc
Template\t429
13．2 基本的数据操作\t431
13．2．1 更改数据\t431
13．2．2 返回数据库的表自增主键值\t434
13．2．3 批量更改数据\t436
13．2．4 查询数据\t437
13．2．5 查询单值数据\t440
13．2．6 调用存储过程\t442
13．3 BLOB/CLOB类型数据的操作\t444
13．3．1 如何获取本地数据连接\t445
13．3．2 相关的操作接口\t446
13．3．3 插入LOB类型的数据\t448
13．3．4 以块数据方式读取LOB
数据\t450
13．3．5 以流数据方式读取LOB
数据\t451
13．4 自增键和行集\t452
13．4．1 自增键的使用\t452
13．4．2 如何规划主键方案\t454
13．4．3 以行集返回数据\t456
13．5 NamedParameterJdbcTemplate
模板类\t456
13．6 小结\t459
第14章 整合其他ORM框架\t460
14．1 Spring整合ORM技术\t460
14．2 在Spring中使用Hibernate\t462
14．2．1 配置SessionFactory\t462
14．2．2 使用HibernateTemplate\t465
14．2．3 处理LOB类型的数据\t469
14．2．4 添加Hibernate事件监听器\t470
14．2．5 使用原生的Hibernate API\t471
14．2．6 使用注解配置\t472
14．2．7 事务处理\t474
14．2．8 延迟加载问题\t475
14．3 在Spring中使用MyBatis\t476
14．3．1 配置SqlMapClient\t476
14．3．2 在Spring中配置MyBatis\t478
14．3．3 编写MyBatis的DAO\t479
14．4 DAO层设计\t482
14．4．1 DAO基类设计\t482
14．4．2 查询接口方法设计\t484
14．4．3 分页查询接口设计\t486
14．5 小结\t487
第4篇 应用篇
第15章 Spring Cache\t490
15．1 缓存概述\t490
15．1．1 缓存的概念\t490
15．1．2 使用Spring Cache\t493
15．2 掌握Spring Cache抽象\t498
15．2．1 缓存注解\t498
15．2．2 缓存管理器\t504
15．2．3 使用SpEL表达式\t506
15．2．4 基于XML的Cache声明\t506
15．2．5 以编程方式初始化缓存\t507
15．2．6 自定义缓存注解\t509
15．3 配置Cache存储\t509
15．3．1 EhCache\t510
15．3．2 Guava\t510
15．3．3 HazelCast\t511
15．3．4 GemFire\t511
15．3．5 JSR-107 Cache\t511
15．4 实战经验\t513
15．5 小结\t514
第16章 任务调度和异步执行器\t516
16．1 任务调度概述\t516
16．2 Quartz快速进阶\t517
16．2．1 Quartz基础结构\t518
16．2．2 使用SimpleTrigger\t520
16．2．3 使用CronTrigger\t522
16．2．4 使用Calendar\t526
16．2．5 任务调度信息存储\t527
16．3 在Spring中使用Quartz\t530
16．3．1 创建JobDetail\t530
16．3．2 创建Trigger\t533
16．3．3 创建Scheduler\t534
16．4 在Spring中使用JDK Timer\t536
16．4．1 Timer和TimerTask\t536
16．4．2 Spring对Java Timer的支持\t539
16．5 Spring对Java 5．0 Executor的
支持\t540
16．5．1 了解Java 5．0的Executor\t541
16．5．2 Spring对Executor所提供的
抽象\t543
16．6 实际应用中的任务调度\t544
16．6．1 如何产生任务\t545
16．6．2 任务调度对应用程序集群的
影响\t547
16．6．3 任务调度云\t547
16．6．4 Web应用程序中调度器的
启动和关闭问题\t549
16．7 小结\t552
第17章 Spring MVC\t553
17．1 Spring MVC体系概述\t554
17．1．1 体系结构\t554
17．1．2 配置DispatcherServlet\t555
17．1．3 一个简单的实例\t560
17．2 注解驱动的控制器\t565
17．2．1 使用@RequestMapping
映射请求\t565
17．2．2 请求处理方法签名\t569
17．2．3 使用矩阵变量绑定参数\t570
17．2．4 请求处理方法签名详细说明\t571
17．2．5 使用HttpMessageConverter
＜T＞\t575
17．2．6 使用@RestController和AsyncRestTemplate\t584
17．2．7 处理模型数据\t586
17．3 处理方法的数据绑定\t591
17．3．1 数据绑定流程剖析\t592
17．3．2 数据转换\t592
17．3．3 数据格式化\t598
17．3．4 数据校验\t602
17．4 视图和视图解析器\t611
17．4．1 认识视图\t611
17．4．2 认识视图解析器\t612
17．4．3 JSP和JSTL\t613
17．4．4 模板视图\t618
17．4．5 Excel\t621
17．4．6 PDF\t623
17．4．7 输出XML\t625
17．4．8 输出JSON\t626
17．4．9 使用XmlViewResolver\t626
17．4．10 使用ResourceBundleView
Resolver\t627
17．4．11 混合使用多种视图技术\t628
17．5 本地化解析\t630
17．5．1 本地化的概念\t630
17．5．2 使用CookieLocaleResolver\t631
17．5．3 使用SessionLocaleResolver\t632
17．5．4 使用LocaleChange
Interceptor\t632
17．6 文件上传\t633
17．6．1 配置MultipartResolver\t633
17．6．2 编写控制器和文件上传表单
页面\t633
17．7 WebSocket支持\t634
17．7．1 使用WebSocket\t634
17．7．2 WebSocket的限制\t638
17．8 杂项\t639
17．8．1 静态资源处理\t639
17．8．2 装配拦截器\t643
17．8．3 异常处理\t644
17．8．4 RequestContextHolder的
使用\t646
17．9 小结\t646
第18章 实战案例开发\t648
18．1 论坛案例概述\t648
18．1．1 论坛整体功能结构\t648
18．1．2 论坛用例描述\t649
18．1．3 主要功能流程描述\t651
18．2 系统设计\t655
18．2．1 技术框架选择\t655
18．2．2 采用Maven构建项目\t656
18．2．3 单元测试类包结构规划\t657
18．2．4 系统架构图\t658
18．2．5 PO类设计\t658
18．2．6 持久层设计\t659
18．2．7 服务层设计\t660
18．2．8 Web层设计\t661
18．2．9 数据库设计\t662
18．3 开发前的准备\t663
18．4 持久层开发\t664
18．4．1 PO类\t664
18．4．2 DAO基类\t666
18．4．3 通过扩展基类定义DAO类\t670
18．4．4 DAO Bean的装配\t672
18．4．5 使用Hibernate二级缓存\t673
18．5 对持久层进行测试\t675
18．5．1 配置Unitils测试环境\t675
18．5．2 准备测试数据库及测试
数据\t676
18．5．3 编写DAO测试基类\t677
18．5．4 编写BoardDao测试用例\t678
18．6 服务层开发\t680
18．6．1 UserService的开发\t680
18．6．2 ForumService的开发\t681
18．6．3 服务类Bean的装配\t683
18．7 对服务层进行测试\t684
18．7．1 编写Service测试基类\t685
18．7．2 编写ForumService测试
用例\t685
18．8 Web层开发\t687
18．8．1 BaseController的基类\t687
18．8．2 用户登录和注销\t689
18．8．3 用户注册\t691
18．8．4 论坛管理\t692
18．8．5 论坛普通功能\t694
18．8．6 分页显示论坛版块的主题
帖子\t696
18．8．7 web．xml配置\t700
18．8．8 Spring MVC配置\t702
18．9 对Web层进行测试\t703
18．9．1 编写Web测试基类\t703
18．9．2 编写ForumManageController
测试用例\t704
18．10 开发环境部署\t705
18．11 项目配置实战经验\t708
18．11．1 “传统的”Web项目属性
文件\t708
18．11．2 如何规划便于部署的Web
项目属性文件\t709
18．11．3 数据源的配置\t710
18．12 小结\t712
第5篇 提高篇
第19章 Spring OXM\t714
19．1 认识XML解析技术\t714
19．1．1 什么是XML\t714
19．1．2 XML的处理技术\t715
19．2 XML处理利器：XStream\t717
19．2．1 XStream概述\t717
19．2．2 快速入门\t718
19．2．3 使用XStream别名\t720
19．2．4 XStream转换器\t721
19．2．5 XStream注解\t723
19．2．6 流化对象\t725
19．2．7 持久化API\t726
19．2．8 额外功能：处理JSON\t727
19．3 其他常见的O/X Mapping开源
项目\t729
19．3．1 JAXB\t729
19．3．2 Castor\t733
19．3．3 JiBX\t738
19．3．4 总结比较\t741
19．4 与Spring OXM整合\t742
19．4．1 Spring OXM概述\t742
19．4．2 整合OXM实现者\t744
19．4．3 如何在Spring中进行配置\t744
19．4．4 Spring OXM简单实例\t747
19．5 小结\t749
第20章 实战型单元测试\t750
20．1 单元测试概述\t751
20．1．1 为什么需要单元测试\t751
20．1．2 单元测试之误解\t752
20．1．3 单元测试之困境\t754
20．1．4 单元测试基本概念\t755
20．2 TestNG快速进阶\t757
20．2．1 TestNG概述\t757
20．2．2 TestNG生命周期\t758
20．2．3 使用TestNG\t758
20．3 模拟利器Mockito\t763
20．3．1 模拟测试概述\t763
20．3．2 创建Mock对象\t763
20．3．3 设定Mock对象的期望行为
及返回值\t764
20．3．4 验证交互行为\t766
20．4 测试整合之王Unitils\t767
20．4．1 Unitils概述\t767
20．4．2 集成Spring\t770
20．4．3 集成Hibernate\t773
20．4．4 集成DbUnit\t774
20．4．5 自定义扩展模块\t775
20．5 使用Unitils测试DAO层\t776
20．5．1 数据库测试的难点\t776
20．5．2 扩展DbUnit用Excel准备
数据\t776
20．5．3 测试实战\t779
20．6 使用Unitils测试Service层\t789
20．7 测试Web层\t794
20．7．1 对LoginController进行单元
测试\t794
20．7．2 使用Spring Servlet API模拟
对象\t795
20．7．3 使用Spring RestTemplate
测试\t797
20．8 小结\t798
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Spring 4.x
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>看透Spring MVC
前言
第一篇　网站基础知识
第1章　网站架构及其演变过程2
1.1　软件的三大类型2
1.2　基础的结构并不简单3
1.3　架构演变的起点5
1.4　海量数据的解决方案5
1.4.1　缓存和页面静态化5
1.4.2　数据库优化6
1.4.3　分离活跃数据8
1.4.4　批量读取和延迟修改8
1.4.5　读写分离9
1.4.6　分布式数据库10
1.4.7　NoSQL和Hadoop10
1.5　高并发的解决方案11
1.5.1　应用和静态资源分离11
1.5.2　页面缓存12
1.5.3　集群与分布式12
1.5.4　反向代理13
1.5.5　CDN14
1.6　底层的优化15
1.7　小结15
第2章　常见协议和标准17
2.1　DNS协议17
2.2　TCP/IP协议与Socket18
2.3　HTTP协议20
2.4　Servlet与Java Web开发22
第3章　DNS的设置23
3.1　DNS解析23
3.2　Windows 7设置DNS服务器24
3.3　Windows设置本机域名和IP的对应关系25
第4章　Java中Socket的用法26
4.1　普通Socket的用法26
4.2　NioSocket的用法28
第5章　自己动手实现HTTP协议33
第6章　详解Servlet37
6.1　Servlet接口37
6.2　GenericServlet40
6.3　HttpServlet41
第7章　Tomcat分析44
7.1　Tomcat的顶层结构及启动过程44
7.1.1　Tomcat的顶层结构44
7.1.2　Bootstrap的启动过程45
7.1.3　Catalina的启动过程47
7.1.4　Server的启动过程48
7.1.5　Service的启动过程50
7.2　Tomcat的生命周期管理52
7.2.1　Lifecycle接口52
7.2.2　LifecycleBase53
7.3　Container分析59
7.3.1　ContainerBase的结构59
7.3.2　Container的4个子容器60
7.3.3　4种容器的配置方法60
7.3.4　Container的启动62
7.4　Pipeline-Value管道69
7.4.1　Pipeline-Value处理模式69
7.4.2　Pipeline-Value的实现方法70
7.5　Connector分析73
7.5.1　Connector的结构73
7.5.2　Connector自身类74
7.5.3　ProtocolHandler77
7.5.4　处理TCP/IP协议的Endpoint77
7.5.5　处理HTTP协议的Processor80
7.5.6　适配器Adapter81
第二篇　俯视Spring MVC
第8章　Spring MVC之初体验84
8.1　环境搭建84
8.2　Spring MVC最简单的配置84
8.2.1　在web.xml中配置Servlet85
8.2.2　创建Spring MVC的xml配置文件85
8.2.3　 创建Controller和view86
8.3　关联spring源代码87
8.4　小结89
第9章　创建Spring MVC之器90
9.1　整体结构介绍90
9.2　HttpServletBean93
9.3　FrameworkServlet95
9.4　DispatcherServlet100
9.5　小结107
第10章　Spring MVC之用108
10.1　HttpServletBean108
10.2　FrameworkServlet108
10.3　DispatcherServlet114
10.4　doDispatch结构118
10.5　小结123
第三篇　Spring MVC组件分析
第11章　组件概览126
11.1　HandlerMapping126
11.2　HandlerAdapter128
11.3　HandlerExceptionResolver130
11.4　ViewResolver131
11.5　RequestToViewNameTranslator133
11.6　LocaleResolver133
11.7　ThemeResolver135
11.8　MultipartResolver137
11.9　FlashMapManager138
11.10　小结139
第12章　HandlerMapping140
12.1　AbstractHandlerMapping140
12.1.1　创建AbstractHandlerMapping之器141
12.1.2　AbstractHandlerMapping之用142
12.2　AbstractUrlHandlerMapping系列143
12.2.1　AbstractUrlHandlerMapping143
12.2.2　SimpleUrlHandlerMapping149
12.2.3　AbstractDetectingUrlHandler-Mapping150
12.3　AbstractHandlerMethodMapping系列152
12.3.1　创建AbstractHandlerMethod-Mapping系列之器153
12.3.2　AbstractHandlerMethodMapping系列之用158
12.4　小结159
第13章　HandlerAdapter161
13.1　RequestMappingHandlerAdapter概述162
13.2　RequestMappingHandlerAdapter自身结构169
13.2.1　创建RequestMappingHandler-Adapter之器169
13.2.2　RequestMappingHandlerAdapter之用173
13.2.3　小结185
13.3　ModelAndViewContainer185
13.4　SessionAttributesHandler和SessionAttributeStore188
13.5　ModelFactory192
13.5.1　初始化Model192
13.5.2　更新Model197
13.6　ServletInvocableHandlerMethod199
13.6.1　HandlerMethod199
13.6.2　InvocableHandlerMethod203
13.6.3　ServletInvocableHandler-Method205
13.7　HandlerMethodArgumentResolver207
13.8　HandlerMethodReturnValue-Handler218
13.9　小结221
第14章　ViewResolver223
14.1　ContentNegotiatingViewResolver225
14.2　AbstractCachingViewResolver系列228
UrlBasedViewResolver231
14.3　小结235
第15章　RequestToViewName-Translator237
第16章　HandlerExceptionResolver239
16.1　AbstractHandlerException-Resolver239
16.2　ExceptionHandlerException-Resolver241
16.3　DefaultHandlerExceptionResolver243
16.4　ResponseStatusExceptionResolver245
16.5　SimpleMappingExceptionResolver246
16.6　小结250
第17章　MultipartResolver251
17.1　StandardServletMultipart-Resolver251
17.2　CommonsMultipartResolver253
17.3　小结256
第18章　LocaleResolver257
第19章　ThemeResolver263
第20章　FlashMapManager266
第四篇　总结与补充
第21章　总结272
21.1　Spring MVC原理总结272
21.2　实际跟踪一个请求275
第22章　异步请求281
22.1　Servlet 3.0对异步请求的支持281
22.1.1　Servlet 3.0处理异步请求实例282
22.1.2　异步请求监听器Async-Listener284
22.2　Spring MVC中的异步请求286
22.2.1　Spring MVC中异步请求相关组件286
22.2.2　Spring MVC对异步请求的支持297
22.2.3　WebAsyncTask和Callable类型异步请求的处理过程及用法301
22.2.4　DeferredResult类型异步请求的处理过程及用法303
22.2.5　ListenableFuture类型异步请求的处理过程及用法305
22.3　小结309
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>看透Spring MVC
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>春之祭
目录
西线地图
前言
序 幕 威尼斯
第一幕
一 巴黎
想象
1913年5月29日
香榭丽舍剧院
佳吉列夫和俄罗斯芭蕾舞团
叛逆
对抗和解放
观众
激起公愤就是成功
二 柏林
圣春
序曲
技术
首都
文化
文化和叛逆
战争即文化
三 在佛兰德斯的原野上
异国他乡的角落
八月枪声
和平降临大地
原因何在
维多利亚时代综论
喝茶还是加蜂蜜吗？
第二幕
四 战争祭
战斗芭蕾
主题
重估一切价值
五 疯狂的理性
他们的办法是不去问为什么
责任
六 神圣的舞蹈
战争之神
会众
七 走向内心
战争即艺术
艺术即形式
艺术和道德
先锋
第三幕
八 夜舞者
新的救主
明星
不要忘记
行程和象征
新世界和旧世界
联想
九 记忆
战争的回声
与死亡为伴
名声
用云彩变戏法的人
十 无尽的春天
德意志，醒来了！
受难的英雄
艺术即生活
神话即现实
“这是无尽的春天！”
致谢
原始资料选
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>春之祭
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>石泉城
石泉城
大瀑布
甜心
少年
赛狗
帝国
冬寒冻死人
乐天派
焰火
共产党
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>石泉城
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring 3.x企业应用开发实战
第1篇 概述
第1章 Spring概述
1.1 认识Spring
1.2 关于SpringSource
1.3 Spring带给我们什么
1.4 Spring体系结构
1.5 Spring 3.0的新功能
1.5.1 核心API更新到Java 5.
1.5.2 Spring表达式语言
1.5.3 可通过Java类提供IoC配置信息
1.5.4 通用类型转换系统和属性格式化系统
1.5.5 数据访问层新增OXM功能
1.5.6 Web层的增强
1.5.7 其他
1.6 Spring对Java版本的要求
1.7 如何获取Spring
1.8 小结
第2章 快速入门
2.1 实例功能概述
2.1.1 比Hello World更适用的实例
2.1.2 实例功能简介
2.2 环境准备
2.2.1 创建库表
2.2.2 建立工程
2.2.3 类包及Spring配置文件规划
2.3 持久层
2.3.1 建立领域对象
2.3.2 UserDao
2.3.3 LoginLogDao
2.3.4 在Spring中装配DAO
2.4 业务层
2.4.1 UserService
2.4.2 在Spring中装配Service
2.4.3 单元测试
2.5 展现层
2.5.1 配置Spring MVC框架
2.5.2 处理登录请求
2.5.3 JSP视图页面
2.6 运行Web应用
2.7 小结
第2篇 IoC和AOP
第3章 IoC容器概述
3.1 IoC概述
3.1.1 通过实例理解IoC的概念
3.1.2 IoC的类型
3.1.3 通过容器完成依赖关系的注入
3.2 相关Java基础知识
3.2.1 简单实例
3.2.2 类装载器ClassLoader
3.2.3 Java反射机制
3.3 资源访问利器
3.3.1 资源抽象接口
3.3.2 资源加载
3.4 BeanFactory和ApplicationContext
3.4.1 BeanFactory介绍
3.4.2 ApplicationContext介绍
3.4.3 父子容器
3.5 Bean的生命周期
3.5.1 BeanFactory中Bean的生命周期
3.5.2 ApplicationContext中Bean的生命周期
3.6 小结
第4章 在IoC容器中装配Bean
4.1 Spring配置概述
4.1.1 Spring容器高层视图
4.1.2 基于XML的配置
4.2 Bean基本配置
4.2.1 装配一个Bean
4.2.2 Bean的命名
4.3 依赖注入
4.3.1 属性注入
4.3.2 构造函数注入
4.3.3 工厂方法注入
4.3.4 选择注入方式的考量
4.4 注入参数详解
4.4.1 字面值
4.4.2 引用其他Bean
4.4.3 内部Bean
4.4.4 null值
4.4.5 级联属性
4.4.6 集合类型属性
4.4.7 简化配置方式
4.4.8 自动装配
4.5 方法注入
4.5.1 lookup方法注入
4.5.2 方法替换
4.6 ＜bean＞之间的关系
4.6.1 继承
4.6.2 依赖
4.6.3 引用
4.7 整合多个配置文件
4.8 Bean作用域
4.8.1 singleton作用域
4.8.2 prototype作用域
4.8.3 Web应用环境相关的Bean作用域
4.8.4 作用域依赖问题
4.9 FactoryBean
4.10 基于注解的配置
4.10.1 使用注解定义Bean
4.10.2 使用注解配置信息启动Spring容器
4.10.3 自动装配Bean
4.10.4 Bean作用范围及生命过程方法
4.11 基于Java类的配置
4.11.1 使用Java类提供Bean定义信息
4.11.2 使用基于Java类的配置信息启动Spring容器
4.12 不同配置方式比较
4.13 小结
第5章 Spring容器高级主题
5.1 Spring容器技术内幕
5.1.1 内部工作机制
5.1.2 BeanDefinition
5.1.3 InstantiationStrategy
5.1.4 BeanWrapper
5.2 属性编辑器
5.2.1 JavaBean的编辑器
5.2.2 Spring默认属性编辑器
5.2.3 自定义属性编辑器
5.3 使用外部属性文件
5.3.1 使用外部属性文件
5.3.2 使用加密的属性文件
5.3.3 属性文件自身的引用
5.4 引用Bean的属性值
5.5 国际化信息
5.5.1 基础知识
5.5.2 MessageSource
5.5.3 容器级的国际化信息资源
5.6 容器事件
5.6.1 Spring事件类结构
5.6.2 解构Spring事件体系的具体实现
5.6.3 一个实例
5.7 小结
第6章 Spring AOP基础
6.1 AOP概述
6.1.1 AOP到底是什么
6.1.2 AOP术语
6.1.3 AOP的实现者
6.2 基础知识
6.2.1 带有横切逻辑的实例
6.2.2 JDK动态代理
6.2.3 CGLib动态代理
6.2.4 AOP联盟
6.2.5 代理知识小结
6.3 创建增强类
6.3.1 增强类型
6.3.2 前置增强
6.3.3 后置增强
6.3.4 环绕增强
6.3.5 异常抛出增强
6.3.6 引介增强
6.4 创建切面
6.4.1 切点类型
6.4.2 切面类型
6.4.3 静态普通方法名匹配切面
6.4.4 静态正则表达式方法匹配切面
6.4.5 动态切面
6.4.6 流程切面
6.4.7 复合切点切面
6.4.8 引介切面
6.5 自动创建代理
6.5.1 实现类介绍
6.5.2 BeanNameAutoProxyCreator
6.5.3 DefaultAdvisorAutoProxyCreator
6.6 小结
第7章 基于@AspectJ和Schema的AOP
7.1 Spring对AOP的支持
7.2 JDK 5.0注解知识快速进阶
7.2.1 了解注解
7.2.2 一个简单的注解类
7.2.3 使用注解
7.2.4 访问注解
7.3 着手使用@AspectJ
7.3.1 使用前的准备
7.3.2 一个简单的例子
7.3.3 如何通过配置使用@AspectJ切面
7.4 @AspectJ语法基础
7.4.1 切点表达式函数
7.4.2 在函数入参中使用通配符
7.4.3 逻辑运算符
7.4.4 不同增强类型
7.4.5 引介增强用法
7.5 切点函数详解
7.5.1 @annotation（）
7.5.2 execution（）
7.5.3 args（）和@args（）
7.5.4 within（）
7.5.5 @within（）和@target（）
7.5.6 target（）的this（）
7.6 @AspectJ进阶
7.6.1 切点复合运算
7.6.2 命名切点
7.6.3 增强织入的顺序
7.6.4 访问连接点信息
7.6.5 绑定连接点方法入参
7.6.6 绑定代理对象
7.6.7 绑定类注解对象
7.6.8 绑定返回值
7.6.9 绑定抛出的异常
7.7 基于Schema配置切面
7.7.1 一个简单切面的配置
7.7.2 配置命名切点
7.7.3 各种增强类型的配置
7.7.4 绑定连接点信息
7.7.5 Advisor配置
7.8 混合切面类型
7.8.1 混合使用各种切面类型
7.8.2 各种切面类型总结
7.9 JVM Class文件字节码转换基础知识
7.9.1 java.lang.instrument包的工作原理
7.9.2 如何向JVM中注册转换器
7.9.3 使用JVM启动参数注册转换器的问题
7.10 使用LTW织入切面
7.10.1 Spring的LoadTimeWeaver
7.10.2 使用LTW织入一个切面
7.10.3 在Tomcat下的配置
7.10.4 在其他Web应用服务器下的配置
7.11 小结
第3篇 数据访问
第8章 Spring对DAO的支持
8.1 Spring的DAO理念
8.2 统一的异常体系
8.2.1 Spring的DAO异常体系
8.2.2 JDBC的异常转换器
8.2.3 其他持久技术的异常转换器
8.3 统一数据访问模板
8.3.1 使用模板和回调机制
8.3.2 Spring为不同持久化技术所提供的模板类
8.4 数据源
8.4.1 配置一个数据源
8.4.2 获取JNDI数据源
8.4.3 Spring的数据源实现类
8.5 小结
第9章 Spring的事务管理
9.1 数据库事务基础知识
9.1.1 何为数据库事务
9.1.2 数据并发的问题
9.1.3 数据库锁机制
9.1.4 事务隔离级别
9.1.5 JDBC对事务支持
9.2 ThreadLocal基础知识
9.2.1 ThreadLocal是什么
9.2.2 ThreadLocal的接口方法
9.2.3 一个TheadLocal实例
9.2.4 与Thread同步机制的比较
9.2.5 Spring使用ThreadLocal解决线程安全问题
9.3 Spring对事务管理的支持
9.3.1 事务管理关键抽象
9.3.2 Spring的事务管理器实现类
9.3.3 事务同步管理器
9.3.4 事务传播行为
9.4 编程式的事务管理
9.5 使用XML配置声明式事务
9.5.1 一个将被实施事务增强的服务接口
9.5.2 使用原始的
TransactionProxyFactoryBean
9.5.3 基于tx/aop命名空间的配置
9.6 使用注解配置声明式事务
9.6.1 使用@Transactional注解
9.6.2 通过AspectJ LTW引入事务切面
9.7 集成特定的应用服务器
9.7.1 BEA WebLogic
9.7.2 BEA WebLogic
9.8 小结
第10章 Spring的事务管理难点剖析
10.1 DAO和事务管理的牵绊
10.1.1 JDBC访问数据库
10.1.2 Hibernate访问数据库
10.2 应用分层的迷惑
10.3 事务方法嵌套调用的迷茫
10.3.1 Spring事务传播机制回顾
10.3.2 相互嵌套的服务方法
10.4 多线程的困惑
10.4.1 Spring通过单实例化Bean简化多线程问题
10.4.2 启动独立线程调用事务方法
10.5 联合军种作战的混乱
10.5.1 Spring事务管理器的应对
10.5.2 Hibernate+Spring JDBC混合框架的事务管理
10.6 特殊方法成漏网之鱼
10.6.1 哪些方法不能实施Spring AOP事务
10.6.2 事务增强遗漏实例
10.7 数据连接泄漏
10.7.1 底层连接资源的访问问题
10.7.2 Spring JDBC数据连接泄漏
10.7.3 通过DataSourceUtils获取数据连接
10.7.4 通过DataSourceUtils获取数据连接
10.7.5 JdbcTemplate如何做到对连接泄漏的免疫
10.7.6 使用TransactionAwareDataSourceProxy
10.7.7 其他数据访问技术的等价类
10.8 小结
第11章 使用Spring JDBC访问数据库
11.1 使用Spring JDBC
11.1.1 JDBCTemplate小试牛刀
11.1.2 在DAO中使用JDBCTemplate
11.2 基本的数据操作
11.2.1 更改数据
11.2.2 返回数据库的表自增主键值
11.2.3 批量更改数据
11.2.4 查询数据
11.2.5 查询单值数据
11.2.6 调用存储过程
11.3 BLOB/CLOB类型数据的操作
11.3.1 如何获取本地数据连接
11.3.2 相关的操作接口
11.3.3 插入Lob类型的数据
11.3.4 以块数据方式读取Lob数据
11.3.5 以流数据方式读取Lob数据
11.4 自增键和行集
11.4.1 自增键的使用
11.4.2 如何规划主键方案
11.4.3 以行集返回数据
11.5 其他类型的JDBCTemplate
11.5.1 NamedParameterJDBCTemplate
11.5.2 SimpleJDBCTemplate
11.6 以OO方式访问数据库
11.6.1 使用MappingSqlQuery查询数据
11.6.2 使用SqlUpdate更新数据
11.6.3 使用StoredProcedure执行存储过程
11.6.4 SqlFunction类
11.7 小结
第12章 整合其他ORM框架
12.1 Spring整合ORM技术
12.2 在Spring中使用Hibernate
12.2.1 配置SessionFactory
12.2.2 使用HibernateTemplate
12.2.3 处理LOB类型数据
12.2.4 添加Hibernate事件监听器
12.2.5 使用原生Hibernate API
12.2.6 使用注解配置
12.2.7 事务处理
12.2.8 延迟加载的问题
12.3 在Spring中使用myBatis
12.3.1 配置SqlMapClient
12.3.2 在Spring配置myBatis
12.3.3 编写myBatis的DAO
12.5 DAO层设计
12.5.1 DAO基类的设计
12.5.2 查询接口方法的设计
12.5.3 分页查询接口设计
12.6 小结
第4篇 业务层及Web层技术
第13章 任务调度和异步执行器
13.1 任务调度概述
13.2 Quartz快速进阶
13.2.1 Quartz基础结构
13.2.2 使用SimpleTrigger
13.2.3 使用CronTrigger
13.2.4 使用Calendar
13.2.5 任务调度信息存储
13.3 在Spring中使用Quartz
13.3.1 创建JobDetail
13.3.2 创建Trigger
13.3.3 创建Scheduler
13.4 Spring中使用JDK Timer
13.4.1 Timer和TimerTask
13.4.2 Spring对JDK Timer的支持
13.5 Spring对JDK 5.0 Executor的支持
13.5.1 了解JDK 5.0的Executor
13.5.2 Spring对Executor所提供的抽象
13.6 实际应用中的任务调度
13.6.1 如何产生任务
13.6.2 任务调度对应用程序集群的影响
13.6.3 任务调度云
13.6.4 Web应用程序中调度器的启动和关闭问题
13.7 小结
第14章 使用OXM进行对象XML映射
14.1 认识XML解析技术
14.1.1 什么是XML
14.1.2 XML的处理技术
14.2 XML处理利器：XStream
14.2.1 XStream概述
14.2.2 快速入门
14.2.3 使用XStream别名
14.2.4 XStream转换器
14.2.5 XStream注解
14.2.6 流化对象
14.2.7 持久化API
14.2.8 额外功能：处理JSON
14.3 其他常见O/X Mapping开源项目
14.3.1 JAXB
14.3.2 XMLBeans
14.3.3 Castor
14.3.4 JiBX
14.3.5 总结比较
14.4 与Spring OXM整合
14.4.1 Spring OXM概述
14.4.2 整合OXM实现者
14.4.3 如何在Spring中进行配置
14.4.4 Spring OXM 简单实例
14.5 小结
第15章 Spring MVC
15.1 Spring MVC概述
15.1.1 体系结构
15.1.2 配置DispatcherServlet
15.1.3 一个简单的实例
15.2 注解驱动的控制器
15.2.1 使用@RequestMapping映射请求
15.2.2 请求处理方法签名概述
15.2.3 处理方法签名详细说明
15.2.4 使用HttpMessageConverter＜T＞
15.2.5 处理模型数据
15.3 处理方法的数据绑定
15.3.1 数据绑定流程剖析
15.3.2 数据转换
15.3.3 数据格式化
15.3.4 数据校验
15.4 视图和视图解析器
15.4.1 认识视图
15.4.2 认识视图解析器
15.4.3 JSP和JSTL
15.4.4 模板视图
15.4.5 Excel
15.4.6 PDF
15.4.7 输出XML
15.4.8 输出JSON
15.4.9 使用XmlViewResolver
15.4.10 使用ResourceBundle ViewResolver
15.4.11 混合使用多种视图技术
15.5 本地化解析
15.5.1 本地化概述
15.5.2 使用CookieLocaleResolver
15.5.3 使用SessionLocaleResolver
15.5.4 使用LocaleChangeInterceptor
15.6 文件上传
15.6.1 配置MultipartResolver
15.6.2 编写控制器和文件上传表单页面
15.7 杂项
15.7.1 静态资源处理
15.7.2 装配拦截器
15.7.3 异常处理
15.8 小结
第5篇 测试及实战
第16章 实战型单元测试
16.1 单元测试概述
16.1.1 为什么需要单元测试
16.1.2 单元测试之误解
16.1.3 单元测试之困境
16.1.4 单元测试基本概念
16.2 JUnit 4快速进阶
16.2.1 JUnit 4概述
16.2.2 JUnit 4生命周期
16.2.3 使用JUnit
16.3 模拟利器Mockito
16.3.1 模拟测试概述
16.3.2 创建Mock对象
16.3.3 设定Mock对象的期望行为及返回值
16.3.4 验证交互行为
16.4 测试整合之王Unitils
16.4.1 Unitils概述
16.4.2 集成Spring
16.4.3 集成Hibernate
16.4.4 集成Dbunit
16.4.5 自定义扩展模块
16.5 使用Unitils测试DAO层
16.5.1 数据库测试的难点
16.5.2 扩展Dbunit用Excel准备数据
16.5.3 测试实战
16.6 使用unitils测试Service层
16.7 测试Web层
16.7.1 对LoginController进行单元测试
16.7.2 使用Spring Servlet API模拟对象
16.7.3 使用Spring RestTemplate测试
16.7.4 使用Selenium测试
16.8 小结
第17章 实战案例开发
17.1 论坛案例概述
17.1.1 论坛整体功能结构
17.1.2 论坛用例描述
17.1.3 主要功能流程描述
17.2 系统设计
17.2.1 技术框架选择
17.2.2 Web目录结构及类包结构规划
17.2.3 单元测试类包结构规划
17.2.4 系统的结构图
17.2.5 PO的类设计
17.2.6 持久层设计
17.2.7 服务层设计
17.2.8 Web层设计
17.2.9 数据库设计
17.3 开发前的准备
17.4 持久层开发
17.4.1 PO类
17.4.2 DAO基类
17.4.3 通过扩展基类所定义DAO类
17.4.4 DAO Bean的装配
17.4.5 使用Hibernate二级缓存
17.5 对持久层进行测试
17.5.1 配置Unitils测试环境
17.5.2 准备测试数据库及测试数据
17.5.3 编写DAO测试基类
17.5.4 编写BoardDao测试用例
17.6 服务层开发
17.6.1 UserService的开发
17.6.2 ForumService的开发
17.6.3 服务类Bean的装配
17.7 对服务层进行测试
17.7.1 编写Service测试基类
17.7.2 编写ForumService测试用例
17.8 Web层开发
17.8.1 BaseController的基类
17.8.2 用户登录和注销
17.8.3 用户注册
17.8.4 论坛管理
17.8.5 论坛普通功能
17.8.6 分页显示论坛版块的主题帖子
17.8.7 web.xml配置
17.8.8 Spring MVC配置
17.9 对Web层进行测试
17.9.1 编写Web测试基类
17.9.2 编写ForumManageController测试用例
17.10 部署和运行应用
17.11 小结
以下内容详见本书配书光盘：
附录A JavaMail发送邮件
附录B 在Spring中开发Web Service
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring 3.x企业应用开发实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE互联网轻量级框架整合开发
第1部分  入门和技术基础
第1章  认识SSM框架和Redis	2
1.1  Spring框架	2
1.1.1  Spring IoC简介	2
1.1.2  Spring AOP	4
1.2  MyBatis简介	6
1.2.1  Hibernate简介	7
1.2.2  MyBatis	8
1.2.3  Hibernate和MyBatis的区别	11
1.3  Spring MVC简介	11
1.4  最流行的NoSQL——Redis	12
1.5  SSM+Redis结构框图及概述	13
第2章  Java设计模式	15
2.1  Java反射技术	15
2.1.1  通过反射构建对象	15
2.1.2  反射方法	17
2.1.3  实例	18
2.2  动态代理模式和责任链模式	19
2.2.1  JDK动态代理	20
2.2.2  CGLIB动态代理	22
2.2.3  拦截器	24
2.2.4  责任链模式	28
2.3  观察者（Observer）模式	30
2.3.1  概述	31
2.3.2  实例	32
2.4  工厂模式和抽象工厂模式	35
2.4.1  普通工厂（Simple Factory）模式	35
2.4.2  抽象工厂（Abstract Factory）模式	36
2.5  建造者（Builder）模式	38
2.5.1  概述	38
2.5.2  Builder模式实例	39
2.6  总结	41
第2部分  互联网持久框架——MyBatis
第3章  认识MyBatis核心组件	44
3.1  持久层的概念和MyBatis的特点	44
3.2  准备MyBatis环境	45
3.3  MyBatis的核心组件	46
3.4  SqlSessionFactory（工厂接口）	47
3.4.1  使用XML构建SqlSessionFactory	48
3.4.2  使用代码创建SqlSessionFactory	50
3.5  SqlSession	50
3.6  映射器	51
3.6.1  用XML实现映射器	52
3.6.2  注解实现映射器	53
3.6.3  SqlSession发送SQL	54
3.6.4  用Mapper接口发送SQL	55
3.6.5  对比两种发送SQL方式	55
3.7  生命周期	55
3.7.1  SqlSessionFactoryBuilder	56
3.7.2  SqlSessionFactory	56
3.7.3  SqlSession	56
3.7.4  Mapper	56
3.8  实例	57
第4章  MyBatis配置	63
4.1  概述	63
4.2  properties属性	64
4.2.1  property子元素	64
4.2.2  使用properties文件	65
4.2.3  使用程序传递方式传递参数	66
4.2.4  总结	66
4.3  settings设置	66
4.4  typeAliases别名	69
4.4.1  系统定义别名	69
4.4.2  自定义别名	72
4.5  typeHandler类型转换器	72
4.5.1  系统定义的typeHandler	73
4.5.2  自定义typeHandler	78
4.5.3  枚举typeHandler	81
4.5.4  文件操作	86
4.6  ObjectFactory（对象工厂）	87
4.7  插件	89
4.8  environments（运行环境）	89
4.8.1  transactionManager（事务管理器）	90
4.8.2  environment数据源环境	92
4.9  databaseIdProvider数据库厂商标识	95
4.9.1  使用系统默认的databaseIdProvider	95
4.9.2  不使用系统规则	98
4.10  引入映射器的方法	99
第5章  映射器	102
5.1  概述	102
5.2  select元素——查询语句	103
5.2.1  简单的select元素的应用	104
5.2.2  自动映射和驼峰映射	105
5.2.3  传递多个参数	106
5.2.4  使用resultMap映射结果集	109
5.2.5  分页参数RowBounds	110
5.3  insert元素——插入语句	112
5.3.1  概述	112
5.3.2  简单的insert语句的应用	113
5.3.3  主键回填	113
5.3.4  自定义主键	114
5.4  update元素和delete元素	114
5.5  sql元素	115
5.6  参数	116
5.6.1  概述	116
5.6.2  存储过程参数支持	117
5.6.3  特殊字符串的替换和处理（#和$）	117
5.7  resultMap元素	118
5.7.1  resultMap元素的构成	118
5.7.2  使用map存储结果集	119
5.7.3  使用POJO存储结果集	119
5.8  级联	120
5.8.1  MyBatis中的级联	121
5.8.2  建立POJO	124
5.8.3  配置映射文件	127
5.8.4  N+1问题	133
5.8.5  延迟加载	133
5.8.6  另一种级联	137
5.8.7  多对多级联	140
5.9  缓存	143
5.9.1  一级缓存和二级缓存	144
5.9.2  缓存配置项、自定义和引用	147
5.10  存储过程	149
5.10.1  IN和OUT参数存储过程	150
5.10.2  游标的使用	152
第6章  动态SQL	155
6.1  概述	155
6.2  if元素	156
6.3  choose、when、otherwise元素	156
6.4  trim、where、set元素	157
6.5  foreach元素	159
6.6  用test的属性判断字符串	159
6.7  bind元素	160
第7章  MyBatis的解析和运行原理	162
7.1  构建SqlSessionFactory过程	163
7.1.1  构建Configuration	165
7.1.2  构建映射器的内部组成	165
7.1.3  构建SqlSessionFactory	167
7.2  SqlSession运行过程	168
7.2.1  映射器（Mapper）的动态代理	168
7.2.2  SqlSession下的四大对象	172
7.2.3  SqlSession运行总结	179
第8章  插件	181
8.1  插件接口	181
8.2  插件的初始化	182
8.3  插件的代理和反射设计	183
8.4  常用的工具类——MetaObject	186
8.5  插件开发过程和实例	187
8.5.1  确定需要拦截的签名	187
8.5.2  实现拦截方法	189
8.5.3  配置和运行	191
8.5.4  插件实例——分页插件	192
8.6  总结	205
第3部分  Spring基础
第9章  Spring IoC的概念	208
9.1  Spring的概述	208
9.2  Spring IoC概述	210
9.2.1  主动创建对象	211
9.2.2  被动创建对象	213
9.2.3  Spring IoC阐述	214
9.3  Spring IoC容器	215
9.3.1  Spring IoC容器的设计	215
9.3.2  Spring IoC容器的初始化和依赖注入	218
9.3.3  Spring Bean的生命周期	219
9.4  小结	223
第10章  装配Spring Bean	224
10.1  依赖注入的3种方式	224
10.1.1  构造器注入	224
10.1.2  使用setter注入	225
10.1.3  接口注入	226
10.2  装配Bean概述	227
10.3  通过XML配置装配Bean	228
10.3.1  装配简易值	228
10.3.2  装配集合	229
10.3.3  命名空间装配	233
10.4  通过注解装配Bean	235
10.4.1  使用@Component装配Bean	236
10.4.2  自动装配——@Autowired	239
10.4.3  自动装配的歧义性（@Primary和@Qualifier）	241
10.4.4  装载带有参数的构造方法类	244
10.4.5  使用@Bean装配Bean	245
10.4.6  注解自定义Bean的初始化和销毁方法	245
10.5  装配的混合使用	246
10.6  使用Profile	249
10.6.1  使用注解@Profile配置	249
10.6.2  使用XML定义Profile	250
10.6.3  启动Profile	252
10.7  加载属性（properties）文件	254
10.7.1  使用注解方式加载属性文件	254
10.7.2  使用XML方式加载属性文件	257
10.8  条件化装配Bean	258
10.9  Bean的作用域	259
10.10  使用Spring表达式（Spring EL）	261
10.10.1  Spring EL相关的类	261
10.10.2  Bean的属性和方法	264
10.10.3  使用类的静态常量和方法	265
10.10.4  Spring EL运算	265
第11章  面向切面编程	267
11.1  一个简单的约定游戏	267
11.1.1  约定规则	267
11.1.2  读者的代码	269
11.1.3  笔者的代码	271
11.2  Spring AOP的基本概念	274
11.2.1  AOP的概念和使用原因	274
11.2.2  面向切面编程的术语	278
11.2.3  Spring对AOP的支持	280
11.3  使用@AspectJ注解开发Spring AOP	280
11.3.1  选择切点	281
11.3.2  创建切面	281
11.3.3  连接点	283
11.3.4  测试AOP	285
11.3.5  环绕通知	287
11.3.6  织入	289
11.3.7  给通知传递参数	289
11.3.8  引入	290
11.4  使用XML配置开发Spring AOP	293
11.4.1  前置通知、后置通知、返回通知和异常通知	294
11.4.2  环绕通知	296
11.4.3  给通知传递参数	297
11.4.4  引入	298
11.5  经典Spring AOP应用程序	299
11.6  多个切面	301
11.7  小结	306
第12章  Spring和数据库编程	307
12.1  传统的JDBC代码的弊端	307
12.2  配置数据库资源	309
12.2.1  使用简单数据库配置	309
12.2.2  使用第三方数据库连接池	310
12.2.3  使用JNDI数据库连接池	310
12.3  JDBC代码失控的解决方案——jdbcTemplate	311
12.3.1  jdbcTemplate的增、删、查、改	312
12.3.2  执行多条SQL	314
12.3.3  jdbcTemplate的源码分析	315
12.4  MyBatis-Spring项目	317
12.4.1  配置SqlSessionFactoryBean	318
12.4.2  SqlSessionTemplate组件	322
12.4.3  配置MapperFactoryBean	324
12.4.4  配置MapperScannerConfigurer	324
12.4.5  测试Spring+MyBatis	327
第13章  深入Spring数据库事务管理	330
13.1  Spring数据库事务管理器的设计	331
13.1.1  配置事务管理器	333
13.1.2  用Java配置方式实现Spring数据库事务	334
13.2  编程式事务	336
13.3  声明式事务	337
13.3.1  Transactional的配置项	337
13.3.2  使用XML进行配置事务管理器	339
13.3.3  事务定义器	340
13.3.4  声明式事务的约定流程	341
13.4  数据库的相关知识	343
13.4.1  数据库事务ACID特性	343
13.4.2  丢失更新	343
13.4.3  隔离级别	344
13.5  选择隔离级别和传播行为	347
13.5.1  选择隔离级别	347
13.5.2  传播行为	348
13.6  在Spring+MyBatis组合中使用事务	350
13.7  @Transactional的自调用失效问题	358
13.8  典型错误用法的剖析	363
13.8.1  错误使用Service	363
13.8.2  过长时间占用事务	364
13.8.3  错误捕捉异常	366
第4部分  Spring MVC框架
第14章  Spring MVC的初始化和流程	370
14.1  MVC设计概述	370
14.1.1  Spring MVC的架构	372
14.1.2  Spring MVC组件与流程	372
14.1.3  Spring MVC入门的实例	374
14.2  Spring MVC初始化	378
14.2.1  初始化Spring IoC上下文	378
14.2.2  初始化映射请求上下文	379
14.2.3  使用注解配置方式初始化	386
14.3  Spring MVC开发流程详解	389
14.3.1  配置@RequestMapping	390
14.3.2  控制器的开发	391
14.3.3  视图渲染	396
14.4  小结	398
第15章  深入Spring MVC组件开发	399
15.1  控制器接收各类请求参数	399
15.1.1  接收普通请求参数	401
15.1.2  使用@RequestParam注解获取参数	402
15.1.3  使用URL传递参数	403
15.1.4  传递JSON参数	404
15.1.5  接收列表数据和表单序列化	406
15.2  重定向	409
15.3  保存并获取属性参数	412
15.3.1  注解@RequestAttribute	412
15.3.2  注解@SessionAttribute和注解@SessionAttributes	414
15.3.3  注解@CookieValue和注解@RequestHeader	417
15.4  拦截器	417
15.4.1  拦截器的定义	418
15.4.2  拦截器的执行流程	419
15.4.3  开发拦截器	419
15.4.4  多个拦截器执行的顺序	421
15.5  验证表单	424
15.5.1  使用JSR 303注解验证输入内容	425
15.5.2  使用验证器	429
15.6  数据模型	432
15.7  视图和视图解析器	434
15.7.1  视图	434
15.7.2  视图解析器	436
15.7.3  实例：Excel视图的使用	438
15.8  上传文件	441
15.8.1  MultipartResolver概述	442
15.8.2  提交上传文件表单	446
第16章  Spring MVC高级应用	449
16.1  Spring MVC的数据转换和格式化	449
16.1.1  HttpMessageConverter和JSON消息转换器	451
16.1.2  一对一转换器（Converter）	455
16.1.3  数组和集合转换器GenericConverter	458
16.1.4  使用格式化器（Formatter）	463
16.2  为控制器添加通知	466
16.3  处理异常	470
16.4  国际化	471
16.4.1  概述	471
16.4.2  MessageSource接口	473
16.4.3  CookieLocaleResolver和SessionLocaleResolver	475
16.4.4  国际化拦截器（LocaleChangeInterceptor）	477
16.4.5  开发国际化	477
第5部分  Redis应用
第17章  Redis概述	480
17.1  Redis在Java Web中的应用	481
17.1.1  缓存	481
17.1.2  高速读/写场合	482
17.2  Redis基本安装和使用	483
17.2.1  在Windows下安装Redis	483
17.2.2  在Linux下安装Redis	485
17.3  Redis的Java API	486
17.3.1  在Java程序中使用Redis	487
17.3.2  在Spring中使用Redis	488
17.4  简介Redis的6种数据类型	494
17.5  Redis和数据库的异同	495
第18章  Redis数据结构常用命令	496
18.1  Redis数据结构——字符串	497
18.2  Redis数据结构——哈希	502
18.3  Redis数据结构——链表（linked-list）	506
18.4  Redis数据结构——集合	513
18.5  Redis数据结构——有序集合	516
18.5.1  Redis基础命令	516
18.5.2  spring-data-redis对有序集合的封装	518
18.5.3  使用Spring操作有序集合	520
18.6  基数——HyperLogLog	522
18.7  小结	524
第19章  Redis的一些常用技术	525
19.1  Redis的基础事务	526
19.2  探索Redis事务回滚	528
19.3  使用watch命令监控事务	529
19.4  流水线（pipelined）	532
19.5  发布订阅	534
19.6  超时命令	538
19.7  使用Lua语言	540
19.7.1  执行输入Lua程序代码	541
19.7.2  执行Lua文件	544
19.8  小结	547
第20章  Redis配置	548
20.1  Redis基础配置文件	548
20.2  Redis备份（持久化）	549
20.3  Redis内存回收策略	552
20.4  复制	553
20.4.1  主从同步基础概念	553
20.4.2  Redis主从同步配置	554
20.4.3  Redis主从同步的过程	555
20.5  哨兵（Sentinel）模式	556
20.5.1  哨兵模式概述	557
20.5.2  搭建哨兵模式	558
20.5.3  在Java中使用哨兵模式	559
20.5.4  哨兵模式的其他配置项	563
第21章  Spring缓存机制和Redis的结合	565
21.1  Redis和数据库的结合	565
21.1.1  Redis和数据库读操作	566
21.1.2  Redis和数据库写操作	567
21.2  使用Spring缓存机制整合Redis	568
21.2.1  准备测试环境	568
21.2.2  Spring的缓存管理器	573
21.2.3  缓存注解简介	575
21.2.4  注解@Cacheable和@CachePut	576
21.2.5  注解@CacheEvict	580
21.2.6  不适用缓存的方法	581
21.2.7  自调用失效问题	582
21.3  RedisTemplate的实例	582
第6部分  SSM框架+Redis实践应用
第22章  高并发业务	586
22.1  互联系统应用架构基础分析	586
22.2  高并发系统的分析和设计	588
22.2.1  有效请求和无效请求	588
22.2.2  系统设计	590
22.2.3  数据库设计	591
22.2.4  动静分离技术	593
22.2.5  锁和高并发	594
22.3  搭建抢红包开发环境和超发现象	595
22.3.1  搭建Service层和DAO层	595
22.3.2  使用全注解搭建SSM开发环境	602
22.3.3  开发控制器和超发现象测试	609
22.4  悲观锁	611
22.5  乐观锁	614
22.5.1  CAS原理概述	614
22.5.2  ABA问题	615
22.5.3  乐观锁实现抢红包业务	616
22.5.4  乐观锁重入机制	618
22.6  使用Redis实现抢红包	621
22.6.1  使用注解方式配置Redis	621
22.6.2  数据存储设计	622
22.6.3  使用Redis实现抢红包	627
22.7  各类方式的优缺点	631
附录A  数据库表模型	633
附录B  DispatcherServlet流程源码分析	637
附录C  JSTL常用标签	648
附录D  spring data redis项目分析	660
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE互联网轻量级框架整合开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
第一章        明日寓言
第二章        忍受的义务
第三章        死神的炼金术
第四章        地表水与地下水
第五章        土壤王国
第六章        地球的绿色外衣
第七章        无谓的浩劫
第八章        没有鸟鸣的地方
第九章        一潭死水
第十章        天穹降下死亡之雨
第十一章    超乎波吉亚家族的想象
第十二章    人类付出的代价
第十三章    透过一扇狭小的窗子
第十四章    患癌率：四分之一
第十五章    自然的报复
第十六章    雪崩前夕的轰鸣
第十七章    另一条路
译后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
蕾切尔·卡逊的《寂静的春天》25周年纪念版简介
致 谢
第一章 明天的寓言
第二章 忍受的义务
第三章 死神的药剂
第四章 地表水和地下海
第五章 土壤的王国
第六章 地球的绿色斗篷
第七章 不必要的浩劫
第八章 再听不到鸟儿的歌声
第九章 死亡之河
第十章 天降灾难
第十一章 超越波吉亚家族的想象
第十二章 人类的代价
第十三章 透过狭小的窗子
第十四章 每四个中就有一个
第十五章 自然的反击
第十六章 雪崩的隆隆声
第十七章 另一条路
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>春之祭
目录
西线地图
前言
序 幕  威尼斯
第一幕
一 巴黎
想象
1913年5月29日
香榭丽舍剧院
佳吉列夫和俄罗斯芭蕾舞团
叛逆
对抗和解放
观众
激起公愤就是成功
二 柏林
圣春
序曲
技术
首都
文化
文化和叛逆
战争即文化
三 在佛兰德斯的原野上
异国他乡的角落
八月枪声
和平降临大地
原因何在
维多利亚时代综论
喝茶还是加蜂蜜吗？
第二幕
四 战争祭
战斗芭蕾
主题
重估一切价值
五 疯狂的理性
他们的办法是不去问为什么
责任
六 神圣的舞蹈
战争之神
会众
七 走向内心
战争即艺术
艺术即形式
艺术和道德
先锋
第三幕
八 夜舞者
新的救主
明星
不要忘记
行程和象征
新世界和旧世界
联想
九 记忆
战争的回声
与死亡为伴
名声
用云彩变戏法的人
十 无尽的春天
德意志，醒来了！
受难的英雄
艺术即生活
神话即现实
“这是无尽的春天！”
致谢
原始资料选
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>春之祭
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
译序
致谢
前言
第一章  明天的寓言
第二章  忍耐的义务
第三章  死神的特效药
第四章  地表水和地下海
第五章  土壤的王国
第六章  地球的绿色斗篷
第七章  不必要的大破坏
第八章  再也没有鸟儿歌唱
第九章  死亡的河流
第十章  自天而降的灾难
第十一章  超过了波尔基亚家族的梦想
第十二章  人类的代价
第十三章  通过一扇狭小的窗户
第十四章  每四个中有一个
第十五章  大自然在反抗
第十六章  崩溃声隆隆
第十七章  另外的道路
索引
附录：主要文献来源目录
人名译名对照表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>黑色的春天
目录
一个超现实主义的春天
第十四区
春天的第三或第四天
一个星期六下午
天使是我的水印图案！
裁缝铺
杰勃沃尔•克朗斯塔特
进入夜生活……
来回漫步于中国
脱衣舞酒吧
大都市疯子
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>黑色的春天
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring响应式微服务
第1章  直面响应式微服务架构	1
1.1  响应式系统核心概念	1
1.1.1  从传统编程方法到响应式编程方法	1
1.1.2  响应式宣言与响应式系统	4
1.2  剖析微服务架构	6
1.2.1  分布式系统与微服务架构	6
1.2.2  服务拆分与集成	8
1.2.3  微服务架构的核心组件	11
1.2.4  微服务架构技术体系	13
1.3  构建响应式微服务架构	15
1.3.1  响应式微服务架构设计原则	15
1.3.2  整合响应式编程与微服务架构	18
1.4  全书架构	19
1.5  本章小结	20
第2章  响应式编程模型与Reactor框架	21
2.1  响应式编程模型	21
2.1.1  流	22
2.1.2  背压	24
2.1.3  响应式流	25
2.2  Reactor框架	28
2.2.1  响应式编程实现技术概述	28
2.2.2  引入Reactor框架	31
2.3  创建Flux和Mono	34
2.3.1  创建Flux	34
2.3.2  创建Mono	37
2.4  Flux和Mono操作符	39
2.4.1  转换操作符	39
2.4.2  过滤操作符	43
2.4.3  组合操作符	46
2.4.4  条件操作符	49
2.4.5  数学操作符	52
2.4.6  Observable工具操作符	54
2.4.7  日志和调试操作符	56
2.5  Reactor框架中的背压机制	58
2.6  本章小结	60
第3章  构建响应式RESTful服务	61
3.1  使用Spring Boot 2.0构建微服务	61
3.1.1  Spring Boot基本特性	61
3.1.2  基于Spring Boot的第一个RESTful服务	63
3.1.3  使用Actuator组件强化服务	67
3.2  使用Spring WebFlux构建响应式服务	80
3.2.1  使用Spring Initializer初始化响应式Web应用	80
3.2.2  对比响应式Spring WebFlux与传统Spring WebMvc	82
3.2.3  使用注解编程模型创建响应式RESTful服务	84
3.2.4  使用函数式编程模型创建响应式RESTful服务	88
3.3  本章小结	93
第4章  构建响应式数据访问组件	94
4.1  Spring Data数据访问模型	94
4.1.1  Spring Data抽象	95
4.1.2  集成Spring Data JPA	98
4.1.3  集成Spring Data Redis	100
4.1.4  集成Spring Data Mongodb	103
4.2  响应式数据访问模型	104
4.2.1  Spring Reactive Data抽象	105
4.2.2  创建响应式数据访问层组件	107
4.3  响应式Mongodb	108
4.3.1  初始化Reactive Mongodb运行环境	109
4.3.2  创建Reactive Mongodb Repository	112
4.3.3  使用CommandLineRunner初始化Mongodb数据	113
4.3.4  在Service层中调用Reactive MongodbRepository	114
4.4  响应式Redis	117
4.4.1  初始化Reactive Redis运行环境	117
4.4.2  创建Reactive Redis Repository	121
4.4.3  在Service层中调用Reactive Repository	122
4.5  本章小结	123
第5章  构建响应式消息通信组件	124
5.1  消息通信系统简介	125
5.2  使用Spring Cloud Stream构建消息通信系统	126
5.2.1  Spring Cloud Stream基本架构	126
5.2.2  Spring Cloud Stream中的Binder组件	130
5.2.3  使用Source组件实现消息发布者	135
5.2.4  使用@StreamListener注解实现消息消费者	137
5.3  引入Reactive Spring Cloud Stream实现响应式 消息通信系统	139
5.3.1  Reactive Spring Cloud Stream组件	139
5.3.2  Reactive Spring Cloud Stream示例	141
5.4  本章小结	147
第6章  构建响应式微服务架构	148
6.1  使用Spring Cloud创建响应式微服务架构	148
6.1.1  服务治理	149
6.1.2  负载均衡	154
6.1.3  服务容错	161
6.1.4  服务网关	166
6.1.5  服务配置	173
6.1.6  服务监控	177
6.2  使用WebClient实现响应式服务调用	182
6.2.1  创建和配置WebClient	182
6.2.2  使用WebClient访问服务	183
6.3  本章小结	187
第7章  测试响应式微服务架构	188
7.1  初始化测试环境	189
7.1.1  引入spring-boot-starter-test组件	189
7.1.2  解析基础类测试注解	190
7.1.3  编写第一个测试用例	191
7.2  测试Reactor组件	192
7.3  测试响应式Repository层组件	194
7.3.1  测试内嵌式Mongodb	194
7.3.2  测试真实MongoDB	197
7.4　测试响应式Service层组件	199
7.5  测试响应式Controller层组件	201
7.6  本章小结	204
第8章  响应式微服务架构演进案例分析	205
8.1  PrescriptionSystem案例简介	205
8.2  传统微服务架构实现案例	207
8.2.1  构建基础设施类服务	207
8.2.2  构建Medicine服务	213
8.2.3  构建Card服务	219
8.2.4  构建Prescription服务	224
８.3  响应式微服务架构演进案例	237
8.3.1  更新基础设施类服务	237
8.3.2  更新数据访问方式	241
8.3.3  更新事件通信方式	246
8.4  本章小结	266
参考文献	267
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring响应式微服务
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Spring MVC 4
第1章　快速搭建Spring Web应用　1
1．1　Spring Tool Suite简介　2
1．2　IntelliJ简介　7
1．3　start．Spring．io简介　8
1．4　命令行方式简介　8
1．5　那就正式开始吧　9
1．5．1　Gradle构建　11
1．5．2　让我们看一下代码　15
1．6　幕后的Spring Boot　17
1．6．1　分发器和multipart配置　17
1．6．2　视图解析器、静态资源以及
区域配置　22
1．7　错误与转码配置　24
1．8　嵌入式Servlet容器（Tomcat）的
配置　27
1．8．1　HTTP端口　29
1．8．2　SSL配置　29
1．8．3　其他配置　29
1．9　小结　30
第2章　精通MVC架构　32
2．1　MVC架构　32
2．2　对MVC的质疑及其最佳实践　33
2．2．1　贫血的领域模型　33
2．2．2　从源码中学习　35
2．3　Spring MVC 1-0-1　35
2．4　使用Thymeleaf　36
2．5　Spring MVC架构　40
2．5．1　DispatcherServlet　40
2．5．2　将数据传递到给视图　41
2．6　Spring表达式语言　42
2．7　结束Hello World，开始获取
Tweet　44
2．7．1　注册应用　44
2．7．2　搭建Spring Social Twitter　46
2．7．3　访问Twitter　46
2．8　Java 8的流和lambda表达式　48
2．9　使用WebJars实现质感设计　49
2．9．1　使用布局　52
2．9．2　导航　54
2．10　检查点　59
2．11　小节　59
第3章　处理表单和复杂的URL映射　60
3．1　基本信息页——表单　60
3．2　校验　68
3．2．1　自定义校验信息　70
3．2．2　用于校验的自定义注解　73
3．3　国际化　74
3．3．1　修改地域　76
3．3．2　翻译应用的文本　79
3．3．3　表单中的列表　81
3．4　客户端校验　84
3．5　检查点　86
3．6　小结　87
第4章　文件上传与错误处理　88
4．1　上传文件　88
4．1．1　将图片写入到响应中　93
4．1．2　管理上传属性　94
4．1．3　展现上传的图片　97
4．1．4　处理文件上传的错误　99
4．2　转换错误信息　102
4．3　将基本信息放到会话中　103
4．4　自定义错误页面　107
4．5　使用矩阵变量进行URL映射　108
4．6　将其组合起来　114
4．7　检查点　121
4．8　小结　122
第5章　创建RESTful应用　123
5．1　什么是REST　123
5．2　Richardson的成熟度模型　124
5．2．1　第0级——HTTP　124
5．2．2　第1级——资源　124
5．2．3　第2级——HTTP动作　124
5．2．4　第3级——超媒体控制　126
5．3　API版本化　127
5．4　有用的HTTP代码　127
5．5　客户端为王　128
5．6　调试RESTful API　130
5．6．1　JSON格式化扩展　130
5．6．2　浏览器中的RESTful
客户端　130
5．6．3　httpie　131
5．7　自定义JSON输出　131
5．8　用户管理API　136
5．9　状态码与异常处理　140
5．9．1　带有状态码的
ResponseEntity　140
5．9．2　使用异常来处理状态码　142
5．10　通过Swagger实现文档化　146
5．11　生成XML　148
5．12　检查点　149
5．13　小结　150
第6章　保护应用　151
6．1　基本认证　151
6．1．1　用户授权　152
6．1．2　URL授权　155
6．1．3　Thymeleaf安全标签　156
6．2　登录表单　158
6．3　Twitter认证　163
6．3．1　搭建社交认证环境　164
6．3．2　详解　167
6．4　分布式会话　169
6．5　SSL　171
6．5．1　生成自签名的证书　172
6．5．2　单一模式　173
6．5．3　双通道模式　173
6．5．4　置于安全的服务器之后　174
6．6　检查点　175
6．7　小结　175
第7章　不要心存侥幸——单元测试与
验收测试　176
7．1　为什么要测试我的代码　176
7．2　该如何测试自己的代码　177
7．3　测试驱动开发　178
7．4　单元测试　179
7．5　验收测试　180
7．6　第一个单元测试　180
7．7　Mock与Stub　184
7．7．1　使用Mockito进行mock　184
7．7．2　在测试时Stub bean　186
7．7．3　该使用Mock还是Stub　189
7．8　对REST控制器进行单元
测试　189
7．9　测试认证　196
7．10　编写验收测试　198
7．10．1　Gradle配置　198
7．10．2　第一个FluentLenium
测试　200
7．10．3　使用FluentLenium创建
页面对象　206
7．10．4　用Groovy实现测试　209
7．10．5　使用Spock进行单元
测试　210
7．10．6　使用Geb进行集成测试　213
7．10．7　在Geb中使用页面对象　215
7．11　检查点　218
7．12　小结　220
第8章　优化请求　221
8．1　生产环境的profile　221
8．2　Gzip　222
8．3　缓存控制　222
8．4　应用缓存　224
8．4．1　缓存失效　229
8．4．2　分布式缓存　230
8．5　异步方法　231
8．6　ETag　237
8．7　WebSocket　241
8．8　检查点　244
8．9　小结　245
第9章　将Web应用部署到云中　246
9．1　选择主机　246
9．1．1　Cloud Foundry　246
9．1．2　OpenShift　247
9．1．3　Heroku　248
9．2　将Web应用部署到Pivotal Web
Services中　248
9．2．1　安装Cloud Foundry CLI
工具　248
9．2．2　装配应用　249
9．2．3　激活Redis　252
9．3　将Web应用部署到
Heroku中　253
9．3．1　安装工具　254
9．3．2　搭建应用　255
9．3．3　Heroku profile　256
9．3．4　运行应用　257
9．3．5　激活Redis　258
9．4　改善应用的功能　260
9．5　小结　261
第10章　超越Spring Web　262
10．1　Spring生态系统　262
10．1．1　核心　263
10．1．2　执行　263
10．1．3　数据　263
10．1．4　其他值得关注的项目　264
10．2　部署　264
10．3　单页面应用　265
10．3．1　参与者　265
10．3．2　未来的前景　266
10．3．3　实现无状态　267
10．4　小结　267
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Spring MVC 4
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高可用可伸缩微服务架构
1.1 什么是架构 1
1.2 几个相关概念 3
1.3 从软件的生命周期看架构设计 7
1.4 架构的形式与特点 9
1.5 架构的目标与方法 13
1.6 架构的不同风格 18
第2章 微服务领域驱动设计 30
2.1 领域驱动设计 31
2.1.1 领域驱动设计概览 31
2.1.2 问题域与解决方案域 34
2.1.3 限界上下文 35
2.1.4 上下文映射 40
2.1.5 领域架构 43
2.2 微服务的设计 48
2.2.1 限界上下文的边界 48
2.2.2 限界上下文即微服务 51
2.2.3 识别限界上下文 53
2.2.4 微服务之间的协作 59
2.3 小结 63
第3章 Apache Dubbo框架的原理与实现 64
3.1 Dubbo框架的选型与使用 64
3.1.1 Dubbo框架的选型 64
3.1.2 Dubbo框架的使用 65
3.2 Dubbo框架的原理分析 70
3.2.1 总体架构分析 70
3.2.2 Dubbo Bean的加载 73
3.2.3 Dubbo Extension机制 77
3.2.4 Dubbo消费端 91
3.2.5 Dubbo服务端 126
3.2.6 Dubbo的通信机制 144
3.3 基于Dubbo的自动化Mock系统 165
3.3.1 Mock模拟系统的产生 166
3.3.2 Dubbo Mock的使用 167
3.3.3 Dubbo Mock的原理解析 168
3.3.4 自动化Mock系统的实现 170
第4章 Spring Boot/Spring Cloud实践 177
4.1 Spring Boot原理剖析 178
4.1.1 Spring Boot Quick Start 178
4.1.2 Spring Boot之SpringApplication 180
4.1.3 spring-boot-loaded模块分析 186
4.1.4 spring-boot-autoconfigure模块分析 190
4.1.5 Spring Boot Conditional注解分析 195
4.2 Dubbo Spring Boot Starter 198
4.2.1 Dubbo Spring Boot Starter简介 198
4.2.2 Dubbo Initializr及sample 198
4.2.3 dubbo-spring-boot-autoconfigure模块 201
4.2.4 dubbo-spring-boot-actuator模块 204
4.3 Spring Cloud栈 211
4.3.1 为什么微服务架构需要Spring Cloud 212
4.3.2 Spring Cloud技术栈总览 214
4.3.3 spring-cloud-scaffold基础库集合 215
4.4 基于Maven Archetype的脚手架 239
4.4.1 Maven Archetype 239
4.4.2 脚手架的搭建 240
4.4.3 生成脚手架 247
第5章 微服务稳定性保证的常用手段 250
5.1 微服务的稳定性 250
5.2 高可用 250
5.2.1 限流原理与实现 250
5.2.2 断路器原理与实现 256
5.2.3 超时与重试 260
5.3 高并发 262
5.3.1 异步 263
5.3.2 缓存 270
5.4 总结 272
第6章 微服务下如何保证事务的一致性 273
6.1 从本地事务到分布式事务的演变 273
6.2 强一致性解决方案 276
6.2.1 二阶段提交协议 276
6.2.2 三阶段提交协议 278
6.3 最终一致性解决方案 280
6.3.1 TCC模式 280
6.3.2 补偿模式 285
6.3.3 可靠事件模式 286
6.4 开源项目的分布式事务实现解读 288
6.4.1 Apache RocketMQ 288
6.4.2 ServiceComb 289
第7章 百亿流量微服务网关的设计与实现 293
7.1 API网关概述 293
7.1.1 分布式服务架构、微服务架构与 API 网关 293
7.1.2 API网关的定义、职能与关注点 296
7.1.3 API网关的分类与技术分析 298
7.2 开源网关的分析与调研 300
7.2.1 常见的开源网关介绍 300
7.2.2 四大开源网关的对比分析 308
7.2.3 开源网关的技术总结 309
7.3 百亿流量交易系统API网关设计 310
7.3.1 百亿流量交易系统API网关的现状和面临问题 310
7.3.2 业务网关的设计与最佳实践 313
第8章 微服务编排 317
8.1 Netflix Conductor 317
8.2 Netflix Conductor的架构 319
8.3 Conductor的使用案例 320
8.4 Netflix Conductor源码分析 328
8.4.1 Client层源码分析 330
8.4.2 Server端源码分析 337
8.4.3 core端源码分析 344
第9章 微服务数据抽取与统计 356
9.1 案例小故事 356
9.2 数据仓库概述 358
9.2.1 什么是数据仓库 358
9.2.2 数据仓库架构 360
9.2.3 数据仓库建模方法 361
9.2.4 数据抽取、转换和加载 361
9.2.5 数据统计 362
9.3 数据仓库工具Hive 362
9.3.1 安装Hive 364
9.3.2 Hive数据库 366
9.3.3 Hive表 367
9.4 使用Sqoop抽取数据 369
9.4.1 安装Sqoop 370
9.4.2 将MySQL表数据导入Hive表 372
9.5 ETL作业调度 375
第10章 微服务双活体系建设 377
10.1 系统高可用 377
10.2 双活数据中心 379
10.2.1 单机房部署 379
10.2.2 双机房部署 380
10.2.3 基于支付场景的双活体系建设 383
第11章 基于支付场景下的微服务改造与性能优化 399
11.1 支付场景的介绍 399
11.2 支付业务建模和服务划分 400
11.3 支付场景下微服务架构的详解与分析 402
11.3.1 业务架构分析 402
11.3.2 技术平台详解 404
11.4 从代码层面提升微服务架构的性能 407
11.4.1 从代码和设计的角度看 407
11.4.2 从整体架构的角度看 418
11.5 微服务架构中常见的一些故障分析技巧 421
第12章 遗留系统的微服务架构改造 426
12.1 代码分层结构的转变 426
12.2 遗留系统的债券与思考 430
12.3 从单体系统拆分服务的方法论 431
12.4 遗留系统的微服务架构改造 436
12.4.1 从代码重构开始 436
12.4.2 拆分服务需要面向服务进行架构设计 437
12.4.3 改造是一个渐进的过程 437
12.4.4 单元测试是基石 440
12.4.5 面向失败的设计 440
12.4.6 前后端分离 441
12.4.7 共享现有数据库 441
12.4.8 灰度发布的必要性 442
12.4.9 日志聚合与全链路监控 442
第13章 Service Mesh详解 443
13.1 Service Mesh是什么 443
13.2 Service Mesh的背景 443
13.3 Service Mesh介绍 444
13.3.1 Service Mesh架构 444
13.3.2 Service Mesh能做什么 445
13.4 Service Mesh的价值 446
13.5 Service Mesh现状 447
13.6 Service Mesh存在的问题 448
13.7 Istio详解 449
13.7.1 Istio架构 449
13.7.2 数据平面 450
13.7.3 控制平面 455
13.7.4 Isito案例 458
13.8 Service Mesh展望 461
第14章 微服务监控实战 463
14.1 APM原理与应用 464
14.1.1 什么是APM 464
14.1.2 APM监控点 464
14.1.3 APM深入解析 464
14.2 Prometheus监控系统介绍 492
14.2.1 Prometheus的主要特点 493
14.2.2 Prometheus的架构及组件介绍 493
14.2.3 Prometheus的安装 494
14.2.4 使用Prometheus对MySQL进行监控 498
14.2.5 Prometheus的告警机制 501
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高可用可伸缩微服务架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot实战派
目录
+++++++++入 门 篇
第1章  进入Spring Boot世界  /2
1.1  认识Spring Boot  /2
∣1.1.1  什么是Spring Boot  /2
∣1.1.2  Spring、Spring Boot、Spring Cloud的关系  /4
∣1.1.3  Spring Boot的特色  /5
∣1.1.4  Spring Boot支持的开发语言  /6
∣1.1.5  学习Spring Boot的前景展望  /6
1.2  学习Spring Boot的建议  /7
∣1.2.1  看透本书理论，模仿实战例子  /7
∣1.2.2  利用开发工具自动学习  /7
∣1.2.3  发现新功能的方法  /8
∣1.2.4  建立高阶的思维方式  /9
∣1.2.5  控制版本，降低犯错的代价  /10
∣1.2.6  获取最新、最全的资料  /11
∣1.2.7  学会自己发现和解决问题  /11
∣1.2.8  善于提问，成功一半  /12
第2章  准备开发环境  /14
2.1  搭建环境  /14
∣2.1.1  安装Java开发环境JDK  /14
∣2.1.2  配置JDK的环境变量  /15
2.2  熟悉Maven  /18
∣2.2.1  安装及配置Maven  /18
∣2.2.2  认识其中的pom.xml文件  /19
∣2.2.3  Maven的运作方式  /23
∣2.2.4  配置国内仓库  /23
第3章  使用开发工具  /25
3.1  安装开发工具IDEA及插件  /25
∣3.1.1  安装IDEA  /25
∣3.1.2  配置IDEA的Maven环境  /27
∣3.1.3  安装Spring Assistant插件  /27
∣3.1.4  安装插件Lombok  /28
3.2  【实例1】用Spring Boot输出“Hello World”  /30
∣3.2.1  构建Spring Boot项目  /30
∣3.2.2  编写控制器，实现输出功能  /31
∣3.2.3  在IDEA中运行程序  /33
∣3.2.4  打包成可执行的JAR包  /33
3.3  在Eclipse中开发Spring Boot应用程序  /35
∣3.3.1  安装Eclipse  /35
∣3.3.2  安装Spring Tools 4插件  /35
∣3.3.3  配置Eclipse的Maven环境  /36
∣3.3.4  创建Spring Boot项目  /37
3.4  了解Spring官方开发工具STS  /37
3.5  必会的IDEA实用技能  /38
∣3.5.1  智能提示代码  /38
∣3.5.2  自动提示参数  /39
∣3.5.3  实现自动转义  /39
∣3.5.4  自定义高复用代码块  /40
∣3.5.5  设置注释信息  /41
∣3.5.6  超能的“Alt+Enter”快捷键  /42
∣3.5.7  使用全局配置  /42
∣3.5.8  自动生成语句  /43
3.6  比较IDEA与Eclipse  /44
3.7  如何使用本书源代码  /47
∣3.7.1  在IDEA中使用  /47
∣3.7.2  在Eclipse（STS）中使用  /47
∣
+++++++++基 础 篇
第4章  Spring Boot基础  /50
4.1  了解Spring Boot  /50
∣4.1.1  了解Spring Boot项目结构  /50
∣4.1.2  了解Spring Boot的入口类  /51
∣4.1.3  了解Spring Boot的自动配置  /52
∣4.1.4  了解Spring Boot热部署  /52
∣4.1.5  【实例2】定制启动画面  /53
4.2  Spring Boot的常用注解  /54
∣4.2.1  什么是注解式编程  /55
∣4.2.2  了解系统注解  /55
∣4.2.3  Spring Boot的常用注解  /56
4.3  使用配置文件  /61
∣4.3.1  【实例3】演示如何使用application.yml文件  /62
∣4.3.2  【实例4】演示如何使用application.properties文件  /65
∣4.3.3  【实例5】用application.yml和application.properties配置多环境  /67
4.4  Spring Boot的Starter  /69
∣4.4.1  了解Starter  /69
∣4.4.2  使用Starter  /70
第5章  分层开发Web应用程序  /71
5.1  应用程序分层开发模式——MVC  /71
∣5.1.1  了解MVC模式  /71
∣5.1.2  MVC和三层架构的关系  /72
5.2  使用视图技术Thymeleaf  /73
∣5.2.1  认识Thymeleaf  /73
∣5.2.2  基础语法  /75
∣5.2.3  处理循环遍历  /78
∣5.2.4  处理公共代码块  /80
∣5.2.5  处理分页  /81
∣5.2.6  验证和提示错误消息  /82
∣5.2.7  【实例6】编写Thymeleaf视图以展示数据  /83
5.3  使用控制器  /85
∣5.3.1  常用注解  /85
∣5.3.2  将URL映射到方法  /86
∣5.3.3  处理HTTP请求的方法  /87
∣5.3.4  处理内容类型  /89
∣5.3.5  在方法中使用参数  /90
5.4  理解模型  /93
5.5  【实例7】实现MVC模式的Web应用程序  /94
∣5.5.1  添加依赖  /94
∣5.5.2  创建实体模型  /95
∣5.5.3  创建控制器  /95
∣5.5.4  创建用于展示的视图  /96
5.6  验证数据  /96
∣5.6.1  认识内置的验证器Hibernate∣validator  /96
∣5.6.2  自定义验证功能  /98
∣5.6.3  【实例8】验证表单数据并实现数据的自定义验证  /99
第6章  响应式编程  /103
6.1  认识响应式编程  /103
∣6.1.1  什么是WebFlux  /103
∣6.1.2  比较MVC和WebFlux  /103
∣6.1.3  认识Mono和Flux  /105
∣6.1.4  开发WebFlux的流程  /106
6.2  【实例9】用注解式开发实现Hello World  /107
∣6.2.1  配置WebFlux依赖  /107
∣6.2.2  编写控制器  /107
6.3  【实例10】用注解式开发实现数据的增、删、改、查  /108
∣6.3.1  创建实体类  /108
∣6.3.2  编写控制器  /108
∣6.3.3  测试API功能  /110
6.4  【实例11】用响应式开发方式开发WebFlux  /111
∣6.4.1  编写处理器类Handler  /111
∣6.4.2  编写路由器类Router  /112
6.5  【实例12】用WebFlux模式操作MongoDB数据库,实现数据的增、删、改、查功能  /112
∣6.5.1  添加依赖  /112
∣6.5.2  创建实体类  /113
∣6.5.3  编写接口  /113
6.5.4  编写增、删、改、查数据的API  /113
∣
+++++++++进 阶 篇
第7章  Spring Boot进阶  /118
7.1  面向切面编程  /118
∣7.1.1  认识Spring AOP  /118
∣7.1.2  【实例13】用AOP方式管理日志  /119
7.2  认识IoC容器和Servlet容器  /121
∣7.2.1  认识容器  /121
∣7.2.2  【实例14】用IoC管理Bean  /123
∣7.2.3  【实例15】用Servlet处理请求  /125
7.3  过滤器与监听器  /126
∣7.3.1  认识过滤器  /126
∣7.3.2  【实例16】实现过滤器  /128
∣7.3.3  认识监听器  /128
∣7.3.4  【实例17】实现监听器  /129
7.4  自动配置  /130
∣7.4.1  自定义入口类  /130
∣7.4.2  自动配置的原理  /131
∣7.4.3  【实例18】自定义Starter  /133
7.5  元注解  /136
∣7.5.1  了解元注解  /136
∣7.5.2  【实例19】自定义注解  /137
7.6  异常处理  /138
∣7.6.1  认识异常处理  /138
∣7.6.2  使用控制器通知  /141
∣7.6.3  【实例20】自定义错误处理控制器  /142
∣7.6.4  【实例21】自定义业务异常类  /143
7.7  单元测试  /145
∣7.7.1  了解单元测试  /145
∣7.7.2  Spring Boot 的测试库  /145
∣7.7.3  快速创建测试单元  /149
∣7.7.4  【实例22】Controller层的单元测试  /150
∣7.7.5  【实例23】Service层的单元测试  /153
∣7.7.6  【实例24】Repository层的单元测试  /154
第8章  用ORM操作SQL数据库  /156
8.1  认识Java的数据库连接模板JDBCTemplate  /156
∣8.1.1  认识JDBCTemplate  /156
∣8.1.2  【实例25】用JDBCTemplate实现数据的增、删、改、查  /157
∣8.1.3  认识ORM  /161
8.2  JPA——Java持久层API  /161
∣8.2.1  认识Spring Data  /161
∣8.2.2  认识JPA  /162
∣8.2.3  使用JPA  /164
∣8.2.4  了解JPA注解和属性  /165
∣8.2.5  【实例26】用JPA构建实体数据表  /167
8.3  认识JPA的接口  /169
∣8.3.1  JPA接口JpaRepository  /169
∣8.3.2  分页排序接口PagingAndSortingRepository  /169
∣8.3.3  数据操作接口CrudRepository  /170
∣8.3.4  分页接口Pageable和Page  /170
∣8.3.5  排序类Sort  /171
8.4  JPA的查询方式  /171
∣8.4.1  使用约定方法名  /171
∣8.4.2  用JPQL进行查询  /173
∣8.4.3  用原生SQL进行查询  /174
∣8.4.4  用Specifications进行查询  /175
∣8.4.5  用ExampleMatcher进行查询  /177
∣8.4.6  用谓语QueryDSL进行查询  /177
∣8.4.7  用NamedQuery进行查询  /177
8.5  【实例27】用JPA开发文章管理模块  /178
∣8.5.1  实现文章实体  /178
∣8.5.2  实现数据持久层  /179
∣8.5.3  实现服务接口和服务接口的实现类  /179
∣8.5.4  实现增、删、改、查的控制层API功能  /180
∣8.5.5  实现增、删、改、查功能的视图层  /182
8.6  实现自动填充字段  /185
8.7  掌握关系映射开发  /187
∣8.7.1  认识实体间关系映射  /187
∣8.7.2  【实例28】实现“一对一”映射  /188
∣8.7.3  【实例29】实现“一对多”映射  /192
∣8.7.4  【实例30】实现“多对多”映射  /195
8.8  认识MyBatis——Java数据持久层框架  /197
∣8.8.1  CRUD注解  /198
∣8.8.2  映射注解  /198
∣8.8.3  高级注解  /199
8.9  【实例31】用MyBatis实现数据的增加、删除、修改、查询和分页  /200
∣8.9.1  创建Spring Boot项目并引入依赖  /201
∣8.9.2  实现数据表的自动初始化  /201
∣8.9.3  实现实体对象建模  /202
∣8.9.4  实现实体和数据表的映射关系  /202
∣8.9.5  实现增、删、改、查功能  /203
∣8.9.6  配置分页功能  /204
∣8.9.7  实现分页控制器  /205
∣8.9.8  创建分页视图  /206
8.10  比较JPA与MyBatis  /207
第9章  接口架构风格——RESTful  /209
9.1  REST——前后台间的通信方式  /209
∣9.1.1  认识REST  /209
∣9.1.2  认识HTTP方法与CRUD动作映射  /210
∣9.1.3  实现RESTful风格的数据增、删、改、查  /210
9.2  设计统一的RESTful风格的数据接口  /212
∣9.2.1  版本控制  /212
∣9.2.2  过滤信息  /213
∣9.2.3  确定HTTP的方法  /213
∣9.2.4  确定HTTP的返回状态  /213
∣9.2.5  定义统一返回的格式  /214
9.3  【实例32】为手机APP、PC、H5网页提供统一风格的API  /214
∣9.3.1  实现响应的枚举类  /214
∣9.3.2  实现返回的对象实体  /215
∣9.3.3  封装返回结果  /215
∣9.3.4  统一处理异常  /215
∣9.3.5  编写测试控制器  /219
∣9.3.6  实现数据的增、删、改、查控制器  /220
∣9.3.7  测试数据  /221
9.4  【实例33】用Swagger实现接口文档  /222
∣9.4.1  配置Swagger  /222
∣9.4.2  编写接口文档  /224
9.5  用RestTemplate发起请求  /224
∣9.5.1  认识RestTemplate  /224
∣9.5.2  【实例34】用RestTemplate发送GET请求  /225
∣9.5.3  【实例35】用RestTemplate发送POST请求  /228
∣9.5.4  用RestTemplate发送PUT和DELETE请求  /231
第10章  集成安全框架，实现安全认证和授权  /233
10.1  Spring Security——Spring的安全框架  /233
∣10.1.1  认识Spring Security  /233
∣10.1.2  核心类  /235
10.2  配置Spring Security  /240
∣10.2.1  继承WebSecurityConfigurer Adapter  /240
∣10.2.2  配置自定义策略  /240
∣10.2.3  配置加密方式  /242
∣10.2.4  自定义加密规则  /242
∣10.2.5  配置多用户系统  /242
∣10.2.6  获取当前登录用户信息的几种方式  /244
10.3  【实例36】用Spring Security实现后台登录及权限认证功能  /246
∣10.3.1  引入依赖  /246
∣10.3.2  创建权限开放的页面  /246
∣10.3.3  创建需要权限验证的页面  /247
∣10.3.4  配置Spring Security  /247
∣10.3.5  创建登录页面  /248
∣10.3.6  测试权限  /249
10.4  权限控制方式  /249
∣10.4.1  Spring EL权限表达式  /249
∣10.4.2  通过表达式控制URL权限  /250
∣10.4.3  通过表达式控制方法权限  /252
∣10.4.4  【实例37】使用JSR∣250注解  /254
∣10.4.5  【实例38】实现RBAC权限模型  /256
10.5  认识JWT  /258
10.6  【实例39】用JWT技术为Spring Boot的API增加认证和授权保护  /260
∣10.6.1  配置安全类  /260
∣10.6.2  处理注册  /261
∣10.6.3  处理登录  /262
∣10.6.4  测试多方式注册和登录  /264
∣10.6.5  测试token方式登录和授权  /265
10.7  Shiro——Apache通用安全框架  /266
∣10.7.1  认识Shiro安全框架  /266
∣10.7.2  认识Shiro的核心组件  /267
10.8  【实例40】用Shiro实现管理后台的动态权限功能  /267
∣10.8.1  创建实体  /267
∣10.8.2  实现视图模板  /270
∣10.8.3  进行权限配置  /271
∣10.8.4  实现认证身份功能  /271
∣10.8.5  测试权限  /272
10.9   对比Spring Security与Shiro  /273
第11章  集成Redis，实现高并发  /275
11.1  认识Spring Cache  /275
∣11.1.1  声明式缓存注解  /276
∣11.1.2  【实例41】用Spring Cache进行缓存管理  /278
∣11.1.3  整合Ehcache  /281
∣11.1.4  整合Caffeine  /281
11.2  认识Redis  /282
∣11.2.1  对比Redis与Memcached  /282
∣11.2.2  Redis的适用场景  /285
11.3  Redis的数据类型  /285
11.4  用RedisTemplate操作Redis的5种数据类型  /287
∣11.4.1  认识opsFor方法  /287
∣11.4.2  【实例42】操作字符串  /287
∣11.4.3  【实例43】操作散列  /290
∣11.4.4  【实例44】操作列表  /294
∣11.4.5  【实例45】操作集合  /298
∣11.4.6  【实例46】操作有序集合  /301
∣11.4.7  比较RedisTemplate和StringRedisTemplate  /306
11.5  【实例47】用Redis和MyBatis完成缓存数据的增加、删除、修改、查询功能  /306
∣11.5.1  在Spring Boot中集成Redis  /306
∣11.5.2  配置Redis类  /307
∣11.5.3  创建测试实体类  /308
∣11.5.4  实现实体和数据表的映射关系  /309
∣11.5.5  创建Redis缓存服务层  /309
∣11.5.6  完成增、删、改、查测试API  /310
11.6  【实例48】用Redis和JPA实现缓存文章和点击量  /311
∣11.6.1  实现缓存文章  /311
∣11.6.2  实现统计点击量  /312
∣11.6.3  实现定时同步  /312
11.7  【实例49】实现分布式Session  /313
∣11.7.1  用Redis实现Session共享  /313
∣11.7.2  配置Nginx实现负载均衡  /314
第12章  集成RabbitMQ，实现系统间的数据交换  /316
12.1  认识RabbitMQ  /316
∣12.1.1  介绍RabbitMQ  /316
∣12.1.2  使用场景  /317
∣12.1.3  特性  /318
12.2  RabbitMQ的基本概念  /318
∣12.2.1  生产者、消费者和代理  /318
∣12.2.2  消息队列  /319
∣12.2.3  交换机  /319
∣12.2.4  绑定  /320
∣12.2.5  通道  /321
∣12.2.6  消息确认  /321
12.3  RabbitMQ的6种工作模式  /321
∣12.3.1  简单模式  /321
∣12.3.2  工作队列模式  /321
∣12.3.3  交换机模式  /322
∣12.3.4  Routing转发模式  /322
∣12.3.5  主题转发模式  /322
∣12.3.6  RPC模式  /323
12.4  认识AmqpTemplate接口  /323
∣12.4.1  发送消息  /324
∣12.4.2  接收消息  /324
∣12.4.3  异步接收消息  /325
12.5  在Spring Boot中集成RabbitMQ  /325
∣12.5.1  安装RabbitMQ  /325
∣12.5.2  界面化管理RabbitMQ  /326
∣12.5.3  在Spring Boot中配置RabbitMQ  /327
12.6  在Spring Boot中实现RabbitMQ的4种发送/接收模式  /328
∣12.6.1  【实例50】实现发送和接收队列  /328
∣12.6.2  【实例51】实现发送和接收对象  /330
∣12.6.3  【实例52】实现用接收器接收多个主题  /331
∣12.6.4  【实例53】实现广播模式  /334
12.7  【实例54】实现消息队列延迟功能  /336
第13章  集成NoSQL数据库，实现搜索引擎  /339
13.1  Elasticsearch——搜索应用服务器  /339
∣13.1.1  什么是搜索引擎  /339
∣13.1.2  用数据库实现搜索功能  /339
∣13.1.3  认识Elasticsearch  /343
∣13.1.4  Elasticsearch应用案例  /343
∣13.1.5  对比Elasticsearch与MySQL  /343
∣13.1.6  认识ElasticSearchRepository  /344
∣13.1.7  认识ElasticsearchTemplate  /345
∣13.1.8  认识注解@Document  /345
∣13.1.9  管理索引  /347
13.2  【实例55】用ELK管理Spring Boot应用程序的日志  /348
∣13.2.1  安装Elasticsearch  /348
∣13.2.2  安装Logstash  /349
∣13.2.3  安装Kibana  /350
∣13.2.4  配置Spring Boot项目  /350
∣13.2.5  创建日志计划任务  /351
∣13.2.6  用Kibana查看管理日志  /352
13.3  【实例56】在Spring Boot中集成Elasticsearch，实现增、删、改、查功能  /353
∣13.3.1  集成Elasticsearch  /353
∣13.3.2  创建实体  /353
∣13.3.3  实现增、删、改、查文档的功能  /355
13.4  Elasticsearch查询  /356
∣13.4.1  自定义方法  /356
∣13.4.2  精准查询  /357
∣13.4.3  模糊查询  /359
∣13.4.4  范围查询  /362
∣13.4.5  组合查询  /362
∣13.4.6  分页查询  /363
∣13.4.7  聚合查询  /364
13.5  【实例57】实现产品搜索引擎  /365
13.6  Solr——搜索应用服务器  /367
∣13.6.1  了解Solr  /367
∣13.6.2  安装配置Solr  /367
∣13.6.3  整合Spring Boot和Solr  /368
13.7  【实例58】在Sping Boot中集成Solr，实现数据的增、删、改和查  /369
∣13.7.1  创建User类  /369
∣13.7.2  测试增、删、改、查功能  /369
13.8  对比Elasticsearch和Solr  /372
∣
+++++++++项目实战篇
第14章  开发企业级通用的后台系统  /376
14.1  用JPA实现实体间的映射关系  /376
∣14.1.1  创建用户实体  /376
∣14.1.2  创建角色实体  /377
∣14.1.3  创建权限实体  /378
14.2  用Spring Security实现动态授权（RBAC）功能  /380
∣14.2.1  实现管理（增、删、改、查）管理员角色功能  /380
∣14.2.2  实现管理权限功能  /381
∣14.2.3  实现管理管理员功能  /383
∣14.2.4  配置安全类  /384
∣14.2.5  实现基于RBAC权限控制功能  /386
14.3  监控Spring Boot应用  /387
∣14.3.1  在Spring Boot中集成Actuator  /387
∣14.3.2  在Spring Boot中集成Spring Boot Admin应用监控  /390
∣14.3.3  在Spring Boot中集成Druid 连接池监控  /392
第15章  实现一个类似“京东”的电子商务商城  /394
15.1  用Spring Security实现会员系统  /394
∣15.1.1  实现会员实体  /394
∣15.1.2  实现会员接口  /395
∣15.1.3  实现用户名、邮箱、手机号多方式注册功能  /396
∣15.1.4  实现用RabbitMQ发送会员注册验证邮件  /398
∣15.1.5  实现用户名、邮箱、手机号多方式登录功能  /399
15.2  整合会员系统（Web、APP多端、多方式注册登录）和后台系统  /400
∣15.3  实现购物系统  /401
∣15.3.1  设计数据表  /401
∣15.3.2  实现商品展示功能  /402
∣15.3.3  实现购物车功能  /403
∣15.3.4  用Redis实现购物车数据持久化  /404
15.4  用Redis实现分布式秒杀系统  /406
∣15.4.1  实现抢购功能，解决并发超卖问题  /406
∣15.4.2  缓存页面和限流  /409
15.5  用RabbitMQ实现订单过期取消功能  /409
15.6  实现结算和支付功能  /411
∣15.6.1  实现结算生成订单功能  /411
∣15.6.2  集成支付  /412
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot实战派
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>春满北国
1.	冬天
冬天赖在那里不走—追春之梦—春天的起点—春天的时间表—南下之旅
2.	春天的起点
佛罗里达大沼泽野火—人造砧状云—野火是冬去春来的一个标志—双色树燕—依次迁徙—沼泽交鸣—春天的气息—季节交混—春天的起点—在春天的南边—反季节的寒意—克拉莎草—空气凤梨—春日天文学
3.	天上的春
春日始于天空—太阳的运转—春日的肇始—猎户星座—春日在天空中的迹象—先春之春—旅鸫归来—叉纹拟蝗蛙—春日效应—影子变短的时候—天空时钟
4.	海贝岛
赤潮—神秘的毒素—爆炸式的繁殖—赤潮的受害者—马科岛—裂榄—马尾藻—贝壳海滩—贝壳之美—海贝钟琴曲—绵蟹—奇妙的海底世界—扇贝—大自然的盲文—敏锐感知力的例子—海边觅食的猪—海上春日—螺壳里的风涛声—桩屋居民的庭院—遭受虐待的小猫—萨尼伯尔
5.奥基乔比的薄暮
北上—草莓—第一只蝙蝠—“得克萨斯吉姆”米切尔—斑尾林鸽群中的猫头鹰—蜻蜓—绕了个大圈子—春日的暴风雨—奥基乔比海—金斯沙洲—黑剪嘴鸥—游丝雨—蜗牛卵—秧鹤—彩鹮归来—孤鸟—鲣鸟之王—月光下的雪鹭
5.	鹰树
畜栏车—鸟类地质学—标鹰人—三月的风—第一拨堇菜—燕尾鸢—沙丘鹤—浅赤根—畜牧之乡的美洲鹫—上冲气流—扑火的鸟—巨隼—食腐的贵族—穴小鸮—取景器测量的安全距离—白鹮—伯劳和鸮—鸟的领地—退休的银行家—鹭的飞行速度—鹰巢—鹰巢里的玩意儿—标鹰—空中筋斗
7.大灌木林地带春困—克罗斯溪—斯蒂克斯河—灌木林—菜棕—臼莓和茉莉—佛罗里达最贫瘠的土地—花椒树—丛鸦—落水洞—山茱萸—一种熟悉的花—松萝凤梨—达尔文的慨叹
8.	菱斑响尾蛇
菱斑响尾蛇猎手—斯蒂克斯河的圣诞老人—小猫遭遇菱斑响尾蛇—捕蛇人的噩梦—黑夜之王—地图上的空白点—四十四美元的靴子—地鼠龟洞—响尾蛇的幽闭恐惧症—袋套菱斑响尾蛇—蛇迹是春天的一个标志
9.浮岛之湖
奥兰治湖—随风漂浮的岛—一个人的自然保护中心—太阳能加热器—博物学家的船—宽尾拟八哥—拟八哥求爱—春天在浮岛上的效应—历史上的漂流岛屿—浮岛的诞生—锯开浮岛—欧亚蓬萍草根—在浮岛上漫步—巨型轴藜—流动的鸟巢—绿色的墨水—浮岛上的树
10.	秧鹤河
六点十三分—春分—没有冬天的世界—日历上的春季—沃库拉河的春天—秧鹤的悲号—狸藻花—地面出现的河流—春天肇始的几小时—蜗牛捕手—秧鹤巢—修桥工人—沼泽之声
11.	三角洲上空的翅膀
蝴蝶群集—君主斑蝶归来—蝴蝶香气—空中的臭迹—蝴蝶树—河流与蝴蝶—淤泥—新奥尔
良—周六晚上的喧嚣—在三角洲上空翱翔—土地之父—三角洲湿地的鸟—麝鼠屋—飓风之乡—灾难的益处—一场解决科学难题的风暴
12.	泥船
路易斯安那低地的春天—弗吉尼亚栎与四垂的藤萝—烟囱雨燕—让人记忆犹新的旅舍—沉溺河与水中草原—气压表示数直降—约翰尼•加斯帕德—泥船—水道—风中的鸟儿—无畏的鸟儿—克拉莎草岛—海狸鼠—沼泽火把—人去楼空的厅堂—美洲鹤—凤眼蓝—水陆大战—鹫鸟杀手
13.	萨旺尼河之春
离开佛罗里达—嘲鸫奇怪的行为—鸟类的眼睛—萨旺尼河的源头—战斗的野猪—金翅雀—沿萨旺尼河逆流而上—芦苇河—春之溪—倒映的星—萨旺尼河之夜—野猪—第摩里山—当地居民对响尾蛇的解释—扑翅和鹮—萨旺尼河的水流日历
14.	颤动的林木
考豪斯岛—奥克弗诺基之春—沼泽蛙—水径—沼泽生灵的横截面—蓝翅黄森莺—赭鼠—柏
林花开—水獭和短吻鳄—敏锐的眼睛—麻鳽和蛇—鸟蛇大战—颤动之地—沼泽春日的气息

15.	堰洲岛
破晓之声—低地的堰洲岛—广告牌夹击—春日的变化—布尔斯岛—标龟人—金鱼藻—美洲短吻鳄—嬉戏的水獭—灯心草—美洲沙漠蝗—一匹孤单的马—捕蛇人—黄金玉米球和全谷物粒—柳絮之战—低地苔藓—岛上物种之谜—美洲钝眼蜱—野火鸡盛典—卡氏夜鹰—寂寥的海滩—彩虹—滨外沙埂上的午夜—霓虹灯下的虫子
16.	地下河
没有春天的洞中世界—紫藤—尼卡杰克洞—穿越水蚀通道—洞尘—蝙蝠室—风的错觉—蝙蝠的叫声—超声波—柔软的蝙蝠皮毛—洞中的湿气—神秘的地下河—石笋—白色小龙虾—三州交界点的地下—洞中的蚊蚋—暴风雨中的蝙蝠
17.中毒的山林
死山—被谋杀的乡土—达克敦沙漠形成的原因—水土流失的后果—野生动物消失—白喉带鹀—奔跑的蚂蚁—熔炉的烟尘—人造沙漠的未来
18.幽谷瑶草幽谷中的野花—栖息地保护区—皮尔逊瀑布—黄水枝—为何林中花开早—蕨类—春天的脚印—幽谷含纳的雅声—野花的芬芳—基本气味—银钟花—杜鹃花
19.	百里莺潮
在春天中进出—清晨的合唱—双领鸻—莺潮—大自然的时序—林莺—完美的春之境—白宫
莺—迁徙之路—果园里的莺鸟—鸟的方言—莺鸟的伪装—一个不相信迁徙的本地人—迁徙中的跳背游戏—莺鸟的夜间飞行—迁徙的速度—迁徙线路上的驿站
20.	山巅草甸
大雾山—在春天中回退—一次载舟出行的后果—朝雾—冬鹪鹩的歌声—云雾林—长长的山径—地理学家先驱—风中的唧鹀—唐棣—风吹云—各种各样的山—草蛉—记忆的复杂性—塞勒斯秃峰顶—山巅草甸之谜—对秃峰顶形成之谜的诸多解释—山巅昆虫—秃峰顶上的野花—山扁芒草之山—月桂坡—群山中的暮色
21.	云中一宿
爬山的后果—野花瀑布—“查理的拇囊肿”—乌鸦—榛鸡的鼓奏—爬云—雾海中的岛屿—山中风暴—勒孔特峰顶—老汤姆和老拙—云中一宿—崖顶—坚树赞歌—狭窄的崖路—塌方—雾中之鹫—大雾山的云雾—杜鹃坡—加特林堡
22.	垂直迁徙
布洛英罗克—南方的雪鸟—垂直迁徙的鸟—南方灯草鹀的歌声—健壮的旅鸫—蚯蚓—春天的水土流失—地下迁徙—浮萍的沉浮
23.凯特谷采药人—“坏人的燕麦片”—檫木—哈皮瓦利—霜芽—遇蛇历险记—“野兔胡”—用枪采集槲寄生—柳絮
23.	幼鳗归来
狄更斯小说中的人名—皮德蒙特高原—蜜蜂群—当地的大雨—查珀尔希尔—紫瓶子草—泥蜂巢里的砖灰—白化种的白喉带鹀—宠物鳗—大海来的鳗群—鳗鱼的征程—玻璃鳗和银鳗—更为宏大的潮水
24.	史前陷阱
嘲鸫之歌—开普菲尔—真正的无树草原—植物陷阱—黄瓶子草和防雨盖—诱捕之路—生活在危险中的蚂蚁—紫瓶子草花—蓝尾石龙子—茅膏菜—捕虫堇的胶液—世界上最奇妙的植物—捕蝇草有限的分布范围—被捕获昆虫的大小—达尔文的问题—丽彩鹀
26.迪斯默尔沼泽之湖
基蒂霍克—普通人的诗情—迪斯默尔大沼泽—沼气—白狗—跷跷板之谜—德拉蒙德湖之蓝—超然的湖—柏树残梗—刺柏拥翠的水域—遥远的声音—鸟的口技—声音的源头—春日之灾
27.	蒙蒂塞洛的五月
弗吉尼亚的五月—博物学家先驱杰斐逊—蒙蒂塞洛的鸟—蒲公英籽—杰斐逊的树—春之绿—树的液质—老式的花—混乱的合唱—扑翅的叫声—天然桥—最古老的侧柏—吹口哨的男孩
28.	松林泥炭地
天际线公路—繁茂的六月—“两铜板路”—泥炭地—“闪蛇”—“泥坑打滚”—想起南方的春天—阿福花状旱叶草—沙盖花—捕蛇人—“翁的帽子”—采苔人—新泽西雨蛙—昆虫攻城槌—双翅目昆虫的幽会—春季跷跷板—“新泽西的冰箱”—赫塞尔灰蝶—三声夜鹰之月
29.	闹市里的塞尔伯恩
泽西草甸—曼哈顿正午—河畔大道的美国旱獭—菜鸟撞大运—闹市里的塞尔伯恩—与约
翰•基伦野游—里夫拜庄园的大火
30.	风林
科德角的暴风雨—大黄的花—刺歌雀铃铃的啼鸣—雨中的霸鹟—卡洪斯山谷—矮森林—风林—海风的效应—半日花—微型花—瘿蜂—六月鳃角金龟—海岬蚁—蚁丘的赏金—双色树燕—黄喉地莺载飞载唱—错觉中的奇遇
31.鹤乡
于梭罗之后九十年—三条河—康科德野景—鹤乡—迪普湾—给灰松鼠的黄油吐司—紫鹩哥—瓦尔登湖的春天—栎树瘿—蚁狮—黄蜂的纸矿—温度的差异—梭罗的铁路线—重力的逻辑—铁路线上的自然庇护所—唧鹀非同寻常的歌声—鸟叫的差异—迪普卡特路堑—蚱蜢幼虫—跳蛛—植物的旅行—农夫与他的田地
31.	苍翠的边界
北方的春天进程更快—生长的季节—苍翠的春天—蕨类之乡—新英格兰范儿—淹水的草甸—山中的天气—稻草人一家—奶牛的生活—在锯末中筑巢的燕子—迁徙平潮—雪花专家—一百英亩内的自然志—冬眠日历—飓风的效应—鸮食丸里的豪猪刺—加拿大的青山—旅程的最北端
32.	林木线
爬云人—山间的石卵—蚋—乘着气泡—草茱萸—如毯的苔藓—隐士湖—万瀑之流—《四
季》—如铃的啼声—冬鹪鹩—比氏夜鸫—白颊林莺—鸣禽袭鹰—华盛顿山的林木线—平矮
的树林—地衣—稀矮植物区—高山植物—山顶的虎凤蝶
34.最长的一天
春日的高潮—北国的合唱—光潮—埃科湖—蜉蝣的求爱之舞—春日最后的鸟声合唱—梭罗的“夜之莺”—弗朗科尼亚白喉带鹀—迷雾之河—春天的碎片—归途—故意拖延—追春之旅
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>春满北国
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云原生Java
目录
前言（James Watters）.......................................................xv
前言（Rod Johnson）........................................................ xvii
前言................................................................................ xix
第Ⅰ部分　基础知识
第1 章　云原生应用程序.......................................................... 3
亚马逊的故事 ........................................................................................................ 3
平台的承诺 ............................................................................................................ 5
模式 ........................................................................................................................ 7
可扩展性 ................................................................................................................. 7
可靠性 .................................................................................................................... 8
敏捷性 ..................................................................................................................... 8
Netflix 的故事 ......................................................................................................... 9
微服务 ................................................................................................................. 11
拆分单体系统 ...................................................................................................... 12
Netflix OSS ......................................................................................................... 13
云原生Java ......................................................................................................... 14
十二要素原则 ....................................................................................................... 14
代码库 ................................................................................................................. 15
依赖 ..................................................................................................................... 15
配置 ..................................................................................................................... 16
x ｜ 目录
后端服务 ............................................................................................................. 17
构建、发布、运行 .............................................................................................. 17
进程 ..................................................................................................................... 17
端口绑定 ............................................................................................................. 18
并发 ..................................................................................................................... 18
易处理 ................................................................................................................. 18
开发/ 生产环境一致 ........................................................................................... 19
日志 ..................................................................................................................... 19
管理进程 ............................................................................................................. 19
总结 ........................................................................................................................ 20
第2 章　训练营：Spring Boot 和Cloud Foundry......................21
什么是Spring Boot ................................................................................................ 21
Spring Initializr 入门 .............................................................................................. 21
Spring Tool Suite 入门 ............................................................................................ 30
安装Spring Tool Suite（STS）............................................................................. 30
使用Spring Initializr 创建一个新项目 ................................................................ 31
Spring 指南大全 ................................................................................................... 36
遵循STS 中的指南 ............................................................................................. 38
配置 ....................................................................................................................... 40
Cloud Foundry 平台 ............................................................................................... 52
总结 ....................................................................................................................... 66
第3 章　符合十二要素程序风格的配置....................................... 67
令人迷惑的“配置”合并 ........................................................................................... 67
Spring 框架对配置的支持 .................................................................................... 67
PropertyPlaceholderConfigurer ............................................................................ 68
Environment 接口和@Value 注解 ....................................................................... 69
Profile .................................................................................................................. 71
启动配置 ............................................................................................................. 73
使用Spring Cloud Config Server 进行中心化、日志型的配置................................... 76
Spring Cloud Config Server ................................................................................. 76
Spring Cloud Config 客户端 ................................................................................ 78
安全 ..................................................................................................................... 79
目录 ｜ xi
可刷新的配置 ....................................................................................................... 79
总结 ...................................................................................................................... 83
第４章　测试..................................................................... 85
测试的构成 ........................................................................................................... 86
在Spring Boot 中进行测试 ................................................................................... 86
集成测试 ............................................................................................................. 88
测试切片 ............................................................................................................. 89
测试中的Mock ................................................................................................... 89
使用@SpringBootTest 中的Servlet 容器 ............................................................ 93
测试分片 ............................................................................................................. 94
端到端测试 ......................................................................................................... 102
测试分布式系统 ................................................................................................ 102
消费者驱动的契约测试 ..................................................................................... 104
Spring Cloud Contract ....................................................................................... 105
总结 .................................................................................................................... 113
第5 章　迁移遗留的应用程序................................................. 115
契约 .................................................................................................................... 115
迁移应用程序环境 ................................................................................................ 116
开箱即用的构建包（Buildpacks） ..................................................................... 116
自定义的构建包 ................................................................................................ 117
容器化的应用程序 ............................................................................................ 118
将应用程序迁移到云上的微重构 ........................................................................ 119
连接后端服务 .................................................................................................... 120
用Spring 实现服务平等 .................................................................................... 121
总结 .................................................................................................................... 133
第Ⅱ部分　Web 服务
第6 章　REST API........................................................... 137
伦纳德· 理查森的成熟模型 .................................................................................. 137
使用Spring MVC 实现简单的REST API ................................................................. 139
内容协商 .............................................................................................................. 142
xii ｜ 目录
读写二进制数据 ................................................................................................ 142
Google Protocol Buffers .................................................................................... 145
错误处理 ............................................................................................................. 150
超媒体 ................................................................................................................. 152
媒体类型和模式 ................................................................................................ 158
API 版本 ............................................................................................................. 159
编写REST API 文档 ........................................................................................... 162
客户端 ................................................................................................................ 167
用于临时浏览和交互的REST 客户端 ............................................................... 167
RestTemplate ..................................................................................................... 171
总结 ................................................................................................................... 177
第7 章　路由.................................................................... 179
DiscoveryClient 接口 .......................................................................................... 180
Cloud Foundry Route 服务 .................................................................................. 190
总结 ...................................................................................................................... 195
第8 章　边缘服务............................................................... 197
Greetings 服务 ...................................................................................................... 198
一个简单的边缘服务 ........................................................................................... 200
Netflix Feign ........................................................................................................ 202
使用Netflix Zuul 进行过滤和代理 ........................................................................... 204
自定义Zuul 过滤器 ........................................................................................... 214
边缘服务的安全 .................................................................................................... 218
OAuth ................................................................................................................... 219
服务端应用程序 ................................................................................................ 220
HTML5 和JavaScript 单页面应用程序 ............................................................. 221
没有用户的应用 ................................................................................................ 221
受信任的客户端 ................................................................................................ 221
Spring Security .................................................................................................... 222
Spring Cloud Security ........................................................................................... 227
一个Spring Security OAuth 授权服务器 ........................................................... 227
保护Greetings 资源服务器的安全 .................................................................... 232
创建一个受OAuth 保护的单页面应用程序 ...................................................... 238
总结 ..................................................................................................................... 247
目录 ｜ xiii
第Ⅲ部分　数据整合
第9 章　数据管理............................................................... 251
数据建模 ............................................................................................................... 251
关系数据库管理系统（RDBMS） ...................................................................... 252
NoSQL............................................................................................................... 253
Spring Data ......................................................................................................... 253
Spring Data 应用程序的结构 ............................................................................. 254
域类 ................................................................................................................... 254
库 ...................................................................................................................... 254
为领域数据组织Java 包 .................................................................................... 255
使用JDBC 访问RDBMS 数据 ............................................................................... 258
Spring 的JDBC 支持 ........................................................................................... 259
Spring Data 示例 ................................................................................................. 261
Spring Data JPA.................................................................................................... 264
Account Service ................................................................................................. 264
集成测试 ........................................................................................................... 274
Spring Data MongoDB ......................................................................................... 275
Order Service ..................................................................................................... 275
集成测试 ........................................................................................................... 282
Spring Data Neo4j ............................................................................................... 284
Inventory Service ............................................................................................... 284
集成测试 ........................................................................................................... 294
Spring Data Redis ................................................................................................ 297
高速缓存 ........................................................................................................... 298
总结 .................................................................................................................... 302
第10 章　消息系统............................................................. 303
Spring Integration 的事件驱动架构 ..................................................................... 304
消息端点 ........................................................................................................... 305
使用简单的组件构建复杂的系统 ...................................................................... 306
消息代理、桥接、竞争消费者模式和事件溯源 ................................................... 314
发布—订阅目的地 ............................................................................................ 314
点对点目的地 .................................................................................................... 315
xiv ｜ 目录
Spring Cloud Stream .......................................................................................... 315
流生产者 ........................................................................................................... 316
流消费者 ........................................................................................................... 321
总结 .................................................................................................................... 323
第11 章　批处理和任务........................................................ 325
批处理工作 ........................................................................................................ 325
Spring Batch ....................................................................................................... 326
我们的第一个批处理作业 ................................................................................. 327
调度 .................................................................................................................... 336
通过消息传递远程分区Spring 批处理作业 ............................................................. 337
任务管理 ............................................................................................................. 346
通过Workflow 进行的以工作流为中心的整合 ........................................................ 348
使用消息传递的分布式......................................................................................... 362
总结 ..................................................................................................................... 362
第12 章　数据集成............................................................. 363
分布式事务 .......................................................................................................... 364
故障隔离和优雅的降级........................................................................................ 364
saga 模式 ............................................................................................................. 369
CQRS（命令查询责任分离） .............................................................................. 369
投诉API ............................................................................................................ 371
投诉统计API .................................................................................................... 383
Spring Cloud Data Flow ...................................................................................... 385
Stream ............................................................................................................... 387
任务 ................................................................................................................... 390
REST API .......................................................................................................... 391
实现Data Flow 客户端 ...................................................................................... 392
总结 .................................................................................................................... 407
第IV 部分　生产
第13 章　可观测的系统....................................................... 411
你构建，你运行 ................................................................................................. 412
目录 ｜ xv
谋杀神秘微服务 .................................................................................................. 413
十二要素运维 ..................................................................................................... 413
新方式 ................................................................................................................. 414
可观测性 ............................................................................................................ 416
推与拉的可观测性和解析率 ................................................................................ 416
使用Spring Boot Actuator 捕获应用程序的当前状态 .......................................... 417
度量 ...................................................................................................................... 418
通过/info 端点识别服务 ......................................................................................... 431
健康检查 ............................................................................................................. 432
审计事件 .............................................................................................................. 436
应用程序日志 ...................................................................................................... 439
指定日志输出 .................................................................................................... 440
指定日志级别 .................................................................................................... 441
分布式跟踪 ......................................................................................................... 445
用Spring Cloud Sleuth 寻找线索 ...................................................................... 446
多少数据是足够的 ............................................................................................ 447
OpenZipkin ：一张图片胜过千丝万缕 ............................................................... 448
跟踪其他平台和技术 ......................................................................................... 454
仪表板 ................................................................................................................ 455
使用Hystrix 仪表板监控下游服务 .................................................................... 455
Codecentric 的Spring Boot Admin .................................................................... 459
Ordina Microservices 仪表板 ............................................................................. 462
Pivotal Cloud Foundry 的AppsManager ............................................................ 463
修复 .................................................................................................................. 465
总结 ................................................................................................................... 467
第14 章　服务代理.............................................................................................469
创建后台服务 .................................................................................................. 470
平台视图 ............................................................................................................ 472
使用Spring Cloud Cloud Foundry Service Broker 实现服务代理 ........................ 473
简单的Amazon S3 服务代理 ............................................................................ 473
服务目录 ........................................................................................................... 474
管理服务实例 .................................................................................................... 476
服务绑定 ........................................................................................................... 482
保护服务代理 .................................................................................................... 486
xvi ｜ 目录
部署 ................................................................................................................... 487
使用BOSH 发布 ............................................................................................... 487
使用Cloud Foundry 发布 .................................................................................. 488
注册Amazon S3 Service Broker ....................................................................... 489
创建Amazon S3 服务实例 ................................................................................ 490
消费服务实例 .................................................................................................... 491
S3 客户端应用程序 ........................................................................................... 493
运行测试 ........................................................................................................... 496
总结 .................................................................................................................. 496
第15 章　持续交付.............................................................497
持续集成之外 .................................................................................................. 497
John Allspaw 在Flickr 以及后来的Etsy ........................................................... 498
Netflix 的Adrian Cockroft ................................................................................ 499
亚马逊的持续交付 ............................................................................................ 500
流水线 ................................................................................................................ 500
测试 .................................................................................................................... 501
持续交付微服务 ................................................................................................502
工具 .................................................................................................................. 503
Concourse ......................................................................................................... 503
容器 ................................................................................................................... 504
持续交付微服务 ................................................................................................. 504
安装Concourse ................................................................................................. 505
基本的管道设计 ................................................................................................ 506
持续集成 ........................................................................................................... 518
消费者驱动的协约测试......................................................................................  518
User 微服务流水线 ............................................................................................ 519
数据 ................................................................................................................... 522
生产 ................................................................................................................... 523
第V 部分　附录
附录A　在Java EE 中使用Spring Boot................................527
索引............................................................................... 552
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云原生Java
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java EE企业应用实战（第4版）
第1章　Java EE应用和开发环境	1
1.1　Java EE应用概述	2
1.1.1　Java EE应用的分层模型	2
1.1.2　Java EE应用的组件	3
1.1.3　Java EE应用的结构和优势	4
1.1.4　常用的Java EE服务器	4
1.2  轻量级Java EE应用相关技术	5
1.2.1  JSP、Servlet 3.x和JavaBean及替代技术	5
1.2.2  Struts 2.3及替代技术	5
1.2.3  Hibernate 4.3及替代技术	6
1.2.4  Spring 4.0及替代技术	6
1.3  Tomcat的下载和安装	7
1.3.1  安装Tomcat服务器	7
1.3.2  配置Tomcat的服务端口	9
1.3.3  进入控制台	9
1.3.4  部署Web应用	12
1.3.5  配置Tomcat的数据源	12
1.4  Eclipse的安装和使用	14
1.4.1  Eclipse的下载和安装	14
1.4.2  在线安装Eclipse插件	14
1.4.3  从本地压缩包安装插件	16
1.4.4  手动安装Eclipse插件	17
1.4.5  使用Eclipse开发Java EE应用	17
1.4.6  导入Eclipse项目	20
1.4.7  导入非Eclipse项目	21
1.5  Ant的安装和使用	22
1.5.1  Ant的下载和安装	22
1.5.2  使用Ant工具	23
1.5.3  定义生成文件	24
1.5.4  Ant的任务（task）	29
1.6  Maven的安装和使用	31
1.6.1  下载和安装Maven	31
1.6.2  设置Maven	32
1.6.3  创建、构建简单的项目	33
1.6.4  Maven的核心概念	36
1.6.5  依赖管理	41
1.6.6  POM文件的元素	44
1.7  使用SVN进行协作开发	44
1.7.1  下载和安装SVN服务器	45
1.7.2  配置SVN资源库	46
1.7.3  下载和安装SVN客户端	47
1.7.4  将项目发布到服务器	48
1.7.5  从服务器下载项目	48
1.7.6  提交（Commit）修改	49
1.7.7  同步（Update）本地文件	49
1.7.8  添加文件和目录	50
1.7.9  删除文件和目录	50
1.7.10 查看文件或目录的版本变革	51
1.7.11 从以前版本重新开始	51
1.7.12 创建分支	52
1.7.13 沿着分支开发	52
1.7.14 合并分支	53
1.7.15 使用Eclipse作为SVN客户端	54
1.8  本章小结	57
第2章　JSP/Servlet及相关技术详解	58
2.1  Web应用和web.xml文件	59
2.1.1  构建Web应用	59
2.1.2  配置描述符web.xml	60
2.2  JSP的基本原理	61
2.3  JSP的4种基本语法	65
2.3.1  JSP注释	65
2.3.2  JSP声明	66
2.3.3  输出JSP表达式	67
2.3.4  JSP脚本	68
2.4  JSP的3个编译指令	70
2.4.1  page指令	70
2.4.2  include指令	74
2.5  JSP的7个动作指令	75
2.5.1  forward指令	75
2.5.2  include指令	77
2.5.3  useBean、setProperty、getProperty指令	79
2.5.4  plugin指令	81
2.5.5  param指令	81
2.6  JSP脚本中的9个内置对象	82
2.6.1  application对象	83
2.6.2  config对象	88
2.6.3  exception对象	90
2.6.4  out对象	92
2.6.5  pageContext对象	93
2.6.6  request对象	95
2.6.7  response对象	102
2.6.8  session对象	106
2.7  Servlet介绍	108
2.7.1  Servlet的开发	108
2.7.2  Servlet的配置	110
2.7.3  JSP/Servlet的生命周期	111
2.7.4  load-on-startup Servlet	112
2.7.5  访问Servlet的配置参数	113
2.7.6  使用Servlet作为控制器	115
2.8  JSP 2的自定义标签	119
2.8.1  开发自定义标签类	120
2.8.2  建立TLD文件	120
2.8.3  使用标签库	121
2.8.4  带属性的标签	122
2.8.5  带标签体的标签	125
2.8.6  以页面片段作为属性的标签	128
2.8.7  动态属性的标签	129
2.9  Filter介绍	131
2.9.1  创建Filter类	132
2.9.2  配置Filter	133
2.9.3  使用URL Rewrite实现网站伪静态	136
2.10  Listener介绍	137
2.10.1 实现Listener类	138
2.10.2 配置Listener	139
2.10.3 使用ServletContextAttributeListener	140
2.10.4 使用ServletRequestListener和ServletRequestAttributeListener	141
2.10.5 使用HttpSessionListener和HttpSessionAttributeListener	142
2.11  JSP 2特性	147
2.11.1 配置JSP属性	147
2.11.2 表达式语言	149
2.11.3  Tag File支持	157
2.12  Servlet 3.0新特性	159
2.12.1  Servlet 3.0的注解	159
2.12.2  Servlet 3.0的Web模块支持	160
2.12.3  Servlet 3.0提供的异步处理	162
2.12.4改进的Servlet API	165
2.13  Servlet 3.1新增的非阻塞式IO	167
2.14  Tomcat 8的WebSocket支持	170
2.15 本章小结	174
第3章　Struts 2的基本用法	175
3.1  MVC思想概述	176
3.1.1  传统Model 1和Model 2	176
3.1.2  MVC思想及其优势	177
3.2  Struts 2的下载和安装	178
3.2.1  为Web应用增加Struts 2支持	178
3.2.2  在Eclipse中使用Struts 2	179
3.2.3  增加登录处理	180
3.3  Struts 2的流程	183
3.3.1  Struts 2应用的开发步骤	183
3.3.2  Struts 2的流程	184
3.4  Struts 2的常规配置	185
3.4.1  常量配置	185
3.4.2  包含其他配置文件	191
3.5  实现Action	191
3.5.1  Action接口和ActionSupport基类	193
3.5.2  Action访问Servlet API	195
3.5.3  Action直接访问Servlet API	197
3.5.4  使用ServletActionContext访问Servlet API	199
3.6  配置Action	200
3.6.1  包和命名空间	200
3.6.2  Action的基本配置	203
3.6.3  使用Action的动态方法调用	204
3.6.4  指定method属性及使用通配符	205
3.6.5  配置默认Action	211
3.6.6  配置Action的默认处理类	211
3.7  配置处理结果	212
3.7.1  理解处理结果	212
3.7.2  配置结果	213
3.7.3  Struts 2支持的结果类型	214
3.7.4  plainText结果类型	215
3.7.5  redirect结果类型	217
3.7.6  redirectAction结果类型	218
3.7.7  动态结果	219
3.7.8  Action属性值决定物理视图资源	219
3.7.9  全局结果	221
3.7.10  使用PreResultListener	222
3.8  配置Struts 2的异常处理	223
3.8.1  Struts 2的异常处理机制	223
3.8.2  声明式异常捕捉	225
3.8.3  输出异常信息	226
3.9  Convention插件与“约定”支持	227
3.9.1  Action的搜索和映射约定	228
3.9.2  按约定映射Result	230
3.9.3  Action链的约定	233
3.9.4  自动重加载映射	234
3.9.5  Convention插件的相关常量	234
3.9.6  Convention插件相关Annotation	235
3.10  使用Struts 2的国际化	235
3.10.1  视图页面的国际化	235
3.10.2  Action的国际化	236
3.10.3  使用包范围的国际化资源	238
3.10.4  使用全局国际化资源	239
3.10.5  输出带占位符的国际化消息	241
3.10.6  加载资源文件的顺序	243
3.11  使用Struts 2的标签库	243
3.11.1  Struts 2标签库概述	243
3.11.2  使用Struts 2标签	244
3.11.3  Struts 2的OGNL表达式语言	245
3.11.4  OGNL中的集合操作	247
3.11.5  访问静态成员	248
3.11.6  Lambda（）表达式	248
3.11.7  控制标签	249
3.11.8  数据标签	259
3.11.9  主题和模板	268
3.11.10  自定义主题	270
3.11.11  表单标签	271
3.11.12  非表单标签	284
3.12  本章小结	287
第4章　深入使用Struts 2	288
4.1  详解Struts 2的类型转换	289
4.1.1  Struts 2内建的类型转换器	290
4.1.2  基于OGNL的类型转换	290
4.1.3  指定集合元素的类型	292
4.1.4  自定义类型转换器	294
4.1.5  注册类型转换器	297
4.1.6  基于Struts 2的自定义类型转换器	298
4.1.7  处理Set集合	299
4.1.8  类型转换中的错误处理	301
4.2  使用Struts 2的输入校验	307
4.2.1  编写校验规则文件	307
4.2.2  国际化提示信息	310
4.2.3  使用客户端校验	311
4.2.4  字段校验器配置风格	312
4.2.5  非字段校验器配置风格	313
4.2.6  短路校验器	315
4.2.7  校验文件的搜索规则	316
4.2.8  校验顺序和短路	318
4.2.9  内建校验器	318
4.2.10  基于注解的输入校验	329
4.2.11  手动完成输入校验	330
4.3  使用Struts 2控制文件上传	334
4.3.1  Struts 2的文件上传	334
4.3.2  实现文件上传的Action	335
4.3.3  配置文件上传的Action	337
4.3.4  手动实现文件过滤	338
4.3.5  拦截器实现文件过滤	340
4.3.6  输出错误提示	341
4.3.7  文件上传的常量配置	342
4.4  使用Struts 2控制文件下载	343
4.4.1  实现文件下载的Action	343
4.4.2  配置Action	343
4.4.3  下载前的授权控制	344
4.5  详解Struts 2的拦截器机制	345
4.5.1  拦截器在Struts 2中的作用	346
4.5.2  Struts 2内建的拦截器	346
4.5.3  配置拦截器	348
4.5.4  使用拦截器的配置语法	349
4.5.5  配置默认拦截器	350
4.5.6  实现拦截器类	351
4.5.7  使用拦截器	353
4.5.8  拦截方法的拦截器	354
4.5.9  拦截器的执行顺序	356
4.5.10 拦截结果的监听器	358
4.5.11 覆盖拦截器栈里特定拦截器的参数	359
4.5.12 使用拦截器完成权限控制	360
4.6  使用Struts 2的Ajax支持	362
4.6.1  使用stream类型的Result实现Ajax	363
4.6.2  JSON的基本知识	365
4.6.3  实现Action逻辑	367
4.6.4  JSON插件与json类型的Result	368
4.6.5  实现JSP页面	370
4.7  本章小结	371
第5章　Hibernate的基本用法	372
5.1  ORM和Hibernate	373
5.1.1  对象/关系数据库映射（ORM）	373
5.1.2  基本映射方式	374
5.1.3  流行的ORM框架简介	375
5.1.4  Hibernate概述	376
5.2  Hibernate入门	376
5.2.1  Hibernate下载和安装	376
5.2.2  Hibernate的数据库操作	377
5.2.3  在Eclipse中使用Hibernate	381
5.3  Hibernate的体系结构	386
5.4  深入Hibernate配置文件	388
5.4.1  创建Configuration对象	388
5.4.2  hibernate.properties文件与hibernate.cfg.xml文件	390
5.4.3  JDBC连接属性	390
5.4.4  数据库方言	391
5.4.5  JNDI数据源的连接属性	393
5.4.6  Hibernate事务属性	393
5.4.7  二级缓存相关属性	393
5.4.8  外连接抓取属性	394
5.4.9  其他常用的配置属性	394
5.5  深入理解持久化对象	394
5.5.1  持久化类的要求	395
5.5.2  持久化对象的状态	396
5.5.3  改变持久化对象状态的方法	397
5.6  深入Hibernate映射	399
5.6.1  映射属性	402
5.6.2  映射主键	409
5.6.3  使用Hibernate的主键生成策略	411
5.6.4  映射集合属性	412
5.6.5  集合属性的性能分析	419
5.6.6  有序集合映射	420
5.6.7  映射数据库对象	422
5.7　映射组件属性	424
5.7.1　组件属性为集合	426
5.7.2　集合属性的元素为组件	427
5.7.3  组件作为Map的索引	429
5.7.4  组件作为复合主键	430
5.7.5  多列作为联合主键	432
5.8  使用传统的映射文件	433
5.8.1  增加XML映射文件	433
5.8.2  注解，还是XML映射文件	436
5.9  本章小结	436
第6章　深入使用Hibernate	437
6.1  Hibernate的关联映射	438
6.1.1  单向N－1关联	438
6.1.2  单向1－1关联	443
6.1.3  单向1－N关联	444
6.1.4  单向N－N关联	448
6.1.5  双向1－N关联	449
6.1.6  双向N－N关联	452
6.1.7  双向1－1关联	454
6.1.8  组件属性包含的关联实体	456
6.1.9  基于复合主键的关联关系	458
6.1.10 复合主键的成员属性为关联实体	460
6.1.11 持久化的传播性	463
6.2  继承映射	464
6.2.1  整个类层次对应一个表的映射策略	466
6.2.2  连接子类的映射策略	468
6.2.3  每个具体类对应一个表的映射策略	471
6.3  Hibernate的批量处理	473
6.3.1  批量插入	473
6.3.2  批量更新	474
6.3.3  DML风格的批量更新/删除	475
6.4  使用HQL查询	476
6.4.1  HQL查询	476
6.4.2  HQL查询的from子句	478
6.4.3  关联和连接	479
6.4.4  HQL查询的select子句	482
6.4.5  HQL查询的聚集函数	482
6.4.6  多态查询	483
6.4.7  HQL查询的where子句	483
6.4.8  表达式	484
6.4.9  order by子句	486
6.4.10  group by子句	486
6.4.11  子查询	487
6.4.12  命名查询	487
6.5  条件查询	489
6.5.1  关联和动态关联	491
6.5.2  投影、聚合和分组	493
6.5.3  离线查询和子查询	496
6.6  SQL查询	497
6.6.1  标量查询	497
6.6.2  实体查询	499
6.6.3  处理关联和继承	501
6.6.4  命名SQL查询	502
6.6.5  调用存储过程	504
6.6.6  使用定制SQL	505
6.7  数据过滤	507
6.8  事务控制	510
6.8.1  事务的概念	510
6.8.2  Session与事务	511
6.8.3  上下文相关的Session	513
6.9  二级缓存和查询缓存	514
6.9.1  开启二级缓存	514
6.9.2  管理缓存和统计缓存	517
6.9.3  使用查询缓存	518
6.10  事件机制	520
6.10.1  拦截器	521
6.10.2  事件系统	523
6.11  本章小结	525
第7章　Spring的基本用法	526
7.1  Spring简介和Spring 4.0的变化	527
7.1.1  Spring简介	527
7.1.2  Spring 4.0的变化	528
7.2  Spring入门	528
7.2.1  Spring下载和安装	528
7.2.2  使用Spring管理Bean	529
7.2.3  在Eclipse中使用Spring	532
7.3  Spring的核心机制：依赖注入	535
7.3.1  理解依赖注入	536
7.3.2  设值注入	538
7.3.3  构造注入	541
7.3.4  两种注入方式的对比	543
7.4  使用Spring容器	543
7.4.1  Spring容器	544
7.4.2  使用ApplicationContext	545
7.4.3  ApplicationContext的国际化支持	546
7.4.4  ApplicationContext的事件机制	548
7.4.5  让Bean获取Spring容器	551
7.5  Spring容器中的Bean	552
7.5.1  Bean的基本定义和Bean别名	553
7.5.2  容器中Bean的作用域	554
7.5.3  配置依赖	557
7.5.4  设置普通属性值	559
7.5.5  配置合作者Bean	560
7.5.6  使用自动装配注入合作者Bean	561
7.5.7  注入嵌套Bean	563
7.5.8  注入集合值	564
7.5.9  组合属性	568
7.5.10  Spring的Bean和JavaBean	569
7.6  Spring 3.0提供的Java配置管理	571
7.7  创建Bean的3种方式	573
7.7.1  使用构造器创建Bean实例	574
7.7.2  使用静态工厂方法创建Bean	574
7.7.3  调用实例工厂方法创建Bean	576
7.8  深入理解容器中的Bean	578
7.8.1  抽象Bean与子Bean	578
7.8.2  Bean继承与Java继承的区别	580
7.8.3  容器中的工厂Bean	580
7.8.4  获得Bean本身的id	582
7.8.5  强制初始化Bean	583
7.9  容器中Bean的生命周期	584
7.9.1  依赖关系注入之后的行为	584
7.9.2  Bean销毁之前的行为	586
7.9.3  协调作用域不同步的Bean	589
7.10  高级依赖关系配置	592
7.10.1 获取其他Bean的属性值	592
7.10.2 获取Field值	595
7.10.3 获取方法返回值	596
7.11  基于XML Schema的简化配置方式	599
7.11.1 使用p:命名空间简化配置	599
7.11.2 使用c:命名空间简化配置	601
7.11.3 使用util:命名空间简化配置	602
7.12  Spring 3.0提供的表达式语言（SpEL）	604
7.12.1 使用Expression接口进行表达式求值	604
7.12.2  Bean定义中的表达式语言支持	606
7.12.3  SpEL语法详述	607
7.13  本章小结	612
第8章　深入使用Spring	613
8.1  两种后处理器	614
8.1.1  Bean后处理器	614
8.1.2  Bean后处理器的用处	617
8.1.3  容器后处理器	618
8.1.4  属性占位符配置器	619
8.1.5  重写占位符配置器	620
8.2  Spring的“零配置”支持	622
8.2.1  搜索Bean类	622
8.2.2  指定Bean的作用域	625
8.2.3  使用@Resource配置依赖	625
8.2.4  使用@PostConstruct和@PreDestroy定制生命周期行为	626
8.2.5  Spring 3.0新增的注解	627
8.2.6  Spring 4.0增强的自动装配和精确装配	627
8.3  资源访问	631
8.3.1  Resource实现类	632
8.3.2  ResourceLoader接口和ResourceLoaderAware接口	636
8.3.3  使用Resource作为属性	639
8.3.4  在ApplicationContext中使用资源	640
8.4  Spring的AOP	643
8.4.1  为什么需要AOP	643
8.4.2  使用AspectJ实现AOP	644
8.4.3  AOP的基本概念	651
8.4.4  Spring的AOP支持	652
8.4.5  基于注解的“零配置”方式	653
8.4.6  基于XML配置文件的管理方式	667
8.5  Spring 3.1新增的缓存机制	673
8.5.1  启用Spring缓存	674
8.5.2  使用@Cacheable执行缓存	676
8.5.3  使用@CacheEvict清除缓存	680
8.6  Spring的事务	681
8.6.1  Spring支持的事务策略	681
8.6.2  使用XML Schema配置事务策略	686
8.6.3  使用@Transactional	692
8.7  Spring整合Struts 2	693
8.7.1  启动Spring容器	693
8.7.2  MVC框架与Spring整合的思考	694
8.7.3  让Spring管理控制器	695
8.7.4  使用自动装配	699
8.8  Spring整合Hibernate	701
8.8.1  Spring提供的DAO支持	701
8.8.2  管理Hibernate的SessionFactory	702
8.8.3  实现DAO组件的基类	703
8.8.4  传统的HibernateTemplate和HibernateDaoSupport	706
8.8.5  实现DAO组件	709
8.8.6  使用IoC容器组装各种组件	709
8.8.7  使用声明式事务	712
8.9  Spring整合JPA	713
8.9.1  管理EntityManagerFactory	713
8.9.2  实现DAO组件基类	715
8.9.3  使用声明式事务	718
8.10  本章小结	719
第9章　企业应用开发的思考和策略	720
9.1  企业应用开发面临的挑战	721
9.1.1  可扩展性、可伸缩性	721
9.1.2  快捷、可控的开发	722
9.1.3  稳定性、高效性	722
9.1.4  花费最小化，利益最大化	723
9.2  如何面对挑战	723
9.2.1  使用建模工具	723
9.2.2  利用优秀的框架	723
9.2.3  选择性地扩展	725
9.2.4  使用代码生成器	726
9.3  常见设计模式精讲	726
9.3.1  单例模式	727
9.3.2  简单工厂	728
9.3.3  工厂方法和抽象工厂	734
9.3.4  代理模式	737
9.3.5  命令模式	742
9.3.6  策略模式	745
9.3.7  门面模式	748
9.3.8  桥接模式	750
9.3.9  观察者模式	754
9.4  常见的架构设计策略	757
9.4.1  贫血模型	757
9.4.2  领域对象模型	760
9.4.3  合并业务逻辑对象与DAO对象	762
9.4.4  合并业务逻辑对象和Domain Object	763
9.4.5  抛弃业务逻辑层	764
9.5  本章小结	765
第10章　简单工作流系统	766
10.1  项目背景及系统结构	767
10.1.1  应用背景	767
10.1.2  系统功能介绍	767
10.1.3  相关技术介绍	768
10.1.4  系统结构	768
10.1.5  系统的功能模块	769
10.2  Hibernate持久层	770
10.2.1  设计持久化实体	770
10.2.2  创建持久化实体类	771
10.3  实现DAO层	777
10.3.1  DAO组件的定义	778
10.3.2  实现DAO组件	780
10.3.3  部署DAO层	783
10.4  实现Service层	784
10.4.1  业务逻辑组件的设计	785
10.4.2  实现业务逻辑组件	785
10.4.3  事务管理	790
10.4.4  部署业务逻辑组件	791
10.5  实现任务的自动调度	791
10.5.1  使用Quartz	791
10.5.2  在Spring中使用Quartz	795
10.6  实现系统Web层	798
10.6.1  Struts 2和Spring的整合	798
10.6.2  控制器的处理顺序图	799
10.6.3  员工登录	799
10.6.4  进入打卡	802
10.6.5  处理打卡	803
10.6.6  进入申请	805
10.6.7  提交申请	806
10.6.8  使用拦截器完成权限管理	808
10.7  本章小结	809
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java EE企业应用实战（第4版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
中文版序
引言
作者的话
致谢
一 明天的寓言
二 忍耐的义务
三 死神的特效药
四 地表水和地下海
五 土壤的王国
六 地球的绿色斗篷
七 不必要的大破坏
八 再也没有鸟儿歌唱
九 死亡的河流
一〇 无人幸免的天灾
一一 超越波吉亚家族的梦想
一二 人类的代价
一三 通过一扇狭小的窗户
一四 每四个中有一个
一五 大自然在反抗
一六 崩溃声隆隆
一七 另一条道路
附录
参考文献
译者后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring in Action（中文版）
第一部分 spring的核心
第1章 开始spring之旅
1.1 spring是什么
1.2 开始spring之旅
1.3 理解依赖注入
1.3.1 依赖注入
1.3.2 di应用
1.3.3 企业级应用中的依赖注入
1.4 应用aop
1.4.1 aop介绍
1.4.2 aop使用
1.5 小结
第2章 基本bean装配
2.1 容纳你的bean
2.1.1 beanfactory介绍
2.1.2 使用应用上下文
2.1.3 bean的生命
2.2 创建bean
2.2.1 声明一个简单的bean
2.2.2 通过构造函数注入
2.3 注入bean属性
2.3.1 注入简单的数值
2.3.2 使用其他的bean
2.3.3 装配集合
2.3.4 装配空值
2.4 自动装配
2.4.1 四种自动装配类型
2.4.2 混合使用自动和手动装配
2.4.3 何时采用自动装配
2.5 控制bean创建
2.5.1 bean范围化
2.5.2 利用工厂方法来创建bean
2.5.3 初始化和销毁bean
2.6 小结
第3章 高级bean装配
3.1 声明父bean和子bean
3.1.1 抽象基bean类型
3.1.2 抽象共同属性
3.2 方法注入
3.2.1 基本的方法替换
3.2.2 获取器注入
3.3 注入非spring bean
3.4 注册自定义属性编辑器
3.5 使用spring的特殊bean
3.5.1 后处理bean
3.5.2 bean工厂的后处理
3.5.3 配置属性的外在化
3.5.4 提取文本消息
3.5.5 程序事件的解耦
3.5.6 让bean了解容器
3.6 脚本化的bean
3.6.1 给椰子上lime
3.6.2 脚本化bean
3.6.3 注入脚本化bean的属性
3.6.4 刷新脚本化bean
3.6.5 编写内嵌的脚本化bean
3.7 小结
第4章 通知bean
4.1 aop简介
4.1.1 定义aop术语
4.1.2 spring对aop的支持
4.2 创建典型的spring切面
4.2.1 创建通知
4.2.2 定义切点和通知者
4.2.3 使用proxyfactorybean
4.3 自动代理
4.3.1 为spring切面创建自动代理
4.3.2 自动代理@aspectj切面
4.4 定义纯粹的pojo切面
4.5 注入aspectj切面
4.6 小结
第二部分 企业spring
第5章 使用数据库
5.1 spring的数据访问哲学
5.1.1 了解spring数据访问的异常体系
5.1.2 数据访问的模板化
5.1.3 使用dao支持类
5.2 配置数据源
5.2.1 使用jndi数据源
5.2.2 使用数据源连接池
5.2.3 基于jdbc驱动的数据源
5.3 在spring里使用jdbc
5.3.1 处理失控的jdbc代码
5.3.2 使用jdbc模板
5.3.3 使用spring对jdbc的dao支持类
5.4 在spring里集成hibernate
5.4.1 选择hibernate的版本
5.4.2 使用hibernate模板
5.4.3 建立基于hibernate的dao
5.4.4 使用hibernate 3上下文会话
5.5 spring和java持久api
5.5.1 使用jpa模板
5.5.2 创建一个实体管理器工厂
5.5.3 建立使用jpa的dao
5.6 spring和ibatis
5.6.1 配置ibatis客户模板
5.6.2 建立基于ibatis的dao
5.7 缓存
5.7.1 配置缓存方案
5.7.2 缓存的代理bean
5.7.3 注解驱动的缓存
5.8 小结
第6章 事务管理
6.1 理解事务
6.1.1 仅用4个词解释事务
6.1.2 理解spring对事务管理的支持
6.2 选择事务管理器
6.2.1 jdbc事务
6.2.2 hibernate事务
6.2.3 jpa事务
6.2.4 jdo事务
6.2.5 jta事务
6.3 在spring中编写事务
6.4 声明式事务
6.4.1 定义事务参数
6.4.2 代理事务
6.4.3 在spring 2.0里声明事务
6.4.4 定义注释驱动事务
6.5 小结
第7章 保护spring
7.1 spring security介绍
7.2 验证用户身份
7.2.1 配置provider manager
7.2.2 根据数据库验证身份
7.2.3 根据ldap仓库进行身份验证
7.3 控制访问
7.3.1 访问决策投票
7.3.2 决定如何投票
7.3.3 处理投票弃权
7.4 保护web应用程序
7.4.1 代理spring security的过滤器
7.4.2 处理安全上下文
7.4.3 提示用户登录
7.4.4 处理安全例外
7.4.5 强制web安全性
7.4.6 确保一个安全的通道
7.5 视图层安全
7.5.1 有条件地渲染内容
7.5.2 显示用户身份验证信息
7.6 保护方法调用
7.6.1 创建一个安全切面
7.6.2 使用元数据保护方法
7.7 小结
第8章 spring和基于pojo的远程服务
8.1 spring远程调用概览
8.2 与rmi一起工作
8.2.1 连接rmi服务
8.2.2 输出rmi服务
8.3 使用hessian和burlap的远程调用
8.3.1 访问hessian/burlap服务
8.3.2 用hessian或burlap公开bean的功能
8.4 使用http invoker
8.4.1 通过http访问服务
8.4.2 把bean作为http服务公开
8.5 spring和web服务
8.5.1 使用xfire将bean输出为web服务
8.5.2 使用jsr-181注释声明web服务
8.5.3 消费web服务
8.5.4 使用xfire客户端代理web服务
8.6 小结
第9章 在spring中建立契约优先web服务
9.1 介绍spring-ws
9.2 定义契约(首先！)
9.3 使用服务端点处理消息
9.3.1 建立基于jdom消息的端点
9.3.2 序列化消息载荷
9.4 合并在一起
9.4.1 spring-ws：全景视图
9.4.2 将消息映射到端点
9.4.3 置入服务端点
9.4.4 配置消息序列化器
9.4.5 处理端点异常
9.4.6 提供wsdl文件
9.4.7 部署服务
9.5 消费spring-ws web服务
9.5.1 使用web服务模板
9.5.2 使用web服务的网关支持
9.6 小结
第10章 spring消息
10.1 jms简介
10.1.1 构建jms
10.1.2 介绍jms的优点
10.1.3 在spring中安装activemq
10.2 协同使用jms和spring
10.2.1 处理冗长失控的jms代码
10.2.2 使用jms模板
10.2.3 转换消息
10.2.4 将spring的网关支持类应用于jms
10.3 创建消息驱动pojo
10.3.1 创建消息监听器
10.3.2 编写纯pojo mdp
10.4 使用基于消息的rpc
10.4.1 引入lingo
10.4.2 输出服务
10.4.3 代理jms
10.5 小结
第11章 spring和ejb
11.1 在spring中置入ejb
11.1.1 代理会话bean(ejb 2.x)
11.1.2 将ejb置入spring bean
11.2 开发spring驱动的ejb(ejb 2.x)
11.3 spring和ejb3
11.3.1 引入pitchfork
11.3.2 从pitchfork起步
11.3.3 通过注释注入资源
11.3.4 使用注释声明拦截器
11.4 小结
第12章 访问企业服务
12.1 从jndi中获取对象
12.1.1 使用传统的jndi
12.1.2 注入jndi对象
12.1.3 在spring 2中注入jndi对象
12.2 发送电子邮件
12.2.1 配置邮件发送器
12.2.2 构建电子邮件
12.3 调度任务
12.3.1 使用java timer调度任务
12.3.2 使用quartz调度器
12.3.3 按调度计划调用方法
12.4 使用jmx管理spring bean
12.4.1 将spring bean输出为mbean
12.4.2 远程访问mbean
12.4.3 处理通知
12.5 小结
第三部分 spring客户端
第13章 处理web请求
13.1 开始spring mvc之旅
13.1.1 请求生命中的一天
13.1.2 配置dispatcherservlet
13.1.3 spring mvc概述
13.2 将请求映射到控制器
13.2.1 使用simpleurlhandler mapping
13.2.2 使用controllerclassname handlermapping
13.2.3 使用元数据映射控制器
13.2.4 使用多映射处理器
13.3 用控制器处理请求
13.3.1 处理命令
13.3.2 处理表单提交
13.3.3 用向导处理复杂表单
13.3.4 使用一次性控制器
13.4 处理异常
13.5 小结
第14章 渲染web视图
14.1 视图解析
14.1.1 使用模板视图
14.1.2 解析视图bean
14.1.3 选择视图解析器
14.2 使用spring模板
14.2.1 绑定表单数据
14.2.2 渲染被存储在外部的文本
14.2.3 显示错误
14.3 使用tile设计页面布局
14.3.1 tile视图
14.3.2 tile控制器
14.4 使用jsp的替代技术
14.4.1 使用velocity模板
14.4.2 使用freemarker
14.5 产生非html输出
14.5.1 产生excel工作表
14.5.2 产生pdf文档
14.5.3 开发自定义视图
14.6 小结
第15章 使用spring web flow
15.1 开始spring web flow之旅
15.1.1 安装spring web flow
15.1.2 配置流程执行程序
15.1.3 登记流程定义
15.2 布置流程的基础
15.2.1 流程变量
15.2.2 start和end状态
15.2.3 搜集顾客信息
15.2.4 绑定比萨饼订单
15.2.5 完成订单
15.2.6 几个结束工作
15.3 高级web流程技术
15.3.1 使用decision状态
15.3.2 提炼子流程并使用子状态
15.4 集成spring web flow与其他框架
15.4.1 jakarts struts
15.4.2 javaserver face
15.5 小结
第16章 集成其他web框架
16.1 协同使用spring和struts
16.1.1 向struts注册spring插件
16.1.2 编写知晓spring的struts动作
16.1.3 委托spring配置的动作
16.1.4 关于struts 2
16.2 协同使用spring和webwork 2/struts 2
16.3 集成spring和tapestry
16.3.1 集成spring和tapestry 3
16.3.2 集成spring和tapestry 4
16.4 协同使用spring和jsf
16.4.1 解析jsf管理的属性
16.4.2 解析spring bean
16.4.3 在jsf页面中使用spring bean
16.4.4 在jsf中暴露应用程序环境
16.5 spring中带有dwr的支持ajax的应用程序
16.5.1 直接web远程控制
16.5.2 访问spring管理的bean dwr
16.6 小结
附录a 装配spring
a.1 下载spring
a.1.1 研究spring发布
a.1.2 构建自己的类路径
a.2 把spring添加为一个maven 2依赖项
a.3 spring与ant
a.4 spring与log4j
附录b 用(和不用)spring进行测试
b.1 测试简介
b.1.1 理解不同类型的测试
b.1.2 使用junit
b.1.3 spring在测试中的角色
b.2 单元测试spring mvc控制器
b.2.1 模拟对象
b.2.2 断言modelandview的内容
b.3 使用spring进行综合测试
b.3.1 测试装配后的对象
b.3.2 综合测试事务处理对象
b.3.3 测试数据库
b.3.4 使用gienah testing在junit 4中进行测试
b.4 小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring in Action（中文版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java EE企业应用实战（第5版）
第1章  Java EE应用和开发环境  1
1.1  Java EE应用概述  2
1.1.1  Java EE应用的分层模型  2
1.1.2  Java EE应用的组件  3
1.1.3  Java EE应用的结构和优势  4
1.1.4  常用的Java EE服务器  4
1.2  轻量级Java EE应用相关技术  5
1.2.1  JSP、Servlet 3.x和JavaBean及替代技术  5
1.2.2  Struts 2.5及替代技术  5
1.2.3  Hibernate 5.2及替代技术  6
1.2.4  Spring 5.0及替代技术  6
1.3  Tomcat的下载和安装  7
1.3.1  安装Tomcat服务器  8
1.3.2  配置Tomcat的服务端口  9
1.3.3  进入控制台  9
1.3.4  部署Web应用  12
1.3.5  配置Tomcat的数据源  12
1.4  Eclipse的安装和使用  14
1.4.1  Eclipse的下载和安装  14
1.4.2  在线安装Eclipse插件  15
1.4.3  从本地压缩包安装插件  17
1.4.4  手动安装Eclipse插件  17
1.4.5  使用Eclipse开发Java EE应用  17
1.4.6  导入Eclipse项目  20
1.4.7  导入非Eclipse项目  21
1.5  Ant的安装和使用  22
1.5.1  Ant的下载和安装  23
1.5.2  使用Ant工具  23
1.5.3  定义生成文件  25
1.5.4  Ant的任务（task）  29
1.6  Maven的安装和使用  31
1.6.1  下载和安装Maven  31
1.6.2  设置Maven  32
1.6.3  创建、构建简单的项目  33
1.6.4  Maven的核心概念  36
1.6.5  依赖管理  41
1.6.6  POM文件的元素  43
1.7  使用SVN进行协作开发  44
1.7.1  下载和安装SVN服务器  45
1.7.2  配置SVN资源库  45
1.7.3  下载和安装SVN客户端  47
1.7.4  将项目发布到服务器  47
1.7.5  从服务器下载项目  48
1.7.6  提交（Commit）修改  48
1.7.7  同步（Update）本地文件  48
1.7.8  添加文件和目录  49
1.7.9  删除文件和目录  50
1.7.10  查看文件或目录的版本变革  50
1.7.11  从以前版本重新开始  50
1.7.12  创建分支  51
1.7.13  沿着分支开发  51
1.7.14  合并分支  52
1.7.15  使用Eclipse作为SVN客户端  52
1.8  使用Git进行软件配置管理（SCM）  55
1.8.1  下载和安装Git、TortoiseGit  56
1.8.2  创建本地资源库  58
1.8.3  添加（Add）文件和目录  59
1.8.4  提交（Commit）修改  60
1.8.5  查看文件或目录的版本变更  61
1.8.6  删除文件和目录  62
1.8.7  从以前版本重新开始  62
1.8.8  克隆（Clone）项目  63
1.8.9  创建分支  64
1.8.10  沿着分支开发  64
1.8.11  合并分支  65
1.8.12  使用Eclipse作为Git客户端  65
1.8.13  配置远程中央资源库  67
1.8.14  推送（Push）项目  69
1.8.15  获取（Fetch）项目和拉取（Pull）项目  70
1.9  本章小结  72
第2章  JSP/Servlet及相关技术详解  73
2.1  Web应用和web.xml文件  74
2.1.1  构建Web应用  74
2.1.2  配置描述符web.xml  75
2.2  JSP的基本原理  76
2.3  JSP的4种基本语法  80
2.3.1  JSP注释  80
2.3.2  JSP声明  81
2.3.3  JSP输出表达式  82
2.3.4  JSP小脚本  83
2.4  JSP的3个编译指令  85
2.4.1  page指令  85
2.4.2  include指令  89
2.5  JSP的7个动作指令  90
2.5.1  forward指令  90
2.5.2  include指令  92
2.5.3  useBean、setProperty、getProperty指令  93
2.5.4  plugin指令  96
2.5.5  param指令  96
2.6  JSP脚本中的9个内置对象  96
2.6.1  application对象  98
2.6.2  config对象  103
2.6.3  exception对象  105
2.6.4  out对象  107
2.6.5  pageContext对象  108
2.6.6  request对象  109
2.6.7  response对象  116
2.6.8  session对象  120
2.7  Servlet介绍  122
2.7.1  Servlet的开发  122
2.7.2  Servlet的配置  124
2.7.3  JSP/Servlet的生命周期  125
2.7.4  load-on-startup Servlet  126
2.7.5  访问Servlet的配置参数  127
2.7.6  使用Servlet作为控制器  129
2.8  JSP 2的自定义标签  133
2.8.1  开发自定义标签类  133
2.8.2  建立TLD文件  134
2.8.3  使用标签库  135
2.8.4  带属性的标签  136
2.8.5  带标签体的标签  139
2.8.6  以页面片段作为属性的标签  141
2.8.7  动态属性的标签  143
2.9  Filter介绍  144
2.9.1  创建Filter类  145
2.9.2  配置Filter  146
2.9.3  使用URL Rewrite实现网站伪静态  149
2.10  Listener介绍  150
2.10.1  实现Listener类  151
2.10.2  配置Listener  152
2.10.3  使用ServletContextAttributeListener  153
2.10.4  使用ServletRequestListener和ServletRequestAttributeListener  154
2.10.5  使用HttpSessionListener和HttpSessionAttributeListener  155
2.11  JSP 2特性  160
2.11.1  配置JSP属性  160
2.11.2  表达式语言  162
2.11.3  Tag File支持  170
2.12  Servlet 3新特性  172
2.12.1  Servlet 3的注解  172
2.12.2  Servlet 3的Web模块支持  172
2.12.3  Servlet 3提供的异步处理  174
2.12.4  改进的Servlet API  177
2.13  Servlet 3.1新增的非阻塞式IO  180
2.14  Tomcat 8.5的WebSocket支持  182
2.15  本章小结  187
第3章  Struts 2的基本用法  188
3.1  MVC思想概述  189
3.1.1  传统Model 1和Model 2  189
3.1.2  MVC思想及其优势  190
3.2  Struts 2的下载和安装  191
3.2.1  为Web应用增加Struts 2支持  191
3.2.2  在Eclipse中使用Struts 2  192
3.2.3  增加登录处理  193
3.3  Struts 2的流程  196
3.3.1  Struts 2应用的开发步骤  196
3.3.2  Struts 2的运行流程  197
3.4  Struts 2的常规配置  198
3.4.1  常量配置  198
3.4.2  包含其他配置文件  204
3.5  实现Action  204
3.5.1  Action接口和ActionSupport基类  206
3.5.2  Action访问Servlet API  208
3.5.3  Action直接访问Servlet API  210
3.5.4  使用ServletActionContext访问Servlet API  212
3.6  配置Action  212
3.6.1  包和命名空间  213
3.6.2  Action的基本配置  216
3.6.3  使用Action的动态方法调用  217
3.6.4  指定method属性及使用通配符  219
3.6.5  配置默认Action  224
3.6.6  配置Action的默认处理类  225
3.7  配置处理结果  225
3.7.1  理解处理结果  225
3.7.2  配置结果  226
3.7.3  Struts 2支持的结果类型  227
3.7.4  plainText结果类型  229
3.7.5  redirect结果类型  230
3.7.6  redirectAction结果类型  231
3.7.7  动态结果  232
3.7.8  Action属性值决定物理视图资源  232
3.7.9  全局结果  234
3.7.10  使用PreResultListener  235
3.8  配置Struts 2的异常处理  236
3.8.1  Struts 2的异常处理机制  236
3.8.2  声明式异常捕捉  238
3.8.3  输出异常信息  239
3.9  Convention插件与“约定”支持  240
3.9.1  Action的搜索和映射约定  241
3.9.2  按约定映射Result  243
3.9.3  Action链的约定  246
3.9.4  自动重加载映射  247
3.9.5  Convention插件的相关常量  247
3.9.6  Convention插件相关注解  248
3.10  使用Struts 2的国际化  248
3.10.1  视图页面的国际化  249
3.10.2  Action的国际化  250
3.10.3  使用包范围的国际化资源  251
3.10.4  使用全局国际化资源  252
3.10.5  输出带占位符的国际化消息  254
3.10.6  加载资源文件的顺序  256
3.11  使用Struts 2的标签库  256
3.11.1  Struts 2标签库概述  256
3.11.2  使用Struts 2标签  257
3.11.3  Struts 2的OGNL表达式语言  258
3.11.4  OGNL中的集合操作  260
3.11.5  访问静态成员  261
3.11.6  Lambda（）表达式  261
3.11.7  控制标签  262
3.11.8  数据标签  271
3.11.9  主题和模板  279
3.11.10  自定义主题  281
3.11.11  表单标签  282
3.11.12  非表单标签  294
3.12  本章小结  297
第4章  深入使用Struts 2  298
4.1  详解Struts 2的类型转换  299
4.1.1  Struts 2内建的类型转换器  299
4.1.2  基于OGNL的类型转换  300
4.1.3  指定集合元素的类型  302
4.1.4  自定义类型转换器  304
4.1.5  注册类型转换器  306
4.1.6  基于Struts 2的自定义类型转换器  308
4.1.7  处理Set集合  308
4.1.8  类型转换中的错误处理  311
4.2  使用Struts 2的输入校验  316
4.2.1  编写校验规则文件  316
4.2.2  国际化提示信息  319
4.2.3  使用客户端校验  320
4.2.4  字段校验器配置风格  321
4.2.5  非字段校验器配置风格  322
4.2.6  短路校验器  324
4.2.7  校验文件的搜索规则  325
4.2.8  校验顺序和短路  327
4.2.9  内建校验器  327
4.2.10  基于注解的输入校验  337
4.2.11  手动完成输入校验  339
4.3  使用Struts 2控制文件上传  342
4.3.1  Struts 2的文件上传  342
4.3.2  实现文件上传的Action  343
4.3.3  配置文件上传的Action  345
4.3.4  手动实现文件过滤  347
4.3.5  拦截器实现文件过滤  348
4.3.6  输出错误提示  349
4.3.7  文件上传的常量配置  350
4.4  使用Struts 2控制文件下载  351
4.4.1  实现文件下载的Action  351
4.4.2  配置Action  352
4.4.3  下载前的授权控制  352
4.5  详解Struts 2的拦截器机制  353
4.5.1  拦截器在Struts 2中的作用  354
4.5.2  Struts 2内建的拦截器  354
4.5.3  配置拦截器  356
4.5.4  使用拦截器的配置语法  357
4.5.5  配置默认拦截器  358
4.5.6  实现拦截器类  360
4.5.7  使用拦截器  361
4.5.8  拦截方法的拦截器  362
4.5.9  拦截器的执行顺序  365
4.5.10  拦截结果的监听器  366
4.5.11  覆盖拦截器栈里特定拦截器的参数  367
4.5.12  使用拦截器完成权限控制  368
4.6  使用Struts 2的Ajax支持  370
4.6.1  使用stream类型的Result实现Ajax  370
4.6.2  JSON的基本知识  372
4.6.3  实现Action逻辑  375
4.6.4  JSON插件与json类型的Result  376
4.6.5  实现JSP页面  377
4.7  本章小结  378
第5章  Hibernate的基本用法  380
5.1  ORM和Hibernate  381
5.1.1  对象/关系数据库映射（ORM）  381
5.1.2  基本映射方式  382
5.1.3  流行的ORM框架简介  383
5.1.4  Hibernate概述  383
5.2  Hibernate入门  384
5.2.1  Hibernate下载和安装  384
5.2.2  Hibernate的数据库操作  385
5.2.3  在Eclipse中使用Hibernate  389
5.3  Hibernate的体系结构  392
5.4  深入Hibernate配置文件  393
5.4.1  创建Configuration对象  393
5.4.2  hibernate.properties文件与hibernate.cfg.xml文件  396
5.4.3  JDBC连接属性  396
5.4.4  数据库方言  397
5.4.5  JNDI数据源的连接属性  398
5.4.6  Hibernate事务属性  399
5.4.7  二级缓存相关属性  399
5.4.8  外连接抓取属性  399
5.4.9  其他常用的配置属性  400
5.5  深入理解持久化对象  400
5.5.1  持久化类的要求  400
5.5.2  持久化对象的状态  401
5.5.3  改变持久化对象状态的方法  402
5.6  深入Hibernate映射  405
5.6.1  映射属性  407
5.6.2  映射主键  415
5.6.3  使用Hibernate的主键生成器  417
5.6.4  映射集合属性  418
5.6.5  集合属性的性能分析  424
5.6.6  有序集合映射  426
5.6.7  映射数据库对象  427
5.7  映射组件属性  430
5.7.1  组件属性为集合  432
5.7.2  集合属性的元素为组件  433
5.7.3  组件作为Map的索引  434
5.7.4  组件作为复合主键  436
5.7.5  多列作为联合主键  438
5.8  使用传统的映射文件  439
5.8.1  增加XML映射文件  439
5.8.2  注解，还是XML映射文件  441
5.9  本章小结  442
第6章  深入使用Hibernate与JPA  443
6.1  Hibernate的关联映射  444
6.1.1  单向N－1关联  444
6.1.2  单向1－1关联  449
6.1.3  单向1－N关联  450
6.1.4  单向N－N关联  453
6.1.5  双向1－N关联  455
6.1.6  双向N－N关联  458
6.1.7  双向1－1关联  459
6.1.8  组件属性包含的关联实体  461
6.1.9  基于复合主键的关联关系  463
6.1.10  复合主键的成员属性为关联实体  464
6.1.11  持久化的传播性  467
6.2  继承映射  468
6.2.1  整个类层次对应一个表的映射策略  470
6.2.2  连接子类的映射策略  472
6.2.3  每个具体类对应一个表的映射策略  475
6.3  批量处理策略  477
6.3.1  批量插入  477
6.3.2  JPA与Hibernate  478
6.3.3  JPA的批量插入  479
6.3.4  批量更新  481
6.3.5  DML风格的批量更新/删除  481
6.3.6  JPA的DML支持  482
6.4  HQL查询和JPQL查询  483
6.4.1  HQL查询  483
6.4.2  JPQL查询  485
6.4.3  from子句  487
6.4.4  关联和连接  487
6.4.5  查询的select子句  490
6.4.6  HQL查询的聚集函数  491
6.4.7  多态查询  491
6.4.8  HQL查询的where子句  492
6.4.9  表达式  493
6.4.10  order by子句  495
6.4.11  group by子句  495
6.4.12  子查询  495
6.4.13  命名查询  496
6.5  动态条件查询  497
6.5.1  执行DML语句  501
6.5.2  select的用法  502
6.5.3  元组查询  503
6.5.4  多Root查询  504
6.5.5  关联和动态关联  505
6.5.6  分组、聚集和排序  508
6.6  原生SQL查询  510
6.6.1  标量查询  510
6.6.2  实体查询  511
6.6.3  处理关联和继承  514
6.6.4  命名SQL查询  515
6.6.5  调用存储过程  517
6.6.6  使用定制SQL  518
6.6.7  JPA的原生SQL查询  520
6.7  数据过滤  524
6.8  事务控制  526
6.8.1  事务的概念  527
6.8.2  Session与事务  527
6.8.3  上下文相关的Session  529
6.9  二级缓存和查询缓存  530
6.9.1  开启二级缓存  530
6.9.2  管理缓存和统计缓存  533
6.9.3  使用查询缓存  534
6.10  事件机制  537
6.10.1  拦截器  537
6.10.2  事件系统  539
6.11  本章小结  541
第7章  Spring的基本用法  542
7.1  Spring简介和Spring 5.0的变化  543
7.1.1  Spring简介  543
7.1.2  Spring 5.0的变化  544
7.2  Spring入门  544
7.2.1  Spring下载和安装  544
7.2.2  使用Spring管理Bean  545
7.2.3  在Eclipse中使用Spring  548
7.3  Spring的核心机制：依赖注入  551
7.3.1  理解依赖注入  552
7.3.2  设值注入  553
7.3.3  构造注入  557
7.3.4  两种注入方式的对比  558
7.4  使用Spring容器  559
7.4.1  Spring容器  559
7.4.2  使用ApplicationContext  560
7.4.3  ApplicationContext的国际化支持  562
7.4.4  ApplicationContext的事件机制  563
7.4.5  让Bean获取Spring容器  566
7.5  Spring容器中的Bean  568
7.5.1  Bean的基本定义和Bean别名  568
7.5.2  容器中Bean的作用域  569
7.5.3  配置依赖  572
7.5.4  设置普通属性值  574
7.5.5  配置合作者Bean  575
7.5.6  使用自动装配注入合作者Bean  575
7.5.7  注入嵌套Bean  578
7.5.8  注入集合值  579
7.5.9  组合属性  583
7.5.10  Spring的Bean和JavaBean  584
7.6  Spring提供的Java配置管理  585
7.7  创建Bean的3种方式  588
7.7.1  使用构造器创建Bean实例  588
7.7.2  使用静态工厂方法创建Bean  589
7.7.3  调用实例工厂方法创建Bean  591
7.8  深入理解容器中的Bean  593
7.8.1  抽象Bean与子Bean  593
7.8.2  Bean继承与Java继承的区别  595
7.8.3  容器中的工厂Bean  595
7.8.4  获得Bean本身的id  597
7.8.5  强制初始化Bean  598
7.9  容器中Bean的生命周期  598
7.9.1  依赖关系注入之后的行为  599
7.9.2  Bean销毁之前的行为  601
7.9.3  协调作用域不同步的Bean  603
7.10  高级依赖关系配置  606
7.10.1  获取其他Bean的属性值  607
7.10.2  获取Field值  609
7.10.3  获取方法返回值  611
7.11  基于XML Schema的简化配置方式  614
7.11.1  使用p:命名空间简化配置  614
7.11.2  使用c:命名空间简化配置  615
7.11.3  使用util:命名空间简化配置  617
7.12  Spring提供的表达式语言（SpEL）  619
7.12.1  使用Expression接口进行表达式求值  619
7.12.2  Bean定义中的表达式语言支持  621
7.12.3  SpEL语法详述  622
7.13  本章小结  627
第8章  深入使用Spring  628
8.1  两种后处理器  629
8.1.1  Bean后处理器  629
8.1.2  Bean后处理器的用处  633
8.1.3  容器后处理器  633
8.1.4  属性占位符配置器  634
8.1.5  重写占位符配置器  636
8.2  Spring的“零配置”支持  637
8.2.1  搜索Bean类  637
8.2.2  指定Bean的作用域  640
8.2.3  使用@Resource和@Value配置依赖  640
8.2.4  使用@PostConstruct和@PreDestroy定制生命周期行为  641
8.2.5  使用@DependsOn和@Lazy改变初始化行为  642
8.2.6  自动装配和精确装配  643
8.2.7  Spring 5新增的注解  647
8.2.8  使用@Required检查注入  648
8.3  资源访问  648
8.3.1  Resource实现类  649
8.3.2  ResourceLoader接口和ResourceLoaderAware接口  653
8.3.3  使用Resource作为属性  655
8.3.4  在ApplicationContext中使用资源  656
8.4  Spring的AOP  660
8.4.1  为什么需要AOP  660
8.4.2  使用AspectJ实现AOP  661
8.4.3  AOP的基本概念  667
8.4.4  Spring的AOP支持  668
8.4.5  基于注解的“零配置”方式  669
8.4.6  基于XML配置文件的管理方式  684
8.5  Spring的缓存机制  690
8.5.1  启用Spring缓存  690
8.5.2  使用@Cacheable执行缓存  693
8.5.3  使用@CacheEvict清除缓存  696
8.6  Spring的事务  698
8.6.1  Spring支持的事务策略  698
8.6.2  使用XML Schema配置事务策略  702
8.6.3  使用@Transactional  708
8.7  Spring整合Struts 2  709
8.7.1  启动Spring容器  709
8.7.2  MVC框架与Spring整合的思考  710
8.7.3  让Spring管理控制器  711
8.7.4  使用自动装配  715
8.8  Spring整合Hibernate  717
8.8.1  Spring提供的DAO支持  717
8.8.2  管理Hibernate的SessionFactory  718
8.8.3  实现DAO组件的基类  719
8.8.4  HibernateTemplate和HibernateDaoSupport  722
8.8.5  实现DAO组件  725
8.8.6  使用IoC容器组装各种组件  725
8.8.7  使用声明式事务  728
8.9  Spring整合JPA  729
8.9.1  管理EntityManagerFactory  729
8.9.2  实现DAO组件基类  732
8.9.3  使用声明式事务  734
8.10  本章小结  735
第9章  企业应用开发的思考和策略  736
9.1  企业应用开发面临的挑战  737
9.1.1  可扩展性、可伸缩性  737
9.1.2  快捷、可控的开发  738
9.1.3  稳定性、高效性  738
9.1.4  花费最小化，利益最大化  739
9.2  如何面对挑战  739
9.2.1  使用建模工具  739
9.2.2  利用优秀的框架  739
9.2.3  选择性地扩展  741
9.2.4  使用代码生成器  742
9.3  常见设计模式精讲  742
9.3.1  单例模式  743
9.3.2  简单工厂  744
9.3.3  工厂方法和抽象工厂  750
9.3.4  代理模式  753
9.3.5  命令模式  758
9.3.6  策略模式  761
9.3.7  门面模式  763
9.3.8  桥接模式  766
9.3.9  观察者模式  769
9.4  常见的架构设计策略  773
9.4.1  贫血模型  773
9.4.2  领域对象模型  776
9.4.3  合并业务逻辑组件与DAO组件  778
9.4.4  合并业务逻辑组件和Domain Object  779
9.4.5  抛弃业务逻辑层  780
9.5  本章小结  781
第10章  简单工作流系统  782
10.1  项目背景及系统结构  783
10.1.1  应用背景  783
10.1.2  系统功能介绍  783
10.1.3  相关技术介绍  784
10.1.4  系统结构  785
10.1.5  系统的功能模块  785
10.2  Hibernate持久层  786
10.2.1  设计持久化实体  786
10.2.2  创建持久化实体类  787
10.3  实现DAO层  792
10.3.1  DAO组件的定义  792
10.3.2  实现DAO组件  795
10.3.3  部署DAO层  797
10.4  实现Service层  799
10.4.1  业务逻辑组件的设计  799
10.4.2  实现业务逻辑组件  800
10.4.3  事务管理  805
10.4.4  部署业务逻辑组件  806
10.5  实现任务的自动调度  806
10.5.1  使用Quartz  806
10.5.2  在Spring中使用Quartz  810
10.6  实现系统Web层  813
10.6.1  Struts 2和Spring的整合  813
10.6.2  控制器的处理顺序图  814
10.6.3  员工登录  814
10.6.4  进入打卡  816
10.6.5  处理打卡  818
10.6.6  进入申请  819
10.6.7  提交申请  821
10.6.8  使用拦截器完成权限管理  823
10.7  本章小结  824
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java EE企业应用实战（第5版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker微服务架构实战
1 微服务架构概述. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.1 单体应用架构存在的问题1
1.2 如何解决单体应用架构存在的问题3
1.3 什么是微服务3
1.4 微服务架构的优点与挑战5
1.4.1 微服务架构的优点5
1.4.2 微服务架构面临的挑战5
1.5 微服务设计原则6
1.6 如何实现微服务架构7
1.6.1 技术选型7
1.6.2 架构图及常用组件8
2 微服务开发框架——Spring Cloud . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2.1 Spring Cloud 简介10
2.2 Spring Cloud 特点10
2.3 Spring Cloud 版本11
2.3.1 版本简介11
2.3.2 子项目一览12
2.3.3 Spring Cloud/Spring Boot 版本兼容性13
3 开始使用Spring Cloud 实战微服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
3.1 Spring Cloud 实战前提14
3.1.1 技术储备14
3.1.2 工具及软件版本15
3.2 服务提供者与服务消费者16
3.3 编写服务提供者16
3.3.1 手动编写项目17
3.3.2 使用Spring Initializr 快速创建Spring Boot 项目21
3.4 编写服务消费者23
3.5 为项目整合Spring Boot Actuator 25
3.6 硬编码有哪些问题27
4 微服务注册与发现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
4.1 服务发现简介29
4.2 Eureka 简介31
4.3 Eureka 原理31
4.4 编写Eureka Server 33
4.5 将微服务注册到Eureka Server 上35
4.6 Eureka Server 的高可用36
4.6.1 将应用注册到Eureka Server 集群上38
4.7 为Eureka Server 添加用户认证39
4.7.1 将微服务注册到需认证的Eureka Server 40
4.8 理解Eureka 的元数据41
4.8.1 改造用户微服务41
4.8.2 改造电影微服务41
4.9 Eureka Server 的REST 端点43
4.9.1 示例45
4.9.2 注销微服务实例49
4.10 Eureka 的自我保护模式51
4.11 多网卡环境下的IP 选择52
4.11.1 忽略指定名称的网卡52
4.11.2 使用正则表达式，指定使用的网络地址52
4.11.3 只使用站点本地地址53
4.11.4 手动指定IP 地址53
4.12 Eureka 的健康检查53
5 使用Ribbon 实现客户端侧负载均衡. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
5.1 Ribbon 简介56
5.2 为服务消费者整合Ribbon 57
5.3 使用Java 代码自定义Ribbon 配置60
5.4 使用属性自定义Ribbon 配置63
5.5 脱离Eureka 使用Ribbon 64
6 使用Feign 实现声明式REST 调用. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
6.1 Feign 简介67
6.2 为服务消费者整合Feign 67
6.3 自定义Feign 配置69
6.4 手动创建Feign 72
6.4.1 修改用户微服务72
6.4.2 修改电影微服务76
6.5 Feign 对继承的支持78
6.6 Feign 对压缩的支持79
6.7 Feign 的日志80
6.8 使用Feign 构造多参数请求82
6.8.1 GET 请求多参数的URL 82
6.8.2 POST 请求包含多个参数83
7 使用Hystrix 实现微服务的容错处理. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
7.1 实现容错的手段85
7.1.1 雪崩效应85
7.1.2 如何容错86
7.2 使用Hystrix 实现容错88
7.2.1 Hystrix 简介88
7.2.2 通用方式整合Hystrix 89
7.2.3 Hystrix 断路器的状态监控与深入理解91
7.2.4 Hystrix 线程隔离策略与传播上下文93
7.2.5 Feign 使用Hystrix 96
7.3 Hystrix 的监控101
7.3.1 Feign 项目的Hystrix 监控102
7.4 使用Hystrix Dashboard 可视化监控数据103
7.5 使用Turbine 聚合监控数据105
7.5.1 Turbine 简介105
7.5.2 使用Turbine 监控多个微服务105
7.5.3 使用消息中间件收集数据108
8 使用Zuul 构建微服务网关. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
8.1 为什么要使用微服务网关113
8.2 Zuul 简介115
8.3 编写Zuul 微服务网关115
8.4 Zuul 的路由端点118
8.5 Zuul 的路由配置详解119
8.6 Zuul 的安全与Header 122
8.6.1 敏感Header 的设置122
8.6.2 忽略Header 123
8.7 使用Zuul 上传文件124
8.7.1 编写文件上传微服务124
8.8 Zuul 的过滤器127
8.8.1 过滤器类型与请求生命周期127
8.8.2 编写Zuul 过滤器128
8.8.3 禁用Zuul 过滤器130
8.9 Zuul 的容错与回退130
8.9.1 为Zuul 添加回退131
8.10 Zuul 的高可用133
8.10.1 Zuul 客户端也注册到了Eureka Server 上133
8.10.2 Zuul 客户端未注册到Eureka Server 上133
8.11 使用Sidecar 整合非JVM 微服务134
8.11.1 编写Node.js 微服务135
8.11.2 编写Sidecar 136
8.11.3 Sidecar 的端点138
8.11.4 Sidecar 与Node.js 微服务分离部署139
8.11.5 Sidecar 原理分析139
9 使用Spring Cloud Config 统一管理微服务配置. . . . . . . . . . . . . . . . . . . . . . . 142
9.1 为什么要统一管理微服务配置142
9.2 Spring Cloud Config 简介143
9.3 编写Config Server 144
9.3.1 Config Server 的端点145
9.4 编写Config Client 147
9.5 Config Server 的Git 仓库配置详解149
9.6 Config Server 的健康状况指示器152
9.7 配置内容的加解密153
9.7.1 安装JCE 153
9.7.2 Config Server 的加解密端点153
9.7.3 对称加密153
9.7.4 存储加密的内容154
9.7.5 非对称加密155
9.8 使用/refresh 端点手动刷新配置155
9.9 使用Spring Cloud Bus 自动刷新配置157
9.9.1 Spring Cloud Bus 简介157
9.9.2 实现自动刷新158
9.9.3 局部刷新159
9.9.4 架构改进159
9.9.5 跟踪总线事件160
9.10 Spring Cloud Config 与Eureka 配合使用161
9.11 Spring Cloud Config 的用户认证162
9.11.1 Config Client 连接需用户认证的Config Server 163
9.12 Config Server 的高可用164
9.12.1 Git 仓库的高可用164
9.12.2 RabbitMQ 的高可用164
9.12.3 Config Server 自身的高可用165
10 使用Spring Cloud Sleuth 实现微服务跟踪. . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
10.1 为什么要实现微服务跟踪167
10.2 Spring Cloud Sleuth 简介168
10.3 整合Spring Cloud Sleuth 170
10.4 Spring Cloud Sleuth 与ELK 配合使用172
10.5 Spring Cloud Sleuth 与Zipkin 配合使用176
10.5.1 Zipkin 简介176
10.5.2 编写Zipkin Server 176
10.5.3 微服务整合Zipkin 178
10.5.4 使用消息中间件收集数据181
10.5.5 存储跟踪数据183
11 Spring Cloud 常见问题与总结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186
11.1 Eureka 常见问题186
11.1.1 Eureka 注册服务慢186
11.1.2 已停止的微服务节点注销慢或不注销187
11.1.3 如何自定义微服务的Instance ID 188
11.1.4 Eureka 的UNKNOWN 问题总结与解决189
11.2 Hystrix/Feign 整合Hystrix 后首次请求失败190
11.2.1 原因分析191
11.2.2 解决方案191
11.3 Turbine 聚合的数据不完整191
11.3.1 解决方案192
11.4 Spring Cloud 各组件配置属性193
11.4.1 Spring Cloud 的配置193
11.4.2 原生配置193
11.5 Spring Cloud 定位问题思路总结194
12 Docker 入门. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
12.1 Docker 简介197
12.2 Docker 的架构197
12.3 安装Docker 199
12.3.1 系统要求199
12.3.2 移除非官方软件包199
12.3.3 设置Yum 源199
12.3.4 安装Dokcer 200
12.3.5 卸载Docker 201
12.4 配置镜像加速器201
12.5 Docker 常用命令202
12.5.1 Docker 镜像常用命令202
12.5.2 Docker 容器常用命令204
13 将微服务运行在Docker 上. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
13.1 使用Dockerfile 构建Docker 镜像209
13.1.1 Dockerfile 常用指令210
13.1.2 使用Dockerfile 构建镜像215
13.2 使用Docker Registry 管理Docker 镜像217
13.2.1 使用Docker Hub 管理镜像217
13.2.2 使用私有仓库管理镜像219
13.3 使用Maven 插件构建Docker 镜像220
13.3.1 快速入门221
13.3.2 插件读取Dockerfile 进行构建222
13.3.3 将插件绑定在某个phase 执行223
13.3.4 推送镜像224
13.4 常见问题与总结226
14 使用Docker Compose 编排微服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227
14.1 Docker Compose 简介227
14.2 安装Docker Compose 227
14.2.1 安装Compose 228
14.2.2 安装Compose 命令补全工具228
14.3 Docker Compose 快速入门229
14.3.1 基本步骤229
14.3.2 入门示例229
14.3.3 工程、服务、容器230
14.4 docker-compose.yml 常用命令230
14.4.1 build 230
14.4.2 command 231
14.4.3 dns 231
14.4.4 dns_search 231
14.4.5 environment 231
14.4.6 env_file 232
14.4.7 expose 232
14.4.8 external_links 232
14.4.9 image 232
14.4.10 links 232
14.4.11 networks 233
14.4.12 network_mode 233
14.4.13 ports 233
14.4.14 volumes 233
14.4.15 volumes_from 234
14.5 docker-compose 常用命令234
14.5.1 build 234
14.5.2 help 235
14.5.3 kill 235
14.5.4 logs 235
14.5.5 port 235
14.5.6 ps 235
14.5.7 pull 235
14.5.8 rm 236
14.5.9 run 236
14.5.10 scale 236
14.5.11 start 236
14.5.12 stop 236
14.5.13 up 236
14.6 Docker Compose 网络设置237
14.6.1 基本概念237
14.6.2 更新容器237
14.6.3 links 238
14.6.4 指定自定义网络238
14.6.5 配置默认网络239
14.6.6 使用已存在的网络239
14.7 综合实战：使用Docker Comose 编排Spring Cloud 微服务240
14.7.1 编排Spring Cloud 微服务240
14.7.2 编排高可用的Eureka Server 243
14.7.3 编排高可用Spring Cloud 微服务集群及动态伸缩245
14.8 常见问题与总结247
后记. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker微服务架构实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java EE企业应用实战
第1章  Java EE应用和开发环境  1.1  Java EE应用概述    1.1.1  Java EE应用的分层模型    1.1.2  Java EE应用的组件    1.1.3  Java EE应用结构和优势    1.1.4  常用的Java EE服务器  1.2  轻量级Java EE应用相关技术    1.2.1  JSP、Servlet 3.0和JavaBean及替代技术    1.2.2  Struts 2.2及替代技术    1.2.3  Hibernate 3.6及替代技术    1.2.4  Spring 3.0及替代技术  1.3  Tomcat的下载和安装    1.3.1  安装Tomcat服务器    1.3.2  配置Tomcat的服务端口    1.3.3  进入控制台    1.3.4  部署Web应用    1.3.5  配置Tomcat的数据源  1.4  Eclipse的安装和使用    1.4.1  Eclipse的下载和安装    1.4.2  在线安装Eclipse插件    1.4.3  从本地压缩包安装插件    1.4.4  手动安装Eclipse插件    1.4.5  使用Eclipse开发Java EE应用    1.4.6  导入Eclipse项目    1.4.7  导入非Eclipse项目  1.5  Ant的安装和使用    1.5.1  Ant的下载和安装    1.5.2  使用Ant工具    1.5.3  定义生成文件    1.5.4  Ant的任务(task)  1.6  使用CVS进行协作开发    1.6.1  安装CVS服务器    1.6.2  配置CVS资源库    1.6.3  安装CVS客户端    1.6.4  发布项目到服务器    1.6.5  从服务器下载项目    1.6.6  同步(Update)本地文件    1.6.7  提交(Commit)修改    1.6.8  添加文件和目录    1.6.9  删除文件和目录    1.6.10  查看文件的版本变革    1.6.11  提取文件以前版本的内容    1.6.12  从以前版本重新开始    1.6.13  创建标签    1.6.14  创建分支    1.6.15  沿着分支开发    1.6.16  使用Eclipse作为CVS客户端  1.7  本章小结第2章  JSP/Servlet及相关技术详解  ……第3章  Struts 2的基本用法第4章  深入使用Struts 2第5章  Hibernate的基本用法第6章  深入使用Hibernate第7章  Spring的基本用法第8章  深入使用Spring第10章  简单工作流系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java EE企业应用实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>幸福假面
第一章 •001
第二章 •019
第三章 •035
第四章 •059
第五章 •069
第六章 •088
第七章 •105
第八章 •130
第九章 •165
第十章 •178
第十一章 •186
第十二章 •201
尾声 •210
特别收录
● 玛丽• 韦斯特马科特的秘密 罗莎琳德• 希克斯•223
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>幸福假面
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SpringBoot 揭秘
推荐序1
推荐序2
序言
前言
第1章了解微服务
1.1什么是微服务
1.2微服务因何而生
1.3微服务会带来哪些好处
1.3.1独立，独立，还是独立
1.3.2多语言生态
1.4微服务会带来哪些挑战
1.5本章小结
第2章饮水思源：回顾与探索Spring框架的本质
2.1Spring框架的起源
2.2Spring IoC其实很简单
2.3了解一点儿JavaConfig
2.3.1那些高曝光率的Annotation
2.4本章小结
第3章SpringBoot的工作机制
3.1SpringBoot初体验
3.2@SpringBootApplication背后的秘密
3.2.1@Configuration创世纪
3.2.2@EnableAutoConfiguration的功效
3.2.3可有可无的@ComponentScan
3.3SpringApplication：SpringBoot程序启动的一站式解决方案
3.3.1深入探索SpringApplication执行流程
3.3.2SpringApplicationRunListener
3.3.3ApplicationListener
3.3.4ApplicationContextInitializer
3.3.5CommandLineRunner
3.4再谈自动配置
3.4.1基于条件的自动配置
3.4.2调整自动配置的顺序
3.5本章小结
第4章了解纷杂的spring—boot—starter
4.1应用日志和spring—boot—starter—logging
4.2快速Web应用开发与spring—boot—starter—web
4.2.1项目结构层面的约定
4.2.2SpringMVC框架层面的约定和定制
4.2.3嵌入式Web容器层面的约定和定制
4.3数据访问与spring—boot—starter—jdbc
4.3.1SpringBoot应用的数据库版本化管理
4.4spring—boot—starter—aop及其使用场景说明
4.4.1spring—boot—starter—aop在构建spring—boot—starter—metrics自定义模块中的应用
4.5应用安全与spring—boot—starter—security
4.5.1了解SpringSecurity基本设计
4.5.2进一步定制spring—boot—starter—security
4.6应用监控与spring—boot—starter—actuator
4.6.1自定义应用的健康状态检查
4.6.2开放的endpoints才真正“有用”
4.6.3用还是不用，这是个问题
4.7本章小结
第5章SpringBoot微服务实践探索
5.1使用SpringBoot构建微服务
5.1.1创建基于Dubbo框架的SpringBoot微服务
5.1.2使用SpringBoot快速构建Web API
5.1.3使用SpringBoot构建其他形式的微服务
5.2SpringBoot微服务的发布与部署
5.2.1spring—boot—starter的发布与部署方式
5.2.2基于RPM的发布与部署方式
5.2.3基于Docker的发布与部署方式
5.3SpringBoot微服务的注册与发现
5.4SpringBoot微服务的监控与运维
5.4.1推还是拉，这一直是个问题
5.4.2从局部性触发式报警到系统性智能化报警
5.5SpringBoot微服务的安全与防护
5.6SpringBoot微服务体系的脊梁：发布与部署平台
5.7本章小结
第6章SpringBoot与Scala
6.1使用Maven构建和发布基于SpringBoot的Scala应用
6.1.1进一步简化基于Maven的Scala项目创建
6.1.2进一步简化基于Scala的Web API开发
6.2使用SBT构建和发布基于SpringBoot的Scala应用
6.2.1探索基于SBT的SpringBoot应用开发模式
6.2.2探索基于SBT的SpringBoot应用发布策略
6.3本章小结
第7章SpringBoot总结与展望
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SpringBoot 揭秘
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring
第一篇 系统介绍篇
第1章 权限管理系统介绍 3
1.1 系统简介 3
1.2 系统架构 4
1.2.1 前端架构 4
1.2.2 后端架构 4
1.3 系统界面 5
1.3.1 登录页面 5
1.3.2 系统主页 5
1.3.3 用户管理 6
1.3.4 机构管理 6
1.3.5 角色管理 7
1.3.6 菜单管理 7
1.3.7 字典管理 8
1.3.8 系统配置 8
1.3.9 登录日志 8
1.3.10 操作日志 9
1.3.11 注册中心 9
1.3.12 接口文档 9
1.3.13 数据监控 10
1.3.14 服务监控 11
1.3.15 备份还原 11
1.3.16 主题切换 11
第2章 安装指南 13
2.1 前端安装指南 13
2.1.1 开发环境 13
2.1.2 技术选型 13
2.1.3 项目结构 13
2.1.4 编译运行 14
2.2 后端安装指南 14
2.2.1 开发环境 14
2.2.2 技术选型 15
2.2.3 项目结构 15
2.2.4 编译运行 15
第3章 关键技术 17
3.1 Spring Boot 17
3.2 Spring Cloud 17
3.2.1 Spring Cloud简介 17
3.2.2 Spring Cloud架构 17
3.2.3 Spring Cloud组件 18
3.2.4 参考教程 19
3.3 Spring Security 19
3.4 MyBatis 19
3.5 Vue.js 19
3.6 Element 20
第二篇 后端实现篇
第4章 数据库设计 23
4.1 数据库表设计 23
4.2 数据库表关系 23
4.3 数据库表结构 24
4.3.1 用户表（sys_user） 24
4.3.2 角色表（sys_role） 25
4.3.3 机构表（sys_dept） 25
4.3.4 菜单表（sys_menu） 26
4.3.5 用户角色表（sys_user_role） 26
4.3.6 角色菜单表（sys_role_menu） 26
4.3.7 角色机构表（sys_role_dept） 27
4.3.8 字典表（sys_dict） 27
4.3.9 配置表（sys_config） 28
4.3.10 操作日志表（sys_log） 28
4.3.11 登录日志表（sys_login_log） 28
第5章 搭建开发环境 30
5.1 开发环境准备 30
5.1.1 安装JDK环境 30
5.1.2 安装Eclipse开发工具 30
5.1.3 安装MySQL数据库 30
5.1.4 安装Maven构建工具 31
5.2 生成项目模板 31
5.3 导入Maven项目 31
5.4 编译打包运行 34
5.4.1 编译打包 34
5.4.2 启动应用 35
5.4.3 修改启动端口 35
5.4.4 自定义Banner 35
5.4.5 接口测试 37
第6章 集成Swagger文档 38
6.1 添加依赖 38
6.2 配置类 39
6.3 页面测试 39
第7章 集成MyBatis框架 41
7.1 添加依赖 41
7.2 添加配置 42
7.2.1 添加MyBatis配置 42
7.2.2 添加数据源配置 42
7.2.3 修改启动类 43
7.3 生成MyBatis模块 43
7.4 编写服务接口 44
7.5 配置打包资源 46
7.6 编译运行测试 47
第8章 集成Druid数据源 48
8.1 Druid介绍 48
8.2 添加依赖 49
8.3 添加配置 49
8.4 配置Servlet和Filter 51
8.5 编译运行 53
8.6 查看监控 54
8.6.1 登录界面 54
8.6.2 监控首页 55
8.6.3 数据源 55
8.6.4 SQL监控 55
第9章 跨域解决方案 57
9.1 什么是跨域 57
9.2 CORS 技术 57
9.2.1 简单请求 57
9.2.2 非简单请求 58
9.3 CORS实现 59
第10章 业务功能实现 60
10.1 工程结构规划 60
10.1.1 mango-admin 60
10.1.2 mango-common 62
10.1.3 mango-core 63
10.1.4 mango-pom 63
10.1.5 打包测试 63
10.2 业务代码封装 65
10.2.1 通用CURD接口 65
10.2.2 分页请求封装 66
10.2.3 分页结果封装 67
10.2.4 分页助手封装 68
10.2.5 HTTP结果封装 69
10.3 MyBatis分页查询 70
10.3.1 添加依赖 70
10.3.2 添加配置 71
10.3.3 分页代码 71
10.3.4 接口测试 73
10.4 业务功能开发 74
10.4.1 编写DAO接口 74
10.4.2 编写映射文件 74
10.4.3 编写服务接口 75
10.4.4 编写服务实现 75
10.4.5 编写控制器 77
10.5 业务接口汇总 78
10.5.1 用户管理 78
10.5.2 机构管理 79
10.5.3 角色管理 79
10.5.4 菜单管理 80
10.5.5 字典管理 81
10.5.6 系统配置 82
10.5.7 登录日志 82
10.5.8 操作日志 83
10.6 导出Excel报表 83
10.6.1 添加依赖 83
10.6.2 编写服务接口 84
10.6.3 编写服务实现 84
10.6.4 编写控制器 85
10.6.5 工具类代码 86
10.6.6 接口测试 87
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring框架高级编程
第1章	Spring框架概述	1
1.1	为什么要Spring？	1
1.1.1	J2EE传统方式的问题	1
1.1.2	轻量级框架	3
1.1.3	进入Spring	4
1.2	Spring的价值	5
1.3	上下文中的Spring	6
1.3.1	技术	7
1.3.2	面向方面的编程	9
1.3.3	一致性抽象	12
1.3.4	与其他框架的关系	16
1.4	使用Spring构造应用程序	18
1.4.1	关系图	18
1.4.2	持久性和集成	20
1.4.3	业务服务对象	23
1.4.4	表示	24
1.5	前景	25
1.5.1	发布日程	25
1.5.2	Java和J2EE的进展	26
1.5.3	技术趋势	27
1.5.4	标准与源码公开	27
1.6	Spring项目和社区	28
1.6.1	历史	28
1.6.2	模块摘要	29
1.6.3	支持的环境	32
1.7	小结	32
第2章	BEAN工厂与应用程序上下文	34
2.1	控制反转和依赖注入	34
2.1.1	不同形式的依赖注入	36
2.1.2	在设置器注入和构造函数注入之间决定	37
2.2	容器	38
2.2.1	Bean工厂	39
2.2.2	应用程序上下文	40
2.2.3	启动容器	41
2.2.4	使用来自工厂的Bean	42
2.2.5	XML Bean配置	43
2.2.6	基本的Bean定义	43
2.2.7	管理Bean生命周期	52
2.2.8	对服务和资源访问的抽象	54
2.2.9	重用Bean定义	57
2.2.10	使用后置处理器处理定制的Bean和容器	59
2.3	小结	63
第3章	高级容器概念	64
3.1	低层资源的抽象	64
3.1.1	应用程序上下文作为ResourceLoader	64
3.1.2	应用程序上下文作为消息源	66
3.2	应用程序事件	68
3.3	管理容器	69
3.3.1	ApplicationContext构造函数中的资源位置路径	69
3.3.2	应用程序上下文的声明性用法	71
3.3.3	将容器定义划分到多个文件	72
3.3.4	处理组件的策略	73
3.3.5	用于访问容器的单态	75
3.4	一些方便的工厂BEAN	75
3.4.1	PropertyPathFactoryBean	76
3.4.2	FieldRetrievingFactoryBean	76
3.4.3	MethodInvokingFactoryBean	77
3.5	SPRING提供的属性编辑器	77
3.6	测试策略	78
3.6.1	单元测试	78
3.6.2	使用Spring容器的测试	80
3.7	XML的替代品	81
3.7.1	来自Properties文件的定义	82
3.7.2	编程化的Bean定义	82
3.7.3	其他格式	83
3.7.4	参考文献	83
3.8	小结	83
第4章	SPRING与AOP	84
4.1	目标	84
4.2	假设	85
4.3	例子	85
4.4	SPRING的AOP框架	86
4.4.1	拦截器链	87
4.4.2	赞成与反对	87
4.4.3	通知	88
4.4.4	切点	92
4.4.5	通知器（Advisor）	96
4.4.6	与Spring IoC容器的集成	97
4.4.7	在运行时间检验并处理代理状态	107
4.4.8	编程化的代理创建	107
4.5	使用SPRING的AOP框架的高级特性	108
4.5.1	TargetSources	108
4.5.2	及早终止拦截器链	112
4.5.3	使用介绍	112
4.5.4	暴露当前的代理	114
4.5.5	暴露当前的MethodInvocation	115
4.5.6	理解代理类型	115
4.5.7	调试与测试	117
4.5.8	其他	118
4.6	与其他AOP框架集成	120
4.6.1	目标	120
4.6.2	AspectJ集成	121
4.6.3	AspectWerkz	125
4.7	参考文献	125
4.8	小结	126
第5章	DAO支持与JDBC框架	127
5.1	数据访问对象模式	127
5.2	SPRING的JDBC框架概述	128
5.2.1	起因：直接使用JDBC的问题	128
5.2.2	Spring可以如何帮助	130
5.2.3	简单的例子	130
5.3	建立样本应用程序的数据访问层	131
5.3.1	样本应用程序的数据模型	131
5.3.2	DataSource	132
5.3.3	异常转译	133
5.4	使用JDBCTEMPLATE的操作	134
5.4.1	回调方法的使用	134
5.4.2	JdbcTemplate的方便方法	135
5.4.3	使用JdbcTemplate的基本查询	136
5.4.4	使用JdbcTemplate的基本更新	137
5.4.5	JdbcTemplate的高级用法	137
5.4.6	对RowSet的支持	138
5.5	使用RDBMS操作类	139
5.5.1	SqlQuery和MappingSqlQuery	139
5.5.2	使用SqlUpdate插入和更新	140
5.5.3	使用UpdatableSqlQuery更新ResultSet	141
5.5.4	生成主键	141
5.5.5	检索数据库生成的键	142
5.5.6	调用存储过程	143
5.6	高级概念	144
5.6.1	在应用程序服务器中的运行Spring JDBC	144
5.6.2	使用定制的异常转译	145
5.6.3	读写LOB数据	147
5.6.4	批量更新	149
5.6.5	存储过程的高级用法	150
5.7	其他的考虑事项	152
5.7.1	性能	152
5.7.2	何时使用JDBC和O/R映射	152
5.7.3	JDBC版本和J2EE版本	153
5.8	小结	153
第6章	事务和资源管理	154
6.1	背景	154
6.1.1	什么是事务？	154
6.1.2	ACID属性	154
6.1.3	并发控制	156
6.2	事务与J2EE	156
6.2.1	局部事务	157
6.2.2	全局/分布式事务	157
6.2.3	事务传播	157
6.2.4	事务划分	157
6.3	SPRING事务支持的例子	158
6.4	SPRING的事务抽象介绍	159
6.4.1	事务控制选择的概述	159
6.4.2	事务划分策略	162
6.4.3	事务管理策略	167
6.5	DATASOURCE声明	171
6.5.1	本地非缓冲	171
6.5.2	本地缓冲	172
6.5.3	JNDI	172
6.5.4	在本地DataSource和JNDI DataSource之间选择	173
6.6	小结	173
第7章	对象/关系映射	175
7.1	背景知识	175
7.1.1	基本的O/R映射	176
7.1.2	对象查询语言	176
7.1.3	透明持久性	177
7.1.4	何时选择O/R映射	177
7.2	SPRING中的O/R映射支持	178
7.2.1	数据访问对象	178
7.2.2	事务管理	179
7.3	IBATIS SQL MAPS	179
7.3.1	映射文件	180
7.3.2	DAO实现	181
7.3.3	在Spring上下文中设置	182
7.3.4	事务管理	182
7.3.5	iBATIS概要	183
7.4	HIBERNATE	184
7.4.1	映射文件	184
7.4.2	DAO实现	185
7.4.3	Spring上下文中的设置	186
7.4.4	设置为JCA连接器	187
7.4.5	事务管理	188
7.4.6	Open Session in View	192
7.4.7	BLOB/CLOB处理	194
7.4.8	Hibernate：小结	195
7.5	JDO	196
7.5.1	持久性对象的生命周期	197
7.5.2	DAO实现	197
7.5.3	在Spring上下文中设置	199
7.5.4	事务管理	200
7.5.5	PersistenceManager的生命周期	200
7.5.6	Open PersistenceManager in View	201
7.5.7	JDO方言	203
7.5.8	JDO：小结	203
7.6	其他O/R映射工具	205
7.6.1	Apache OJB	205
7.6.2	TopLink	206
7.6.3	Cayenne	207
7.6.4	JSR-220持久性	207
7.7	小结	207
第8章	轻量级远程处理	209
8.1	概念和范围	209
8.2	公共的配置风格	211
8.3	HESSIAN和BURLAP	212
8.3.1	访问一个服务	213
8.3.2	导出一个服务	214
8.4	HTTP调用器	215
8.4.1	访问一个服务	216
8.4.2	导出一个服务	216
8.4.3	定制化选项	217
8.5	RMI	218
8.5.1	访问一个服务	219
8.5.2	Stub查询策略	220
8.5.3	导出一个服务	221
8.5.4	定制化选项	222
8.5.5	RMI-IIOP	222
8.6	通过JAX-RPC的WEB服务	223
8.6.1	访问一个服务	224
8.6.2	导出一个服务	225
8.6.3	定制的类型映射	226
8.7	小结	227
第9章	支持性服务	229
9.1	JMS	229
9.1.1	引言	229
9.1.2	Spring的JMS支持的起因	230
9.1.3	通过模板的JMS访问	230
9.1.4	异常处理	232
9.1.5	ConnectionFactory管理	232
9.1.6	消息转换器	233
9.1.7	目的管理	233
9.1.8	事务管理	234
9.1.9	JmsGatewaySupport	235
9.1.10	前景	236
9.2	使用SPRING的调度	236
9.2.1	Timer与Quartz	236
9.2.2	Timer	237
9.2.3	Quartz	238
9.3	使用SPRING发送电子邮件	241
9.3.1	入门指南	242
9.3.2	重用现有的邮件会话	242
9.3.3	使用COS的邮寄发送	242
9.3.4	通用的邮件管理器	243
9.4	脚本	245
9.4.1	一致性模型	245
9.4.2	其他脚本语言	248
9.5	小结	248
第10章	SPRING的ACEGI SECURITY系统	249
10.1	企业应用程序的安全选择	249
10.1.1	典型的需求	249
10.1.2	Acegi Security简介	250
10.1.3	Java身份验证和授权服务	252
10.1.4	Servlet规范	254
10.2	ACEGI SECURITY的基础	255
10.2.1	身份验证	255
10.2.2	存储身份验证对象	257
10.2.3	授权	258
10.2.4	域对象实例的安全	259
10.3	范例代码	262
10.3.1	范例介绍	262
10.3.2	安全不知道的实现	262
10.3.3	安全方法	263
10.3.4	身份验证	263
10.3.5	授权	264
10.4	小结	265
第11章	SPRING与EJB	267
11.1	对EJB的需要做出决断	267
11.2	访问EJB	268
11.2.1	样板方法	268
11.2.2	Spring的方法	269
11.3	用SPRING实现EJB	273
11.3.1	无状态会话Bean	273
11.3.2	有状态会话Bean	275
11.3.3	消息驱动的Bean	276
11.3.4	XDoclet	276
11.4	单态容器访问，好还是坏？	277
11.4.1	ContextSingletonBeanFactoryLocator和SingletonBeanFactoryLocator	278
11.4.2	共享的上下文作为Web应用程序的应用程序上下文的双亲	280
11.4.3	使用来自EJB的共享的上下文	280
11.5	测试关注点	281
11.5.1	在POJO委托中实现业务功能	281
11.5.2	使用模仿的EJB容器	282
11.5.3	应用程序服务器内部的集成测试	282
11.6	小结	283
第12章	WEB MVC框架	284
12.1	简单的例子	284
12.2	一般的体系结构	285
12.2.1	Web MVC概念	285
12.2.2	使用分发器和控制器的通用Web MVC	286
12.2.3	好的Web MVC框架的需求	286
12.2.4	Spring的Web MVC的等价物	287
12.3	基础设施组件	289
12.3.1	DispatcherServlet	289
12.3.2	WebApplicationContext	291
12.4	处理请求有关的工作流	293
12.5	SPRING MVC WEB应用程序的一般布局	294
12.6	HANDLERMAPPING	295
12.6.1	BeanNameUrlHandlerMapping	296
12.6.2	SimpleUrlHandlerMapping	296
12.6.3	CommonsPathMapUrlHandlerMapping	297
12.6.4	多个HandlerMapping	298
12.7	HANDLEREXECUTIONCHAIN和拦截器	298
12.7.1	WebContentInterceptor	299
12.7.2	UserRoleAuthorizationInterceptor	300
12.7.3	Spring MVC提供的其他处理器拦截器	300
12.8	处理器及其适配器	300
12.9	MODELANDVIEW和VIEWRESOLVERS	301
12.9.1	UrlBasedViewResolver	301
12.9.2	BeanNameViewResolver和XmlViewResolver	302
12.9.3	ResourceBundleViewResolver	302
12.9.4	视图解析器成链	303
12.10	地区值的改变和解析	304
12.11	HANDLEREXCEPTIONRESOLVERS	305
12.12	控制器	307
12.12.1	WebContentGenerator	307
12.12.2	AbstractController	308
12.12.3	UrlFilenameViewController	308
12.12.4	ParameterizableViewController	309
12.12.5	MultiActionController	309
12.13	数据绑定	310
12.13.1	使用数据绑定时的方便功能	310
12.14	使用控制器的实际例子	311
12.15	使用ABSTRACTCONTROLLER查看演出列表	311
12.15.1	预订	313
12.16	向导功能	318
12.16.1	基本配置	318
12.16.2	模板方法	318
12.16.3	向导流程	319
12.16.4	页面改变、编号和其他动作	319
12.17	扩展SPRING处理器的基础设施	320
12.18	上传文件	321
12.18.1	配置多部分解析器	321
12.18.2	创建表单来上传文件	321
12.18.3	处理上传的数据	322
12.19	测试控制器	322
12.19.1	无需应用程序上下文的测试	323
12.19.2	使用模仿对象的更广泛测试	323
12.19.3	使用完全的应用程序上下文测试	323
12.19.4	测试Web应用程序的其他方法	324
12.19.5	小结	324
第13章	WEB视图技术	326
13.1	一个例子	326
13.1.1	通用配置	327
13.1.2	JSP	327
13.1.3	FreeMarker	327
13.1.4	使用iText生成PDF	328
13.2	选择技术时的注意事项	328
13.3	视图对象和模型	329
13.4	ABSTRACTVIEW提供的特性	330
13.4.1	使用RedirectView发布新的请求	330
13.4.2	使用视图前缀发布转向或者重定向	331
13.5	JSP	332
13.5.1	配置应用程序以使用JSP	332
13.5.2	使用定制标记创建表单	333
13.5.3	使用标记文件创建可重用的元素	337
13.6	VELOCITY和FREEMARKER	338
13.6.1	配置视图解析器	338
13.6.2	使用表单简化宏	340
13.7	TILES	342
13.8	基于XML和XSLT的视图	344
13.9	EXCEL和基于其他文档的视图	345
13.9.1	从表演列表生成Excel文件	345
13.9.2	以模板作为Excel文件的基础	346
13.9.3	基于其他文档的视图	346
13.9.4	使用HandlerInterceptor区分HTML和Excel	346
13.10	实现定制视图	347
13.10.1	View和AbstractView	347
13.10.2	实现从数据对象生成XML的视图	348
13.10.3	实现定制视图时的注意事项	348
13.11	小结	349
第14章	与其他WEB框架集成	350
14.1	选择MVC框架时的注意事项	350
14.1.1	比较传统的Web MVC框架	350
14.2	与SPRING集成：核心概念	359
14.3	WEBWORK 集成	361
14.3.1	设置ObjectFactory	361
14.4	STRUTS集成	361
14.4.1	使用ActionSupport	362
14.4.2	使用DelegationRequestProcessor和DelegationActionProxy	362
14.4.3	使用自动装配的基本动作	364
14.5	TAPESTRY集成	365
14.5.1	为Tapestry准备Bean	365
14.5.2	页面类	365
14.5.3	页面定义	366
14.5.4	页面模板	366
14.5.5	Tapestry集成的最终思考	366
14.6	JSF集成	367
14.7	小结	368
第15章	样本应用程序	369
15.1	服务器技术的选择	369
15.2	应用层	370
15.3	持久性层	370
15.3.1	数据模型	370
15.3.2	域对象模型	371
15.3.3	对象/关系映射	371
15.3.4	DAO实现	373
15.3.5	数据访问上下文	374
15.4	业务服务层	374
15.4.1	服务	374
15.4.2	应用程序上下文	375
15.5	WEB层	375
15.5.1	应用程序流程	376
15.5.2	通过web.xml配置应用程序	376
15.5.3	Web控制器	377
15.5.4	视图技术	377
15.6	与J2EE设计和开发实现的比较	378
15.6.1	更简单的技术	378
15.6.2	数据库变化	378
15.7	服务器配置	378
15.7.1	MySQL	379
15.7.2	Tomcat	379
15.8	组建和部署	379
15.8.1	创建和载入数据库表	380
15.8.2	组建应用程序并部署到Tomcat服务器	380
15.9	小结	380
第16章	结论	381
16.1	SPRING解决的问题	381
16.2	SPRING解决方案	381
16.3	SPRING开发的指导方针	383
16.3.1	技术选择	383
16.3.2	层与层	385
16.3.3	构造应用程序	389
16.3.4	测试应用程序	392
16.4	相关项目	394
16.4.1	Spring的Acegi Security	394
16.5	其他项目	395
16.6	非J2EE环境中的SPRING	395
16.7	发现更多	396
16.7.1	书籍和文章	396
16.7.2	在线资源	397
16.7.3	样本应用程序	397
16.8	前景..	398
附录A	样本应用程序的需求	399
A.1	概述	399
A.2	用户群体	399
A.2.1	公众Internet用户	399
A.2.2	售票处用户	400
A.2.3	系统管理员	400
A.3	假设	400
A.4	范围限制	401
A.5	交付时间表	401
A.6	INTERNET用户界面	401
A.6.1	基本工作流	402
A.6.2	错误处理	402
A.6.3	应用程序屏幕	402
A.7	非功能性需求	409
A.8	硬件和软件环境	410
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring框架高级编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Expert One-on-One J2EE Development without EJB中文版
第1章 为什么要“j2ee without ejb”
聚光灯下的ejb
j2ee还剩什么？
站在十字路口的j2ee
前行的路
主旋律
轻量级框架和容器
我们还应该使用ejb吗？
小结
第2章 目标
生产率
问题
传统j2ee方案解决生产率问题的办法
提升生产率更好的办法
oo
业务需求的重要性
经验过程的重要性
小结
第3章 各种架构
架构性构件
.业务服务层
向外部暴露业务对象
数据访问层，或eis层
j2ee架构
两种ejb架构
两种非ejb架构
j2ee架构实例
“经典的”j2ee远程ejb架构
本地ejb架构
特制的非ejb架构
“轻量级容器架构”：示例应用系统
确定是否采用应用服务器
小结
第4章 简单性的红利
复杂性的代价
在j2ee应用系统中，导致复杂性产生的原因
导致复杂性的架构性原因
导致复杂性的文化性原因：一个依靠复杂性为生的产业
复杂到什么地步就是过度了？
简单还是幼稚？
刚刚够好就行吗？
变化的趋势
总结
第5章 ejb，五年间
炒作和经验
ejb和j2ee行业
实践中的ejb
一个过时的组件模型
java语言的进步
.net的挑战
web service
敏捷方法学的兴起
关于ejb目标的混淆
从未出现的组件市场
方兴未艾的新范式：aop
ejb, 我们真正需要什么？为什么无状态session bean如此流行？
声明性事务管理
远程调用
集群
线程管理
ejb实例池
资源池
安全
业务对象管理
总结：ejb的服务
ejb，我们不想要什么？
容器的锁定
丑陋的结构，泛滥的类
部署描述文件的地狱
类加载器的地狱
测试
ejb的滥用
复杂的编程模型
简单的事情会变得困难
“让开发人员忽略企业应用的复杂性”，这个目标现实吗？
生产率的损失
可移植性的问题
ejb能浴火重生吗？
工具支持
ejb 3.0
神话与谬论
jee == ejb
使用ejb的可疑论据
继续前进
moving forward
选择是否使用ejb
传统的知识
今天的选择
后ejb时代的舆论
标准，创新，和开源
小结
第6章 轻量级容器与控制反转
轻量级容器
什么是轻量级容器？
我们到底为什么需要容器？
轻量级容器 vs. ejb容器
ejb的好处
管理业务对象
接口与实现的分离
ejb：不完善的解决方案
控制反转
ioc实现策略
ioc容器
ioc容器间的移植
对代码风格、测试以及开发过程的影响
代码风格
可测试性
开发过程
使用企业级服务
小结
第7章 spring框架简介
来历与动机
一个分层的应用框架
基础构建模块
j2ee之上的spring
web应用中的spring
核心bean工厂
基础接口
通过xml组装bean
非xml格式的bean声明
组装应用对象
自动装配和依赖检查
构造子决议
生命周期回调
复杂的属性值
资源设置
典型的java/j2ee资源访问
bean容器中的资源声明
工厂bean
spring应用上下文
生命周期回调
信息源
文件资源
bean factory 后处理
小结
第8章 基于aop概念的声明性中间件
aop 101
动机
j2ee中的aop
定义
历史
作为aop子集的ejb
aop实现策略
动态代理
动态字节码生成
java代码生成
使用定制的类加载器
语言扩展
aop实现
aspectj
aspectwerkz
jboss4
spring
nanning
aop联盟
aop设计问题
aop的危险性
aop设计的建议
随意点菜的j2ee
spring中的aop实践
使用proxyfactorybean
便利的factorybean
自动代理
编程用法
使用源码级元数据提供aop之上的抽象
.net范例
概念级元数据 vs. 实现级元数据
编程访问上下文信息
spring范例
ejb 3.0
编程风格的暗含意味
前后一致的命名规范
避免依赖aop基础设施
受控异常和增强
参考资料
书籍
论文
文章和在线资源
小结
第9章 事务管理
上层（high-level）事务管理
传统的j2ee事务管理
j2ee容器作为事务协调器
人见人爱的cmt
直接使用jta
插曲：远程事务传播
轻量级事务基础设施
spring framework的事务管理
事务声明
编程式事务处理
声明式事务管理
事务管理策略
选择j2ee服务器的提示
小结
第10章 持久化
常见持久化策略
持久化模式概览
流行的j2ee数据访问解决方案
选择一种持久化策略
透明持久化和领域对象的行为
java持久化技术简史
java o/r映射解决方案的缓慢成长
entity bean的败笔
实践中的数据访问技术
资源管理
jdbc
ibatis sql映射
jdo
hibernate
数据访问对象（dao）模式
业务对象与数据访问对象
dao和透明持久化
数据访问对象的种类
dao设计中的问题
dao基础设施的问题
使用spring框架进行数据访问
通用的数据访问异常
再论业务对象与数据访问对象的关系
jdbc
ibatis sql映射
jdo
hibernate
小结
第11章 远程调用
经典的j2se远程方案：rmi
访问和暴露rmi服务
用rmi调用器实现透明远程调用
经典的j2ee远程机制：ejb
通信协议
状态管理
访问远程ejb
部署远程ejb
基于wsdl的web services：jax-rpc
访问web services
servlet和ejb端点
轻量级远程方案：hessian和burlap
访问和暴露hessian和burlap服务
小结
第12章 替换其它的ejb服务
线程管理
线程神话
ejb线程模型
ejb实例池
何时需要实例池？
何时不需要实例池
ejb线程机制和缓冲池的替代方案
线程模型
实例池概述
声明性安全
ejb安全模型
ejb模型的缺陷
借助aop的声明式安全
jms和消息驱动bean
小结
第13章 web层设计
目标和体系结构的讨论
web层设计目标
用servlet和jsp定制的mvc
融入整体架构
请求驱动的web mvc框架
struts 1.1
webwork2
spring的web mvc框架
适宜的视图技术
web mvc的其它实现方式
portals和portlets
事件驱动的web mvc框架
小论asp.net
总结
第14章 单元测试与可测试性
为何测试很重要？
单元测试的目标
确保可测试性
编程风格
如何让你的代码难于测试
来自标准库的难题
提高可测试性的技巧
依赖倒置
aop
单元测试技巧
替换
模仿对象
编写有效测试
测试驱动开发（tdd）
好处
对tdd的反对意见
tdd实践
学习tdd
案例研究：spring的经验
测试spring应用程序
对pojo进行测试
spring的抽象带来的好处
何时需要依赖spring api
使用替换配置进行测试
覆盖率分析和其他测试工具
测试生成器
覆盖分析工具
突变测试工具
资源
小结
第15章 性能与可伸缩性
定义
设置清晰的目标
体系结构的选择：影响性能和可伸缩性的关键因素
对象分布、集群和农场
数据访问
其他体系结构方面的问题
不同实现的选择
摆脱ejb服务设施对性能的影响
结果总结
摆脱ejb服务设施对性能的影响
缓存的代码优化
调优和部署
jvm
应用服务器
框架配置
数据库配置
一种循证的性能策略
基准测试
采样（profiling）
诊断
资源
小结
第16章 示例应用系统
pet store（宠物店）业务需求
ibatis jpetstore 3.1
中间层
远程调用机制
可改进的空间
spring jpetstore
中间层
数据访问层
web层
远程机制
编译和部署
war部署中的一些问题
部署spring jpetstore
小结
第17章 结语
回顾
前行
为你的应用选择最佳架构
轻量级容器架构
标准关键词
指导方针
编程风格
控制反转（ioc）和依赖注入
aop
测试
写在最后
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Expert One-on-One J2EE Development without EJB中文版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
中文版序Ⅰ
引言Ⅴ
作者的话ⅩⅦ
致谢ⅩⅨ
一 明天的寓言1
二 忍耐的义务5
三 死神的特效药15
四 地表水和地下海39
五 土壤的王国53
六 地球的绿色斗篷63
七 不必要的大破坏85
八 再也没有鸟儿歌唱101
九 死亡的河流127
一〇 无人幸免的天灾151
一一 超越波吉亚家族的梦想169
一二 人类的代价183
一三 通过一扇狭小的窗户195
一四 每四个中有一个215
一五 大自然在反抗241
一六 崩溃声隆隆261
一七 另一条道路275
附录
参考文献299
译者后记357
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring 5核心原理与30个类手写实战
第1篇  Spring内功心法
第1章　软件架构设计原则	2
1.1  开闭原则	2
1.2  依赖倒置原则	4
1.3  单一职责原则	7
1.4  接口隔离原则	10
1.5  迪米特原则	12
1.6  里氏替换原则	14
1.7  合成复用原则	19
1.8  设计原则总结	20
第2章　Spring中常用的设计模式	21
2.1  为什么要从设计模式开始	21
2.1.1  写出优雅的代码	22
2.1.2  更好地重构项目	24
2.1.3  经典框架都在用设计模式解决问题	36
2.2  工厂模式详解	36
2.2.1  工厂模式的由来	36
2.2.2  简单工厂模式	37
2.2.3  工厂方法模式	41
2.2.4  抽象工厂模式	43
2.2.5  利用工厂模式重构的实践案例	47
2.3  单例模式详解	53
2.3.1  单例模式的应用场景	53
2.3.2  饿汉式单例模式	53
2.3.3  懒汉式单例模式	54
2.3.4  反射破坏单例	60
2.3.5  序列化破坏单例	61
2.3.6  注册式单例模式	68
2.3.7  线程单例实现ThreadLocal	74
2.3.8  单例模式小结	75
2.4  原型模式详解	75
2.4.1  原型模式的应用场景	75
2.4.2  浅克隆	77
2.4.3  深克隆	79
2.4.4  克隆破坏单例模式	81
2.4.5  clone()方法的源码	82
2.5  代理模式详解	82
2.5.1  代理模式的应用场景	82
2.5.2  静态代理	83
2.5.3  动态代理	88
2.5.4  代理模式与Spring	107
2.5.5  静态代理和动态代理的本质区别	108
2.5.6  代理模式的优缺点	109
2.6  委派模式详解	109
2.6.1  委派模式的定义及应用场景	109
2.6.2  委派模式在源码中的体现	111
2.7  策略模式详解	114
2.7.1  策略模式的应用场景	114
2.7.2  用策略模式实现选择支付方式的业务场景	114
2.7.3  策略模式在JDK源码中的体现	122
2.7.4  策略模式的优缺点	125
2.7.5  委派模式与策略模式综合应用	125
2.8  模板模式详解	129
2.8.1  模板模式的应用场景	129
2.8.2  利用模板模式重构JDBC操作业务场景	132
2.8.3  模板模式在源码中的体现	136
2.8.4  模板模式的优缺点	138
2.9  适配器模式详解	139
2.9.1  适配器模式的应用场景	139
2.9.2  重构第三方登录自由适配的业务场景	141
2.9.3  适配器模式在源码中的体现	149
2.9.4  适配器模式的优缺点	153
2.10  装饰者模式详解	153
2.10.1  装饰者模式的应用场景	153
2.10.2  装饰者模式和适配器模式对比	163
2.10.3  装饰者模式在源码中的应用	163
2.10.4  装饰者模式的优缺点	165
2.11  观察者模式详解	165
2.11.1  观察者模式的应用场景	165
2.11.2  观察者模式在源码中的应用	175
2.11.3  基于Guava API轻松落地观察者模式	176
2.11.4  观察者模式的优缺点	177
2.12  各设计模式的总结与对比	177
2.12.1  GoF 23种设计模式简介	177
2.12.2  设计模式之间的关联关系	178
2.12.3  Spring中常用的设计模式	182
2.13  Spring中的编程思想总结	183
第2篇  Spring环境预热
第3章　Spring的前世今生	186
3.1  一切从Bean开始	187
3.2  Spring的设计初衷	188
3.3  BOP编程伊始	188
3.4  理解BeanFactory	189
3.5  AOP编程理念	189
第4章　Spring 5系统架构	191
4.1  核心容器	192
4.2  AOP和设备支持	192
4.3  数据访问与集成	193
4.4  Web组件	194
4.5  通信报文	194
4.6  集成测试	194
4.7  集成兼容	194
4.8  各模块之间的依赖关系	194
第5章　Spring版本命名规则	196
5.1  常见软件的版本命名	196
5.2  语义化版本命名通行规则	197
5.3  商业软件中常见的修饰词	197
5.4  软件版本号使用限定	198
5.5  Spring版本命名规则	199
第6章　Spring源码下载及构建技巧	200
6.1  Spring 5源码下载	200
6.2  基于Gradle的源码构建技巧	201
6.3  Gradle构建过程中的坑	207
第3篇  Spring核心原理
第7章　用300行代码手写提炼Spring核心原理	210
7.1  自定义配置	210
7.1.1  配置application.properties文件	210
7.1.2  配置web.xml文件	210
7.1.3  自定义注解	211
7.1.4  配置注解	212
7.2  容器初始化	213
7.2.1  实现1.0版本	213
7.2.2  实现2.0版本	216
7.2.3  实现3.0版本	223
7.3  运行效果演示	227
第8章　一步一步手绘Spring IoC运行时序图	228
8.1  Spring核心之IoC容器初体验	228
8.1.1  再谈IoC与DI	228
8.1.2  Spring核心容器类图	229
8.1.3  Web IoC容器初体验	232
8.2  基于XML的IoC容器的初始化	237
8.2.1  寻找入口	238
8.2.2  获得配置路径	238
8.2.3  开始启动	240
8.2.4  创建容器	242
8.2.5  载入配置路径	243
8.2.6  分配路径处理策略	244
8.2.7  解析配置文件路径	247
8.2.8  开始读取配置内容	249
8.2.9  准备文档对象	250
8.2.10  分配解析策略	251
8.2.11  将配置载入内存	252
8.2.12  载入<bean>元素	257
8.2.13  载入<property>元素	261
8.2.14  载入<property>子元素	264
8.2.15  载入<list>子元素	266
8.2.16  分配注册策略	267
8.2.17  向容器注册	267
8.3  基于注解的IoC初始化	270
8.3.1  注解的前世今生	270
8.3.2  定位Bean扫描路径	271
8.3.3  读取注解的元数据	273
8.3.4  扫描指定包并解析为BeanDefinition	277
8.3.5  注册注解BeanDefinition	283
8.4  IoC容器初始化小结	285
第9章　一步一步手绘Spring DI运行时序图	287
9.1  Spring自动装配之依赖注入	287
9.1.1  依赖注入发生的时间	287
9.1.2  寻找获取Bean的入口	288
9.1.3  开始实例化	293
9.1.4  选择Bean实例化策略	297
9.1.5  执行Bean实例化	299
9.1.6  准备依赖注入	301
9.1.7  解析属性依赖注入规则	306
9.1.8  注入赋值	310
9.2  Spring IoC容器中那些鲜为人知的细节	314
9.2.1  关于延时加载	314
9.2.2  关于FactoryBean和BeanFactory	317
9.2.3  再述autowiring	322
第10章　一步一步手绘Spring AOP运行时序图	326
10.1  Spring AOP初体验	326
10.1.1  再述Spring AOP应用场景	326
10.1.2  AOP中必须明白的几个概念	327
10.1.3  使用Spring AOP的两种方式	329
10.1.4  切入点表达式的配置规则	333
10.2  Spring AOP源码分析	334
10.2.1  寻找入口	334
10.2.2  选择代理策略	338
10.2.3  调用代理方法	341
10.2.4  触发通知	347
第11章　一步一步手绘Spring MVC运行时序图	352
11.1  初探Spring MVC请求处理流程	352
11.2  Spring MVC九大组件	353
11.2.1  HandlerMapping	353
11.2.2  HandlerAdapter	353
11.2.3  HandlerExceptionResolver	354
11.2.4  ViewResolver	354
11.2.5  RequestToViewNameTranslator	354
11.2.6  LocaleResolver	354
11.2.7  ThemeResolver	355
11.2.8  MultipartResolver	355
11.2.9  FlashMapManager	355
11.3  Spring MVC源码分析	355
11.3.1  初始化阶段	356
11.3.2  运行调用阶段	359
11.4  Spring MVC优化建议	367
第4篇  Spring手写实战
第12章　环境准备	370
12.1  IDEA集成Lombok插件	370
12.1.1  安装插件	370
12.1.2  配置注解处理器	373
12.1.3  使用插件	374
12.2  从Servlet到ApplicationContext	375
12.3  准备基础配置	376
12.3.1  application.properties配置	377
12.3.2  pom.xml配置	377
12.3.3  web.xml配置	378
12.3.4  GPDispatcherServlet	378
第13章　IoC顶层结构设计	380
13.1  Annotation（自定义配置）模块	380
13.1.1  @GPService	380
13.1.2  @GPAutowired	381
13.1.3  @GPController	381
13.1.4  @GPRequestMapping	382
13.1.5  @GPRequestParam	382
13.2  core（顶层接口）模块	382
13.2.1  GPFactoryBean	382
13.2.2  GPBeanFactory	383
13.3  beans（配置封装）模块	383
13.3.1  GPBeanDefinition	383
13.3.2  GPBeanWrapper	384
13.4  context（IoC容器）模块	385
13.4.1  GPAbstractApplicationContext	385
13.4.2  GPDefaultListableBeanFactory	385
13.4.3  GPApplicationContext	385
13.4.4  GPBeanDefinitionReader	388
13.4.5  GPApplicationContextAware	391
第14章　完成DI模块的功能	392
14.1  从getBean()方法开始	393
14.2  GPBeanPostProcessor	395
第15章　完成MVC模块的功能	396
15.1  MVC顶层设计	396
15.1.1  GPDispatcherServlet	396
15.1.2  GPHandlerMapping	402
15.1.3  GPHandlerAdapter	403
15.1.4  GPModelAndView	406
15.1.5  GPViewResolver	406
15.1.6  GPView	407
15.2  业务代码实现	409
15.2.1  IQueryService	409
15.2.2  QueryService	410
15.2.3  IModifyService	410
15.2.4  ModifyService	411
15.2.5  MyAction	412
15.2.6  PageAction	413
15.3  定制模板页面	414
15.3.1  first.html	414
15.3.2  404.html	414
15.3.3  500.html	415
15.4  运行效果演示	415
第16章　完成AOP代码织入	417
16.1  基础配置	417
16.2  完成AOP顶层设计	418
16.2.1  GPJoinPoint	418
16.2.2  GPMethodInterceptor	419
16.2.3  GPAopConfig	419
16.2.4  GPAdvisedSupport	420
16.2.5  GPAopProxy	422
16.2.6  GPCglibAopProxy	423
16.2.7  GPJdkDynamicAopProxy	423
16.2.8  GPMethodInvocation	425
16.3  设计AOP基础实现	427
16.3.1  GPAdvice	427
16.3.2  GPAbstractAspectJAdvice	427
16.3.3  GPMethodBeforeAdvice	428
16.3.4  GPAfterReturningAdvice	429
16.3.5  GPAfterThrowingAdvice	430
16.3.6  接入getBean()方法	430
16.4  织入业务代码	432
16.4.1  LogAspect	432
16.4.2  IModifyService	433
16.4.3  ModifyService	434
16.5  运行效果演示	435
第5篇  Spring数据访问
第17章　数据库事务原理详解	438
17.1  从Spring事务配置说起	438
17.2  事务的基本概念	439
17.3  事务的基本原理	439
17.4  Spring事务的传播属性	440
17.5  数据库事务隔离级别	441
17.6  Spring中的事务隔离级别	441
17.7  事务的嵌套	442
17.8  Spring事务API架构图	444
17.9  浅谈分布式事务	444
第18章　Spring JDBC源码初探	446
18.1  异常处理	447
18.2  config模块	448
18.3  core模块	450
18.4  DataSource	456
18.5  object模块	457
18.6  JdbcTemplate	458
18.7  NamedParameterJdbcTemplate	458
第19章　基于Spring JDBC手写ORM框架	459
19.1  实现思路概述	459
19.1.1  从ResultSet说起	459
19.1.2  为什么需要ORM框架	464
19.2  搭建基础架构	467
19.2.1  Page	467
19.2.2  ResultMsg	470
19.2.3  BaseDao	471
19.2.4  QueryRule	473
19.2.5  Order	479
19.3  基于Spring JDBC实现关键功能	480
19.3.1  ClassMappings	480
19.3.2  EntityOperation	483
19.3.3  QueryRuleSqlBuilder	488
19.3.4  BaseDaoSupport	498
19.4  动态数据源切换的底层原理	507
19.4.1  DynamicDataSource	508
19.4.2  DynamicDataSourceEntry	509
19.5  运行效果演示	510
19.5.1  创建Member实体类	510
19.5.2  创建Order实体类	511
19.5.3  创建MemberDao	512
19.5.4  创建OrderDao	512
19.5.5  修改db.properties文件	514
19.5.6  修改application-db.xml文件	515
19.5.7  编写测试用例	516
第6篇  Spring经验分享
第20章　Spring 5新特性总结	520
20.1  升级到Java SE 8和Java EE 7	520
20.2  反应式编程模型	521
20.3  使用注解进行编程	521
20.4  函数式编程	522
20.5  使用 REST 端点执行反应式编程	523
20.6  支持HTTP/2	523
20.7  Kotlin和Spring WebFlux	523
20.8  使用Lambda表达式注册Bean	524
20.9  Spring Web MVC 支持最新的 API	524
20.10  使用JUnit 5执行条件和并发测试	525
20.11  包清理和弃用	526
20.12  Spring核心和容器的一般更新	526
20.13  我如何看Spring 5	527
第21章　关于Spring的经典高频面试题	528
21.1  什么是Spring框架，Spring框架有哪些主要模块	528
21.2  使用Spring框架能带来哪些好处	528
21.3  什么是控制反转（IoC），什么是依赖注入	529
21.4  在Java中依赖注入有哪些方式	529
21.5  BeanFactory和ApplicationContext有什么区别	530
21.6  Spring提供几种配置方式来设置元数据	530
21.7  如何使用XML配置方式配置Spring	531
21.8  Spring提供哪些配置形式	532
21.9  怎样用注解的方式配置Spring	533
21.10  请解释Spring Bean的生命周期	534
21.11  Spring Bean作用域的区别是什么	535
21.12  什么是Spring Inner Bean	535
21.13  Spring中的单例Bean是线程安全的吗	536
21.14  请举例说明如何在Spring中注入一个Java集合	536
21.15  如何向Spring Bean中注入java.util.Properties	537
21.16  请解释Spring Bean的自动装配	538
21.17  自动装配有哪些局限性	538
21.18  请解释各种自动装配模式的区别	539
21.19  请举例解释@Required注解	539
21.20  请举例说明@Qualifier注解	540
21.21  构造方法注入和设值注入有什么区别	540
21.22  Spring中有哪些不同类型的事件	541
21.23  FileSystemResource和ClassPathResource有什么区别	542
21.24  Spring中用到了哪些设计模式	542
21.25  在Spring中如何更有效地使用JDBC	543
21.26  请解释Spring中的IoC容器	543
21.27  在Spring中可以注入null或空字符串吗	543
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring 5核心原理与30个类手写实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring攻略
第1章 Spring简介
1.1 实例化Spring IoC容器
1.1.1 问题
1.1.2 解决方案
1.1.3 工作原理
1.2 配置Spring IoC容器中的Bean
1.2.1 问题
1.2.2 解决方案
1.2.3 工作原理
1.3 调用构造程序创建Bean
1.3.1 问题
1.3.2 解决方案
1.3.3 工作原理
1.4 解决构造程序歧义
1.4.1 问题
1.4.2 解决方案
1.4.3 工作原理
1.5 指定Bean引用
1.5.1 问题
1.5.2 解决方案
1.5.3 工作原理
1.6 为集合元素指定数据类型
1.6.1 问题
1.6.2 解决方案
1.6.3 工作原理
1.7 使用Spring的FactoryBean创建Bean
1.7.1 问题
1.7.2 解决方案
1.7.3 工作原理
1.8 使用工厂Bean和Utility Schema定义集合
1.8.1 问题
1.8.2 解决方案
1.8.3 工作原理
1.9 用依赖检查属性
1.9.1 问题
1.9.2 解决方案
1.9.3 工作原理
1.10 用@Required注解检查属性
1.10.1 问题
1.10.2 解决方案
1.10.3 工作原理
1.11 用XML配置自动装配Bean
1.11.1 问题
1.11.2 解决方案
1.11.3 工作原理
1.12 用@Autowired和@Resource自动装配Bean
1.12.1 问题
1.12.2 解决方案
1.12.3 工作原理
1.13 继承Bean配置
1.13.1 问题
1.13.2 解决方案
1.13.3 工作原理
1.14 从Classpath中扫描组件
1.14.1 问题
1.14.2 解决方案
1.14.3 工作原理
1.15 小结
第2章 高级Spring IoC容器
2.1 调用静态工厂方法创建Bean
2.1.1 问题
2.1.2 解决方案
2.1.3 工作原理
2.2 调用一个实例工厂方法创建Bean
2.2.1 问题
2.2.2 解决方案
2.2.3 工作原理
2.3 从静态字段中声明Bean
2.3.1 问题
2.3.2 解决方案
2.3.3 工作原理
2.4 从对象属性中声明Bean
2.4.1 问题
2.4.2 解决方案
2.4.3 工作原理
2.5 使用Spring表达式语言
2.5.1 问题
2.5.2 解决方案
2.5.3 工作原理
2.6 设置Bean作用域
2.6.1 问题
2.6.2 解决方案
2.6.3 工作原理
2.7 自定义Bean初始化和析构
2.7.1 问题
2.7.2 解决方案
2.7.3 工作原理
2.8 用Java Config简化XML配置
2.8.1 问题
2.8.2 解决方案
2.8.3 工作原理
2.9 使Bean感知容器
2.9.1 问题
2.9.2 解决方案
2.9.3 工作原理
2.10 加载外部资源
2.10.1 问题
2.10.2 解决方案
2.10.3 工作原理
2.11 创建Bean后处理器
2.11.1 问题
2.11.2 解决方案
2.11.3 工作原理
2.12 外部化Bean配置
2.12.1 问题
2.12.2 解决方案
2.12.3 工作原理
2.13 解析文本消息
2.13.1 问题
2.13.2 解决方案
2.13.3 工作原理
2.14 使用应用事件进行通信
2.14.1 问题
2.14.2 解决方案
2.14.3 工作原理
2.15 在Spring中注册属性编辑器
2.15.1 问题
2.15.2 解决方案
2.15.3 工作原理
2.16 创建自定义属性编辑器
2.16.1 问题
2.16.2 解决方案
2.16.3 工作原理
2.17 使用TaskExecutor实现并发性
2.17.1 问题
2.17.2 解决方案
2.17.3 工作原理
2.18 小结
第3章 Spring AOP和AspectJ支持
3.1 启用Spring的AspectJ注解支持
3.1.1 问题
3.1.2 解决方案
3.1.3 工作原理
3.2 用AspectJ注解声明aspect
3.2.1 问题
3.2.2 解决方案
3.2.3 工作原理
3.3 访问连接点信息
3.3.1 问题
3.3.2 解决方案
3.3.3 工作原理
3.4 指定aspect优先级
3.4.1 问题
3.4.2 解决方案
3.4.3 工作原理
3.5 重用切入点定义
3.5.1 问题
3.5.2 解决方案
3.5.3 工作原理
3.6 编写AspectJ切入点表达式
3.6.1 问题
3.6.2 解决方案
3.6.3 工作原理
3.7 在你的Bean中引入行为
3.7.1 问题
3.7.2 解决方案
3.7.3 工作原理
3.8 为你的Bean引入状态
3.8.1 问题
3.8.2 解决方案
3.8.3 工作原理
3.9 用基于XML的配置声明aspect
3.9.1 问题
3.9.2 解决方案
3.9.3 工作原理
3.10 Spring中的AspectJ加载时织入aspect
3.10.1 问题
3.10.2 解决方案
3.10.3 工作原理
3.11 在Spring中配置AspectJ aspect
3.11.1 问题
3.11.2 解决方案
3.11.3 工作原理
3.12 将Spring Bean注入领域对象
3.12.1 问题
3.12.2 解决方案
3.12.3 工作原理
3.13 小结
第4章 Spring中的脚本
4.1 用脚本语言实现Bean
4.1.1 问题
4.1.2 解决方案
4.1.3 工作原理
4.2 将Spring Bean注入脚本中
4.2.1 问题
4.2.2 解决方案
4.2.3 工作原理
4.3 从脚本中刷新Bean
4.3.1 问题
4.3.2 解决方案
4.3.3 工作原理
4.4 定义内联脚本源码
4.4.1 问题
4.4.2 解决方案
4.4.3 工作原理
4.5 小结
第5章 Spring Security
5.1 加强URL访问安全
5.1.1 问题
5.1.2 解决方案
5.1.3 工作原理
5.2 登录到Web应用
5.2.1 问题
5.2.2 解决方案
5.2.3 工作原理
5.3 验证用户
5.3.1 问题
5.3.2 解决方案
5.3.3 工作原理
5.4 做出访问控制决策
5.4.1 问题
5.4.2 解决方案
5.4.3 工作原理
5.5 加强方法调用的安全
5.5.1 问题
5.5.2 解决方案
5.5.3 工作原理
5.6 处理视图中的安全性
5.6.1 问题
5.6.2 解决方案
5.6.3 工作原理
5.7 处理领域对象安全性
5.7.1 问题
5.7.2 解决方案
5.7.3 工作原理
5.8 小结
第6章 将Spring与其他Web框架集成
6.1 在一般Web应用中访问Spring
6.1.1 问题
6.1.2 解决方案
6.1.3 工作原理
6.2 在你的Servlet和过滤器中使用Spring
6.2.1 问题
6.2.2 解决方案
6.2.3 工作原理
6.3 将Spring与Struts 1.x集成
6.3.1 问题
6.3.2 解决方案
6.3.3 工作原理
6.4 将Spring与JSF集成
6.4.1 问题
6.4.2 解决方案
6.4.3 工作原理
6.5 将Spring与DWR集成
6.5.1 问题
6.5.2 解决方案
6.5.3 工作原理
6.6 小结
第7章 Spring Web Flow
7.1 用Spring Web Flow管理简单的UI流程
7.1.1 问题
7.1.2 解决方案
7.1.3 工作原理
7.2 用不同状态类型建立Web流程模型
7.2.1 问题
7.2.2 解决方案
7.2.3 工作原理
7.3 加强Web流程安全
7.3.1 问题
7.3.2 解决方案
7.3.3 工作原理
7.4 持续存储Web流程中的对象
7.4.1 问题
7.4.2 解决方案
7.4.3 工作原理
7.5 将Spring Web Flow与JSF集成
7.5.1 问题
7.5.2 解决方案
7.5.3 工作原理
7.6 使用RichFaces与Spring WebFlow协作
7.6.1 问题
7.6.2 解决方案
7.6.3 方法
7.7 小结
第8章 Spring @MVC
8.1 用Spring MVC开发简单的Web应用
8.1.1 问题
8.1.2 解决方案
8.1.3 工作原理
8.2 用@RequestMapping映射请求
8.2.1 问题
8.2.2 解决方案
8.2.3 工作原理
8.3 用处理程序拦截器拦截请求
8.3.1 问题
8.3.2 解决方案
8.3.3 工作原理
8.4 解析用户区域
8.4.1 问题
8.4.2 解决方案
8.4.3 工作原理
8.5 外部化区分区域的文本信息
8.5.1 问题
8.5.2 解决方案
8.5.3 工作原理
8.6 按照名称解析视图
8.6.1 问题
8.6.2 解决方案
8.6.3 工作原理
8.7 视图和内容协商
8.7.1 问题
8.7.2 解决方案
8.7.3 工作原理
8.8 映射异常视图
8.8.1 问题
8.8.2 解决方案
8.8.3 工作原理
8.9 用@Value在控制器中赋值
8.9.1 问题
8.9.2 解决方案
8.9.3 工作原理
8.10 用控制器处理表单
8.10.1 问题
8.10.2 解决方案
8.10.3 工作原理
8.11 用向导表单控制器处理多页表单
8.11.1 问题
8.11.2 解决方案
8.11.3 工作原理
8.12 使用注解(JSR-303)的Bean校验
8.12.1 问题
8.12.2 解决方案
8.12.3 工作原理
8.13 创建Excel和PDF视图
8.13.1 问题
8.13.2 解决方案
8.13.3 工作原理
8.14 小结
第9章 Spring REST
9.1 用Spring发布一个REST服务
9.1.1 问题
9.1.2 解决方案
9.1.3 工作原理
9.2 用Spring访问REST服务
9.2.1 问题
9.2.2 解决方案
9.2.3 工作原理
9.3 发布RSS和Atom信息源
9.3.1 问题
9.3.2 解决方案
9.3.3 工作原理
9.4 用REST服务发布JSON
9.4.1 问题
9.4.2 解决方案
9.4.3 工作原理
9.5 访问具有复杂XML响应的REST服务
9.5.1 问题
9.5.2 解决方案
9.5.3 工作原理
9.6 小结
第10章 Spring和Flex
10.1 Flex入门
10.1.1 问题
10.1.2 解决方案
10.1.3 工作原理
10.2 离开沙箱
10.2.1 问题
10.2.2 解决方案
10.2.3 工作原理
10.3 为应用添加Spring BlazeDS支持
10.3.1 问题
10.3.2 解决方案
10.3.3 工作原理
10.4 通过BlazeDS/Spring暴露服务
10.4.1 问题
10.4.2 解决方案
10.4.3 工作原理
10.5 使用服务器端对象
10.5.1 问题
10.5.2 解决方案
10.5.3 工作原理
10.6 使用BlazeDS和Spring消费面向消息的服务
10.6.1 问题
10.6.2 解决方案
10.6.3 工作原理
10.7 将依赖注入带给你的ActionScript客户
10.7.1 问题
10.7.2 解决方案
10.7.3 工作原理
10.8 小结
第11章 Grails
11.1 获取和安装Grails
11.1.1 问题
11.1.2 解决方案
11.1.3 工作原理
11.2 创建Grails应用
11.2.1 问题
11.2.2 解决方案
11.2.3 工作原理
11.3 Grails插件
11.3.1 问题
11.3.2 解决方案
11.3.3 工作原理
11.4 在Grails环境中开发、生产和测试
11.4.1 问题
11.4.2 解决方案
11.4.3 工作原理
11.5 创建应用的领域类
11.5.1 问题
11.5.2 解决方案
11.5.3 工作原理
11.6 为一个应用的领域类生成CRUD控制器和视图
11.6.1 问题
11.6.2 解决方案
11.6.3 工作原理
11.7 国际化(I18n)信息属性
11.7.1 问题
11.7.2 解决方案
11.7.3 工作原理
11.8 改变永久性存储系统
11.8.1 问题
11.8.2 解决方案
11.4.3 工作原理
11.9 日志
11.9.1 问题
11.9.2 解决方案
11.9.3 工作原理
11.10 运行单元和集成测试
11.10.1 问题
11.10.2 解决方案
11.10.3 工作原理
11.11 使用自定义布局和模板
11.11.1 问题
11.11.2 解决方案
11.11.3 工作原理
11.12 使用GORM查询
11.12.1 问题
11.12.2 解决方案
11.12.3 工作原理
11.13 创建自定义标记
11.13.1 问题
11.13.2 解决方案
11.13.3 工作原理
11.14 小结
第12章 Spring Roo
12.1 设置Spring Roo开发环境
12.1.1 问题
12.1.2 解决方案
12.1.3 工作原理
12.2 创建第一个Spring Roo项目
12.2.1 问题
12.2.2 解决方案
12.2.3 工作原理
12.3 把现有项目导入SpringSource Tool Suite
12.3.1 问题
12.3.2 解决方案
12.3.3 工作原理
12.4 更快地构建更好的应用程序
12.4.1 问题
12.4.2 解决方案
12.4.3 工作原理
12.5 从项目中删除Spring Roo
12.5.1 问题
12.5.2 解决方案
12.5.3 工作原理
12.6 小结
第13章 Spring测试
13.1 用JUnit and TestNG创建测试
13.1.1 问题
13.1.2 解决方案
13.1.3 工作原理
13.2 创建单元测试和集成测试
13.2.1 问题
13.2.2 解决方案
13.2.3 工作原理
13.3 Spring MVC控制器的单元测试
13.3.1 问题
13.3.2 解决方案
13.3.3 工作原理
13.4 管理集成测试中的应用上下文
13.4.1 问题
13.4.2 解决方案
13.4.3 工作原理
13.5 向集成测试注入测试夹具
13.5.1 问题
13.5.2 解决方案
13.5.3 工作原理
13.6 管理集成测试中的事务
13.6.1 问题
13.6.2 解决方案
13.6.3 工作原理
13.7 在集成测试中访问数据库
13.7.1 问题
13.7.2 解决方案
13.7.3 工作原理
13.8 使用Spring的常用测试注解
13.8.1 问题
13.8.2 解决方案
13.8.3 工作原理
13.9 小结
第14章 Spring Portlet MVC框架
14.1 用Spring Portlet MVC开发一个简单的Portlet
14.1.1 问题
14.1.2 解决方案
14.1.3 工作原理
14.2 将Portlet请求映射到处理程序
14.2.1 问题
14.2.2 解决方案
14.2.3 工作原理
14.3 用简单的表单控制器处理portlet表单
14.3.1 问题
14.3.2 解决方案
14.3.3 工作原理
14.4 小结
第15章 数据访问
15.1 Direct JDBC的问题
15.1.1 建立应用数据库
15.1.2 理解数据访问对象设计模式
15.1.3 用JDBC实现DAO
15.1.4 在Spring中配置数据源
15.1.5 运行DAO
15.1.6 更进一步
15.2 使用JDBC模板更新数据库
15.2.1 问题
15.2.2 解决方案
15.2.3 工作原理
15.3 使用JDBC模板查询数据库
15.3.1 问题
15.3.2 解决方案
15.3.3 工作原理
15.4 简化JDBC模板创建
15.4.1 问题
15.4.2 解决方案
15.4.3 工作原理
15.5 在Java 1.5中使用简单的JDBC模板
15.5.1 问题
15.5.2 解决方案
15.5.3 工作原理
15.6 在JDBC模板中使用命名参数
15.6.1 问题
15.6.2 解决方案
15.6.3 工作原理
15.7 在Spring JDBC框架中处理异常
15.7.1 问题
15.7.2 解决方案
15.7.3 工作原理
15.8 直接使用ORM框架的问题
15.8.1 问题
15.8.2 解决方案
15.8.3 工作原理
15.8.4 使用Hibernate API，用Hibernate XML映射持续化对象
15.8.5 使用Hibernate API，以JPA注解持续化对象
15.8.6 使用JPA，以Hibernate为引擎持续化对象
15.9 在Spring中配置ORM资源工厂
15.9.1 问题
15.9.2 解决方案
15.9.3 工作原理
15.10 用Spring ORM模板持续化对象
15.10.1 问题
15.10.2 解决方案
15.10.3 工作原理
15.11 用Hibernate的上下文会话持续化对象
15.11.1 问题
15.11.2 解决方案
15.11.3 工作原理
15.12 用JPA的上下文注入持续化对象
15.12.1 问题
15.12.2 解决方案
15.12.3 工作原理
15.13 小结
第16章 Spring中的事务管理
16.1 事务管理的问题
16.2 选择一个事务管理器实现
16.2.1 问题
16.2.2 解决方案
16.2.3 工作原理
16.3 用事务管理器API编程管理事务
16.3.1 问题
16.3.2 解决方案
16.3.3 工作原理
16.4 用事务模板编程管理事务
16.4.1 问题
16.4.2 解决方案
16.4.3 工作原理
16.5 用事务通知声明式地管理事务
16.5.1 问题
16.5.2 解决方案
16.5.3 工作原理
16.6 用@Transactional注解声明式地管理事务
16.6.1 方法
16.6.2 解决方案
16.6.3 工作原理
16.7 设置事务传播属性
16.7.1 问题
16.7.2 解决方案
16.7.3 工作原理
16.8 设置隔离事务属性
16.8.1 问题
16.8.2 解决方案
16.8.3 工作原理
16.9 设置Rollback事务属性
16.9.1 问题
16.9.2 解决方案
16.9.3 工作原理
16.10 设置超时和只读事务属性
16.10.1 问题
16.10.2 解决方案
16.10.3 工作原理
16.11 用加载时织入管理事务
16.11.1 问题
16.11.2 解决方案
16.11.3 工作原理
16.12 小结
第17章 EJB、Spring Remoting和Web服务
17.1 通过RMI暴露和调用服务
17.1.1 问题
17.1.2 解决方案
17.1.3 工作原理
17.2 用Spring创建EJB 2.x组件
17.2.1 问题
17.2.2 解决方案
17.2.3 工作原理
17.3 在Spring中访问遗留的EJB 2.x组件
17.3.1 问题
17.3.2 解决方案
17.3.3 工作原理
17.4 在Spring中创建EJB 3.0组件
17.4.1 问题
17.4.2 解决方案
17.4.3 工作原理
17.5 在Spring中访问EJB 3.0组件
17.5.1 问题
17.5.2 解决方案
17.5.3 工作原理
17.6 通过HTTP暴露和调用服务
17.6.1 问题
17.6.2 解决方案
17.6.3 工作原理
17.7 选择SOAP Web服务开发方法
17.7.1 问题
17.7.2 解决方案
17.7.3 工作原理
17.8 使用JAX-WS暴露和调用Contract-Last SOAP Web服务
17.8.1 问题
17.8.2 解决方案
17.8.3 工作原理
17.9 定义Web服务契约
17.9.1 问题
17.9.2 解决方案
17.9.3 工作原理
17.10 使用Spring-WS实现Web服务
17.10.1 问题
17.10.2 解决方案
17.10.3 工作原理
17.11 使用Spring-WS调用Web服务
17.11.1 问题
17.11.2 解决方案
17.11.3 工作原理
17.12 用XML编组开发Web服务
17.12.1 问题
17.12.2 解决方案
17.12.3 工作原理
17.13 用注解创建服务端点
17.13.1 问题
17.13.2 解决方案
17.13.3 工作原理
17.14 小结
第18章 企业中的Spring
18.1 将Spring Bean输出为JMX MBean
18.1.1 问题
18.1.2 解决方案
18.1.3 工作原理
18.2 发布和监听JMX通知
18.2.1 问题
18.2.2 解决方案
18.2.3 工作原理
18.3 在Spring中访问远程JMX MBean
18.3.1 问题
18.3.2 解决方案
18.3.3 工作原理
18.4 用Spring电子邮件支持发送邮件
18.4.1 问题
18.4.2 解决方案
18.4.3 工作原理
18.5 用Spring的Quartz支持进行调度
18.5.1 问题
18.5.2 解决方案
18.5.3 工作原理
18.6 用Spring 3.0的调度命名空间进行调度
18.6.1 问题
18.6.2 解决方案
18.6.3 工作原理
18.7 小结
第19章 消息
19.1 用Spring发送和接收JMS消息
19.1.1 问题
19.1.2 解决方案
19.1.3 工作原理
19.2 转换JMS消息
19.2.1 问题
19.2.2 解决方案
19.2.3 方法
19.3 管理JMS事务
19.3.1 问题
19.3.2 方法
19.3.3 解决方案
19.4 在Spring中创建消息驱动POJO
19.4.1 问题
19.4.2 解决方案
19.4.3 工作原理
19.5 建立连接
19.5.1 问题
19.5.2 解决方案
19.5.3 工作原理
19.6 小结
第20章 Spring Integration
20.1 用EAI集成一个系统到另一个系统
20.1.1 问题
20.1.2 解决方案
20.1.3 工作原理
20.2 使用JMS集成两个系统
20.2.1 问题
20.2.2 解决方案
20.2.3 工作原理
20.3 查询Spring Integration消息得到上下文信息
20.3.1 问题
20.3.2 解决方案
20.3.3 工作原理
20.4 用一个文件系统集成两个系统
20.4.1 问题
20.4.2 解决方案
20.4.3 工作原理
20.5 将消息从一种类型转换为另一种类型
20.5.1 问题
20.5.2 解决方案
20.5.3 工作原理
20.6 使用Spring Integration进行错误处理
20.6.1 问题
20.6.2 解决方案
20.6.3 工作原理
20.7 集成控制分支：分解器和聚合器
20.7.1 问题
20.7.2 解决方案
20.7.3 工作原理
20.8 用路由器实现条件路由
20.8.1 问题
20.8.2 解决方案
20.8.3 工作原理
20.9 使外部系统适应总线
20.9.1 问题
20.9.2 解决方案
20.9.3 工作原理
20.10 用Spring Batch产生事件
20.10.1 问题
20.10.2 解决方案
20.10.3 工作原理
20.11 使用网关
20.11.1 问题
20.11.2 解决方案
20.11.3 工作原理
20.12 小结
第21章 Spring Batch
21.1 建立Spring Batch的基础架构
21.1.1 问题
21.1.2 解决方案
21.1.3 工作原理
21.2 读取和写入(无计算)
21.2.1 问题
21.2.2 解决方案
21.2.3 工作原理
21.3 编写自定义ItemWriter和ItemReader
21.3.1 问题
21.3.2 解决方案
21.3.3 工作原理
21.4 在写入前处理输入
21.4.1 问题
21.4.2 解决方案
21.4.3 工作原理
21.5 通过事务改善生活
21.5.1 问题
21.5.2 解决方案
21.5.3 工作原理
21.6 重试
21.6.1 问题
21.6.2 解决方案
21.6.3 工作原理
21.7 控制步骤异常
21.7.1 问题
21.7.2 解决方案
21.7.3 工作原理
21.8 启动一个作业
21.8.1 问题
21.8.2 解决方案
21.8.3 工作原理
21.9 参数化一个作业
21.9.1 问题
21.9.2 解决方案
21.9.3 工作原理
21.10 小结
第22章 网格上的Spring
22.1 使用Terracotta聚合对象状态
22.1.1 问题
22.1.2 解决方案
22.1.3 工作原理
22.2 将执行分布到网格上
22.2.1 问题
22.2.2 解决方案
22.2.3 方法
22.3 方法的负载平衡
22.3.1 问题
22.3.2 解决方案
22.3.3 方法
22.4 并行处理
22.4.1 问题
22.4.2 解决方案
22.4.3 方法
22.5 在GridGain上部署
22.5.1 问题
22.5.2 解决方案
22.5.3 工作原理
22.6 小结
第23章 jBPM和Spring
软件过程
23.1 理解工作流模型
23.1.1 问题
23.1.2 解决方案
23.1.3 工作原理
23.2 安装jBPM
23.2.1 问题
23.2.2 解决方案
23.2.3 工作原理
23.3 将jBPM4与Spring整合
23.3.1 问题
23.3.2 解决方案
23.3.3 工作原理
23.4 用Spring构建一个服务
23.4.1 问题
23.4.2 解决方案
23.4.3 工作原理
23.5 构建业务过程
23.5.1 问题
23.5.2 解决方案
23.5.3 工作原理
23.6 小结
第24章 OSGi和Spring
24.1 OSGi入门
24.1.1 问题
24.1.2 解决方案
24.1.3 工作原理
24.2 开始使用Spring Dynamic Modules
24.2.1 问题
24.2.2 解决方案
24.2.3 工作原理
24.3 用Spring Dynamic Modules输出服务
24.3.1 问题
24.3.2 解决方案
24.3.3 工作原理
24.4 在OSGi注册表中寻找一个具体服务
24.4.1 问题
24.4.2 解决方案
24.4.3 工作原理
24.5 发布多个接口的一个服务
24.5.1 问题
24.5.2 解决方案
24.5.3 工作原理
24.6 定制Spring Dynamic Modules
24.6.1 问题
24.6.2 解决方案
24.6.3 工作原理
24.7 使用SpringSource dm Server
24.7.1 问题
24.7.2 解决方案
24.7.3 工作原理
24.8 SpringSource的各类工具
24.8.1 问题
24.8.2 解决方案
24.8.3 工作原理
24.9 小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring攻略
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
目　录
1. 明日的预言　　001
2. 忍受的义务　　004
3. 死神的万灵药　　012
4. 地表水和地下水　　032
5. 土壤王国　　043
6. 地球的绿披风　　051
7. 没必要的大破坏　　069
8. 再也听不到鸟儿的歌唱　　083
9. 死亡的河流　　106
10. 祸从天降　　127
11. 超越波尔吉亚家族的梦想　　142
12. 人类付出的代价　　153
13. 透过一扇狭小的窗户　　163
14. 每4个人中就会有一个癌症患者　　178
15. 大自然在反击　　199
16. 隆隆的崩溃声　　214
17. 另外一条路　　225
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务：入门、实战与进阶
Contents 目　　录
赞誉
前言
第一部分　准备篇
第1章　Spring Cloud 与微服务概述  2
1.1　传统的单体应用  2
1.1.1　改进单体应用的架构  2
1.1.2　向微服务靠拢  3
1.2　什么是微服务  4
1.2.1　使用微服务架构的优势和劣势  4
1.2.2　重构前的准备工作  5
1.3　什么是Spring Cloud  5
1.3.1　Spring Cloud模块介绍  6
1.3.2　Spring Cloud版本介绍  6
1.4　本章小结  7
第2章　实战前的准备工作  8
2.1　开发环境的准备  8
2.2　Spring Boot入门  9
2.2.1　Spring Boot简介  9
2.2.2　搭建Spring Boot项目  9
2.2.3　编写第一个REST接口  11
2.2.4　读取配置文件  11
2.2.5　profiles多环境配置  13
2.2.6　热部署  13
2.2.7　actuator监控  15
2.2.8　自定义actuator端点  17
2.2.9　统一异常处理  18
2.2.10　异步执行  20
2.2.11　随机端口  22
2.2.12　编译打包  24
2.3　Spring Boot Starter自定义  25
2.3.1　Spring Boot Starter项目创建  25
2.3.2　自动创建客户端  26
2.3.3　使用Starter  27
2.3.4　使用注解开启Starter自动构建  27
2.3.5　使用配置开启Starter自动构建  28
2.3.6　配置Starter内容提示  29
2.4　本章小结  29
第二部分　基础篇
第3章　Eureka 注册中心  32
3.1　Eureka  32
3.2　使用 Eureka 编写注册中心服务  33
3.3　编写服务提供者  35
3.3.1　创建项目注册到Eureka  35
3.3.2　编写提供接口  36
3.4　编写服务消费者  37
3.4.1　直接调用接口  37
3.4.2　通过Eureka来消费接口  38
3.5　开启 Eureka 认证  38
3.6　Eureka 高可用搭建  39
3.6.1　高可用原理  39
3.6.2　搭建步骤  40
3.7　常用配置讲解  41
3.7.1　关闭自我保护  41
3.7.2　自定义Eureka的
InstanceID  41
3.7.3　自定义实例跳转链接  42
3.7.4　快速移除已经失效的服务信息  43
3.8　扩展使用  44
3.8.1　Eureka REST API  44
3.8.2　元数据使用  46
3.8.3　EurekaClient使用  47
3.8.4　健康检查  49
3.8.5　服务上下线监控  50
3.9　本章小结  51
第4章　客户端负载均衡 Ribbon  52
4.1　Ribbon  52
4.1.1　Ribbon模块  52
4.1.2　Ribbon 使用  53
4.2　RestTemplate 结合 Ribbon 使用  54
4.2.1　使用 RestTemplate 与整合 Ribbon  54
4.2.2　RestTemplate 负载均衡示例  57
4.2.3　@LoadBalanced 注解原理  58
4.2.4　Ribbon API 使用  62
4.2.5　Ribbon 饥饿加载  63
4.3　负载均衡策略介绍  64
4.4　自定义负载策略  65
4.5　配置详解  66
4.5.1　常用配置  66
4.5.2　代码配置 Ribbon  67
4.5.3　配置文件方式配置Ribbon  67
4.6　重试机制  68
4.7　本章小结  69
第5章　声明式REST客户端Feign  70
5.1　使用 Feign 调用服务接口  70
5.1.1　在Spring Cloud中集成Feign  71
5.1.2　使用Feign调用接口  71
5.2　自定义 Feign的配置  72
5.2.1　日志配置  72
5.2.2　契约配置  73
5.2.3　Basic认证配置  74
5.2.4　超时时间配置  75
5.2.5　客户端组件配置  75
5.2.6　GZIP压缩配置  76
5.2.7　编码器解码器配置  77
5.2.8　使用配置自定义Feign的配置  78
5.2.9　继承特性  78
5.2.10　多参数请求构造  80
5.3　脱离 Spring Cloud 使用 Feign  80
5.3.1　原生注解方式  81
5.3.2　构建Feign对象  82
5.3.3　其他配置  83
5.4　本章小结  83
第6章　Hystrix 服务容错处理  84
6.1　Hystrix  84
6.1.1　Hystrix的简单使用  84
6.1.2　回退支持  85
6.1.3　信号量策略配置  86
6.1.4　线程隔离策略配置  86
6.1.5　结果缓存  87
6.1.6　缓存清除  88
6.1.7　合并请求  89
6.2　在 Spring Cloud 中使用Hystrix  91
6.2.1　简单使用  91
6.2.2　配置详解  92
6.2.3　Feign整合Hystrix服务容错  95
6.2.4　Feign中禁用Hystrix  97
6.3　Hystrix 监控  97
6.4　整合 Dashboard 查看监控数据  98
6.5　Turbine 聚合集群数据  100
6.5.1　Turbine使用  100
6.5.2　context-path导致监控失败  101
6.6　本章小结  102
第7章　API网关  103
7.1　Zuul 简介  103
7.2　使用 Zuul 构建微服务网关  104
7.2.1　简单使用  104
7.2.2　集成Eureka  105
7.3　Zuul 路由配置  105
7.4　Zuul过滤器讲解  106
7.4.1　过滤器类型  106
7.4.2　请求生命周期  107
7.4.3　使用过滤器  108
7.4.4　过滤器禁用  109
7.4.5　过滤器中传递数据  110
7.4.6　过滤器拦截请求  111
7.4.7　过滤器中异常处理  113
7.5　Zuul 容错和回退  115
7.5.1　容错机制  115
7.5.2　回退机制  116
7.6　Zuul使用小经验  118
7.6.1　/routes 端点  118
7.6.2　/filters 端点  118
7.6.3　文件上传  119
7.6.4　请求响应信息输出  121
7.6.5　Zuul自带的Debug功能  124
7.7　Zuul 高可用  126
7.8　本章小结  127
第三部分　实战篇
第8章　API 网关之Spring Cloud Gateway  130
8.1　Spring Cloud Gateway介绍  130
8.2　Spring Cloud Gateway工作原理  131
8.3　Spring Cloud Gateway快速上手  131
8.3.1　创建Gateway项目  131
8.3.2　路由转发示例  132
8.3.3　整合Eureka路由  133
8.3.4　整合Eureka的默认路由  133
8.4　Spring Cloud Gateway路由断言工厂  134
8.4.1　路由断言工厂使用  134
8.4.2　自定义路由断言工厂  136
8.5　Spring Cloud Gateway过滤器工厂  137
8.5.1　Spring Cloud Gateway过滤器工厂使用  137
8.5.2　自定义Spring Cloud Gateway过滤器工厂  138
8.6　全局过滤器  140
8.7　实战案例  143
8.7.1　限流实战  143
8.7.2　熔断回退实战  145
8.7.3　跨域实战  145
8.7.4　统一异常处理  147
8.7.5　重试机制  150
8.8　本章小结  151
第9章　自研分布式配置管理  152
9.1　自研配置管理框架 Smconf 简介  152
9.2　Smconf 工作原理  153
9.3　Smconf 部署  154
9.3.1　Mongodb 安装  154
9.3.2　Zookeeper 安装  155
9.3.3　Smconf Server 部署  156
9.4　项目中集成 Smconf  157
9.4.1　集成Smconf  157
9.4.2　使用Smconf  158
9.4.3　配置更新回调  159
9.5　Smconf 详细使用  160
9.5.1　源码编译问题  160
9.5.2　后台账号管理  160
9.5.3　REST API  161
9.6　Smconf 源码解析  163
9.6.1　Client启动  163
9.6.2　启动加载配置  165
9.6.3　配置修改推送原理  166
9.7　本章小结  167
第10章　分布式配置中心Apollo  168
10.1　Apollo简介  168
10.2　Apollo的核心功能点  168
10.3　Apollo核心概念  170
10.4　Apollo本地部署  171
10.5　Apollo Portal管理后台使用  172
10.6　Java中使用Apollo  174
10.6.1　普通Java项目中使用  174
10.6.2　Spring Boot中使用  177
10.7　Apollo的架构设计  179
10.7.1　Apollo架构设计介绍  179
10.7.2　Apollo服务端设计  181
10.7.3　Apollo客户端设计  188
10.7.4　Apollo高可用设计  195
10.8　本章小结  196
第11章　Sleuth 服务跟踪  197
11.1　Spring Cloud 集成 Sleuth  197
11.2　整合 Logstash  198
11.2.1　ELK 简介  198
11.2.2　输出 JSON 格式日志  198
11.3　整合 Zipkin  200
11.3.1　Zipkin 数据收集服务  200
11.3.2　项目集成 Zipkin 发送调用链数据  201
11.3.3　抽样采集数据  203
11.3.4　异步任务线程池定义  203
11.3.5　TracingFilter  204
11.3.6　监控本地方法  205
11.3.7　过滤不想跟踪的请求  206
11.3.8　用 RabbitMq 代替 Http 发送调用链数据  206
11.3.9　用 Elasticsearch 存储调用链数据  207
11.4　本章小结  208
第12章　微服务之间调用的安全认证  209
12.1　什么是 JWT  209
12.2　创建统一的认证服务  210
12.2.1　表结构  210
12.2.2　JWT工具类封装  210
12.2.3　认证接口  212
12.3　服务提供方进行调用认证  212
12.4　服务消费方申请 Token  214
12.5　Feign 调用前统一申请 Token 传递到调用的服务中  216
12.6　RestTemplate调用前统一申请 Token 传递到调用的服务中  217
12.7　Zuul 中传递 Token 到路由的服务中  218
12.8　本章小结  219
第13章　Spring Boot Admin  220
13.1　Spring Boot Admin 的使用方法  220
13.1.1　创建 Spring Boot Admin项目  220
13.1.2　将服务注册到 Spring Boot Admin  221
13.1.3　监控内容介绍  223
13.1.4　如何在 Admin 中查看各个服务的日志  225
13.2　开启认证  226
13.3　集成 Eureka  227
13.4　监控服务  228
13.4.1　邮件警报  228
13.4.2　自定义钉钉警报  229
13.5　本章小结  232
第14章　服务的API文档管理  233
14.1　Swagger 简介  233
14.2　集成 Swagger 管理 API 文档  234
14.2.1　项目中集成 Swagger  234
14.2.2　使用 Swagger 生成文档  234
14.2.3　在线测试接口  235
14.3　Swagger 注解  236
14.4　Eureka 控制台快速查看 Swagger 文档  240
14.5　请求认证  240
14.6　Zuul中聚合多个服务Swagger  241
14.7　本章小结  242
第四部分　高级篇
第15章　API 网关扩展  244
15.1　用户认证  244
15.1.1　动态管理不需要拦截的 API 请求  244
15.1.2　创建认证的用户服务  246
15.1.3　路由之前的认证  247
15.1.4　向下游微服务中传递认证之后的用户信息  248
15.1.5　内部服务间的用户信息传递  248
15.2　服务限流  250
15.2.1　限流算法  250
15.2.2　单节点限流  251
15.2.3　集群限流  255
15.2.4　具体服务限流  258
15.2.5　具体接口限流  258
15.3　服务降级  262
15.4　灰度发布  264
15.4.1　原理讲解  264
15.4.2　根据用户做灰度发布  265
15.4.3　根据 IP 做灰度发布  268
15.5　本章小结  268
第16章　微服务之缓存  269
16.1　Guava Cache 本地缓存  269
16.1.1　Guava Cache 简介  269
16.1.2　代码示例  270
16.1.3　回收策略  270
16.2　Redis 缓存  271
16.2.1　用 Redistemplate 操作 Redis  271
16.2.2　用 Repository 操作 Redis  272
16.2.3　Spring Cache 缓存数据  274
16.2.4　缓存异常处理  278
16.2.5　自定义缓存工具类  279
16.3　防止缓存穿透方案  282
16.3.1　什么是缓存穿透  282
16.3.2　缓存穿透的危害  282
16.3.3　解决方案  282
16.3.4　布隆过滤器介绍  283
16.3.5　代码示例  283
16.4　防止缓存雪崩方案  284
16.4.1　什么是缓存雪崩  284
16.4.2　缓存雪崩的危害  284
16.4.3　解决方案  284
16.4.4　代码示例  285
16.4.5　分布式锁方式  285
16.5　本章小结  286
第17章　微服务之存储  287
17.1　存储选型  287
17.2　Mongodb  288
17.2.1　集成 Spring Data Mongodb  288
17.2.2　添加数据操作  288
17.2.3　索引使用  290
17.2.4　修改数据操作  291
17.2.5　删除数据操作  293
17.2.6　查询数据操作  294
17.2.7　GridFS 操作  295
17.2.8　用 Repository方式操作数据  296
17.2.9　自增 ID 实现  300
17.2.10　批量更新扩展  303
17.3　Mysql  304
17.3.1　集成 Spring Jdbc-Template  304
17.3.2　JdbcTemplate 代码示例  305
17.3.3　封装 JdbcTemplate 操作 Mysql 更简单  305
17.3.4　扩展 JdbcTemplate 使用方式  306
17.3.5　常见问题  310
17.4　Elasticsearch  312
17.4.1　集成 Spring Data Elasticsearch  312
17.4.2　Repository 示例  312
17.4.3　ElasticsearchTemplate 示例  315
17.4.4　索引构建方式  318
17.5　本章小结  319
第18章　微服务之分布式事务解决方案  320
18.1　两阶段型  320
18.2　TCC 补偿型  321
18.3　最终一致性  321
18.3.1　原理讲解  321
18.3.2　创建可靠性消息服务  323
18.3.3　消息存储表设计  324
18.3.4　提供服务接口  325
18.3.5　创建消息发送系统  329
18.3.6　消费消息逻辑  332
18.3.7　消息管理系统  335
18.4　最大努力通知型事务  335
18.5　本章小结  335
第19章　分布式任务调度  336
19.1　Elastic-Job  336
19.1.1　Elastic-Job 介绍  336
19.1.2　任务调度目前存在的问题  336
19.1.3　为什么选择 Elastic-Job  337
19.2　快速集成  338
19.3　任务使用  339
19.3.1　简单任务  339
19.3.2　数据流任务  340
19.3.3　脚本任务  340
19.4　配置参数讲解  341
19.4.1　注册中心配置  341
19.4.2　作业配置  342
19.4.3　dataflow 独有配置  343
19.4.4　script独有配置  343
19.5　多节点并行调度  344
19.5.1　分片概念  344
19.5.2　任务节点分片策略  344
19.5.3　业务数据分片处理  345
19.6　事件追踪  347
19.7　扩展功能  349
19.7.1　自定义监听器  349
19.7.2　定义异常处理  349
19.8　运维平台  350
19.8.1　功能列表  350
19.8.2　部署运维平台  351
19.8.3　运维平台使用  351
19.9　使用经验分享  355
19.9.1　任务的划分和监控  355
19.9.2　任务的扩展性和节点数量  355
19.9.3　任务的重复执行  355
19.9.4　overwrite 覆盖问题  356
19.9.5　流水式任务  356
19.10　本章小结  357
第20章　分库分表解决方案  358
20.1　Sharding-JDBC  358
20.1.1　介绍  358
20.1.2　功能列表  359
20.1.3　相关概念  359
20.2　快速集成  360
20.3　读写分离实战  362
20.3.1　准备数据  362
20.3.2　配置读写分离  363
20.3.3　验证读从库  363
20.3.4　验证写主库  365
20.3.5　Hint 强制路由主库  366
20.4　分库分表实战  367
20.4.1　常用分片算法  367
20.4.2　使用分片算法  368
20.4.3　不分库只分表实战  368
20.4.4　既分库又分表实战  372
20.5　分布式主键  375
20.6　本章小结  377
第21章　最佳生产实践经验  378
21.1　开发环境和测试环境共用Eureka  378
21.2　Swagger和Actuator访问进行权限控制  379
21.3　Spring Boot Admin监控被保护的服务  380
21.4　Apollo配置中心简化版搭建分享  380
21.5　Apollo使用小经验  382
21.5.1　公共配置  382
21.5.2　账号权限  383
21.5.3　环境配置和项目配置  385
21.6　Apollo动态调整日志级别  385
21.7　Apollo存储加密  387
21.8　扩展Apollo支持存储加解密  390
21.9　Apollo结合Zuul实现动态路由  391
21.10　Apollo整合Archaius  393
21.11　Elastic-Job的Spring-Boot-Starter封装  394
21.12　Spring Boot中Mongodb多数据源封装  396
21.13　Zuul中对API进行加解密  398
21.14　本章小结  400
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务：入门、实战与进阶
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型门户网站是这样炼成的！
第1篇 技术篇　第1章 大型门户网站架构分析　　1.1 大型门户网站与小型企业网站的区别　　1.2 高性能、高负载门户网站架构剖析　　　1.2.1 服务器操作系统的选择　　　1.2.2 DNS服务器BIND　　　1.2.3 Cache服务器Squid　　　1.2.4 带负载均衡的HTTP服务器Apache　　　1.2.5 支持集群功能的Web服务器Tomcat　　　1.2.6 开源数据库服务器之骄子MySQL　　　1.2.7 功能强大的FlV流媒体服务器RED5　　1.3 门户网站开发指导思想　　1.4 SSH 2组合框架—门户网站开发之首选　　　1.4.1 MVC混血宠儿Struts 2　　　1.4.2 幕后的财政部长Spring 2.5　　　1.4.3 ORM中间件香馍馍Hibernate 3.2　　1.5 小结　第2章 MVC混血宠儿Struts 2　　2.1 初识MVC新秀Struts 2　　　2.1.1 MVC概述　　　2.1.2 Struts 2的MVC实现　　　2.1.3 Struts 2的基本组成　　　2.1.4 Struts 2的常用类介绍　　　2.1.5 Struts 2的业务控制器Action实现　　　2.1.6 Struts 2的处理结果Result　　　2.1.7 功能强大的表达式语言OGNL　　　2.1.8 Struts 2的运行流程分析—HelloWorld　　　2.1.9 Struts 2的异常处理　　2.2 Struts 2配置精要　　　2.2.1 web.xml中Struts 2的配置实现　　　2.2.2 Struts 2属性配置文件struts.properties详解　　　2.2.3 Struts 2核心配置文件struts.xml详解　　2.3 Struts 2应用开发实务　　　2.3.1 Struts 2应用开发环境的搭建　　　2.3.2 Struts 2应用基本开发步骤—搭建ePortal应用　　　2.3.3 Struts 2中集成FCKeditor　　　2.3.4 Struts 2中集成DisplayTag　　2.4 Struts 2国际化实现　　　2.4.1 Web应用的中文本地化　　　2.4.2 Struts 2应用的国际化　　　2.4.3 Struts 2国际化语言的动态切换　　2.5 Struts 2的校验框架　　　2.5.1 在Action中实现手动校验　　　2.5.2 调用校验框架进行自动校验　　　2.5.3 自定义国际化Struts 2校验错误消息　　　2.5.4 Struts 2的自带校验器　　2.6 Struts 2的拦截器　　　2.6.1 Struts 2内建拦截器介绍　　　2.6.2 定义和使用拦截器栈　　　2.6.3 使用自定义拦截器　　2.7 小结　第3章 Struts 2标签库详解与AJAX技术应用　　3.1 Struts 2主题与模板　　3.2 Struts 2控制标签详解　　　3.2.1 if/elseif/else标签详解　　　3.2.2 iterator标签详解　　　3.2.3 append标签详解　　　3.2.4 generator标签详解　　　3.2.5 merge标签详解　　　3.2.6 subset标签详解　　　3.2.7 sort标签详解　　3.3 Struts 2数据标签详解　　　3.3.1 action标签详解　　　3.3.2 bean标签详解　　　3.3.3 date标签详解　　　3.3.4 debug标签详解　　　3.3.5 i18n标签详解　　　3.3.6 include标签详解　　　3.3.7 param标签详解　　　3.3.8 push标签详解　　　3.3.9 set标签详解　　　3.3.10 text标签详解　　　3.3.11 url标签详解　　　3.3.12 property标签详解　　3.4 Struts 2表单标签详解　　　3.4.1 checkbox标签详解　　　3.4.2 checkboxlist标签详解　　　3.4.3 combobox标签详解　　　3.4.4 doubleselect标签详解　　　3.4.5 file标签详解　　　3.4.6 form标签详解　　　3.4.7 hidden标签详解　　　3.4.8 select标签详解　　　3.4.9 optgroup标签详解　　　3.4.10 optiontransferselect标签详解　　　3.4.11 password标签详解　　　3.4.12 radio标签详解　　　3.4.13 reset与submit标签详解　　　3.4.14 textarea标签详解　　　3.4.15 textfield标签详解　　　3.4.16 token标签详解　　　3.4.17 updownselect标签详解　　3.5 Struts 2 AJAX标签详解　　　3.5.1 a与submit标签详解　　　3.5.2 autocompleter标签详解　　　3.5.3 datetimepicker标签详解　　　3.5.4 div标签详解　　　3.5.5 head标签详解　　　3.5.6 tabbedPanel标签详解　　3.6 Struts 2其他标签详解　　　3.6.1 actionerror与actionmessage标签详解　　　3.6.2 fielderror标签详解　　　3.6.3 tree与treenode标签详解　　3.7 Struts 2全力支持AJAX　　　3.7.1 Struts 2中原始AJAX技术应用　　　3.7.2 基于DWR的AJAX实现　　　3.7.3 基于DWR的AJAX表单验证　　　3.7.4 基于JSON插件的AJAX实现　　3.8 小结　第4章 ORM中间件名流Hibernate 3接管持久层　　4.1 ORM简介　　　4.1.1 持久化与持久层　　　4.1.2 JDBC劣势　　　4.1.3 实体域模型与关系数据模型　　　4.1.4 ORM中间件　　4.2 Hibernate简介　　　4.2.1 Hibernate体系结构　　　4.2.2 Hibernate API简介　　　4.2.3 配置Hibernate　　　4.2.4 Hibernate的映射配置文件　　　4.2.5 体验Hibernate（会员管理）　　4.3 Hibernate的映射机制　　　4.3.1 Hibernate的基本映射数据类型　　　4.3.2 Hibernate的主键映射　　　4.3.3 Hibernate的实体映射　　　4.3.4 映射一对一关联关系　　　4.3.5 映射多对一单向关联关系　　　4.3.6 映射一对多双向关联关系　　　4.3.7 映射一对多双向自身关联关系　　　4.3.8 映射多对多单向关联关系　　　4.3.9 映射多对多双向关联关系　　　4.3.10 映射组成关系　　　4.3.11 映射继承关系　　　4.3.12 Hibernate的集合映射　　4.4 小结　第5章 Hibernate 3持久化技术实践与性能优化　　5.1 操作持久化对象的常用方法介绍　　　5.1.1 使用Session的beginTransaction()方法　　　5.1.2 使用Session的close()方法　　　5.1.3 使用Session的connection()方法　　　5.1.4 使用Session的delete()方法　　　5.1.5 使用Session的get()方法　　　5.1.6 使用Session的load()方法　　　5.1.7 使用Session的save()方法　　　5.1.8 使用Session的update()方法　　　5.1.9 使用Session的saveOrUpdate()方法　　　5.1.10 使用Hibernate的isInitialized()与initialize()方法　　　5.1.11 持久化对象间的级联操作　　5.2 Hibernate的检索策略　　　5.2.1 立即检索　　　5.2.2 延迟检索　　　5.2.3 迫切左外连接检索　　5.3 HQL查询方式　　　5.3.1 基本查询　　　5.3.2 条件查询　　　5.3.3 分页查询　　　5.3.4 连接查询　　　5.3.5 子查询　　　5.3.6 动态实例化查询结果　　5.4 QBC查询方式　　　5.4.1 基本查询　　　5.4.2 QBE查询　　　5.4.3 分页查询　　　5.4.4 复合查询　　　5.4.5 离线查询　　5.5 本地SQL查询　　5.6 Hibernate的批量处理　　　5.6.1 批量插入　　　5.6.2 批量更新　　　5.6.3 批量删除　　5.7 Hibernate的事务管理　　　5.7.1 事务边界声明　　　5.7.2 并发控制　　　5.7.3 悲观锁　　　5.7.4 乐观锁　　5.8 Hibernate的缓存机制　　　5.8.1 Hibernate的缓存分类　　　5.8.2 Hibernate的缓存范围　　　5.8.3 Hibernate的缓存管理　　　5.8.4 Hibernate二级缓存的并发访问策略　　　5.8.5 Hibernate的二级缓存配置　　5.9 Hibernate应用的性能优化　　5.10 多数据源的应用　　5.11 JDBC的应用　　5.12 Hibernate调用存储过程　　5.13 XML数据持久化　　5.14 小结　第6章 充分利用Spring 2.5的IoC利器统管Bean世界　　6.1 Java程序员的春天厚礼—Spring 2.5　　　6.1.1 爱上Spring 2.5的十大理由　　　6.1.2 一睹Spring 2.5芳容　　　6.1.3 Spring 2.5拿手戏——控制反转与依赖注入　　　6.1.4 何为“面向切面编程AOP”　　　6.1.5 Spring 2.5圣经——面向接口编程　　　6.1.6 开始Spring 2.5旅程—Hello World　　6.2 Spring 2.5核心技术　　　6.2.1 Bean工厂之BeanFactory介绍　　　6.2.2 实用的Bean工厂ApplicationContext　　　6.2.3 Spring 2.5配置文件详解　　　6.2.4 Bean的作用域与生命周期　　　6.2.5 基于XML方式的Bean装配　　　6.2.6 基于Annotation方式的Bean装配　　　6.2.7 基于XML方式的AOP实现　　　6.2.8 基于Annotation方式的AOP实现　　6.3 Spring 2.5事务管理机制　　　6.3.1 Spring 2.5的声明式事务管理　　　6.3.2 基于XML方式的事务管理配置　　　6.3.3 基于Annotation方式的事务管理配置　　6.4 “桃园三结义”——SSH 2组合开发框架始成　　　6.4.1 Spring 2.5集成ORM中间件Hibernate 3.2　　　6.4.2 Spring 2.5集成MVC框架Struts 2　　　6.4.3 SSH 2组合框架的基本开发步骤—ePortal启程　　6.5 小结第2篇 实践篇　第7章 SSH 2热身——构建新闻发布系统　　7.1 门户网站新闻资讯基本分类　　7.2 新闻发布系统需求分析　　7.3 新闻发布系统功能设计　　7.4 新闻栏目后台管理　　　7.4.1 展示层JSP 2+Struts 2 标签库实现　　　7.4.2 控制层Struts2实现　　　7.4.3 持久层Hibernate3实现　　　7.4.4 Spring2接管业务逻辑层　　7.5 新闻内容后台管理　　　7.5.1 展示层JSP2+Struts2标签库实现　　　7.5.2 控制层Struts 2实现　　　7.5.3 持久层Hibernate3实现　　　7.5.4 Spring2接管业务逻辑层　　7.6 新闻资讯前台展现　　　7.6.1 文本新闻列表自定义标签类TextnewsTag　　　7.6.2 文本新闻列表分页控制自定义标签类TextnewsPageTag　　　7.6.3 图片新闻列表自定义标签类PicnewsTag　　　7.6.4 幻灯片新闻列表自定义标签类SlidenewsTag　　　7.6.5 Struts2与AJAX完全结合实现点击数加一　　7.7 基于HttpClient构建通用静态页面发布引擎　　　7.7.1 优秀的模拟浏览器HttpClient　　　7.7.2 构建通用静态页面发布引擎　　7.8 小结　第8章 通用新闻采集系统　　8.1 新闻采集系统需求分析　　8.2 新闻采集系统功能设计　　8.3 使用正则表达式与HTMLParser采集新闻内容　　　8.3.1 正则表达式基本知识　　　8.3.2 体验HTMLParser　　8.4 量身定制采集规则　　　8.4.1 展示层JSP 2+Struts 2标签库实现　　　8.4.2 控制层Struts 2实现　　　8.4.3 持久层Hibernate3实现　　　8.4.4 Spring 2接管业务逻辑层　　8.5 新闻采集功能实现　　8.6 小结　第9章 会员注册及会员管理系统　　9.1 会员管理系统需求分析　　9.2 会员管理系统功能设计　　9.3 会员级别后台管理　　　9.3.1 展示层JSP 2+Struts 2标签库实现　　　9.3.3 持久层Hibernate 3实现　　　9.3.4 Spring 2接管业务逻辑层　　9.4 注册会员后台管理　　　9.4.1 展示层JSP 2+Struts 2标签库实现　　　9.4.2 控制层Struts2实现　　　9.4.3 持久层Hibernate3实现　　　9.4.4 Spring 2接管业务逻辑层　　9.5 前台会员注册与登录　　9.6 小结　第10章 举一反三—实现商品分类管理　　10.1 商品管理系统需求分析　　10.2 商品管理系统功能设计　　10.3 商品类别后台管理　　　10.3.1 展示层JSP 2+Struts 2标签库实现　　　10.3.2 控制层Struts 2实现　　　10.3.3 持久层Hibernate3实现　　　10.3.4 Spring2接管业务逻辑层　　10.4 商品后台管理　　　10.4.1 展示层JSP 2+Struts 2标签库实现　　　10.4.2 控制层Struts 2实现　　　10.4.3 持久层Hibernate3实现　　　10.4.4 Spring 2接管业务逻辑层　　10.5 小结　第11章 温故知新—打造购物车与订单管理系统　　11.1 购物车与订单管理系统需求分析　　11.2 购物车及订单管理系统功能设计　　11.3 购物车自助管理　　　11.3.1 展示层JSP2+Struts2标签库实现　　　11.3.2 控制层Struts 2实现　　　11.3.3 持久层Hibernate3实现　　　11.3.4 Spring2接管业务逻辑层　　11.4 订单管理　　　11.4.1 展示层JSP 2+Struts 2标签库实现　　　11.4.2 控制层Struts 2实现　　　11.4.3 持久层Hibernate 3实现　　　11.4.4 Spring 2接管业务逻辑层　　11.5 小结　第12章 站务必备—系统用户管理与流量统计　　12.1 系统用户管理与流量统计需求分析　　12.2 系统用户管理与流量统计功能设计　　12.3 系统用户管理　　　12.3.1 展示层JSP 2+Struts 2标签库实现　　　12.3.2 控制层Struts 2实现　　　12.3.3 持久层Hibernate3实现　　　12.3.4 Spring2接管业务逻辑层　　12.4 流量统计分析　　　12.4.1 展示层JSP 2+Struts 2标签库实现　　　12.4.2 控制层Struts 2实现　　　12.4.3 持久层Hibernate3实现　　　12.4.4 Spring2接管业务逻辑层　　12.5 小结第3篇 部署篇　第13章 门户网站的搜索引擎优化—SEO技术　　13.1 为什么要进行搜索引擎优化　　　13.1.1 搜索引擎概述　　　13.1.2 网络营销催生SEO　　　13.1.3 SEO让你的网站脱颖而出　　13.2 搜索引擎到底喜欢什么样的网站　　　13.2.1 影响网站自然排名的主要因素　　　13.2.2 评价网站优劣的重要指标　　　13.2.3 正确看待SEO　　　13.2.4 远离Google的“沙盒”　　13.3 搜索引擎优化最佳实践　　　13.3.1 如何快速被搜索引擎收录　　　13.3.2 建立合理的网站结构与网站地图的应用　　　13.3.3 设计良好的网页结构　　　13.3.4 SEO基本功——关键词的选用　　　13.3.5 域名与空间对SEO的影响　　　13.3.6 搜索引擎偏爱“勤快”的网站　　13.4 搜索引擎优化辅助工具大本营　　　13.4.1 关键字选词辅助工具　　　13.4.2 关键字排名查询　　　13.4.3 关键字密度查询　　　13.4.4 热门关键字及搜索量查询　　　13.4.5 PR值查询　　　13.4.6 Alexa世界排名查询　　　13.4.7 搜索引擎收录页面数查询　　　13.4.8 搜索引擎反向链接查询　　　13.4.9 网站地图制作工具　　　13.4.10 百度指数查询　　　13.4.11 网页中无效链接检测工具　　13.5 小结　第14章 基于RHEL 5的服务器架构　　14.1 Red Hat Enterprise Linux 5安装与优化　　14.2 Linux客户端工具Secure SSH安装与应用　　14.3 RHEL5服务器维护的基本操作　　　14.3.1 系统维护相关的Linux命令　　　14.3.2 文件操作相关的Linux命令　　　14.3.3 网络维护相关的Linux命令　　　14.3.4 日志查看相关的Linux命令　　　14.3.5 用户管理相关的Linux命令　　　14.3.6 应用软件安装相关的Linux命令　　14.4 RHEL5中的JDK1.6安装　　14.5 RHEL5中的MySQL5安装与性能优化　　14.6 基于vsftpd搭建FTP服务器　　14.7 RHEL5中的Tomcat6安装与性能优化　　14.8 RHEL5中的Apache2.2安装与性能优化　　14.9 Apache2.2配置文件httpd.conf详解　　14.10 使用subversion搭建SVN版本控制服务器　　14.11 利用Red5搭建Flash流媒体服务器　　14.12 利用vncserver服务实现远程桌面　　14.13 小结　第15章 负载均衡与服务器集群　　15.1 Web服务器集群概述　　15.2 搭建Apache2.2+Tomcat6分工协作服务器架构　　15.3 构建Apache2.2负载均衡与Tomcat6集群　　15.4 搭建主从结构的MySQL数据库集群　　15.5 基于MySQL Proxy的负载均衡与读写分离　　15.6 小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型门户网站是这样炼成的！
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java EE企业应用实战
第1章  Java EE应用和开发环境	1
1.1  Java EE应用概述	2
1.1.1  Java EE应用的分层模型	2
1.1.2  Java EE应用的组件	3
1.1.3  Java EE应用的结构和优势	4
1.1.4  常用的Java EE服务器	4
1.2  轻量级Java EE应用相关技术	5
1.2.1  JSP、Servlet 3.0和JavaBean及替代技术	5
1.2.2  Struts 2.2及替代技术	5
1.2.3  Hibernate 3.6及替代技术	6
1.2.4  Spring 3.0及替代技术	6
1.3  Tomcat的下载和安装	7
1.3.1  安装Tomcat服务器	8
1.3.2  配置Tomcat的服务端口	9
1.3.3  进入控制台	10
1.3.4  部署Web应用	12
1.3.5  配置Tomcat的数据源	13
1.4  Eclipse的安装和使用	15
1.4.1  Eclipse的下载和安装	15
1.4.2  在线安装Eclipse插件	15
1.4.3  从本地压缩包安装插件	17
1.4.4  手动安装Eclipse插件	17
1.4.5  使用Eclipse开发Java EE应用	18
1.4.6  导入Eclipse项目	21
1.4.7  导入非Eclipse项目	22
1.5  Ant的安装和使用	23
1.5.1  Ant的下载和安装	23
1.5.2  使用Ant工具	24
1.5.3  定义生成文件	25
1.5.4  Ant的任务（task）	29
1.6  使用CVS进行协作开发	31
1.6.1  安装CVS服务器	32
1.6.2  配置CVS资源库	34
1.6.3  安装CVS客户端	35
1.6.4  发布项目到服务器	35
1.6.5  从服务器下载项目	37
1.6.6  同步（Update）本地文件	38
1.6.7  提交（Commit）修改	39
1.6.8  添加文件和目录	39
1.6.9  删除文件和目录	40
1.6.10  查看文件的版本变革	41
1.6.11  提取文件以前版本的内容	42
1.6.12  从以前版本重新开始	42
1.6.13  创建标签	43
1.6.14  创建分支	43
1.6.15  沿着分支开发	44
1.6.16  使用Eclipse作为CVS客户端	44
1.7  本章小结	46
第2章  JSP/Servlet及相关技术详解	47
2.1  Web应用和web.xml文件	48
2.1.1  构建Web应用	48
2.1.2  配置描述符web.xml	49
2.2  JSP的基本原理	50
2.3  JSP注释	54
2.4  JSP声明	54
2.5  输出JSP表达式	56
2.6  JSP脚本	56
2.7  JSP的3个编译指令	59
2.7.1  page指令	59
2.7.2  include指令	63
2.8  JSP的7个动作指令	63
2.8.1  forward指令	64
2.8.2  include指令	66
2.8.3  useBean、setProperty、getProperty指令	67
2.8.4  plugin指令	70
2.8.5  param指令	70
2.9  JSP脚本中的9个内置对象	70
2.9.1  application对象	72
2.9.2  config对象	77
2.9.3  exception对象	79
2.9.4  out对象	81
2.9.5  pageContext对象	82
2.9.6  request对象	84
2.9.7  response对象	91
2.9.8  session对象	95
2.10  Servlet介绍	97
2.10.1  Servlet的开发	97
2.10.2  Servlet的配置	99
2.10.3  JSP/Servlet的生命周期	101
2.10.4  load-on-startup Servlet	101
2.10.5  访问Servlet的配置参数	102
2.10.6  使用Servlet作为控制器	104
2.11  JSP 2的自定义标签	108
2.11.1  开发自定义标签类	109
2.11.2  建立TLD文件	109
2.11.3  使用标签库	110
2.11.4  带属性的标签	111
2.11.5  带标签体的标签	115
2.11.6  以页面片段作为属性的标签	117
2.11.7  动态属性的标签	118
2.12  Filter介绍	120
2.12.1  创建Filter类	120
2.12.2  配置Filter	121
2.12.3  使用URL Rewrite实现网站伪静态	125
2.13  Listener介绍	126
2.13.1  实现Listener类	127
2.13.2  配置Listener	128
2.13.3  使用ServletContextAttribute-Listener	129
2.13.4  使用ServletRequestListener和ServletRequestAttributeListener	130
2.13.5  使用HttpSessionListener和HttpSessionAttributeListener	131
2.14  JSP 2特性	136
2.14.1  配置JSP属性	136
2.14.2  表达式语言	138
2.14.3  Tag File支持	146
2.15  Servlet 3.0新特性	148
2.15.1  Servlet 3.0的Annotation	148
2.15.2  Servlet 3.0的Web模块支持	149
2.15.3  Servlet 3.0提供的异步处理	151
2.15.4  改进的Servlet API	154
2.16  本章小结	156
第3章  Struts 2的基本用法	157
3.1  MVC思想概述	158
3.1.1  传统Model 1和Model 2	158
3.1.2  MVC思想及其优势	159
3.2  Struts 2的下载和安装	160
3.2.1  为Web应用增加Struts 2支持	160
3.2.2  在Eclipse中使用Struts 2	161
3.2.3  增加登录处理	162
3.3  Struts 2的流程	165
3.3.1  Struts 2应用的开发步骤	165
3.3.2  Struts 2的流程	166
3.4  Struts 2的常规配置	167
3.4.1  常量配置	167
3.4.2  包含其他配置文件	173
3.5  实现Action	174
3.5.1  Action接口和ActionSupport基类	175
3.5.2  Action访问Servlet API	177
3.5.3  Action直接访问Servlet API	179
3.5.4  使用ServletActionContext访问Servlet API	181
3.6  配置Action	182
3.6.1  包和命名空间	182
3.6.2  Action的基本配置	185
3.6.3  使用Action的动态方法调用	186
3.6.4  指定method属性及使用通配符	188
3.6.5  配置默认Action	194
3.6.6  配置Action的默认处理类	194
3.7  配置处理结果	195
3.7.1  理解处理结果	195
3.7.2  配置结果	195
3.7.3  Struts 2支持的结果类型	197
3.7.4  plainText结果类型	198
3.7.5  redirect结果类型	200
3.7.6  redirectAction结果类型	201
3.7.7  动态结果	202
3.7.8  Action属性值决定物理视图资源	202
3.7.9  全局结果	204
3.7.10  使用PreResultListener	205
3.8  配置Struts 2的异常处理	206
3.8.1  Struts 2的异常处理机制	207
3.8.2  声明式异常捕捉	208
3.8.3  输出异常信息	210
3.9  Convention插件与“约定”支持	211
3.9.1  Action的搜索和映射约定	211
3.9.2  按约定映射Result	214
3.9.3  Action链的约定	216
3.9.4  自动重加载映射	218
3.9.5  Convention插件的相关常量	218
3.9.6  Convention插件相关Annotation	219
3.10  使用Struts 2的国际化	219
3.10.1  Struts 2中加载全局资源文件	219
3.10.2  访问国际化消息	220
3.10.3  输出带占位符的国际化消息	222
3.10.4  加载资源文件的方式	224
3.10.5  加载资源文件的顺序	228
3.11  使用Struts 2的标签库	228
3.11.1  Struts 2标签库概述	228
3.11.2  使用Struts 2标签	229
3.11.3  Struts 2的OGNL表达式语言	230
3.11.4  OGNL中的集合操作	232
3.11.5  访问静态成员	233
3.11.6  Lambda（）表达式	234
3.11.7  控制标签	234
3.11.8  数据标签	244
3.11.9  主题和模板	254
3.11.10  自定义主题	256
3.11.11  表单标签	257
3.11.12  非表单标签	270
3.12  本章小结	273
第4章  深入使用Struts 2	274
4.1  详解Struts 2的类型转换	275
4.1.1  Struts 2内建的类型转换器	276
4.1.2  基于OGNL的类型转换	276
4.2.3  指定集合元素的类型	279
4.1.4  自定义类型转换器	280
4.1.5  注册类型转换器	283
4.1.6  基于Struts 2的自定义类型转换器	284
4.1.7  处理Set集合	285
4.1.8  类型转换中的错误处理	288
4.2  使用Struts 2的输入校验	293
4.2.1  编写校验规则文件	294
4.2.2  国际化提示信息	296
4.2.3  使用客户端校验	298
4.2.4  字段校验器配置风格	300
4.2.5  非字段校验器配置风格	301
4.2.6  短路校验器	302
4.2.7  校验文件的搜索规则	304
4.2.8  校验顺序和短路	305
4.2.9  内建校验器	306
4.2.10  基于Annotation的输入校验	316
4.2.11  手动完成输入校验	318
4.3  使用Struts 2控制文件上传	322
4.3.1  Struts 2的文件上传	322
4.3.2  实现文件上传的Action	322
4.3.3  配置文件上传的Action	325
4.3.4  手动实现文件过滤	326
4.3.5  拦截器实现文件过滤	328
4.3.6  输出错误提示	329
4.3.7  文件上传的常量配置	330
4.4  使用Struts 2控制文件下载	330
4.4.1  实现文件下载的Action	330
4.4.2  配置Action	332
4.4.3  下载前的授权控制	332
4.5  详解Struts 2的拦截器机制	334
4.5.1  拦截器在Struts 2中的作用	334
4.5.2  Struts 2内建的拦截器	334
4.5.3  配置拦截器	336
4.5.4  使用拦截器	338
4.5.5  配置默认拦截器	338
4.5.6  实现拦截器类	340
4.5.7  使用拦截器	342
4.5.8  拦截方法的拦截器	343
4.5.9  拦截器的执行顺序	345
4.5.10  拦截结果的监听器	347
4.5.11  覆盖拦截器栈里特定拦截器的参数	348
4.5.12  使用拦截器完成权限控制	349
4.6  使用Struts 2的Ajax支持	351
4.6.1  使用stream类型的Result实现Ajax	352
4.6.2  JSON的基本知识	354
4.6.3  实现Action逻辑	356
4.6.4  JSON插件与json类型的Result	357
4.6.5  实现JSP页面	359
4.7  本章小结	361
第5章  Hibernate的基本用法	362
5.1  ORM和Hibernate	363
5.1.1  对象/关系数据库映射（ORM）	363
5.1.2  基本映射方式	364
5.1.3  流行的ORM框架简介	365
5.1.4  Hibernate概述	366
5.2  Hibernate入门	366
5.2.1  Hibernate下载和安装	366
5.2.2  Hibernate的数据库操作	367
5.2.3  在Eclipse中使用Hibernate	371
5.3  Hibernate的体系结构	376
5.4  深入Hibernate的配置文件	377
5.4.1  创建Configuration对象	377
5.4.2  hibernate.properties文件与hibernate.cfg.xml文件	380
5.4.3  JDBC连接属性	380
5.4.4  数据库方言	381
5.4.5  JNDI数据源的连接属性	382
5.4.6  Hibernate事务属性	382
5.4.7  二级缓存相关属性	383
5.4.8  外连接抓取属性	383
5.4.9  其他常用的配置属性	383
5.5  深入理解持久化对象	384
5.5.1  持久化类的要求	384
5.5.2  持久化对象的状态	385
5.5.3  改变持久化对象状态的方法	386
5.6  深入Hibernate的映射文件	389
5.6.1  映射文件结构	389
5.6.2  映射主键	392
5.6.3  映射普通属性	393
5.6.4  映射集合属性	398
5.6.5  集合属性的性能分析	407
5.6.6  有序集合映射	409
5.6.7  映射数据库对象	411
5.7  映射组件属性	414
5.7.1  组件属性为集合	416
5.7.2  集合属性的元素为组件	418
5.7.3  组件作为Map的索引	420
5.7.4  组件作为复合主键	422
5.7.5  多列作为联合主键	425
5.8  使用JPA Annotation标注实体	426
5.8.1  增加JPA Annotation支持	426
5.8.2  Annotation？还是XML映射文件	429
5.9  本章小结	429
第6章  深入使用Hibernate	430
6.1  Hibernate的关联映射	431
6.1.1  单向N－1关联	431
6.1.2  单向1－1关联	436
6.1.3  单向1－N关联	439
6.1.4  单向N－N关联	443
6.1.5  双向1－N关联	443
6.1.6  双向N－N关联	448
6.1.7  双向1－1关联	450
6.1.8  组件属性包含的关联实体	453
6.1.9  基于复合主键的关联关系	456
6.1.10  复合主键的成员属性为关联实体	458
6.1.11  持久化的传播性	461
6.2  继承映射	462
6.2.1  采用subclass元素的继承映射	466
6.2.2  采用joined-subclass元素的继承映射	467
6.2.3  采用union-subclass元素的继承映射	470
6.3  Hibernate的批量处理	472
6.3.1  批量插入	473
6.3.2  批量更新	474
6.3.3  DML风格的批量更新/删除	474
6.4  使用HQL查询	476
6.4.1  HQL查询	476
6.4.2  HQL查询的from子句	478
6.4.3  关联和连接	478
6.4.4  HQL查询的select子句	481
6.4.5  HQL查询的聚集函数	482
6.4.6  多态查询	483
6.4.7  HQL查询的where子句	483
6.4.8  表达式	484
6.4.9  order by子句	486
6.4.10  group by子句	486
6.4.11  子查询	487
6.4.12  命名查询	488
6.5  条件查询	488
6.5.1  关联和动态关联	491
6.5.2  投影、聚合和分组	492
6.5.3  离线查询和子查询	495
6.6  SQL查询	496
6.6.1  标量查询	496
6.6.2  实体查询	498
6.6.3  处理关联和继承	500
6.6.4  命名SQL查询	501
6.6.5  调用存储过程	502
6.6.6  使用定制SQL	503
6.7  数据过滤	505
6.8  事务控制	508
6.8.1  事务的概念	508
6.8.2  Session与事务	509
6.8.3  上下文相关的Session	511
6.9  二级缓存和查询缓存	511
6.9.1  开启二级缓存	512
6.9.2  管理缓存和统计缓存	515
6.9.3  使用查询缓存	516
6.10  事件机制	518
6.10.1  拦截器	519
6.10.2  事件系统	521
6.11  本章小结	525
第7章  Spring的基本用法	526
7.1  Spring简介和Spring 3.0的变化	527
7.1.1  Spring简介	527
7.1.2  Spring 3.0的变化	528
7.2  Spring的下载和安装	528
7.2.1  在Java SE应用中使用Spring	528
7.2.2  在Web应用中使用Spring	529
7.2.3  在Eclipse中开发Spring应用	530
7.3  Spring的核心机制：依赖注入	533
7.3.1  理解依赖注入	533
7.3.2  设值注入	534
7.3.3  构造注入	538
7.3.4  两种注入方式的对比	539
7.4  使用Spring容器	539
7.4.1  Spring容器	540
7.4.2  使用ApplicationContext	541
7.4.3  ApplicationContext的国际化支持	542
7.4.4  ApplicationContext的事件机制	544
7.4.5  让Bean获取Spring容器	546
7.5  Spring容器中的Bean	548
7.5.1  Bean的基本定义	548
7.5.2  容器中Bean的作用域	551
7.5.3  配置依赖	553
7.5.4  设置普通属性值	555
7.5.5  配置合作者Bean	557
7.5.6  使用自动装配注入合作者Bean	557
7.5.7  注入嵌套Bean	560
7.5.8  注入集合值	561
7.5.9  组合属性名称	565
7.5.10  Spring的Bean和JavaBean	566
7.6  Spring 3.0提供的Java配置管理	567
7.7  Bean实例的创建方式及依赖配置	570
7.7.1  使用构造器创建Bean实例	570
7.7.2  使用静态工厂方法创建Bean	572
7.7.3  调用实例工厂方法创建Bean	575
7.8  深入理解容器中的Bean	577
7.8.1  使用抽象Bean	577
7.8.2  使用子Bean	578
7.8.3  Bean继承与Java继承的区别	579
7.8.4  容器中的工厂Bean	580
7.8.5  获得Bean本身的id	582
7.8.6  强制初始化Bean	583
7.9  容器中Bean的生命周期	583
7.9.1  依赖关系注入之后的行为	584
7.9.2  Bean销毁之前的行为	585
7.9.3  协调作用域不同步的Bean	588
7.10  深入理解依赖关系配置	591
7.10.1  注入其他Bean的属性值	592
7.10.2  注入其他Bean的Field值	594
7.10.3  注入其他Bean的方法返回值	595
7.11  基于XML Schema的简化配置方式	598
7.11.1  使用p名称空间配置属性	599
7.11.2  使用util Schema	600
7.12  Spring 3.0提供的表达式语言（SpEL）	602
7.12.1  使用Expression接口进行表达式求值	603
7.12.2  Bean定义中的表达式语言支持	604
7.12.3  SpEL语法详述	606
7.13  本章小结	611
第8章  深入使用Spring	612
8.1  两种后处理器	613
8.1.1  Bean后处理器	613
8.1.2  Bean后处理器的用处	617
8.1.3  容器后处理器	617
8.1.4  属性占位符配置器	619
8.1.5  重写占位符配置器	620
8.2  Spring的“零配置”支持	621
8.2.1  搜索Bean类	621
8.2.2  指定Bean的作用域	624
8.2.3  使用@Resource配置依赖	625
8.2.4  使用@PostConstruct和@PreDestroy定制生命周期行为	626
8.2.5  Spring 3.0新增的Annotation	626
8.2.6  自动装配和精确装配	627
8.3  资源访问	629
8.3.1  Resource实现类	630
8.3.2  ResourceLoader接口和ResourceLoaderAware接口	635
8.3.3  使用Resource作为属性	638
8.3.4  在ApplicationContext中使用资源	639
8.4  Spring的AOP	643
8.4.1  为什么需要AOP	643
8.4.2  使用AspectJ实现AOP	644
8.4.3  AOP的基本概念	649
8.4.4  Spring的AOP支持	650
8.4.5  基于Annotation的“零配置”方式	651
8.4.6  基于XML配置文件的管理方式	666
8.5  Spring的事务	672
8.5.1  Spring支持的事务策略	673
8.5.2  使用TransactionProxyFactoryBean创建事务代理	678
8.5.3  Spring 2.X的事务配置策略	681
8.5.4  使用@Transactional	685
8.6  Spring整合Struts 2	686
8.6.1  启动Spring容器	686
8.6.2  MVC框架与Spring整合的思考	688
8.6.3  让Spring管理控制器	689
8.6.4  使用自动装配	692
8.7  Spring整合Hibernate	695
8.7.1  Spring提供的DAO支持	695
8.7.2  管理Hibernate的SessionFactory	696
8.7.3  使用HibernateTemplate	697
8.7.4  使用HibernateCallback	701
8.7.5  实现DAO组件	703
8.7.6  使用IoC容器组装各种组件	705
8.7.7  使用声明式事务	707
8.8  Spring整合JPA	708
8.8.1  管理EntityManager	709
8.8.2  使用JpaTemplate	711
8.8.3  使用JpaCallback	713
8.8.4  借助JpaDaoSupport实现DAO组件	714
8.8.5  使用声明式事务	714
8.9  本章小结	715
第9章  企业应用开发的思考和策略	716
9.1  企业应用开发面临的挑战	717
9.1.1  可扩展性、可伸缩性	717
9.1.2  快捷、可控的开发	718
9.1.3  稳定性、高效性	719
9.1.4  花费最小化，利益最大化	719
9.2  如何面对挑战	719
9.2.1  使用建模工具	719
9.2.2  利用优秀的框架	720
9.2.3  选择性地扩展	722
9.2.4  使用代码生成器	722
9.3  常见设计模式精讲	722
9.3.1  单例模式	723
9.3.2  简单工厂	724
9.3.3  工厂方法和抽象工厂	730
9.3.4  代理模式	733
9.3.5  命令模式	739
9.3.6  策略模式	741
9.3.7  门面模式	743
9.3.8  桥接模式	746
9.3.9  观察者模式	750
9.4  常见的架构设计策略	753
9.4.1  贫血模型	753
9.4.2  领域对象模型	756
9.4.3  合并业务逻辑对象与DAO对象	758
9.4.4  合并业务逻辑对象和Domain Object	759
9.4.5  抛弃业务逻辑层	761
9.5  本章小结	762
第10章  简单工作流系统	763
10.1  项目背景及系统结构	764
10.1.1  应用背景	764
10.1.2  系统功能介绍	764
10.1.3  相关技术介绍	765
10.1.4  系统结构	766
10.1.5  系统的功能模块	766
10.2  Hibernate持久层	767
10.2.1  设计持久化实体	767
10.2.2  创建持久化实体类	768
10.2.3  映射持久化实体	772
10.3  实现DAO层	777
10.3.1  DAO组件的定义	778
10.3.2  实现DAO组件	783
10.3.3  部署DAO层	787
10.4  实现Service层	789
10.4.1  业务逻辑组件的设计	789
10.4.2  实现业务逻辑组件	789
10.4.3  事务管理	795
10.4.4  部署业务逻辑组件	795
10.5  实现任务的自动调度	797
10.5.1  使用Quartz	797
10.5.2  在Spring中使用Quartz	802
10.6  实现系统Web层	804
10.6.1  Struts 2和Spring的整合	804
10.6.2  控制器的处理顺序	805
10.6.3  员工登录	806
10.6.4  进入打卡	808
10.6.5  处理打卡	810
10.6.6  进入申请	811
10.6.7  提交申请	812
10.6.8  使用拦截器完成权限管理	814
10.7  本章小结	816
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java EE企业应用实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring+MyBatis企业应用实战
第1章　Java EE应用	1
1.1　Java EE应用概述	2
1.1.1　Java EE应用的分层模型	2
1.1.2　Java EE应用的组件	3
1.1.3　Java EE应用的结构和优势	4
1.2　轻量级Java EE应用相关技术	4
1.2.1　JSP、Servlet和JavaBean及替代技术	4
1.2.2　MyBatis3及替代技术	5
1.2.3　Spring4及替代技术	6
1.2.4　使用开源框架的好处	7
1.3　本章小结	7
第2章　Spring MVC简介	8
2.1　MVC思想概述	9
2.1.1　传统Model1和Model2	9
2.1.2　MVC思想及其优势	10
2.2　Struts2和Spring MVC	11
2.3　开发第一个Spring MVC应用	11
2.3.1　Spring的下载和安装	11
2.3.2　Spring MVC的DispatcherServlet	12
2.3.3　基于Controller接口的控制器	13
示例：第一个Spring MVC应用	13
示例：基于注解的控制器	17
2.4　详解DispatcherServlet	19
2.5　Spring MVC执行的流程	21
2.5.1　Spring MVC应用的开发步骤	22
2.5.2　Spring MVC执行的流程	23
2.6　本章小结	24
第3章　Spring MVC的常用注解	25
3.1　@Controller注解	26
示例：@Controller注解的使用	26
3.2　@RequestMapping注解	28
3.2.1　@RequestMapping注解	28
3.2.2　请求处理方法可出现的参数类型	30
3.2.3　请求处理方法可返回的类型	31
3.2.4　Model和ModelAndView	31
示例：Model和ModelMap的使用	32
示例：ModelAndView的使用	33
3.3　参数绑定注解	33
3.3.1　@RequestParam注解	33
示例：@RequestMapping和@RequestParam注解的使用	34
3.3.2　@PathVariable注解	38
3.3.3　@RequestHeader注解	38
3.3.4　@CookieValue注解	39
示例：@PathVariable、@RequestHeader和@CookieValue注解的使用	39
3.3.5　@SessionAttributes注解	41
示例：@SessionAttributes注解的使用	41
3.3.6　@ModelAttribute注解	42
示例：@ModelAttribute注解的使用	43
3.4　信息转换	49
3.4.1　HttpMessageConverter＜T＞接口	49
3.4.2　转换JSON数据	51
示例：接收JSON格式的数据	51
示例：自定义HttpMessageConverter接收JSON格式的数据	55
示例：返回JSON格式的数据	57
示例：自定义HttpMessageConverter返回JSON格式的数据	58
3.4.3　转换XML数据	59
示例：接收XML格式的数据	59
示例：返回XML格式的数据	61
3.5　本章小结	62
第4章　Spring MVC的标签库	64
4.1　表单标签库	65
4.1.1　form标签	65
4.1.2　input标签	66
示例：form和input标签的使用	66
4.1.3　password标签	68
4.1.4　hidden标签	69
4.1.5　textarea标签	69
4.1.6　checkbox标签	70
示例：checkbox标签的使用	70
4.1.7　checkboxes标签	71
示例：checkboxes标签的使用	72
4.1.8　radiobutton标签	76
示例：radiobutton标签的使用	76
4.1.9　radiobuttons标签	77
示例：radiobuttons标签的使用	77
4.1.10　select标签	79
4.1.11　option标签	79
4.1.12　options标签	79
示例：select、option和options标签的使用	80
4.1.13　errors标签	83
示例：errors标签的使用	84
4.2　本章小结	86
第5章　Spring MVC的国际化	87
5.1　Spring MVC国际化的相关知识	88
5.1.1　messageSource	88
5.1.2　localeResolver	88
5.1.3　message标签	89
5.2　AcceptHeaderLocaleResolver国际化	89
示例：基于浏览器请求的国际化实现	89
5.3　SessionLocaleResolver国际化	92
示例：基于HttpSession的国际化实现	93
5.4　CookieLocaleResolver国际化	95
示例：基于Cookie的国际化实现	95
5.5　本章小结	96
第6章　Spring MVC的数据转换、格式化和数据校验	97
6.1　数据绑定流程	98
6.2　数据转换	98
6.2.1　ConversionService	98
6.2.2　Spring支持的转换器	99
示例：使用ConversionService转换数据	100
示例：使用@InitBinder添加自定义编辑器转换数据	103
示例：使用WebBindingInitializer注册全局自定义编辑器转换数据	103
6.2.3 多种转换器的优先顺序	104
6.3　数据格式化	104
示例：使用Formatter格式化数据	105
示例：使用FormatterRegistrar注册Formatter	107
示例：使用AnnotationFormatterFactory＜A extends Annotation＞格式化数据	108
6.4　数据校验	110
6.4.1　Spring的Validation校验框架	111
示例：测试Spring的Validation校验	112
6.4.2　JSR 303校验	114
示例：测试JSR 303校验	115
6.5　本章小结	120
第7章　Spring MVC的文件上传和下载	121
7.1　文件上传	122
示例：Spring MVC的文件上传	122
示例：使用对象接收上传文件	124
7.2　文件下载	125
示例：Spring MVC的文件下载	125
7.3　拦截器	126
7.3.1　HandlerInterceptor接口	127
示例：拦截器实现用户权限验证	127
7.4　本章小结	131
第8章　MyBatis简介	132
8.1　ORM和MyBatis	133
8.1.1　对象/关系数据库映射（ORM）	133
8.1.2　基本映射方式	134
8.1.3　流行的ORM框架简介	135
8.1.4　MyBatis概述	135
8.2　MyBatis入门	136
8.2.1　MyBatis下载和安装	136
8.2.2　MyBatis的数据库操作	137
8.3　本章小结	142
第9章　MyBatis的基本用法	143
9.1　MyBatis的体系结构	144
9.1.1　SqlSessionFactory	144
9.1.2　SqlSession	144
9.2　深入MyBatis的配置文件	146
9.2.1　MyBatis的配置文件结构	147
9.2.2　properties属性	147
9.2.3　settings设置	148
9.2.4　typeAliases类型命名	150
9.2.5　typeHandlers类型处理器	151
9.2.6　objectFactory对象工厂	152
9.2.7　environments配置环境	152
9.2.8　mapper映射器	154
9.3　深入Mapper XML映射文件	155
9.3.1　select	155
9.3.2　insert、update和delete	157
9.3.3　sql	158
9.3.4　参数（Parameters）	159
示例：测试select、insert、update和delete操作	159
9.3.5　ResultMaps	163
示例：测试ResultMaps	163
9.4　本章小结	169
第10章　MyBatis的关联映射和动态SQL	170
10.1　MyBatis的关联映射	171
10.1.1　一对一	171
示例：OneToOneTest	171
10.1.2　一对多	174
示例：OneToManyTest	174
10.1.3　多对多	179
示例：ManyToManyTest	179
10.2　动态SQL	185
示例：DynamicSQLTest	185
10.2.1　if	186
10.2.2　choose（when、otherwise）	188
10.2.3　where	190
10.2.4　set	191
10.2.5　foreach	192
10.2.6　bind	193
10.3　本章小结	194
第11章　MyBatis的事务管理和缓存机制	195
11.1　MyBatis的事务管理	196
11.1.1　事务的概念	196
11.1.2　Transaction接口	196
11.1.3　事务的配置创建和使用	197
11.2　MyBatis的缓存机制	201
11.2.1　一级缓存（SqlSession级别）	201
示例OneLevelCacheTest	201
11.2.2　二级缓存（mapper级别）	204
示例：TwoLevelCacheTest	204
11.3　本章小结	207
第12章　MyBatis的注解配置	208
12.1　常用Annotation注解	209
12.2　Annotation注解的使用	209
示例：测试select、insert、update和delete操作	210
示例：AOneToOneTest	213
示例：AOneToManyTest	215
示例：AManyToManyTest	216
示例：ADynamicSQLTest	218
12.3　本章小结	224
第13章　Spring4整合MyBatis3	225
13.1　开发环境搭建	226
13.2　准备所需的jar包	226
13.3　准备数据库资源	226
13.4　完成配置文件	227
13.5　持久层功能实现	229
13.6　服务层功能实现	230
13.7　控制层功能实现	232
13.8　jsp页面	233
13.9　测试Spring4整合MyBatis3	234
13.10　本章小结	235
第14章　实战项目：人事管理系统	236
14.1　项目简介及系统结构	237
14.1.1　系统功能介绍	237
14.1.2　相关技术介绍	238
14.1.3　系统结构	238
14.1.4　系统的功能模块	239
14.2　数据表和持久化类	239
14.2.1　设计数据库表	239
14.2.2　设计持久化实体	241
14.2.3　创建持久化实体类	242
14.3　实现DAO持久层	248
14.3.1　公共常量类	249
14.3.2　定义DAO接口	249
14.3.3　部署DAO层	263
14.4　实现Service持久层	264
14.4.1　业务逻辑组件的设计	264
14.4.2　实现业务逻辑组件	264
14.4.3　事务管理	279
14.4.4　部署业务逻辑组件	279
14.5　实现Web层	280
14.5.1　控制器的处理顺序	280
14.5.2　用户管理	283
14.5.3　部门管理	287
14.5.4　职位管理	290
14.5.5　员工管理	292
14.5.6　公告管理	296
14.5.7　下载中心	299
14.6　本章小结	303
附录A　EL表达式和JSTL标签库	304
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring+MyBatis企业应用实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE设计模式
第1章　企业级java应用程序架构和设计
简介	1
1.1　分布式计算的发展历程	1
1.1.1　单层架构	2
1.1.2　两层架构	2
1.1.3　三层架构	2
1.1.4　多层架构	4
1.1.5　java ee架构	4
1.2　java ee应用程序设计	8
1.3　java ee设计模式目录	9
1.4　使用uml描述java ee架构和设计	10
1.4.1　类图	10
1.4.2　序列图	12
1.5　小结	13
第2章　使用spring框架简化企业级java
应用程序	14
2.1　什么是spring	14
2.2　为什么spring很重要	14
2.3　spring框架的组成部分	16
2.3.1　spring core	16
.2.3.2　spring aop	22
2.3.3　spring dao	23
2.3.4　spring orm	23
2.3.5　jee	23
2.3.6　web mvc	23
2.4　使用spring构建分层应用程序	23
2.4.1　表现层	24
2.4.2　业务层	25
2.4.3　集成层	25
2.5　spring java设计模式讲解模板	26
2.5.1　名称	26
2.5.2　问题描述	26
2.5.3　模式目的	26
2.5.4　解决方案	26
2.5.5　模式评价	26
2.6　小结	26
第3章　表现层设计模式	27
3.1　前端控制器	28
3.1.1　问题描述	28
3.1.2　模式目的	30
3.1.3　解决方案	30
3.1.4　模式评价	33
3.2　应用程序控制器	33
3.2.1　问题描述	33
3.2.2　模式目的	34
3.2.3　解决方案	34
3.2.4　模式评价	46
3.3　页面控制器	47
3.3.1　问题描述	47
3.3.2　模式目的	47
3.3.3　解决方案	47
3.3.4　模式评价	63
3.4　上下文对象模式	64
3.4.1　问题描述	64
3.4.2　模式目的	64
3.4.3　解决方案	64
3.4.4　模式评价	70
3.5　拦截过滤器模式	70
3.5.1　问题描述	70
3.5.2　模式目的	70
3.5.3　解决方案	71
3.5.4　模式评价	76
3.6　视图助手模式	76
3.6.1　问题描述	76
3.6.2　模式目的	76
3.6.3　解决方案	77
3.6.4　模式评价	84
3.7　组合视图模式	85
3.7.1　问题描述	85
3.7.2　模式目的	85
3.7.3　解决方案	85
3.7.4　模式评价	89
3.8　分发者视图模式	89
3.8.1　问题描述	89
3.8.2　模式目的	89
3.8.3　解决方案	90
3.8.4　模式评价	94
3.9　服务到工作者模式	94
3.9.1　问题描述	94
3.9.2　模式目的	94
3.9.3　解决方案	95
3.9.4　模式评价	95
3.10　小结	96
第4章　业务层设计模式	97
4.1　服务定位器模式	97
4.1.1　问题描述	97
4.1.2　模式目的	100
4.1.3　解决方案	100
4.1.4　模式评价	109
4.2　业务代理模式	109
4.2.1　问题描述	109
4.2.2　模式目的	109
4.2.3　解决方案	109
4.2.4　模式评价	111
4.3　会话外观模式	112
4.3.1　问题描述	112
4.3.2　模式目的	112
4.3.3　解决方案	112
4.3.4　模式评价	116
4.4　应用程序服务模式	117
4.4.1　问题描述	117
4.4.2　模式目的	117
4.4.3　解决方案	118
4.4.4　模式评价	120
4.5　业务接口模式	121
4.5.1　问题描述	121
4.5.2　模式目的	121
4.5.3　解决方案	121
4.5.4　模式评价	127
4.6　小结	127
第5章　集成层设计模式	128
5.1　数据访问对象模式	128
5.1.1　问题描述	128
5.1.2　模式目的	131
5.1.3　解决方案	131
5.1.4　模式评价	140
5.2　过程访问对象模式	140
5.2.1　问题描述	140
5.2.2　模式目的	140
5.2.3　解决方案	140
5.2.4　模式评价	143
5.3　服务触发器模式	143
5.3.1　问题描述	143
5.3.2　模式目的	144
5.3.3　解决方案	144
5.3.4　模式评价	151
5.4　web服务代理模式	151
5.4.1　问题描述	151
5.4.2　模式目的	151
5.4.3　解决方案	152
5.4.4　模式评价	161
5.5　小结	161
第6章　横切设计模式	162
6.1　验证和授权实施者模式	163
6.1.1　问题描述	163
6.1.2　模式目的	164
6.1.3　解决方案	164
6.1.4　模式评价	182
6.2　审核拦截器模式	182
6.2.1　问题描述	182
6.2.2　模式目的	182
6.2.3　解决方案	183
6.2.4　模式评价	189
6.3　域服务所有者事务模式	189
6.3.1　问题描述	189
6.3.2　模式目的	189
6.3.3　解决方案	190
6.3.4　模式评价	197
6.4　小结	197
第7章　案例研究：构建订单管理系统	198
7.1　需求	198
7.1.1　用户故事卡：用户登录	199
7.1.2　用户故事卡：查询服务	199
7.1.3　用户故事卡：保存订单	199
7.2　迭代规划	199
7.3　架构	200
7.3.1　表现层	200
7.3.2　业务层	201
7.3.3　集成层	202
7.4　设计	202
7.5　安全机制	203
7.5.1　问题描述	203
7.5.2　模式目的	203
7.5.3　解决方案	203
7.6　jsp	203
7.6.1　问题描述	203
7.6.2　模式目的	204
7.6.3　解决方案	204
7.7　页面控制器	204
7.7.1　问题描述	204
7.7.2　模式目的	204
7.7.3　解决方案	204
7.8　开发	205
7.8.1　创建工作区	206
7.8.2　创建项目	207
7.8.3　添加依赖关系	208
7.8.4　构建项目	210
7.8.5　部署项目	219
7.9　小结	227
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构探险――从零开始写Java Web框架
第1章 从一个简单的Web应用 1
正所谓“工欲善其事，必先利其器”，在正式开始设计并开发我们的轻量级Java Web框架之前，有必要首先掌握以下技能：
使用IDEA搭建并开发Java项目；
使用Maven自动化构建Java项目；
使用Git管理项目源代码。
1.1 使用IDEA创建Maven项目 3
1.1.1 创建IDEA项目 3
1.1.2 调整Maven配置 3
1.2 搭建Web项目框架 5
1.2.1 转为Java Web项目 5
1.2.2 添加Java Web的Maven依赖 6
1.3 编写一个简单的Web应用 10
1.3.1 编写 Servlet类 10
1.3.2 编写JSP页面 11
1.4 让Web应用跑起来 12
1.4.1 在IDEA中配置Tomcat 12
1.4.2 使用Tomcat的Maven插件 13
1.4.3 以Debug方式运行程序 13
1.5 将代码放入Git仓库中 14
1.5.1 编写.gitignore文件 14
1.5.2 提交本地 Git 仓库 15
1.5.3 推送远程Git仓库 15
1.5.4 总结 16
第2章 为Web应用添加业务功能 17
我们将在这个应用的基础上增加一些业务功能，您将学会更多有关项目实战的技能，具体包括：
如何进行需求分析；
如何进行系统设计；
如何编写应用程序。
2.1 需求分析与系统设计 19
2.1.1 需求分析 19
2.1.2 系统设计 19
2.2 动手开发Web应用 21
2.2.1 创建数据库 22
2.2.2 准备开发环境 22
2.2.3 编写模型层 23
2.2.4 编写控制器层 25
2.2.5 编写服务层 27
2.2.6 编写单元测试 28
2.2.7 编写视图层 31
2.3 细节完善与代码优化 31
2.3.1 完善服务层 32
2.3.2 完善控制器层 59
2.3.3 完善视图层 60
2.4 总结 65
第3章 搭建轻量级Java Web框架 66
我们需要这样的框架，它足够轻量级、足够灵巧，不妨给它取一个优雅的名字——Smart Framework，本章我们就一起来实现这个框架。
您将通过本章的学习，掌握如下技能：
如何快速搭建开发框架；
如何加载并读取配置文件；
如何实现一个简单的IOC容器；
如何加载指定的类；
如何初始化框架。
3.1 确定目标 68
3.2 搭建开发环境 70
3.2.1 创建框架项目 70
3.2.2 创建示例项目 73
3.3 定义框架配置项 74
3.4 加载配置项 75
3.5 开发一个类加载器 78
3.6 实现Bean容器 87
3.7 实现依赖注入功能 90
3.8 加载Controller 93
3.9 初始化框架 97
3.10 请求转发器 98
3.11 总结 109
第4章 使框架具备AOP特性 110
在本章中，读者将学到大量有用的技术，具体包括：
如何理解并使用代理技术；
如何使用Spring提供的AOP技术；
如何使用动态代理技术实现AOP框架；
如何理解并使用ThreadLocal技术；
如何理解数据库事务管理机制；
如何使用AOP框架实现事务控制。
4.1 代理技术简介 112
4.1.1 什么是代理 112
4.1.2 JDK动态代理 114
4.1.3 CGlib动态代理 116
4.2 AOP技术简介 118
4.2.1 什么是AOP 118
4.2.2 写死代码 119
4.2.3 静态代理 120
4.2.4 JDK动态代理 121
4.2.5 CGLib动态代理 122
4.2.6 Spring AOP 124
4.2.7 Spring + AspectJ 136
4.3 开发AOP框架 142
4.3.1 定义切面注解 142
4.3.2 搭建代理框架 143
4.3.3 加载AOP框架 150
4.4 ThreadLocal简介 158
4.4.1 什么是ThreadLocal 158
4.4.2 自己实现ThreadLocal 161
4.4.3 ThreadLocal使用案例 163
4.5 事务管理简介 172
4.5.1 什么是事务 172
4.5.2 事务所面临的问题 173
4.5.3 Spring的事务传播行为 175
4.6 实现事务控制特性 178
4.6.1 定义事务注解 178
4.6.2 提供事务相关操作 181
4.6.3 编写事务代理切面类 182
4.6.4 在框架中添加事务代理机制 184
4.7 总结 185
第5章 框架优化与功能扩展 186
本章将对现有框架进行优化，并提供一些扩展功能。通过本章的学习，读者可以了解到：
如何优化Action参数；
如何实现文件上传功能；
如何与Servlet API完全解耦；
如何实现安全控制框架；
如何实现Web服务框架。
5.1 优化Action参数 188
5.1.1 明确Action参数优化目标 188
5.1.2 动手优化Action参数使用方式 188
5.2 提供文件上传特性 191
5.2.1 确定文件上传使用场景 191
5.2.2 实现文件上传功能 194
5.3 与Servlet API解耦 214
5.3.1 为何需要与Servlet API解耦 214
5.3.2 与Servlet API解耦的实现过程 215
5.4 安全控制框架——Shiro 219
5.4.1 什么是Shiro 219
5.4.2 Hello Shiro 220
5.4.3 在Web开发中使用Shiro 224
5.5 提供安全控制特性 230
5.5.1 为什么需要安全控制 230
5.5.2 如何使用安全控制框架 231
5.5.3 如何实现安全控制框架 242
5.6 Web服务框架——CXF 261
5.6.1 什么是CXF 261
5.6.2 使用CXF开发SOAP服务 262
5.6.3 基于SOAP的安全控制 278
5.6.4 使用CXF开发REST服务 291
5.7 提供Web服务特性 308
5.8 总结 329
附录A Maven快速入门 330
附录B 将构件发布到Maven中央仓库 342
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构探险――从零开始写Java Web框架
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot编程思想（核心篇）
第1部分  总览Spring Boot
第1章  初览Spring Boot  2
1.1  Spring Framework时代  2
1.2  Spring Boot简介  3
1.3  Spring Boot的特性  5
1.4  准备运行环境  5
1.4.1  装配JDK 8  5
1.4.2  装配Maven  6
1.4.3  装配IDE（集成开发环境）  8
第2章  理解独立的Spring应用  9
2.1  创建Spring Boot应用  10
2.1.1  命令行方式创建Spring Boot应用  11
2.1.2  图形化界面创建Spring Boot应用  21
2.1.3  创建Spring Boot应用可执行JAR  29
2.2  运行Spring Boot应用  31
2.2.1  执行Spring Boot应用可执行JAR  32
2.2.2  Spring Boot应用可执行JAR资源结构  32
2.2.3  FAT JAR和WAR执行模块——spring-boot-loader  36
2.2.4  JarLauncher的实现原理  40
第3章  理解固化的Maven依赖  58
3.1  spring-boot-starter-parent与spring-boot-dependencies简介  58
3.2  理解spring-boot-starter-parent与spring-boot- dependencies  61
第4章  理解嵌入式Web容器  70
4.1  嵌入式Servlet Web容器  71
4.1.1  Tomcat作为嵌入式Servlet Web容器  72
4.1.2  Jetty作为嵌入式Servlet Web容器  77
4.1.3  Undertow作为嵌入式Servlet Web容器  80
4.2  嵌入式Reactive Web容器  82
4.2.1  UndertowServletWebServer作为嵌入式Reactive Web容器  82
4.2.2  UndertowWebServer作为嵌入式Reactive Web容器  84
4.2.3  WebServerInitializedEvent  91
4.2.4  Jetty作为嵌入式Reactive Web容器  93
4.2.5  Tomcat作为嵌入式Reactive Web容器  94
第5章  理解自动装配  96
5.1  理解@SpringBootApplication注解语义  97
5.2  @SpringBootApplication属性别名  103
5.3  @SpringBootApplication标注非引导类  107
5.4  @EnableAutoConfiguration激活自动装配  108
5.5  @SpringBootApplication“继承”@Configuration CGLIB提升特性  110
5.6  理解自动配置机制  112
5.7  创建自动配置类  116
第6章  理解Production- Ready特性  119
6.1  理解Production-Ready一般性定义  120
6.2  理解Spring Boot Actuator  123
6.3  Spring Boot Actuator Endpoints  124
6.4  理解“外部化配置  129
6.5  理解“规约大于配置”  132
6.6  小马哥有话说  134
6.6.1  Spring Boot作为微服务中间件  134
6.6.2  Spring Boot作为Spring Cloud基础设施  135
6.7  下一站：走向自动装配  135
第2部分  走向自动装配
第7章  走向注解驱动编程（Annotation-Driven）  138
7.1  注解驱动发展史  138
7.1.1  注解驱动启蒙时代：Spring Framework 1.x  138
7.1.2  注解驱动过渡时代：Spring Framework 2.x  139
7.1.3  注解驱动黄金时代：Spring Framework 3.x  142
7.1.4  注解驱动完善时代：Spring Framework 4.x  146
7.1.5  注解驱动当下时代：Spring Framework 5.x  151
7.2  Spring核心注解场景分类  152
7.3  Spring注解编程模型  154
7.3.1  元注解（Meta-Annotations）  154
7.3.2  Spring模式注解（Stereotype Annotations）  155
7.3.3  Spring组合注解（Composed Annotations）  187
7.3.4  Spring注解属性别名和覆盖（Attribute Aliases and Overrides）  195
第8章  Spring注解驱动设计模式  225
8.1  Spring @Enable模块驱动  225
8.1.1  理解@Enable模块驱动  225
8.1.2  自定义@Enable模块驱动  226
8.1.3  @Enable模块驱动原理  236
8.2  Spring Web自动装配  250
8.2.1  理解Web自动装配  250
8.2.2  自定义Web自动装配  254
8.2.3  Web自动装配原理  258
8.3  Spring条件装配  270
8.3.1  理解配置条件装配  271
8.3.2  自定义配置条件装配  274
8.3.3  配置条件装配原理  277
第9章  Spring Boot自动装配  292
9.1  理解Spring Boot自动装配  295
9.1.1  理解@EnableAutoConfiguration  296
9.1.2  优雅地替换自动装配  298
9.1.3  失效自动装配  298
9.2  Spring Boot自动装配原理  299
9.2.1  @EnableAutoConfiguration读取候选装配组件  301
9.2.2  @EnableAutoConfiguration排除自动装配组件  305
9.2.3  @EnableAutoConfiguration过滤自动装配组件  307
9.2.4  @EnableAutoConfiguration自动装配事件  313
9.2.5  @EnableAutoConfiguration自动装配生命周期  317
9.2.6  @EnableAutoConfiguration排序自动装配组件  324
9.2.7  @EnableAutoConfiguration自动装配BasePackages  332
9.3  自定义Spring Boot自动装配  337
9.3.1  自动装配Class命名的潜规则  338
9.3.2  自动装配package命名的潜规则  338
9.3.3  自定义Spring Boot Starter  340
9.4  Spring Boot条件化自动装配  346
9.4.1  Class条件注解  347
9.4.2  Bean条件注解  358
9.4.3  属性条件注解  370
9.4.4  Resource条件注解  376
9.4.5  Web应用条件注解  391
9.4.6  Spring表达式条件注解  397
9.5  小马哥有话说  401
9.6  下一站：理解SpringApplication  402
第3部分  理解SpringApplication
第10章  SpringApplication初始化阶段  405
10.1  SpringApplication构造阶段  405
10.1.1  理解SpringApplication主配置类  406
10.1.2  SpringApplication的构造过程  410
10.1.3  推断Web应用类型  411
10.1.4  加载Spring应用上下文初始化器（ApplicationContextInitializer）  412
10.1.5  加载Spring应用事件监听器（ApplicationListener）  415
10.1.6  推断应用引导类  416
10.2  SpringApplication配置阶段  417
10.2.1  自定义SpringApplication  417
10.2.2  调整SpringApplication设置  417
10.2.3  增加SpringApplication配置源  420
10.2.4  调整Spring Boot外部化配置  423
第11章  SpringApplication运行阶段  425
11.1  SpringApplication准备阶段  425
11.1.1  理解SpringApplicationRunListeners  426
11.1.2  理解SpringApplicationRunListener  428
11.1.3  理解Spring Boot事件  431
11.1.4  理解Spring事件/监听机制  432
11.1.5  理解Spring Boot事件/监听机制  492
11.1.6  装配ApplicationArguments  509
11.1.7  准备ConfigurableEnvironment  512
11.1.8  创建Spring应用上下文（ConfigurableApplicationContext）  512
11.1.9  Spring应用上下文运行前准备  516
11.2  Spring应用上下文启动阶段  537
11.3  Spring应用上下文启动后阶段  539
11.3.1  afterRefresh方法签名的变化  540
11.3.2  afterRefresh方法语义的变化  541
11.3.3  Spring Boot事件ApplicationStartedEvent语义的变化  543
11.3.4  执行CommandLineRunner和ApplicationRunner  548
第12章  SpringApplication结束阶段  550
12.1  SpringApplication正常结束  550
12.2  SpringApplication异常结束  555
12.2.1  Spring Boot异常处理  556
12.2.2  错误分析报告器——FailureAnalysisReporter  562
12.2.3  自定义实现FailureAnalyzer和FailureAnalysisReporter  564
12.2.4  Spring Boot 2.0重构handleRunFailure和reportFailure方法  566
12.2.5  Spring Boot 2.0的SpringBootExceptionReporter接口  567
第13章  Spring Boot应用退出  571
13.1  Spring Boot应用正常退出  572
13.1.1  ExitCodeGenerator Bean生成退出码  572
13.1.2  ExitCodeGenerator Bean退出码使用场景  576
13.2  Spring Boot应用异常退出  580
13.2.1  ExitCodeGenerator异常使用场景  582
13.2.2  ExitCodeExceptionMapper Bean映射异常与退出码  587
13.2.3  退出码用于SpringApplication异常结束  589
13.3  小马哥有话说  594
13.4  下一站：运维篇  596
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot编程思想（核心篇）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring入门经典
目录
第1章 POJO编程模型、轻量级容器和控制反转 1
1.1 POJO编程模型 2
1.1.1 原来的EJB编程模型所存在的问题 2
1.1.2 POJO编程模型的优点 7
1.2 轻量级容器和控制反转 8
1.2.1 轻量级容器 8
1.2.2 控制反转 9
1.3 依赖注入 10
1.3.1 Setter注入 11
1.3.2 构造函数注入 11
1.3.3 Setter注入或构造函数注入 11
1.4 小结 12
1.5 习题 12
1.6 本章主要知识点 12
第2章 使用Spring进行依赖注入 15
2.1 Spring IoC容器 16
2.1.1 配置元数据 16
2.1.2 配置和使用容器 18
2.2 依赖注入 28
2.2.1 Setter注入 28
2.2.2 构造函数注入 29
2.2.3 循环依赖 32
2.2.4 依赖解析过程 33
2.2.5 重写Bean定义 34
2.2.6 使用depends-on特性 36
2.2.7 自动装配 37
2.2.8 Bean查找 41
2.3 Spring管理的Bean 42
2.3.1 命名Bean 42
2.3.2 Bean实例化方法 43
2.3.3 Bean作用域 46
2.3.4 延迟初始化 49
2.3.5 生命周期回调 50
2.3.6 Bean定义配置文件 52
2.3.7 环境 54
2.4 小结 57
2.5 习题 58
2.6 本章主要知识点 58
第3章 使用Spring MVC构建 Web应用程序 61
3.1 学习Spring MVC的功能和优点 62
3.2 使用Dispatcher Servlet机制 63
3.2.1 定义Servlet 64
3.2.2 访问Servlet上下文 65
3.3 创建第一个Spring MVC应用程序 65
3.4 使用注解配置Spring MVC 69
3.5 使用JSP处理表单 70
3.5.1 配置表单标签库 71
3.5.2 理解绑定的强大功能 72
3.5.3 使用表单 72
3.5.4 使用输入元素 73
3.5.5 输入日期 74
3.5.6 使用下拉框进行选择 74
3.5.7 使用单选按钮进行选择 75
3.5.8 使用复选框进行选择 76
3.5.9 添加标签 76
3.5.10 放置按钮 76
3.5.11 样式 76
3.6 使用注解的强大功能 81
3.6.1 @Controller 82
3.6.2 @RequestMapping 82
3.6.3 @ModeAttribute 82
3.6.4 @PathVariable 82
3.6.5 @ControllerAdvice 83
3.6.6 @InitBinder 83
3.6.7 @ExceptionHandler 83
3.7 验证用户输入 83
3.8 上传文件 88
3.9 处理异常 91
3.10 实现国际化(i18n) 92
3.11 使用主题 94
3.12 小结 97
3.13 习题 97
3.14 本章主要知识点 98
第4章 使用Spring进行JDBC数据访问 101
4.1 使用普通JDBC所带来的问题 102
4.2 引入Spring的JDBC支持 103
4.2.1 管理JDBC连接 103
4.2.2 配置和使用Spring的JDBC支持 109
4.3 使用Spring执行数据访问操作 112
4.3.1 执行查询 112
4.3.2 使用命名参数进行查询 115
4.3.3 使用In子句编写查询 116
4.3.4 在JdbcTemplate中使用PreparedStatements 117
4.3.5 插入、更新和删除记录 119
4.3.6 调用存储过程和存储函数 122
4.3.7 执行批处理操作 124
4.3.8 处理BLOB和CLOB对象 124
4.3.9 访问特定于供应商的 JDBC 方法 125
4.3.10 执行DDL操作 125
4.4 将JDBC操作模块化为Java对象 126
4.4.1 封装SQL查询执行 126
4.4.2 封装SQL DML操作 128
4.4.3 封装存储过程执行 129
4.5 异常处理和错误代码转换 130
4.5.1 常见的数据访问异常层次结构 130
4.5.2 SQLException的自动处理和转换 131
4.6 小结 131
4.7 习题 132
4.8 本章主要知识点 132
第5章 通过Spring使用JPA进行数据访问 135
5.1 概述ORM和JPA 136
5.1.1 范式不匹配 136
5.1.2 ORM框架的构建块 137
5.1.3 JPA所提供的功能 137
5.1.4 将对象模型映射到关系模型 137
5.1.5 将Java类型映射到SQL类型 142
5.1.6 配置和使用JPA 144
5.2 Spring的JPA支持 153
5.2.1 在Spring容器中设置JPA 153
5.2.2 基于纯JPA实现DAO 158
5.2.3 处理和转换异常 163
5.2.4 在Spring环境中进一步配置JPA 165
5.3 小结 168
5.4 习题 169
5.5 本章主要知识点 169
第6章 使用Spring管理事务 171
6.1 理解事务管理 172
6.2 Spring的事务抽象模型 175
6.2.1 本地事务与全局事务 177
6.2.2 PlatformTransaction Manager实现 178
6.2.3 Spring的抽象事务模型的优点 178
6.3 使用Spring进行声明式事务管理 179
6.3.1 将服务层与数据访问技术细节进行隔离 182
6.3.2 自定义默认的事务行为 184
6.3.3 在类级别使用@Transactional 185
6.3.4 理解事务传播规则 186
6.3.5 使用进行声明式事务管理 190
6.4 使用Spring进行编程式事务管理 193
6.5 在事务之前或者之后执行自定义逻辑 198
6.5.1 通知事务性操作 199
6.5.2 使用Transaction Synchronization执行事务后的逻辑 200
6.6 小结 201
6.7 习题 201
6.8 本章主要知识点 201
第7章 使用Spring进行测试驱动开发 203
7.1 配置和缓存ApplicationContext 204
7.1.1 在测试中使用基于XML和基于Java的上下文配置 204
7.1.2 使用Application ContextInitializer配置上下文 207
7.1.3 继承上下文配置 208
7.1.4 ApplicationContext缓存 210
7.2 注入测试夹具的依赖项 211
7.3 在测试中使用事务管理 213
7.4 测试Web应用程序 216
7.4.1 测试中的上下文层次结构 218
7.4.2 测试Request和Session作用域的Bean 219
7.4.3 测试Spring MVC项目 221
7.5 使用Mock对象以及其他用于测试的实用工具 225
7.5.1 Spring针对测试所提供的Mock对象 226
7.5.2 其他实用工具和测试注解 226
7.6 小结 227
7.7 习题 227
7.8 本章主要知识点 228
第8章 使用Spring进行面向方面编程 229
8.1 在Spring中开始使用AOP 230
8.2 熟悉通知的类型 235
8.2.1 Before 236
8.2.2 After Returning 236
8.2.3 After Throwing 236
8.2.4 After(Finally) 237
8.2.5 Around 238
8.3 定义切入点指示符 239
8.3.1 类型签名表达式 240
8.3.2 方法签名表达式 240
8.3.3 其他替代的切入点指示符 240
8.4 利用注解的强大功能 241
8.4.1 @Before 241
8.4.2 @PointCut 242
8.4.3 @After 243
8.4.4 @AfterReturning 243
8.4.5 @AfterThrowing 244
8.4.6 @Aspect 244
8.4.7 @Around 244
8.4.8 @DeclareParents 245
8.5 将ApectJ和Spring融合在一起 246
8.6 使用注解配置Spring AOP 250
8.7 小结 251
8.8 习题 251
8.9 本章主要知识点 252
第9章 Spring表达式语言 253
9.1 使用SpEL配置应用程序 254
9.2 创建一个分析器 256
9.3 调用方法 260
9.3.1 调用构造函数 262
9.3.2 调用静态方法 263
9.4 使用变量和函数 263
9.4.1 #root 263
9.4.2 #this 264
9.4.3 访问系统属性和环境 264
9.4.4 内联列表 264
9.4.5 注册函数 265
9.5 了解SpEL运算符 265
9.5.1 关系运算符 266
9.5.2 算术运算符 266
9.5.3 逻辑运算符 266
9.5.4 条件运算符 267
9.5.5 正则表达式运算符 268
9.5.6 安全导航运算符 269
9.5.7 集合选择和投影 269
9.5.8 选择集合中的第一个和最后一个元素 270
9.6 使用SpEL中的实用工具 271
9.6.1 访问Spring Bean 271
9.6.2 	271
9.6.3 缓存中的表达式 272
9.7 小结 272
9.8 习题 272
9.9 本章主要知识点 272
第10章 缓存 275
10.1 创建第一个缓存应用程序 276
10.1.1 使用一个不同的名称配置缓存管理器 279
10.1.2 使用注解配置缓存抽象 279
10.2 使用缓存注解 280
10.2.1 @Cacheable 280
10.2.2 @CacheEvict 282
10.2.3 @CachePut 282
10.2.4 @Caching 282
10.3 实现缓存管理器 283
10.3.1 SimpleCacheManager 283
10.3.2 NoOpCacheManager 284
10.3.3 ConcurrentMap CacheManager 284
10.3.4 CompositeCache Manager 284
10.4 将SpEL投射到缓存中 285
10.5 以编程方式初始化缓存 286
10.6 寻找替换的缓存提供程序 288
10.6.1 Ehcache 288
10.6.2 Guava 292
10.6.3 Hazelcast 292
10.7 小结 293
10.8 习题 293
10.9 本章主要知识点 294
第11章 使用Spring开发REST风格的Web服务 295
11.1 创建第一个REST Web服务 296
11.2 从REST Web服务返回不同的HTTP状态码 307
11.3 学习一种基于注解的配置替换方法 308
11.4 通过XML使用REST Web服务 309
11.5 使用异常处理机制 312
11.6 对REST风格的服务进行单元测试 315
11.7 小结 318
11.8 习题 318
11.9 本章主要知识点 318
第12章 使用Spring Security保护Web应用程序的安全 321
12.1 为什么要使用Spring Security 322
12.2 Spring Security的功能 323
12.3 配置和使用Spring Security 324
12.4 理解Spring Security的基础构建基块 330
12.5 对用户进行身份验证 331
12.5.1 不成功的登录流程 331
12.5.2 成功的登录流程 332
12.5.3 匿名身份验证 333
12.5.4 自定义登录页面 334
12.5.5 注销过程 335
12.5.6 使用JDBC访问UserDetails 336
12.5.7 对密码进行加密 339
12.5.8 Remember-Me支持 339
12.5.9 用户会话管理 341
12.5.10 基本身份验证 342
12.6 授权Web请求和服务方法调用 343
12.6.1 授权Web请求 343
12.6.2 授权是如何工作的 345
12.6.3 基于表达式的授权 347
12.6.4 使用JSP安全标记 348
12.6.5 授权服务方法 349
12.7 小结 353
12.8 习题 354
12.9 本章主要知识点 354
第13章 Spring 4.0 357
13.1 跟上最新技术：Java 8和Java EE7支持 357
13.2 使用条件依赖项配置注入 362
13.3 对自动配置集合中的元素进行排序 365
13.4 重复的注解 367
13.5 引入新的注解 369
13.6 小结 370
13.7 习题 370
13.8 本章主要知识点 370
附录A 参考答案 371
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring入门经典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Batch 批处理框架
目录
第1篇 入门篇
第1章 Spring Batch简介	2
1.1 什么是批处理	2
1.2 Spring Batch	3
1.2.1 典型场景	3
1.2.2 Spring Batch架构	4
1.3 Spring Batch优势	4
1.3.1 丰富的开箱即用组件	5
1.3.2 面向Chunk的处理	5
1.3.3 事务管理能力	5
1.3.4 元数据管理	5
1.3.5 易监控的批处理应用	5
1.3.6 丰富的流程定义	5
1.3.7 健壮的批处理应用	6
1.3.8 易扩展的批处理应用	6
1.3.9 复用企业现有IT资产	6
1.4 Spring Batch 2.0新特性	6
1.4.1 支持Java5	7
1.4.2 支持非顺序的Step	7
1.4.3 面向Chunk处理	7
1.4.4 元数据访问	11
1.4.5 扩展性	11
1.4.6 可配置性	12
1.5 Spring Batch 2.2新特性	13
1.5.1 Spring Data集成	13
1.5.2 支持Java配置	13
1.5.3 Spring Retry	14
1.5.4 Job Parameters	14
1.6 开发环境搭建	15
第2章 Spring Batch之Hello World	16
2.1 场景说明	16
2.2 项目准备	16
2.2.1 项目结构	16
2.2.2 准备对账单文件	17
2.2.3 定义领域对象	18
2.3 定义job基础设施	18
2.4 定义对账Job	19
2.4.1 配置ItemReader	19
2.4.2 配置ItemProcessor	21
2.4.3 配置ItemWriter	22
2.5 执行Job	23
2.5.1 Java调用	23
2.5.2 JUnit单元测试	24
2.6 概念预览	26
第2篇 基本篇
第3章 Spring Batch基本概念	28
3.1 命名空间	29
3.2 Job	30
3.2.1 Job Instance	31
3.2.2 Job Parameters	33
3.2.3 Job Execution	34
3.3 Step	35
3.3.1 Step Execution	37
3.4 Execution Context	38
3.5 Job Repository	39
3.5.1 Job Repository Schema	39
3.5.2 配置Memory Job
Repository	40
3.5.3 配置DB Job Repository	41
3.5.4 数据库Schema	42
3.6 Job Launcher	48
3.7 ItemReader	49
3.8 ItemProcessor	50
3.9 ItemWriter	50
第4章 配置作业Job	52
4.1 基本配置	52
4.1.1 重启Job	54
4.1.2 Job拦截器	55
4.1.3 Job Parameters校验	58
4.1.4 Job抽象与继承	59
4.2 高级特性	61
4.2.1 Step Scope	61
4.2.2 属性Late Binding	62
4.3 运行Job	63
4.3.1 调度作业	65
4.3.2 命令行执行	68
4.3.3 与定时任务集成	71
4.3.4 与Web应用集成	73
4.3.5 停止Job	77
第5章 配置作业步Step	85
5.1 配置Step	86
5.1.1 Step抽象与继承	87
5.1.2 Step执行拦截器	89
5.2 配置Tasklet	92
5.2.1 重启Step	93
5.2.2 事务	94
5.2.3 事务回滚	96
5.2.4 多线程Step	97
5.2.5 自定义Tasklet	97
5.3 配置Chunk	99
5.3.1 提交间隔	102
5.3.2 异常跳过	103
5.3.3 Step重试	105
5.3.4 Chunk完成策略	107
5.3.5 读、处理事务	110
5.4 拦截器	112
5.4.1 ChunkListener	115
5.4.2 ItemReadListener	116
5.4.3 ItemProcessListener	116
5.4.4 ItemWriteListener	117
5.4.5 SkipListener	117
5.4.6 RetryListener	118
第6章 读数据ItemReader	120
6.1 ItemReader	120
6.1.1 ItemReader	120
6.1.2 ItemStream	121
6.1.3 系统读组件	122
6.2 Flat格式文件	122
6.2.1 Flat文件格式	123
6.2.2 FlatFileItemReader	125
6.2.3 RecordSeparatorPolicy	129
6.2.4 LineMapper	130
6.2.5 DefaultLineMapper	131
6.2.6 LineCallbackHandler	138
6.2.7 读分隔符文件	139
6.2.8 读定长文件	141
6.2.9 读JSON文件	143
6.2.10 读记录跨多行文件	145
6.2.11 读混合记录文件	147
6.3 XML格式文件	150
6.3.1 XML解析	150
6.3.2 Spring OXM	151
6.3.3 StaxEventItemReader	153
6.4 读多文件	156
6.5 读数据库	159
6.5.1 JdbcCursorItemReader	160
6.5.2 HibernateCursorItem
Reader	167
6.5.3 StoredProcedureItem
Reader	171
6.5.4 JdbcPagingItemReader	174
6.5.5 HibernatePagingItem
Reader	179
6.5.6 JpaPagingItemReader	183
6.5.7 IbatisPagingItemReader	186
6.6 读JMS队列	190
6.6.1 JmsItemReader	190
6.7 服务复用	194
6.8 自定义ItemReader	197
6.8.1 不可重启ItemReader	197
6.8.2 可重启ItemReader	199
6.9 拦截器	202
6.9.1 拦截器接口	202
6.9.2 拦截器异常	203
6.9.3 执行顺序	204
6.9.4 Annotation	204
6.9.5 属性Merge	205
第7章 写数据ItemWriter	207
7.1 ItemWrite	207
7.1.1 ItemWriter	208
7.1.2 ItemStream	208
7.1.3 系统写组件	209
7.2 Flat格式文件	210
7.2.1 FlatFileItemWriter	210
7.2.2 LineAggregator	214
7.2.3 FieldExtractor	217
7.2.4 回调操作	219
7.3 XML格式文件	222
7.3.1 StaxEventItemWriter	222
7.3.2 回调操作	226
7.4 写多文件	230
7.4.1 MultiResourceItemWriter	230
7.4.2 扩展MultiResourceItem
Writer	233
7.5 写数据库	234
7.5.1 JdbcBatchItemWriter	235
7.5.2 HibernateItemWriter	239
7.5.3 IbatisBatchItemWriter	242
7.5.4 JpaItemWriter	245
7.6 写JMS队列	248
7.6.1 JmsItemWriter	248
7.7 组合写	252
7.8 Item路由Writer	254
7.9 发送邮件	258
7.9.1 SimpleMailMessageItem
Writer	258
7.10 服务复用	262
7.10.1 ItemWriterAdapter	262
7.10.2 PropertyExtracting
DelegatingItemWriter	264
7.11 自定义ItemWrite	267
7.11.1 不可重启ItemWriter	267
7.11.2 可重启ItemWriter	268
7.12 拦截器	271
7.12.1 拦截器接口	271
7.12.2 拦截器异常	273
7.12.3 执行顺序	274
7.12.4 Annotation	274
7.12.5 属性Merge	275
第8章 处理数据ItemProcessor	277
8.1 ItemProcessor	277
8.1.1 ItemProcessor	277
8.1.2 系统处理组件	278
8.2 数据转换	279
8.2.1 部分数据转换	279
8.2.2 数据类型转换	281
8.3 数据过滤	282
8.3.1 数据Filter	282
8.3.2 数据过滤统计	283
8.4 数据校验	285
8.4.1 Validator	285
8.4.2 ValidatingItemProcessor	286
8.5 组合处理器	288
8.6 服务复用	291
8.6.1 ItemProcessorAdapter	291
8.7 拦截器	293
8.7.1 拦截器接口	293
8.7.2 拦截器异常	295
8.7.3 执行顺序	295
8.7.4 Annotation	296
8.7.5 属性Merge	297
第3篇 高级篇
第9章 作业流Step Flow	300
9.1 顺序Flow	300
9.2 条件Flow	302
9.2.1 next	303
9.2.2 ExitStatus VS
BatchStatus	306
9.2.3 decision条件	308
9.3 并行Flow	311
9.4 外部Flow定义	314
9.4.1 Flow	314
9.4.2 FlowStep	317
9.4.3 JobStep	319
9.5 Step数据共享	321
9.6 终止Job	323
9.6.1 end	324
9.6.2 stop	326
9.6.3 fail	327
第10章 健壮Job	330
10.1 跳过Skip	331
10.1.1 配置Skip	331
10.1.2 跳过策略SkipPolicy	333
10.1.3 跳过拦截器	335
10.2 重试Retry	338
10.2.1 配置Retry	339
10.2.2 重试策略RetryPolicy	341
10.2.3 重试拦截器	343
10.2.4 重试模板	345
10.3 重启Restart	353
10.3.1 重启Job	353
10.3.2 启动次数限制	355
10.3.3 重启已完成的任务	355
第11章 扩展Job、并行处理	357
11.1 可扩展性	357
11.2 多线程Step	358
11.2.1 配置多线程Step	359
11.2.2 线程安全性	360
11.2.3 线程安全Step	361
11.2.4 可重启的线程
安全Step	363
11.3 并行Step	365
11.4 远程Step	366
11.4.1 远程Step框架	366
11.4.2 基于SI实现远程Step	368
11.5 分区Step	373
11.5.1 关键接口	374
11.5.2 基本配置	376
11.5.3 文件分区	378
11.5.4 数据库分区	382
11.5.5 远程分区Step	387
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Batch 批处理框架
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring微服务实战
目录
第　1章 欢迎迈入云世界，Spring　1
1.1　什么是微服务　1
1.2　什么是Spring，为什么它与微服务有关　4
1.3　在本书中读者会学到什么　5
1.4　为什么本书与你有关　6
1.5　使用Spring Boot来构建微服务　6
1.6　为什么要改变构建应用的方式　10
1.7　云到底是什么　11
1.8　为什么是云和微服务　13
1.9　微服务不只是编写代码　14
1.9.1　核心微服务开发模式　15
1.9.2　微服务路由模式　16
1.9.3　微服务客户端弹性模式　17
1.9.4　微服务安全模式　18
1.9.5　微服务日志记录和跟踪模式　19
1.9.6　微服务构建和部署模式　20
1.10　使用Spring Cloud构建微服务　22
1.10.1　Spring Boot　23
1.10.2　Spring Cloud Config　23
1.10.3　Spring Cloud服务发现　24
1.10.4　Spring Cloud与Netflix Hystrix和Netflix Ribbon　24
1.10.5　Spring Cloud与Netflix Zuul　24
1.10.6　Spring Cloud Stream　24
1.10.7　Spring Cloud Sleuth　24
1.10.8　Spring Cloud Security　25
1.10.9　代码供应　25
1.11　通过示例来介绍Spring Cloud　25
1.12　确保本书的示例是有意义的　27
1.13　小结　28
第　2章 使用Spring Boot构建微服务　29
2.1　架构师的故事：设计微服务架构　31
2.1.1　分解业务问题　31
2.1.2　建立服务粒度　32
2.1.3　互相交流：定义服务接口　35
2.2　何时不应该使用微服务　36
2.2.1　构建分布式系统的复杂性　36
2.2.2　服务器散乱　36
2.2.3　应用程序的类型　36
2.2.4　数据事务和一致性　37
2.3　开发人员的故事：用SpringBoot和Java构建微服务　37
2.3.1　从骨架项目开始　37
2.3.2　引导Spring Boot应用程序：编写引导类　39
2.3.3　构建微服务的入口：Spring Boot控制器　40
2.4　DevOps工程师的故事：构建运行时的严谨性　44
2.4.1　服务装配：打包和部署微服务　46
2.4.2　服务引导：管理微服务的配置　47
2.4.3　服务注册和发现：客户端如何与微服务通信　48
2.4.4　传达微服务的“健康状况”　49
2.5　将视角综合起来　51
2.6　小结　52
第3章　使用Spring Cloud配置服务器控制配置　53
3.1　管理配置（和复杂性）　54
3.1.1　配置管理架构　55
3.1.2　实施选择　56
3.2　构建Spring Cloud配置服务器　58
3.2.1　创建Spring Cloud Config引导类　61
3.2.2　使用带有文件系统的Spring Cloud配置服务器　62
3.3　将Spring Cloud Config与Spring Boot客户端集成　64
3.3.1　建立许可证服务对Spring Cloud Config服务器的依赖　65
3.3.2　配置许可证服务以使用Spring Cloud Config　66
3.3.3　使用Spring Cloud配置服务器连接数据源　69
3.3.4　使用@Value注解直接读取属性　72
3.3.5　使用Spring Cloud配置服务器和Git　73
3.3.6　使用Spring Cloud配置服务器刷新属性　73
3.4　保护敏感的配置信息　75
3.4.1　下载并安装加密所需的Oracle JCE jar　75
3.4.2　创建加密密钥　76
3.4.3　加密和解密属性　76
3.4.4　配置微服务以在客户端使用加密　78
3.5　最后的想法　79
3.6　小结　80
第4章　服务发现　81
4.1　我的服务在哪里　82
4.2　云中的服务发现　84
4.2.1　服务发现架构　84
4.2.2　使用Spring和Netflix Eureka进行服务发现实战　87
4.3　构建Spring Eureka服务　88
4.4　通过Spring Eureka注册服务　90
4.5　使用服务发现来查找服务　93
4.5.1　使用Spring DiscoveryClient查找服务实例　95
4.5.2　使用带有Ribbon功能的Spring RestTemplate调用服务　97
4.5.3　使用Netflix Feign客户端调用服务　98
4.6　小结　100
第5章　使用Spring Cloud和NetflixHystrix的客户端弹性模式　101
5.1　什么是客户端弹性模式　102
5.1.1　客户端负载均衡模式　103
5.1.2　断路器模式　103
5.1.3　后备模式　103
5.1.4　舱壁模式　104
5.2　为什么客户端弹性很重要　104
5.3　进入Hystrix　107
5.4　搭建许可服务器以使用Spring Cloud和Hystrix　107
5.5　使用Hystrix实现断路器　109
5.5.1　对组织微服务的调用超时　111
5.5.2　定制断路器的超时时间　112
5.6　后备处理　113
5.7　实现舱壁模式　115
5.8　基础进阶—微调Hystrix　118
5.9　线程上下文和Hystrix　122
5.9.1　ThreadLocal与Hystrix　122
5.9.2　HystrixConcurrencyStrategy实战　125
5.10　小结　129
第6章　使用Spring Cloud和Zuul进行服务路由　131
6.1　什么是服务网关　132
6.2　Spring Cloud和Netflix Zuul简介　133
6.2.1　建立一个Zuul Spring Boot项目　134
6.2.2　为Zuul服务使用Spring Cloud注解　134
6.2.3　配置Zuul与Eureka进行通信　135
6.3　在Zuul中配置路由　135
6.3.1　通过服务发现自动映射路由　136
6.3.2　使用服务发现手动映射路由　137
6.3.3　使用静态URL手动映射路由　140
6.3.4　动态重新加载路由配置　142
6.3.5　Zuul和服务超时　143
6.4　Zuul的真正威力：过滤器　144
6.5　构建第 一个生成关联ID的Zuul前置过滤器　147
6.6　构建接收关联ID的后置过滤器　155
6.7　构建动态路由过滤器　157
6.7.1　构建路由过滤器的骨架　159
6.7.2　实现run()方法　159
6.7.3　转发路由　161
6.7.4　整合　162
6.8　小结　163
第7章　保护微服务　164
7.1　OAuth2简介　165
7.2　从小事做起：使用Spring和OAuth2来保护单个端点　167
7.2.1　建立EagleEye OAuth2验证服务　167
7.2.2　使用OAuth2服务注册客户端应用程序　168
7.2.3　配置EagleEye用户　171
7.2.4　验证用户　172
7.3　使用OAuth2保护组织服务　175
7.3.1　将Spring Security和OAuth2 jar添加到各个服务　176
7.3.2　配置服务以指向OAuth2验证服务　176
7.3.3　定义谁可以访问服务　177
7.3.4　传播OAuth2访问令牌　180
7.4　JSON Web Token与OAuth2　183
7.4.1　修改验证服务以颁发JWT令牌　184
7.4.2　在微服务中使用JWT　188
7.4.3　扩展JWT令牌　189
7.4.4　从JWT令牌中解析自定义字段　191
7.5　关于微服务安全的总结　193
7.6　小结　195
第8章　使用Spring Cloud Stream的事件驱动架构　196
8.1　为什么使用消息传递、EDA和微服务　197
8.1.1　使用同步请求-响应方式来传达状态变化　198
8.1.2　使用消息传递在服务之间传达状态更改　199
8.1.3　消息传递架构的缺点　201
8.2　Spring Cloud Stream简介　202
8.3　编写简单的消息生产者和消费者　205
8.3.1　在组织服务中编写消息生产者　205
8.3.2　在许可证服务中编写消息消费者　210
8.3.3　在实际操作中查看消息服务　213
8.4　Spring Cloud Stream用例：分布式缓存　214
8.4.1　使用Redis来缓存查找　215
8.4.2　定义自定义通道　221
8.4.3　将其全部汇集在一起：在收到消息时清除缓存　222
8.5　小结　223
第9章　使用Spring Cloud Sleuth和Zipkin进行分布式跟踪　224
9.1　Spring Cloud Sleuth与关联ID　225
9.1.1　将Spring Cloud Sleuth添加到许可证服务和组织服务中　226
9.1.2　剖析Spring Cloud Sleuth跟踪　226
9.2　日志聚合与Spring Cloud Sleuth　227
9.2.1　Spring Cloud Sleuth与Papertrail实现实战　229
9.2.2　创建Papertrail账户并配置syslog连接器　230
9.2.3　将Docker输出重定向到Papertrail　232
9.2.4　在Papertrail中搜索Spring Cloud Sleuth的跟踪ID　234
9.2.5　使用Zuul将关联ID添加到HTTP响应　235
9.3　使用Open Zipkin进行分布式跟踪　237
9.3.1　添加Spring Cloud Sleuth和Zipkin依赖项　238
9.3.2　配置服务以指向Zipkin　238
9.3.3　安装和配置Zipkin服务器　239
9.3.4　设置跟踪级别　240
9.3.5　使用Zipkin跟踪事务　241
9.3.6　可视化更复杂的事务　243
9.3.7　捕获消息传递跟踪　244
9.3.8　添加自定义跨度　246
9.4　小结　248
第　10章 部署微服务　250
10.1　EagleEye：在云中建立核心基础设施　251
10.1.1　使用亚马逊的RDS创建PostgreSQL数据库　253
10.1.2　在AWS中创建Redis集群　257
10.1.3　创建ECS集群　258
10.2　超越基础设施：部署EagleEye　262
10.3　构建和部署管道的架构　265
10.4　构建和部署管道实战　268
10.5　开始构建和部署管道：GitHub和Travis CI　270
10.6　使服务能够在Travis CI中构建　270
10.6.1　构建的核心运行时配置　273
10.6.2　安装预构建工具　275
10.6.3　执行构建　277
10.6.4　标记源代码　277
10.6.5　构建微服务并创建Docker镜像　279
10.6.6　将镜像推送到Docker Hub　279
10.6.7　在Amazon ECS中启动服务　280
10.6.8　启动平台测试　280
10.7　关于构建和部署管道的总结　282
10.8　小结　282
附录A　在桌面运行云服务　283
附录B　OAuth2授权类型　291
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring微服务实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring实战（第5版 ）
第1部分 Spring 基础
第 1 章 Spring 起步 3
1.1 什么是Spring 4
1.2 初始化Spring 应用 6
1.2.1 使用Spring Tool Suite
初始化Spring 项目 7
1.2.2 检查Spring 项目的
结构 10
1.3 编写Spring 应用 16
1.3.1 处理Web 请求 16
1.3.2 定义视图 17
1.3.3 测试控制器 18
1.3.4 构建和运行应用 20
1.3.5 了解Spring Boot DevTools 21
1.3.6 回顾一下 23
1.4 俯瞰Spring 风景线 24
1.4.1 Spring 核心框架 24
1.4.2 Spring Boot 25
1.4.3 Spring Data 25
1.4.4 Spring Security 25
1.4.5 Spring Integration 和Spring
Batch 26
1.4.6 Spring Cloud 26
1.5 小结 26
第 2 章 开发Web 应用 27
2.1 展现信息 27
2.1.1 构建领域类 28
2.1.2 创建控制器类 30
2.1.3 设计视图 33
2.2 处理表单提交 37
2.3 校验表单输入 43
2.3.1 声明校验规则 43
2.3.2 在表单绑定的时候执行
校验 45
2.3.3 展现校验错误 46
2.4 使用视图控制器 48
2.5 选择视图模板库 49
2.6 小结 52
第3 章 使用数据 53
3.1 使用JDBC 读取和写入
数据 53
3.1.1 调整领域对象以适应
持久化 55
3.1.2 使用JdbcTemplate 56
3.1.3 定义模式和预加载数据 61
3.1.4 插入数据 63
3.2 使用Spring Data JPA 持久
化数据 72
3.2.1 添加Spring Data JPA 到
项目中 72
3.2.2 将领域对象标注为实体 73
3.2.3 声明JPA repository 76
3.2.4 自定义JPA repository 77
3.3 小结 80
第4 章 保护Spring 81
4.1 启用Spring Security 81
4.2 配置Spring Security 83
4.2.1 基于内存的用户存储 85
4.2.2 基于JDBC 的用户存储 86
4.2.3 以LDAP 作为后端的
用户存储 89
4.2.4 自定义用户认证 92
4.3 保护Web 请求 100
4.3.1 保护请求 100
4.3.2 创建自定义的登录页 103
4.3.3 tui出 105
4.3.4 防止跨站请求伪造 106
4.4 了解用户是谁 107
4.5 小结 109
第5 章 使用配置属性 111
5.1 细粒度的自动配置 112
5.1.1 理解Spring 的环境抽象 112
5.1.2 配置数据源 114
5.1.3 配置嵌入式服务器 115
5.1.4 配置日志 116
5.1.5 使用特定的属性值 118
5.2 创建自己的配置属性 118
5.2.1 定义配置属性的持有者 120
5.2.2 声明配置属性元数据 123
5.3 使用profile 进行配置 125
5.3.1 定义特定profile 的属性 126
5.3.2 激活profile 127
5.3.3 使用profile 条件化地创建
bean 128
5.4 小结 129
第２部分 Spring 集成
第6 章 创建REST 服务 133
6.1 编写RESTful 控制器 134
6.1.1 从服务器中检索数据 136
6.1.2 发送数据到服务器端 140
6.1.3 在服务器上更新数据 142
6.1.4 删除服务器上的数据 144
6.2 启用超媒体 145
6.2.1 添加超链接 147
6.2.2 创建资源装配器 149
6.2.3 命名嵌套式的关联关系 154
6.3 启用数据后端服务 155
6.3.1 调整资源路径和关系
名称 157
6.3.2 分页和排序 159
6.3.3 添加自定义的端点 160
6.3.4 为Spring Data 端点添加
自定义的超链接 162
6.4 小结 163
第7 章 消费REST 服务 165
7.1 使用RestTemplate 消费
REST 端点 166
7.1.1 GET 资源 167
7.1.2 PUT 资源 169
7.1.3 DELETE 资源 169
7.1.4 POST 资源 169
7.2 使用Traverson 导航
REST API 170
7.3 小结 172
第8 章 发送异步消息 173
8.1 使用JMS 发送消息 174
8.1.1 搭建JMS 环境 174
8.1.2 使用JmsTemplate 发送
消息 176
8.1.3 接收JMS 消息 183
8.2 使用RabbitMQ 和
AMQP 186
8.2.1 添加RabbitMQ 到
Spring 中 188
8.2.2 通过RabbitTemplate 发送
消息 189
8.2.3 接收来自RabbitMQ 的
消息 192
8.3 使用Kafka 的消息 196
8.3.1 为Spring 搭建支持Kafka
消息的环境 197
8.3.2 通过KafkaTemplate 发送
消息 198
8.3.3 编写Kafka 监听器 200
8.4 小结 201
第9 章 Spring 集成 203
9.1 声明一个简单的
集成流 204
9.1.1 使用XML 定义集成流 205
9.1.2 使用Java 配置集成流 207
9.1.3 使用Spring Integration 的
DSL 配置 209
9.2 Spring Integration 功能
概览 210
9.2.1 消息通道 211
9.2.2 过滤器 212
9.2.3 转换器 213
9.2.4 路由器 214
9.2.5 切分器 216
9.2.6 服务激活器 218
9.2.7 网关 220
9.2.8 通道适配器 221
9.2.9 端点模块 223
9.3 创建Email 集成流 224
9.4 小结 229
第３部分 反应式Spring
第 10 章 理解反应式编程 233
10.1 反应式编程概览 234
10.2 初识Reactor 237
10.2.1 绘制反应式流图 238
10.2.2 添加Reactor 依赖 239
10.3 使用常见的反应式
操作 240
10.3.1 创建反应式类型 240
10.3.2 组合反应式类型 244
10.3.3 转换和过滤反应式流 248
10.3.4 在反应式类型上执行逻辑
操作 258
10.4 小结 259
第 11 章 开发反应式API 261
11.1 使用Spring WebFlux 261
11.1.1 Spring WebFlux 简介 262
11.1.2 编写反应式控制器 264
11.2 定义函数式请求处
理器 268
11.3 测试反应式控制器 271
11.3.1 测试GET 请求 271
11.3.2 测试POST 请求 274
11.3.3 使用实时服务器进行
测试 275
11.4 反应式消费
REST API 276
11.4.1 获取资源 277
11.4.2 发送资源 279
11.4.3 删除资源 280
11.4.4 处理错误 280
11.4.5 交换请求 282
11.5 保护反应式Web API 283
11.5.1 配置反应式Web 应用的
安全性 284
11.5.2 配置反应式的用户详情
服务 285
11.6 小结 287
第 12 章 反应式持久化数据 289
12.1 理解Spring Data 的
反应式概况 290
12.1.1 Spring Data 反应式本
质论 290
12.1.2 反应式和非反应式类型
之间的转换 291
12.1.3 开发反应式repository 292
12.2 使用反应式的
Cassandra repository 293
12.2.1 启用Spring Data
Cassandra 293
12.2.2 理解Cassandra 的数据
模型 296
12.2.3 将领域对象映射为Cassandra
持久化 296
12.2.4 编写反应式
Cassandra repository 301
12.3 编写反应式的
MongoDB repository 304
12.3.1 启用Spring Data
MongoDB 304
12.3.2 将领域对象映射为
文档 306
12.3.3 编写反应式的MongoDB
repository 接口 309
12.4 小结 312
第4 部分 云原生Spring
第 13 章 注册和发现服务 315
13.1 思考微服务 316
13.2 搭建服务注册中心 318
13.2.1 配置Eureka 321
13.2.2 扩展Eureka 324
13.3 注册和发现服务 325
13.3.1 配置Eureka 客户端
属性 326
13.3.2 消费服务 328
13.4 小结 332
第 14 章 管理配置 333
14.1 共享配置 334
14.2 运行配置服务器 335
14.2.1 启用配置服务器 336
14.2.2 填充配置仓库 339
14.3 消费共享配置 341
14.4 提供特定应用和profile 的
属性 343
14.4.1 提供特定应用的属性 343
14.4.2 提供来自profile 的
属性 344
14.5 保持配置属性的
私密性 346
14.5.1 在Git 中加密属性 346
14.5.2 在Vault 中存储私密
信息 349
14.6 在运行时刷新配置
属性 353
14.6.1 手动刷新配置属性 354
14.6.2 自动刷新配置属性 356
14.7 小结 363
第 15 章 处理失败和延迟 365
15.1 理解断路器模式 365
15.2 声明断路器 367
15.2.1 缓解延迟 369
15.2.2 管理断路器的阈值 371
15.3 监控失败 372
15.3.1 Hystrix dashboard
简介 373
15.3.2 理解Hystrix 的线程
模型 375
15.4 聚合多个Hystrix 流 377
15.5 小结 378
第5 部分 部署Spring
第 16 章 使用Spring Boot
Actuator 381
16.1 Actuator 概览 382
16.1.1 配置Actuator 的基础
路径 383
16.1.2 启用和禁用Actuator
端点 383
16.2 消费Actuator 端点 384
16.2.1 获取应用的基础信息 385
16.2.2 查看配置细节 388
16.2.3 查看应用的活动 396
16.2.4 获取应用的指标 398
16.3 自定义Actuator 401
16.3.1 为“/info”端点提供信息 401
16.3.2 实现自定义的健康
指示器 405
16.3.3 注册自定义的指标 407
16.3.4 创建自定义的端点 408
16.4 保护Actuator 411
16.5 小结 413
第 17 章 管理Spring 415
17.1 使用Spring Boot
Admin 415
17.1.1 创建Admin 服务器 416
17.1.2 注册Admin 客户端 418
17.2 探索Admin 服务器 421
17.2.1 查看应用基本的健康状况
和信息 421
17.2.2 观察核心指标 423
17.2.3 探查环境属性 424
17.2.4 查看和设置日志
级别 424
17.2.5 监控线程 425
17.2.6 跟踪HTTP 请求 426
17.3 保护Admin 服务器 428
17.3.1 为Admin 服务器启用登录
功能 428
17.3.2 为Actuator 启用认证 429
17.4 小结 429
第 18 章 使用JMX 监控
Spring 431
18.1 使用Actuator MBean 431
18.2 创建自己的MBean 434
18.3 发送通知 436
18.4 小结 437
第 19 章 部署Spring 439
19.1 权衡各种部署方案 440
19.2 构建和部署WAR
文件 441
19.3 推送JAR 文件到Cloud
Foundry 上 443
19.4 在Docker 容器中运行
Spring Boot 445
19.5 以终为始 449
19.6 小结 449
附录 初始化Spring 应用 451
A.1 使用Spring Tool Suite
初始化项目 451
A.2 使用IntelliJ IDEA 初始化
项目 454
A.3 使用NetBeans 初始化
项目 457
A.4 在start.spring.io 中初始化
项目 459
A.5 使用命令行初始化
项目 462
A.5.1 curl 和Initializr API 462
A.5.2 Spring Boot 命令行
接口 464
A.6 使用元框架创建Spring
应用 465
A.7 构建和运行项目 465
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring实战（第5版 ）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Data实战
第一部分　背景知识
第1章　Spring Data项目　3
1.1　为Spring开发人员提供的NoSQL数据访问功能　3
1.2　主题概述　4
1.3　领域　5
1.4　示例代码　6
1.4.1　将源码导入到IDE　6
第2章　Repository：便利的数据访问层　11
2.1　快速入门　11
2.2　定义查询方法　14
2.2.1　查找查询的策略　14
2.2.2　衍生查询　14
2.2.3　分页和排序　15
2.3　定义Repository　16
2.3.1　调整Repository接口　17
2.3.2　手动实现Repository方法　18
2.4　IDE集成　20
2.4.1　Intelli IDEA　21
第3章　使用Querydsl实现类型安全的查询　23
3.1　Querydsl简介　23
3.2　生成查询元模型　26
3.2.1　构建系统集成　26
3.2.2　所支持的注解处理器　27
3.2.3　使用Querydsl对存储进行查询　28
3.3　集成Spring Data Repository　28
3.3.1　执行断言　29
3.3.2　手动实现Repository　29
第二部分　关系型数据库
第4章　JPA Repository　33
4.1　示例工程　33
4.2　传统方式　38
4.3　启动示例代码　39
4.4　使用Spring Data Repository　42
4.4.1　事务性　45
4.4.2　Repository与Querydsl集成　46
第5章　借助Querydsl SQL实现类型安全的JDBC编程　48
5.1　示例工程与搭建过程　48
5.1.1　HyperSQL数据库　49
5.1.2　Querydsl的SQL模块　50
5.1.3　构建系统集成　53
5.1.4　数据库模式　54
5.1.5　示例工程的领域实现　54
5.2　QueryDslJdbcTemplate　57
5.3　执行查询　58
5.3.1　Repository实现起步　59
5.3.2　查询单个对象　60
5.3.3　OneToManyResultSetExtractor抽象类　61
5.3.4　CustomerListExtractor实现　63
5.3.5　RowMapper的实现类　64
5.3.6　查询对象列表　65
5.4　插入、更新和删除操作　65
5.4.1　使用SQLInsertClause进行插入操作　65
5.4.2　使用SQLUpdateClause进行更新操作　66
5.4.3　使用SQLDeleteClause进行删除行操作　67
第三部分　NoSQL
第6章　MongoDB: 文档存储　71
6.1　MongoDB简介　71
6.1.1　设置MongoDB　72
6.1.2　使用MongoDB Shell　73
6.1.3　MongoDB Java驱动　74
6.2　使用Spring命名空间搭建基础设施　75
6.3　映射模块　76
6.3.1　领域模型　76
6.3.2　搭建映射的基础设施　81
6.3.3　索引　83
6.3.4　自定义转换　84
6.4　MongoTemplate　86
6.5　Mongo Repository　88
6.5.1　搭建基础设施　88
6.5.2　Repository详解　88
6.5.3　Mongo Querydsl集成　90
第7章　Neo4j：图数据库　92
7.1　图数据库　92
7.2　Neo4j　93
7.3　Spring Data Neo4j概览　95
7.4　将领域建模为图　96
7.5　使用Spring Data Neo4j持久化领域对象　101
7.5.1　Neo4jTemplate　103
7.6　组合发挥图和Repository的威力　104
7.6.1　基本的图Repository操作　106
7.6.2　衍生和基于注解的查找方法　106
7.7　示例领域模型中的高级图用例　109
7.7.1　单个节点的多重角色　109
7.7.2　以产品分类和标签为例讲解图中的索引　110
7.7.3　利用类似的兴趣(协同过滤)　111
7.7.4　推荐　111
7.8　事务、实体生命周期以及抓取策略　112
7.9　高级映射模型　113
7.10　使用Neo4j服务器　114
7.11　从这里继续学习　115
第8章　Redis：键/值存储　116
8.1　Redis概述　116
8.1.1　搭建Redis　116
8.1.2　使用Redis Shell　117
8.2　连接到Redis　118
8.3　对象转换　119
8.4　对象映射　121
8.5　原子级计数器　123
8.6　发布/订阅功能　123
8.6.1　对信息进行监听和响应　124
8.6.2　在Redis中使用Spring的缓存抽象　125
第四部分　快速应用开发
第9章　使用Spring Roo实现持久层　129
9.1　Roo简介　129
9.2　Roo的持久层　131
9.3　快速起步　132
9.3.1　借助命令行使用Roo　132
9.3.2　借助Spring Tool Suite使用Roo　133
9.4　Spring Roo JPA Repository示例　135
9.4.1　创建工程　135
9.4.2　搭建JPA持久化　135
9.4.3　创建实体　135
9.4.4　定义Repository　137
9.4.5　创建Web层　138
9.4.6　运行示例　139
9.5　Spring MongoDB JPA Repository的例子　140
9.5.1　创建工程　140
9.5.2　搭建MongoDB持久化　140
9.5.3　创建实体　140
9.5.4　定义Repository　141
9.5.5　创建Web层　141
9.5.6　运行示例　141
第10章　REST Repository导出器　143
10.1　示例工程　144
10.1.1　与Rest导出器进行交互　146
10.1.2　访问Product　148
10.1.3　访问Customer　151
10.1.4　访问Order　154
第五部分　大数据
第11章　Spring for Apache Hadoop　159
11.1　Hadoop开发面临的挑战　159
11.2　Hello World　161
11.3　揭秘Hello World　163
11.4　使用Spring for Apache Hadoop的Hello World　166
11.5　在JVM中编写HDFS脚本　170
11.6　结合HDFS脚本与Job提交　172
11.7　Job调度　173
11.7.1　使用TaskScheduler调度MapReduce Job　173
11.7.2　使用Quartz调度MapReduce Job　175
第12章　使用Hadoop分析数据　176
12.1　使用Hive　176
12.1.1　Hello World　177
12.1.2　运行Hive服务器　178
12.1.3　使用Hive Thrift客户端　179
12.1.4　使用Hive JDBC客户端　181
12.1.5　使用Hive分析Apache日志文件　183
12.2　使用Pig　184
12.2.1　Hello World　185
12.2.2　运行PigServer　187
12.2.3　控制运行期脚本的执行　189
12.2.4　在Spring Integration数据管道中调用Pig脚本　191
12.2.5　使用Pig分析Apache日志文件　192
12.3　使用HBase　193
12.3.1　Hello World　193
12.3.2　使用HBase Java客户端　194
第13章　使用Spring Batch和Spring Integration创建大数据管道　197
13.1　收集并将数据加载到HDFS　197
13.1.1　Spring Integration介绍　198
13.1.2　复制日志文件　200
13.1.3　事件流　203
13.1.4　事件转发　206
13.1.5　管理　207
13.1.6　Spring Batch简介　208
13.1.7　从数据库中加载并处理数据　211
13.2　Hadoop工作流　214
13.2.1　Spring Batch对Hadoop的支持　214
13.2.2　将wordcount样例改造为Spring Batch应用　216
13.2.3　Hive和Pig的步骤　218
13.3　从HDFS导出数据　219
13.3.1　从HDFS到JDBC　219
13.3.2　从HDFS到MongoDB　224
13.4　收集并加载数据到Splunk　225
第六部分　数据网格
第14章　分布式数据网格：GemFire　231
14.1　GemFire简介　231
14.2　缓存与域　232
14.3　如何获取GemFire　233
14.4　通过Spring XML命名空间配置GemFire　234
14.4.1　缓存配置　234
14.4.2　域配置　238
14.4.3　缓存客户端配置　240
14.4.4　缓存服务端配置　241
14.4.5　WAN配置　242
14.4.6　磁盘存储配置　243
14.5　使用GemfireTemplate进行数据访问　244
14.6　使用Repository　245
14.6.1　POJO映射　245
14.6.2　创建Repository　246
14.6.3　PDX序列化　246
14.7　支持持续查询　247
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Data实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Web Flow权威指南
第1章 初识Spring Web Flow   1.1 自由浏览   1.2 可控导航     1.2.1 导航的控制    1.2.2 状态管理     1.2.3 模块化问题   1.3 传统解决方案   1.4 Spring Web Flow   1.5 小结     第2章 入门  2.1 下载Spring Web Flow   2.2 运行时需求   2.3 构建系统的集成    2.3.1 手工集成     2.3.2 与Ivy的集成     2.3.3 与Maven的集成    2.3.4 Spring Jumpstart   2.4 Hello World   2.5 开发环境中的Spring Web Flow    2.5.1 安装IDE     2.5.2 Eclipse中的“Hello World”     2.5.3 使用Spring IDE   2.6 给Hello World增添些趣味   2.7 小结     第3章 Spring Web Flow架构  3.1 语言  3.2 架构层     3.2.1 执行核心     3.2.2 执行引擎     3.2.3 执行者    3.2.4 测试支持    3.2.5 系统配置   3.3 小结     第4章 Spring Web Flow基础  4.1 设计流     4.1.1 UML状态图     4.1.2 第一个流定义   4.2 流生成器     4.2.1 XML流生成器    4.2.2 Java流生成器    4.2.3 选择合适的流生成器  4.3 定义流    4.3.1 流    4.3.2 状态    4.3.3 转移     4.3.4 流定义结构  4.4 流执行     4.4.1 流会话    4.4.2 流执行环境     4.4.3 请求环境  4.5 实现动作    4.5.1 AbstractAction     4.5.2 MultiAction    4.5.3 动作部署  4.6 基本状态类型     4.6.1 视图状态     4.6.2 动作状态     4.6.3 结束状态   4.7 流定义注册表    4.7.1 XML流定义注册表     4.7.2 Java流定义注册表    4.7.3 合并流定义注册表  4.8 小结     第5章 高级Web流概念   5.1 OGNL     5.1.1 通过示例学习OGNL     5.1.2 OGNL实战   5.2 转换服务  5.3 注解流定义工件   5.4 处理异常   5.5 视图选择     5.5.1 空字符串     5.5.2 viewName     5.5.3 redirect:viewName     5.5.4 externalRedirect:url     5.5.5 flowRedirect:flowId?input1=value&…&inputN=valueN    5.5.6 bean:id     5.5.7 自定义视图选择器  5.6 数据绑定和验证  5.7 子流    5.7.1 内联流    5.7.2 重温流会话    5.7.3 声明输入/输出契约    5.7.4 映射输入输出参数    5.7.5 增强“输入支付款”流   5.8 流的开始动作和结束动作   5.9 完整的“输入支付款”流定义  5.10 小结     第6章 流执行管理  6.1 流执行存储库介绍  6.2 流执行者    6.2.1 启动流执行    6.2.2 恢复流执行     6.2.3 刷新流执行     6.2.4 请求处理    6.2.5 配置流执行者  6.3 流执行存储库    6.3.1 对话管理    6.3.2 简单存储库    6.3.3 单键存储库     6.3.4 Continuation存储库     6.3.5 客户Continuation存储库     6.3.6 选择存储库  6.4 流执行监听器     6.4.1 监听器调用示例     6.4.2 监听器配置   6.5 小结     第7章 驱动流执行   7.1 流执行者集成   7.2 Spring Web Flow视图开发     7.2.1 模型数据    7.2.2 构建请求   7.3 宿主框架集成     7.3.1 Spring Web MVC     7.3.2 Spring Portlet MVC     7.3.3 Struts     7.3.4 JSF   7.4 小结    第8章 Spring Web Flow的测  8.1 单元测试     8.1.1 MockRequestContext    8.1.2 MockRequestControlContext     8.1.3 MockExternalContext    8.1.4 MockParameterMap    8.1.5 MockFlowExecutionContext     8.1.6 MockFlowSession    8.1.7 MockFlowServiceLocator     8.1.8 使用Mock对象测试  8.2 流执行测试    8.2.1 测试Java流定义     8.2.2 测试XML流定义     8.2.3 测试“输入支付款”流     8.2.4 使用流执行监听器  8.3 集成测试  8.4 小结    第9章 示例应用程序   9.1 功能需求  9.2 下载和构建   9.3 领域模型   9.4 应用程序搭建  9.5 表现层    9.5.1 Spring Web MVC搭建     9.5.2 实现“输入支付款”用例    9.5.3 国际化    9.5.4 异常处理     9.5.5 页面布局  9.6 小结    第10章 真实用例   10.1 访问宿主环境  10.2 流定义的参数化  10.3 使用监听器     10.3.1 安全化流    10.3.2 全局后退转移     10.3.3 面包屑  10.4 负载测试和压力测试   10.5 Spring Web Flow和AJAX  10.6 小结    第11章 扩展Spring Web Flow  11.1 通用扩展点    11.1.1 使用Bean引用    11.1.2 扩展流定义结构     11.1.3 定制流生成器   11.2 数据库支持的对话管理器   11.3 流Servlet  11.4 构建Spring Web Flow  11.5 小结     后记参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Web Flow权威指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker微服务架构实战（第2版）
1 微服务架构概述  1
1.1 单体应用架构存在的问题  . 1
1.2 如何解决单体应用架构存在的问题  3
1.3 什么是微服务  . 3
1.4 微服务架构的优点与挑战  . 4
1.4.1 微服务架构的优点  5
1.4.2 微服务架构面临的挑战  5
1.5 微服务设计原则  6
1.6 如何实现微服务架构  7
1.6.1 技术选型  7
1.6.2 架构图及常用组件  8
2 微服务开发框架——Spring Cloud  . 9
2.1 Spring Cloud 简介  . 9
2.2 Spring Cloud 特点  . 10
2.3 Spring Cloud 版本  . 10
2.3.1 版本简介  10
2.3.2 子项目一览  . 12
2.3.3 Spring Cloud/Spring Boot 版本兼容性  . 13
3 开始使用Spring Cloud 实战微服务  14
3.1 Spring Cloud 实战前提  14
3.1.1 技术储备  14
3.1.2 工具及软件版本  . 15
3.2 服务提供者与服务消费者  . 16
3.3 编写服务提供者  16
3.3.1 手动编写项目  . 17
3.3.2 使用Spring Initializr 快速创建Spring Boot 项目  . 21
3.4 编写服务消费者  23
3.5 为项目整合Spring Boot Actuator  . 25
3.6 硬编码有哪些问题  28
4 微服务注册与发现  30
4.1 服务发现简介  . 30
4.2 Eureka 简介  . 32
4.3 Eureka 原理  . 32
4.4 编写Eureka Server  34
4.5 将微服务注册到Eureka Server 上  36
4.6 Eureka Server 的高可用  38
4.6.1 编写高可用Eureka Server  38
4.6.2 将应用注册到Eureka Server 集群上  41
4.7 用户认证  . 41
4.7.1 为Eureka Server 添加用户认证  . 41
4.7.2 将微服务注册到需认证的Eureka Server  43
4.8 Eureka 的元数据  43
4.8.1 改造用户微服务  . 43
4.8.2 改造电影微服务  . 44
4.9 Eureka Server 的REST 端点  46
4.9.1 示例  47
4.9.2 注销微服务实例  . 52
4.10 Eureka 的自我保护模式  . 53
4.11 多网卡环境下的IP 选择  . 54
4.12 Eureka 的健康检查  56
4.13 排除Jersey 依赖  . 57
5 使用Ribbon 实现客户端侧负载均衡  . 59
5.1 Ribbon 简介  59
5.2 为服务消费者整合Ribbon  . 60
5.3 Ribbon 配置自定义  63
5.3.1 使用Java 代码自定义Ribbon 配置  63
5.3.2 使用属性自定义Ribbon 配置  67
5.4 脱离Eureka 使用Ribbon  68
5.5 饥饿加载  . 70
6 使用Feign 实现声明式REST 调用  . 72
6.1 Feign 简介  73
6.2 为服务消费者整合Feign  73
6.3 自定义Feign 配置  . 75
6.3.1 使用Java 代码自定义Feign 配置  . 75
6.3.2 使用属性自定义Feign 配置  79
6.4 手动创建Feign  80
6.4.1 修改用户微服务  . 80
6.4.2 修改电影微服务  . 84
6.5 Feign 对继承的支持  . 86
6.6 Feign 对压缩的支持  . 87
6.7 Feign 的日志  87
6.7.1 编码方式设置日志级别  88
6.7.2 使用属性配置日志级别  89
6.8 使用Feign 构造多参数请求  90
6.8.1 GET 请求多参数的URL  . 90
6.8.2 POST 请求包含多个参数  91
6.9 使用Feign 上传文件  92
7 使用Hystrix 实现微服务的容错处理  . 94
7.1 实现容错的手段  94
7.1.1 雪崩效应  95
7.1.2 如何容错  95
7.2 使用Hystrix 实现容错  . 97
7.2.1 Hystrix 简介  . 97
7.2.2 通用方式整合Hystrix  98
7.2.3 Hystrix 断路器的状态监控与深入理解  102
7.2.4 Hystrix 线程隔离策略与传播上下文  103
7.2.5 Feign 使用Hystrix  . 106
7.3 Hystrix 的监控  112
7.4 使用Hystrix Dashboard 可视化监控数据  . 113
7.5 使用Turbine 聚合监控数据  116
7.5.1 Turbine 简介  116
7.5.2 使用Turbine 监控多个微服务  117
7.5.3 使用消息中间件收集数据  119
8 使用Zuul 构建微服务网关  124
8.1 为什么要使用微服务网关  . 124
8.2 Zuul 简介  . 126
8.3 编写Zuul 微服务网关  . 126
8.4 管理端点  . 129
8.4.1 routes 端点  129
8.4.2 filters 端点  131
8.5 路由配置详解  . 132
8.6 Zuul 的安全与Header  . 136
8.6.1 敏感Header 的设置  . 136
8.6.2 忽略Header  . 136
8.7 使用Zuul 上传文件  . 137
8.8 Zuul 的过滤器  140
8.8.1 过滤器类型与请求生命周期  . 140
8.8.2 内置过滤器详解  . 141
8.8.3 编写Zuul 过滤器  144
8.8.4 禁用Zuul 过滤器  146
8.9 Zuul 的容错与回退  146
8.10 饥饿加载  . 149
8.11 Query String 编码  . 150
8.12 Hystrix 隔离策略与线程池  . 150
8.12.1 隔离策略  150
8.12.2 线程池配置  . 151
8.13 Zuul 的高可用  152
8.13.1 Zuul 客户端也注册到了Eureka Server 上  . 152
8.13.2 Zuul 客户端未注册到Eureka Server 上  152
8.14 使用Sidecar 整合非JVM 微服务  . 154
8.14.1 编写Node.js 微服务  . 154
8.14.2 编写Sidecar  . 155
8.14.3 Sidecar 的端点  . 157
8.14.4 Sidecar 与Node.js 微服务分离部署  . 158
8.14.5 Sidecar 原理分析  158
8.15 使用Zuul 聚合微服务  . 160
9 使用Spring Cloud Config 统一管理微服务配置  166
9.1 为什么要统一管理微服务配置  . 166
9.2 Spring Cloud Config 简介  167
9.3 编写Config Server  . 168
9.4 编写Config Client  . 171
9.5 Config Server 的Git 仓库配置详解  . 173
9.5.1 占位符支持  . 173
9.5.2 模式匹配  174
9.5.3 搜索目录  174
9.5.4 启动时加载配置文件  175
9.6 Config Server 的健康状况指示器  . 176
9.7 配置内容的加解密  177
9.7.1 安装JCE  177
9.7.2 Config Server 的加解密端点  177
9.7.3 对称加密  177
9.7.4 存储加密的内容  . 178
9.7.5 非对称加密  . 179
9.8 使用/refresh 端点手动刷新配置  180
9.9 使用Spring Cloud Bus 自动刷新配置  . 181
9.9.1 Spring Cloud Bus 简介  181
9.9.2 实现自动刷新  . 182
9.9.3 局部刷新  183
9.9.4 架构改进  184
9.9.5 跟踪总线事件  . 184
9.10 Spring Cloud Config 与Eureka 配合使用  186
9.11 Spring Cloud Config 的用户认证  . 187
9.12 Config Server 的高可用  188
9.12.1 Git 仓库的高可用  188
9.12.2 RabbitMQ 的高可用  . 189
9.12.3 Config Server 自身的高可用  189
10 使用Spring Cloud Sleuth 实现微服务跟踪  . 191
10.1 为什么要实现微服务跟踪  . 191
10.2 Spring Cloud Sleuth 简介  . 192
10.3 整合Spring Cloud Sleuth  . 194
10.4 Spring Cloud Sleuth 与ELK 配合使用  . 196
10.5 Spring Cloud Sleuth 与Zipkin 配合使用  . 200
10.5.1 Zipkin 简介  . 200
10.5.2 编写Zipkin Server  . 200
10.5.3 微服务整合Zipkin  . 202
10.5.4 Zipkin 与Eureka 配合使用  . 205
10.5.5 使用消息中间件收集数据  206
10.5.6 使用Elasticsearch 存储跟踪数据  209
10.5.7 依赖关系图  . 211
11 Spring Cloud 常见问题与总结  . 213
11.1 Eureka 常见问题  213
11.1.1 Eureka 注册服务慢  213
11.1.2 已停止的微服务节点注销慢或不注销  214
11.1.3 如何自定义微服务的Instance ID  . 215
11.1.4 Eureka 的UNKNOWN 问题总结与解决  217
11.2 整合Hystrix 后首次请求失败  218
11.2.1 原因分析  218
11.2.2 解决方案  218
11.3 Turbine 聚合的数据不完整  219
11.4 Spring Cloud 各组件超时  220
11.4.1 RestTemplate 的超时  . 221
11.4.2 Ribbon 的超时  . 221
11.4.3 Feign 的超时  221
11.4.4 Hystrix 的超时  222
11.4.5 Zuul 的超时  . 222
11.5 Spring Cloud 各组件重试  223
11.5.1 重试步骤  224
11.5.2 基于HTTP 响应码重试  224
11.5.3 关闭重试  224
11.5.4 注意点  224
11.6 Spring Cloud 各组件调优  225
11.6.1 Tomcat 参数  . 225
11.6.2 Hystrix 参数  . 225
11.6.3 Feign 参数  226
11.6.4 Zuul 参数  . 226
11.7 Spring Cloud 各组件配置属性  228
11.7.1 Spring Boot 的配置  228
11.7.2 Spring Cloud 的配置  . 228
11.7.3 原生配置  229
11.8 Spring Cloud 定位问题思路总结  . 229
12 Docker 入门  232
12.1 Docker 简介  232
12.2 版本与迭代计划  232
12.2.1 版本区别  233
12.2.2 迭代计划  233
12.3 Docker 的架构  234
12.4 安装Docker  236
12.4.1 CentOS 7 安装Docker  . 236
12.4.2 Ubuntu 安装Docker  . 239
12.4.3 Windows 安装Docker  244
12.4.4 Mac OS 安装Docker  . 245
12.5 配置镜像加速器  245
12.6 Docker 常用命令  246
12.6.1 Docker 镜像常用命令  246
12.6.2 Docker 容器常用命令  252
13 将微服务运行在Docker 上  260
13.1 使用Dockerfile 构建Docker 镜像  260
13.1.1 Dockerfile 常用指令  . 261
13.1.2 使用Dockerfile 构建镜像  266
13.2 使用Docker Registry 管理Docker 镜像  . 268
13.2.1 使用Docker Hub 管理镜像  . 268
13.2.2 使用私有仓库管理镜像  270
13.3 使用Maven 插件构建Docker 镜像  . 271
13.3.1 快速入门  272
13.3.2 插件读取Dockerfile 进行构建  273
13.3.3 将插件绑定在某个phase 执行  274
13.3.4 推送镜像  275
13.4 常见问题与总结  277
14 使用Docker Compose 编排微服务  . 278
14.1 Docker Compose 简介  . 278
14.2 安装Docker Compose  . 279
14.2.1 安装Compose  . 279
14.2.2 安装Compose 命令补全工具  . 279
14.3 Docker Compose 快速入门  . 280
14.3.1 基本步骤  280
14.3.2 入门示例  280
14.3.3 工程、服务、容器  281
14.4 docker-compose.yml 常用命令  . 281
14.5 docker-compose 常用命令  . 285
14.6 Docker Compose 网络设置  . 286
14.6.1 基本概念  286
14.6.2 更新容器  287
14.6.3 links  287
14.6.4 指定自定义网络  . 288
14.6.5 配置默认网络  . 289
14.6.6 使用已存在的网络  289
14.7 综合实战：使用Docker Comose 编排Spring Cloud 微服务  289
14.7.1 编排Spring Cloud 微服务  289
14.7.2 编排高可用的Eureka Server  293
14.7.3 编排高可用Spring Cloud 微服务集群及动态伸缩  . 295
14.8 常见问题与总结  297
后记  298
附录A：本书配套代码  . 299
附录B：Spring Cloud YES——快速开发脚手架  300
附录C：使用Docker 快速安装本书中的组件  301
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker微服务架构实战（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入实践Spring Boot
前　言
第一部分　基础应用开发
第1章　Spring Boot入门 3
1.1　配置开发环境 3
1.1.1　安装JDK 3
1.1.2　安装InterlliJ IDEA 4
1.1.3　安装Apache Maven 4
1.1.4　安装Git客户端 5
1.2　创建项目工程 8
1.2.1　使用Maven新建项目 8
1.2.2　使用Spring Initializr新建项目 11
1.3　使用Spring Boot 14
1.3.1　Maven依赖管理 14
1.3.2　一个简单的实例 17
1.4　运行与发布 18
1.4.1　在IDEA环境中运行 18
1.4.2　将应用打包发布 19
1.5　关于Spring Boot配置 22
1.6　小结 23
第2章　在Spring Boot中使用数据库 24
2.1　使用MySQL 24
2.1.1　MySQL依赖配置 25
2.1.2　实体建模 25
2.1.3　实体持久化 27
2.1.4　MySQL测试 29
2.2　使用Redis 33
2.2.1　Redis依赖配置 33
2.2.2　创建Redis服务类 34
2.2.3　Redis测试 36
2.3　使用MongoDB 38
2.3.1　MongoDB依赖配置 38
2.3.2　文档建模 39
2.3.3　文档持久化 40
2.3.4　MongoDB测试 41
2.4　使用Neo4j 43
2.4.1　Neo4j依赖配置 43
2.4.2　节点和关系实体建模 43
2.4.3　节点实体持久化 45
2.4.4　Neo4j测试 46
2.5　小结 49
第3章　Spring Boot界面设计 50
3.1　模型设计 50
3.1.1　节点实体建模 51
3.1.2　关系实体建模 51
3.1.3　分页查询设计 52
3.2　控制器设计 53
3.2.1　新建控制器 53
3.2.2　查看控制器 53
3.2.3　修改控制器 54
3.2.4　删除控制器 55
3.2.5　分页查询控制器 55
3.3　使用Thymeleaf模板 56
3.3.1　Thymeleaf配置 56
3.3.2　Thymeleaf功能简介 57
3.4　视图设计 60
3.4.1　列表视图设计 60
3.4.2　新建视图设计 64
3.4.3　查看视图设计 68
3.4.4　修改视图设计 70
3.4.5　删除视图设计 72
3.5　运行与发布 73
3.6　小结 74
第4章　提高数据库访问性能 75
4.1　使用Druid 75
4.1.1　配置Druid依赖 76
4.1.2　关于XML配置 76
4.1.3　Druid数据源配置 77
4.1.4　开启监控功能 78
4.2　扩展JPA功能 80
4.2.1　扩展JPA接口 81
4.2.2　装配自定义的扩展接口 83
4.2.3　使用扩展接口 85
4.3　使用Redis做缓存 86
4.3.1　使用Spring Cache注解 86
4.3.2　使用RedisTemplate 88
4.4　Web应用模块 91
4.4.1　引用数据管理模块 91
4.4.2　Web应用配置 92
4.5　运行与发布 94
4.6　小结 95
第5章　Spring Boot安全设计 96
5.1　依赖配置管理 96
5.2　安全策略配置 97
5.2.1　权限管理规则 98
5.2.2　登录成功处理器 99
5.2.3　防攻击策略 100
5.2.4　记住登录状态 102
5.3　登录认证设计 103
5.3.1　用户实体建模 103
5.3.2　用户身份验证 104
5.3.3　登录界面设计 106
5.3.4　验证码验证 108
5.4　权限管理设计 109
5.4.1　权限管理配置 109
5.4.2　权限管理过滤器 110
5.4.3　权限配置资源管理器 111
5.4.4　权限管理决断器 112
5.5　根据权限设置链接 113
5.6　运行与发布 116
5.6.1　系统初始化 116
5.6.2　系统运行与发布 118
5.7　小结 119
第二部分　分布式应用开发
第6章　Spring Boot SSO 123
6.1　模块化设计 123
6.2　登录认证模块 124
6.2.1　使用OAuth2 124
6.2.2　创建数字证书 125
6.2.3　认证服务端配置 125
6.3　安全配置模块 128
6.4　SSO客户端 129
6.4.1　客户端配置 129
6.4.2　登录登出设计 130
6.5　共享资源服务 132
6.5.1　提供共享资源接口 133
6.5.2　使用共享资源 134
6.5.3　查询登录用户的详细信息 135
6.6　运行与发布 136
6.7　小结 138
第7章　使用分布式文件系统 139
7.1　FastDFS安装 139
7.1.1　下载安装包 141
7.1.2　安装服务 141
7.1.3　Tracker Server配置 142
7.1.4　Storage Server配置 145
7.1.5　启动服务 148
7.1.6　客户端测试 148
7.2　FastFDS客户端 149
7.2.1　客户端配置 150
7.2.2　客户端服务类 150
7.3　使用定制方式上传图片 151
7.3.1　实体建模 151
7.3.2　上传图片 152
7.4　使用富文本编辑器上传图片 156
7.4.1　使用富文本编辑器 156
7.4.2　实现文件上传 157
7.5　使用本地文件库 158
7.5.1　本地文件库建模 159
7.5.2　文件保存方法 159
7.5.3　文件库管理 161
7.6　运行与发布 163
7.7　小结 164
第8章　云应用开发 165
8.1　使用配置管理 166
8.1.1　创建配置管理服务器 167
8.1.2　使用配置管理的客户端 168
8.1.3　实现在线更新 171
8.1.4　更新所有客户端的配置 172
8.2　使用发现服务 174
8.2.1　创建发现服务器 174
8.2.2　使用发现服务的客户端配置 175
8.2.3　发现服务器测试 175
8.3　使用动态路由和断路器 176
8.3.1　依赖配置 176
8.3.2　共享REST资源 177
8.3.3　通过路由访问REST资源 180
8.3.4　使用断路器功能 182
8.3.5　路由器和断路器测试 183
8.4　使用监控服务 184
8.4.1　创建监控服务器 184
……
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入实践Spring Boot
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入浅出Spring Boot 2.x
第　1章 Spring Boot来临　1
1.1　Spring的历史　1
1.2　注解还是XML　2
1.3　Spring Boot的优点　3
1.4　传统Spring MVC和Spring Boot的对比　4
第　2章 聊聊开发环境搭建和基本开发　10
2.1　搭建Spring Boot开发环境　10
2.1.1　搭建Eclipse开发环境　10
2.1.2　搭建IntelliJ IDEA开发环境　13
2.2　Spring Boot的依赖和自动配置　15
2.3　使用自定义配置　19
2.4　开发自己的Spring Boot项目　21
第3章　全注解下的Spring IoC　23
3.1　IoC容器简介　23
3.2　装配你的Bean　27
3.2.1　通过扫描装配你的Bean　27
3.2.2　自定义第三方Bean　31
3.3　依赖注入　32
3.3.1　注解@Autowired　34
3.3.2　消除歧义性——@Primary和@Quelifier　35
3.3.3　带有参数的构造方法类的装配　36
3.4　生命周期　37
3.5　使用属性文件　42
3.6　条件装配Bean　45
3.7　Bean的作用域　46
3.8　使用@Profile　48
3.9　引入XML配置Bean　50
3.10　使用Spring EL　51
第4章　开始约定编程——Spring AOP　53
4.1　约定编程　53
4.1.1　约定　53
4.1.2　ProxyBean的实现　57
4.1.3　总结　60
4.2　AOP的概念　61
4.2.1　为什么使用AOP　61
4.2.2　AOP 术语和流程　64
4.3　AOP开发详解　65
4.3.1　确定连接点　65
4.3.2　开发切面　66
4.3.3　切点定义　67
4.3.4　测试AOP　68
4.3.5　环绕通知　71
4.3.6　引入　72
4.3.7　通知获取参数　74
4.3.8　织入　75
4.4　多个切面　77
第5章　访问数据库　82
5.1　配置数据源　83
5.1.1　启动默认数据源　83
5.1.2　配置自定义数据源　83
5.2　使用JdbcTemplate操作数据库　86
5.3　使用JPA（Hibernate）操作数据　90
5.3.1　概述　90
5.3.2　开发JPA　90
5.4　整合MyBatis框架　96
5.4.1　MyBatis简介　96
5.4.2　MyBatis的配置　97
5.4.3　Spring Boot整合MyBatis　101
5.4.4　MyBatis的其他配置　104
第6章　聊聊数据库事务处理　107
6.1　JDBC的数据库事务　108
6.2　Spring声明式事务的使用　110
6.2.1　Spring声明式数据库事务约定　110
6.2.2　@Transactional的配置项　111
6.2.3　Spring事务管理器　113
6.2.4　测试数据库事务　114
6.3　隔离级别　118
6.3.1　数据库事务的知识　118
6.3.2　详解隔离级别　120
6.4　传播行为　124
6.4.1　传播行为的定义　125
6.4.2　测试传播行为　126
6.5　@Transactional自调用失效问题　130
第7章　使用性能利器——Redis　134
7.1　spring-data-redis项目简介　135
7.1.1　spring-data-redis项目的设计　135
7.1.2　RedisTemplate　137
7.1.3　Spring对Redis数据类型操作的封装　139
7.1.4　SessionCallback和RedisCallback接口　141
7.2　在Spring Boot中配置和使用Redis　142
7.2.1　在Spring Boot中配置Redis　142
7.2.2　操作Redis数据类型　143
7.3　Redis的一些特殊用法　148
7.3.1　使用Redis事务　148
7.3.2　使用Redis流水线　149
7.3.3　使用Redis发布订阅　150
7.3.4　使用Lua脚本　153
7.4　使用Spring缓存注解操作Redis　156
7.4.1　缓存管理器和缓存的启用　156
7.4.2　开发缓存注解　157
7.4.3　测试缓存注解　163
7.4.4　缓存注解自调用失效问题　165
7.4.5　缓存脏数据说明　165
7.4.6　自定义缓存管理器　166
第8章　文档数据库——MongoDB　168
8.1　配置MongoDB　169
8.2　使用MongoTemplate实例　170
8.2.1　搭建开发环境　170
8.2.2　使用MongoTemplate操作文档　173
8.3　使用JPA　178
8.3.1　基本用法　178
8.3.2　使用自定义查询　180
第9章　初识Spring MVC　183
9.1　Spring MVC框架的设计　183
9.2　Spring MVC流程　184
9.3　定制Spring MVC的初始化　191
9.4　Spring MVC实例　192
9.4.1　开发控制器　193
9.4.2　视图和视图渲染　194
第　10章 深入Spring MVC开发　197
10.1　处理器映射　197
10.2　获取控制器参数　198
10.2.1　在无注解下获取参数　199
10.2.2　使用@RequestParam获取参数　199
10.2.3　传递数组　200
10.2.4　传递JSON　200
10.2.5　通过URL传递参数　203
10.2.6　获取格式化参数　204
10.3　自定义参数转换规则　205
10.3.1　处理器获取参数逻辑　205
10.3.2　一对一转换器（Converter）　208
10.3.3　GenericConverter集合和数组转换　210
10.4　数据验证　211
10.4.1　JSR-303 验证　211
10.4.2　参数验证机制　214
10.5　数据模型　217
10.6　视图和视图解析器　219
10.6.1　视图设计　219
10.6.2　视图实例——导出PDF文件　220
10.7　文件上传　224
10.7.1　Spring MVC对文件上传的支持　224
10.7.2　开发文件上传功能　226
10.8　拦截器　228
10.8.1　拦截器的设计　228
10.8.2　开发拦截器　229
10.8.3　多个拦截器的顺序　231
10.9　国际化　234
10.9.1　国际化消息源　234
10.9.2　国际化解析器　235
10.9.3　国际化实例——SessionLocaleResolver　237
10.10　Spring MVC拾遗　240
10.10.1　@ResponseBody转换为JSON的秘密　240
10.10.2　重定向　241
10.10.3　操作会话对象　243
10.10.4　给控制器增加通知　245
10.10.5　获取请求头参数　247
第　11章 构建REST风格网站　249
11.1　REST简述　249
11.1.1　REST名词解释　249
11.1.2　HTTP的动作　250
11.1.3　REST风格的一些误区　251
11.2　使用Spring MVC开发REST风格端点　251
11.2.1　Spring MVC整合REST　252
11.2.2　使用Spring开发REST风格的端点　252
11.2.3　使用@RestController　260
11.2.4　渲染结果　261
11.2.5　处理HTTP状态码、异常和响应头　262
11.3　客户端请求RestTemplate　266
11.3.1　使用RestTemplate请求后端　267
11.3.2　获取响应头、状态码和资源交换　269
第　12章 安全——Spring Security　271
12.1　概述和简单安全认证　271
12.2　使用WebSecurityConfigurerAdapter自定义　273
12.3　自定义用户服务信息　274
12.3.1　使用内存签名服务　275
12.3.2　使用数据库定义用户认证服务　276
12.3.3　使用自定义用户认证服务　279
12.4　限制请求　281
12.4.1　配置请求路径访问权限　282
12.4.2　使用Spring表达式配置访问权限　283
12.4.3　强制使用HTTPS　285
12.4.4　防止跨站点请求伪造　285
12.5　用户认证功能　287
12.5.1　自定义登录页面　287
12.5.2　启用HTTP Basic认证　288
12.5.3　登出　289
第　13章 学点Spring其他的技术　291
13.1　异步线程池　291
13.1.1　定义线程池和开启异步可用　292
13.1.2　异步实例　292
13.2　异步消息　294
13.2.1　JMS实例——ActiveMQ　295
13.2.2　使用AMQP——RabbitMQ　299
13.3　定时任务　303
13.4　WebSocket 应用　306
13.4.1　开发简易的WebSocket服务　306
13.4.2　使用STOMP　311
第　14章 Spring 5新框架——WebFlux　319
14.1　基础概念　319
14.1.1　响应式编程的宣言　320
14.1.2　Reactor模型　320
14.1.3　Spring WebFlux的概述　322
14.1.4　WebHandler接口和运行流程　323
14.2　通过Spring MVC方式开发WebFlux服务端　325
14.2.1　开发持久层　325
14.2.2　开发服务层　327
14.2.3　开发控制层　328
14.2.4　配置服务　330
14.2.5　客户端开发——WebClient　331
14.3　深入WebFlux服务端开发　335
14.3.1　类型转换器——Converter　335
14.3.2　验证器——Validator　337
14.3.3　访问静态资源　338
14.4　深入客户端开发　339
14.4.1　处理服务端错误和转换　339
14.4.2　设置请求头　341
14.5　使用路由函数方式开发WebFlux　342
14.5.1　开发处理器　342
14.5.2　开发请求路由　346
14.5.3　使用过滤器　347
第　15章 实践一下——抢购商品　349
15.1　设计与开发　349
15.1.1　数据库表设计　349
15.1.2　使用MyBatis开发持久层　350
15.1.3　使用Spring开发业务层和控制层　353
15.1.4　测试和配置　355
15.2　高并发开发　357
15.2.1　超发现象　357
15.2.2　悲观锁　358
15.2.3　乐观锁　359
15.2.4　使用Redis处理高并发　365
第　16章 部署、测试和监控　371
16.1　部署和运行　371
16.1.1　打包　371
16.1.2　运行项目　373
16.1.3　热部署　375
16.2　测试　376
16.2.1　构建测试类　376
16.2.2　使用随机端口和REST风格测试　377
16.2.3　Mock测试　378
16.3　Actuator监控端点　379
16.4　HTTP监控　381
16.4.1　查看敏感信息　382
16.4.2　shutdown端点　383
16.4.3　配置端点　385
16.4.4　自定义端点　387
16.4.5　健康指标项　389
16.5　JMX监控　392
第　17章 分布式开发——Spring Cloud　393
17.1　服务治理和服务发现——Eureka　395
17.1.1　配置服务治理节点　395
17.1.2　服务发现　397
17.1.3　配置多个服务治理中心节点　401
17.2　微服务之间的调用　403
17.2.1　Ribbon客户端负载均衡　403
17.2.2　Feign声明式调用　406
17.3　断路器——Hystrix　409
17.3.1　使用降级服务　410
17.3.2　启用Hystrix仪表盘　412
17.4　路由网关——Zuul　415
17.4.1　构建Zuul网关　415
17.4.2　使用过滤器　418
17.5　使用@SpringCloudApplication　421
附录　Spring Boot知识点补充　423
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入浅出Spring Boot 2.x
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring 5高级编程（第5版）
目录
第1章 Spring介绍  1
1.1 什么是Spring  1
1.1.1 Spring框架的演变  1
1.1.2 翻转控制或依赖注入  5
1.1.3 依赖注入的演变  6
1.1.4 除了依赖注入  7
1.2 Spring项目  10
1.2.1 Spring的起源  10
1.2.2 Spring社区  10
1.2.3 Spring工具套件  11
1.2.4 Spring Security项目  11
1.2.5 Spring Boot  11
1.2.6 Spring批处理和集成  11
1.2.7 许多其他项目  11
1.3 Spring的替代品  12
1.3.1 JBoss Seam框架  12
1.3.2 Google Guice  12
1.3.3 PicoContainer  12
1.3.4 JEE 7容器  12
1.4 小结  12
第2章 入门  13
2.1 获取Spring框架  13
2.1.1 快速入门  13
2.1.2 在GitHub中查找Spring  14
2.1.3 使用正确的JDK  14
2.2 了解Spring打包  14
2.2.1 为自己的应用程序选择模块  15
2.2.2 在Maven存储库上访问Spring模块  15
2.2.3 使用Gradle访问Spring模块  16
2.2.4 使用Spring文档  17
2.2.5 将Spring放入Hello World中  17
2.2.6 构建示例Hello World应用程序  17
2.2.7 用Spring重构  20
2.3 小结  22
第3章 在Spring中引入IoC和DI  23
3.1 控制反转和依赖注入  23
3.2 控制反转的类型  23
3.2.1 依赖拉取  24
3.2.2 上下文依赖查找  24
3.2.3 构造函数依赖注入  25
3.2.4 setter依赖注入  25
3.2.5 注入与查找  25
3.2.6 setter注入与构造函数注入  26
3.3 Spring中的控制反转  28
3.4 Spring中的依赖注入  28
3.4.1 bean和BeanFactory  28
3.4.2 BeanFactory实现  29
3.4.3 ApplicationContext  30
3.5 配置ApplicationContext  30
3.5.1 设置Spring配置选项  30
3.5.2 基本配置概述  30
3.5.3 声明Spring组件  31
3.5.4 使用方法注入  53
3.5.5 了解bean命名  60
3.5.6 了解bean实例化模式  66
3.6 解析依赖项  69
3.7 自动装配bean  71
3.8 设置bean继承  77
3.9 小结  79
第4章 详述Spring配置和Spring Boot  80
4.1 Spring对应用程序可移植性的影响  80
4.2 管理bean生命周期  81
4.3 挂钩到bean的创建  82
4.3.1 在创建bean时执行方法  82
4.3.2 实现InitializingBean接口  84
4.3.3 使用JSR-250 @PostConstruct注解  86
4.4 使用@Bean声明一个初始化方法  88
4.5 挂钩到bean的销毁  89
4.5.1 在bean被销毁时执行一个方法  89
4.5.2 实现DisposableBean接口  91
4.5.3 使用JSR-250 @PreDestroy注解  92
4.6 使用@Bean声明销毁方法  93
4.7 了解解析的顺序  94
4.8 让Spring感知bean  94
4.8.1 使用BeanNameAware接口  95
4.8.2 使用ApplicationContextAware接口  96
4.9 使用FactoryBean  97
4.10 直接访问FactoryBean  100
4.11 使用factory-bean和factory-method属性  101
4.12 JavaBean PropertyEditor  102
4.12.1 使用内置的PropertyEditor  102
4.12.2 创建自定义PropertyEditor  106
4.13 更多的Spring ApplicationContext配置  108
4.13.1 使用MessageSource进行国际化  108
4.13.2 在独立的应用程序中使用MessageSource  110
4.13.3 应用程序事件  111
4.14 访问资源  112
4.15 使用Java类进行配置  113
4.15.1 Java中的ApplicationContext配置  113
4.15.2 Spring混合配置  119
4.15.3 Java或XML配置？  121
4.16 配置文件  121
4.17 使用Java配置来配置Spring配置文件  123
4.18 Environment和PropertySource抽象  125
4.19 使用JSR-330注解进行配置  128
4.20 使用Groovy进行配置  130
4.21 Spring Boot  132
4.22 小结  135
第5章 Spring AOP  136
5.1 AOP概念  137
5.2 AOP的类型  137
5.2.1 使用静态AOP  137
5.2.2 使用动态AOP  137
5.2.3 选择AOP类型  138
5.3 Spring中的AOP  138
5.3.1 AOP Alliance  138
5.3.2 AOP中的Hello World示例  138
5.4 Spring AOP架构  139
5.4.1 Spring中的连接点  139
5.4.2 Spring中的切面  140
5.4.3 关于ProxyFactory类  140
5.4.4 在Spring中创建通知  140
5.4.5 通知的接口  141
5.4.6 创建前置通知  141
5.4.7 通过使用前置通知保护方法访问  142
5.4.8 创建后置返回通知  145
5.4.9 创建环绕通知  147
5.4.10 创建异常通知  148
5.4.11 选择通知类型  150
5.5 在Spring中使用顾问和切入点  150
5.5.1 Pointcut接口  151
5.5.2 可用的切入点实现  152
5.5.3 使用DefaultPointcutAdvisor  152
5.5.4 使用StaticMethodMatcherPointcut创建静态切入点  153
5.5.5 使用DyanmicMethodMatcherPointcut创建动态切入点  155
5.5.6 使用简单名称匹配  157
5.5.7 用正则表达式创建切入点  158
5.5.8 使用AspectJ切入点表达式创建切入点  159
5.5.9 创建注解匹配切入点  160
5.5.10 便捷的Advisor实现  161
5.6 了解代理  161
5.6.1 使用JDK动态代理  162
5.6.2 使用CGLIB代理  162
5.6.3 比较代理性能  163
5.6.4 选择要使用的代理  165
5.7 切入点的高级使用  166
5.7.1 使用控制流切入点  166
5.7.2 使用组合切入点  168
5.7.3 组合和切入点接口  170
5.7.4 切入点小结  170
5.8 引入入门  170
5.8.1 引入的基础知识  171
5.8.2 使用引入进行对象修改检测  172
5.8.3 引入小结  175
5.9 AOP的框架服务  175
5.9.1 以声明的方式配置AOP  175
5.9.2 使用ProxyFactoryBean  176
5.9.3 使用aop名称空间  180
5.10 使用@AspectJ样式注解  184
5.11 AspectJ集成  189
5.11.1 关于AspectJ  189
5.11.2 使用单例切面  189
5.12 小结  191
第6章 Spring JDBC支持  192
6.1 介绍Lambda表达式  192
6.2 示例代码的示例数据模型  193
6.3 研究JDBC基础结构  196
6.4 Spring JDBC基础结构  199
6.5 数据库连接和数据源  200
6.6 嵌入数据库支持  203
6.7 在DAO类中使用DataSource  204
6.8 异常处理  206
6.9 JdbcTemplate类  207
6.9.1 在DAO类中初始化JdbcTemplate  207
6.9.2 通过NamedParameterJdbcTemplate使用命名参数  209
6.9.3 使用RowMapper检索域对象  210
6.10 使用ResultSetExtractor检索嵌套域对象  211
6.11 建模JDBC操作的Spring类  213
6.12 使用MappingSqlQuery查询数据  215
6.13 插入数据并检索生成的键  220
6.14 使用BatchSqlUpdate进行批处理操作  221
6.15 使用SqlFunction调用存储函数  225
6.16 Spring Data项目：JDBC Extensions  226
6.17 使用JDBC的注意事项  226
6.18 Spring Boot JDBC  227
6.19 小结  229
第7章 在Spring中使用Hibernate  230
7.1 示例代码的示例数据模型  230
7.2 配置Hibernate的SessionFactory  232
7.3 使用Hibernate注解的ORM映射  234
7.3.1 简单的映射  235
7.3.2 一对多映射  238
7.3.3 多对多映射  239
7.4 Hibernate会话接口  240
7.4.1 使用Hibernate查询语言查询数据  241
7.4.2 使用延迟获取进行简单查询  241
7.4.3 使用关联获取进行查询  243
7.5 插入数据  245
7.6 更新数据  248
7.7 删除数据  249
7.8 配置Hibernate以便从实体生成表  250
7.9 注解方法或字段？  252
7.10 使用Hibernate时的注意事项  254
7.11 小结  254
第8章 在Spring中使用JPA 2进行数据访问  255
8.1 JPA 2.1介绍  255
8.1.1 示例代码的示例数据模型  256
8.1.2 配置JPA的EntityManagerFactory  256
8.1.3 使用JPA注解进行ORM映射  258
8.2 使用JPA执行数据库操作  259
8.2.1 使用Java持久化查询语言来查询数据  260
8.2.2 查询非类型化结果  266
8.3 使用构造函数表达式查询自定义结果类型  267
8.3.1 插入数据  269
8.3.2 更新数据  271
8.3.3 删除数据  272
8.4 使用本地查询  273
8.5 使用简单的本地查询  273
8.6 使用SQL ResultSet映射进行本地查询  274
8.7 Spring Data JPA介绍  278
8.7.1 添加Spring Data JPA库依赖项  279
8.7.2 使用Spring Data JPA Repository抽象进行数据库操作  279
8.8 使用JpaRepository  283
8.9 带有自定义查询的Spring Data JPA  284
8.10 通过使用Hibernate Envers保存实体版本  293
8.10.1 为实体版本控制添加表  293
8.10.2 为实体版本控制配置EntityManagerFactory  294
8.10.3 启用实体版本控制和历史检索  296
8.10.4 测试实体版本控制  297
8.11 Spring Boot JPA  298
8.12 使用JPA时的注意事项  302
8.13 小结  302
第9章 事务管理  303
9.1 研究Spring事务抽象层  303
9.2 PlatformTransactionManager的实现  304
9.3 分析事务属性  305
9.3.1 TransactionDefinition接口  305
9.3.2 TransactionStatus接口  306
9.4 示例代码的示例数据模型和基础结构  307
9.4.1 创建一个带有依赖项的简单Spring JPA项目  307
9.4.2 示例数据模型和通用类  308
9.4.3 使用AOP配置进行事务管理  315
9.5 使用编程式事务  316
9.6 使用Spring实现全局事务  318
9.6.1 实现JTA示例的基础结构  318
9.6.2 使用JTA实现全局事务  319
9.6.3 Spring Boot JTA  325
9.6.4 使用JTA事务管理器的注意事项  328
9.7 小结  329
第10章 使用类型转换和格式化进行验证  330
10.1 依赖项  330
10.2 Spring类型转换系统  331
10.3 使用PropertyEditors从字符串进行转换  331
10.4 Spring类型转换介绍  333
10.4.1 实现自定义转换器  333
10.4.2 配置ConversionService  334
10.4.3 任意类型之间的转换  335
10.5 Spring中的字段格式化  338
10.5.1 实现自定义格式化器  338
10.5.2 配置ConversionServiceFactoryBean  339
10.6 Spring中的验证  340
10.6.1 使用Spring Validator接口  340
10.6.2 使用JSR-349 Bean Validation  342
10.6.3 在Spring中配置Bean Validation支持  343
10.6.4 创建自定义验证器  344
10.7 使用AssertTrue进行自定义验证  346
10.8 自定义验证的注意事项  347
10.9 决定使用哪种验证API  347
10.10 小结  347
第11章 任务调度  348
11.1 任务调度示例的依赖项  348
11.2 Spring中的任务调度  349
11.2.1 Spring TaskScheduler抽象介绍  349
11.2.2 研究示例任务  350
11.2.3 使用注解进行任务调度  355
11.2.4 Spring中异步任务的执行  357
11.3 Spring中任务的执行  359
11.4 小结  360
第12章 使用Spring远程处理  361
12.1 使用示例的数据模型  362
12.2 为JPA后端添加必需的依赖项  363
12.3 实现和配置SingerService  364
12.3.1 实现SingerService  364
12.3.2 配置SingerService  365
12.3.3 公开服务  367
12.3.4 调用服务  368
12.4 在Spring中使用JMS  369
12.4.1 在Spring中实现JMS监听器  371
12.4.2 在Spring中发送JMS消息  372
12.5 Spring Boot Artemis启动器  373
12.6 在Spring中使用RESTful-WS  375
12.6.1 RESTful Web服务介绍  375
12.6.2 为示例添加必需的依赖项  376
12.6.3 设计Singer RESTful Web服务  376
12.6.4 使用Spring MVC展示REST样式的Web服务  376
12.7 配置Castor XML  377
12.7.1 实现SingerController  378
12.7.2 配置Spring Web应用程序  380
12.7.3 使用curl测试RESTful-WS  382
12.7.4 使用RestTemplate访问RESTful-WS  383
12.7.5 使用Spring Security来保护RESTful-WS  386
12.8 使用Spring Boot开发RESTful-WS  389
12.9 在Spring中使用AMQP  392
12.10 小结  397
第13章 Spring测试  398
13.1 测试类别介绍  398
13.2 使用Spring测试注解  399
13.3 实施逻辑单元测试  400
13.3.1 添加所需的依赖项  400
13.3.2 单元测试Spring MVC控制器  401
13.4 实现集成测试  403
13.4.1 添加所需的依赖项  403
13.4.2 配置用于服务层测试的配置文件  403
13.4.3 Java配置版本  404
13.4.4 实施基础结构类  405
13.4.5 对服务层进行单元测试  408
13.4.6 丢弃DbUnit  410
13.5 实现前端单元测试  413
13.6 小结  413
第14章 Spring中的脚本支持  414
14.1 在Java中使用脚本支持  414
14.2 Groovy介绍  415
14.2.1 动态类型化  416
14.2.2 简化的语法  416
14.2.3 闭包  417
14.3 与Spring一起使用Groovy  418
14.3.1 开发Singer对象域  418
14.3.2 实现规则引擎  418
14.3.3 将规则工厂实现为Spring可刷新bean  420
14.3.4 测试年龄分类规则  421
14.3.5 内联动态语言代码  423
14.4 小结  424
第15章 应用程序监控  425
15.1 Spring中的JMX支持  425
15.2 将Spring bean导出为JMX  425
15.3 使用Java VisualVM进行JMX监控  426
15.4 监视Hibernate统计信息  428
15.5 使用了Spring Boot的JMX  429
15.6 小结  431
第16章 Web应用程序  432
16.1 实现示例的服务层  433
16.1.1 对示例使用数据模型  433
16.1.2 实现DAO层  435
16.1.3 实现服务层  435
16.2 配置SingerService  436
16.3 MVC和Spring MVC介绍  437
16.3.1 MVC介绍  438
16.3.2 Spring MVC介绍  438
16.3.3 Spring MVC WebApplicationContext层次结构  439
16.3.4 Spring MVC请求生命周期  439
16.3.5 Spring MVC配置  440
16.3.6 在Spring MVC中创建第一个视图  442
16.3.7 配置DispatcherServlet  443
16.3.8 实现SingerController  444
16.3.9 实现歌手列表视图  445
16.3.10 测试歌手列表视图  445
16.4 理解Spring MVC项目结构  445
16.5 实现国际化(il8n)  446
16.5.1 在DispatcherServlet配置中配置国际化  446
16.5.2 为国际化支持而修改歌手列表视图  448
16.6 使用主题和模板  448
16.7 使用Apache Tiles查看模板  450
16.7.1 设计模板布局  450
16.7.2 实现页面布局组件  451
16.8 在Spring MVC中配置Tiles  453
16.9 实现歌手信息视图  454
16.9.1 将URL映射到视图  454
16.9.2 实现显示歌手视图  454
16.9.3 实现编辑歌手视图  456
16.9.4 实现添加歌手视图  459
16.9.5 启用JSR-349(bean验证)  460
16.10 使用jQuery和jQuery UI  462
16.10.1 jQuery和jQuery UI介绍  462
16.10.2 在视图中使用jQuery和jQuery UI  462
16.10.3 使用CKEditor进行富文本编辑  463
16.10.4 使用jqGrid实现具有分页支持的数据网格  464
16.10.5 在歌手列表视图中启用jqGrid  464
16.10.6 在服务器端启用分页  466
16.11 处理文件上传  468
16.11.1 配置文件上传支持  468
16.11.2 修改视图以支持文件上传  469
16.11.3 修改控制器以支持文件上传  470
16.12 用Spring Security保护Web应用程序  471
16.12.1 配置Spring安全性  471
16.12.2 将登录功能添加到应用程序中  473
16.12.3 使用注解来保护控制器方法  475
16.13 使用Spring Boot创建Spring Web应用程序  475
16.14 设置DAO层  476
16.14.1 设置服务层  477
16.14.2 设置Web层  478
16.14.3 设置Spring安全性  479
16.15 创建Thymeleaf视图  479
16.16 使用Thymeleaf扩展  482
16.17 小结  486
第17章 WebSocket  487
17.1 WebSocket介绍  487
17.2 与Spring一起使用WebSocket  487
17.3 使用WebSocket API  488
17.4 使用STOMP发送消息  496
17.5 小结  500
第18章 Spring项目：批处理、集成和XD等  501
18.1 Spring Batch  502
18.2 JSR-352  507
18.3 Spring Boot Batch  509
18.4 Spring Integration  512
18.5 Spring XD  516
18.6 Spring框架的五个最显著的功能  517
18.6.1 功能性Web框架  518
18.6.2 Java 9 互操作性  526
18.6.3 JDK模块化  526
18.6.4 使用Java 9和Spring WebFlux进行反应式编程  528
18.6.5 Spring支持JUnit 5 Jupiter  529
18.7 小结  536
附录A 设置开发环境  537
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring 5高级编程（第5版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring MVC实战
1　企业级Spring应用的搭建.1
引言 1
安装Eclipse JEE开发者版本与Java SE 82
为Eclipse配置Java 8、Maven 3和Tomcat 8 5
定义Maven的项目结构 12
安装Spring、Spring MVC和Web结构24
2　使用Spring MVC设计微服务架构35
引言35
使用简单URL映射配置控制器 36
使用ViewResolver配置回退控制器 49
使用Bootstrap创建并自定义响应式单页面Web设计.53
使用JSTL在视图中显示模型 72
定义通用WebContentInterceptor82
使用AngularJS设计客户端MVC模式88
3　Java持久化与实体100
引言 100
在Spring中配置Java持久化API 101
定义有用的EJB3实体和关系105
使用JPA与Spring Data JPA  115
4　为无状态架构构建REST API122
引言 122
绑定请求与编排响应123
配置内容协商（JSON与XML等） 133
添加分页、过滤器与排序功能 138
全局处理异常149
使用Swagger生成文档与公开API 156
5　使用Spring MVC进行认证.163
引言 163
配置Apache HTTP服务器来代理Tomcat服务器 163
修改用户和角色以适应Spring Security 172
基于BASIC的认证方式.183
第三方OAuth2认证193
在REST环境中保存认证信息 211
服务与控制器授权 220
6　实现HATEOAS.235
引言 235
将DTO改造成Spring HATEOAS资源 236
为超媒体驱动的API创建链接 244
JPA实体的暴露策略 252
通过OAuth从第三方API获取数据259
7　开发CRUD操作与校验266
引言 266
为所有HTTP方法扩展REST处理程序.267
使用Bean Validation校验资源 278
REST消息与内容的国际化.292
使用HTML5和AngularJS校验客户端表单 302
8　通过WebSocket与STOMP进行通信.308
引言 308
通过基于SockJS的STOMP使社交事件流媒体化309
使用RabbitMQ作为多协议消息代理 322
将任务放入RabbitMQ并通过AMQP消费任务 328
通过Spring Session和Redis保证消息安全334
9　测试与故障排除351
引言 351
通过Flyway实现数据库迁移自动化352
使用Mockito和Maven Surefire进行单元测试 357
使用Cargo、Rest-assured和Maven Failsafe进行集成测试 364
在集成测试中注入Spring Bean 373
使用Log4j2记录日志的现代应用 377
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring MVC实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务
前言
第一部分　准备篇
第1章　Spring Cloud与微服务概述 2
1.1　传统的单体应用 2
1.1.1　改进单体应用的架构 2
1.1.2　向微服务靠拢 3
1.2　什么是微服务 4
1.2.1　使用微服务架构的优势和劣势 4
1.2.2　重构前的准备工作 5
1.3　什么是Spring Cloud 5
1.3.1　Spring Cloud模块介绍 5
1.3.2　Spring Cloud版本介绍 6
1.4　本章小结 7
第2章　实战前的准备工作 8
2.1　开发环境的准备 8
2.2　Spring Boot入门 9
2.2.1　Spring Boot简介 9
2.2.2　搭建Spring Boot项目 9
2.2.3　编写第一个REST接口 11
2.2.4　读取配置文件 11
2.2.5　profiles多环境配置 13
2.2.6　热部署 13
2.2.7　actuator监控 15
2.2.8　统一异常处理 16
2.2.9　异步执行 18
2.2.10　随机端口 21
2.3　本章小结 23
第二部分　基础篇
第3章　Eureka注册中心 26
3.1　Eureka 26
3.2　使用Eureka编写注册中心服务 27
3.3　编写服务提供者 29
3.3.1　创建项目注册到Eureka 29
3.3.2　编写提供接口 30
3.4　编写服务消费者 31
3.4.1　直接调用接口 31
3.4.2　通过Eureka来消费接口 32
3.5　开启Eureka认证 33
3.6　Eureka高可用搭建 33
3.6.1　高可用原理 33
3.6.2　搭建步骤 34
3.7　常用配置讲解 35
3.7.1　关闭自我保护 35
3.7.2　自定义Eureka的Instance ID 35
3.7.3　自定义实例跳转链接 36
3.7.4　快速移除已经失效的服务信息 37
3.8　扩展使用 38
3.8.1　Eureka REST API 38
3.8.2　元数据使用 40
3.8.3　EurekaClient使用 41
3.8.4　健康检查 43
3.8.5　服务上下线监控 45
3.9　本章小结 46
第4章　客户端负载均衡Ribbon 47
4.1　Ribbon 47
4.1.1　Ribbon模块 47
4.1.2　Ribbon使用 48
4.2　RestTemplate结合Ribbon使用 49
4.2.1　使用RestTemplate与整合Ribbon 49
4.2.2　RestTemplate负载均衡示例 52
4.2.3　@LoadBalanced注解原理 53
4.2.4　Ribbon API使用 57
4.2.5　Ribbon饥饿加载 58
4.3　负载均衡策略介绍 59
4.4　自定义负载策略 60
4.5　配置详解 61
4.5.1　常用配置 61
4.5.2　代码配置Ribbon 62
4.6　重试机制 63
4.7　本章小结 64
第5章　声明式REST客户端Feign 65
5.1　使用Feign调用服务接口 65
5.1.1　在Spring Cloud中集成Feign 66
5.1.2　使用Feign调用接口 66
5.2　自定义Feign的配置 67
5.2.1　日志配置 67
5.2.2　契约配置 69
5.2.3　Basic认证配置 69
5.2.4　超时时间配置 70
5.2.5　客户端组件配置 71
5.2.6　GZIP压缩配置 72
5.2.7　编码器解码器配置 72
5.3　脱离Spring Cloud 使用Feign 73
5.3.1　原生注解方式 73
5.3.2　构建Feign对象 74
5.3.3　其他配置 75
5.4　本章小结 76
第6章　Hystrix 服务容错处理 77
6.1　Hystrix 77
6.1.1　Hystrix的简单使用 77
6.1.2　回退支持 78
6.1.3　信号量策略配置 79
6.1.4　线程隔离策略配置 79
6.1.5　结果缓存 80
6.1.6　缓存清除 81
6.1.7　合并请求 83
6.2　在Spring Cloud中使用Hystrix 84
6.2.1　简单使用 84
6.2.2　配置详解 85
6.2.3　Feign整合Hystrix服务容错 88
6.2.4　Feign中禁用Hystrix 90
6.3　Hystrix监控 91
6.4　整合Dashboard查看监控数据 92
6.5　Turbine聚合集群数据 94
6.5.1　Turbine使用 94
6.5.2　context-path导致监控失败 95
6.6　本章小结 95
第7章　API网关 96
7.1　Zuul 简介 96
7.2　使用Zuul构建微服务网关 97
7.2.1　简单使用 97
7.2.2　集成Eureka 98
7.3　Zuul路由配置 98
7.4　Zuul过滤器讲解 99
7.4.1　过滤器类型 100
7.4.2　请求生命周期 100
7.4.3　使用过滤器 101
7.4.4　过滤器禁用 103
7.4.5　过滤器中传递数据 103
7.4.6　过滤器拦截请求 104
7.4.7　过滤器中异常处理 106
7.5　Zuul容错和回退 108
7.5.1　容错机制 108
7.5.2　回退机制 109
7.6　Zuul高可用 111
7.7　本章小结 111
第三部分　实战篇
第8章　分布式配置管理 114
8.1　自研配置管理框架Smconf简介 114
8.2　Smconf工作原理 115
8.3　Smconf 部署 116
8.3.1　Mongodb安装 116
8.3.2　Zookeeper安装 117
8.3.3　Smconf Server部署 118
8.4　项目中集成Smconf 119
8.4.1　集成Smconf 119
8.4.2　使用Smconf 120
8.4.3　配置更新回调 121
8.5　Smconf详细使用 122
8.5.1　源码编译问题 122
8.5.2　后台账号管理 122
8.5.3　REST API 123
8.6　Smconf源码解析 125
8.6.1　Client启动 125
8.6.2　启动加载配置 127
8.6.3　配置修改推送原理 128
8.7　本章小结 129
第9章　Sleuth服务跟踪 130
9.1　Spring Cloud集成Sleuth 130
9.2　整合Logstash 131
9.2.1　ELK简介 131
9.2.2　输出JSON格式日志 131
9.3　整合Zipkin 133
9.3.1　创建Zipkin数据收集服务 133
9.3.2　项目集成Zipkin发送调用链数据 134
9.3.3　抽样采集数据 135
9.3.4　用RabbitMq代替Http发送调用链数据 135
9.3.5　用Elasticsearch存储调用链数据 136
9.4　本章小结 137
第10章　微服务之间调用的安全认证 138
10.1　什么是JWT 138
10.2　创建统一的认证服务 139
10.2.1　表结构 139
10.2.2　JWT工具类封装 139
10.2.3　认证接口 141
10.3　服务提供方进行调用认证 142
10.4　服务消费方申请Token 143
10.5　Feign调用前统一申请Token传递到调用的服务中 145
10.6　Zuul中传递Token到路由的服务中 147
10.7　本章小结 148
第11章　Spring Boot Admin 149
11.1　Spring Boot Admin的使用方法 149
11.1.1　创建Spring Boot Admin项目 149
11.1.2　将服务注册到Spring Boot Admin 150
11.1.3　如何在Admin中查看各个服务的日志 151
11.2　开启认证 152
11.3　集成Eureka 153
11.4　集成Turbine 154
11.5　监控服务 155
11.5.1　邮件警报 156
11.5.2　自定义钉钉警报 156
11.6　本章小结 159
第12章　服务的API文档管理 160
12.1　Swagger简介 160
12.2　集成Swagger管理API文档 161
12.2.1　封装Swagger Starter 161
12.2.2　在项目中集成Swagger starter 162
12.2.3　使用Swagger生成文档 162
12.2.4　在线测试接口 163
12.3　Swagger注解 164
12.4　Eureka 控制台快速查看Swagger文档 169
12.5　本章小结 169
第四部分　高级篇
第13章　API网关扩展 172
13.1　用户认证 172
13.1.1　动态管理不需要拦截的API请求 172
13.1.2　创建认证的用户服务 174
13.1.3　路由之前的认证 175
13.1.4　向下游微服务中传递认证之后的用户信息 176
13.1.5　内部服务间的用户信息传递 177
13.2　服务限流 179
13.2.1　限流算法 179
13.2.2　单节点限流 179
13.2.3　集群限流 184
13.2.4　具体服务限流 187
13.2.5　具体接口限流 188
13.3　服务降级 194
13.4　灰度发布 196
13.4.1　原理讲解 196
13.4.2　根据用户做灰度发布 197
13.4.3　根据IP做灰度发布 200
13.5　本章小结 200
第14章　微服务之缓存 201
14.1　Guava Cache本地缓存 201
14.1.1　Guava Cache简介 201
14.1.2　代码示例 202
14.1.3　回收策略 202
14.2　Redis缓存 203
14.2.1　用Redistemplate 操作Redis 203
14.2.2　用Repository操作Redis 204
14.2.3　Spring Cache 缓存数据 206
14.2.4　扩展Spring Cache支持对每个缓存的时间配置 211
14.2.5　缓存异常处理 212
14.2.6　自定义缓存工具类 214
14.3　防止缓存穿透方案 216
14.3.1　什么是缓存穿透 216
14.3.2　缓存穿透的危害 216
14.3.3　解决方案 217
14.3.4　布隆过滤器介绍 217
14.3.5　代码示例 217
14.4　防止缓存雪崩方案 219
14.4.1　什么是缓存雪崩 219
14.4.2　缓存雪崩的危害 219
14.4.3　解决方案 219
14.4.4　代码示例 219
14.4.5　分布式锁方式 220
14.5　本章小结 221
第15章　微服务之存储 222
15.1　存储选型 222
15.2　Mongodb 223
15.2.1　集成Spring Data Mongodb 223
15.2.2　添加数据操作 223
15.2.3　索引使用 225
15.2.4　修改数据操作 227
15.2.5　删除数据操作 228
15.2.6　查询数据操作 229
15.2.7　GridFS操作 231
15.2.8　用Repository方式操作数据 232
15.2.9　自增ID实现 236
15.2.10　批量更新扩展 239
15.3　Mysql 243
15.3.1　集成Spring JdbcTemplate 243
15.3.2　JdbcTemplate代码示例 243
15.3.3　封装JdbcTemplate 操作Mysql更简单 244
15.3.4　扩展JdbcTemplate使用方式 244
15.3.5　常见问题 248
15.4　Elasticsearch 251
15.4.1　集成Spring Data Elasticsearch 251
15.4.2　Repository示例 251
15.4.3　ElasticsearchTemplate示例 254
15.4.4　索引构建方式 257
15.5　本章小结 259
第16章　微服务之分布式事物解决方案 260
16.1　两阶段型 260
16.2　TCC补偿型 261
16.3　最终一致性 261
16.3.1　原理讲解 261
16.3.2　创建可靠性消息服务 263
16.3.3　消息存储表设计 264
16.3.4　提供服务接口 265
16.3.5　创建消息发送系统 269
16.3.6　消费消息逻辑 273
16.3.7　消息管理系统 275
16.4　最大努力通知型事物 276
16.4.1　介绍 276
16.4.2　原理 276
16.5　本章小结 276
第17章　分布式任务调度 277
17.1　Elastic-Job 277
17.1.1　Elastic-Job介绍 277
17.1.2　任务调度目前存在的问题 277
17.1.3　为什么选择Elastic-Job 278
17.2　快速集成 279
17.3　任务使用 280
17.3.1　简单任务 280
17.3.2　数据流任务 281
17.3.3　脚本任务 282
17.4　配置参数讲解 282
17.4.1　注册中心配置 283
17.4.2　作业配置 283
17.4.3　dataflow独有配置 284
17.4.4　script独有配置 284
17.5　多节点并行调度 285
17.5.1　分片概念 285
17.5.2　任务节点分片策略 285
17.5.3　业务数据分片处理 286
17.6　事件追踪 289
17.7　扩展功能 290
17.7.1　自定义监听器 290
17.7.2　定义异常处理 291
17.8　运维平台 291
17.8.1　功能列表 292
17.8.2　部署运维平台 292
17.8.3　运维平台使用 293
17.9　使用经验分享 296
17.9.1　任务的划分和监控 296
17.9.2　任务的扩展性和节点数量 297
17.9.3　任务的重复执行 297
17.9.4　overwrite覆盖问题 298
17.9.5　流水式任务 298
17.10　本章小结 299
第18章　分库分表解决方案 300
18.1　Sharding-JDBC 300
18.1.1　介绍 300
18.1.2　功能列表 301
18.1.3　相关概念 301
18.2　快速集成 302
18.3　读写分离实战 304
18.3.1　准备数据 304
18.3.2　配置读写分离 304
18.3.3　验证读从库 305
18.3.4　验证写主库 307
18.3.5　Hint强制路由主库 308
18.4　分库分表实战 309
18.4.1　常用分片算法 310
18.4.2　使用分片算法 310
18.4.3　不分库只分表实战 311
18.4.4　既分库又分表实战 314
18.5　分布式主键 317
18.6　本章小结 319
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>J2EE设计开发编程指南
第1章 J2EE体系结构
第2章 J2EE项目的选择与风险
第3章 J2EE应用的测试
第4章 J2EE项目的设计技术与编程标准
第5章 示例应用的需求
第6章 应用J2EE技术
第7章 J2EE应用中的数据存取
第8章 使用实体组件进行数据存取
第9章 实际的数据存取
第10章 会话组件
第11章 基础结构与应用实现
第12章 Web层的MVC设计
第13章 Web层中的视图
第14章 应用的包装与部署
第15章 应用的性能测试与调整
第16章 结论：让J2EE为我所用
附录A 实现视图技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>J2EE设计开发编程指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Spring
第1章  Spring基础知识第2章  开始Spring之旅第3章  贯穿Spring应用的核心理念第4章  模式：Spring前行的路标第5章  Spring核心Bean工厂装配指南第6章  ApplicationContext和更多特性第7章  Spring面向方面编程基础第8章  面向方面编程(AOP)高级应用第9章  J2EE的持久化数据访问方案第10章  Spring和J2EE持久化数据访问第11章  传统的企业JavaBean(EJB)第12章  Spring和EJB第13章  Spring和邮件服务第14章  Spring和派程(scheduling)技术第15章  J2EE中流行的Web MVC框架第16章  请求驱动的Spring Web MVC框架第17章  Spring和视图技术及Web框架的集成第18章  Spring和单元测试第19章  Spring和JMX技术第20章  从Spring宠物店看企业应用架构模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Spring
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序开发大全
第1章 初识myeclipse 1
1.1 myeclipse简介 1
1.2 myeclipse的安装 1
1.2.1 jdk的安装与配置 1
1.2.2 myeclipse 7.0的安装和运行 4
1.3 获取和阅读myeclipse帮助文档 5
1.4 本章小结 5
第2章 myeclipse集成开发环境的使用 6
2.1 myeclipse集成开发工具界面 6
2.1.1 myeclipse的菜单栏 7
2.1.2 myeclipse的工具栏 13
2.1.3 myeclipse的透视图 14
2.1.4 myeclipse的视图 17
2.1.5 myeclipse的编辑器 20
2.1.6 myeclipse的tasks视图 22
2.1.7 myeclipse的bookmarks视图 24
2.2 myeclipse中的资源管理 26
2.2.1 myeclipse中的工作空间 26
2.2.2 myeclipse中的navigator视图 27
2.3 定制myeclipse的工作台 33
.2.3.1 定制工作台外观 34
2.3.2 定制快捷键 35
2.3.3 定制编辑器 36
2.3.4 定制工作台公共设置 36
2.4 myeclipse中常用操作 36
2.4.1 配置jre 36
2.4.2 设置编译路径 37
2.4.3 设置项目属性 38
2.5 本章小结 39
第3章 java程序的开发 40
3.1 使用jdt编写java项目 40
3.2 myeclipse中的java代码编辑器 43
3.2.1 java代码编辑器基本功能 43
3.2.2 自定义java代码编辑器 45
3.2.3 java代码编辑器相关视图 50
3.3 myeclipse中的java代码编译器 51
3.4 myeclipse中的java代码调试器 52
3.4.1 java项目的运行 52
3.4.2 java项目的调试 53
3.5 myeclipse中的java代码搜索器 57
3.5.1 搜索功能 57
3.5.2 查找功能 58
3.6 myeclipse中的java代码重构支持 59
3.6.1 java元素重命名 59
3.6.2 java元素移动 60
3.6.3 java元素复制 61
3.7 本章小结 61
第4章 java开发的版本控制及svn 62
4.1 版本控制与svn 62
4.2 svn服务器的安装与配置 62
4.3 myeclipse连接svn服务器 63
4.3.1 配置myeclipse连接svn服务器 63
4.3.2 将svn服务器中的项目导入到myeclipse 64
4.3.3 将myeclipse中的项目提交到svn服务器 65
4.4 本章小结 67
第5章 java开发项目的软件测试工具——junit 68
5.1 软件测试简介 68
5.2 junit简介 68
5.2.1 junit的特点 69
5.2.2 junit的常用类和接口 69
5.3 在myeclipse中设置junit 71
5.4 junit测试 72
5.4.1 junit测试用例 72
5.4.2 junit测试套件 75
5.5 junit应用实例：数据库程序单元测试 77
5.6 本章小结 80
第6章 java web应用程序的开发 81
6.1 java web应用程序概述 81
6.2 tomcat服务器的安装和配置 82
6.2.1 tomcat服务器的下载 82
6.2.2 tomcat服务器的安装与配置 83
6.2.3 myeclipse中集成tomcat服务器 85
6.3 使用myeclipse开发web应用程序 86
6.3.1 创建web项目 87
6.3.2 创建html静态页面 88
6.3.3 创建jsp页面 90
6.3.4 创建servlet 91
6.3.5 创建web项目中的java类文件 92
6.3.6 发布和运行web项目 94
6.4 web应用实例：登录系统 96
6.5 本章小结 102
第7章 数据库应用程序的开发及应用 103
7.1 mysql数据库的安装与配置 103
7.2 myeclipse中的database explorer透视图 106
7.2.1 切换到database explorer透视图 107
7.2.2 连接到mysql数据库 107
7.2.3 打开数据库连接 108
7.2.4 关闭数据库连接 108
7.2.5 浏览数据库结构 109
7.2.6 编辑和执行sql语句 110
7.2.7 生成实体关系图 111
7.2.8 编辑和清除数据表中的数据 112
7.2.9 创建和删除数据表 112
7.2.10 创建和删除外键 113
7.2.11 自动生成sql语句 113
7.3 jdbc应用实例：登录系统 114
7.4 本章小结 116
第8章 struts框架的开发及应用 117
8.1 struts框架概述 117
8.1.1 mvc设计模式 117
8.1.2 struts框架工作原理 118
8.1.3 struts框架执行流程 118
8.2 myeclipse创建基于struts框架的项目 119
8.2.1 创建struts项目 119
8.2.2 struts组件向导 121
8.2.3 struts配置文件编辑器 124
8.3 struts应用实例：登录系统 125
8.4 本章小结 133
第9章 hibernate框架的开发及应用 134
9.1 hibernate框架概述 134
9.1.1 o/r mapping（对象/关系映射）技术 134
9.1.2 hibernate框架的作用 135
9.1.3 hibernate框架与jdbc技术的比较 135
9.1.4 hibernate框架工作流程 137
9.2 myeclipse创建基于hibernate框架的项目 138
9.2.1 创建hibernate项目 139
9.2.2 创建hibernate配置文件 140
9.2.3 创建hibernate使用的数据库连接 140
9.2.4 创建sessionfactory类 140
9.2.5 使用hibernate配置文件编辑器 141
9.2.6 使用反向工程生成持久化对象、映射文件和dao类 143
9.2.7 使用hibernate功能 151
9.3 myeclipse中hibernate框架的高级操作 152
9.3.1 在hibernate反向工程中定制映射关系 153
9.3.2 使用hql编辑器 154
9.4 hibernate应用实例：基于struts+hibernate的登录系统 155
9.5 本章小结 160
第10章 spring框架的开发及应用 161
10.1 spring框架概述 161
10.2 spring框架中的ioc编程 162
10.2.1 控制反转的原理 163
10.2.2 控制反转中的主要组件 163
10.2.3 控制反转中的依赖注入方式 164
10.3 spring框架中的aop编程 165
10.3.1 面向切面编程的原理 165
10.3.2 面向切面编程中的主要概念 166
10.4 使用myeclipse实现spring框架中的ioc编程 166
10.4.1 创建spring项目 166
10.4.2 创建bean类 167
10.4.3 配置bean类 168
10.4.4 编写测试代码 171
10.5 使用myeclipse实现spring框架中的aop编程 173
10.5.1 向项目添加aop支持包 173
10.5.2 创建bean类 173
10.5.3 创建前置通知类 174
10.5.4 装配拦截器和配置bean类 175
10.5.5 编写测试代码 176
10.6 spring整合struts框架 177
10.6.1 使用actionsupport类整合struts 177
10.6.2 覆盖requestprocessor类整合struts 178
10.6.3 将action管理委托给spring框架 180
10.7 spring整合hibernate框架 182
10.7.1 创建hibernate+spring项目 182
10.7.2 反向工程生成spring整合hibernate的dao 184
10.7.3 spring实现事务自动提交 188
10.8 基于spring与struts、hibernate整合的登录系统 194
10.9 本章小结 199
第11章 jsf框架的开发与应用 200
11.1 jsf框架概述 200
11.1.1 jsf框架工作方式 200
11.1.2 jsf框架的请求处理生命周期 201
11.1.3 jsf应用程序结构 202
11.2 myeclipse创建基于jsf框架的项目 202
11.2.1 创建jsf项目 202
11.2.2 jsf配置文件编辑器 203
11.2.3 创建managed bean 204
11.2.4 创建jsp页面 206
11.2.5 创建导航规则 207
11.3 jsf应用实例：登录系统 207
11.4 本章小结 213
第12章 struts 2.0的开发及应用 214
12.1 struts 2.0框架概述 214
12.1.1 struts 2.0框架工作流程 214
12.1.2 struts 2.0与struts 1.x框架的区别 215
12.2 myeclipse创建基于struts 2.0框架的项目 215
12.2.1 下载struts 2.0开发包 216
12.2.2 创建struts 2.0项目 216
12.2.3 配置struts 2.0项目 217
12.2.4 创建struts 2.0的action类 218
12.2.5 struts 2.0中的国际化编程 221
12.2.6 创建基于pojo的action 223
12.3 spring整合struts 2.0框架 224
12.4 struts 2.0应用实例：登录系统 227
12.5 本章小结 231
第13章 jpa的开发与应用 232
13.1 jpa规范概述 232
13.2 myeclipse创建基于jpa规范的项目 233
13.2.1 创建jpa项目 233
13.2.2 使用反向工程生成jpa实体类和dao类 234
13.2.3 调整生成的实体类标注 237
13.2.4 使用jpa功能 238
13.3 myeclipse中支持jpa规范的工具 238
13.3.1 jpa透视图 239
13.3.2 jpa标注配置视图 239
13.3.3 jpa代码编辑辅助功能 240
13.4 spring整合jpa框架 240
13.4.1 向项目添加spring框架功能支持 241
13.4.2 反向工程生成jpa 实体类和spring dao类 242
13.4.3 创建测试类 243
13.5 本章小结 243
第14章 web service的开发及应用 244
14.1 web service概述 244
14.2 使用myeclipse创建web service项目 245
14.2.1 创建web service项目 245
14.2.2 开发web service服务器端 247
14.2.3 发布和运行web service 249
14.2.4 使用web services explorer访问web service 250
14.2.5 使用java客户端访问web service 251
14.3 向现有web项目加入web service功能 252
14.4 创建直接调用internet中的web service的客户端 252
14.4.1 创建客户端weatherwsclient项目 253
14.4.2 使用wsdl生成客户端代码 253
14.4.3 创建web service客户端测试代码 255
14.5 本章小结 255
第15章 java ee中ejb的开发 256
15.1 ejb概述 256
15.2 weblogic服务器的安装与配置 257
15.2.1 weblogic服务器的安装 257
15.2.2 weblogic服务器的配置 258
15.2.3 myeclipse中集成weblogic服务器 260
15.3 使用myeclipse开发ejb 261
15.3.1 开发session bean 261
15.3.2 开发entity bean 267
15.3.3 开发message driven bean 275
15.4 本章小结 277
第16章 java me的开发及应用 278
16.1 java me概述 278
16.2 wireless toolkit的安装和配置 279
16.3 myeclipse中java me开发环境的搭建 280
16.3.1 搭建myeclipse+eclipseme开发平台 281
16.3.2 myeclipse+eclipseme开发平台集成wtk 283
16.4 使用myeclipse开发java me应用 284
16.5 java me应用实例：吃豆游戏 286
16.6 本章小结 289
第17章 swt的开发及应用 290
17.1 swt简介 290
17.1.1 swt概述 290
17.1.2 swt的包结构 290
17.2 swt中的常用类 291
17.2.1 widget类 291
17.2.2 display类 292
17.2.3 shell类 292
17.3 swt中的基本组件 294
17.3.1 标签（label）组件 294
17.3.2 按钮（button）组件 295
17.3.3 文本框（text）组件 295
17.3.4 列表框（list）组件 297
17.3.5 组合框（combo）组件 298
17.3.6 菜单栏（menu）和菜单项（menuitem） 299
17.4 swt中的布局管理器 302
17.4.1 rowlayout布局管理器 302
17.4.2 filllayout布局管理器 304
17.4.3 gridlayout布局管理器 305
17.4.4 formlayout布局管理器 308
17.5 swt中的事件模型 309
17.6 本章小结 313
第18章 uml建模 314
18.1 uml概述 314
18.2 myeclipse中的uml支持 314
18.3 使用myeclipse创建uml模型仓库 315
18.4 使用myeclipse创建uml图 316
18.4.1 创建uml图 316
18.4.2 设计uml图 317
18.5 使用myeclipse实现正向工程和反向工程 324
18.5.1 myeclipse中实现正向工程 324
18.5.2 myeclipse中实现反向工程 324
18.6 本章小结 326
第19章 使用myeclipse开发插件 327
19.1 myeclipse中的插件机制 327
19.2 myeclipse使用pde开发插件 328
19.2.1 简单的插件开发 328
19.2.2 创建一个空白的插件项目 331
19.3 rcp应用程序的开发 333
19.3.1 rcp应用开发初步 333
19.3.2 创建用户自定义的菜单和工具条 338
19.4 本章小结 341
第20章 网上宠物商店（jsp+javabean） 342
20.1 系统需求分析与概要设计 342
20.1.1 系统需求分析 342
20.1.2 系统模块划分 342
20.2 数据库设计 344
20.3 使用myeclipse创建项目 347
20.4 系统公共模块的实现 348
20.4.1 建立数据库连接的dbconnection类 348
20.4.2 格式化处理时间的strformat类 350
20.5 登录和注册模块的实现 351
20.5.1 对应用户的实体类user 351
20.5.2 用户注册页面register.jsp 354
20.5.3 负责用户注册的servlet类reg 356
20.5.4 生成随机验证码的imgnum类 358
20.5.5 用户登录页面index.jsp 359
20.5.6 验证用户登录信息的servlet类login 360
20.6 显示宠物信息模块的实现 363
20.6.1 对应宠物的实体类user 363
20.6.2 定义对宠物信息进行数据库操作的业务逻辑类petbuy 363
20.6.3 分页显示系统中销售的所有宠物信息的页面newpet.jsp 366
20.6.4 显示销售的每个宠物详细信息的页面petinfo.jsp 368
20.7 显示宠物商品模块的实现 370
20.7.1 显示商品页面 370
20.7.2 定义对宠物商品信息进行数据库操作的业务逻辑类thingsbuy 370
20.8 显示宠物新闻模块的实现 373
20.8.1 对应宠物新闻的实体类news 374
20.8.2 定义对宠物新闻进行数据库操作的业务逻辑类newsbuy 374
20.8.3 分页显示宠物新闻的页面petnews.jsp 375
20.8.4 显示宠物新闻详细内容的页面newsinfo.jsp 377
20.9 显示宠物知识模块的实现 378
20.10 留言模块的实现 379
20.10.1 发表留言评论的页面comment.jsp 379
20.10.2 将用户评论信息插入到数据库中的servlet类comment 381
20.11 后台管理模块的实现 384
20.11.1 后台管理模块的用户登录页面index.jsp 384
20.11.2 后台管理模块的首页面default.jsp 385
20.11.3 输入要添加的宠物信息的页面addpet.jsp 386
20.11.4 将宠物添加到系统中的页面addpet_do.jsp 387
20.11.5 显示系统全部宠物信息的页面petlist.jsp 389
20.11.6 显示出售的宠物信息的页面petnote.jsp 392
20.11.7 后台管理模块的业务逻辑处理类ctrladmin 393
20.12 项目发布与执行 397
20.13 本章小结 397
第21章 新闻管理系统（struts+hibernate） 398
21.1 系统需求分析与概要设计 398
21.1.1 系统需求分析 398
21.1.2 系统模块划分 398
21.2 数据库设计 399
21.3 使用myeclipse创建项目 400
21.3.1 创建web项目 400
21.3.2 向项目添加struts框架 401
21.3.3 向项目添加hibernate框架 402
21.3.4 向项目添加数据库驱动程序jar包 403
21.3.5 项目中的包组织结构 403
21.3.6 项目中的系统配置文件 404
21.4 系统公共模块的实现 411
21.4.1 实现字符集转换的过滤器类setcharacterencodingfilter 411
21.4.2 实现页面分页功能的pager和pagerhelper类 412
21.4.3 实现md5加密算法的md5类 413
21.5 管理员登录模块的实现 413
21.5.1 管理员登录页面adminlogin.jsp 414
21.5.2 管理员登录的actionform类adminloginform 416
21.2.3 管理员登录的action类adminloginaction 417
21.5.4 创建系统中各个业务逻辑类的工厂类managerfactory 419
21.4.5 定义管理员信息业务逻辑操作方法的接口adminmanager 419
21.4.6 adminmanager接口的实现类adminmanagerimpl 420
21.4.7 定义管理员dao操作方法的接口admindao 421
21.4.8 admindao接口的实现类admindaoimpl 421
21.4.9 管理员实体类admin和实体映射文件 426
21.4.10 系统中的dao配置类daoconfig 428
21.6 新闻类别管理模块的实现 429
21.6.1 生成添加新闻类别页面中新闻类别层次树的action类addsortaction 430
21.6.2 添加新闻类别的页面addsort.jsp 430
21.6.3 添加新闻类别的actionform类和action类 431
21.6.4 定义新闻类别信息业务逻辑操作方法的接口sortmanager 432
21.6.5 sortmanager接口的实现类sortmanagerimpl 433
21.6.6 定义新闻类别dao操作方法的接口sortdao 434
21.6.7 sortdao接口的实现类sortdaoimpl 434
21.6.8 新闻类别实体类sort和实体映射文件 445
21.7 新闻管理模块的实现 447
21.7.1 返回到添加新闻页面的action类addnewsaction 447
21.7.2 添加新闻的页面addnews.jsp 448
21.7.3 定义新闻业务逻辑操作方法的接口newsmanager 448
21.7.4 newsdao接口的实现类newsdaoimpl 449
21.8 自动生成页面模块的实现 453
21.8.1 生成前台页面 454
21.8.2 生成首页面的模板页面 457
21.9 管理员账户管理模块的实现 458
21.10 项目发布与执行 460
21.11 本章小节
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序开发大全
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务架构实战派
-------------第1篇 入门
-
第1章 进入微服务世界 2
1.1 系统架构的发展阶段 2
|1.1.1 单体应用阶段 2
|1.1.2 垂直应用阶段 3
|1.1.3 分布式系统阶段 4
|1.1.4 服务治理阶段 5
|1.1.5 微服务阶段 6
|1.1.6 服务网格阶段 6
1.2 主流的微服务框架 8
|1.2.1 主流微服务框架一览表 8
|1.2.2 Dubbo 9
|1.2.3 Spring Cloud 10
1.3 服务网格（Service Mesh）框架Istio 11
1.4 比较Dubbo、Spring Cloud和Istio 12
|1.4.1 对比架构 12
|1.4.2 对比各项数据 15
|1.4.3 总结 15
-
第2章 准备开发环境和工具 17
2.1 搭建环境 17
|2.1.1 安装Java开发环境JDK 17
|2.1.2 配置JDK的环境变量 18
2.2 安装和配置Maven 20
|2.2.1 安装和配置 20
|2.2.2 认识pom.xml文件 22
|2.2.3 了解Maven的运作方式 25
|2.2.4 配置国内仓库 26
2.3 安装及配置开发工具IDEA 27
|2.3.1 安装IDEA 27
|2.3.2 配置IDEA的Maven环境 29
|2.3.3 安装Spring Assistant插件 29
2.4 安装及配置开发工具Eclipse 30
|2.4.1 安装Eclipse 30
|2.4.2 安装Spring Tools 4插件 30
|2.4.3 配置Eclipse的Maven环境 31
|2.4.4 创建Spring Cloud项目 32
2.5 熟悉Spring官方开发工具STS 32
2.6 如何使用本书源码 33
|2.6.1 在IDEA中使用 33
|2.6.2 在Eclipse（STS）中使用 33
-
第3章 实例1：用Spring Cloud实现一个微服务系统 35
3.1 本实例的架构和实现步骤 35
3.2 创建Spring Cloud项目 36
3.3 用Eureka实现“服务中心” 37
|3.3.1 添加配置 37
|3.3.2 实现“服务中心”集群（满足高可用） 38
|3.3.3 打包和部署“服务中心” 40
3.4 用Eureka实现“服务提供者” 42
|3.4.1 实现“服务提供者”的客户端 42
|3.4.2 实现“服务提供者”的接口 44
|3.4.3 检查服务的有效性 44
|3.4.4 实现“服务提供者”集群 44
3.5 用Feign实现“服务消费者” 45
|3.5.1 用Feign实现“服务消费者”的客户端 45
|3.5.2 调用“服务提供者”的接口 46
3.6 测试微服务系统 48
-
-------------第2篇 基础
-
第4章 认识微服务 50
4.1 微服务的优点和缺点 50
|4.1.1 微服务的优点 50
|4.1.2 微服务的缺点 52
4.2 微服务设计的原则 53
4.3 领域驱动设计（DDD） 56
4.4 跨服务的事务管理模式 57
|4.4.1 2PC/3PC算法模式 58
|4.4.2 TCC事务机制模式 60
|4.4.3 消息中间件模式 60
|4.4.4 Saga模式 61
|4.4.5 Paxos算法模式 61
4.5 跨服务的查询模式 62
|4.5.1 API组合器模式 62
|4.5.2 CQRS模式 62
4.6 微服务部署 63
|4.6.1 部署模式 63
|4.6.2 升级模式 64
4.7 微服务架构与云原生的关系 66
|4.7.1 了解云原生 66
|4.7.2 微服务架构和云原生架构的区别 67
-
第5章 Spring Cloud基础 68
5.1 了解Spring Cloud生态 68
|5.1.1 Spring Cloud的总体架构 68
|5.1.2 主要子项目 69
|5.1.3 Netflix家族项目 70
|5.1.4 阿里巴巴家族项目 71
|5.1.5 其他子项目 72
|5.1.6 常用的技术栈 73
5.2 了解Spring Cloud 74
|5.2.1 Spring Cloud与Spring、Spring Boot的关系 74
|5.2.2 Spring Cloud的版本 76
|5.2.3 Spring Cloud项目的结构 77
|5.2.4 Spring Cloud的入口类 78
|5.2.5 Spring Cloud的自动配置 78
|5.2.6 开箱即用 79
5.3 了解注解 80
|5.3.1 什么是注解 80
|5.3.2 Spring Boot的系统注解 80
|5.3.3 Spring Boot的常用注解 81
|5.3.4 Spring Cloud的常用注解 86
5.4 了解Starter 87
|5.4.1 Spring Boot的Starter 87
|5.4.2 Spring Cloud的Starter 88
|5.4.3 如何使用Starter 88
5.5 使用配置文件 88
|5.5.1 配置文件application.properties 89
|5.5.2 实例2：使用配置文件application.properties 91
|5.5.3 配置文件application.yml 93
|5.5.4 实例3：使用配置文件application.yml 94
|5.5.5 实例4：用application.yml和application.properties配置多环境 98
|5.5.6 了解application.yml和application.properties的迁移 100
|5.5.7 比较配置文件bootstrap和application 100
5.6 应用程序分层开发模式——MVC 101
|5.6.1 了解MVC模式 101
|5.6.2 MVC和三层架构的关系 102
5.7 响应式编程——WebFlux 103
|5.7.1 什么是WebFlux 103
|5.7.2 比较MVC和WebFlux 103
|5.7.3 比较Mono和Flux 105
|5.7.4 开发WebFlux的流程 106
5.8 了解Spring Cloud Commons 106
|5.8.1 Spring Cloud的上下文 107
|5.8.2 Spring Cloud的公共抽象类 107
-
-------------第3篇 进阶
-
第6章 用Consul实现服务治理 110
6.1 为什么需要服务治理 110
6.2 主流的“服务中心” 111
|6.2.1 Eureka 111
|6.2.2 Zookeeper 112
|6.2.3 ETCD 113
|6.2.4 Consul 113
|6.2.5 比较Eureka、Consul、ETCD、Zookeeper和Nacos 114
|6.2.6 了解CAP（一致性、可用性、分区容错性） 115
|6.2.7 在容器化时代如何选择“服务中心” 115
6.3 认识“服务发现”接口 116
|6.3.1 如何进行服务的注册和发现 116
|6.3.2 @EnableDiscoveryClient与@EnableEurekaClient的区别 117
6.4 认识Consul 117
|6.4.1 Consul的术语 117
|6.4.2 Consul的工作原理 118
|6.4.3 集群的实现原理 119
|6.4.4 健康检查 120
|6.4.5 安装和实现Consul集群 122
|6.4.6 在Linux中构建Consul集群 124
6.5 实例5：用Consul实现“服务提供者”集群和“服务消费者” 125
|6.5.1 实现“服务提供者”集群 126
|6.5.2 实现“服务消费者” 128
6.6 将“服务中心”从Eureka迁移到Consul 129
-
第7章 用Ribbon和Feign实现客户端负载均衡和服务调用 130
7.1 认识负载均衡 130
|7.1.1 服务器端负载均衡 130
|7.1.2 客户端负载均衡 131
7.2 认识Ribbon 131
|7.2.1 Ribbon的工作原理 131
|7.2.2 Ribbon的主要组件 132
|7.2.3 认识负载均衡器 133
|7.2.4 了解注解@LoadBalanced 135
|7.2.5 Ping机制 136
7.3 认识负载均衡策略 137
|7.3.1 Ribbon支持的9大负载均衡策略 137
|7.3.2 实例6：自定义负载均衡策略 139
7.4 实例7：在没有“服务中心”的情况下，实现自维护的客户端负载均衡 141
|7.4.1 添加依赖和配置，并启用客户端负载均衡 142
|7.4.2 编写负载均衡控制器 143
|7.4.3 测试客户端负载均衡 143
7.5 了解Feign 143
|7.5.1 Feign简介 143
|7.5.2 了解Feign的Bean 144
|7.5.3 压缩请求和响应 145
|7.5.4 了解注解@QueryMap 145
|7.5.5 使用Feign 146
7.6 实例8：覆盖Feign的默认配置 147
|7.6.1 添加依赖和配置，并启用支持 147
|7.6.2 自定义Feign的配置 147
|7.6.3 自定义Feign的接口 148
7.7 实例9：实现在Feign中记录日志 148
|7.7.1 添加配置项 148
|7.7.2 设置记录日志等级 149
|7.7.3 实现接口类 149
|7.7.4 实现调用接口 149
7.8 用Feign构建多参数请求 150
|7.8.1 用GET方式构建多参数请求 150
|7.8.2 用POST方式构建多参数请求 150
7.9 Ribbon和Feign的区别 151
-
第8章 用Hystrix实现容错处理 152
8.1 雪崩效应 152
|8.1.1 什么是雪崩效应 152
|8.1.2 造成服务雪崩的原因 153
8.2 主流的容错项目 155
|8.2.1 流量防卫兵Sentinel 155
|8.2.2 容错框架Resilience4j 156
|8.2.3 容错框架Hystrix 156
|8.2.4 对比Sentinel、Hystrix和Resilience4j 157
8.3 Hystrix处理容错的机制 157
|8.3.1 熔断机制 157
|8.3.2 隔离机制 158
|8.3.3 降级机制 160
|8.3.4 缓存机制 160
8.4 实例10：在Feign中用Hystrix实现服务调用的容错 160
|8.4.1 了解Feign对Hystrix的支持 161
|8.4.2 添加依赖和配置，并启用支持 162
|8.4.3 实现回调类 163
|8.4.4 添加fallback属性 163
|8.4.5 测试fallback状态 163
8.5 实例11：用Hystrix Dashboard实现数据的可视化监控 163
|8.5.1 添加依赖和配置 164
|8.5.2 配置启动类和Servlet 165
|8.5.3 查看监控数据 165
8.6 实例12：用Turbine聚合监控数据 166
|8.6.1 添加依赖并启用支持 166
|8.6.2 创建多个“服务消费者” 167
|8.6.3 配置多监控点 167
|8.6.4 启动并测试聚合监控 168
-
第9章 用Spring Cloud Gateway构建微服务网关 169
9.1 认识微服务网关 169
|9.1.1 什么是微服务网关 169
|9.1.2 为什么要使用微服务网关 169
|9.1.3 认识Spring Cloud Gateway 170
|9.1.4 Spring Cloud Gateway的工作流程 171
|9.1.5 比较Zuul与Spring Cloud Gateway 172
9.2 路由（Route） 173
|9.2.1 认识路由的谓词接口和谓词工厂 173
|9.2.2 认识配置路由规则的方式 173
|9.2.3 实例13：用Java API和配置文件方式构建路由 175
|9.2.4 实例14：应用Spring Cloud Gateway的11种路由规则 176
|9.2.5 实例15：测试多种路由规则匹配优先级 181
|9.2.6 实例16：将网关注册到“服务中心”，实现服务转发 183
9.3 过滤器（Filter） 184
|9.3.1 过滤器的基本知识 184
|9.3.2 网关过滤器（GatewayFilter） 184
|9.3.3 全局过滤器（GlobalFilter） 186
|9.3.4 实例17：用AddRequestHeader过滤器工厂给请求添加Header参数 189
9.4 实例18：实现路由容错 190
|9.4.1 处理未定义的路由 190
|9.4.2 用Hystrix处理路由熔断 191
9.5 限流 193
|9.5.1 为什么要限流 193
|9.5.2 常见的限流措施 193
|9.5.3 限流算法 194
|9.5.4 实例19：用Spring Cloud Gateway内置的限流工厂实现限流 195
9.6 高可用 197
9.7 Spring Cloud Gateway的端点 197
|9.7.1 认识Spring Cloud Gateway的端点 197
|9.7.2 实例20：通过Spring Cloud Gateway的端点添加动态路由 198
-
第10章 用Spring Cloud Sleuth实现微服务链路跟踪 200
10.1 微服务链路跟踪 200
|10.1.1 为什么要实现微服务链路跟踪 200
|10.1.2 微服务链路跟踪的技术要求 201
10.2 一些开源的链路跟踪项目——Skywalking、Pinpoint、Zipkin和CAT 202
10.3 认识Sleuth和Zipkin 203
|10.3.1 Sleuth 203
|10.3.2 Zipkin 203
10.4 实例21：用Sleuth实现日志采样 204
10.5 实例22：在Spring Cloud中使用Zipkin 205
|10.5.1 搭建Zipkin服务器 205
|10.5.2 添加依赖和配置 206
|10.5.3 测试链路数据 207
-
第11章 用Spring Cloud Config配置微服务 209
11.1 了解配置中心 209
|11.1.1 配置信息的管理方式 209
|11.1.2 对比主流配置中心 211
|11.1.3 了解Spring Cloud Config 212
|11.1.4 Spring Cloud Config的常用配置 213
11.2 设置配置中心的安全 214
11.3 加/解密配置文件 215
|11.3.1 实例23：用对称加密方式加/解密配置文件 215
|11.3.2 实例24：用非对称加密方式加/解密配置文件 217
11.4 实例25：用Git配置“配置服务器” 220
|11.4.1 在Git仓库中创建配置文件 220
|11.4.2 添加配置中心的依赖和配置，并启用支持 220
|11.4.3 读取配置信息 221
11.5 实例26：从客户端获取“配置服务器”放置在Git仓库中的配置文件 222
|11.5.1 添加依赖和配置 222
|11.5.2 创建用来获取配置的控制器 223
|11.5.3 测试获取到的数据 223
11.6 实例27：用Spring Cloud Bus自动刷新配置信息 224
|11.6.1 Spring Cloud Bus简介 224
|11.6.2 添加服务器端的依赖和配置，并启用支持 224
|11.6.3 添加客户端的依赖和配置，并启用支持 225
|11.6.4 启动并刷新客户端的配置 227
|11.6.5 实现配置的自动刷新 228
|11.6.6 局部刷新客户端的配置信息 229
|11.6.7 跟踪Bus事件 229
11.7 实例28：实现配置中心和配置客户端的服务化 230
|11.7.1 实现服务器端服务化 230
|11.7.2 实现客户端服务化 231
-
第12章 用Spring Cloud Alibaba组件实现服务治理和流量控制 232
12.1 认识Spring Cloud Alibaba组件 232
|12.1.1 Spring Cloud Alibaba是什么 232
|12.1.2 Spring Cloud Alibaba、Netflix和Spring Cloud的关系 233
|12.1.3 Spring Cloud Alibaba与Spring Boot、Spring Cloud的版本兼容关系 234
12.2 认识Sentinel 235
|12.2.1 Sentinel概述 235
|12.2.2 安装和启动Sentinel 239
|12.2.3 认识流控规则 239
|12.2.4 降级规则 241
|12.2.5 系统规则 241
|12.2.7 Sentinel对RestTemplate和Feign的支持 242
|12.2.8 Sentinel的规则持久化 243
12.3 用Sentinel实现Spring Cloud项目的流控和降级 244
|12.3.1 实例29：实现直接限流 244
|12.3.2 实例30：实现关联限流 246
|12.3.3 实例31：实现链路限流 247
|12.3.4 测试流控模式 249
|12.3.5 测试降级模式 250
12.4 认识Nacos 251
|12.4.1 Nacos概述 251
|12.4.2 下载和使用Nacos 251
12.5 实例32：用Nacos实现“服务提供者”和“服务消费者” 252
|12.5.1 用Nacos实现“服务提供者” 252
|12.5.2 用Nacos实现“服务消费者” 253
|12.5.3 测试服务接口 254
12.6 实例33：用Nacos实现“配置中心” 254
|12.6.1 添加依赖和配置 255
|12.6.2 创建属性承载类 255
|12.6.3 在Nacos控制台中添加配置 255
12.6.4 测试动态刷新 256
12.6.5 测试配置回滚 257
12.7 实例34：用Nacos存储Sentinel的限流规则 257
|12.7.1 添加依赖和配置 257
|12.7.2 自定义埋点 258
|12.7.3 添加Nacos配置 258
|12.7.4 测试配置的持久化 259
12.8 实例35：实现Nacos的数据持久化和集群 260
|12.8.1 实现Nacos的数据持久化 260
|12.8.2 部署集群 261
-
第13章 用Spring Cloud Security实现微服务安全 264
13.1 认识Spring Security与Spring Cloud Security 264
|13.1.1 Spring Security 264
|13.1.2 Spring Cloud Security 266
13.2 认识OAuth 2.0 267
|13.2.1 OAuth 2.0概述 267
|13.2.2 客户端的授权模式 268
13.3 Spring Cloud Security如何实现OAuth 2.0 273
|13.3.1 认识Oauth 2.0服务提供端 273
|13.3.2 配置授权服务器 274
|13.3.3 配置资源服务器 276
13.4 实例36：用Spring Security实现安全认证和授权 276
|13.4.1 添加依赖和配置数据库 276
|13.4.2 创建用户实体类 277
|13.4.3 实现用户注册和密码加密 278
|13.4.4 自定义认证管理器 279
|13.4.5 实现Spring Security配置类 279
|13.4.6 实现登录验证成功处理类 280
|13.4.7 实现登录验证失败处理类 281
|13.4.8 测试注册和登录 281
13.5 实例37：用OAuth 2.0实现认证和授权 282
|13.5.1 添加OAuth 2.0的依赖 282
|13.5.2 配置认证服务器 282
|13.5.3 配置资源服务器 284
|13.5.4 实现用户实体类和角色映射 284
|13.5.5 实现角色实体类 285
|13.5.6 实现测试控制器 286
|13.5.7 测试用密码模式获取Token 286
|13.5.8 测试携带Token访问资源 288
|13.5.9 测试用授权码模式获得Token 288
13.6 实例38：用MySQL实现Token信息的持久化 290
13.7 实例39：用Redis实现Token信息的持久化 292
-
-------------第4篇 项目实战
-
第14章 实例40：用Spring Cloud实现页面日访问量3000万的某平台微服务架构 296
14.1 本实例的整体架构 296
|14.1.1 实施方案 296
|14.1.2 整体架构 297
14.2 实现“配置中心”以提供配置信息 297
|14.2.1 创建配置文件，并将其上传到Git仓库中 297
|14.2.2 编写“配置服务器”的信息 298
14.3 实现“服务提供者”集群、“服务消费者”及客户端自动配置 298
|14.3.1 实现“服务提供者”集群 298
|14.3.2 实现“服务消费者”，并通过“配置中心”实现客户端的自动配置 299
14.4 用OAuth 2.0实现统一的认证和授权 301
|14.4.1 实现认证服务器 301
|14.4.2 配置“服务消费者”的资源安全 301
14.5 在Spring Cloud中用“Redis+MySQL”实现路由服务器 302
|14.5.1 整体思路 302
|14.5.2 设计并实现自定义路由模型 303
|14.5.3 实现路由信息和版本信息实体 303
|14.5.4 实现路由和版本的控制器 304
|14.5.5 实现路由服务器的服务化 306
14.6 用Spring Cloud Gateway实现网关集群 306
|14.6.1 同步路由信息 306
|14.6.2 转换路由对象 308
|14.6.3 开启计划任务和负载均衡 308
|14.6.4 实现网关的服务化 309
14.7 用Nginx实现负载均衡 309
|14.7.1 认识Nginx 309
|14.7.2 实现网关负载均衡 312
|14.7.3 实现Nginx自身负载均衡 313
14.8 用Spring Boot Admin监控Spring Cloud应用程序 314
|14.8.1 集成Actuator 314
|14.8.2 集成Spring Boot admin以监控应用 316
14.9 集成“Prometheus+Grafana”以监控服务 319
|14.9.1 安装和配置Prometheus 319
|14.9.2 在Spring Cloud中集成Prometheus 321
|14.9.3 用Grafana实现可视化监控 322
-
-------------第5篇 开发运维一体化（DevOps）
-
第15章 基于Docker、K8s、Jenkins的DevOps实践 324
15.1 认识DevOps 324
|15.1.1 软件开发的演变过程 324
|15.1.2 认识DevOps 326
|15.1.3 开发模式的关系 327
|15.1.4 为什么要践行DevOps 328
|15.1.5 了解DevOps工具 329
15.2 认识Docker 332
|15.2.1 认识虚拟机和容器 332
|15.2.2 什么是Docker 334
|15.2.3 Docker的特点 335
|15.2.4 Docker的基本概念 335
15.3 使用Docker 337
|15.3.1 在Linux中安装Docker 337
|15.3.2 在Windows中安装Docker 338
|15.3.3 配置国内镜像加速器 338
|15.3.4 Docker的常用操作 340
15.4 用Docker Compose管理容器 342
|15.4.1 了解Docker Compose工具 342
|15.4.2 安装Docker Compose工具 342
|15.4.3 用Docker Compose工具运行容器 344
15.5 管理镜像 344
|15.5.1 用Docker Hub管理镜像 344
|15.5.2 创建私有仓库 345
15.6 认识Docker Swarm、Kubernetes（K8s）和Jenkins 345
|15.6.1 Docker Swarm 345
|15.6.2 Kubernetes（K8s） 347
|15.6.3 Jenkins 349
|15.6.4 比较Docker、Compose、Swarm、K8s和Jenkins 350
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务架构实战派
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring微服务
目 录
第1章 解密微服务 1
微服务的演进 2
命令式架构的演进 4
什么是微服务 5
微服务——蜂窝类比 8
微服务原则 8
微服务的特性 10
微服务中服务的特性 11
微服务案例 17
微服务的好处 22
与其他架构风格的联系 31
微服务使用案例 40
总结 44
第2章 用Spring Boot构建微服务 45
开发RESTful服务——传统方法 46
传统Web应用转移到微服务 49
使用Spring Boot构建RESTful微服务 50
开始使用Spring Boot 51
使用CLI开发Spring Boot微服务 51
使用STS开发Spring Boot Java微服务 52
下一步是什么 63
Spring Boot配置 63
修改默认嵌入的Web服务器 66
实现Spring Boot安全性 67
为微服务开启跨域访问 71
实现Spring Boot通知 72
Spring Boot Actuator 84
配置应用信息 86
添加自定义运行状况模块 86
记录微服务 88
总结 90
第3章 微服务概念的应用 91
模式和常见设计决策 92
微服务的挑战 122
微服务能力模型 127
总结 132
第4章 微服务的演变——一个案例的学习 133
回顾微服务能力模型 134
理解PSS应用 135
庞然大物的终结 139
使用微服务来拯救 144
业务用例 144
为演化制定计划 145
只有在需要时迁移模块 161
目标架构 162
目标实现视图 167
总结 172
第5章 通过Spring Cloud对微服务 进行扩（缩）容 173
回顾微服务 174
回顾BrownField航空的PSS系统实践 174
什么是Spring Cloud 175
建立BrownField PSS的环境 179
Spring Cloud Config 180
一个声明式的REST客户端Feign 194
用于负载均衡的Ribbon 196
注册和发现的Eureka 198
API网关——Zuul代理 208
反应式微服务流 215
总结BrownFeild PSS架构 219
总结 220
第6章 自动化扩（缩）容微服务 221
回顾微服务功能模型 221
用Spring Cloud扩（缩）容微服务 222
理解自动化扩（缩）容的概念 223
自动化扩（缩）容方法 228
总结 240
第7章 日志记录和监控微服务 241
回顾微服务能力模型 242
理解日志管理的挑战 242
集中式日志解决方案 244
日志方案的选择 245
微服务监控 254
使用数据湖泊的数据分析 265
总结 266
第8章 用Docker实现容器化微服务 267
回顾微服务功能模型 267
理解BrownField PSS微服务的区别 268
什么是容器 269
VMs与容器之间的区别 270
容器的好处 272
微服务和容器 273
Docker简介 274
在Docker中部署微服务 278
在Docker上运行RabbitMQ 281
使用Docker Registry 282
云上的微服务 283
在EC2上运行BrownField服务 284
更新生命周期管理器 285
容器化的未来——内核和强化安全 285
总结 286
第9章 使用Mesos和Marathon管理Dockerized微服务 287
回顾微服务功能模型 288
缺少的部分 288
为什么集群管理很重要 289
集群管理能做什么 290
与微服务的关系 293
与虚拟化的关系 293
集群管理解决方案 293
集群管理与Mesos和Marathon 296
为BrownField微服务实现Mesos和Marathon 300
生命周期管理器的部署 312
技术元模型 313
总结 314
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring微服务
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring 5 开发大全
目录
第1章Spring 5 概述
1.1 Spring 与 Java EE
1.1.1Java 平台发展简史
1.1.2Java EE 现状
重点1.1.3Spring 与 Java EE 的关系
1.2 Spring 简史
1.2.1挑衅 EJB
1.2.2化繁为简
难点1.2.3Spring 设计哲学
重点1.2.4面向未来的 Spring
1.3 Spring 5 的新特性
1.3.1基准升级
1.3.2兼容 JDK 9
1.3.3响应式编程模型
1.3.4函数式编程
1.3.5多语言的支持
1.3.6支持 HTTP/2
1.3.7清理了代码
1.3.8更强的测试套件
1.4 快速开启第一个 Spring 应用
实战1.4.1Hello World项目概述
重点1.4.2使用 Maven
重点1.4.3使用 Gradle
重点1.4.4创建服务类
1.4.5创建打印器
1.4.6创建应用主类
1.4.7运行
1.5 Gradle 与 Maven 的抉择
1.5.1Maven 概述
1.5.2Gradle 概述
1.5.3Gradle 与 Maven 对比
第2章Spring 框架核心概念
2.1 Spring 框架总览
重点2.1.1Spring 的狭义与广义
2.1.2Spring 框架概述
难点2.1.3Spring 框架常用模块
2.1.4Spring 设计模式
2.2 IoC 容器
难点2.2.1依赖注入与控制反转
难点2.2.2IoC 容器和 bean
重点2.2.3配置元数据
重点2.2.4实例化容器
2.2.5使用容器
2.2.6bean 的命名
2.2.7实例化 bean 的方式
重点2.2.8注入方式
重点2.2.9实战：依赖注入的例子
2.2.10依赖注入的详细配置
难点2.2.11使用 depends-on
2.2.12延迟加载 bean
重点2.2.13自动装配
2.2.14方法注入
难点2.2.15bean scope
重点2.2.16singleton bean 与 prototype bean
2.2.17request、session、application 及 websocket scope
2.2.18自定义 scope
2.2.19实战：自定义 scope 的例子
2.2.20自定义 bean 的生命周期
难点
2.2.21bean 定义继承
难点
2.2.22容器扩展点
2.2.23实战：容器扩展的例子
重点2.2.24基于注解的配置
2.2.25基于注解的配置与基于 XML 的配置
重点2.2.26类路径扫描及组件管理
2.2.27JSR-330 规范注解
重点2.2.28基于 Java 的容器配置
重点2.2.29环境抽象
2.2.30国际化
2.2.31事件与监听器
2.3 AOP 编程
2.3.1AOP 概述
重点2.3.2AOP 核心概念
2.3.3Spring AOP
难点2.3.4AOP 代理
2.3.5使用 @AspectJ
2.3.6实战：使用 @AspectJ 的例子
重点2.3.7基于 XML 的 AOP
2.3.8实战：基于 XML 的 AOP 例子
2.3.9如何选择 AOP 类型
难点2.3.10理解代理机制
2.3.11创建 @AspectJ 代理
2.4 资源处理
重点2.4.1常用资源接口
2.4.2内置资源接口实现
2.4.3ResourceLoader
重点2.4.4ResourceLoaderAware
2.4.5资源作为依赖
2.5 Bean 验证
重点2.5.1Bean 验证概述
2.5.2Validator 接口
2.6 表达式语言 SpEL
2.6.1SpEL 概述
难点2.6.2表达式接口
2.6.3对于 bean 定义的支持
重点2.6.4常用表达式
2.6.5实战：使用 SpEL 的例子
2.7 数据缓冲器和编解码器
2.7.1数据缓冲器
2.7.2编解码器
2.8 空安全
2.8.1空安全概述
2.8.2如何使用
第3章测试
3.1 测试概述
3.1.1传统的测试所面临的问题
3.1.2如何破解测试面临的问题
3.2 测试的类型和范围
3.2.1测试类型
3.2.2测试范围
3.2.3测试比例
3.3 如何进行微服务的测试
3.3.1微服务的单元测试
3.3.2mock 与 stub 的区别
3.3.3微服务的集成测试
3.3.4微服务的系统测试
第4章单元测试
4.1 Mock 对象
重点4.1.1Environment
4.1.2JNDI
重点4.1.3Servlet API
新功能4.1.4Spring Web Reactive
4.2 测试工具类
4.2.1测试工具
4.2.2测试 Spring MVC
第5章集成测试
5.1 集成测试概述
难点5.1.1上下文管理与缓存
重点5.1.2测试夹具的依赖注入
重点5.1.3事务管理
重点5.1.4集成测试类
测试5.1.5JDBC
5.2 测试相关的注解
5.2.1@BootstrapWith
5.2.2@ContextConfiguration
5.2.3@WebAppConfiguration
5.2.4@ContextHierarchy
5.2.5@ActiveProfiles
5.2.6@TestPropertySource
5.2.7@DirtiesContext
5.2.8@TestExecutionListeners
5.2.9@Commit
5.2.10@Rollback
5.2.11@BeforeTransaction
5.2.12@AfterTransaction
5.2.13@Sql
5.2.14@SqlConfig
5.2.15@SqlGroup
5.2.16标准注解
5.2.17Spring JUnit 4 注解
新功能5.2.18Spring JUnit Jupiter 注解
5.2.19元注解
难点5.3 Spring TestContext 框架
5.3.1Spring TestContext 框架概述
5.3.2核心抽象
5.3.3引导 TestContext
5.3.4TestExecutionListener 配置
难点5.3.5上下文管理
5.3.6测试夹具的依赖注入
难点5.3.7如何测试 request bean 和 session bean
重点5.3.8事务管理
5.3.9执行 SQL 脚本
新功能5.3.10并行测试
新功能5.3.11SpringExtension 测试类
5.4 Spring MVC Test 框架
5.4.1服务端测试概述
难点5.4.2选择测试策略
重点5.4.3设置测试功能
重点5.4.4执行请求
难点5.4.5定义期望
5.4.6注册过滤器
5.4.7脱离容器的测试
5.4.8实战：服务端测试的例子
5.4.9HtmlUnit 集成
5.4.10客户端 REST 测试
5.4.11实战：客户端 REST 测试的例子
★新功能  5.5 WebTestClient
5.5.1WebTestClient 概述
5.5.2设置 WebTestClient
5.5.3如何编写测试用例
5.5.4处理空内容
5.5.5处理 JSON
5.5.6处理流式响应
第6章事务管理
6.1 事务管理概述
6.1.1Spring 事务管理优势
难点6.1.2Spring 事务模型
6.2 通过事务实现资源同步
6.2.1高级别的同步方法
6.2.2低级别的同步方法
6.2.3TransactionAwareDataSourceProxy
6.3 声明式事务管理
重点6.3.1声明式事务管理
6.3.2实战：声明式事务管理的例子
重点6.3.3事务回滚
6.3.4配置不同的事务策略
重点6.3.5@Transactional 详解
重点6.3.6事务传播机制
6.4 编程式事务管理
6.4.1编程式事务管理概述
6.4.2声明式事务管理和编程式事务管理
6.5 事件中的事务
第7章DAO
7.1 DAO 概述
7.2 DAO 常用异常类
7.3 DAO 常用注解
第8章基于 JDBC 的数据访问
8.1 Spring JDBC 概述
8.1.1不同的 JDBC 访问方式
8.1.2Spring JDBC 包
8.2 JDBC 核心类
重点8.2.1JdbcTemplate
8.2.2实战：使用 JdbcTemplate 的例子
8.2.3NamedParameterJdbcTemplate
8.2.4SQLExceptionTranslator
重点8.2.5执行语句
重点8.2.6运行查询
重点8.2.7更新数据
8.2.8检索自动生成的主键
8.3 控制数据库连接
8.4 批处理
8.4.1使用 JdbcTemplate 实现批处理
8.4.2批量更新 List
8.4.3多个批次更新
8.5 SimpleJdbc 类
8.5.1使用 SimpleJdbcInsert 插入数据
8.5.2使用 SimpleJdbcInsert 检索自动生成的主键
8.5.3使用 SqlParameterSource
8.5.4使用 SimpleJdbcCall
8.6 JDBC 转为对象模型
8.6.1SqlQuery
8.6.2MappingSqlQuery
8.6.3SqlUpdate
8.6.4StoredProcedure
8.6.5实战：JDBC 转为对象模型的例子
8.7 内嵌数据库
重点8.7.1使用内嵌数据库的好处
8.7.2使用 Spring XML 创建内存数据库
8.7.3编程方式创建内存数据库
8.7.4实战：使用内存数据库进行测试的例子
8.8 初始化 DataSource
第9章基于 ORM 的数据访问
9.1 Spring ORM 概述
9.2 ORM 集成注意事项
重点9.2.1资源与事务管理
难点9.2.2异常处理
9.3 集成 Hibernate
重点9.3.1设置 SessionFactory
9.3.2基于 Hibernate 的 DAO
重点9.3.3声明式事务
重点9.3.4编程事务
9.3.5事务管理策略
9.4 JPA
9.4.1设置 JPA 不同方式
重点9.4.2基于 JPA 的 DAO
9.4.3JPA 事务
重点9.4.4JpaDialect
9.4.5JTA 事务管理
第10章XML 与对象的转换
10.1 XML 解析概述
10.2 XML 的序列化与反序列化
10.2.1序列化接口 Marshaller
10.2.2反序列化接口 Unmarshaller
10.2.3XML 解析异常类
重点10.2.4如何使用 XML 的序列化与反序列化
10.2.5XML 配置命名空间
10.3 常用 XML 解析工具
10.3.1JAXB
10.3.2Castor
10.3.3JiBX
10.3.4XStream
10.3.5实战：使用 JAXB 解析 XML 的例子
第11章Spring Web MVC
11.1 Spring Web MVC 概述
11.2 DispatcherServlet
11.2.1DispatcherServlet 概述
重点11.2.2上下文层次结构
11.2.3特定的 bean
重点11.2.4框架配置
11.2.5容器配置
11.2.6处理流程
11.2.7拦截
11.2.8视图解析
11.2.9语言环境
重点11.2.10Multipart 请求
11.3 过滤器
11.3.1HTTP PUT 表单
11.3.2转发头
11.3.3ShallowEtagHeaderFilter
11.3.4CORS
11.4 控制器
11.4.1控制器概述
重点11.4.2声明控制器
重点11.4.3请求映射
重点11.4.4处理器方法
重点11.4.5模型方法
11.4.6绑定器方法
11.5 URI 处理
11.5.1URI 链接
11.5.2链接到控制器
11.5.3视图中的链接
11.6 异常处理
11.6.1异常处理概述
11.6.2@ExceptionHandler
11.6.3框架异常处理
11.6.4REST API 异常
11.6.5注解异常
11.6.6容器错误页面
11.7 异步请求
难点11.7.1异步请求处理流程
11.7.2异常处理
11.7.3异步拦截器
难点11.7.4流式响应
重点11.7.5Server-Sent Events
11.7.6发送原生数据
新功能11.7.7响应式返回值
11.7.8配置
11.8 CORS 处理
重点11.8.1CORS 概述
重点11.8.2@CrossOrigin
11.8.3全局 CORS 配置
11.8.4自定义CORS
11.8.5CORS 过滤器
11.9 HTTP 缓存
11.9.1HTTP 缓存概述
重点11.9.2缓存控制
重点11.9.3静态资源
11.9.4控制器缓存
11.10 MVC 配置
11.10.1启用 MVC 配置
11.10.2类型转换
11.10.3验证
重点 11.10.4拦截器
11.10.5内容类型
重点11.10.6消息转换器
重点11.10.7视图控制器
重点11.10.8视图解析器
重点11.10.9静态资源
11.10.10DefaultServletHttpRequestHandler
难点11.10.11路径匹配
11.11 视图处理
重点11.11.1常用视图技术
11.11.2文档视图
11.11.3Feed 视图
★新功能  11.12 HTTP/2
11.12.1TLS 的考虑
11.12.2容器配置
实战11.13 基于 Spring Web MVC 的 REST 接口
11.13.1系统概述
难点11.13.2接口设计
重点11.13.3系统配置
重点11.13.4后台编码实现
重点11.13.5应用配置
11.13.6运行
第12章REST 客户端
12.1 RestTemplate
★新功能  12.2 WebClient
实战12.3 基于 RestTemplate 的天气预报服务
重点12.3.1系统配置
重点12.3.2后台编码实现
12.3.3运行
第13章WebSocket
13.1 WebSocket 概述
13.1.1HTTP和WebSocket
重点13.1.2理解 WebSocket 使用场景
13.2 WebSocket 常用 API
重点13.2.1WebSocketHandler
13.2.2WebSocket 握手
13.2.3部署
重点13.2.4配置
13.2.5跨域处理
13.3 SockJS
13.3.1SockJS 概述
13.3.2启用 SockJS
13.3.3心跳
13.3.4客户端断开连接
13.3.5CORS 处理
13.3.6SockJsClient
13.4 STOMP
13.4.1STOMP 概述
13.4.2启用 STOMP
重点13.4.3消息流程
13.4.4处理器方法
重点13.4.5发送消息
13.4.6内嵌 Broker和外部 Broker
重点13.4.7连接到 Broker
13.4.8认证
重点13.4.9用户目的地
13.4.10事件和拦截
13.4.11STOMP 客户端
13.4.12WebSocket Scope
难点13.4.13性能优化
13.5 基于 STOMP 的聊天室
实战13.5.1聊天室项目的概述
重点13.5.2设置 Broker
重点13.5.3服务端编码
重点13.5.4客户端编码
13.5.5运行
第14章Spring WebFlux
★新功能  14.1 响应式编程概述
14.1.1响应式编程简述
重点14.1.2Spring WebFlux 与 Spring MVC 的区别
重点14.1.3响应式 API
难点14.1.4响应式编程模型
★新功能  14.2 Spring 中的响应式编程
重点14.2.1HttpHandler
重点14.2.2WebHandler API
14.2.3编码器和解码器
★新功能  14.3 DispatcherHandler
重点14.3.1Spring WebFlux 常用 bean
14.3.2配置
14.3.3执行
★新功能  14.4 控制器
重点14.4.1@Controller
重点14.4.2请求映射
重点14.4.3处理器方法
★新功能  14.5 常用函数
重点14.5.1HandlerFunction
重点14.5.2RouterFunction
14.5.3运行服务器
14.5.4HandlerFilterFunction
★新功能  14.6 WebFlux 相关配置
重点14.6.1启用 WebFlux
难点14.6.2配置 WebFlux
重点14.6.3数据转换
重点14.6.4数据验证
重点14.6.5内容类型解析器
重点14.6.6HTTP 消息编码器和解码器
重点14.6.7视图解析器
重点14.6.8静态资源
重点14.6.9路径匹配
★新功能  14.7 CORS 处理
重点14.7.1CORS 概述
重点14.7.2@CrossOrigin
14.7.3全局CORS 配置
14.7.4自定义CORS
14.7.5CORS 过滤器
第15章响应式编程中的 WebClient
★新功能  重点 15.1 retrieve() 方法
★新功能  重点 15.2 exchange() 方法
★新功能  15.3 请求主体
重点15.3.1处理 Form 表单数据
重点15.3.2处理文件上传数据
★新功能  15.4 生成器
★新功能  15.5 过滤器
★新功能 实战 15.6 基于 WebClient 的文件上传、下载
15.6.1应用的概述
重点15.6.2文件上传的编码实现
重点15.6.3文件下载的编码实现
15.6.4运行
第16章响应式编程中的 WebSocket
16.1 WebSocket 概述
16.2 WebSocket 常用 API
重点16.2.1WebSocketHandler
16.2.2WebSocket 握手
重点16.2.3配置
16.2.4跨域处理
★新功能  16.3 WebSocketClient
第17章常用集成模式
17.1 Spring 集成模式概述
17.2 使用 RMI
重点17.2.1使用 RmiServiceExporter 暴露服务
重点17.2.2客户端访问服务
17.3 使用 Hessian
重点17.3.1编写 DispatcherServlet
重点17.3.2使用 HessianServiceExporter 暴露 bean
重点17.3.3客户端访问服务
17.3.4在 Hessian 中使用基本认证
17.4 使用 HTTP
重点17.4.1暴露服务
重点17.4.2客户端访问服务
17.5 Web 服务
重点17.5.1暴露基于 JAX-WS 的 Web 服务
重点17.5.2访问服务
17.6 JMS
17.6.1JMS 概述
重点17.6.2服务端配置
重点17.6.3客户端配置
17.7 REST 服务
重点17.7.1RestTemplate
17.7.2HTTP 消息转换器
第18章EJB 集成
18.1 EJB 集成概述
18.2 EJB 集成的实现
18.2.1访问本地 SLSB
18.2.2访问远程 SLSB
第19章JMS 集成
19.1 JMS 集成概述
19.2 Spring JMS
重点19.2.1JmsTemplate
重点19.2.2连接管理
重点19.2.3目的地管理
19.2.4消息监听器容器
重点19.2.5事务管理
19.3 发送消息
19.3.1使用消息转换器
19.3.2回调
19.4 接收消息
19.4.1同步接收
重点19.4.2异步接收
19.4.3SessionAwareMessageListener
19.4.4MessageListenerAdapter
19.4.5处理事务
重点
19.5 JCA 消息端点
19.6 基于注解的监听器
19.6.1启用基于注解的监听器
重点19.6.2编程式端点注册
重点19.6.3基于注解的端点方法签名
19.6.4响应管理
19.7 JMS 命名空间
难点19.8 基于 JMS 的消息发送、接收
19.8.1项目概述
19.8.2配置
19.8.3编码实现
19.8.4运行
第20章JMX 集成
20.1 JMX 集成概述
20.2 bean 转为 JMX
重点20.2.1创建 MBeanServer
20.2.2重用 MBeanServer
20.2.3延迟实例化 MBean
20.2.4MBean 自动注册
重点20.2.5控制注册行为
20.3 bean 的控制管理
20.3.1MBeanInfoAssembler
重点20.3.2注解
20.3.3AutodetectCapableMBeanInfoAssembler
重点20.3.4定义管理接口
20.3.5MethodNameBasedMBeanInfoAssembler
20.4 通知
20.4.1注册监听器
20.4.2发布通知
第21章JCA CCI 集成
21.1 JCA CCI 集成概述
21.2 配置 CCI
21.2.1连接器配置
21.2.2ConnectionFactory 配置
21.2.3配置连接
21.3 使用 CCI 进行访问
21.3.1记录转换
重点21.3.2CciTemplate
21.3.3DAO
21.3.4自动输出记录生成
21.4 CCI 访问对象建模
21.4.1MappingRecordOperation
21.4.2MappingCommAreaOperation
21.5 CCI 中的事务处理
第22章使用 E-mail
22.1 使用 E-mail 概述
22.2 实现发送 E-mail
重点22.2.1MailSender 和 SimpleMailMessage 的基本用法
重点22.2.2JavaMailSender 和 MimeMessagePreparator 的用法
22.3 使用 MimeMessageHelper
难点22.3.1发送附件和内联资源
重点22.3.2使用模板创建 E-mail 内容
实战22.4   实现 E-mail 服务器
22.4.1项目概述
22.4.2E-mail 服务器编码实现
22.4.3格式化 E-mail 内容
22.4.4运行
第23章任务执行与调度
23.1 任务执行与调度概述
23.2 TaskExecutor
23.2.1TaskExecutor 类型
23.2.2使用 TaskExecutor
23.3 TaskScheduler
23.3.1Trigger 接口
23.3.2实现
23.4 任务调度及异步执行
23.4.1启用调度注解
重点23.4.2@Scheduled
重点23.4.3@Async
23.4.4@Async 的异常处理
23.4.5命名空间
23.5 使用 Quartz Scheduler
23.5.1使用 JobDetailFactoryBean
23.5.2使用 MethodInvokingJobDetailFactoryBean
实战23.6  基于 Quartz Scheduler 的天气预报系统
23.6.1项目概述
23.6.2后台编码实现
23.6.3运行
第24章缓存
24.1 缓存概述
24.2 声明式缓存注解
重点24.2.1@Cacheable
重点24.2.2@CachePut
重点24.2.3@CacheEvict
重点24.2.4@Caching
24.2.5@CacheConfig
重点24.2.6启用缓存
24.2.7使用自定义缓存
24.3 JCache 注解
24.3.1JCache 注解概述
24.3.2与 Spring 缓存注解的差异
24.4 基于 XML 的声明式缓存
24.5 配置缓存存储
24.5.1基于 JDK 的缓存
24.5.2基于 Ehcache 的缓存
24.5.3基于 Caffeine 的缓存
24.5.4基于 GemFire 的缓存
24.5.5基于 JSR-107 的缓存
实战 24.6 基于缓存的天气预报系统
24.6.1项目概述
24.6.2后台编码实现
24.6.3缓存配置
24.6.4运行
第25章Spring Boot
25.1 从单块架构到微服务架构
25.1.1单块架构的概念
重点25.1.2单块架构的优缺点
难点25.1.3将单块架构进化为微服务架构
25.2 微服务设计原则
难点25.2.1拆分足够“微”
重点25.2.2轻量级通信
难点25.2.3领域驱动原则
重点25.2.4单一职责原则
重点25.2.5DevOps 及两个比萨原则
重点25.2.6不限于技术栈
重点25.2.7可独立部署
25.3 Spring Boot 概述
难点25.3.1Spring Boot 产生的背景
重点25.3.2Spring Boot 的目标
重点25.3.3Spring Boot 与其他 Spring 应用的关系
重点25.3.4Starter
实战25.4 开启第一个 Spring Boot 项目
25.4.1通过 Spring Initializr 初始化一个 Spring Boot 原型
25.4.2用 Gradle 编译项目
25.4.3探索项目
第26章Spring Cloud
★新功能  26.1 Spring Cloud 概述
26.1.1Spring Cloud 简介
26.1.2Spring Cloud 与 Spring Boot 的关系
★新功能  26.2 Spring Cloud 入门配置
重点26.2.1Maven 配置
重点26.2.2Gradle 配置
重点26.2.3声明式方法
★新功能  26.3 Spring Cloud 的子项目介绍
26.3.1Spring Cloud 子项目的组成
重点26.3.2Spring Cloud 组件的版本
★新功能 实战  26.4 实现微服务的注册与发现
26.4.1服务发现的意义
重点26.4.2集成 Eureka Server
重点26.4.3集成 Eureka Client
重点26.4.4实现服务的注册与发现
附录
附录A  EJB 规范摘要
A1EJB 2.1 规范目标
A2EJB 3.2 规范目标
附录B  Bean Validation 内置约束
附录C	提升 Gradle 的构建速度
附录D	本书所采用的技术及相关版本
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring 5 开发大全
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>龙枪编年史3
译者序•001
作者序克莱恩，你心中真实的世界•005
作者序是故事将我们联系在一起•006
主要人物介绍•007
第1卷
坦尼斯的道别•001
序曲：永恒之人•003
难逃黑暗魔掌•013
追逐•024
凝聚的黑暗•038
“弟弟……”•049
历史学者和法师•062
帕兰萨斯•075
索兰尼亚骑士指挥官•093
龙之誓约•106
胜利•118
第2卷
春晓•137
失败的处罚•151
黑玫瑰骑士•164
陷阱……•169
平静的间奏•186
“我杀死过他……”•196
阿波莉塔•209
贝伦意料之外的帮助•221
黑潮•228
一根蜡烛•240
第3卷
一位老人和一条金龙•251
金色拱桥•262
神之乡•275
永恒之人的故事•287
奈拉卡•297
坦尼斯的条件加汉的调查•311
黑暗之后的神殿•324
黑暗之后•339
末日号角声•351
“戴上此冠者将君临天下”•367
“洁思拉在呼唤我——”•376
还债•384
奇蒂拉•394
善良与邪恶的结局•406
回家•421
雷斯林的道别•424
后记•427
中英名词对照表•429
克莱恩历史简表•443
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>龙枪编年史3
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
致谢
第一章      明日寓言
第二章      人类不得不承受的义务
第三章      要命的灵药
第四章      地表水与地下海
第五章      土壤的国度
第六章      地球的绿衣
第七章      无谓的破坏
第八章      不闻鸟鸣
第九章     死亡之河
第十章     漫天盖地
第十一章      难以摆脱的噩梦
第十二章      人命值多少
第十三章     透过一扇窄窗
第十四章      四分之一
第十五章      大自然反扑
第十六章      隆隆的雪崩声
第十七章      另一条路
《寂静的春天》大事记

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构实战
第1章 微服务架构设计 1
1.1 直面微服务架构 1
1.1.1 分布式系统与微服务架构 1
1.1.2 微服务架构的优势与挑战 3
1.1.3 实施微服务架构 5
1.2 服务建模方法 6
1.2.1 服务的模型 6
1.2.2 服务的边界 7
1.2.3 服务的数据 7
1.3 服务拆分与集成 8
1.3.1 服务拆分 8
1.3.2 服务集成 9
1.4 微服务架构的基础组件和关键要素 10
1.4.1 微服务架构的基础组件 11
1.4.2 微服务架构的关键元素 11
1.5 实现微服务架构 13
1.5.1 微服务架构技术体系 13
1.5.2 微服务架构实现技术选型 14
1.6 案例分析 17
1.7 全书架构 18
1.8 本章小结 19
第2章 使用Spring Boot构建服务 21
2.1 引入Spring Boot 21
2.2 基于Spring Boot的第一个服务 23
2.2.1 环境准备 23
2.2.2 实现RESTful服务 24
2.3 Spring Boot常见功能 28
2.3.1 集成Spring Data 28
2.3.2 集成消息中间件 37
2.3.3 系统监控 39
2.4 Spring Boot基本原理 44
2.5 本章小结 46
第3章 Spring Cloud Netflix Eureka与服务治理 47
3.1 服务治理解决方案 48
3.1.1 服务治理的需求和模型 48
3.1.2 服务治理的基本方案 49
3.2 构建Eureka服务 52
3.2.1 构建单个Eureka服务器 52
3.2.2 构建Eureka服务器集群 55
3.3 使用Eureka注册和发现服务 57
3.3.1 通过配置实现服务注册 58
3.3.2 获取服务注册信息 59
3.4 Eureka基本架构 61
3.4.1 Eureka服务注册和发现架构 61
3.4.2 Eureka高可用架构 64
3.4.3 Eureka区域亲和性 65
3.5 本章小结 66
第4章 Spring Cloud Netflix Ribbon与负载均衡 67
4.1 负载均衡 68
4.1.1 负载均衡的类型 68
4.1.2 负载均衡的算法 70
4.2 使用Ribbon实现客户端负载均衡 71
4.2.1 Spring Cloud Netflix Ribbon简介 71
4.2.2 使用DiscoveryClient查找服务 72
4.2.3 通过RestTemplate调用服务 74
4.3 Ribbon基本架构 78
4.3.1 Ribbon核心机制 79
4.3.2 Ribbon负载均衡策略 81
4.3.3 @LoadBalanced注解与RestTemplate 82
4.3.4 @RibbonClient注解与自定义负载均衡策略 83
4.4 本章小结 85
第5章 Spring Cloud Netflix Hystrix与服务容错 86
5.1 服务消费者容错思想和模式 87
5.1.1 服务消费者容错的需求 87
5.1.2 服务隔离 88
5.1.3 服务熔断 90
5.1.4 服务回退 91
5.2 使用Hystrix实现服务容错 91
5.2.1 引入Hystrix 92
5.2.2 使用Hystrix实现服务隔离 93
5.2.3 使用Hystrix实现服务熔断 96
5.2.4 使用Hystrix实现服务回退 99
5.3 Hystrix基本原理 101
5.3.1 服务隔离 101
5.3.2 服务熔断 103
5.3.3 Hystrix配置项 105
5.4 本章小结 109
第6章 Spring Cloud Netflix Zuul与API网关 110
6.1 服务网关的设计理念 111
6.1.1 服务网关的作用 111
6.1.2 服务网关的结构和功能 112
6.2 使用Zuul构建服务网关 113
6.2.1 构建Zuul服务器 113
6.2.2 配置Zuul服务路由 115
6.3 Zuul基本架构 120
6.3.1 ZuulFilter组件架构 120
6.3.2 使用Zuul过滤器 124
6.4 本章小结 129
第7章 Spring Cloud Config与配置中心 130
7.1 分布式配置中心方案 131
7.1.1 分布式配置模型 131
7.1.2 配置中心实现工具 133
7.2 构建配置中心服务器 134
7.2.1 引入Spring Cloud Config 134
7.2.2 实现基于本地文件系统的配置方案 135
7.2.3 实现基于Git的配置方案 139
7.3 使用配置服务 140
7.3.1 访问配置项 141
7.3.2 配置数据安全性 145
7.4 Spring Cloud Config特性 148
7.4.1 Spring Cloud Config对比Zookeeper 148
7.4.2 Spring Cloud Config高可用 149
7.5 本章小结 150
第8章 Spring Cloud Stream与事件驱动 151
8.1 事件驱动架构与模型 152
8.1.1 基本事件驱动架构与实现机制 152
8.1.2 事件驱动与领域模型 155
8.2 引入Spring Cloud Stream 157
8.2.1 Spring Cloud Stream基本架构 157
8.2.2 Spring Cloud Stream与Spring Integration 159
8.2.3 Spring Cloud Stream与消息中间件 162
8.3 实现消息发布者 165
8.3.1 消息发送场景与实现流程 165
8.3.2 在服务中添加消息发布者 166
8.4 实现消息消费者 170
8.4.1 消息消费场景与实现流程 170
8.4.2 在服务中添加消息消费者 172
8.5 本章小结 177
第9章 Spring Cloud Security与服务安全 178
9.1 服务访问安全性与OAuth协议 178
9.1.1 微服务架构中的安全性设计 179
9.1.2 OAuth协议 180
9.2 构建OAuth认证服务器 184
9.2.1 引入Spring Cloud Security 185
9.2.2 初始化用户与客户端 186
9.2.3 生成Token 191
9.3 使用OAuth保护服务访问 195
9.3.1 集成OAuth认证服务 195
9.3.2 创建服务访问策略 196
9.3.3 使用OAuth2RestTemplate传播Token 201
9.4 本章小结 206
第10章 Spring Cloud Sleuth与服务监控 207
10.1 服务监控与Spring Cloud Sleuth 207
10.1.1 服务监控基本原理 207
10.1.2 引入Spring Cloud Sleuth 209
10.2 整合Spring Cloud Sleuth与Zipkin 215
10.2.1 Zipkin基本结构 215
10.2.2 引入Zipkin 216
10.2.3 使用Zipkin跟踪服务调用链路 218
10.2.4 使用Zipkin实现自定义跟踪 226
10.3 本章小结 228
第11章 Spring Test与服务测试 230
11.1 微服务测试的方法 231
11.1.1 单元测试 231
11.1.2 集成测试 233
11.1.3 端到端测试 233
11.2 测试Spring Boot应用程序 234
11.2.1 初始化测试环境 234
11.2.2 执行单元测试 237
11.3 使用Mock和注解实施集成测试 241
11.3.1 使用@JsonTest注解测试JSON数据 242
11.3.2 使用@DataJpaTest注解测试Repository层 244
11.3.3 使用Mock测试Service层 248
11.3.4 使用Mock和@WebMvcTest注解测试Controller层 252
11.4 消费者驱动的契约测试 254
11.4.1 面向契约的端对端测试 254
11.4.2 实现面向契约的端对端测试 257
11.5 本章小结 266
第12章 Docker与服务部署 267
12.1 Docker与微服务架构 267
12.1.1 Docker的优势 268
12.1.2 Docker组件与命令 268
12.2 使用Dockerfile构建服务镜像 272
12.2.1 Dockerfile命令 272
12.2.2 使用Dockerfile命令构建镜像 273
12.3 使用Docker Compose编排服务 276
12.3.1 Docker Compose组件与命令 276
12.3.2 使用Docker Compose 279
12.3.3 Docker Compose案例分析 281
12.4 本章小结 283
参考文献 284
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>互联网轻量级SSM框架解密
第1篇  深入剖析Spring源码
第1章  Spring基础介绍  2
1.1  Spring的核心结构  2
1.2  Spring的领域模型  6
第2章  Spring上下文和容器  7
2.1  Spring上下文的设计  7
2.2  Spring容器BeanFactory的设计  11
2.3  Spring父子上下文与容器  13
第3章  Spring加载机制的设计与实现  18
3.1  Spring ApplicationContext的加载及源码实现  18
3.2  Spring XML文件标签加载解析及自定义  27
3.3  Spring注解的加载及自动注入  31
第4章  Spring Bean探秘  45
4.1  Spring Bean的定义和注册设计  45
4.2  Spring Bean的定义模型  47
4.3  Spring Bean的运行（获取、创建）实现  48
4.4  Spring Bean的依赖注入的实现  59
4.5  Spring Bean的初始化  70
第5章  Spring代理与AOP  74
5.1  Spring代理的设计及JDK、CGLIB动态代理  75
5.2  Spring AOP的设计  82
5.3  Spring AOP的加载和执行机制  83
5.3.1  Spring AOP的加载及源码解析  83
5.3.2  Spring AOP的创建执行及源码解析  88
5.4  Spring事务管理设计及源码  101
5.5  Spring事务传播机制  115
第6章  Spring实战  118
6.1  对Spring重复AOP问题的分析  118
6.2  Spring Bean循环依赖的问题  125
第2篇  深入剖析Spring MVC源码
第7章  MVC简介  138
7.1  MVC的体系结构和工作原理  138
7.1.1  控制器  139
7.1.2  视图  139
7.1.3  模型  140
7.2  Web MVC的体系结构和工作原理  140
第8章  Spring Web MVC工作流  142
8.1  组件及其接口  142
8.1.1  DispatcherServlet  143
8.1.2  处理器映射  143
8.1.3  处理器适配器  144
8.1.4  处理器与控制器  145
8.1.5  视图解析器  145
8.1.6  视图  146
8.2  组件间的协调通信  146
第9章  DispatcherServlet的实现  148
9.1  深入剖析GenericServlet和HttpServlet  150
9.1.1  HTTP和Servlet规范简介  150
9.1.2  Servlet和GenericServlet详解  152
9.1.3  HttpServlet详解  152
9.2  深入剖析DispatcherServlet  159
9.2.1  HttpServletBean详解  161
9.2.2  FrameworkServlet详解  162
9.2.3  DispatchServlet详解  166
9.3  根共享环境的加载  182
9.3.1  基于Servlet环境监听器的实现结构  182
9.3.2  多级Spring环境的加载方式  189
第10章  基于简单控制器的流程实现  194
10.1  通过Bean名称URL处理器映射获取处理器执行链  194
10.1.1  抽象处理器映射  196
10.1.2  抽象URL处理器映射  199
10.1.3  抽象探测URL处理器映射  209
10.1.4  Bean名称URL处理器映射  210
10.2  通过处理器适配器把请求转接给处理器  211
10.2.1  简单控制处理适配器的设计  211
10.2.2  表单控制器处理HTTP请求的流程  212
10.3  对控制器类体系结构的深入剖析  214
10.3.1  Web内容产生器  215
10.3.2  抽象控制器类  217
10.3.3  基本命令控制器  218
10.3.4  抽象表单控制器  222
10.3.5  简单表单控制器  229
第11章  基于注解控制器的流程实现  230
11.1  默认注解处理器映射的实现  230
11.2  注解处理器适配器的架构设计  237
11.3  深入剖析注解控制器的处理流程  238
11.3.1  解析处理器方法  241
11.3.2  解析处理器方法的参数  253
11.3.3  绑定、初始化领域模型和管理领域模型  272
11.3.4  调用处理器方法  278
11.3.5  处理方法返回值和隐式模型到模型或视图的映射  281
11.3.6  如何更新模型数据  286
第12章  基于HTTP请求处理器实现RPC  288
12.1  深入剖析RPC客户端的实现  289
12.2  深入剖析RPC服务端的实现  299
第13章  深入剖析处理器映射、处理器适配器及处理器的实现  311
13.1  处理器映射的实现架构  311
13.1.1  处理器映射实现类  312
13.1.2  处理器映射抽象类  313
13.1.3  对处理器映射类的代码剖析  315
13.2  处理器适配器的实现架构  322
13.3  深入剖析处理器  325
13.3.1  简单控制器  325
13.3.2  注解控制器  339
13.3.3  HTTP请求处理器  342
13.4  拦截器的实现架构  344
第14章  视图解析和视图显示  353
14.1  基于URL的视图解析器和视图  353
14.1.1  内部资源视图解析器和内部资源视图  365
14.1.2  瓦块视图解析器和瓦块视图  371
14.1.3  模板视图解析器和模板视图  373
14.1.4  XSLT视图解析器和XSLT视图  377
14.2  更多的视图解析器  378
14.2.1  Bean名称视图解析器  378
14.2.2  内容选择视图解析器  379
14.2.3  资源绑定视图解析器  383
14.2.4  XML视图解析器  385
第3篇  深入剖析MyBatis源码
第15章  MyBatis介绍  388
15.1  MyBatis的历史  388
15.2  MyBatis子项目  389
15.3  MyBatis的自身定位  389
15.3.1  JPA持久化框架  390
15.3.2  MyBatis的功能  390
15.3.3  MyBatis与JPA的异同  390
15.4  MyBatis的架构  391
15.4.1  模块  391
15.4.2  MyBatis的项目包  392
第16章  构建阶段  394
16.1  关键类  394
16.2  关键时序  395
16.3  构建的入口：SqlSessionFactoryBuilder和SqlSessionFactory  396
16.4  配置（Configuration）和配置构造器（XmlConfigBuilder）  397
16.4.1  XmlConfigBuilder的初始化  397
16.4.2  完整的mybatis-3-config.dtd  399
16.4.3  解析配置文件构建Configuration配置  399
16.5  SQL简介  418
16.6  SQL映射的构建  419
16.6.1  通过XML定义的SQL Mapper  419
16.6.2  Configuration类中与SQL Mapping相关的类  420
16.6.3  XmlMapperBuilder是如何工作的  421
16.6.4  映射注解器定义的SQL Mapper  438
16.6.5  小结  440
第17章  执行阶段  441
17.1  关键类  441
17.2  关键接口及默认实现初始化  442
17.2.1  SqlSession及其关联类的构建过程  442
17.2.2  StatementHandler语句处理器  446
17.3  DQL语句是如何执行的  448
17.3.1  查询接口  448
17.3.2  关键时序  449
17.3.3  程序执行查询的入口：DefaultSqlSession#selectList(statement)  450
17.3.4  生成执行语句：getMappedStatement()  450
17.3.5  执行器查询：Executor#query()  451
17.3.6  JDBC执行语句：SimpleStatementHandler#query()  455
17.3.7  结果集处理：DefaultResultSetHandler#handlerResultSets()  455
17.4  DML语句是如何执行的  460
17.4.1  操作接口  460
17.4.2  关键时序  460
17.4.3  程序执行更新的入口：DefaultSqlSession#update()  461
17.4.4  执行器执行方法：Executor#update()  461
17.4.5  SQL语句执行：SimpleStatementHandler#update()  464
17.4.6  结果集主键逻辑：Jdbc3KeyGenerator#processAfter()  464
17.5  小结  466
第18章  专题特性解析  467
18.1  动态SQL支持  467
18.1.1  XmlScriptBuilder解析配置  467
18.1.2  NodeHandler构建SqlNode树  468
18.1.3  SqlNode处理SQL语句  471
18.2  MyBatis的缓存支持  477
18.2.1  本地缓存  478
18.2.2  二级缓存  482
18.3  结果集支持：Object、List、Map和Cursor  491
18.4  自定义扩展点及接口  496
第19章  作为中间件如何承上启下  498
19.1  MyBatis与底层的JDBC  498
19.1.1  java.sql.DataSource  498
19.1.2  java.sql.Connection  499
19.1.3  java.sql.Statement  500
19.1.4  java.sql.Resultset  502
19.2  MyBatis的主流集成方式  502
19.2.1  mybatis-spring简介  502
19.2.2  Spring对JDBC的支持  502
19.2.3  mybatis-spring与Spring  504
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>互联网轻量级SSM框架解密
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>从企业级开发到云原生微服务：Spring Boot实战
目录
第 1 章  初识 Spring Boot ............................................................................................... 1
1.1  Spring Boot 概述 ............................................................................................................ 1  1.2  快速建立 Spring Boot 应用 ........................................................................................... 2
1.2.1  安装 Java ............................................................................................................. 2
1.2.2  使用 Spring Initializr ........................................................................................... 2
1.2.3  第一段代码 ......................................................................................................... 3
1.3  体验 Spring Boot ............................................................................................................ 4  1.3.1  Spring Boot 的应用结构 ..................................................................................... 4
1.3.2  build.gradle .......................................................................................................... 5
1.3.3  QuickStartApplication ......................................................................................... 5
1.3.4  application.properties .......................................................................................... 6
1.4  小结 ................................................................................................................................ 6
第 2 章  函数式编程 ........................................................................................................ 7
2.1  了解函数式编程 ............................................................................................................ 7
2.2  Lambda 表达式 .............................................................................................................. 7
2.2.1  了解Lambda 表达式 .......................................................................................... 7
2.2.2  把 Lambda 表达式作为参数 .............................................................................. 8
2.3  函数接口 ........................................................................................................................ 9
2.3.1  Predicate ............................................................................................................ 10
2.3.2  Function ............................................................................................................. 12
2.3.3  Consumer .......................................................................................................... 14
2.3.4  Supplier ............................................................................................................. 14
2.3.5  Operator ............................................................................................................. 15
2.3.6  Comparator ........................................................................................................ 15
2.3.7  自定义函数接口 ............................................................................................... 16
2.4  方法引用 ...................................................................................................................... 16
2.4.1  构造器方法引用 ............................................................................................... 16
2.4.2  静态方法引用 ................................................................................................... 17
2.4.3  实例方法引用 ................................................................................................... 18
2.4.4  引用特定类的任意对象的方法 ....................................................................... 18
2.5  Stream ........................................................................................................................... 18
2.5.1  Stream 简介 ....................................................................................................... 19
2.5.2  获得 Stream ....................................................................................................... 19
2.5.3  中间操作 ........................................................................................................... 20
2.5.4  终结操作 ........................................................................................................... 23
2.6  Optional ........................................................................................................................ 27
2.6.1  获得Optional .................................................................................................... 28
2.6.2  Optional 的用法 ................................................................................................ 28
2.7小结......................................................................................................................29
第 3 章  Spring 5.X 基础 ............................................................................................... 30
3.1  IoC 容器 ....................................................................................................................... 30
3.2  Spring Bean 的配置 ..................................................................................................... 31
3.2.1  注解配置（@Component） ............................................................................. 31
3.2.2  Java 配置（@Configuration 和@Bean） ........................................................ 31
3.2.3  依赖注入（Dependency Injection） ................................................................ 32
3.2.4  运行检验（CommandLineRunner） ............................................................... 37
3.2.5  Bean 的 Scope ................................................................................................... 38
3.2.6  Bean 的生命周期 .............................................................................................. 40
3.2.7  应用环境 ........................................................................................................... 43
3.2.8  条件配置（@Conditional） ............................................................................ 46
3.2.9  开启配置（@Enable*和@Import） ................................................................ 47
3.3  对 Bean 的处理（BeanPostProcessor） ...................................................................... 53
3.4  Spring Aware 容器 ....................................................................................................... 54
3.5  Bean 之间的事件通信 ................................................................................................. 57
3.6  Spring EL ...................................................................................................................... 59
3.7  AOP .............................................................................................................................. 61
3.8  注解工作原理 .............................................................................................................. 64
3.8.1  BeanPostProcessor ............................................................................................ 64
3.8.2  BeanFactoryPostProcessor ................................................................................ 66
3.8.3  使用AOP .......................................................................................................... 68
3.8.4  组合元注解 ....................................................................................................... 68
3.9小结......................................................................................................................68
第 4 章  深入 Spring Boot ............................................................................................. 69
4.1  Spring Boot 介绍 .......................................................................................................... 69
4.2  Spring Boot 的“魔法” .................................................................................................. 69
4.2.1  加载自动配置 ................................................................................................... 69
4.2.2  实现自动配置 ................................................................................................... 71
4.3  Spring Boot 的配置 ...................................................................................................... 73
4.3.1  应用配置 ........................................................................................................... 74
4.3.2  修改默认配置 ................................................................................................... 76
4.3.3  外部配置 ........................................................................................................... 79
4.4  日志和报告 .................................................................................................................. 91
4.4.1  日志 ................................................................................................................... 91
4.4.2  报告 ................................................................................................................... 93
4.5  多线程任务和计划任务 .............................................................................................. 94
4.5.1  Task Executor .................................................................................................... 94
4.5.2  Task Scheduler .................................................................................................. 97
4.6  Gradle 插件 .................................................................................................................. 99
4.6.1  依赖 ................................................................................................................... 99
4.6.2  Spring Boot Starter .......................................................................................... 100
4.6.3  插件任务 ......................................................................................................... 100
4.7  自定义Starter ............................................................................................................. 100
4.7.1  包装技术库 ..................................................................................................... 101
4.7.2  Starter 的结构 ................................................................................................. 103
4.7.3  autoconfigure 模块 .......................................................................................... 105
4.7.4  Starter 模块 ..................................................................................................... 107
4.7.5  使用 Starter ..................................................................................................... 108
4.8  Spring Boot Actuator .................................................................................................. 110
4.8.1  常用端点 ......................................................................................................... 110
4.8.2  自定义 ............................................................................................................. 119
4.8.3  使用 Prometheus 和Grafana 监控指标 ......................................................... 124
4.9  小结 ............................................................................................................................ 128
第 5 章  Spring Web MVC .......................................................................................... 129
5.1  Spring Web MVC 简介 .............................................................................................. 129
5.2  用 Spring Boot 学习Web MVC ................................................................................ 129
5.2.1  核心注解 ......................................................................................................... 129
5.2.2  RESTful 服务 .................................................................................................. 130
5.2.3  @ControllerAdvice ......................................................................................... 146
5.2.4  @RestControllerAdvice .................................................................................. 151
5.2.5  JSON 定制 ...................................................................................................... 156
5.2.6  RestTemplate ................................................................................................... 159
5.3  Web MVC 配置 .......................................................................................................... 161
5.3.1  Spring MVC 的工作原理 ............................................................................... 161
5.3.2  配置MVC ....................................................................................................... 161
5.3.3  Interceptor ....................................................................................................... 162
5.3.4  Formatter ......................................................................................................... 164
5.3.5  HttpMessageConverter .................................................................................... 166
5.3.6  方法参数和返回值处理设置 ......................................................................... 169
5.3.7  初始化数据绑定设置 ..................................................................................... 176
5.3.8  类型转换原理与设置 ..................................................................................... 176
5.3.9  路径匹配和内容协商 ..................................................................................... 183
5.3.10  JSON ............................................................................................................. 188
5.3.11 其他外部属性配置 ......................................................................................... 189
5.4  Servlet 容器 ................................................................................................................ 191
5.4.1  注册 Servlet、Filter 和 Listener ..................................................................... 191
5.4.2  配置 Servlet 容器 ............................................................................................ 196
5.5  异步请求 .................................................................................................................... 202
5.5.1  Servlet 3.0 异步返回 ...................................................................................... 202
5.5.2  HTTP Streaming.............................................................................................. 206
5.5.3  HTTP/2 ............................................................................................................ 212
5.6  小结 ............................................................................................................................ 214
第 6 章  数据访问 ....................................................................................................... 215
6.1   Spring Data Repository ............................................................................................. 215
6.1.1  DDD 与 Spring Data Repository ..................................................................... 215
6.1.2  查询方法 ......................................................................................................... 218
6.2  关系数据库——Spring Data JPA .............................................................................. 218
6.2.1  JPA、Hibernate 和Spring Data JPA .............................................................. 218
6.2.2  环境准备 ......................................................................................................... 218
6.2.3  自动配置 ......................................................................................................... 220
6.2.4  定义聚合 ......................................................................................................... 221
6.2.5  定义聚合 Repository ...................................................................................... 224
6.2.6  查询 ................................................................................................................. 226
6.2.7  事件监听 ......................................................................................................... 238
6.2.8  领域事件 ......................................................................................................... 242
6.2.9  审计功能 ......................................................................................................... 245
6.2.10  Web 支持 ...................................................................................................... 246
6.2.11  数据库初始化 ............................................................................................... 248
6.3  NoSQL——Spring Data Elasticsearch ....................................................................... 252
6.3.1  Elascticsearch 简介 ......................................................................................... 252
6.3.2  环境准备 ......................................................................................................... 252
6.3.3  自动配置 ......................................................................................................... 253
6.3.4  定义聚合 ......................................................................................................... 254
6.3.5  定义聚合 Repository ...................................................................................... 255
6.3.6  查询 ................................................................................................................. 256
6.4  数据缓存 .................................................................................................................... 261
6.4.1  Spring Boot 与缓存......................................................................................... 261
6.4.2  环境准备 ......................................................................................................... 262
6.4.3  使用缓存注解 ................................................................................................. 264
6.5  小结 ............................................................................................................................ 266
第 7 章  安全控制 ....................................................................................................... 267
7.1  Spring Security 的应用 .............................................................................................. 267
7.1.1  Spring Boot 的自动配置 ................................................................................. 267
7.1.2  开启Web 安全配置 ....................................................................................... 268
7.1.3  定制Web 安全配置 ....................................................................................... 268
7.1.4  Authentication ................................................................................................. 269
7.1.5  Authorization ................................................................................................... 281
7.1.6  Spring Data 集成 ............................................................................................. 294
7.2  Spring Security 实战 .................................................................................................. 295
7.3  OAuth 2.0 ................................................................................................................... 301
7.3.1  OAuth 2.0 Authorization Server ...................................................................... 301
7.3.2  OAuth 2.0 Resource Server ............................................................................. 310
7.3.3  OAuth 2.0 Client ............................................................................................. 317
7.4  小结 ............................................................................................................................ 322
第 8 章  响应式编程 .................................................................................................... 323
8.1  Project Reactor............................................................................................................ 323
8.1.1  Reactive Streams 的基础接口 ........................................................................ 323
8.1.2  Flux 和 Mono .................................................................................................. 325
8.2  Spring WebFlux .......................................................................................................... 327
8.2.1  Spring WebFlux 基础 ..................................................................................... 327
8.2.2  Spring Boot 的自动配置 ................................................................................. 328
8.2.3  注解控制器 ..................................................................................................... 329
8.2.4  函数式端点 ..................................................................................................... 332
8.2.5  Spring WebFlux 的配置 ................................................................................. 334
8.3  Reactive NoSQL ......................................................................................................... 334
8.3.1  响应式 Elasticsearch ....................................................................................... 335
8.3.2  响应式 MongoDB ........................................................................................... 339
8.4  Reactive 关系型数据库：R2DBC ............................................................................. 342
8.4.1  安装 PostgreSQL ............................................................................................ 343
8.4.2  Spring Boot 的自动配置 ................................................................................. 343
8.4.3  示例 ................................................................................................................. 344
8.5  Reactive Spring Security ............................................................................................ 347
8.5.1  Reactive Spring Security 原理 ........................................................................ 347
8.5.2  Spring Boot 的自动配置 ................................................................................. 347
8.5.3  示例 ................................................................................................................. 348
8.6  小结 ............................................................................................................................ 354
第 9 章  事件驱动 ....................................................................................................... 355
9.1  JMS ............................................................................................................................. 355
9.1.1  安装Apache ActiveMQ Artemis .................................................................... 355
9.1.2  新建应用 ......................................................................................................... 356
9.1.3  Spring Boot 的自动配置 ................................................................................. 356
9.1.4  示例 ................................................................................................................. 356
9.1.5  Topic 和 Queue ............................................................................................... 358
9.2  RabbitMQ ................................................................................................................... 360
9.3  Kafka .......................................................................................................................... 367
9.4  Websocket .................................................................................................................. 374
9.4.1  STOMP Websocket ......................................................................................... 374
9.4.2  Reactive Websocket ........................................................................................ 379
9.5  RSocket ....................................................................................................................... 382
9.5.1  新建应用 ......................................................................................................... 382
9.5.2  Spring Boot 的自动配置 ................................................................................. 383
9.5.3  示例 ................................................................................................................. 383
9.6  小结 ............................................................................................................................ 388
第 10 章  系统集成与批处理 ....................................................................................... 389
10.1  Spring Integration ..................................................................................................... 389
10.1.1  Spring Integration 基础 ................................................................................. 389
10.1.2  Spring Integration Java DSL ......................................................................... 391
10.1.3  示例 ............................................................................................................... 392
10.2  Spring Batch ............................................................................................................. 395
10.2.1  Spring Batch 的流程 ..................................................................................... 396
10.2.2  Spring Boot 的自动配置 ............................................................................... 396
10.2.3  示例 ............................................................................................................... 397
10.3  小结 .......................................................................................................................... 402
第 11 章  Spring Cloud 与微服务 ................................................................................ 403  11.1  微服务基础 .............................................................................................................. 403  11.1.1  微服务和云原生应用 ................................................................................... 403
11.1.2  领域驱动设计 ............................................................................................... 404
11.2  Spring Cloud ............................................................................................................. 405
11.2.1  服务发现 ....................................................................................................... 405
11.2.2  配置管理 ....................................................................................................... 408
11.2.3  同步服务交互 ............................................................................................... 412
11.2.4  异步服务交互 ............................................................................................... 417
11.2.5  响应式异步交互 ........................................................................................... 427
11.2.6  应用网关：Spring Cloud Gateway .............................................................. 430
11.2.7  认证授权 ....................................................................................................... 433
11.3  小结 .......................................................................................................................... 442
第 12 章  Kubernetes 与微服务 .................................................................................. 443
12.1  Kubernetes ................................................................................................................ 443
12.1.1  安装 ............................................................................................................... 443
12.1.2  Kubernetes 基础知识 .................................................................................... 445
12.1.3  Helm .............................................................................................................. 460
12.1.4  DevOps .......................................................................................................... 463
12.1.5  安装Jenkins .................................................................................................. 464
12.1.6  微服务示例 ................................................................................................... 465
12.1.7  镜像仓库和 Dockerfile ................................................................................. 467
12.1.8  使用Helm 打包应用 .................................................................................... 471
12.1.9  Jenkins 流程 .................................................................................................. 475
12.2  Service Mesh 和 Istio ............................................................................................... 481
12.2.1  安装Istio ....................................................................................................... 482
12.2.2  微服务示例 ................................................................................................... 483
12.3  小结 .......................................................................................................................... 490
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>从企业级开发到云原生微服务：Spring Boot实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaEE 轻量级框架
第1章 3个框架的概述
1.1 软件开发中需要解决的问题
1.2 Struts2、Hibernate和Spring框架
第2章 Struts2的基础知识
2.1 MVC模式
2.2 Struts2的基本工作原理
2.2.1 Struts2的框架结构
2.2.2 Struts2的控制流程
2.3 Struts2的工作环境
2.3.1 搭建Struts开发环境
2.3.2 创建一个简单的Struts2程序
2.3.3 Struts2的配置
2.4 Action的创建和配置
2.4.1 Action的创建
2.4.2 Action的多方法调用
2.4.3 Result类型
2.4.4 在Action中调用Web对象
实验一 创建一个简单的Struts2应用程序
实验二 创建一个Action多方法调用的Struts2应用程序
第3章 Struts2标签库及使用
3.1 Struts2标签库概述
3.2 0GNL表达式语言
3.2.1 0GNL基础知识
3.2.2 0GNL的集合操作
3.3 Struts2标签
3.3.1 表单标签
3.3.2 控制标签
3.3.3 其他常用标签
3.4 标签综合应用
3.4.1 综合实例1
3.4.2 综合实例2
实验三Struts2标签的应用
第4章 Struts2的高级特性
4.1 拦截器
4.1.1 Struts2中拦截器的工作过程
4.1.2 在Struts2中内置拦截器
4.1.3 配置拦截器
4.1.4 拦截器的使用
4.1.5 自定义拦截器
4.2 Struts2的国际化
4.2.1 在Struts2中加载全局资源文件
4.2.2 访问国际化消息
4.3 Struts2校验框架
4.3.1 编写校验规则文件
4.3.2 Struts2的内建校验规则
4.4 Struts2开发案例
实验四Struts2校验框架的应用
第5章 Hibernate的基础知识
5.1 0RM基本概念
5.1.1 0RM框架简介
5.1.2 0RM中的映射关系
5.2 Hibernate的体系结构.
5.3 HibernateAPI简介
5.4 Hibernate的配置文件
5.5 Hibernate中的持久化类
5.6 Hibernate的对象——关系映射文件
5.7 通过HibernateAPI操纵数据库
5.8 在MyEclipse中使用Hibernate
5.9 Session的缓存
实验五完成表的查询和删除操作
……
第6章 Hibernate的关联映射
第7章 Hibernate查询
第8章 Struts2与Hibernate3的集成开发案例——网上书店
第9章 Spring的基础知识
第10章 Spring的基本用法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaEE 轻量级框架
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MyBatis从入门到精通
第1章  MyBatis入门	1
1.1  MyBatis简介	2
1.2  创建Maven项目	3
1.3　简单配置让MyBatis跑起来	7
1.3.1　准备数据库	8
1.3.2  配置MyBatis	8
1.3.3  创建实体类和Mapper.xml文件	10
1.3.4  配置Log4j以便查看MyBatis操作数据库的过程	11
1.3.5  编写测试代码让MyBatis跑起来	12
1.4  本章小结	14
第2章  MyBatis XML方式的基本用法	15
2.1  一个简单的权限控制需求	16
2.1.1  创建数据库表	16
2.1.2  创建实体类	19
2.2  使用XML方式	21
2.3  select用法	23
2.4  insert用法	35
2.4.1  简单的insert方法	35
2.4.2  使用JDBC方式返回主键自增的值	38
2.4.3  使用selectKey返回主键的值	40
2.5  update用法	42
2.6  delete用法	45
2.7  多个接口参数的用法	47
2.8  Mapper接口动态代理实现原理	50
2.9  本章小结	51
第3章  MyBatis注解方式的基本用法	53
3.1  @Select注解	54
3.1.1  使用mapUnderscoreToCamelCase配置	55
3.1.2  使用resultMap方式	55
3.2  @Insert注解	58
3.2.1  不需要返回主键	58
3.2.2  返回自增主键	58
3.2.3  返回非自增主键	59
3.3  @Update注解和@Delete注解	59
3.4  Provider注解	60
3.5  本章小结	61
第4章  MyBatis动态SQL	63
4.1  if用法	64
4.1.1  在WHERE条件中使用if	64
4.1.2  在UPDATE更新列中使用if	68
4.1.3  在INSERT动态插入列中使用if	70
4.2  choose用法	72
4.3  where、set、trim用法	75
4.3.1  where用法	75
4.3.2  set用法	76
4.3.3  trim用法	77
4.4  foreach用法	78
4.4.1  foreach实现in集合	78
4.4.2  foreach实现批量插入	81
4.4.3  foreach实现动态UPDATE	84
4.5  bind用法	86
4.6  多数据库支持	86
4.7  OGNL用法	89
4.8  本章小结	90
第5章  Mybatis代码生成器	91
5.1  XML配置详解	92
5.1.1  property标签	95
5.1.2  plugin标签	96
5.1.3  commentGenerator标签	97
5.1.4  jdbcConnection标签	99
5.1.5  javaTypeResolver标签	100
5.1.6  javaModelGenerator标签	101
5.1.7  sqlMapGenerator标签	102
5.1.8  javaClientGenerator标签	103
5.1.9  table标签	104
5.2  一个配置参考示例	109
5.3  运行MyBatis Generator	111
5.3.1  使用Java编写代码运行	111
5.3.2  从命令提示符运行	113
5.3.3  使用Maven Plugin运行	115
5.3.4  使用Eclipse插件运行	117
5.4  Example介绍	119
5.5  本章小结	124
第6章  MyBatis高级查询	125
6.1  高级结果映射	126
6.1.1  一对一映射	126
6.1.2  一对多映射	140
6.1.3  鉴别器映射	156
6.2  存储过程	159
6.2.1  第一个存储过程	162
6.2.2  第二个存储过程	164
6.2.3  第三个和第四个存储过程	166
6.2.4  在Oracle中使用游标参数的存储过程	168
6.3  使用枚举或其他对象	170
6.3.1  使用MyBatis提供的枚举处理器	170
6.3.2  使用自定义的类型处理器	172
6.3.3  对Java 8日期（JSR-310）的支持	175
6.4  本章小结	176
第7章  MyBatis缓存配置	177
7.1  一级缓存	178
7.2  二级缓存	181
7.2.1  配置二级缓存	181
7.2.2  使用二级缓存	184
7.3  集成EhCache缓存	187
7.4  集成Redis缓存	190
7.5  脏数据的产生和避免	191
7.6  二级缓存适用场景	194
7.7  本章小结	194
第8章  MyBatis插件开发	195
8.1  拦截器接口介绍	196
8.2  拦截器签名介绍	198
8.2.1  Executor接口	198
8.2.2  ParameterHandler接口	200
8.2.3  ResultSetHandler接口	201
8.2.4  StatementHandler接口	202
8.3  下画线键值转小写驼峰形式插件	203
8.4  分页插件	206
8.4.1  PageInterceptor拦截器类	207
8.4.2  Dialect接口	212
8.4.3  MySqlDialect实现	216
8.5  本章小结	220
第9章  Spring集成MyBatis	221
9.1  创建基本的Maven Web项目	222
9.2  集成Spring和Spring MVC	227
9.3  集成MyBatis	232
9.4  几个简单实例	234
9.4.1  基本准备	235
9.4.2  开发Mapper层（Dao层）	235
9.4.3  开发业务层（Service层）	238
9.4.4  开发控制层（Controller层）	240
9.4.5  开发视图层（View层）	242
9.4.6  部署和运行应用	245
9.5  本章小结	246
第10章  Spring Boot集成MyBatis	247
10.1  基本的Spring Boot项目	248
10.2  集成MyBatis	251
10.3  MyBatis Starter配置介绍	253
10.4  简单示例	255
10.4.1  引入simple依赖	255
10.4.2  开发业务（Service）层	258
10.4.3  开发控制（Controller）层	259
10.4.4  运行应用查看效果	259
10.5  本章小结	260
第11章  MyBatis开源项目	261
11.1  Git入门	262
11.1.1  初次运行配置	262
11.1.2  初始化和克隆仓库	263
11.1.3　本地操作	265
11.1.4  远程操作	267
11.2  GitHub入门	269
11.2.1  创建并提交到仓库	269
11.2.2  Fork仓库并克隆到本地	272
11.2.3  社交功能	275
11.3  MyBatis源码讲解	278
11.4  MyBatis测试用例	290
11.5  本章小结	293
附录  类型处理器（TypeHandler）	295
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MyBatis从入门到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>马克西姆经典钢琴名曲
1澄镜之水
2克罗地亚狂想曲
3克劳汀幻想曲
4C小调革命进行曲
5韩德尔变奏曲
6古巴！古巴！
7汉娜之眼
8野蜂飞舞
9胜利
10亚马逊之魂
11格里格钢琴变奏曲
12新乐园
13诺斯特拉达姆
14蜂鸟
15利鲁之歌
16荒漠天际
17天国的孩子
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>马克西姆经典钢琴名曲
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Servlet＆JSP技術手冊
目錄
第1章 簡介Web應用程式
第2章 撰寫與設定Servlet
第3章 請求與回應
第4章 會話管理
第5章 Servlet進階API、過濾器與傾聽器
第6章 使用JSP
第7章 使用JSTL
第8章 自訂標籤
第9章 整合資料庫
第10章 Web容器安全管理
第11章 JavaMail入門
第12章 從模式到框架
附錄A 如何使用本書專案
附錄B MySQL入門
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Servlet＆JSP技術手冊
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JSP & Servlet学习笔记（第3版）
Chapter 1  Web应用程序简介   1
1.1  Web应用程序基础   2
1.1.1  关于HTML   2
1.1.2  URL、URN与URI   3
1.1.3  关于HTTP   5
1.1.4  HTTP请求方法   6
1.1.5  有关URI编码   9
1.1.6  后端与前端   11
1.1.7　Web安全概念   13
1.2  Servlet/JSP简介   14
1.2.1  何谓Web容器   14
1.2.2  Servlet与JSP的关系   16
1.2.3  关于MVC/Model 2   19
1.2.4  Java EE简介   22
1.3  重点复习   23
Chapter 2  编写与设置Servlet   24
2.1  第一个Servlet   25
2.1.1  准备开发环境   25
2.1.2  第一个Servlet程序   27
2.2  在Hello之后   29
2.2.1  关于HttpServlet   30
2.2.2  使用@WebServlet   32
2.2.3  使用web.xml   33
2.2.4  文件组织与部署   36
2.3  进阶部署设置   37
2.3.1  URL模式设置   37
2.3.2  Web文件夹结构   40
2.3.3  使用web-fragment.xml   41
2.4  重点复习   44
2.5  课后练习   45
Chapter 3  请求与响应   46
3.1  从容器到HttpServlet   47
3.1.1  Web容器做了什么   47
3.1.2  doXXX()方法   49
3.2  关于HttpServletRequest   52
3.2.1  处理请求参数   52
3.2.2　处理请求标头   55
3.2.3  请求参数编码处理   56
3.2.4  getReader()、getInputStream()读取内容   58
3.2.5  getPart()、getParts()取得
上传文件   62
3.2.6  使用RequestDispatcher调派请求   67
3.3  关于HttpServletResponse   73
3.3.1  设置响应标头、缓冲区   73
3.3.2  使用getWriter()输出字符   75
3.3.3  使用getOutputStream()输出
二进制字符   78
3.3.4  使用sendRedirect()、
sendError()   80
3.4  综合练习   81
3.4.1  微博应用程序功能概述   82
3.4.2  实现会员注册功能   83
3.4.3  实现会员登录功能   88
3.5  重点复习   89
3.6  课后练习   90
Chapter 4  会话管理   92
4.1  会话管理基本原理   93
4.1.1  使用隐藏域   93
4.1.2  使用Cookie   96
4.1.3  使用URI重写   100
4.2  HttpSession会话管理   102
4.2.1  使用HttpSession   103
4.2.2  HttpSession会话管理
原理   107
4.2.3  HttpSession与URI重写   109
4.3  综合练习   111
4.3.1  登录与注销   111
4.3.2　会员信息管理   112
4.3.3　新增与删除信息   116
4.4  重点复习   118
4.5  课后练习   119
Chapter 5  Servlet进阶API、过滤
器与监听器   120
5.1  Servlet进阶API   121
5.1.1  Servlet、ServletConfig与GenericServlet   121
5.1.2  使用ServletConfig   123
5.1.3  使用ServletContext   126
5.1.4　使用PushBuilder   128
5.2  应用程序事件、监听器   130
5.2.1  ServletContext事件、
监听器   130
5.2.2  HttpSession事件、
监听器   135
5.2.3  HttpServletRequest事件、
监听器   141
5.3  过滤器   142
5.3.1  过滤器的概念   142
5.3.2  实现与设置过滤器   144
5.3.3  请求封装器   149
5.3.4  响应封装器   153
5.4  异步处理   157
5.4.1  AsyncContext简介   158
5.4.2  异步Long Polling   160
5.4.3  更多AsyncContext细节   163
5.4.4　异步Server-Sent Event   164
5.4.5　使用ReadListener   167
5.4.6　使用WriteListener   169
5.5  综合练习   172
5.5.1  创建UserService   172
5.5.2  设置过滤器   177
5.5.3  重构微博   179
5.6  重点复习   183
5.7  课后练习   185
Chapter 6  使用JSP   186
6.1  从JSP到Servlet   187
6.1.1  JSP生命周期   187
6.1.2  Servlet至JSP的简单
转换   191
6.1.3  指示元素   194
6.1.4  声明、Scriptlet与表达式
元素   197
6.1.5  注释元素   201
6.1.6  隐式对象   201
6.1.7  错误处理   204
6.2  标准标签   208
6.2.1  、标签   208
6.2.2  、与简介   209
6.2.3  深入、与   211
6.2.4  谈谈Model 1   214
6.2.5  XML格式标签   216
6.3  表达式语言(EL)   217
6.3.1  EL简介   218
6.3.2  使用EL取得属性   220
6.3.3  EL隐式对象   222
6.3.4  EL运算符   223
6.3.5  自定义EL函数   224
6.3.6　EL 3.0   226
6.4  综合练习   227
6.4.1  改用JSP实现视图   228
6.4.2  重构UserService与
member.jsp   231
6.4.3  创建register.jsp、index.jsp、user.jsp   234
6.5  重点复习   242
6.6  课后练习   243
Chapter 7  使用JSTL   244
7.1  JSTL简介   245
7.2  核心标签库   246
7.2.1  流程处理标签   246
7.2.2  错误处理标签   249
7.2.3  网页导入、重定向、URI
处理标签   250
7.2.4  属性处理与输出标签   252
7.3  I18N兼容格式标签库   254
7.3.1  I18N基础   254
7.3.2  信息标签   257
7.3.3  地区标签   259
7.3.4  格式标签   264
7.4  XML标签库   267
7.4.1  XPath、XSLT基础   267
7.4.2  解析、设置与输出标签   270
7.4.3  流程处理标签   271
7.4.4  文件转换标签   272
7.5  函数标签库   274
7.6  综合练习   275
7.6.1  修改index.jsp、
register.jsp   275
7.6.2  修改member.jsp   277
7.6.3  修改user.jsp   278
7.7  重点复习   278
7.8  课后练习   280
Chapter 8  自定义标签   281
8.1  Tag File自定义标签   282
8.1.1  Tag File简介   282
8.1.2  处理标签属性与Body   285
8.1.3  TLD文件   287
8.2  Simple Tag自定义标签   288
8.2.1  Simple Tag简介   288
8.2.2  了解API架构与生命
周期   290
8.2.3  处理标签属性与Body   293
8.2.4  与父标签沟通   296
8.2.5  TLD文件   300
8.3  Tag自定义标签   301
8.3.1  Tag简介   301
8.3.2  了解架构与生命周期   302
8.3.3  重复执行标签Body   304
8.3.4  处理Body运行结果   306
8.3.5  与父标签沟通   309
8.4  综合练习   311
8.4.1　重构/使用DAO   312
8.4.2　加强user.jsp   315
8.5  重点复习   317
8.6  课后练习   319
Chapter 9  整合数据库   320
9.1  JDBC入门   321
9.1.1  JDBC简介   321
9.1.2  连接数据库   327
9.1.3  使用Statement、
ResultSet   331
9.1.4  使用PreparedStatement、CallableStatement   335
9.2  JDBC进阶   338
9.2.1  使用DataSource取得
连接   338
9.2.2  使用ResultSet卷动、更新
数据   341
9.2.3  批次更新   343
9.2.4  Blob与Clob   344
9.2.5  事务简介   350
9.2.6  metadata简介   356
9.2.7  RowSet简介   358
9.3  使用SQL标签库   363
9.3.1  数据源、查询标签   363
9.3.2  更新、参数、事务标签   364
9.4  综合练习   366
9.4.1  使用JDBC实现DAO   366
9.4.2  设置JNDI部署描述   369
9.4.3　实现首页最新信息   370
9.5  重点复习   374
9.6  课后练习   375
Chapter 10  Web容器安全管理   376
10.1  了解与实现Web容器安全
管理   377
10.1.1  Java EE安全基本
概念   377
10.1.2  声明式基本身份验证   379
10.1.3  容器基本身份验证
原理   384
10.1.4  声明式窗体验证   385
10.1.5  容器窗体验证原理   386
10.1.6  使用HTTPS保护
数据   387
10.1.7  编程式安全管理   389
10.1.8  标注访问控制   391
10.2  综合练习   393
10.2.1  使用容器窗体验证   393
10.2.2  设置DataSource-
Realm   395
10.3  重点复习   396
10.4  课后练习   397
Chapter 11  JavaMail入门   398
11.1  使用JavaMail   399
11.1.1  发送纯文字邮件   399
11.1.2  发送多重内容邮件   401
11.2  综合练习   405
11.2.1  发送验证账号邮件   405
11.2.2　验证用户账号   411
11.2.3　发送重设密码邮件   412
11.2.4　重新设置密码   415
11.3  重点复习   418
11.4  课后练习   419
Chapter 12  Spring起步走   420
12.1　使用Gradle   421
12.1.1　下载和设置Gradle   421
12.1.2　简单的Gradle项目   422
12.1.3　Gradle与Eclipse   423
12.2　认识Spring核心   425
12.2.1　相依注入   425
12.2.2　使用Spring核心   427
12.3　重点复习   430
12.4  课后练习   430
Chapter 13  整合Spring MVC   431
13.1　初识Spring MVC   432
13.1.1　链接库或框架   432
13.1.2　初步套用Spring
MVC   433
13.1.3　注入服务对象与
属性   440
13.2　逐步善用Spring MVC   444
13.2.1　简化控制器   444
13.2.2　建立窗体对象   449
13.2.3　关于Thymeleaf
模板   452
13.3　重点复习   455
13.4  课后练习   456
Chapter 14  简介Spring Boot   457
14.1　初识Spring Boot   458
14.1.1　哈喽！Spring Boot！   458
14.1.2　实现MVC   461
14.1.3　使用JSP   464
14.2　整合IDE   465
14.2.1　导入Spring Boot
项目   465
14.2.2　Spring Tool Suite   466
14.3　重点复习   467
14.4  课后练习   468
Appendix A  如何使用《JSP & Servlet学习笔记（第3版）——从Servlet到Spring Boot》项目   469
A.1　项目环境配置   470
A.2　范例项目导入   470


Java EE 7/8 新功能索引
web.xml版本变动   33
web.xml新增   34
HttpServletRequest新增getHttpServletMapping()   39
web.xml新增   57
Part新增getSubmittedFileName()   64
web.xml新增   76
HttpServletRequest新增changeSessionId()   104
ServletContext新增setSessionTimeout()   109
新增PushBuilder   128
新增HttpSessionIdListener   141
新增了GenericFilter、HttpFilter类别   145
ServletInputStream非阻断输入   168
ServletOutputStream非阻断输出   170
Expression Language 3.0   226
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JSP & Servlet学习笔记（第3版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>故事的影响力
前言 故事的魅力
第一部分 为变革讲一个好故事
第1章 从默默无闻到成为焦点
第2章 讲述恰当的故事
第3章 说一个好故事胜过千言万语
第二部分 透视推动变革的好故事
第4章 探究听众对故事的解读方式
第5章 激发听众成为变革的推动者
第6章 为听众量身打造的故事
第7章 讲故事比逻辑分析更有效
第三部分 打造激发听众热情的故事
第8章 创作故事
第9章 表现故事
第10章 加工故事
第11章 有效沟通才是硬道理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>故事的影响力
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>遙遠的目擊者
序◎傑夫．賈維斯（Jeff Jarvis）
前言
第一章 突尼西亞 Tunisia
星星之火 The Spark
第二章 埃及 Egypt
大火延燒 The Fire Spreads
塔利爾廣場之戰 The Battle for Tahrir Square
人民的要求 The People Demand
發展受挫 Arrested Development
第三章 巴林 Bahrain
我們不會被你打倒 U Cant Break Us
第四章 利比亞 Libya
大賭注高風險 Long Shot
燭火不會白燒 A Candle Loses Nothing
謠言滿天飛 Tilting at Rumor Mills
解放之路 The Road To Liberation
L-團隊 The L-Team
多鏡頭拍攝  Multi-Camera Shoot
第五章 葉門 Yemen
衝突報告 Conflicting Reports
第六章 敘利亞 Syria
大馬士革同性戀女孩 Outing A Gay Girl in Damascus
錄影毛片 Raw Footage
第七章 後記
催淚彈俱樂部 The Tear Gas Club
革命遺產 A Revolution’s Legacy
致謝
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>遙遠的目擊者
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
致谢
序言（一）
序言（二）
第一章　明日寓言
第二章　忍耐的义务
第三章　死神的特效药
第四章　地表水和地下水
第五章　土壤的疆域
第六章　大地的绿色幔布
第七章　无谓的浩劫
第八章　鸟儿不再歌唱
第九章　死亡之河
第十章　　空中撒药，无孔不入
第十一章　波吉亚家族的噩梦
第十二章　人类的代价
第十三章　穿过狭窄的窗户
第十四章　持续现状会导致每四个人中有一个患癌
第十五章　大自然的报复
第十六章　雪崩的轰鸣声
第十七章　另一条道路
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂靜的春天
前言
作者序
第一章 明日寓言
第二章 忍耐的義務
第三章 致命的萬靈丹
第四章 地球的水
第五章 土壤的國度
第六章 地球的綠衣
第七章 無謂的破壞
第八章 沒有鳥兒歌唱
第九章 死河
第十章 禍從天降
第十一章 如影隨形的惡夢
第十二章 人的價格
第十三章 一扇窄窗
第十四章 四分之一
第十五章 大自然的反撲
第十六章 大災難的徵兆
第十七章 另一條路
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂靜的春天
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
：蕾切尔·卡逊一直与我们在一起
鸣谢
第一章 为明天写的一则寓言
第二章 忍耐的义务
第三章 死神的特效药
第四章 地表水和地下水
第五章 土壤的世界
第六章 地球的绿色植被
第七章 毫无必要的大破坏
第八章 再也没有鸟儿歌唱
第九章 死亡的河流
第十章 肆无忌惮的空中喷药
第十一章 超越波吉亚家族的梦想
第十二章 人类的代价
第十三章 透过一扇狭小的窗
第十四章 每四个中有一个
第十五章 大自然的反击
第十六章 隆隆的崩塌声
第十七章 另一条路
附录
《农药的使用》
奥尔加·欧文斯·哈金斯写给波士顿《先驱报》的信
蕾切尔·卡逊对哈金斯的相关回忆及回信
《寂静的春天》的评述摘录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>听了那么多大道理，为什么依旧过不好这一生
引言 关于成功的两个问题
第一个问题：什么是成功
第一章 第一个答案：选择你自己的人生
第二章 呼之欲出的答案：感到幸福
第三章 来自社会的答案：追名、逐利、求地位
第四章 鼓舞人心的答案：找到一份有意义的工作
第二个问题：我如何获得成功
第五章 发现你比大多数人做得更好的事情：能力
第六章 燃烧你的小宇宙：动力
第七章 学会面对失败：自信
第八章 集中所有思维力量：激情、想象力、直觉和理智
第九章 影响他人：信誉和对话
结语 正确答案
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>听了那么多大道理，为什么依旧过不好这一生
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Eclipse RCP与Spring OSGi
推荐序
前言
第一部分　基　础　篇
第1章　初识Eclipse RCP / 2
1.1　Eclipse平台概述 / 2
1.2　Eclipse RCP概述 / 2
1.3　Eclipse RCP的应用 / 3
1.4　OSGi与Equinox / 5
1.5　SWT与JFace / 7
1.6　小结 / 7
第2章　搭建Eclipse RCP开发环境 / 8
2.1　JDK的安装与配置 / 8
2.1.1　下载JDK安装程序 / 8
2.1.2　安装JDK运行程序 / 8
2.1.3　配置JDK运行环境 / 10
2.1.4　测试JDK安装状态 / 11
2.1.5　卸载JDK应用程序 / 11
2.2　安装Eclipse IDE / 12
2.2.1　Eclipse开发包 / 12
2.2.2　Eclipse版本更新 / 13
2.2.3　下载Eclipse / 14
2.2.4　安装Eclipse / 14
2.2.5　技术资源 / 14
2.3　Maven的安装与配置 / 14
2.3.1　Maven介绍 / 14
2.3.2　下载Maven / 15
2.3.3　安装Maven / 15
2.3.4　测试Maven / 16
2.3.5　修改Maven的配置文件 / 16
2.3.6　技术资源 / 17
2.4　Maven和Eclipse的集成 / 17
2.4.1　安装Maven Eclipse插件 / 17
2.4.2　配置Maven Eclipse插件 / 18
2.4.3　技术资源 / 18
2.5　安装Spring IDE Plugin / 19
2.5.1　Spring IDE介绍 / 19
2.5.2　安装Spring IDE插件 / 19
2.5.3　技术资源 / 19
2.6　安装WindowBuilderProPlugin / 20
2.6.1　WindowBuilder介绍 / 20
2.6.2　安装WindowBuilder插件 / 21
2.7　小结 / 21
第3章　SWT界面设计详解 / 22
3.1　SWT介绍 / 22
3.2　WindowBuilder插件初识 / 23
3.2.1　设计视图 / 23
3.2.2　源码视图 / 24
3.2.3　结构视图 / 26
3.3　SWT设计面板 / 26
3.4　SWT设计准备 / 27
3.4.1　Element / 27
3.4.2　ElementFactory / 28
3.5　Shell使用入门 / 30
3.5.1　Shell样式 / 30
3.5.2　Shell TRIM / 30
3.5.3　Shell模态类型 / 31
3.6　容器使用入门 / 33
3.6.1　Composite / 33
3.6.2　Group / 34
3.6.3　ScrolledComposit / 35
3.6.4　SashForm / 36
3.6.5　TabFolder与TabItem / 36
3.6.6　CTabFolder与CTabItem / 37
3.6.7　ViewForm / 38
3.6.8　CBanner / 40
3.7　容器使用进阶 / 41
3.7.1　checkSubclass方法 / 41
3.7.2　界面复用 / 42
3.7.3　添加自定义的Component / 44
3.7.4　背景模式 / 45
3.7.5　带分隔条的SashForm / 47
3.8　布局使用入门 / 48
3.8.1　AbsoluteLayout / 48
3.8.2　FillLayout / 49
3.8.3　GridLayout / 50
3.8.4　FormLayout / 51
3.8.5　RowLayout / 52
3.8.6　StackLayout / 53
3.8.7　GroupLayout / 54
3.8.8　FlowLayout / 55
3.8.9　BoxLayout / 56
3.8.10　BorderLayout / 57
3.9　布局使用进阶 / 58
3.9.1　使用AbsoluteLayout / 58
3.9.2　 使用GridLayout / 59
3.9.3　StackLayout / 59
3.10　控件使用入门 / 60
3.10.1　Label / 60
3.10.2   CLabel / 61
3.10.3　Separator / 62
3.10.4   Text / 63
3.10.5　StyledText / 63
3.10.6　Combo / 64
3.10.7   CCombo / 64
3.10.8　List / 65
3.10.9　Button / 66
3.10.10　DateTime / 68
3.10.11　Spinner / 68
3.10.12　Slider / 69
3.10.13　Scale / 70
3.10.14　Link / 70
3.10.15　ToolBar与ToolItem / 71
3.10.16　CoolBar与CoolItem / 73
3.10.17　ExpandBar与ExpandItem / 74
3.10.18　ProgressBar / 75
3.10.19　Browser / 76
3.10.20　Canvas / 77
3.10.21　TrayItem / 77
3.10.22　Table / 78
3.10.23　Tree / 80
3.10.24　TableTree / 81
3.11　控件使用进阶 / 83
3.11.1　创建Simple Table / 83
3.11.2　创建Lazy Table / 86
3.11.3　创建Virtual Table / 89
3.11.4　Virtual Table注意事项 / 92
3.11.5　Virtual Table排序 / 94
3.11.6　创建Lazy Tree / 95
3.11.7　创建Virtual Tree / 100
3.11.8　创建TreeVirtualDynamic / 104
3.11.9　创建POJOComposite / 106
3.11.10　如何与浏览器交互 / 107
3.12　菜单使用入门 / 111
3.12.1　Menu Bar组件 / 111
3.12.2 　Popup Menu / 112
3.12.3 　MenuItem / 113
3.13　菜单使用进阶 / 113
3.14　技术资源 / 113
3.15　小结 / 114
第4章　JFace界面设计详解 / 115
4.1　MVC设计思想 / 115
4.1.1　MVC模式 / 115
4.1.2   Java与MVC模式 / 116
4.2　JFace与MVC模式 / 117
4.2.1　JFace Viewer框架概述 / 117
4.2.2　JFace Viewer框架机制 / 118
4.3　JFace常用组件入门 / 121
4.3.1　ComboViewer / 122
4.3.2   ListViewer / 130
4.3.3   TableViewer / 132
4.3.4   TreeViewer / 135
4.3.5   CheckboxTableViewer / 137
4.3.6　CheckboxTreeViewer / 139
4.3.7　TreeTableViewer / 141
4.3.8   TableViewer Composite / 141
4.3.9   Table Composite / 142
4.3.10　TreeViewer Composite / 142
4.3.11　Tree Composite / 143
4.4　JFace组件使用进阶 / 143
4.4.1　数据绑定 / 143
4.4.2   基于EditingSupport的可编辑表格 / 146
4.4.3　基于ICellModifier的可编辑表格 / 147
4.4.4   对话框编辑器 / 149
4.4.5　其他表格标签 / 150
4.4.6   Viewer浮动提示控件 / 151
4.5　小结 / 153
第5章　Eclipse Forms与Nebula界面设计 / 154
5.1　Eclipse Forms项目介绍 / 154
5.2　Eclipse Forms使用入门 / 154
5.2.1　Composite / 154
5.2.2　ExpandableComposite / 155
5.2.3　Label与Text / 158
5.2.4　Hyperlink与ImageHyperlink / 158
5.2.5　Composite Separator / 159
5.2.6   Section / 160
5.2.7　Form与ScrolledForm / 162
5.3　Eclipse Forms使用进阶 / 164
5.3.1　FormEditor与FormPage / 164
5.3.2　MasterDetailsBlock 与IDetailsPage / 167
5.4　Eclipse Forms技术资源 / 173
5.5　Nebula项目介绍 / 173
5.6　安装Eclipse Nebula Plugin / 174
5.6.1　安装Eclipse Nebula Main Widgets / 174
5.6.2　安装Eclipse Nebula incubation Widgets / 174
5.6.3　加载Eclipse Nebula控件到WindowBuilder Pro Plugin中 / 174
5.7　Nebula Main Widgets设计初识 / 176
5.8　Nebula Incubation widgets设计初识 / 177
5.9　Nebula设计经验 / 178
5.10　Nebula技术资源 / 180
5.11　小结 / 180
第二部分　高　级　篇
第6章　Eclipse RCP 开发基础 / 182
6.1　Eclipse概念 / 182
6.1.1　欢迎界面 / 183
6.1.2　工作台 / 183
6.1.3　透视图 / 184
6.1.4　视图 / 184
6.1.5　编辑器 / 185
6.2　RCP应用程序设计 / 185
6.2.1　RCP插件创建向导 / 185
6.2.2　Plug-in Project / 185
6.2.3　Plugin Content / 186
6.2.4　Templates / 187
6.2.5　Sample Intro / 188
6.2.6　产品初次运行 / 188
6.3　插件清单编辑器 / 189
6.3.1　插件概述 / 189
6.3.2　插件依赖项 / 191
6.3.3　插件运行时 / 193
6.3.4　插件扩展 / 197
6.3.5　插件扩展点 / 199
6.3.6　插件构建 / 199
6.3.7   其他页面 / 200
6.4　RCP Activator与Advisor类解析 / 200
6.4.1　WorkshopAppActivator / 200
6.4.2　Application / 201
6.4.3　ActionBarAdvisor / 202
6.4.4　WorkbenchAdvisor / 203
6.4.5　WorkbenchWindowAdvisor / 205
6.5　小结 / 206
第7章　构建产品帮助系统 / 207
7.1　创建帮助插件向导 / 207
7.1.1　帮助插件的 Content向导页面 / 208
7.1.2　帮助插件的Templates向导页面 / 208
7.1.3　帮助插件的Sample Help Table of Contents向导页面 / 209
7.2　维护Help Content / 209
7.2.1　帮助系统配置与资源文件的目录 / 209
7.2.2　帮助系统配置与资源文件的关系 / 210
7.2.3　帮助系统扩展 / 211
7.3　添加帮助的菜单项 / 211
7.4　帮助文件的创建 / 212
7.5　小结 / 212
第8章　构建产品欢迎页面 / 213
8.1　产品绑定欢迎页面 / 213
8.1.1　欢迎页面扩展 / 213
8.1.2　欢迎页面定义 / 215
8.1.3　欢迎页面首页 / 215
8.1.4　页面跳转链接 / 216
8.2　欢迎页面请求 / 216
8.2.1　创建IIntroAction  / 216
8.2.2　添加IIntroAction链接 / 217
8.3　添加动态内容 / 217
8.3.1　动态页面创建 / 217
8.3.2　动态数据创建 / 218
8.4   创建页面扩展 / 219
8.5   小结 / 221
第9章　构建产品多国语言 / 222
9.1　插件清单的多国语言 / 222
9.2　Java程序的多国语言 / 223
9.2.1　Java程序的外部化字符串 / 223
9.2.2   Java程序的多国语言包 / 226
9.2.3   产品多国语言进阶 / 228
9.3   帮助系统的多国语言 / 229
9.4   Eclipse界面汉化 / 230
9.5   切换软件系统语言 / 234
9.5.1   添加自定义产品的config文件 / 234
9.5.2   添加语言切换扩展点 / 234
9.5.3   语言切换处理器 / 236
9.6   小结 / 238
第10章　产品的运行与导出 / 240
10.1   产品配置 / 240
10.2   产品配置编辑器 / 241
10.3   导出向导 / 244
10.3.1   产品导出 / 244
10.3.2   跨平台导出 / 245
10.3.3　插件导出 / 247
10.4　运行与导出进阶 / 247
10.5   小结 / 250
第11章　Eclipse RCP扩展的使用 / 251
11.1   ViewPart 视图 / 251
11.1.1　创建新插件 / 251
11.1.2　视图向导 / 251
11.1.3　视图代码 / 252
11.1.4   视图扩展 / 252
11.2　Perspective透视图 / 253
11.2.1　透视图向导 / 253
11.2.2　透视图代码 / 254
11.2.3　透视图扩展 / 254
11.2.4　透视图布局 / 255
11.2.5　打开透视图 / 256
11.3　EditorPart编辑器 / 256
11.3.1　创建数据表单 / 257
11.3.2　创建编辑器的输入 / 257
11.3.3　创建编辑器 / 260
11.3.4　创建视图树形组件 / 262
11.3.5　编辑器扩展 / 262
11.4　编程实现Action / 263
11.4.1　IAction / 263
11.4.2　ToolBar工具栏 / 264
11.4.3　CoolBar工具栏 / 264
11.4.4　ContentMenuBar菜单栏 / 265
11.4.5　工作台Action / 265
11.4.6　视图Action菜单栏 / 267
11.4.7　视图Action工具栏 / 267
11.4.8　编辑器Action工具栏 / 268
11.5　扩展实现Action / 269
11.5.1　工作台Action扩展 / 269
11.5.2　视图Action扩展 / 270
11.5.3　编辑器Action扩展 / 271
11.6　Action的键盘绑定 / 272
11.6.1　Commands扩展 / 273
11.6.2　Bindings扩展 / 274
11.7　Eclipse RCP设计进阶 / 276
11.7.1　视图/编辑器之间通信 / 276
11.7.2　创建状态栏项 / 278
11.7.3　创建属性配置页面 / 279
11.7.4　创建登录对话框 / 286
11.8　小结 / 289
第12章　Eclipse RCP扩展点开发 / 290
12.1　扩展点简介 / 290
12.2　创建扩展点 / 290
12.3　扩展点编辑器 / 291
12.3.1　扩展点概述 / 291
12.3.2　扩展点定义 / 292
12.3.3　扩展点源码 / 295
12.4　扩展点处理 / 295
12.4.1　扩展点对象 / 295
12.4.2　扩展点注册 / 296
12.4.3　扩展点获取 / 297
12.5　添加扩展 / 301
12.6　使用扩展 / 302
12.7   小结 / 303
第三部分　实　战　篇
第13章　Eclipse RCP与Spring OSGi / 306
13.1　OSGi技术介绍 / 306
13.1.1　软件开发面临的问题 / 306
13.1.2　动态模块化解决方案 / 306
13.1.3   OSGi框架  / 307
13.1.4　选择合适的OSGi实现 / 308
13.2　Spring OSGi项目所需要的开发包 / 308
13.2.1　下载Spring DM的开发包 / 308
13.2.2　解压缩Spring DM的开发包 / 309
13.2.3　创建Spring DM目标平台 / 309
13.3　Spring OSGi项目的Maven管理 / 311
13.3.1　创建Maven POM项目 / 311
13.3.2　修改Maven项目类型 / 312
13.4　Spring OSGi项目的模块化设计 / 313
13.4.1　创建Spring DM业务项目 / 313
13.4.2　设计Spring DM业务项目 / 313
13.5　 Spring OSGi项目转为插件项目 / 318
13.6　Spring OSGi插件项目发布接口 / 319
13.6.1　创建接口发布配置 / 319
13.6.2　添加包的路径导出 / 319
13.7　Eclipse RCP获取Spring OSGi服务 / 320
13.7.1　创建Eclipse RCP UI 插件 / 320
13.7.2   获取Spring OSGi服务接口 / 320
13.7.3   调用Spring OSGi服务接口 / 321
13.8　Eclipse RCP与Spring OSGi的启动 / 322
13.8.1　Eclipse 应用程序启动选项 / 322
13.8.2　启动Eclipse RCP产品配置 / 326
13.8.3　启动基于Spring OSGi的RCP程序 / 326
13.9　在Eclipse RCP中获取ApplicationContext和Bean / 328
13.10　Spring OSGi的Maven插件项目打包 / 331
13.10.1　PDE插件导出向导 / 331
13.10.2　Maven插件项目的打包配置 / 332
13.10.3　执行Maven插件打包 / 333
13.11　小结 / 334
第14章　Eclipse RCP与数据访问 / 335
14.1　SpringOSGi与Hibernate / 335
14.1.1　Hibernate简介 / 335
14.1.2　数据访问插件目标 / 335
14.1.3　数据访问插件设计 / 336
14.2　插件如何引入第三方开发包 / 338
14.2.1　如何获取第三方开发包 / 338
14.2.2　如何引用第三方开发包 / 341
14.3　将普通JAR转成插件格式 / 344
14.3.1　导入向导 / 344
14.3.2　BND工具 / 344
14.4　创建数据库插件 / 345
14.4.1　Maven POM配置文件 / 345
14.4.2　properties配置文件 / 346
14.4.3　Spring XML配置文件 / 346
14.4.4　MAINFEST.MF配置文件 / 349
14.5 　创建连接池插件 / 349
14.5.1 　Maven POM配置文件 / 349
14.5.2　properties配置文件 / 349
14.5.3   Spring XML配置文件 / 350
14.5.4　Java类设计 / 352
14.5.5　MAINFEST.MF配置文件 / 355
14.6 　创建连接池Feature插件 / 355
14.6.1　修改DBCP的MAINFEST.MF文件 / 356
14.6.2　创建DBCP的Fragment插件 / 356
14.7　创建Hibernate插件 / 356
14.7.1 　Maven POM配置文件 / 356
14.7.2　properties配置文件 / 358
14.7.3　Spring XML配置文件 / 358
14.7.4　扩展点设计 / 362
14.7.5　Java类设计 / 364
14.7.6　MAINFEST.MF配置文件 / 371
14.8　创建业务插件 / 371
14.8.1　Spring XML配置文件 / 372
14.8.2　Java类设计 / 375
14.8.3　数据库SQL设计 / 376
14.8.4　MAINFEST.MF配置文件 / 376
14.8.5　添加BundleAnnotationSessionFactoryBean扩展 / 377
14.9 　启动OSGi Framework程序 / 378
14.10 　其他整合数据库的方式 / 379
14.11　基于数据访问插件的RCP程序启动 / 380
14.12　小结 / 382
第15章　Eclipse与Java的模块化设计 / 383
15.1 　基于编程语言的模块化 / 383
15.1.1　Java语句的模块化设计 / 383
15.1.2　Java方法的模块化设计 / 383
15.1.3　Java类的模块化设计 / 384
15.1.4　Java接口的模块化设计 / 385
15.2 　基于编程方法的模块化 / 385
15.2.1　IoC编程的模块化设计 / 385
15.2.2　AOP编程的模块化设计 / 386
15.3 　基于程序物理文件的模块化 / 388
15.3.1　Package路径的模块化设计 / 388
15.3.2　XML文件的模块化设计 / 389
15.3.3　Properties文件的模块化设计 / 389
15.3.4　JAR组件的模块化设计 / 390
15.4 　基于技术架构的模块化 / 391
15.4.1　OSGi的模块化设计 / 391
15.4.2　Eclipse插件的模块化设计 / 392
15.4.3　JMS的模块化设计 / 392
15.5　模块化的技术移植 / 394
15.6　小结 / 394
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Eclipse RCP与Spring OSGi
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>四季成长路-每日一个希腊词灵修（全套4册）
《四季成长路•春》
第一部
1不住更新3
2变5
3超越环境的福乐7
4化时为机9
5每一天11
6灵里贫穷12
7温柔的人14
8真正的怜恤16
9清心的福乐18
10和平使者20
11恩慈相待22
12谦让的心24
13当神“有”到26
14神，你真厉害!28
15一队兵32
16神迹34
17你怕错了!36
18为父为师38
19赦罪的主40
20借神图利43
21像天父完全45
22神的愤怒47
23灵性尘封49
24耶稣是谁?52
25死亡与荣耀54
26如此无礼?!56
27反倒虚己58
28保惠师60
29圣灵的工作62
30凭据64
31一切从悔罪开始66
第二部
32教会71
33教会——治疗的群体75
34教会——祷告的群体77
35牧者的榜样79
36天国的真义81
37家在教会85
38不可停止聚会87
39割礼89
40开开心心地献上91
41耶稣的差遣93
42听道的艺术95
43优先次序97
44托付99
45沟通的艺术101
46彼此分担103
47提防弄权105
48人在江湖107
49身不由己111
50你对什么曾说：不!114
51心疲117
52暂时拥有VS天长地久120
53钱!钱!钱!122
54忍耐125
55忍耐宽容128
56随流失去130
57终132
58客旅134
59罪136
60泪138
第三部
61激发爱心143
62劝勉的威力145
63男人，你在哪里?147
64不要勉强!149
65自己可靠吗?151
66真真假假153
67出去痛哭155
68出埃及157
69有情有理159
70跳下去!161
71永垂不朽的美163
72绊脚石166
73抚摸的事奉168
74多可喜亦多可悲170
75化咒诅为祝福172
76痛174
77苦难176
78苦难神学178
79人间无情180
80最佳回报之投资183
81随风飘来飘去的信徒185
82输不起187
83愈饮愈渴的私欲189
84耶稣的嘶叫191
85英雄彼得193
86预表死亡的生日礼物196
87死啊!你得胜的权势在哪里？198
88髑髅地200
89胜过焦虑202
90和平之君204
希腊文索引206
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>四季成长路-每日一个希腊词灵修（全套4册）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>女孩进化史
第一部分
1  梅雷迪思
2  乔
3  梅格
4  乔
5  梅格
6  乔
7  梅格
8  贝丝
9  梅格
10  乔
第二部分
11  梅格
12  乔
13  贝丝
14  乔
15  梅格
16  贝丝
17  梅格
18  乔
19  梅格
20  乔
21  梅格
第三部分
22  乔
23  贝丝
24  梅格
25  贝丝
26  乔
27  贝丝
28  梅格
29  贝丝
30  乔
致谢
译者后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>女孩进化史
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>賽狗場的女人
1.    石泉城
2.    大瀑布
3.    甜心
4.    少年
5.    賽狗場的女人
6.    國度
7.    寒冬
8.    樂觀的人
9.    煙火
10.    共產黨
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>賽狗場的女人
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>外遇的男女心理
前言 當外遇的警鐘響起
第一階段：辯識你的情緒反應
第一章　受傷伴侶的反應：埋沒在重重的失落中
第二章 不忠伴侶的反應：迷失在選擇的迷陣裡
第二階段：評估你的去留選擇
第三章　探索你的愛情觀
第四章　面對內心的疑懼
第三階段：走出外遇的陰影
第五章 自外遇當中學習
第六章 重建信任
第七章 互訴衷曲
第八章 重拾閨房之樂
第九章 認識與學習寬恕
後記　在說與不說之間
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>外遇的男女心理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot 2精髓
第1章　Java EE简介
1.1　Java EE
1.1.1　Java EE架构
1.1.2　Java EE的缺点
1.2　Spring
1.2.1　Spring IoC容器和AOP
1.2.2　Spring的缺点
1.3　Spring Boot
1.4　Hello，Spring Boot
1.4.1　创建一个Maven工程
1.4.2　增加Web支持
1.4.3　Hello Spring Boot示例
1.4.4　使用热部署
1.4.5　添加REST支持
第2章　Spring Boot基础
2.1　检查Java环境与安装Java
2.2　安装和配置Maven
2.2.1　Maven介绍
2.2.2　安装Maven
2.2.3　设置Maven
2.2.4　使用IDE设置Maven
2.2.5　Maven的常用命令
2.3　Spring核心技术
2.3.1　Spring的历史
2.3.2　Spring容器介绍
2.3.3　Spring AOP介绍
第3章　MVC框架
3.1　集成MVC框架
3.1.1　引入依赖
3.1.2　Web应用目录结构
3.1.3　Java包名结构
3.2　使用Controller
3.3　URL映射到方法
3.3.1　@RequestMapping
3.3.2　URL路径匹配
3.3.3　HTTP method匹配
3.3.4　consumes和produces
3.3.5　params和header匹配
3.4　方法参数
3.4.1　PathVariable
3.4.2　Model&ModelAndView
3.4.3　JavaBean接受HTTP参数
3.4.4　@RequsetBody接受JSON
3.4.5　MultipartFile
3.4.6　@ModelAttribute
3.4.7　@InitBinder
3.5　验证框架
3.5.1　JSR-303
3.5.2　MVC中使用@Validated
3.5.3　自定义校验
3.6　WebMvcConfigurer
3.6.1　拦截器
3.6.2　跨域访问
3.6.3　格式化
3.6.4　注册Controller
3.7　视图技术
3.7.1　使用Freemarker
3.7.2　使用Beetl
3.7.3　使用Jackson
3.7.4　Redirect和Forward
3.8　通用错误处理
3.9　@Service和@Transactional
3.9.1　声明一个Service类
3.9.2　事务管理
3.10　curl命令
第4章　视图技术
4.1　Beetl模板引擎
4.1.1　安装Beetl
4.1.2　设置定界符号和占位符
4.1.3　配置Beetl
4.1.4　groupTemplate
4.2　使用变量
4.2.1　全局变量
4.2.2　局部变量
4.2.3　共享变量
4.2.4　模板变量
4.3　表达式
4.3.1　计算表达式
4.3.2　逻辑表达式
4.4　控制语句
4.4.1　循环语句
4.4.2　条件语句
4.4.3　try catch
4.5　函数调用
4.6　格式化函数
4.7　直接调用Java
4.8　标签函数
4.9　HTML标签
4.10　安全输出
4.11　高级功能
4.11.1　配置Beetl
4.11.2　自定义函数
4.11.3　自定义格式化函数
4.11.4　自定义标签函数
4.11.5　自定义HTML标签
4.11.6　布局
4.11.7　AJAX局部渲染
4.12　脚本引擎
4.13　JSON技术
4.13.1　在Spring Boot中使用Jackson
4.13.2　自定义ObjectMapper
4.13.3　Jackson的三种使用方式
4.13.4　Jackson树遍历
4.13.5　对象绑定
4.13.6　流式操作
4.13.7　Jackson注解
4.13.8　集合的反序列化
4.14　MVC分离开发
4.14.1　集成WebSimulate
4.14.2　模拟JSON响应
4.14.3　模拟模板渲染
第5章　数据库访问
5.1　配置数据源
5.2　Spring JDBC Template
5.2.1　查询
5.2.2　修改
5.2.3　JdbcTemplate增强
5.3　BeetlSQL介绍
5.3.1　BeetlSQL功能概览
5.3.2　添加Maven依赖
5.3.3　配置BeetlSQL
5.3.4　SQLManager
5.3.5　使用SQL文件
5.3.6　Mapper
5.3.7　使用实体
5.4　SQLManager内置CRUD
5.4.1　内置的插入API
5.4.2　内置的更新（删除）API
5.4.3　内置的查询API
5.4.4　代码生成方法
5.5　使用sqlId
5.5.1　md文件命名
5.5.2　md文件构成
5.5.3　调用sqlId
5.5.4　翻页查询
5.5.5　TailBean
5.5.6　ORM查询
5.5.7　其他API
5.5.8　Mapper详解
5.6　BeetlSQL的其他功能
5.6.1　常用函数和标签
5.6.2　主键设置
5.6.3　BeetlSQL注解
5.6.4　NameConversion
5.6.5　锁
第6章　Spring Data JPA
6.1　集成Spring Data JPA
6.1.1　集成数据源
6.1.2　配置JPA支持
6.1.3　创建Entity
6.1.4　简化Entity
6.2　Repository
6.2.1　CrudRepository
6.2.2　PagingAndSortingRepository
6.2.3　JpaRepository
6.2.4　持久化Entity
6.2.5　Sort
6.2.6　Pageable和Page
6.2.7　基于方法名字查询
6.2.8　@Query查询
6.2.9　使用JPA Query
6.2.10　Example查询
第7章　Spring Boot配置
7.1　配置Spring Boot
7.1.1　服务器配置
7.1.2　使用其他Web服务器
7.1.3　配置启动信息
7.1.4　配置浏览器显示ico
7.2　日志配置
7.3　读取应用配置
7.3.1　Environment
7.3.2　@Value
7.3.3　@ConfigurationProperties
7.4　Spring Boot自动装配
7.4.1　@Configuration和@Bean
7.4.2　Bean条件装配
7.4.3　Class条件装配
7.4.4　Environment装配
7.4.5　其他条件装配
7.4.6　联合多个条件
7.4.7　Condition接口
7.4.8　制作Starter
第8章　部署Spring Boot应用
8.1　以jar文件运行
8.2　以war方式部署
8.3　多环境部署
8.4　@Profile注解
第9章　Testing单元测试
9.1　JUnit介绍
9.1.1　JUnit的相关概念
9.1.2　JUnit测试
9.1.3　Assert
9.1.4　Suite
9.2　Spring Boot单元测试
9.2.1　测试范围依赖
9.2.2　Spring Boot测试脚手架
9.2.3　测试Service
9.2.4　测试MVC
9.2.5　完成MVC请求模拟
9.2.6　比较MVC的返回结果
9.2.7　JSON比较
9.3　Mockito
9.3.1　模拟对象
9.3.2　模拟方法参数
9.3.3　模拟方法返回值
9.4　面向数据库应用的单元测试
9.4.1　@Sql
9.4.2　XLSUnit
9.4.3　XLSUnit的基本用法
第10章　REST
10.1　REST简介
10.1.1　REST风格的架构
10.1.2　使用“api”作为上下文
10.1.3　增加一个版本标识
10.1.4　标识资源
10.1.5　确定HTTP Method
10.1.6　确定HTTP Status
10.1.7　REST VS. WebService
10.2　Spring Boot集成REST
10.2.1　集成REST
10.2.2　@RestController
10.2.3　REST Client
10.3　Swagger UI
10.3.1　集成Swagger
10.3.2　Swagger规范
10.3.3　接口描述
10.3.4　查询参数描述
10.3.5　URI中的参数
10.3.6　HTTP头参数
10.3.7　表单参数
10.3.8　文件上传参数
10.3.9　整个请求体作为参数
10.4　模拟REST服务
第11章　MongoDB
11.1　安装MongoDB
11.2　使用shell
11.2.1　指定数据库
11.2.2　插入文档
11.2.3　查询文档
11.2.4　更新操作
11.2.5　删除操作
11.3　Spring Boot集成MongoDB
11.4　增删改查
11.4.1　增加API
11.4.2　根据主键查询API
11.4.3　查询API
11.4.4　修改API
11.4.5　删除API
11.4.6　使用MongoDatabase
11.4.7　打印日志
第12章　Redis
12.1　安装Redis
12.2　使用redis-cli
12.2.1　安全设置
12.2.2　基本操作
12.2.3　keys
12.2.4　Redis List
12.2.5　Redis Hash
12.2.6　Set
12.2.7　Pub/Sub
12.3　Spring Boot集成Redis
12.4　使用StringRedisTemplate
12.4.1　opsFor
12.4.2　绑定Key的操作
12.4.3　RedisConnection
12.4.4　Pub/Sub
12.5　序列化策略
12.5.1　默认序列化策略
12.5.2　自定义序列化策略
第13章　Elasticsearch
13.1　Elasticsearch介绍
13.1.1　安装Elasticsearch
13.1.2　Elasticsearch的基本概念
13.2　使用REST访问Elasticsearch
13.2.1　添加文档
13.2.2　根据主键查询
13.2.3　根据主键更新
13.2.4　根据主键删除
13.2.5　搜索文档
13.2.6　联合多个索引搜索
13.3　使用RestTemplate访问ES
13.3.1　创建Book
13.3.2　使用RestTemplate获取搜索结果
13.4　Spring Data Elastic
13.4.1　安装Spring Data
13.4.2　编写Entity
13.4.3　编写Dao
13.4.4　编写Controller
第14章　Cache
14.1　关于Cache
14.1.1　Cache的组件和概念
14.1.2　Cache的单体应用
14.1.3　使用专有的Cache服务器
14.1.4　使用一二级缓存服务器
14.2　Spring Boot Cache
14.3　注释驱动缓存
14.3.1　@Cacheable
14.3.2　Key生成器
14.3.3　@CachePut
14.3.4　@CacheEvict
14.3.5　@Caching
14.3.6　@CacheConfig
14.4　使用Redis Cache
14.4.1　集成Redis缓存
14.4.2　禁止缓存
14.4.3　定制缓存
14.5　Redis缓存原理
14.6　实现Redis两级缓存
14.6.1　实现TwoLevelCacheManager
14.6.2　创建RedisAndLocalCache
14.6.3　缓存同步说明
14.6.4　将代码组合在一起
第15章　Spring Session
15.1　水平扩展实现
15.2　Nginx的安装和配置
15.2.1　安装Nginx
15.2.2　配置Nginx
15.3　Spring Session
15.3.1　Spring Session介绍
15.3.2　使用Redis
15.3.3　Nginx+Redis
第16章　Spring Boot和ZooKeeper
16.1　ZooKeeper
16.1.1　ZooKeeper的数据结构
16.1.2　安装ZooKeeper
16.1.3　ZooKeeper的基本命令
16.1.4　领导选取演示
16.1.5　分布式锁演示
16.1.6　服务注册演示
16.2　Spring Boot集成ZooKeeper
16.2.1　集成Curator
16.2.2　Curator API
16.3　实现分布式锁
16.4　服务注册
16.4.1　通过ServiceDiscovery注册服务
16.4.2　获取服务
16.5　领导选取
第17章　监控Spring Boot应用
17.1　安装Acutator
17.2　HTTP跟踪
17.3　日志查看
17.4　线程栈信息
17.5　内存信息
17.6　查看URL映射
17.7　查看Spring容器管理的Bean
17.8　其他监控
17.9　编写自己的监控信息
17.9.1　编写HealthIndicator
17.9.2　自定义监控
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot 2精髓
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot微服务实战
目录
第1 章 介绍 1
1.1 设置场景 1
1.2 读者对象 2
1.3 本书与其他图书和指南有何区别 2
1.3.1 工具背后的论证 2
1.3.2 学习：渐进的过程 3
1.3.3 这是一本指南还是一本图书 3
1.4 本书内容 3
1.4.1 从基础知识到高级话题 3
1.4.2 搭建Spring Boot骨架的专业方式 4
1.4.3 测试驱动开发 4
1.4.4 连接微服务 4
1.4.5 事件驱动的系统 5
1.4.6 端到端测试 5
1.5 本章小结 5
第2 章 一个基本的Spring Boot应用 7
2.1 业务需求 7
2.2 骨架应用 8
2.2.1 轻薄应用与真实应用 8
2.2.2 创建应用骨架 8
2.3 热身：一些TDD的实战 10
2.4 本章小结 16
第3 章 一个真实的三层Spring Boot 应用 17
3.1 简介 17
3.2 完成基本功能 18
3.3 领域设计 24
3.4 业务逻辑层 28
3.5 展示层(REST API) 30
3.5.1 Multiplication Controller 31
3.5.2 Results控制器 35
3.6 前端(Web客户端) 38
3.7 试玩(第1部分) 42
3.8 数据持久化的新需求 43
3.9 重构代码 45
3.10 数据层 50
3.10.1 数据模型 51
3.10.2 资源库 56
3.11 完成第二个用户故事：串联所有层 63
3.12 畅玩应用(第2部分) 69
3.13 本章小结 71
第4 章 初识微服务 73
4.1 小单体之路 73
4.1.1 单体分析 75
4.1.2 继续前进 76
4.2 游戏化基础 77
4.2.1 分数、徽章和排行榜 77
4.2.2 应用游戏化技术 78
4.3 转向微服务架构 78
4.3.1 职责分离和松耦合 78
4.3.2 独立变更 79
4.3.3 伸缩性 79
4.4 连接不同的微服务 80
4.5 事件驱动架构 81
4.5.1 相关技术 81
4.5.2 事件驱动架构的优缺点 82
4.5.3 深入阅读 84
4.5.4 应用事件驱动架构 84
4.6 使用RabbitMQ和Spring AMQP实现事件驱动 85
4.6.1 在系统中使用RabbitMQ 86
4.6.2 Spring AMQP 86
4.7 从乘法微服务发送事件 87
4.7.1 RabbitMQ配置 87
4.7.2 对事件建模 89
4.7.3 发送事件：分发器模式 91
4.7.4 深入新游戏化微服务 95
4.8 使用RabbitMQ接收事件 111
4.8.1 订阅者 111
4.8.2 RabbitMQ配置 111
4.8.3 事件处理程序 114
4.9 在微服务之间请求数据 115
4.9.1 结合反应式模式和REST 115
4.9.2 保持领域隔离 117
4.9.3 实现REST客户端 119
4.9.4 更新游戏化业务逻辑 123
4.10 使用微服务 126
4.11 本章小结 128
第5 章 使用工具的微服务架构 131
5.1 介绍 131
5.2 抽取UI部分，并连接游戏化服务 132
5.2.1 移动静态内容 133
5.2.2 连接UI和游戏化服务 134
5.2.3 改变现有服务 136
5.2.4 全新的、更好的UI，而且(几乎)不需要额外的代价 139
5.3 当前架构 146
5.4 服务发现和负载均衡 147
5.4.1 服务发现 147
5.4.2 负载均衡 149
5.4.3 多语言系统、Eureka以及 Ribbon 151
5.5 通过API网关路由 153
5.5.1 API网关模式 153
5.5.2 让Zuul、Eureka和Ribbon一起工作 156
5.6 动手准则 158
5.6.1 使用Zuul实现API网关 158
5.6.2 使用服务发现 172
5.6.3 微服务准备好扩展了吗 174
5.6.4 通过Ribbon实现负载均衡 176
5.7 断路器和REST客户端 183
5.7.1 Hystrix断路器 183
5.7.2 Hystrix和Zuul 183
5.7.3 来自REST客户端的Hystrix 186
5.7.4 使用Feign的REST消费者 189
5.8 微服务模式和PaaS 189
5.9 本章小结 190
第6 章 测试分布式系统 193
6.1 介绍 193
6.2 设置场景 194
6.3 Cucumber的工作方式 195
6.4 动手准则 197
6.4.1 创建一个空项目并选择工具 197
6.4.2 让系统可测试 200
6.4.3 编写第一个Cucumber测试 207
6.4.4 把功能测试连接到Java代码 210
6.4.5 支持类 218
6.4.6 在feature之间重用步骤 223
6.4.7 运行测试并检查报告 225
6.5 本章小结 226
附录A 升级到Spring Boot 2.0 229
A.1 介绍 229
A.2 升级依赖项 229
A.3 修复已破坏的变化 232
A.3.1 CrudRepository接口不包含findOne()方法 232
A.3.2 actuator端点被移动 233
A.4 应用可选的更新 234
A.5 使用Spring Boot 2.0 234
后记 235
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot微服务实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java Web 整合开发入门——Struts 2+Hibernate 4+Spring 3
第1章  轻量级Java Web开发概述	1
1.1  Java概述	1
1.2  Java Web开发概述	2
1.2.1  Java Web项目基本结构	2
1.2.2  轻量级Java Web开发概述	7
1.2.3  经典Java Web开发概述	7
1.3  常用的Java Web服务器	7
1.4  轻量级Java Web开发环境	9
1.4.1  环境变量的配置	9
1.4.2  常用的集成开发环境	10
1.5  轻量级Java Web开发相关技术	11
1.5.1  JSP简介	12
1.5.2  数据库技术简介	13
1.5.3  配置文件的格式	13
1.5.4  其他相关软件	15
1.6  Java Web项目的部署	15
1.6.1  拷贝部署法	15
1.6.2  WAR包部署法	16
1.6.3  IDE部署法	17
1.7  学习轻量级Java Web开发的方法	18
1.8  本章小结	18
1.9  习题	18
1.10  实验	19
第2章  设计模式概述	21
2.1  单例模式	22
2.2  工厂模式	23
2.2.1  简单工厂模式	23
2.2.2  工厂方法模式	27
2.2.3  抽象工厂模式	29
2.3  代理模式	31
2.4  命令模式	33
2.5  策略模式	36
2.6  MVC	38
2.7  本章小结	40
2.8  习题	41
2.9  实验	42
第3章  Struts 2框架	43
3.1  Struts 2框架概述	43
3.1.1  Struts 2框架的由来	43
3.1.2  Struts 2框架的下载和安装	44
3.1.3  Struts 2框架的体系结构图	45
3.2  Struts 2框架的基本用法	46
3.2.1  使用Struts 2框架的开发步骤	47
3.2.2  Struts 2框架的Action接口	48
3.2.3  Struts 2框架的配置文件	49
3.2.4  完整的Struts 2框架应用实例	50
3.3  Struts 2框架的标签库	57
3.3.1  Struts 2标签库和JSP标签库的
区别	57
3.3.2  常用的Struts 2标签介绍	58
3.3.3  Struts 2框架的国际化支持	59
3.3.4  用户注册的实例	64
3.4  Struts 2框架的高级应用	66
3.4.1  Struts 2的类型转换	66
3.4.2  Struts 2的输入校验	72
3.4.3  Struts 2的文件上传与下载	76
3.4.4  Struts 2的拦截器	83
3.5  本章小结	90
3.6  习题	91
3.7  实验	92
第4章  Hibernate框架	93
4.1  Hibernate框架概述	93
4.1.1  ORM的概念	93
4.1.2  常用的ORM框架	94
4.1.3  JPA的概念	94
4.1.4  Hibernate的下载和安装	95
4.1.5  Hibernate框架的结构图	96
4.2  Hibernate框架的基本用法	98
4.2.1  使用Hibernate框架的流程	98
4.2.2  Hibernate框架的核心类	110
4.2.3  持久化类的概念	112
4.2.4  Hibernate框架的配置文件	114
4.2.5  Hibernate框架的映射文件	116
4.2.6  使用Hibernate进行增删改查	118
4.3  Hibernate框架的高级应用	124
4.3.1  Hibernate框架的关联映射	124
4.3.2  Hibernate框架的查询	138
4.3.3  Hibernate的批量处理	146
4.4  本章小结	149
4.5  习题	149
4.6  实验	150
第5章  Spring框架	151
5.1  Spring框架概述	151
5.1.1  Spring框架简介	152
5.1.2  Spring框架的下载和安装	153
5.1.3  Spring框架的结构图	154
5.1.4  使用Spring框架的好处	156
5.2  Spring框架的基本用法	157
5.2.1  使用Spring框架的流程	157
5.2.2  Spring框架的使用范围	158
5.2.3  Spring框架的依赖注入	159
5.2.4  Spring框架的配置文件	164
5.3  Spring框架的高级应用	165
5.3.1  Spring的后处理器	165
5.3.2  Spring的资源访问	168
5.3.3  Spring的AOP	171
5.3.4  使用AOP进行权限验证及
日志记录	172
5.4  Java的反射和代理	176
5.4.1  Java的反射	176
5.4.2  Java的代理	181
5.5  本章小结	186
5.6  习题	186
5.7  实验	187
第6章  轻量级整合开发实例	189
6.1  整合开发概述	189
6.1.1  为什么要整合开发	189
6.1.2  常用的轻量级整合开发	189
6.2  Struts和Hibernate的整合开发	190
6.2.1  整合开发步骤	190
6.2.2  整合开发实例	190
6.3  Struts、Hibernate及Spring的整合开发	202
6.3.1  整合开发步骤	203
6.3.2  整合开发实例	203
6.3.3  整合开发注意事项	205
6.4  SSH整合开发实例：权限管理
系统	206
6.4.1  项目概述	206
6.4.2  项目详细创建过程	207
6.4.3  项目小结	221
6.5  轻量级整合和经典整合的区别	221
6.6  本章小结	221
6.7  习题	221
6.8  实验	222
第7章  Java Web开发常见问题	223
7.1  Struts 2框架常见问题	223
7.1.1  核心过滤器的配置	223
7.1.2  Web页面中文乱码问题	224
7.2  Hibernate框架常见问题	224
7.2.1  MySql服务不能启动	224
7.2.2  MySql数据库乱码问题	225

7.2.3  1-N双向关联映射统一外键问题	226
7.2.4  Hibernate 3和Hibernate 4二级缓存的配置区别	226
7.2.5  Hibernate生成表的默认名称对Linux和Windows的区别	227
7.2.6  Linux和Windows对路径表示方式的区别	228
7.3  Spring框架常见问题	228
7.4  一切问题的根源	228

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java Web 整合开发入门——Struts 2+Hibernate 4+Spring 3
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构基础:Spring Boot+Spring Cloud+Docker
第1章认识微服务架构1
1.1 为什么需要微服务架构 2
1.1.1 传统单体应用架构的问题 2
1.1.2 如何解决传统应用架构的问题 3
1.2 微服务架构是什么 4
1.2.1 微服务架构的概念 4
1.2.2 微服务架构的优点 5
1.2.3 微服务架构的不足 6
1.2.4 微服务架构与SOA的区别 6
1.3 如何构建微服务架构 6
1.3.1 微服务的拆分 7
1.3.2 微服务架构的组件 7
1.3.3 微服务架构的搭建 7
1.3.4 微服务架构的技术选型 8
1.4 本章小结 10
第2章 初识Spring Boot 11
2.1 Spring Boot介绍 12
2.1.1 Spring Boot的由来和特点 12
2.1.2 Spring Boot的使用要求 12
2.2 Spring Boot入门 13
2.2.1 Spring Boot项目的快速搭建 13
2.2.2 第一个Spring Boot程序 18
2.3 Spring Boot的工作机制 20
2.3.1 @Spring BootApplication 20
2.3.2 Spring Application 21
2.4 本章小结 22
第3章 Spring Boot应用开发 23
3.1 Spring Boot与MyBatis的集成 24
3.2 Spring Boot与Redis的集成 29
3.2.1 添加Redis缓存 29
3.2.2 清除Redis缓存 31
3.3 Spring Boot与ActiveMQ的集成 31
3.3.1 使用内嵌的ActiveMQ 31
3.3.2 使用外部的ActiveMQ 33
3.4 Spring Boot应用的打包和部署 35
3.4.1 JAR包 35
3.4.2 WAR包 36
3.5 本章小结 37
第4章 Spring Cloud（上） 38
4.1 Spring Cloud简介 39
4.1.1 什么是Spring Cloud 39
4.1.2 Spring Cloud的特点 39
4.1.3 Spring Cloud的版本 39
4.2 服务发现 40
4.2.1 Eureka介绍 40
4.2.2 如何使用Eureka注册服务 41
4.2.3 如何实现服务间的调用 47
4.3 客户端负载均衡 50
4.3.1 Ribbon介绍 50
4.3.2 Ribbon的使用 51
4.4 本章小结 53
第5章 Spring Cloud（下） 54
5.1 服务容错保护 55
5.1.1 Spring Cloud Hystrix介绍 55
5.1.2 Spring Cloud Hystrix的使用 56
5.1.3 HystrixDashboard的使用 59
5.2 API网关服务 63
5.2.1 为什么需要API网关 63
5.2.2 如何使用Zuul构建API网关服务 64
5.3 分布式配置管理 68
5.3.1 Spring Cloud Config简介 68
5.3.2 使用本地存储的方式实现配置管理 69
5.3.3 使用Git存储的方式实现配置管理 73
5.4 本章小结 76
第6章 初识Docker 77
6.1 Docker概述 78
6.1.1 什么是Docker 78
6.1.2 Docker的特点 78
6.1.3 Docker与虚拟机的区别 79
6.2 Docker的安装要求 79
6.3 Docker的安装方式 80
6.3.1 在线安装 80
6.3.2 离线安装 82
6.3.3 脚本文件安装 83
6.3.4 安装时的问题及解决方法 84
6.4 Docker的运行机制 85
6.4.1 Docker的引擎 85
6.4.2 Docker的架构 85
6.5 Docker的底层技术 87
6.6 本章小结 87
第7章 Docker的使用 88
7.1 Docker入门程序 89
7.2 Dockerfile介绍 92
7.2.1 Dockerfile基本结构 92
7.2.2 Dockerfile常用指令 93
7.2.3 dockerignore文件 95
7.3 Docker客户端常用指令 96
7.3.1 Docker常用操作指令 96
7.3.2 Docker管理指令 101
7.4 Docker镜像管理 102
7.4.1 Docker镜像管理工具 102
7.4.2 Docker Hub远程镜像管理 103
7.4.3 Docker Registry本地私有仓库搭建 106
7.4.4 Docker Registry本地私有仓库配置 107
7.5 本章小结 112
第8章 Docker中的网络与数据管理 113
8.1 Docker网络管理 114
8.1.1 Docker默认网络管理 114
8.1.2 自定义网络介绍 115
8.1.3 自定义bridge网络 116
8.1.4 容器之间的网络通信 118
8.2 Docker Swarm集群 122
8.2.1 Docker Swarm概述 122
8.2.2 Docker Swarm使用 123
8.3 Docker数据管理 127
8.3.1 Docker数据存储机制 127
8.3.2 Docker数据存储方式 129
8.4 Volumes数据卷管理 129
8.4.1 Volumes数据卷的优势 129
8.4.2 Volumes数据卷使用 130
8.5 本章小结 134
第9章 微服务项目的整合与测试 135
9.1 微服务项目整合 136
9.1.1 微服务项目结构预览 136
9.1.2 微服务项目功能介绍 136
9.1.3 微服务项目的启动和测试 140
9.2 接口可视化工具—Swagger—UI 143
9.2.1 Swagger—UI使用方法 143
9.2.2 Swagger—UI使用测试 145
9.3 本章小结 147
第10章 微服务的部署 149
10.1 Docker Compose编排工具 150
10.1.1 Docker Compose介绍 150
10.1.2 Docker Compose的安装与卸载 150
10.1.3 Composefile文件的使用说明 151
10.2 微服务与Docker的整合 154
10.3 环境搭建以及镜像准备 159
10.3.1 环境搭建 159
10.3.2 镜像准备 161
10.4 微服务的手动部署 162
10.4.1 非集群环境下的服务部署 162
10.4.2 集群环境下服务部署 163
10.4.3 微服务测试 167
10.5 使用Jenkins自动部署微服务 169
10.5.1 Jenkins介绍 169
10.5.2 Jenkins安装 170
10.5.3 Jenkins集成插件配置 173
10.5.4 服务自动化部署 175
10.6 本章小结 180
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构基础:Spring Boot+Spring Cloud+Docker
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Spring
目录
第一部分  微服务架构和Spring Cloud项目基础知识
第1章  微服务简介 3
1.1  微服务的优点 3
1.2  使用Spring Framework构建微服务 4
1.3  云原生应用程序开发方法 4
1.4  了解微服务架构 5
1.4.1  理解服务发现的必要性 7
1.4.2  服务之间的通信 9
1.4.3  故障和断路器 11
1.5  小结 11
第2章  使用微服务的Spring 13
2.1  关于Spring Boot 13
2.2  使用Spring Boot开发应用程序 15
2.2.1  自定义配置文件 17
2.2.2  创建RESTful Web服务 20
2.3  API文档 23
2.3.1  联合使用Swagger 2和Spring Boot 23
2.3.2  使用Swagger UI测试API 24
2.4  Spring Boot执行器功能 27
2.4.1  应用信息 27
2.4.2  健康信息 29
2.4.3  指标信息 30
2.5  开发者工具 32
2.6  将应用程序与数据库集成 33
2.7  运行应用程序 36
2.8  小结 40
第3章  Spring Cloud概述 41
3.1  从基础开始 41
3.1.1  Netflix OSS 42
3.1.2  使用Eureka进行服务发现 43
3.1.3  使用Zuul路由 43
3.1.4  使用Ribbon实现负载均衡 44
3.1.5  编写Java HTTP客户端 44
3.1.6  Hystrix的延迟和容错能力 44
3.1.7  使用Archaius进行配置管理 45
3.2  发现和分布式配置 45
3.2.1  可选替代方案—Consul 46
3.2.2  Apache Zookeeper 46
3.2.3  其他项目 47
3.3  使用Sleuth进行分布式跟踪 47
3.4  消息传递和集成 48
3.5  云平台支持 49
3.6  其他有用的库 50
3.6.1  安全性 51
3.6.2  自动化测试 51
3.6.3  集群功能 51
3.7  项目概述 51
3.8  版本列车 52
3.9  小结 54
第二部分  微服务架构常见元素和Spring Cloud实现
第4章  服务发现 57
4.1  在服务器端运行Eureka 57
4.2  在客户端启用Eureka 59
4.2.1  关机时取消注册 60
4.2.2  以编程方式使用发现客户端 62
4.3  高级配置设置 63
4.3.1  刷新注册表 63
4.3.2  更改实例标识符 65
4.3.3  选择使用IP地址 66
4.3.4  响应缓存 66
4.4  启用客户端和服务器之间的安全通信 67
4.5  Eureka API 69
4.6  副本和高可用性 70
4.6.1  样本解决方案的架构 70
4.6.2  构建示例应用程序 71
4.6.3  故障转移 75
4.7  区域 76
4.7.1  具有独立服务器的区域 77
4.7.2  构建示例应用程序 78
4.8  小结 80
第5章  使用Spring Cloud Config 进行分布式配置 83
5.1  HTTP API资源简介 84
5.2  构建服务器端应用程序 86
5.3  构建客户端应用程序 87
5.4  客户端引导方法 88
5.5  存储库后端类型 91
5.5.1  文件系统后端 91
5.5.2  Git后端 92
5.5.3  Vault后端 96
5.6  其他功能 98
5.6.1  启动失败和重试 98
5.6.2  保护客户端的安全 99
5.7  自动重新加载配置 99
5.7.1  解决方案架构 99
5.7.2  使用@RefreshScope重新加载配置 100
5.7.3  使用来自消息代理的事件 103
5.7.4  监视Config Server上的存储库更改 104
5.8  小结 108
第6章  微服务之间的通信 109
6.1  不同类型的通信 109
6.2  使用Spring Cloud进行同步通信 109
6.3  使用Ribbon执行负载均衡 110
6.3.1  使用Ribbon客户端启用微服务之间的通信 110
6.3.2  静态负载均衡配置 111
6.3.3  调用其他服务 112
6.4  将RestTemplate与服务发现结合使用 115
6.5  使用Feign客户端 118
6.5.1  对不同区域的支持 118
6.5.2  为应用程序启用Feign 119
6.5.3  继承支持 123
6.5.4  手动创建客户端 124
6.5.5  客户端的自定义 124
6.6  小结 126
第7章  高级负载均衡和断路器 127
7.1  负载均衡规则 127
7.1.1  WeightedResponseTime规则 128
7.1.2  引入Hoverfly进行测试 128
7.1.3  测试规则 129
7.2  自定义Ribbon客户端 131
7.3  带Hystrix的断路器模式 133
7.3.1  使用Hystrix构建应用程序 133
7.3.2  跳闸断路器 137
7.4  监控延迟和容错 140
7.4.1  公开Hystrix的指标流 141
7.4.2  Hystrix仪表板 142
7.5  故障和带有Feign的断路器模式 149
7.5.1  重试与Ribbon的连接 149
7.5.2  Hystrix对Feign的支持 150
7.6  小结 153
第8章  使用API网关进行路由和过滤 155
8.1  使用Spring Cloud Netflix Zuul 155
8.1.1  构建网关应用程序 156
8.1.2  与服务发现集成 157
8.1.3  自定义路由配置 158
8.1.4  管理端点 161
8.1.5  提供Hystrix回退bean 162
8.1.6  Zuul过滤器 164
8.2  使用Spring Cloud Gateway 166
8.2.1  为项目启用Spring Cloud Gateway 167
8.2.2  内置谓词和过滤器 168
8.2.3  微服务的网关 170
8.2.4  与服务发现集成 172
8.3  小结 173
第9章  分布式日志记录和跟踪 175
9.1  微服务的最佳日志记录实践 175
9.2  使用Spring Boot记录日志 177
9.3  使用ELK Stack集中日志 179
9.3.1  在机器上设置ELK堆栈 180
9.3.2  将应用程序与ELK Stack集成 181
9.4  Spring Cloud Sleuth 188
9.4.1  将Sleuth与应用程序集成 189
9.4.2  使用Kibana搜索事件 190
9.4.3  集成Sleuth和Zipkin 192
9.5  小结 198
第10章  其他配置和发现功能 199
10.1  使用Spring Cloud Consul 199
10.1.1  运行Consul代理 200
10.1.2  在客户端集成 201
10.1.3  服务发现 201
10.1.4  分布式配置 208
10.2  使用Spring Cloud Zookeeper 212
10.2.1  运行Zookeeper 213
10.2.2  服务发现 214
10.2.3  分布式配置 216
10.3  小结 217
第11章  消息驱动的微服务 219
11.1  了解Spring Cloud Stream 219
11.2  构建消息传递系统 220
11.2.1  启用Spring Cloud Stream 220
11.2.2  声明和绑定频道 222
11.2.3  自定义与RabbitMQ代理的连接 224
11.2.4  与其他Spring Cloud项目集成 228
11.3  发布/订阅模型 231
11.3.1  运行示例系统 232
11.3.2  扩展和分组 233
11.4  配置选项 238
11.4.1  Spring Cloud Stream属性 238
11.4.2  绑定属性 239
11.5  高级编程模型 240
11.5.1  制作消息 240
11.5.2  转换 240
11.5.3  有条件地使用消息 241
11.6  使用Apache Kafka 242
11.6.1  运行Kafka 242
11.6.2  自定义应用程序设置 243
11.6.3  Kafka Streams API支持 244
11.6.4  配置属性 245
11.7  多个绑定器 245
11.8  小结 247
第12章  保护API的安全 249
12.1  为Spring Boot启用HTTPS 249
12.2  保证发现服务器的安全 251
12.2.1  注册安全的应用程序 251
12.2.2  通过HTTPS服务Eureka 251
12.3  保证配置服务器的安全 255
12.3.1  加密和解密 255
12.3.2  配置客户端和服务器的身份验证 257
12.4  使用OAuth2进行授权 259
12.4.1  OAuth2简介 259
12.4.2  构建授权服务器 260
12.4.3  客户端配置 264
12.4.4  使用JDBC后端存储 266
12.4.5  服务间授权 269
12.4.6  在API网关上启用SSO 273
12.5  小结 274
第13章  测试Java微服务 275
13.1  测试策略 275
13.2  测试Spring Boot应用程序 277
13.2.1  构建示例应用程序 278
13.2.2  与数据库集成 279
13.3  单元测试 280
13.4  组件测试 282
13.4.1  使用内存数据库运行测试 282
13.4.2  处理HTTP客户端和服务发现 283
13.4.3  实现示例测试 285
13.5  集成测试 286
13.5.1  对测试进行分类 286
13.5.2  捕获HTTP流量 287
13.6  契约测试 289
13.6.1  使用Pact 289
13.6.2  使用Spring Cloud Contract 294
13.7  性能测试 301
13.8  小结 305
第三部分  Docker支持和Spring Cloud平台
第14章  Docker支持 309
14.1  关于Docker 309
14.2  安装Docker 311
14.3  常用的Docker命令 312
14.3.1  运行和停止容器 312
14.3.2  列出并删除容器 313
14.3.3  提取和推送镜像 314
14.3.4  构建镜像 315
14.3.5  创建网络 316
14.4  创建具有微服务的Docker镜像 316
14.4.1  Dockerfile 317
14.4.2  运行容器化微服务 319
14.4.3  使用Maven插件构建镜像 321
14.4.4  高级Docker镜像 323
14.5  持续交付 325
14.5.1  将Jenkins与Docker集成 325
14.5.2  构建管道 327
14.6  使用Kubernetes 330
14.6.1  概念和组件 331
14.6.2  通过Minikube以本地方式运行Kubernetes 332
14.6.3  部署应用程序 333
14.6.4  维护集群 336
14.7  小结 338
第15章  云平台上的Spring微服务 339
15.1  Pivotal Cloud Foundry 339
15.1.1  使用模式 340
15.1.2  准备应用程序 341
15.1.3  部署应用程序 343
15.1.4  维护 347
15.2  Heroku平台 352
15.2.1  部署方法 352
15.2.2  准备应用程序 355
15.2.3  测试部署 356
15.3  小结 358
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Spring
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
译 序
致 谢
第 一 章　 明天的寓言
第 二 章　 忍耐的义务
第 三 章　 死神的特效药
第 四 章　 地表水与地下海洋
第 五 章　 土壤王国
第 六 章　 地球的绿色斗篷
第 七 章　 全无必要的清剿
第 八 章　 鸟儿不再歌唱
第 九 章　 死亡之河
第 十 章　 灾难普天而降
第十一章　 波吉亚家族都不敢想象
第十二章　 人类的代价
第十三章　 透过一扇小窗
第十四章　 四中有一的概率
第十五章　 大自然的反击
第十六章　 轰隆隆的雪崩声
第十七章　 另一条路
译 后 记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂靜的春天：自然文學不朽經典全譯本【精裝版】
編者序
推薦序：我們都欠瑞秋‧卡森一份情 文／李偉文
推薦序：科學萬能世代裡敲起的一記警鐘 文／袁孝維

第一章 明日寓言
第二章 人類不得不承受的共業
第三章 要命的靈藥
第四章 地表水和地下海
第五章 土壤的國度
第六章 地球的綠衣
第七章 無謂的破壞
第八章 不聞鳥鳴
第九章 死亡之河
第十章 漫天蓋地
第十一章 難以擺脫的噩夢
第十二章 人命值多少
第十三章 隔著一道窄窗
第十四章 四分之一
第十五章 大自然反撲
第十六章 隆隆的雪崩聲
第十七章 另一條路

誌謝
作者小記
瑞秋．卡森《寂靜的春天》迴響大事記
附錄
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂靜的春天：自然文學不朽經典全譯本【精裝版】
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Spring
目    录
第1章  Spring Boot 2.0 1
1.1  Spring Boot概述 2
1.2  利用Spring Boot简化应用程序开发 3
1.3  Spring Boot中的核心组件 5
1.3.1  Spring Boot Starter 5
1.3.2  Spring Boot Starter Parent POM 7
1.3.3  Spring Boot auto-configuration 7
1.3.4  启用Spring Boot auto-configuration 9
1.3.5  Spring Boot CLI 11
1.3.6  Spring Boot Actuator 11
1.4  设置Spring Boot工作区 12
1.4.1  利用Maven设置Spring Boot 13
1.4.2  利用Gradle设置Spring Boot 13
1.5  开发第一个Spring Boot应用程序 15
1.5.1  使用Web界面 15
1.5.2  利用STS IDE创建Spring Boot项目 17
1.6  实现REST服务 19
1.7  Spring Boot 2.0中的新特性 22
1.8  本章小结 22
第2章  定制auto-configuration 25
2.1  理解auto-configuration 26
2.2  定制Spring Boot 27
2.2.1  利用Spring Boot属性进行定制 27
2.2.2  替换已生成的Bean 29
2.2.3  禁用特定的auto-configuration类 29
2.2.4  修改库的依赖关系 30
2.3  基于属性的配置外部化 31
2.3.1  属性的评估顺序 31
2.3.2  重命名Spring应用程序中的application.properties 32
2.4  外部配置应用程序属性 33
2.5  基于日志记录的调优 35
2.6  YAML配置文件 36
2.6.1  针对属性的YAML 36
2.6.2  单一YAML文件中的多个属性 37
2.7  定制应用程序错误页面 37
2.8  本章小结 39
第3章  Spring CLI和Actuator 41
3.1  使用Spring Boot CLI 41
3.1.1  安装Spring Boot CLI 42
3.1.2  从安装文件中手动安装Spring Boot CLI 42
3.1.3  使用SDKMAN!安装Spring Boot CLI 43
3.1.4  利用OSX Homebrew安装Spring Boot CLI 43
3.2  使用Initializr 44
3.3  Spring Boot Actuator 48
3.3.1  在应用程序中启用Spring Boot Actuator 49
3.3.2  分析Actuator的端点 49
3.3.3  显示配置细节 51
3.3.4  显示指标端点 56
3.3.5  显示应用程序信息 57
3.3.6  关闭应用程序 59
3.3.7  自定义Actuator端点 59
3.3.8  创建一个自定义端点 64
3.4  Actuator端点的安全性 66
3.5  Spring Boot 2.x中的Actuator 67
3.6  本章小结 68
第4章  Spring Cloud和配置操作 69
4.1  原生云应用程序架构 69
4.1.1  微服务架构 71
4.1.2  微服务的优点 72
4.1.3  微服务面临的挑战 73
4.2  Spring Cloud简介 74
4.2.1  云和微服务程序的构造块 74
4.2.2  Spring Cloud应用 76
4.3  配置Spring Cloud应用程序 77
4.4  创建配置生成器—Spring Cloud Config Server 78
4.5  实现Cloud Config Server 79
4.5.1  配置application.properties文件 80
4.5.2  创建Git存储库作为配置存储 80
4.6  利用模式配置多个存储库 83
4.6.1  身份验证 84
4.6.2  force-pull属性 85
4.7  创建Spring Cloud客户端 85
4.8  本章小结 87
第5章  Spring Cloud Netflix和Service Discovery 89
5.1  Spring Cloud Netflix简介 89
5.2  微服务架构中的Service Discovery 90
5.3  实现Service Discovery—Eureka Server 92
5.3.1  Maven构建配置文件 92
5.3.2  Gradle构建配置文件 93
5.3.3  启用Eureka服务器作为Discovery Service服务器 94
5.4  实现Service Discovery—Eureka客户端 96
5.4.1  添加Maven依赖关系配置 96
5.4.2  Gradle构建配置 98
5.5  利用Eureka注册客户端 99
5.5.1  使用REST服务 102
5.5.2  使用EurekaClient 102
5.5.3  Feign Client 107
5.6  本章小结 111
第6章  构建Spring Boot RESTful微服务 113
6.1  基于Spring Boot的微服务 113
6.1.1  bootstrap.yml和application.yml简介 114
6.1.2  简单的微服务示例 115
6.2  Spring Data简介 128
6.2.1  Apache Ignite存储库 129
6.2.2  Spring Data MongoDB 129
6.2.3  Spring Data JPA 130
6.3  本章小结 130
第7章  利用Netflix Zuul创建API网关 133
7.1  API网关模式需求 133
7.1.1  API Gateway模式的优点 135
7.1.2  API Gateway的一些缺点 135
7.1.3  API Gateway模式组件 135
7.2  利用Netflix Zuul Proxy实现API Gateway 136
7.2.1  利用Maven依赖关系包含Zuul 137
7.2.2  启用Zuul服务代理 137
7.2.3  配置Zuul属性 138
7.2.4  添加过滤器 141
7.3  本章小结 144
第8章  利用Feign客户端简化HTTP API 145
8.1  Feign基础知识 145
8.2  在云应用程序中包含Feign 148
8.2.1  重载Feign的默认配置 153
8.2.2  创建Feign客户端 155
8.2.3  Feign继承机制 156
8.2.4  多重继承 156
8.3  Feign客户端的高级应用 157
8.4  异常处理 158
8.5  自定义编码器和解码器 159
8.5.1  自定义编码器 160
8.5.2  自定义解码器 161
8.6  Feign和Hystrix 161
8.7  Feign客户端单元测试 163
8.8  本章小结 164
第9章  构建事件驱动和异步响应式系统 165
9.1  事件驱动型架构模式 165
9.1.1  调停者拓扑 165
9.1.2  代理拓扑 166
9.2  响应式编程简介 167
9.2.1  Spring Reactive 167
9.2.2  ReactiveX 168
9.3  命令查询的责任分离简介 168
9.3.1  Event Sourcing模式简介 170
9.3.2  最终一致性 171
9.4  构建事件驱动型响应式异步系统 172
9.5  Spring Cloud Streaming简介 173
9.5.1  向应用程序中添加Kafka 174
9.5.2  安装和运行Kafka 175
9.5.3  Kafka配置属性 175
9.5.4  用于写入Kafka的服务 176
9.5.5  Rest API控制器 177
9.5.6  监听Kafka主题 177
9.6  本章小结 181
第10章  利用Hystrix和Turbine构建弹性系统 183
10.1  断路器模式 184
10.2  使用Hystrix library 186
10.3  在应用程序中配置Hystrix 187
10.3.1  Maven依赖关系 188
10.3.2  启用断路器 188
10.3.3  向服务中添加Hystrix注解 189
10.3.4  错误传递 192
10.4  在客户服务中实现REST控制器 192
10.5  构建和测试客户服务 195
10.6  自定义默认的配置项 196
10.7  Hystrix Metrics Stream 198
10.8  在项目中实现Hystrix Dashboard 199
10.9  Turbine仪表盘 201
10.10  基于Hystrix和Feign的REST使用者 204
10.11  本章小结 206
第11章  测试Spring Boot应用程序 207
11.1  测试驱动开发 207
11.2  单元测试机制 208
11.2.1  单元测试的优点 211
11.2.2  单元测试的缺点 212
11.2.3  其他模拟库 212
11.3  集成测试 212
11.3.1  Spring测试的优点 214
11.3.2  激活测试类的配置 214
11.4  Spring Boot应用程序的JUnit测试 214
11.5  使用Mockito模拟服务 216
11.6  测试RESTful服务契约的Postman 217
11.7  本章小结 220
第12章  微服务的容器化 221
12.1  微服务架构的容器 222
12.1.1  虚拟机和容器 222
12.1.2  容器方案的优点 224
12.1.3  面向容器方案的缺点 224
12.2  Docker简介 225
12.2.1  安装Docker 226
12.2.2  在Linux上安装Docker 226
12.2.3  在Windows中安装Docker 227
12.2.4  Docker架构 229
12.2.5  Docker引擎 231
12.2.6  Docker容器 232
12.2.7  编写Dockerfile 233
12.3  Docker化Spring Boot应用程序 235
12.4  利用Maven创建Docker镜像 239
12.5  Docker Compose简介 240
12.5.1  安装Docker Compose 241
12.5.2  使用Docker Compose 242
12.5.3  编写docker-compose文件 242
12.5.4  基于docker-compose文件的编排操作 244
12.5.5  利用docker-compose和负载平衡扩展容器 247
12.6  Kubernetes简介 248
12.7  本章小结 249
第13章  API管理器 251
13.1  API管理 251
13.1.1  API管理软件的优点 252
13.1.2  API管理工具 252
13.2  速率限制 252
13.3  KONG简介 253
13.3.1  基于KONG架构的微服务REST API 254
13.3.2  未采用KONG架构的API应用 255
13.3.3  安装KONG 255
13.3.4  使用KONG API 257
13.4  Swagger 265
13.4.1  Swagger应用 265
13.4.2  在微服务中使用Swagger 266
13.4.3  Swagger的优点 277
13.5  本章小结 278
第14章  云部署（AWS） 279
14.1  AWS EC2实例 279
14.2  AWS上的微服务架构 284
14.3  在AWS EC2上安装Docker 289
14.4  在AWS EC2上运行微服务 291
14.5  本章小结 293
第15章  生产服务监视和最佳实践 295
15.1  监视容器 295
15.2  日志机制所面临的挑战 295
15.3  微服务架构的中心日志方案 297
15.3.1  基于ELK栈的日志聚合 299
15.3.2  使用Sleuth的请求跟踪 306
15.3.3  基于Zipkin的请求跟踪 310
15.4  本章小结 315
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Spring
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java Web企业应用实战――Spring MVC+Spring+MyBatis整合开发
第1章　Java EE应用和开发环境	1
1.1　Java EE应用概述	2
1.1.1  Java EE应用的分层模型	2
1.1.2  Java EE应用的组件	3
1.1.3　Java EE应用的结构和优势	4
1.1.4　常用的Java EE服务器	4
1.2　轻量级Java EE应用相关技术	5
1.2.1　JSP、Servlet 4.x和JavaBean及替代技术	5
1.2.2　Spring MVC及替代技术	6
1.2.3　MyBatis及替代技术	6
1.2.4　Spring及替代技术	7
1.3　Tomcat的下载和安装	8
1.3.1　安装Tomcat服务器	8
1.3.2　配置Tomcat的服务端口	9
1.3.3　进入控制台	10
1.3.4　部署Web应用	12
1.3.5　配置Tomcat的数据源	13
1.4　Eclipse的安装和使用	15
1.4.1　Eclipse的下载和安装	15
1.4.2  在线安装Eclipse插件	15
1.4.3　从本地压缩包安装插件	17
1.4.4　手动安装Eclipse插件	18
1.4.5　使用Eclipse开发Java Web应用	18
1.4.6　导入Eclipse项目	21
1.4.7　导入非Eclipse项目	22
1.5　Ant的安装和使用	23
1.5.1　Ant的下载和安装	24
1.5.2　使用Ant工具	25
1.5.3　定义生成文件	26
1.5.4　Ant的任务（task）	30
1.6　Maven的安装和使用	32
1.6.1　下载和安装Maven	33
1.6.2　设置Maven	34
1.6.3　创建、构建简单的项目	35
1.6.4  Maven的核心概念	39
1.6.5　依赖管理	44
1.6.6　POM文件的元素	46
1.7　使用Git进行软件配置管理（SCM）	47
1.7.1　下载和安装Git、TortoiseGit	47
1.7.2  创建本地资源库	49
1.7.3  添加文件和文件夹	51
1.7.4  提交修改	52
1.7.5　查看文件或文件夹的版本变更	53
1.7.6　删除文件或文件夹	54
1.7.7  从以前版本重新开始	55
1.7.8  克隆项目	56
1.7.9  创建分支	56
1.7.10　沿着分支开发	57
1.7.11　合并分支	58
1.7.12  使用Eclipse作为Git客户端	59
1.7.13　配置远程中央资源库	61
1.7.14  推送项目	64
1.7.15  获取项目和拉取项目	64
1.8　本章小结	66
第2章　MyBatis的基础用法	67
2.1　MyBatis是ORM框架吗	68
2.1.1　何谓ORM	68
2.1.2  ORM的映射方式	69
2.1.3  MyBatis的映射方式	70
2.2　MyBatis入门	71
2.2.1　MyBatis的下载和安装	72
2.2.2　MyBatis的数据库操作	72
2.2.3  使用MyBatis执行CRUD	78
2.2.4  利用Mapper对象	80
2.2.5  在Eclipse中使用MyBatis	84
2.3  MyBatis核心API及作用域	90
2.3.1  SqlSessionFactoryBuilder的作用域	90
2.3.2  SqlSessionFactory的作用域	91
2.3.3  SqlSession及其作用域	92
2.3.4  Mapper组件的作用域	94
2.4  MyBatis配置详解	94
2.4.1  属性配置	95
2.4.2  设置配置	98
2.4.3  为类型配置别名	101
2.4.4  对象工厂	103
2.4.5  加载Mapper	105
2.5  类型处理器	106
2.5.1  内置的类型处理器	106
2.5.2  自定义类型处理器	107
2.5.3　枚举的类型处理器	111
2.5.4  存储枚举值的序号	112
2.5.5  同时存储枚举值的名称和序号	113
2.6  数据库环境配置	116
2.6.1  环境配置与默认环境配置	116
2.6.2  事务管理器	117
2.6.3  数据源配置	121
2.6.4  配置第三方C3P0数据源	122
2.7  支持不同类型的数据库	124
2.8  Mapper基础	127
2.8.1  select的用法	128
2.8.2  insert的用法	130
2.8.3  使用useGeneratedKeys返回	自增长的主键值	131
2.8.4  使用selectKey生成主键值	132
2.8.5  update和delete元素的用法	134
2.8.6  使用sql元素定义可复用的SQL片段	134
2.8.7  参数处理	136
2.8.8  参数的额外声明	142
2.8.9  字符串替换	142
2.9  MyBatis代码生成器	144
2.9.1  提供配置文件	145
2.9.2  运行MBG	146
2.10  本章小结	149
第3章　深入使用MyBatis	151
3.1  结果集映射	152
3.1.1  简单resultMap映射	152
3.1.2  构造器映射	154
3.1.3  自动映射	157
3.2  调用存储过程	159
3.2.1  调用返回结果集的存储过程	159
3.2.2  调用带out模式参数的存储过程	160
3.2.3  调用传出参数为游标引用的存储过程	162
3.3  关联映射	165
3.3.1  基于嵌套select的一对一映射	165
3.3.2  基于嵌套select映射策略的性能缺陷	171
3.3.3  延迟加载的原理	175
3.3.4  基于多表连接查询的一对一映射	176
3.3.5  基于多结果集的一对一映射	182
3.3.6  基于嵌套select的一对多映射	184
3.3.7  基于多表连接查询的一对多映射	191
3.3.8  基于多结果集的一对多映射	192
3.3.9  多对多映射的三种策略	194
3.4  基于辨别者列的继承映射	201
3.4.1  继承映射的简单示例	201
3.4.2  继承映射的复杂示例	205
3.5  动态SQL	210
3.5.1  if元素的用法	210
3.5.2  在update更新列中使用if	216
3.5.3　在insert动态插入列中使用if	219
3.5.4  choose、when、otherwise元素的	用法	222
3.5.5  where与trim的用法	225
3.5.6  set与trim的用法	228
3.5.7  使用trim实现动态插入	230
3.5.8  foreach元素的基本用法	232
3.5.9  foreach实现批量插入	234
3.5.10  foreach实现批量更新	236
3.5.11  bind元素的用法	239
3.6  缓存	240
3.6.1  一级缓存	240
3.6.2  一级缓存的脏数据与避免方法	243
3.6.3  二级缓存	246
3.6.4  二级缓存的脏数据与避免方法	248
3.6.5  整合Ehcache实现二级缓存	252
3.7  用插件扩展MyBatis	254
3.7.1  拦截器接口及作用原理	254
3.7.2  可拦截的目标	256
3.7.3  为MyBatis开发分页插件	260
3.8  本章小结	266
第4章　Spring的基础用法	267
4.1  Spring简介和Spring 5的变化	268
4.1.1  Spring简介	268
4.1.2  Spring 5.x的变化	269
4.2  Spring入门	269
4.2.1  Spring的下载和安装	270
4.2.2  使用Spring管理Bean	270
4.2.3  在Eclipse中使用Spring	274
4.3  Spring的核心机制：依赖注入	276
4.3.1  理解依赖注入	277
4.3.2  设值注入	278
4.3.3  构造注入	282
4.3.4  两种注入方式的对比	284
4.4  使用Spring容器	284
4.4.1  Spring容器	284
4.4.2  使用ApplicationContext	286
4.4.3  ApplicationContext的国际化支持	287
4.4.4  ApplicationContext的事件机制	289
4.4.5  让Bean获取Spring容器	292
4.5  Spring容器中的Bean	294
4.5.1  Bean的基本定义和Bean别名	294
4.5.2  容器中Bean的作用域	295
4.5.3  配置依赖	299
4.5.4  设置普通属性值	300
4.5.5  配置合作者Bean	302
4.5.6  使用自动装配注入合作者Bean	302
4.5.7  注入嵌套Bean	305
4.5.8  注入集合值	306
4.5.9  组合属性	311
4.5.10  Spring的Bean和JavaBean	312
4.6  Spring的Java配置管理	313
4.7  创建Bean的三种方式	316
4.7.1  使用构造器创建Bean	316
4.7.2  使用静态工厂方法创建Bean	317
4.7.3  使用实例工厂方法创建Bean	319
4.8  深入理解容器中的Bean	321
4.8.1  抽象Bean与子Bean	322
4.8.2  Bean继承与Java继承的区别	323
4.8.3  容器中的工厂Bean	323
4.8.4  获得Bean本身的id	326
4.8.5  强制初始化Bean	327
4.9  容器中Bean的生命周期	327
4.9.1  依赖关系注入之后的行为	328
4.9.2  Bean销毁之前的行为	330
4.9.3  协调作用域不同步的Bean	332
4.10  高级依赖关系配置	336
4.10.1  获取其他Bean的属性值	336
4.10.2  获取Field值	339
4.10.3  获取方法的返回值	341
4.11  基于XML Schema的简化配置方式	344
4.11.1  使用p:命名空间简化配置	344
4.11.2  使用c:命名空间简化配置	345
4.11.3  使用util:命名空间简化配置	347
4.12  Spring表达式语言	349
4.12.1  使用Expression接口进行表达式求值	350
4.12.2  Bean定义中的表达式语言支持	352
4.12.3  SpEL语法详述	353
4.13  本章小结	358
第5章　深入使用Spring	359
5.1  两种后处理器	360
5.1.1  Bean后处理器	360
5.1.2  Bean后处理器的用处	364
5.1.3  容器后处理器	364
5.1.4  属性占位符配置器	366
5.1.5  重写占位符配置器	367
5.2  “零配置”支持	368
5.2.1  搜索Bean类	368
5.2.2  指定Bean的作用域	371
5.2.3  使用@Resource、@Value配置依赖	372
5.2.4  使用@PostConstruct和@PreDestroy定制生命周期行为	373
5.2.5  @DependsOn和@Lazy	374
5.2.6  自动装配和精确装配	374
5.2.7  Spring 5新增的注解	379
5.3  资源访问	380
5.3.1  Resource实现类	381
5.3.2  ResourceLoader接口和	ResourceLoaderAware接口	385
5.3.3  使用Resource作为属性	388
5.3.4  在ApplicationContext中使用资源	389
5.4  Spring的AOP	392
5.4.1  为什么需要AOP	393
5.4.2  使用AspectJ实现AOP	394
5.4.3  AOP的基本概念	401
5.4.4  Spring的AOP支持	402
5.4.5  基于注解的“零配置”方式	403
5.4.6  基于XML配置文件的管理方式	418
5.5  Spring的缓存机制	424
5.5.1  启用Spring缓存	425
5.5.2  使用@Cacheable执行缓存	427
5.5.3  使用@CacheEvict清除缓存数据	431
5.6  Spring的事务	433
5.6.1  Spring支持的事务策略	433
5.6.2  使用XML Schema配置事务策略	436
5.6.3  使用@Transactional	442
5.7  Spring整合MyBatis	443
5.7.1  整合MyBatis的关键点及快速入门	443
5.7.2  配置SqlSessionFactory	448
5.7.3  通过工厂Bean配置Mapper组件	449
5.7.4  通过扫描自动配置Mapper组件	450
5.7.5  基于SqlSession实现DAO组件	452
5.7.6  继承SqlSessionDaoSupport实现DAO组件	455
5.7.7  事务管理	457
5.8  本章小结	458
第6章　Spring MVC的基础用法	459
6.1  MVC概述	460
6.1.1  MVC模式及其优势	460
6.1.2  Spring MVC与Struts 2的区别	461
6.2  Spring MVC入门	463
6.2.1  在Web应用中启动Spring容器	463
6.2.2  配置核心控制器	466
6.2.3  开发控制器	468
6.2.4  提供视图资源	470
6.2.5  使用Eclipse开发Spring MVC应用	471
6.3  Spring MVC的流程	472
6.3.1  Spring MVC应用的开发步骤	472
6.3.2  Spring MVC的运行流程	474
6.3.3  DispatcherServlet详解	475
6.3.4  mvc:annotation-driven详解	480
6.4  静态资源处理	481
6.4.1  静态资源映射	481
6.4.2  配置默认Servlet	483
6.5  视图解析器	485
6.5.1  UrlBasedViewResolver的功能与用法	486
6.5.2  InternalResourceViewResolver的功能与用法	491
6.5.3  XmlViewResolver及视图解析器的链式处理	492
6.5.4  ResourceBundleViewResolver的功能与用法	496
6.5.5  BeanNameViewResolver的功能与用法	497
6.5.6  重定向视图	499
6.5.7  将数据传给重定向目标	500
6.5.8  ContentNegotiatingViewResolver的功能与用法	503
6.6  请求映射与参数处理	510
6.6.1  HandlerMapping与处理映射	510
6.6.2  SimpleUrlHandlerMapping的功能与用法	511
6.6.3  @RequestMapping注解及其变体	512
6.6.4  处理方法允许的返回值类型	515
6.6.5  @RequestParam注解与MultiValueMap	516
6.6.6  使用@PathVariable获取路径变量的值	520
6.6.7  使用@PathVariable处理正则	表达式	523
6.6.8  路径模式	524
6.6.9  使用@MatrixVariable处理Matrix变量	526
6.6.10  使用@RequestHeader获取请求头的值	529
6.6.11  异步处理	530
6.6.12  使用DeferredResult支持异步处理	534
6.6.13  使用@ModelAttribute修饰方法本身	536
6.6.14  使用@ModelAttribute修饰方法参数	539
6.7  将数据传给视图页面	541
6.7.1  Model、ModelMap和RedirectAttributes	541
6.7.2  使用@SessionAttributes添加session属性	542
6.8  RESTful服务支持	544
6.8.1  RESTful简介	544
6.8.2  @RequestBody与@ResponseBody注解	546
6.8.3  HttpMessageConverter与消息转换	550
6.8.4  转换XML数据	553
6.8.5  使用@RestController修饰RESTful控制器	557
6.8.6  @CrossOrigin注解与跨域请求	557
6.9  访问Servlet API相关数据	561
6.9.1  处理方法可接受的形参类型	561
6.9.2  使用@RequestAttribute获取请求属性	562
6.9.3  使用@SessionAttribute获取session属性	563
6.9.4  直接访问Servlet API	566
6.9.5  使用WebRequest和NativeWebRequest伪访问	567
6.9.6  使用@CookieValue获取cookie值	569
6.9.7  在处理方法中使用IO流	571
6.10  本章小结	573
第7章　深入使用Spring MVC	574
7.1  国际化	575
7.1.1  国际化到底怎么做	575
7.1.2  根据浏览器请求头确定Locale	577
7.1.3  根据session确定Locale	582
7.1.4  根据cookie值确定Locale	586
7.2  异常处理	587
7.2.1  Spring MVC异常处理	587
7.2.2  传统的异常处理机制	590
7.2.3  使用@ResponseStatus修饰异常类	594
7.2.4  使用@ExceptionHandler修饰异常	处理方法	596
7.2.5  使用@ControllerAdvice定义异常Aspect	599
7.2.6  使用@RestControllerAdvice定义异常Aspect	600
7.3  标签库	602
7.3.1  form标签与普通表单域标签	602
7.3.2  radiobutton和radiobuttons标签	605
7.3.3  checkbox和checkboxes标签	607
7.3.4  select和option、options标签	610
7.3.5  htmlEscape和escapeBody标签	612
7.3.6  url和param标签	613
7.4  类型转换与绑定	615
7.4.1  BeanWrapper简介	616
7.4.2  PropertyEditor与内置实现类	618
7.4.3  自定义PropertyEditor	619
7.4.4  使用WebBindingInitializer注册全局PropertyEditor	621
7.4.5  使用ConversionService执行转换	623
7.4.6  处理转换错误	626
7.5  格式化	629
7.5.1  使用格式化器	630
7.5.2  使用FormatterRegistrar注册	格式化器	633
7.6  数据校验	634
7.6.1  使用Validation执行校验	634
7.6.2  基于JSR 303执行校验	638
7.7  文件上传与下载	641
7.7.1  使用MultipartFile处理文件上传	641
7.7.2  基于Commons FileUpload组件	上传文件	646
7.7.3  使用@RequestPart注解	647
7.7.4  文件下载	650
7.7.5  下载前的授权控制	652
7.8  拦截器	653
7.9  SSM整合开发	656
7.9.1  搭建项目	657
7.9.2  开发Mapper组件	659
7.9.3  开发Service组件	660
7.9.4  控制器与视图	661
7.10  本章小结	666
第8章　简单工作流系统	667
8.1  项目背景及系统结构	668
8.1.1  应用背景	668
8.1.2  系统功能介绍	668
8.1.3  相关技术介绍	669
8.1.4  系统结构	670
8.1.5  系统的功能模块	670
8.2  领域对象层	671
8.2.1  设计领域对象	671
8.2.2  创建领域对象类	672
8.3  实现Mapper（DAO）层	677
8.3.1  Mapper组件的定义	677
8.3.2  实现Mapper组件	681
8.3.3  部署Mapper层	685
8.4  实现Service层	686
8.4.1  业务逻辑组件的设计	686
8.4.2  实现业务逻辑组件	687
8.4.3  事务管理	692
8.4.4  部署业务逻辑组件	693
8.5  实现任务的自动调度	693
8.5.1  使用Quartz	693
8.5.2  在Spring中使用Quartz	698
8.6  实现系统Web层	700
8.6.1  配置核心控制器和启动Spring容器	700
8.6.2  控制器的处理顺序	701
8.6.3  员工登录	702
8.6.4  进入打卡	705
8.6.5  处理打卡	707
8.6.6  进入申请	708
8.6.7  提交申请	709
8.6.8  使用拦截器完成权限管理	710
8.7  本章小结	712
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java Web企业应用实战――Spring MVC+Spring+MyBatis整合开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot+Spring Cloud微服务开发实战
第1篇 Web基础知识
第1章 认识微服务03
1．1　什么是微服务框架　03
1．2　互联网框架的演变　04
1．2．1　ORM框架　05
1．2．2　MVC框架　06
1．2．3　RPC框架　07
1．2．4　SOA框架　09
1．3　模块的拆分　09
1．3．1　拆分中的问题　10
1．3．2　拆分原则　10
1．4　当前主流微服务框架　12
1．4．1　Dubbo简介　12
1．4．2　Spring Cloud简介　13
1．4．3　HTTP与RPC简介　14
1．4．4　Spring Boot与Spring Cloud的关系　15
第2章 快速搭建一个微服务框架16
2．1　Spring Boot框架搭建　16
2．1．1　使用STS搭建开发环境　16
2．1．2　使用IntelliJ IDEA搭建开发环境　19
2．2　实现安全登录的微服务框架　21
2．2．1　功能描述与最终目标　22
2．2．2　功能结构　22
2．3　微服务框架搭建　23
2．3．1　搭建模块　23
2．3．2　启动Demo　31
2．3．3　打包发布　34
第3章　Restful风格的编程　36
3．1　Restful 简介　36
3．2　查询用户以及用户详情　37
3．2．1　编写测试类程序　37
3．2．2　常用注解　40
3．2．3　查询用户详情　47
3．3　处理创建请求　50
3．3．1　@RequestBody注解　51
3．3．2　日期类型的处理　52
3．3．3　@Valid注解　54
3．3．4　BindingResult验证参数合法性　55
3．4　用户信息修改与删除　56
3．4．1　用户信息修改　56
3．4．2　用户信息删除　58
第2篇 Spring Boot
第4章　Spring Boot中的IOC　61
4．1　IOC原理简介　61
4．1．1　IOC小案例　61
4．1．2　IOC简介　64
4．2　装配Bean　67
4．2．1　@ComponentScan简介　67
4．2．2　@ComponentScan使用实例　69
4．3　依赖注入ID　75
4．3．1　常用注解　75
4．3．2　@Autowired 注解　76
4．4　Bean 的生命周期　82
4．4．1　Bean 的初始化过程　82
4．4．2　Bean 的延迟初始化　85
4．4．3　Bean 的生命周期　86
4．5　配置文件90
4．5．1　配置文件的使用方式　90
4．5．2　Yml 配置文件的使用　95
第5章　Spring Boot 中的AOP　97
5．1　AOP 简介　97
5．1．1　AOP 小案例　97
5．1．2　AOP 术语　101
5．2　AOP 开发详解　102
5．2．1　连接点与两种代理　102
5．2．2　切面　106
5．2．3　切点　107
5．2．4　多切面与@Order　111
5．3　AOP 原理　114
5．3．1　AOP 代理原理讲解　114
5．3．2　ProxyCreatorSupport 核心代理类　116
5．3．3　通知和通知器　118
5．4　AOP 后置处理器　120
5．4．1　AnnotationAwareAspectJAutoProxyCreator 方式　120
5．4．2　后置处理器的注册　122
5．4．3　后置处理器处理@Aspect 的Bean　123
第6章　Spring Boot 中的数据源　125
6．1　配置数据源　125
6．1．1　默认数据源　125
6．1．2　自定义数据源　126
6．2　JdbcTemplate 的使用　131
6．2．1　JdbcTemplate 实例　131
6．2．2　JdbcTemplate 原理说明　134
6．3　JPA 的使用　135
6．3．1　JPA 概述　135
6．3．2　JPA 使用实例135
6．4　Spring Boot 与MyBatis 集成　140
6．4．1　MyBatis 原理　140
6．4．2　Spring Boot 与MyBatis 集成　141
第7章　Spring Boot 中的事务　148
7．1　隔离级别148
7．1．1　数据库的隔离级别　148
7．1．2　Spring Boot 中的隔离级别　151
7．2　声明式事务　152
7．2．1　@Transaction 注解　152
7．2．2　事务管理器　153
7．3　JPA 下的事务　155
7．3．1　普通的数据库访问　155
7．3．2　事务　159
7．4　JDBC 下的事务　161
7．5　事务传播行为　164
第8章　Spring Boot 中的Redis　167
8．1　Redis 的简单使用　167
8．1．1　Spring-boot-starter-data-redis 介绍　167
8．1．2　Redis 的使用　168
8．1．3　使用配置类建立Redis 工厂　170
8．2　对Redis 数据类型的操作　172
8．2．1　StringRedisTemplate 的使用　172
8．2．2　模板template　175
8．2．3　数据类型的操作　177
8．3　序列化　181
8．3．1　序列化实例　181
8．3．2　序列化讲解　185
8．4　缓存　186
8．4．1　缓存的使用　186
8．4．2　缓存的注解　191
第9章　Spring Boot 中的Security　200
9．1　基本原理200
9．1．1　默认安全登录　201
9．1．2　Security 原理说明　202
9．2　自定义用户认证逻辑　204
9．2．1　处理用户获取逻辑　204
9．2．2　处理用户校验逻辑　206
9．2．3　密码加密与解密　208
9．3　自定义用户认证流程　210
9．3．1　自定义登录页面　210
9．3．2　优化自定义登录页面　213
9．3．3　登录成功之后的处理　218
9．3．4　登录失败之后的处理　220
第3篇　Spring Cloud
第10章 服务治理Spring Cloud Eureka　225
10．1　Eureka 快速入门　225
10．1．1　服务治理　225
10．1．2　Eureka 的服务治理　227
10．1．3　Eureka 的服务注册中心搭建　228
10．1．4　Eureka 的服务提供者　232
10．1．5　Eureka Server 的高可用　235
10．2　Eureka 的消费　237
10．2．1　RestTemplate 直接调用　237
10．2．2　LoadBalancerClient 调用　239
10．2．3　@LoadBalanced 注解　240
10．3　Eureka 原理详解　241
10．3．1　基础框架　241
10．3．2　机制　242
10．4　进阶配置项说明　244
10．4．1　服务注册类的配置　244
10．4．2　服务实例类的配置　246
10．4．3　服务注册中心配置　248
10．4．4　服务注册中心仪表盘配置　249
10．5　Eureka 源码分析　249
10．5．1　DiscoveryClient 实例　250
10．5．2　服务发现　251
第11章 负载均衡Spring Cloud Ribbon　254
11．1　Ribbon 使用　254
11．1．1　客户端负载均衡　254
11．1．2　Ribbon 实例　255
11．1．3　Ribbon 用法总结　258
11．2　RestTemplate 的详细使用方法　259
11．2．1　RestTemplate 功能　259
11．2．2　GET 请求API　261
11．2．3　POST 请求API　265
11．2．4　PUT 请求API　271
11．2．5　DELETE 请求API　271
11．3　Ribbon 的负载均衡入口　272
11．4　Ribbon 的负载均衡器　274
11．4．1　AbstractLoadBalancer 类　274
11．4．2　BaseLoadBalancer 类　275
11．4．3　DynamicServerListLoadBalancer 类　277
11．4．4　服务注册　282
第12章 声明式服务调用Spring Cloud Feign　285
12．1　Feign 的使用实例　285
12．1．1　Feign 演示实例　285
12．1．2　Feign 与Spring MVC　290
12．2　Feign 中Ribbon 的配置　294
12．2．1　全局配置与指定服务的配置　294
12．2．2　重试机制　295
12．3　Feign 的配置　296
12．3．1　日志配置　296
12．3．2　其他配置　298
12．3．3　自定义配置　299
第13章 服务容错保护Spring Cloud Hystrix　303
13．1　Hystrix 的使用　303
13．1．1　服务降级　303
13．1．2　超时设置　308
13．1．3　服务熔断　313
13．2　Hystrix 的原理　314
13．2．1　Hystrix 产生背景　315
13．2．2　Hystrix 实现原理　316
13．3　Hystrix 的应用　318
13．3．1　Hystrix 工作流程　318
13．3．2　自定义使用Hystrix　320
13．4　Hystrix 的配置　322
13．4．1　属性配置说明　322
13．4．2　属性配置　323
13．4．3　Command 属性　325
第14章 配置中心Spring Cloud Config　328
14．1　Config 的原理　328
14．2　Config 的服务端使用　329
14．2．1　搭建配置中心　329
14．2．2　配置中心测试　333
14．2．3　本地Git　336
14．3　Config 的客户端使用　337
14．3．1　配置客户端　337
14．3．2　客户端测试　338
14．3．3　Config 的高可用性　340
14．4　Config 的知识点　341
14．4．1　Config 的Git 介绍　341
14．4．2　动态刷新配置　342
第15章 网关Spring Cloud Zuul　343
15．1　Zuul 路由　343
15．1．1　基本的网关功能　343
15．1．2　自定义路由　348
15．1．3　Cookie 头信息控制　349
15．2　Zuul 请求过滤　351
15．2．1　应用场景　351
15．2．2　鉴权　352
15．2．3　限流　355
15．3　Zuul 其他知识点　356
15．3．1　过滤器　356
15．3．2　高可用　356
第４篇　微服务开发实战
第16章 点餐管理系统实战359
16．1　点餐管理系统框架说明　359
16．1．1　系统使用的技术　359
16．1．2　系统功能模块　361
16．1．3　系统搭建　361
16．2　点餐管理系统框架设计　372
16．2．1　具体需求分析　372
16．2．2　数据库设计　372
16．2．3　对外接口设计　373
16．3　商品模块开发　374
16．3．1　基本的准备工作　374
16．3．2　接口开发　376
16．3．3　封装Restful 接口　379
16．3．4　Restful 接口测试　380
16．4　订单模块开发　382
16．4．1　基本的准备工作　382
16．4．2　接口开发　384
16．4．3　封装Restful 接口　386
16．4．4　Restful 接口测试　386
第17章 图书管理系统实战387
17．1　图书管理系统框架说明　387
17．1．1　需求分析　387
17．1．2　技术说明　388
17．2　图书管理系统框架设计　388
17．2．1　数据库设计　388
17．2．2　接口设计　389
17．2．3　环境搭建　390
17．3　借阅模块开发　393
17．3．1　实体类　394
17．3．2　Repository 接口　394
17．3．3　Service 层　395
17．3．4　Controller 层　395
17．3．5　接口测试　395
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot+Spring Cloud微服务开发实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Spring：Java Web开发与Spring Boot高级功能
第1章 向Spring Framework 5.0进化　1
1.1 Spring Framework　1
1.2 Spring Framework为什么流行　2
1.2.1 简化了单元测试　2
1.2.2 减少了衔接代码　3
1.2.3 架构灵活性　4
1.2.4 与时俱进　4
1.3 Spring模块　5
1.3.1 Spring核心容器　5
1.3.2 横切关注点　5
1.3.3 Web层　6
1.3.4 业务层　6
1.3.5 数据层　6
1.4 Spring项目　6
1.4.1 Spring Boot　7
1.4.2 Spring Cloud　7
1.4.3 Spring Data　8
1.4.4 Spring Batch　8
1.4.5 Spring Security　8
1.4.6 Spring HATEOAS　9
1.5 Spring Framework 5.0中的新增功能　9
1.5.1 基准升级　10
1.5.2 JDK 9运行时兼容性　10
1.5.3 在Spring Framework代码中使用JDK 8功能　11
1.5.4 反应式编程支持　11
1.5.5 函数式Web框架　11
1.5.6 Java通过Jigsaw实现模块化　12
1.5.7 Kotlin支持　13
1.5.8 已停用的功能　14
1.6 Spring Boot 2.0的新增功能　14
1.7 小结　15
第2章 依赖注入　16
2.1 了解依赖注入　16
2.1.1 了解依赖项　17
2.1.2 Spring IoC容器　19
2.1.3 使用模拟对象进行单元测试　26
2.1.4 容器托管bean　28
2.1.5 依赖注入类型　28
2.1.6 Spring bean作用域　30
2.1.7 Java与XML配置　30
2.1.8 @Autowired 注解详解　31
2.1.9 其他重要的Spring注解　32
2.1.10 上下文和依赖注入　32
2.2 小结　33
第3章 使用Spring MVC 构建Web应用程序　34
3.1 Java Web应用程序架构　34
3.1.1 Model 1架构　35
3.1.2 Model 2架构　35
3.1.3 Model 2前端控制器架构　36
3.2 基本流　37
3.2.1 基本设置　38
3.2.2 流1——不包含视图的简单控制器流　39
3.2.3 流2——包含视图的简单控制器流　42
3.2.4 流3——控制器通过模型重定向到视图　45
3.2.5 流4——控制器通过ModelAndView重定向到视图　47
3.2.6 流5——重定向到包含表单的视图的控制器　48
3.2.7 流6——在上一个流中添加验证功能　51
3.3 Spring MVC概述　54
3.3.1 重要特性　54
3.3.2 工作机制　55
3.4 Spring MVC背后的重要概念　56
3.4.1 RequestMapping　56
3.4.2 视图解析　58
3.4.3 处理程序映射和拦截器　59
3.4.4 模型属性　61
3.4.5 会话属性　62
3.4.6 @InitBinder注解　63
3.4.7 @ControllerAdvice注解　63
3.5 Spring MVC——高级功能　64
3.5.1 异常处理　64
3.5.2 国际化　66
3.5.3 对Spring 控制器进行集成测试　68
3.5.4 提供静态资源　69
3.5.5 集成Spring MVC与Bootstrap　71
3.6 Spring Security　72
3.6.1 添加Spring Security依赖项　73
3.6.2 配置过滤器以拦截所有请求　73
3.6.3 注销　74
3.7 小结　75
第4章 向微服务和云原生应用程序进化　76
4.1 使用Spring的典型Web应用程序架构　77
4.1.1 Web层　77
4.1.2 业务层　78
4.1.3 数据层　78
4.1.4 集成层　79
4.1.5 横切关注点　79
4.2 Spring解决的问题　79
4.2.1 松散耦合和可测试性　80
4.2.2 衔接代码　80
4.2.3 轻量级架构　80
4.2.4 架构灵活性　80
4.2.5 简化横切关注点的实现过程　81
4.2.6 免费的设计模式　81
4.3 应用程序开发目标　81
4.3.1 速度　82
4.3.2 安全保障　83
4.3.3 可扩展性　84
4.4 单体应用面临的挑战　84
4.4.1 漫长的发布周期　85
4.4.2 难以扩展　85
4.4.3 适应新技术　85
4.4.4 适应新方法　85
4.4.5 适应现代化开发实践　85
4.5 了解微服务　85
4.5.1 什么是微服务　86
4.5.2 微服务架构　86
4.5.3 微服务的特点　88
4.5.4 微服务的优势　91
4.5.5 微服务面临的挑战　92
4.6 云原生应用程序　94
4.7 Spring项目　98
4.7.1 Spring Boot　98
4.7.2 Spring Cloud　99
4.8 小结　99
第5 章 使用Spring Boot构建微服务　100
5.1 什么是Spring Boot　100
5.1.1 快速构建微服务器原型　101
5.1.2 主要目标　101
5.1.3 非功能性特性　102
5.2 Spring Boot Hello World　102
5.2.1 配置spring-boot-starter-parent　102
5.2.2 用所需的starter项目配置pom.xml　105
5.2.3 配置spring-boot-maven-plugin　106
5.2.4 创建第一个Spring Boot启动类　107
5.2.5 运行Hello World应用程序 ....... 108
5.2.6 自动配置　110
5.2.7 starter项目　113
5.3 什么是REST　114
5.4 首个REST服务　115
5.4.1 返回字符串的简单方法　116
5.4.2 返回对象的简单REST方法　118
5.4.3 包含路径变量的GET方法　120
5.5 创建待办事项资源　121
5.5.1 请求方法、操作和URI　122
5.5.2 bean和服务　122
5.5.3 检索待办事项列表　124
5.5.4 检索特定待办事项的详细信息　126
5.5.5 添加待办事项　128
5.6 Spring Initializr　132
5.7 自动配置概述　136
5.8 小结　138
第6章 扩展微服务　139
6.1 异常处理　139
6.2 HATEOAS　144
6.3 验证　147
6.3.1 对控制器方法启用验证　148
6.3.2 定义bean验证　148
6.3.3 验证功能单元测试　149
6.4 编写REST服务文档　149
6.5 使用Spring Security确保REST服务的安全　156
6.5.1 添加Spring Security starter　157
6.5.2 基本身份验证　157
6.5.3 OAuth 2身份验证　159
6.6 国际化　164
6.7 缓存　166
6.7.1 spring-boot-startercache　166
6.7.2 启用缓存　167
6.7.3 缓存数据　167
6.7.4 JSR-107缓存注解　167
6.8 小结　168
第7章 Spring Boot的高级功能　169
7.1 配置外部化　169
7.1.1 通过application.properties自定义框架　170
7.1.2 application.properties中的自定义属性　173
7.1.3 配置文件　176
7.1.4 其他定义应用程序配置值的选项　178
7.1.5 YAML配置　178
7.2 嵌入式服务器　179
7.2.1 切换到Jetty和Undertow　182
7.2.2 构建WAR文件　183
7.3 开发者工具　183
7.4 Spring Boot Actuator　184
7.4.1 HAL浏览器　185
7.4.2 配置属性　187
7.4.3 环境细节　188
7.4.4 运行状况　189
7.4.5 映射　189
7.4.6 bean　190
7.4.7 度量　191
7.4.8 自动配置　193
7.4.9 调试　194
7.5 部署应用程序到云端　194
7.6 小结　196
第8章 Spring Data　197
8.1 背景信息——数据存储　197
8.2 Spring Data　198
8.2.1 Spring Data Commons　199
8.2.2 Spring Data JPA　200
8.3 Spring Data Rest　212
8.3.1 GET方法　213
8.3.2 POST方法　214
8.3.3 搜索资源　215
8.4 大数据　215
8.5 小结　217
第9章 Spring Cloud　218
9.1 Spring Cloud 简介　218
9.2 演示微服务设置　220
9.2.1 微服务A　220
9.2.2 服务消费方　223
9.3 集中式微服务配置　225
9.3.1 问题陈述　225
9.3.2 解决方案　226
9.3.3 选项　226
9.3.4 Spring Cloud Config　227
9.4 Spring Cloud Bus　233
9.4.1 Spring Cloud Bus需求　233
9.4.2 使用Spring Cloud Bus传播配置更改　233
9.4.3 实现　234
9.5 声明式REST客户端——Feign　235
9.6 负载均衡　237
9.7 名称服务器　240
9.8 名称服务器的工作机制　240
9.8.1 选项　241
9.8.2 实现　241
9.9 API 网关　245
9.10 分布式跟踪　250
9.10.1 分布式跟踪选项　250
9.10.2 实现Spring Cloud Sleuth和Zipkin　251
9.11 Hystrix——容错　256
9.12 小结　257
第10章 Spring Cloud Data Flow　258
10.1 基于消息的异步通信　258
10.2 用于异步消息传递的Spring项目　260
10.2.1 Spring Integration　261
10.2.2 Spring Cloud Stream　261
10.2.3 Spring Cloud Data Flow　262
10.3 Spring Cloud Stream　263
10.3.1 Spring Cloud Stream架构　263
10.3.2 事件处理——股票交易示例　264
10.4 Spring Cloud Data Flow　269
10.4.1 高级架构　270
10.4.2 实现Spring Cloud Data Flow　271
10.4.3 Spring Cloud Data Flow REST API　280
10.5 Spring Cloud Task　281
10.6 小结　282
第11章 反应式编程　283
11.1 反应式宣言　283
11.2 反应式用例——股价页面　285
11.2.1 传统方法　285
11.2.2 反应式方法　286
11.2.3 传统与反应式方法比较　286
11.3 Java反应式编程　287
11.3.1 反应式流　287
11.3.2 Reactor　288
11.3.3 Spring Web Reactive　292
11.3.4 反应式数据库　298
11.4 小结　302
第12章 Spring最佳实践　303
12.1 Maven标准目录布局　303
12.2 分层架构　304
12.3 异常处理　306
12.3.1 Spring的异常处理方法　307
12.3.2 推荐的处理方法　307
12.4 确保简化Spring配置　308
12.4.1 在ComponentScan中使用basePackageClasses属性　308
12.4.2 不在架构引用中使用版本号　308
12.4.3 强制性依赖项首选构造函数注入而不是setter注入　309
12.5 管理Spring项目的依赖项版本　309
12.6 单元测试　311
12.6.1 业务层　311
12.6.2 Web层　312
12.6.3 数据层　312
12.6.4 其他最佳实践　313
12.7 集成测试　313
12.7.1 Spring Session　314
12.7.2 示例　315
12.8 缓存　316
12.8.1 添加Spring Boot Starter Cache依赖项　317
12.8.2 添加缓存注解　317
12.9 日志记录　317
12.9.1 Logback　317
12.9.2 Log4j2　318
12.9.3 独立于框架的配置　319
12.10 小结　319
第13章 在Spring 中使用Kotlin　320
13.1 Kotlin　320
13.2 Kotlin与Java　321
13.2.1 变量和类型推断　321
13.2.2 变量和不变性　322
13.2.3 类型系统　322
13.2.4 函数　323
13.2.5 数组　324
13.2.6 集合　324
13.2.7 未受检异常　325
13.2.8 数据类　326
13.3 在Eclipse 中创建Kotlin项目　326
13.3.1 Kotlin插件　326
13.3.2 创建Kotlin项目　327
13.3.3 创建Kotlin类　329
13.3.4 运行Kotlin类　330
13.4 使用Kotlin创建Spring Boot项目　331
13.4.1 依赖项和插件　332
13.4.2 Spring Boot应用程序类　333
13.4.3 Spring Boot应用程序测试类　334
13.5 使用Kotlin实现REST服务　335
13.5.1 返回字符串的简单方法　335
13.5.2 返回对象的简单REST方法　337
13.5.3 包含路径变量的GET方法　338
13.6 小结　340
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Spring：Java Web开发与Spring Boot高级功能
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ZUCCa SPRING/SUMMER 2012
a Male and a Female
feat. Sakura Ando × Ryo Kase
2012春夏コレクションのプレゼンテーションに密着
STRIPE BLOCK
ZUCCa 2012 SPRING / SUMMER CATALOGUE Part.1
遊び心満載、ボリュームもたっぷり。 「CAFE Z.」のおすすめメニュー
CAFE Z.
ZUCCa feat. HIKARI MITSUSHIMA
The Past Recedes
ZUCCa 2012 SPRING / SUMMER CATALOGUE Part.2
菊池亜希子と旅する
ZUCCa in Nagasaki
個性派メンズスタイリストたちが提案する CABANE de ZUCCaのシルエット
THE SILHOUETTE of CABANE de ZUCCa SPRING / SUMMER 2012
RAT GLORY:
STANDING ON THE GARDEN
本誌限定特別付録
ZUCCa特製ミリタリートートバッグ
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ZUCCa SPRING/SUMMER 2012
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Spring Cloud与微服务构建 第2版
第 1章 微服务简介1
1．1 单体架构及其存在的不足 1
1．1．1 单体架构简介 1
1．1．2 单体架构存在的不足 2
1．1．3 单体架构使用服务器集群及存在的不足 2
1．2 微服务 3
1．2．1 什么是微服务 4
1．2．2 微服务的优势 8
1．3 微服务的不足 9
1．3．1 微服务的复杂度 9
1．3．2 分布式事务 9
1．3．3 服务的划分 11
1．3．4 服务的部署 11
1．4 微服务和SOA的关系 12
1．5 微服务的设计原则 12
第 2章 Spring Cloud简介 14
2．1 微服务应该具备的功能 14
2．1．1 服务的注册与发现 15
2．1．2 服务的负载均衡 15
2．1．3 服务的容错 16
2．1．4 服务网关 18
2．1．5 服务配置的统一管理 19
2．1．6 服务链路追踪 20
2．2 Spring Cloud 20
2．2．1 简介 20
2．2．2 常用组件 21
2．2．3 项目一览 22
2．3 Dubbo简介 23
2．4 Spring Cloud与Dubbo比较 24
2．5 Kubernetes简介 25
2．6 Spring Could与Kubernetes比较 27
2．7 总结 28
第3章 构建微服务的准备 29
3．1 JDK的安装 29
3．1．1 JDK的下载和安装 29
3．1．2 环境变量的配置 29
3．2 IDEA的安装 30
3．2．1 IDEA的下载 30
3．2．2 用IDEA创建一个Spring Boot工程 31
3．2．3 用IDEA启动多个Spring Boot工程实例 33
3．3 构建工具Maven的使用 34
3．3．1 Maven简介 34
3．3．2 Maven的安装 34
3．3．3 Maven的核心概念 36
3．3．4 编写Pom文件 36
3．3．5 Maven构建项目的生命周期 38
3．3．6 常用的Maven命令 39
第4章 开发框架Spring Boot 41
4．1 Spring Boot简介 41
4．1．1 Spring Boot的特点 41
4．1．2 Spring Boot的优点 42
4．2 用IDEA构建Spring Boot工程 42
4．2．1 项目结构 42
4．2．2 在Spring Boot工程中构建Web程序 43
4．2．3 Spring Boot的测试 44
4．3 Spring Boot配置文件详解 45
4．3．1 自定义属性 45
4．3．2 将配置文件的属性赋给实体类 46
4．3．3 自定义配置文件 47
4．3．4 多个环境的配置文件 48
4．4 运行状态监控Actuator 48
4．4．1 查看运行程序的健康状态 50
4．4．2 查看运行程序的Bean 51
4．4．3 使用Actuator关闭应用程序 53
4．4．4 使用shell连接Actuator 54
4．5 Spring Boot整合JPA 55
4．6 Spring Boot整合Redis 58
4．6．1 Redis简介 58
4．6．2 Redis的安装 58
4．6．3 在Spring Boot中使用Redis 58
4．7 Spring Boot整合Swagger2，搭建Restful API在线文档 60
第5章 服务注册和发现Eureka 64
5．1 Eureka简介 64
5．1．1 什么是Eureka 64
5．1．2 为什么选择Eureka 64
5．1．3 Eureka的基本架构 65
5．2 编写Eureka Server 65
5．3 编写Eureka Client 68
5．4 源码解析Eureka 71
5．4．1 Eureka的一些概念 71
5．4．2 Eureka的高可用架构 72
5．4．3 Register服务注册 72
5．4．4 Renew服务续约 76
5．4．5 为什么Eureka Client获取服务实例这么慢 77
5．4．6 Eureka 的自我保护模式 78
5．5 构建高可用的Eureka Server集群 79
5．6 总结 81
第6章 负载均衡Ribbon 82
6．1 RestTemplate简介 82
6．2 Ribbon简介 83
6．3 使用RestTemplate和Ribbon来消费服务 83
6．4 LoadBalancerClient简介 86
6．5 源码解析Ribbon 88
第7章 声明式调用Feign 99
7．1 写一个Feign客户端 99
7．2 FeignClient详解 103
7．3 FeignClient的配置 104
7．4 从源码的角度讲解Feign的工作原理 105
7．5 在Feign中使用HttpClient和OkHttp 108
7．6 Feign是如何实现负载均衡的 110
7．7 总结 112
第8章 熔断器Hystrix 113
8．1 Hystrix简介 113
8．2 Hystrix解决的问题 113
8．3 Hystrix的设计原则 115
8．4 Hystrix的工作机制 115
8．5 在RestTemplate和Ribbon上使用熔断器 116
8．6 在Feign上使用熔断器 117
8．7 使用Hystrix Dashboard监控熔断器的状态 118
8．7．1 在RestTemplate中使用Hystrix Dashboard 118
8．7．2 在Feign中使用Hystrix Dashboard 121
8．8 使用Turbine聚合监控 122
第9章 路由网关Spring Cloud Zuul 124
9．1 为什么需要Zuul 124
9．2 Zuul的工作原理 124
9．3 案例实战 126
9．3．1 搭建Zuul服务 126
9．3．2 在Zuul上配置API接口的版本号 129
9．3．3 在Zuul上配置熔断器 130
9．3．4 在Zuul中使用过滤器 131
9．3．5 Zuul的常见使用方式 133
第 10章 服务网关 135
10．1 服务网关的实现原理 135
10．2 断言工厂 136
10．2．1 After路由断言工厂 136
10．2．2 Header断言工厂 138
10．2．3 Cookie路由断言工厂 139
10．2．4 Host路由断言工厂 140
10．2．5 Method路由断言工厂 140
10．2．6 Path 路由断言工厂 141
10．2．7 Query 路由断言工厂 141
10．3 过滤器 142
10．3．1 过滤器的作用 143
10．3．2 过滤器的生命周期 144
10．3．3 网关过滤器 144
10．3．4 全局过滤器 151
10．4 限流 153
10．4．1 常见的限流算法 153
10．4．2 服务网关的限流 154
10．5 服务化 156
10．5．1 工程介绍 156
10．5．2 service-gateway工程详细介绍 157
10．6 总结 159
第 11章 服务注册和发现Consul 160
11．1 什么是Consul 160
11．1．1 基本术语 160
11．1．2 Consul的特点和功能 161
11．1．3 Consul的原理 161
11．1．4 Consul的基本架构 161
11．1．5 Consul服务注册发现流程 163
11．2 Consul与Eureka比较 163
11．3 下载和安装Consul 164
11．4 使用Spring Cloud Consul进行服务注册和发现 165
11．4．1 服务提供者consul-provider 165
11．4．2 服务消费者consul-provider 167
11．5 使用Spring Cloud Consul Config做服务配置中心 168
11．6 动态刷新配置 170
11．7 总结 171
第 12章 配置中心Spring Cloud Config 172
12．1 Config Server从本地读取配置文件 172
12．1．1 构建Config Server 172
12．1．2 构建Config Client 174
12．2 Config Server从远程Git仓库读取配置文件 175
12．3 构建高可用的Config Server 176
12．3．1 构建Eureka Server 177
12．3．2 改造Config Server 178
12．3．3 改造Config Client 178
12．4 使用Spring Cloud Bus刷新配置 180
12．5 将配置存储在MySQL数据库中 182
12．5．1 改造config-server工程 182
12．5．2 初始化数据库 183
第 13章 服务链路追踪Spring Cloud Sleuth 184
13．1 为什么需要Spring Cloud Sleuth 184
13．2 基本术语 184
13．3 案例讲解 186
13．3．1 启动Zipkin Server 187
13．3．2 构建服务提供者 187
13．3．3 构建服务消费者 189
13．3．4 项目演示 191
13．4 在链路数据中添加自定义数据 192
13．5 使用RabbitMQ 传输链路数据 192
13．6 在MySQL数据库中存储链路数据 194
13．7 在ElasticSearch中存储链路数据 195
13．8 用Kibana展示链路数据 196
第 14章 微服务监控Spring Boot Admin 198
14．1 使用Spring Boot Admin监控Spring Boot应用程序 199
14．1．1 创建Spring Boot Admin Server 199
14．1．2 创建Spring Boot Admin Client 200
14．2 使用Spring Boot Admin监控Spring Cloud微服务 202
14．2．1 构建Admin Server 202
14．2．2 构建Admin Client 204
14．3 在Spring Boot Admin中添加Security和Mail组件 205
14．3．1 Spring Boot Admin集成Security组件 206
14．3．2 Spring Boot Admin集成Mail组件 208
第 15章 Spring Boot Security详解 209
15．1 Spring Security简介 209
15．1．1 什么是Spring Security 209
15．1．2 为什么选择Spring Security 209
15．1．3 Spring Security提供的安全模块 210
15．2 Spring Boot Security与Spring Security的关系 211
15．3 Spring Boot Security案例详解 211
15．3．1 构建Spring Boot Security工程 211
15．3．2 配置Spring Security 213
15．3．3 编写相关界面 215
15．3．4 Spring Security方法级别上的保护 220
15．3．5 从数据库中读取用户的认证信息 223
15．4 总结 228
第 16章 使用Spring Cloud OAuth2保护微服务系统 230
16．1 什么是OAuth2 230
16．2 如何使用Spring OAuth2 231
16．2．1 OAuth2 Provider 231
16．2．2 OAuth2 Client 235
16．3 案例分析 236
16．3．1 编写Eureka Server 237
16．3．2 编写Uaa授权服务 237
16．3．3 编写service-hi资源服务 244
16．4 总结 250
第 17章 使用Spring Security OAuth2和JWT保护微服务系统 251
17．1 JWT简介 251
17．1．1 什么是JWT 251
17．1．2 JWT的结构 252
17．1．3 JWT的应用场景 253
17．1．4 如何使用JWT 253
17．2 案例分析 253
17．2．1 案例架构设计 253
17．2．2 编写主Maven工程 254
17．2．3 编写Eureka Server 256
17．2．4 编写Uaa授权服务 256
17．2．5 编写user-service资源服务 262
17．3 总结 270
第 18章 使用Spring Cloud构建微服务综合案例 271
18．1 案例介绍 271
18．1．1 工程结构 271
18．1．2 使用的技术栈 271
18．1．3 工程架构 272
18．1．4 功能展示 274
18．2 案例详解 277
18．2．1 准备工作 278
18．2．2 构建主Maven工程 278
18．2．3 构建eureka-server工程 279
18．2．4 构建config-server工程 280
18．2．5 构建Zipkin工程 281
18．2．6 构建monitoring-service工程 282
18．2．7 构建uaa-service工程 284
18．2．8 构建gateway-service工程 286
18．2．9 构建admin-service工程 287
18．2．10 构建user-service工程 287
18．2．11 构建blog-service工程 290
18．2．12 构建log-service工程 291
18．3 启动源码工程 294
18．4 项目演示 295
18．5 总结 296
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Spring Cloud与微服务构建 第2版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>手编大好！3：花片拼接的针织衫
本书中的个性时尚单品
南明奈穿着示范 甜美休闲针织物
今年春夏流行趋势舒适自然的针织衫

经久不衰！人气花片拼接
简单易学！！直线钩织的针织物
快乐的针织家族 时尚无龄差针织衫	温馨舒适家庭装针织衫
帽子·围巾·手提包 春夏外出小物件
用钩针钩织梦幻的手工作品 婚礼·饰品
“织花屋”简单编织法！花朵花样的小物件和衣物
Fukuyoka老师推荐的个性针织衫
编制培训班 花朵花片拼接的套头衫
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>手编大好！3：花片拼接的针织衫
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>疯狂Spring Cloud微服务架构实战
第1章　Spring Cloud概述	1
1.1　传统的应用	2
1.1.1　单体应用	2
1.1.2　架构演进	3
1.1.3　架构要求	4
1.2　微服务与Spring Cloud	5
1.2.1　什么是微服务	5
1.2.2　关于Netflix OSS	6
1.2.3　Spring Cloud与Netflix	6
1.2.4　Spring Cloud的主要模块	6
1.3　学习方面的准备工作	7
1.3.1　下载本书的软件及源码	7
1.3.2　导入本书的案例	7
1.4　本章小结	8
第2章　搭建开发环境	9
2.1　安装与配置Maven	10
2.1.1　关于Maven	10
2.1.2　下载与安装Maven	11
2.1.3　配置远程仓库	11
2.2　安装Eclipse	12
2.2.1　Eclipse版本	12
2.2.2　在Eclipse中配置Maven	12
2.3　Spring Boot	13
2.3.1　Spring Boot简介	13
2.3.2　新建Maven项目	14
2.3.3　编写启动类	15
2.3.4　编写控制器	16
2.3.5　发布REST WebService	17
2.4　Spring Boot配置文件	18
2.4.1　默认配置文件	18
2.4.2　指定配置文件位置	19
2.4.3　yml文件	19
2.4.4　运行时指定profiles配置	20
2.4.5　热部署	20
2.5　Spring Cloud的版本	21
2.6　本章小结	21
第3章　微服务发布与调用	22
3.1　Eureka介绍	23
3.1.1　关于Eureka	23
3.1.2　Eureka架构	23
3.1.3　服务器端	24
3.1.4　服务提供者	24
3.1.5　服务调用者	24
3.2　第一个Eureka应用	24
3.2.1　构建服务器	24
3.2.2　服务器注册开关	27
3.2.3　编写服务提供者	27
3.2.4　编写服务调用者	29
3.2.5　程序结构	32
3.3　Eureka集群搭建	33
3.3.1　本例集群结构图	33
3.3.2　改造服务器端	34
3.3.3　改造服务提供者	35
3.3.4　改造服务调用者	37
3.3.5　编写REST客户端进行测试	37
3.4　服务实例的健康自检	38
3.4.1　程序结构	39
3.4.2　使用Spring Boot Actuator	39
3.4.3　实现应用健康自检	39
3.4.4　服务查询	42
3.5　Eureka的常用配置	44
3.5.1　心跳检测配置	44
3.5.2　注册表抓取间隔	44
3.5.3　配置与使用元数据	45
3.5.4　自我保护模式	45
3.6　本章小结	46
第4章　负载均衡	47
4.1　Ribbon介绍	48
4.1.1　Ribbon简介	48
4.1.2　Ribbon子模块	48
4.1.3　负载均衡器组件	48
4.2　第一个Ribbon程序	49
4.2.1　编写服务	49
4.2.2　编写请求客户端	51
4.2.3　Ribbon的配置	52
4.3　Ribbon的负载均衡机制	53
4.3.1　负载均衡器	53
4.3.2　自定义负载规则	54
4.3.3　Ribbon自带的负载规则	56
4.3.4　Ping机制	57
4.3.5　自定义Ping	59
4.3.6　其他配置	59
4.4　在Spring Cloud中使用Ribbon	60
4.4.1　准备工作	60
4.4.2　使用代码配置Ribbon	61
4.4.3　使用配置文件设置Ribbon	63
4.4.4　Spring使用Ribbon的API	64
4.5　RestTemplate负载均衡	66
4.5.1　@LoadBalanced注解概述	66
4.5.2　编写自定义注解以及拦截器	66
4.5.3　使用自定义拦截器以及注解	68
4.5.4　在控制器中使用RestTemplate	69
4.6　本章小结	71
第5章　REST客户端Feign	72
5.1　REST客户端	73
5.1.1　使用CXF调用REST服务	73
5.1.2　使用Restlet调用REST服务	74
5.1.3　Feign框架介绍	75
5.1.4　第一个Feign程序	76
5.1.5　请求参数与返回对象	77
5.2　使用Feign	78
5.2.1　编码器	79
5.2.2　解码器	80
5.2.3　XML的编码与解码	80
5.2.4　自定义编码器与解码器	83
5.2.5　自定义Feign客户端	83
5.2.6　使用第三方注解	85
5.2.7　Feign解析第三方注解	86
5.2.8　请求拦截器	89
5.2.9　接口日志	89
5.3　在Spring Cloud中使用Feign	90
5.3.1　Spring Cloud整合Feign	91
5.3.2　Feign负载均衡	93
5.3.3　默认配置	93
5.3.4　自定义配置	94
5.3.5　可选配置	97
5.3.6　压缩配置	98
5.4　本章小结	98
第6章　Spring Cloud的保护机制	99
6.1　概述	100
6.1.1　实际问题	100
6.1.2　传统的解决方式	101
6.1.3　集群容错框架Hystrix	101
6.1.4　Hystrix的功能	102
6.2　第一个Hystrix程序	103
6.2.1　准备工作	103
6.2.2　客户端使用Hystrix	103
6.2.3　调用错误服务	105
6.2.4　Hystrix的运作流程	106
6.3　Hystrix的使用	108
6.3.1　命令执行	108
6.3.2　属性配置	110
6.3.3　回退	111
6.3.4　回退的模式	112
6.3.5　断路器开启	113
6.3.6　断路器关闭	116
6.3.7　隔离机制	118
6.3.8　合并请求	121
6.3.9　请求缓存	125
6.4　在Spring Cloud中使用Hystrix	127
6.4.1　整合Hystrix	128
6.4.2　命令配置	130
6.4.3　默认配置	131
6.4.4　缓存注解	132
6.4.5　合并请求注解	134
6.4.6　Feign与Hystrix整合	136
6.4.7　Hystrix监控	140
6.5　本章小结	142
第7章　微服务集群网关	143
7.1　Zuul框架介绍	144
7.1.1　关于Zuul	144
7.1.2　Zuul的功能	144
7.2　在Web项目中使用Zuul	145
7.2.1　Web项目整合Zuul	145
7.2.2　测试路由功能	145
7.2.3　过滤器运行机制	147
7.3　在微服务集群中初试Zuul	148
7.3.1　集群搭建	149
7.3.2　路由到集群服务	150
7.3.3　Zuul Http客户端	153
7.4　路由配置	153
7.4.1　简单路由	154
7.4.2　跳转路由	155
7.4.3　Ribbon路由	155
7.4.4　自定义路由规则	156
7.4.5　忽略路由	157
7.5　Zuul的其他配置	157
7.5.1　请求头配置	157
7.5.2　路由端点	158
7.5.3　Zuul与Hystrix	158
7.5.4　在Zuul中预加载Ribbon	161
7.6　Zuul功能进阶	161
7.6.1　过滤器优先级	161
7.6.2　自定义过滤器	162
7.6.3　动态加载过滤器	163
7.6.4　禁用过滤器	165
7.6.5　请求上下文	166
7.6.6　@EnableZuulServer注解	168
7.6.7　error过滤器	169
7.6.8　动态路由	171
7.7　本章小结	172
第8章　微服务与消息驱动	173
8.1　Spring Cloud Stream介绍	174
8.1.1　关于Stream框架	174
8.1.2　Stream框架的组成部分	174
8.1.3　消息代理中间件	174
8.2　RabbitMQ框架	175
8.2.1　RabbitMQ和AMQP	175
8.2.2　下载与运行	176
8.2.3　编写生产者	177
8.2.4　编写消费者	179
8.2.5　交换器、绑定与队列	180
8.3　Apache Kafka框架	181
8.3.1　关于Kafka	181
8.3.2　运行Kafka服务器	182
8.3.3　编写生产者	182
8.3.4　编写消费者	184
8.3.5　消费者组	185
8.4　开发消息微服务	185
8.4.1　准备工作	186
8.4.2　编写生产者	187
8.4.3　编写消费者	188
8.4.4　更换绑定器	189
8.4.5　Sink、Source与Processor	190
8.4.6　消费者组	191
8.5　本章小结	192
第9章　集群配置中心	193
9.1　概述	194
9.1.1　关于Spring Cloud Config	194
9.1.2　应用结构	195
9.1.3　引导程序简介	195
9.1.4　搭建SVN环境	196
9.2　构建第一个例子	196
9.2.1　创建服务器	196
9.2.2　配置SVN仓库	197
9.2.3　创建客户端	199
9.2.4　从客户端读取SVN配置	200
9.2.5　目录配置总结	201
9.2.6　刷新配置	202
9.2.7　刷新Bean	203
9.3　配置的加密和解密	205
9.3.1　为服务器安装JCE	205
9.3.2　加密和解密端点	205
9.3.3　SVN存储加密数据	206
9.3.4　非对称加密	207
9.4　其他配置	207
9.4.1　服务器健康指示器	207
9.4.2　客户端的错误提前与重试机制	208
9.4.3　安全配置	209
9.4.4　访问服务器配置	210
9.5　整合使用	210
9.5.1　准备工作	210
9.5.2　配置服务器、客户端整合Eureka	212
9.5.3　整合Zuul	214
9.5.4　整合Spring Cloud Bus刷新配置	216
9.5.5　刷新单个节点配置	217
9.6　本章小结	217
第10章　微服务跟踪	219
10.1　概述	220
10.1.1　实际问题与Sleuth	220
10.1.2　服务跟踪系统	220
10.1.3　Sleuth的基本概念	220
10.1.4　项目准备	221
10.2　Sleuth整合Zipkin	222
10.2.1　Zipkin简介	222
10.2.2　构建Zipkin服务器项目	223
10.2.3　配置微服务	224
10.2.4　查看数据	225
10.2.5　使用MySQL保存数据	228
10.2.6　使用消息采集数据	230
10.3　Sleuth整合ELK	232
10.3.1　关于ELK	232
10.3.2　下载ELK	233
10.3.3　运行Elasticsearch	233
10.3.4　使用Logstash读取JSON	234
10.3.5　使用Kibana展示数据	235
10.3.6　使用Logback转换JSON	237
10.4　本章小结	240
第11章　微服务数据库实战	241
11.1　概述	242
11.1.1　关于Spring Data	242
11.1.2　Spring Data的功能	243
11.1.3　Spring Data的模块	243
11.2　Spring Data与JPA	243
11.2.1　构建项目	244
11.2.2　数据访问层与业务层	245
11.2.3　自定义数据存储逻辑	247
11.2.4　方法名查询	248
11.2.5　使用@Query注解	249
11.3　Spring Data与MongoDB	250
11.3.1　安装MongoDB	250
11.3.2　配置权限	251
11.3.3　MongoDB的概念	252
11.3.4　构建项目	252
11.3.5　数据访问层与业务层	253
11.3.6　自定义数据存储逻辑	254
11.3.7　方法名查询	256
11.3.8　使用@Query注解	258
11.4　Spring Data与Redis	258
11.4.1　Redis的安装与配置	258
11.4.2　Redis的数据类型	259
11.4.3　使用Jedis	260
11.4.4　构建Spring Data项目	262
11.4.5　数据访问层与业务层	263
11.4.6　自定义数据存储逻辑	265
11.4.7　方法名查询	267
11.5　本章小结	268
第12章　案例实战	269
12.1　概述	270
12.1.1　表现层技术	270
12.1.2　案例概述	270
12.1.3　案例技术选型	270
12.2　Spring Boot与JSP	271
12.2.1　构建项目	271
12.2.2　配置	272
12.2.3　打包部署	273
12.3　模板引擎Thymeleaf	274
12.3.1　关于Thymeleaf	274
12.3.2　Spring Boot整合Thymeleaf	274
12.3.3　加载资源	275
12.3.4　获取请求数据	276
12.3.5　调用Bean方法	276
12.3.6　遍历集合	277
12.3.7　表单提交	277
12.4　图书管理案例	278
12.4.1　运行案例	278
12.4.2　案例模块	279
12.4.3　案例架构	279
12.4.4　数据库	280
12.4.5　用户登录	280
12.4.6　新建图书	284
12.4.7　图书展示	286
12.5　本章小结	287
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>疯狂Spring Cloud微服务架构实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Spring Cloud与微服务构建
第1章　微服务简介 1
1.1　单体架构及其存在的不足 1
1.1.1　单体架构简介 1
1.1.2　单体架构存在的不足 2
1.1.3　单体架构使用服务器集群
及存在的不足 2
1.2　微服务 3
1.2.1　什么是微服务 4
1.2.2　微服务的优势 8
1.3　微服务的不足 9
1.3.1　微服务的复杂度 9
1.3.2　分布式事务 9
1.3.3　服务的划分 11
1.3.4　服务的部署 11
1.4　微服务和SOA的关系 12
1.5　微服务的设计原则 12
第2章　Spring Cloud简介 14
2.1　微服务应该具备的功能 14
2.1.1　服务的注册与发现 15
2.1.2　服务的负载均衡 15
2.1.3　服务的容错 17
2.1.4　服务网关 18
2.1.5　服务配置的统一管理 19
2.1.6　服务链路追踪 20
2.2　Spring Cloud 21
2.2.1　简介 21
2.2.2　常用组件 21
2.2.3　项目一览表 23
2.3　Dubbo简介 24
2.4　Spring Cloud与Dubbo比较 25
2.5　Kubernetes简介 26
2.6　Spring Could与Kubernetes比较 27
2.7　总结 29
第3章　构建微服务的准备 30
3.1　JDK的安装 30
3.1.1　JDK的下载和安装 30
3.1.2　环境变量的配置 30
3.2　IDEA的安装 31
3.2.1　IDEA的下载 31
3.2.2　用IDEA创建一个Spring Boot
工程 32
3.2.3　用IDEA启动多个Spring Boot
工程实例 34
3.3　构建工具Maven的使用 35
3.3.1　Maven简介 35
3.3.2　Maven的安装 35
3.3.3　Maven的核心概念 37
3.3.4　编写Pom文件 37
3.3.5　Maven构建项目的生命周期 39
3.3.6　常用的Maven命令 40
第4章　开发框架Spring Boot 43
4.1　Spring Boot简介 43
4.1.1　Spring Boot的特点 43
4.1.2　Spring Boot的优点 44
4.2　用IDEA构建Spring Boot工程 44
4.2.1　项目结构 44
4.2.2　在Spring Boot工程中构建
Web 45
4.2.3　Spring Boot的测试 46
4.3　Spring Boot配置文件详解 46
4.3.1　自定义属性 47
4.3.2　将配置文件的属性赋给
实体类 47
4.3.3　自定义配置文件 49
4.3.4　多个环境的配置文件 50
4.4　运行状态监控Actuator 50
4.4.1　查看运行程序的健康状态 52
4.4.2　查看运行程序的Bean 53
4.4.3　使用Actuator关闭应用程序 55
4.4.4　使用shell连接Actuator 56
4.5　Spring Boot整合JPA 57
4.6　Spring Boot整合Redis 60
4.6.1　Redis简介 60
4.6.2　Redis的安装 60
4.6.3　在Spring Boot中使用Redis 60
4.7　Spring Boot整合Swagger2，搭建
Restful API在线文档 62
第5章　服务注册和发现Eureka 66
5.1　Eureka简介 66
5.1.1　什么是Eureka 66
5.1.2　为什么选择Eureka 66
5.1.3　Eureka的基本架构 67
5.2　编写Eureka Server 67
5.3　编写Eureka Client 70
5.4　源码解析Eureka 73
5.4.1　Eureka的一些概念 73
5.4.2　Eureka的高可用架构 74
5.4.3　Register服务注册 74
5.4.4　Renew服务续约 78
5.4.5　为什么Eureka Client获取
服务实例这么慢 80
5.4.6　Eureka 的自我保护模式 80
5.5　构建高可用的Eureka Server集群 81
5.6　总结 83
第6章　负载均衡Ribbon 84
6.1　RestTemplate简介 84
6.2　Ribbon简介 85
6.3　使用RestTemplate和Ribbon来消费
服务 85
6.4　LoadBalancerClient简介 88
6.5　源码解析Ribbon 90
第7章　声明式调用Feign 101
7.1　写一个Feign客户端 101
7.2　FeignClient详解 105
7.3　FeignClient的配置 106
7.4　从源码的角度讲解Feign的工作
原理 107
7.5　在Feign中使用HttpClient和
OkHttp 110
7.6　Feign是如何实现负载均衡的 112
7.7　总结 114
第8章　熔断器Hystrix 115
8.1　什么是Hystrix 115
8.2　Hystrix解决了什么问题 115
8.3　Hystrix的设计原则 117
8.4　Hystrix的工作机制 117
8.5　在RestTemplate和Ribbon上使用
熔断器 118
8.6　在Feign上使用熔断器 119
8.7　使用Hystrix Dashboard监控熔断器的
状态 120
8.7.1　在RestTemplate中使用Hystrix Dashboard 120
8.7.2　在Feign中使用
Hystrix Dashboard 123
8.8　使用Turbine聚合监控 124
第9章　路由网关Spring Cloud Zuul 126
9.1　为什么需要Zuul 126
9.2　Zuul的工作原理 126
9.3　案例实战 128
9.3.1　搭建Zuul服务 128
9.3.2　在Zuul上配置API接口的
版本号 131
9.3.3　在Zuul上配置熔断器 132
9.3.4　在Zuul中使用过滤器 133
9.3.5　Zuul的常见使用方式 135
第10章　配置中心
Spring Cloud Config 137
10.1　Config Server从本地读取配置
文件 137
10.1.1　构建Config Server 137
10.1.2　构建Config Client 138
10.2　Config Server从远程Git仓库读取
配置文件 140
10.3　构建高可用的Config Server 141
10.3.1　构建Eureka Server 141
10.3.2　改造Config Server 142
10.3.3　改造Config Client 143
10.4 使用Spring Cloud Bus刷新配置 144
第11章　服务链路追踪
Spring Cloud Sleuth 147
11.1　为什么需要Spring Cloud Sleuth 147
11.2　基本术语 147
11.3　案例讲解 148
11.3.1　构建Zipkin Server 148
11.3.2　构建User Service 149
11.3.3　构建Gateway Service 151
11.3.4　项目演示 152
11.4　在链路数据中添加自定义数据 153
11.5　使用RabbitMQ 传输链路数据 154
11.6　在MySQL数据库中存储链路数据 155
11.6.1　使用Http传输链路数据，
并存储在MySQL数据
库中 156
11.6.2　使用RabbitMQ传输链路
数据，并存储在MySQL
数据库中 157
11.7　在ElasticSearch中存储链路数据 158
11.8　用Kibana展示链路数据 159
第12章　微服务监控
Spring Boot Admin 161
12.1　使用Spring Boot Admin监控Spring Cloud微服务 161
12.1.1　构建Admin Server 161
12.1.2　构建Admin Client 163
12.2　在Spring Boot Admin中集成Turbine 166
12.2.1　改造Eureka Client 166
12.2.2　另行构建Eureka Client 167
12.2.3　构建Turbine工程 168
12.2.4　在Admin Server中集成
Turbine 169
12.3　在Spring Boot Admin中添加安全
登录界面 172
第13章　Spring Boot Security详解 174
13.1　Spring Security简介 174
13.1.1　什么是Spring Security 174
13.1.2　为什么选择Spring Security 174
13.1.3　Spring Security提供的安全
模块 175
13.2　Spring Boot Security与Spring Security
的关系 176
13.3　Spring Boot Security案例详解 176
13.3.1　构建Spring Boot Security
工程 176
13.3.2　配置Spring Security 178
13.3.3　编写相关界面 180
13.3.4　Spring Security方法级别上
的保护 185
13.3.5　从数据库中读取用户的
认证信息 188
13.4　总结 193
第14章　使用Spring Cloud OAuth2
保护微服务系统 195
14.1　什么是OAuth2 195
14.2　如何使用Spring OAuth2 196
14.2.1　OAuth2 Provider 196
14.2.2　OAuth2 Client 200
14.3　案例分析 201
14.3.1　编写Eureka Server 202
14.3.2　编写Uaa授权服务 202
14.3.3　编写service-hi资源服务 209
14.4　总结 215
第15章　使用Spring Security OAuth2
和JWT保护微服务系统 217
15.1　JWT简介 217
15.1.1　什么是JWT 217
15.1.2　JWT的结构 218
15.1.3　JWT的应用场景 219
15.1.4　如何使用JWT 219
15.2　案例分析 219
15.2.1　案例架构设计 219
15.2.2　编写主Maven工程 220
15.2.3　编写Eureka Server 221
15.2.4　编写Uaa授权服务 222
15.2.5　编写user-service资源服务 227
15.3 总结 236
第16章　使用Spring Cloud构建微
服务综合案例 237
16.1　案例介绍 237
16.1.1　工程结构 237
16.1.2　使用的技术栈 238
16.1.3　工程架构 238
16.1.4　功能展示 240
16.2　案例详解 244
16.2.1　准备工作 244
16.2.2　构建主Maven工程 244
16.2.3　构建eureka-server工程 245
16.2.4　构建config-server工程 246
16.2.5　构建zipkin-service工程 247
16.2.6　构建monitoring-service
工程 248
16.2.7　构建uaa-service工程 250
16.2.8　构建gateway-service工程 251
16.2.9　构建admin-service工程 253
16.2.10　构建user-service工程 253
16.2.11　构建blog-service工程 256
16.2.12　构建log-service工程 256
16.3　启动源码工程 260
16.4　项目演示 261
16.5　总结 262
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Spring Cloud与微服务构建
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud 微服务架构开发实战
内容简介
前言
第1章 微服务概述
1.1 传统软件行业面临的挑战
1.2 常见分布式系统架构
1.3 单块架构如何进化为微服务架构
1.4 微服务架构的设计原则
1.5 如何来设计微服务系统
第2章 微服务的基石——Spring Boot
2.1 Spring Boot 简介
2.2 开启第一个 Spring Boot 项目
2.3 Hello World
2.4 如何搭建开发环境
2.5 Gradle 与 Maven 的抉择
第3章 Spring Boot 的高级主题
3.1 构建 RESTful 服务
3.2 Spring Boot 的配置详解
3.3 内嵌 Servlet 容器
3.4 实现安全机制
3.5 允许跨域访问
3.6 消息通信
3.7 数据持久化
3.8 实现热插拔（hot swapping）
第4章 微服务的测试
4.1 测试概述
4.2 测试的类型和范围
4.3 如何进行微服务的测试
第5章 微服务的协调者——Spring Cloud
5.1 Spring Cloud 简介
5.2 Spring Cloud 入门配置
5.3 Spring Cloud 的子项目介绍
第6章 服务拆分与业务建模
6.1 从一个天气预报系统讲起
6.2 使用Redis提升应用的并发访问能力
6.3 实现天气数据的同步
6.4 给天气预报一个“面子”
6.5 如何进行微服务的拆分
6.6 领域驱动设计与业务建模
第7章 天气预报系统的微服务架构设计与实现
7.1 天气预报系统的架构设计
7.2 天气数据采集微服务的实现
7.3 天气数据API微服务的实现
7.4 天气预报微服务的实现
7.5 城市数据API微服务的实现
第8章 微服务的注册与发现
8.1 服务发现的意义
8.2 如何集成 Eureka Server
8.3 如何集成 Eureka Client
8.4 实现服务的注册与发现
第9章 微服务的消费
9.1 微服务的消费模式
9.2 常见微服务的消费者
9.3 使用 Feign 实现服务的消费者
9.4 实现服务的负载均衡及高可用
第10章 API 网关
10.1 API 网关的意义
10.2 常见 API 网关的实现方式
10.3 如何集成Zuul
10.4 实现 API 网关
第11章 微服务的部署与发布
11.1 部署微服务将面临的挑战
11.2 持续交付与持续部署微服务
11.3 基于容器的部署与发布微服务
11.4 使用 Docker 来构建、运行、发布微服务
第12章 微服务的日志与监控
12.1 微服务日志管理将面临的挑战
12.2 日志集中化的意义
12.3 常见日志集中化的实现方式
12.4 Elastic Stack 实现日志集中化
第13章 微服务的集中化配置
13.1 为什么需要集中化配置
13.2 使用 Config 实现的配置中心
第14章 微服务的高级主题——自动扩展
14.1 什么是自动扩展
14.2 自动扩展的意义
14.3 自动扩展的常见模式
14.4 如何实现微服务的自动扩展
第15章 微服务的高级主题——熔断机制
15.1 什么是服务的熔断机制
15.2 熔断的意义
15.3 熔断与降级的区别
15.4 如何集成 Hystrix
15.5 实现微服务的熔断机制
第16章 微服务的高级主题——分布式消息总线
16.1 什么是消息总线
16.2 Spring Cloud Bus 设计原理
16.3 如何集成 Bus
16.4 实现配置信息的自动更新
附录A：本书所涉及到的技术及相关版本
参考资料
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud 微服务架构开发实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂靜的春天［典藏版］
〔導言〕最靈敏的耳朵——關於《寂靜的春天》／吳明益
〔導言〕台灣的寂靜之春／陳佳珣
［作者序］致謝／瑞秋‧卡森
［編輯序］寫在書前
第一章 明日寓言
第二章 忍耐的義務
第三章 致命的萬靈丹
第四章 地球的水
第五章 土壤的國度
第六章 地球的綠衣
第七章 無謂的破壞
第八章 不再有鳥兒歌唱
第九章 死河
第十章 禍從天降
第十一章 如影隨形的惡夢
第十二章 人的價格
第十三章 一扇窄窗
第十四章 四分之一
第十五章 大自然的反撲
第十六章 大災難的徵兆
第十七章 另一條路
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂靜的春天［典藏版］
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
第一章 明日寓言
第二章 忍耐的义务
第三章 死神的特效药
第四章 地表水和地下水
第五章 土壤的王国
第六章 地球的绿色斗篷
第七章 无妄之灾
第八章 鸟儿歌声的消失
第九章 死亡之河
第十章 祸从天降
第十一章 无法想象的后果
第十二章 人类的代价
第十三章 小窗之外看世界
第十四章 四分之一的概率
第十五章 大自然的反击
第十六章 雪崩轰鸣
第十七章 另一条路
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot 开发实战
前　言
第Ⅰ部分　Spring Boot框架基础
第1章　Spring Boot简介 2
1.1　从Spring到Spring Boot 2
1.1.1　从EJB到Spring 3
1.1.2　Spring框架发展简史 4
1.1.3　Spring框架的核心模块 5
1.2　Spring Boot简介 7
1.2.1　Spring Boot是什么 7
1.2.2　Spring Boot核心模块 10
1.3　约定优于配置极简化理念 11
1.4　本章小结 12
第2章　快速开始HelloWorld 13
2.1　创建Spring Boot项目 13
2.2　Spring Boot项目的入口类 16
2.3　添加HelloWorldController 18
2.4　Spring Boot应用注解@Spring BootApplication 19
2.4.1　Spring Boot配置类注解 20
2.4.2　启用自动配置注解 21
2.4.3　组件扫描注解 21
2.5　XML配置与注解配置 22
2.6　本章小结 22
第3章　深入理解Spring Boot自动配置 23
3.1　传统的SSM开发过程 23
3.2　Spring Boot自动配置原理 26
3.2.1　Java配置 26
3.2.2　条件化Bean 27
3.2.3　组合注解 32
3.3　Spring Boot自动配置过程 33
3.3.1　@EnableAutoConfiguration注解 33
3.3.2　spring.factories文件 34
3.3.3　获取候选配置类 35
3.4　FreeMarkerAutoConfiguration实例分析 35
3.4.1　spring-boot-starter-freemarker工程 35
3.4.2　spring-boot-autoconfigure工程 37
3.5　本章小结 39
第Ⅱ部分　Spring Boot项目综合实战
第4章　Spring Boot集成MyBatis数据库层开发 42
4.1　Java EE分层架构 42
4.2　MyBatis简介 43
4.2.1　概述 43
4.2.2　MyBatis框架组成 44
4.2.3　MyBatis基础设施 46
4.3　项目实战 54
4.3.1　使用Spring Boot CLI创建工程 54
4.3.2　Spring Boot命令行CLI简介 54
4.3.3　配置application.properties 58
4.3.4　使用IDEA中自带的连接数据库客户端 59
4.3.5　使用MyBatis Generator生成dao层代码 60
4.3.6　设置MyBatis同时使用Mapper.xml和注解 62
4.3.7　使用@Select注解 62
4.3.8　使用MyBatis分页插件pagehelper 63
4.3.9　MyBatis插件机制 64
4.3.10　实现分页接口 64
4.3.11　PageHelper工作原理 67
4.3.12　多表关联查询级联 74
4.4　本章小结 78
第5章　Spring Boot集成JPA数据库层开发 79
5.1　JPA简介 79
5.1.1　JPA生态 81
5.1.2　JPA技术栈 82
5.2　ORM框架概述 83
5.3　Hibernate简介 83
5.4　Spring Data JPA简介 88
5.5　项目实战 90
5.5.1　Spring Data JPA提供的接口 90
5.5.2　创建项目 91
5.5.3　配置数据库连接 91
5.5.4　自动生成Entity实体类代码 91
5.5.5　配置项目数据源信息 95
5.5.6　实现查询接口 96
5.5.7　分页查询 97
5.5.8　多表级联查询 99
5.5.9　级联类型 101
5.5.10　模糊搜索接口 102
5.5.11　JPQL语法基础 103
5.5.12　JPA常用注解 108
5.6　本章小结 109
第6章　Spring Boot Gradle插件应用开发 110
6.1　Gradle简介 110
6.2　用Gradle构建生命周期 112
6.3　Gradle 插件 114
6.4　项目实战 118
6.4.1　创建项目 118
6.4.2　添加依赖 121
6.4.3　配置上传本地Maven仓库 121
6.4.4　实现插件 122
6.4.5　添加插件属性配置 124
6.4.6　运行测试 124
6.4.7　在项目中使用kor插件 126
6.5　本章小结 128
第7章　使用Spring MVC开发Web应用 129
7.1　Spring MVC简介 129
7.1.1　Servlet概述 129
7.1.2　MVC简介 131
7.1.3　Spring、Spring MVC与Spring Boot 2.0 132
7.1.4　Spring MVC框架 133
7.2　Spring MVC常用注解 136
7.3　项目实战：使用FreeMarker模板引擎 137
7.3.1　FreeMarker简介 137
7.3.2　实现一个分页查询页面 138
7.4　实现文件下载 144
7.5　本章小结 145
第8章　Spring Boot自定义Web MVC配置 146
8.1　Web MVC配置简介 146
8.1.1　静态资源配置 147
8.1.2　拦截器配置 148
8.1.3　跨域配置 148
8.1.4　视图控制器配置 149
8.1.5　消息转换器配置 150
8.1.6　数据格式化器配置 150
8.1.7　视图解析器配置 151
8.2　全局异常处理 152
8.2.1　使用@ControllerAdvice和@ExceptionHandler注解 152
8.2.2　实现HandlerExceptionResolver接口 154
8.3　定制Web容器 157
8.4　定制Spring Boot应用程序启动Banner 158
8.5　自定义注册Servlet、Filter和Listener 161
8.5.1　注册Servlet 161
8.5.2　注册Filter 163
8.5.3　注册Listener 168
8.6　本章小结 169
第9章　Spring Boot中的AOP编程 170
9.1　Spring Boot与AOP 170
9.1.1　AOP简介 170
9.1.2　Spring AOP介绍 172
9.1.3　实现一个简单的日志切面 172
9.2　项目实战：使用AOP + Filter实现登录鉴权与权限控制 175
9.2.1　系统整体架构 175
9.2.2　创建工程 176
9.2.3　数据库表结构设计 177
9.2.4　用户登录逻辑 179
9.2.5　登录态鉴权过滤器 181
9.2.6　AOP实现用户权限管理 185
9.2.7　用户注册 187
9.2.8　数据后端校验 188
9.3　本章小结 192
第10章　Spring Boot集成Spring Security安全开发 193
10.1　Spring Security简介 193
10.2　Spring Security核心组件 194
10.3　项目实战 201
10.3.1　初阶Security：默认认证用户名密码 201
10.3.2　中阶Security：内存用户名密码认证 204
10.3.3　角色权限控制 206
10.3.4　进阶Security：基于数据库的用户和角色权限 211
10.4　本章小结 225
第11章　Spring Boot集成React.js开发前后端分离项目 226
11.1　Web前端技术简史 226
11.2　前后端分离架构 228
11.3　项目实战 229
11.3.1　系统功能介绍 229
11.3.2　实现登录后端接口 230
11.3.3　实现登录前端页面 231
11.3.4　实现列表展示后端接口 232
11.3.5　前后端联调测试 233
11.4　本章小结 235
第12章　任务调度与邮件服务开发 236
12.1　定时任务 236
12.1.1　通用实现方法 236
12.1.2　静态定时任务 237
12.1.3　Cron简介 238
12.1.4　动态定时任务 240
12.1.5　多线程执行任务 243
12.2　开发任务调度服务 245
12.2.1　同步与异步 245
12.2.2　同步任务执行 245
12.2.3　异步任务执行 247
12.3　开发邮件服务 250
12.3.1　发送富文本邮件 252
12.3.2　发送带附件的富文本邮件 253
12.4　本章小结 254
第13章　Spring Boot集成WebFlux开发响应式Web应用 255
13.1　响应式宣言及架构 255
13.2　项目实战 256
13.2.1　创建项目 256
13.2.2　代码分析 258
13.3　本章小结 262
第14章　Spring Boot缓存 263
14.1　Spring Cache简介 263
14.2　Cache注解 264
14.3　项目实战 266
14.4　本章小结 272
第15章　使用Spring Session集成Redis实现Session共享 273
15.1　Spring Session简介 273
15.2　Redis简介 275
15.2.1　Redis是什么 275
15.2.2　安装Redis 275
15.2.3　设置Redis密码 276
15.2.4　Redis数据类型 277
15.2.5　Spring Boot集成Redis 279
15.3　项目实战 281
15.4　本章小结 285
第16章　使用Zuul开发API Gateway 286
16.1　API Gateway简介 286
16.2　Zuul简介 287
16.3　项目实战 290
16.4　本章小结 294
第17章　Spring Boot日志 295
17.1　Logback简介 295
17.2　配置logback日志 296
17.3　logback.groovy配置文件 298
17.3.1　显示系统Log级别 298
17.3.2　使用logback.groovy配置 299
17.3.3　配置文件说明 301
17.4　本章小结 306
第Ⅲ部分　Spring Boot系统监控、测试与运维
第18章　Spring Boot应用的监控：Actuator与Admin 308
18.1　Actuator简介 308
18.2　启用Actuator 309
18.3　揭秘端点 311
18.3.1　常用的Actuator端点 311
18.3.2　启用和禁用端点 317
18.4　自定义Actuator端点 318
18.4.1　Endpoint接口 319
18.4.2　实现Endpoint接口 320
18.4.3　继承AbstractEndpoint抽象类 321
18.4.4　实现健康指标接口HealthIndicator 323
18.4.5　实现度量指标接口PublicMetrics 324
18.4.6　统计方法执行数据 328
18.5　使用Admin 331
18.5.1　Admin简介 331
18.5.2　创建Admin Server项目 334
18.5.3　在客户端使用Admin Server 335
18.6　本章小结 339
第19章　Spring Boot应用的测试 340
19.1　准备工作 340
19.2　分层测试 340
19.2.1　dao层测试 341
19.2.2　service层测试 342
19.2.3　使用Mockito测试service层代码 342
19.2.4　controller层测试 344
19.2.5　JSON接口测试 346
19.3　本章小结 347
第20章　Spring Boot应用Docker化 348
20.1　Spring Boot应用打包 348
20.2　Spring Boot应用运维 352
20.2.1　查看JVM参数的值 352
20.2.2　应用重启 353
20.3　使用Docker构建部署运行Spring Boot应用 353
20.3.1　Docker简介 354
20.3.2　环境搭建 355
20.4　项目实战 356
20.4.1　添加Docker构建插件 356
20.4.2　配置Dockerfile文件创建自定义的镜像 357
20.4.3　Dockerfile配置说明 358
20.4.4　构建镜像 362
20.4.5　运行测试 363
20.5　本章小结 364
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot 开发实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
寂静的春天
第一章 明天的寓言
第二章 忍耐的义务
第三章 死神的万能药
第四章 地表水及地下海
第五章 土壤王国
第六章 地球的绿斗篷
第七章 不必要的破坏
第八章 鸟类的歌声消失
第九章 死亡之河
第十章 无处可逃的天灾
第十一章 超出波吉亚家族的想象
第十二章 人类的代价
第十三章 透过一扇小窗户
第十四章 四个中就有一个
第十五章 大自然的反抗
第十六章 雪崩的轰鸣
第十七章 另一条路
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
第一章 明天的寓言
第二章 忍耐的义务
第三章 死神的催命符
第四章 地表水和地下海
第五章 土壤的王国
第六章 地球的绿色斗篷
第七章 浩 劫
第八章 再也听不到鸟儿歌唱
第九章 死亡之河
第十章 死亡之雨
第十一章 超越波吉亚家族的幻想
第十二章 人类的代价
第十三章 透过一扇狭小的窗户
第十四章 每四个中有一个
第十五章 大自然的反击
第十六章 崩溃声隆隆
第十七章 另一条出路
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>极简Spring Cloud实战
序
前言
第一篇　基础服务篇
第1章　微服务与Spring Cloud2
1.1　架构演进2
1.1.1　服务端架构发展2
1.1.2　微服务架构4
1.2　Spring Cloud面面观7
1.2.1　Spring Cloud与Dubbo对比7
1.2.2　Spring Cloud好在哪里9
1.2.3　Spring Cloud子项目与解决方案10
1.3　小结15
第2章　服务发现：Eureka16
2.1　使用Eureka17
2.1.1　Eureka服务提供方18
2.1.2　Eureka服务调用方19
2.2　进阶场景20
2.3　小结24
第3章　配置中心：Config25
3.1　Spring Cloud Config的组成25
3.2　使用Config Server配置服务端26
3.3　使用Config Client配置客户端29
3.4　进阶场景31
3.4.1　热生效31
3.4.2　高可用32
3.4.3　安全与加解密34
3.4.4　自定义格式文件支持36
3.5　其他仓库的实现配置37
3.6　小结39
第4章　客户端负载均衡：Ribbon40
4.1　使用Ribbon40
4.2　进阶场景42
4.2.1　使用配置类42
4.2.2　使用配置文件42
4.2.3　默认实现43
4.3　小结44
第5章　RESTful客户端：Feign45
5.1　使用Feign45
5.2　进阶场景46
5.2.1　配置与默认实现46
5.2.2　Feign整合Hystrix47
5.2.3　数据压缩48
5.2.4　日志48
5.3　小结49
第6章　熔断器：Hystrix50
6.1　为什么要有熔断50
6.2　熔断原理52
6.3　使用Hystrix55
6.4　Hystrix数据监控58
6.4.1　健康指示器58
6.4.2　监控面板59
6.4.3　聚合监控61
6.5　小结62
第7章　路由网关：Zuul63
7.1　使用Zuul64
7.2　业务场景深入解析65
7.3　小结71
第8章　网关新选择：Gateway72
8.1　使用Gateway73
8.2　路由断言76
8.3　过滤器81
8.4　小结88
第9章　调用链追踪：Spring Cloud Sleuth89
9.1　术语解释90
9.2　Zipkin简介91
9.3　使用Zipkin93
9.4　Span进阶场景97
9.4.1　自定义日志采样策略97
9.4.2　Span的生命周期98
9.4.3　重命名Span99
9.4.4　自定义Span100
9.5　其他场景与配置101
9.6　小结104
第10章　加密管理：Vault105
10.1　初识HashiCorp Vault105
10.2　整合Spring Cloud Vault111
10.3　认证模式114
10.4　三方组件支持116
10.5　小结118
第11章　公共子项目119
11.1　命令行工具：Spring Boot CLI119
11.1.1　安装Spring Boot CLI119
11.1.2　使用Spring Cloud CLI120
11.1.3　加解密122
11.2　注册中心：Spring Cloud ZooKeeper122
11.2.1　安装ZooKeeper122
11.2.2　基于ZooKeeper服务发现122
11.2.3　相关配置124
11.2.4　节点监听126
11.3　注册中心：Spring Cloud Consul127
11.3.1　安装Consul127
11.3.2　基于Consul注册服务127
11.4　小结128
第二篇　任务与消息篇
第12章　消息驱动：Spring Cloud Stream130
12.1　Stream应用模型130
12.2　示例131
12.3　代码解析133
12.4　Spring Integration支持137
12.5　Binder解析138
12.6　常用配置141
12.7　小结142
第13章　消息总线：Spring Cloud Bus143
13.1　使用Spring Cloud Bus144
13.2　进阶场景144
13.3　小结148
第14章　批处理：Spring Cloud Task149
14.1　使用Spring Cloud Task149
14.2　进阶场景150
14.2.1　数据库集成150
14.2.2　任务事件监听152
14.2.3　相关配置项153
12.4.4　整合Spring Cloud Stream154
14.3　源码解析154
14.4　小结156
第三篇　微服务实战篇
第15章　利用Docker进行编排与整合158
15.1　Docker基础应用158
15.1.1　Docker基础158
15.1.2　Dockerfile基础159
15.2　Spring Cloud核心组件整合161
15.3　Dockerfile编写186
15.4　启动与接口测试188
15.5　小结190
后记191
附录　配置汇总192
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>极简Spring Cloud实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot 2实战之旅
目录
第1章 Spring Boot概述  1
1.1 Spring Boot简介  1
1.2 Spring Boot的特点  2
1.2.1 快速构建项目  2
1.2.2 嵌入式Web容器  3
1.2.3 易于构建任何应用  3
1.2.4 自动化配置  3
1.2.5 开发者工具  4
1.2.6 强大的应用监控  4
1.2.7 默认提供测试框架  4
1.2.8 可执行Jar部署  4
1.2.9 IDE多样性  4
1.3 为什么要学习Spring Boot  5
1.3.1 简化工作  5
1.3.2 微服务时代  5
1.3.3 社区背景强大  6
1.3.4 市场需求  6
1.4 Spring Boot的发展历史  7
1.4.1 发布里程碑（2013.8.6）  7
1.4.2 Spring Boot 1.0（2014.4）  7
1.4.3 Spring Boot 1.1（2014.6）  8
1.4.4 Spring Boot 1.2（2015.3）  8
1.4.5 Spring Boot 1.3（2016.12）  8
1.4.6 Spring Boot 1.4（2017.1）  8
1.4.7 Spring Boot 1.5（2017.2）  9
1.4.8 Spring Boot 2.0（2018.3）  9
1.5 小结  10
第2章 走进Spring Boot  11
2.1 环境搭建  11
2.1.1 JDK安装  11
2.1.2 IntelliJ IDEA的安装  12
2.1.3 Maven的安装  12
2.1.4 IntelliJ IDEA内配置JDK和Maven  15
2.2 新建Spring Boot项目  16
2.2.1 开始创建项目  16
2.2.2 配置JDK版本和Initializr Service URL  17
2.2.3 配置Project Metadata信息  17
2.2.4 配置Spring Boot版本及默认引入组件  18
2.2.5 配置项目名称和项目位置  18
2.3 项目工程介绍  19
2.3.1 Java类文件  20
2.3.2 资源文件  20
2.3.3 测试类文件  20
2.3.4 pom文件  21
2.4 运行项目  22
2.5 小结  22
第3章 Spring Boot的Web之旅  23
3.1 Spring Boot的第一个Web项目  23
3.1.1 加入Web依赖  23
3.1.2 创建Controller  23
3.1.3 测试运行  24
3.2 WebFlux的使用  25
3.2.1 添加WebFlux依赖  25
3.2.2 创建一个处理方法类  26
3.2.3 创建一个Router类  26
3.2.4 测试运行  27
3.3 使用热部署  27
3.4 配置文件  28
3.4.1 配置文件类型  28
3.4.2 自定义属性  28
3.4.3 使用随机数  29
3.4.4 多环境配置  31
3.4.5 自定义配置文件  31
3.5 使用页面模板  32
3.5.1 使用Thymeleaf  32
3.5.2 使用FreeMarker  35
3.5.3 使用传统JSP  37
3.6 使用WebJars  39
3.7 国际化使用  41
3.8 文件的上传和下载  44
3.9 小结  48
第4章 Spring Boot的数据库之旅  49
4.1 使用数据库  49
4.1.1 使用MySQL数据库  49
4.1.2 使用SQL Server数据库  50
4.1.3 使用Oracle数据库  51
4.1.4 使用MongoDB数据库  55
4.1.5 使用Neo4j数据库  56
4.1.6 使用Redis数据库  57
4.1.7 使用Memcached数据库  58
4.2 使用JDBC操作数据库  58
4.2.1 JDBC依赖配置  59
4.2.2 配置数据库信息  59
4.2.3 创建实体类  60
4.2.4 使用Controller进行测试  60
4.3 使用JPA操作数据库  68
4.3.1 JPA介绍  68
4.3.2 JPA依赖配置  68
4.3.3 配置文件  69
4.3.4 创建实体对象  69
4.3.5 创建数据操作层  71
4.3.6 简单测试运行  73
4.3.7 JPA扩展学习  74
4.3.8 基于WebFlux的使用  75
4.4 使用MyBatis操作数据库  80
4.4.1 MyBatis简介  80
4.4.2 MyBatis依赖配置  80
4.4.3 配置文件  80
4.4.4 基于XML的使用  82
4.4.5 基于注解使用  85
4.4.6 测试运行  85
4.4.7 Mybatis-Generator插件学习  87
4.4.8 PageHelper插件  96
4.4.9 Mybatis-Plus插件  97
4.5 配置多数据源  101
4.5.1 多数据源情况分析  102
4.5.2 配置多数据源  102
4.5.3 基于JPA使用多数据源  105
4.5.4 基于MyBatis使用多数据  106
4.6 使用Druid数据库连接池  108
4.6.1 Druid简介  108
4.6.2 配置Druid  109
4.6.3 操作数据库  114
4.6.4 Druid监控页面介绍  115
4.7 小结  121
第5章 Spring Boot的缓存之旅  122
5.1 使用Spring Cache  122
5.1.1 Spring Cache简介  122
5.1.2 配置Spring Cache依赖  124
5.1.3 测试运行  125
5.1.4 验证缓存  126
5.2 使用Redis  127
5.2.1 Redis简介  127
5.2.2 项目配置  127
5.2.3 测试运行  129
5.2.4 使用Redis缓存  130
5.3 使用Memcached  132
5.3.1 Memcached简介  132
5.3.2 配置Memcached依赖  132
5.3.3 使用Memcached缓存  137
5.3.4 Redis与Memcached的区别  138
5.4 小结  138
第6章 Spring Boot的日志之旅  139
6.1 Logback日志  139
6.1.1 Logback简介  139
6.1.2 日志格式  140
6.1.3 控制台输出  140
6.1.4 日志文件输出  141
6.1.5 日志级别  141
6.1.6 日志配置  142
6.1.7 基于XML配置日志  142
6.2 Log4j日志  145
6.2.1 Log4j简介  146
6.2.2 Spring Boot使用Log4j  146
6.2.3 控制台输出  146
6.2.4 日志文件输出  147
6.3 Log4j 2日志  148
6.3.1 Log4j 2简介  148
6.3.2 Spring Boot使用Log4j 2  150
6.3.3 控制台输出  151
6.3.4 日志文件输出  152
6.3.5 异步日志  152
6.4 ELK日志收集  155
6.4.1 ELK日志收集流程介绍  155
6.4.2 ELK安装  155
6.4.3 ELK配置  157
6.4.4 使用Kibana查看日志  159
6.4.5 Spring Boot直接输出到Logstash  162
6.4.6 ELK日志收集优化方案及建议  163
6.5 小结  164
第7章 Spring Boot的安全之旅  165
7.1 使用Shiro安全管理  165
7.1.1 什么是Shiro  165
7.1.2 使用Shiro做权限控制  167
7.2 使用Spring Security  177
7.2.1 Spring Security简介  177
7.2.2 使用Spring Security做权限控制  178
7.3 小结  184
第8章 Spring Boot的监控之旅  185
8.1 使用actuator监控  185
8.1.1 actuator是什么  185
8.1.2 如何使用actuator  185
8.1.3 actuator监控介绍  186
8.1.4 保护HTTP端点  188
8.1.5 健康信息  190
8.1.6 自定义应用程序信息  192
8.1.7 自定义管理端点路径  192
8.2 使用Admin监控  193
8.2.1 什么是Spring Boot Admin  193
8.2.2 设置Spring Boot Admin Server  193
8.2.3 Spring Cloud Eureka  194
8.2.4 Spring Boot Admin Client的使用  197
8.2.5 安全验证  202
8.2.6 JMX-bean管理  203
8.2.7 通知  203
8.3 Prometheus Grafana监控  207
8.3.1 Prometheus的安装  207
8.3.2 Grafana的安装  208
8.3.3 Spring Boot项目使用Prometheus  208
8.3.4 Prometheus配置  210
8.3.5 启动Grafana  211
8.4 小结  213
第9章 Spring Boot的消息之旅  214
9.1 RabbitMQ消息队列  214
9.1.1 RabbitMQ介绍  214
9.1.2 RabbitMQ的几种角色  215
9.1.3 RabbitMQ的几种模式  216
9.1.4 Spring Boot使用RabbitMQ  218
9.2 Kafka消息队列  226
9.2.1 Kafka介绍  226
9.2.2 Spring Boot使用Kafka  228
9.3 RocketMQ消息队列  230
9.3.1 RocketMQ介绍  230
9.3.2 Spring Boot使用RocketMQ  231
9.4 消息队列对比  236
9.5 小结  238
第10章 Spring Boot的搜索之旅  239
10.1 使用Solr  239
10.1.1 Solr简介  239
10.1.2 Spring Boot使用Solr  240
10.2 使用Elasticsearch  246
10.2.1 Elasticsearch简介  246
10.2.2 Spring Boot使用Elasticsearch  246
10.2.3 使用Elasticsearch Repository进行操作  247
10.2.4 使用Elasticsearch Template进行操作  248
10.2.5 非聚合查询  249
10.2.6 聚合查询  251
10.2.7 复杂查询练习  252
10.3 搜索引擎对比  256
10.3.1 技术背景  256
10.3.2 热度比较  258
10.3.3 集群部署  259
10.3.4 数据格式  259
10.3.5 效率  259
10.4 小结  259
第11章 Spring Boot的小彩蛋  260
11.1 修改启动Banner  260
11.1.1 启动Banner介绍  260
11.1.2 启动Banner修改  263
11.2 使用LomBok让编程更简单  264
11.2.1 什么是LomBok  264
11.2.2 IntelliJ IDEA安装Lombok插件  264
11.2.3 如何使用LomBok  265
11.3 邮件发送  266
11.3.1 在Spring Boot中使用邮件发送  266
11.3.2 基础配置信息  267
11.3.3 文本邮件发送  268
11.3.4 网页邮件发送  269
11.3.5 附件邮件发送  270
11.3.6 嵌入静态资源邮件发送  271
11.4 三“器”的使用  272
11.4.1 过滤器  272
11.4.2 拦截器  274
11.4.3 监听器  275
11.4.4 Spring Boot引用三“器”  276
11.4.5 测试  277
11.5 事务使用  278
11.5.1 事务介绍  278
11.5.2 在项目中使用事务  279
11.5.3 Spring事务拓展介绍  280
11.6 统一处理异常  282
11.6.1 异常介绍  282
11.6.2 Java异常分类  282
11.6.3 Spring Boot中统一处理异常  284
11.7 使用AOP  284
11.7.1 AOP介绍  285
11.7.2 Spring Boot使用AOP  285
11.8 使用validator后台校验  288
11.9 使用Swagger构建接口文档  291
11.9.1 什么是Swagger  291
11.9.2 Swagger 2注解介绍  291
11.9.3 Spring Boot使用Swagger  293
11.10 使用ApiDoc构建接口文档  298
11.10.1 如何使用ApiDoc接口文档  298
11.10.2 ApiDoc常用注解  298
11.10.3 Spring Boot使用ApiDoc  299
11.11 小结  302
第12章 Spring Boot打包部署  303
12.1 使用IDE启动  303
12.1.1 运行Spring Boot应用程序  303
12.1.2 IntelliJ IDEA启动多实例  304
12.2 使用Maven启动  305
12.3 JAR形式启动  305
12.3.1 使用命令将Spring Boot应用程序打成JAR  305
12.3.2 IntelliJ IDEA打JAR包  306
12.4 War形式启动  307
12.4.1 创建项目  307
12.4.2 打War包部署到Tomcat  308
12.5 使用Docker构建Spring Boot项目  308
12.5.1 Docker简介  309
12.5.2 安装Docker  309
12.5.3 Dockerfile  309
12.5.4 运行Docker镜像  310
12.6 使用Jenkins自动化部署SpringBoot应用  311
12.6.1 Jenkins简介  311
12.6.2 Spring Boot应用使用Jenkins  311
12.7 小结  317
第13章 Spring Boot实战之博客系统  318
13.1 博客的制作思路  318
13.1.1 博客布局介绍  318
13.1.2 博客功能介绍  319
13.2 博客模板制作  320
13.3 效果展示  325
13.4 依赖配置  328
13.5 配置文件  329
13.6 后台实体  330
13.6.1 文章表  330
13.6.2 标签表  332
13.6.3 链接表  333
13.6.4 消息表  333
13.6.5 博客访问记录表  334
13.6.6 博客配置表  335
13.7 主功能  336
13.7.1 博客页  336
13.7.2 搜索页  339
13.7.3 文章详情页  341
13.7.4 联系页  343
13.8 辅助功能  344
13.8.1 拦截器  344
13.8.2 定时器  345
13.8.3 初始化  346
13.9 小结  347
第14章 Spring Boot实战之博客后台系统  350
14.1 博客后台的制作思路  350
14.1.1 博客后台布局介绍  350
14.1.2 博客功能介绍  351
14.2 博客后台模板制作  352
14.3 效果展示  352
14.4 依赖配置  356
14.5 配置文件  358
14.6 后台实体  359
14.6.1 用户表  359
14.6.2 角色表  360
14.7 主功能  361
14.7.1 首页  362
14.7.2 文章管理  363
14.8 辅助功能  368
14.8.1 拦截器  368
14.8.2 定时器  369
14.8.3 认证和授权  370
14.8.4 工具类  373
14.8.5 初始化方法  373
14.9 小结  374
参考文献  375
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot 2实战之旅
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring 5企业级开发实战
目录
第一篇 Spring基础篇
第1章 环境搭建  3
1.1 Spring介绍  3
1.1.1 Spring设计目标  3
1.1.2 Spring各个子模块  3
1.1.3 Spring使用场景  4
1.1.4 Spring与Spring MVC的关系  5
1.1.5 Spring 5高级特性  5
1.2 环境准备  5
1.2.1 安装JDK  5
1.2.2 安装IntelliJ IDEA  6
1.2.3 安装Apache Maven  6
1.2.4 安装Apache Tomcat  7
1.3 快速搭建Spring 5项目  8
1.3.1 使用IntelliJ IDEA创建Spring 5 Spring MVC项目  8
1.3.2 测试部署  9
1.4 小结  9
第2章 Spring IoC容器原理  10
2.1 IoC容器揭秘  10
2.1.1 IoC的概念  10
2.1.2 依赖倒置原则  11
2.1.3 依赖注入  16
2.2 Spring IoC的实现方式  17
2.2.1 XML方式实现  17
2.2.2 通过注解方式实现  20
2.3 Spring IoC实现原理解析  21
2.3.1 BeanFactory代码解析  21
2.3.2 ApplicationContext代码解析  22
2.3.3 BeanDefinition代码解析  23
2.3.4 Spring IoC代码分析  23
2.4 Spring IoC容器中Bean的生命周期  44
2.5 小结  52
第3章 Spring AOP揭秘  53
3.1 AOP前置知识  53
3.1.1 JDK动态代理  53
3.1.2 CGLIB动态代理  56
3.1.3 AOP联盟  58
3.2 AOP概述  58
3.2.1 AOP基本概念  58
3.2.2 Spring AOP相关概念  59
3.3 Spring AOP实现  60
3.3.1 基于JDK动态代理实现  60
3.3.2 基于CGLIB动态代理实现  65
3.4 基于Spring AOP的实战  70
3.4.1 增强类型  70
3.4.2 前置增强  71
3.4.3 后置增强  73
3.4.4 环绕增强  74
3.4.5 异常抛出增强  75
3.4.6 引介增强  75
3.4.7 切入点类型  77
3.5 Spring集成AspectJ实战  78
3.5.1 使用AspectJ方式配置Spring AOP  78
3.5.2 AspectJ各种切点指示器  81
3.5.3 args()与“@args()”  81
3.5.4 @annotation()  87
3.5.5 execution  89
3.5.6 target()与“@target()”  90
3.5.7 this()  92
3.5.8 within()与“@within()”  95
3.6 Spring AOP的实现原理  98
3.6.1 设计原理  99
3.6.2 JdkDynamicAopProxy  106
3.6.3 CglibAopProxy  110
3.7 小结  115
第二篇 Spring 5新特性篇
第4章 Spring 5新特性概述  117
4.1 Spring 5.0新特性  117
4.1.1 运行环境  117
4.1.2 删除的代码  118
4.1.3 核心修改  118
4.1.4 核心容器更新  118
4.1.5 Spring Web MVC更新  118
4.1.6 Spring WebFlux  119
4.1.7 对Kotlin的支持  119
4.1.8 测试改进  120
4.2 Spring 5.1新特性  121
4.2.1 核心修改  121
4.2.2 核心容器更新  121
4.2.3 Web修改  121
4.2.4 Spring Web MVC更新  121
4.2.5 Spring WebFlux更新  122
4.2.6 Spring Messaging更新  122
4.2.7 Spring ORM更新  122
4.2.8 测试更新  122
第5章 Java 8新特性概述  123
5.1 Lambda表达式  123
5.1.1 Lambda表达式初探  123
5.1.2 Lambda表达式作用域  125
5.1.3 在线程中使用Lambda表达式  126
5.1.4 在集合中使用Lambda表达式  127
5.1.5 在Stream中使用Lambda表达式  128
5.2 接口默认方法  129
5.3 小结  132
第6章 Spring WebFlux响应式编程  133
6.1 传统的编程模型  133
6.2 响应式编程模型  134
6.3 Reactor  135
6.3.1 Flux与Mono  135
6.3.2 subscribe()  137
6.3.3 操作符（Operator）  139
6.3.4 线程模型  144
6.4 Spring WebFlux  146
6.4.1 基于注解的WebFlux开发方式  146
6.4.2 基于函数式的WebFlux开发方式  147
6.5 小结  152
第7章 WebClient响应式客户端  153
7.1 RestTemplate调试Spring MVC  153
7.2 WebClient调试Spring WebFlux  156
7.3 小结  158
第8章 Spring 5结合Kotlin编程  159
8.1 Kotlin简介  159
8.1.1 Kotlin的特性  159
8.1.2 Kotlin基本数据类型  161
8.1.3 Kotlin开发环境搭建  161
8.1.4 在Kotlin中定义常量与变量  162
8.1.5 字符串模板  162
8.1.6 NULL检查机制  163
8.1.7 For循环和区间  163
8.1.8 定义函数  166
8.1.9 类和对象  167
8.1.10 Kotlin与Java互操作  169
8.2 Spring 5集成Kotlin  170
8.3 小结  172
第9章 Spring 5更多新特性  173
9.1 Resource接口  173
9.2 HTTP 2  174
9.2.1 HTTP的现状  174
9.2.2 HTTP 2的新特性  174
9.2.3 多路复用与长连接的区别  175
9.3 JUnit 5  176
9.3.1 JUnit 5简介  176
9.3.2 JUnit 5快速体验  176
9.3.3 JUnit 5常用注解  178
9.4 小结  179
第三篇 Spring系统集成篇
第10章 Spring集成Log4j2  181
10.1 Log4j2配置详解  181
10.2 Log4j2日志级别  184
10.3 Log4j2实战演练  185
10.4 小结  188
第11章 Spring集成Spring MVC  189
11.1 Spring MVC快速体验  189
11.1.1 web.xml配置  189
11.1.2 创建Spring MVC的配置 文件  190
11.1.3 创建Spring MVC的视图 文件  190
11.1.4 创建控制器  191
11.1.5 测试运行  191
11.2 Spring MVC视图呈现  192
11.2.1 FreeMarker视图的实现  192
11.2.2 XML视图的实现  193
11.2.3 JSON视图的实现  195
11.3 Spring MVC拦截器  196
11.4 Spring MVC代码解析  198
11.5 小结  225
第12章 Spring集成MyBatis  226
12.1 Spring、Spring MVC和MyBatis集成 快速体验  226
12.2 MyBatis代码解析  236
12.3 小结  243
第13章 Spring事务管理  244
13.1 事务的特性  244
13.2 事务的隔离级别  244
13.2.1 READ_UNCOMMITTED  245
13.2.2 READ_COMMITTED  245
13.2.3 REPEATABLE_READ  246
13.2.4 SERIALIZABLE  246
13.3 JDBC方式使用事务  247
13.4 Spring事务管理快速体验  248
13.5 Spring事务隔离级别  254
13.6 Spring事务传播行为  255
13.7 Spring事务代码分析  255
13.8 小结  263
第14章 Spring集成Redis  264
14.1 Redis单节点安装  264
14.2 Redis支持的数据类型  266
14.2.1 Redis String类型的使用 方式  266
14.2.2 Redis Hash类型的使用 方式  271
14.2.3 Redis List类型的使用 方式  274
14.2.4 Redis Set类型的使用 方式  277
14.2.5 Redis SortedSet类型的使用 方式  280
14.3 Redis持久化策略  284
14.3.1 Redis RDB持久化  284
14.3.2 Redis AOF持久化  285
14.4 Redis主从复制模式  287
14.4.1 Redis一主一从拓扑结构  289
14.4.2 Redis一主多从拓扑结构  289
14.4.3 Redis树形拓扑结构  290
14.4.4 Redis主从架构的缺点  291
14.5 Redis哨兵模式  291
14.5.1 Redis哨兵模式简介  291
14.5.2 Redis哨兵定时监控任务  292
14.5.3 主观下线和客观下线  294
14.5.4 Redis哨兵选举领导者  295
14.5.5 故障转移  295
14.5.6 Redis哨兵模式安装部署  296
14.6 Redis集群模式  302
14.6.1 Redis集群模式数据共享  303
14.6.2 Redis集群中的主从复制  303
14.6.3 Redis集群中的一致性 问题  303
14.6.4 Redis集群架构  304
14.6.5 Redis集群容错  304
14.6.6 Redis集群环境搭建  305
14.7 Spring、MyBatis和Redis集成快速 体验  313
14.8 Redis缓存穿透和雪崩  323
14.8.1 Redis缓存穿透  323
14.8.2 Redis缓存雪崩  326
14.9 小结  329
第15章 Spring集成ZooKeeper  330
15.1 ZooKeeper集群安装  330
15.2 ZooKeeper总体架构  336
15.2.1 ZooKeeper选举机制  336
15.2.2 ZooKeeper数据模型  338
15.3 Spring集成ZooKeeper快速体验  342
15.4 ZooKeeper发布订阅  346
15.4.1 NodeCache  346
15.4.2 PathChildrenCache  349
15.4.3 TreeCache  352
15.5 ZooKeeper分布式锁  356
15.6 小结  361
第16章 Spring集成Kafka  362
16.1 Kafka集群安装  362
16.2 Kafka总体架构  365
16.3 Spring集成Kafka快速体验  374
16.4 小结  377
第17章 Spring集成Mycat  379
17.1 Mycat分库分表  379
17.2 Mycat分库分表实战  381
17.3 Spring MyBatis Mycat快速体验  386
17.4 小结  397
第18章 Spring集成Sharding-JDBC  398
18.1 Spring集成Sharding-JDBC快速 体验  398
18.2 Sharding-JDBC强制路由  407
18.3 Sharding-JDBC分布式主键  408
18.4 小结  413
第19章 Spring集成Dubbo  414
19.1 远程过程调用协议  414
19.2 Spring集成Dubbo快速体验  415
19.3 Dubbo代码分析  419
19.4 小结  452
附录A 设计模式  453
A.1 工厂模式  453
A.2 抽象工厂模式  456
A.3 单例模式  462
A.4 建造者模式  463
A.5 原型模式  468
A.6 适配器模式  472
A.7 桥接模式  476
A.8 标准模式  477
A.9 组合模式  481
A.10 装饰器模式  483
A.11 外观模式  486
A.12 享元模式  489
A.13 代理模式  491
A.14 责任链模式  493
A.15 命令模式  496
A.16 解释器模式  499
A.17 迭代器模式  502
A.18 中介者模式  504
A.19 备忘录模式  506
A.20 观察者模式  509
A.21 状态 模 式  511
A.22 空对象模式  513
A.23 策略模式  516
A.24 模板模式  519
A.25 拦截过滤器模式  522
参考文献  365
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring 5企业级开发实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
第一章 明天的寓言
第二章 忍耐的义务
第三章 死神的灵药
第四章 地表水和地下海
第五章 土壤王国
第六章 地球的绿色斗篷
第七章 无妄之灾
第八章 再无鸟儿的歌声
第九章 死亡之河
第十章 祸从天降
第十一章 超乎博尔吉亚家族的想象
第十二章 人类的代价
第十三章 透过小窗
第十四章 四分之一的概率
第十五章 自然的反击
第十六章 雪崩的轰隆声
第十七章 另一条路
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>寂静的春天
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud Alibaba 微服务原理与实战
第1章　微服务的发展史	1
1.1　从单体架构到分布式架构的演进	2
1.1.1　单体架构	2
1.1.2　集群及垂直化	3
1.1.3　SOA	4
1.1.4　微服务架构	5
1.2　微服务架构带来的挑战	7
1.2.1　微服务架构的优点	7
1.2.2　微服务架构面临的挑战	7
1.3　如何实现微服务架构	8
1.3.1　微服务架构图	8
1.3.2　微服务架构下的技术挑战	9
第2章　微服务解决方案之Spring Cloud	10
2.1　什么是Spring Cloud	11
2.2　Spring Cloud版本简介	12
2.3　Spring Cloud规范下的实现	13
2.4　Spring Cloud Netflix	14
2.5　Spring Cloud Alibaba	15
2.5.1　Spring Cloud Alibaba的优势	15
2.5.2　Spring Cloud Alibaba的版本	16
第3章　Spring Cloud的核心之Spring Boot	18
3.1　重新认识Spring Boot	18
3.1.1　Spring IoC/DI	19
3.1.2　Bean装配方式的升级	21
3.1.3　Spring Boot的价值	23
3.2　快速构建Spring Boot应用	25
3.3　Spring Boot自动装配的原理	26
3.3.1　自动装配的实现	27
3.3.2　EnableAutoConfiguration	28
3.3.3　AutoConfigurationImportSelector	29
3.3.4　自动装配原理分析	31
3.3.5　@Conditional条件装配	34
3.3.6　spring-autoconfigure-metadata	37
3.4　手写实现一个Starter	38
3.4.1　Starter的命名规范	38
3.4.2　实现基于Redis的Starter	38
3.5　本章小结	41
第4章　微服务架构下的服务治理	42
4.1　如何理解Apache Dubbo	43
4.2　Apache Dubbo实现远程通信	44
4.3　Spring Boot集成Apache Dubbo	48
4.4　快速上手ZooKeeper	52
4.4.1　ZooKeeper的安装	52
4.4.2　ZooKeeper的数据结构	52
4.4.3　ZooKeeper的特性	53
4.4.4　Watcher机制	54
4.4.5　常见应用场景分析	54
4.5　Apache Dubbo集成ZooKeeper实现服务注册	56
4.5.1　Apache Dubbo集成ZooKeeper实现服务注册的步骤	57
4.5.2　ZooKeeper注册中心的实现原理	59
4.6　实战Dubbo Spring Cloud	60
4.6.1　实现Dubbo服务提供方	60
4.6.2　实现Dubbo服务调用方	63
4.7　Apache Dubbo的高级应用	65
4.7.1　集群容错	66
4.7.2　负载均衡	67
4.7.3　服务降级	68
4.7.4　主机绑定规则	69
4.8　Apache Dubbo核心源码分析	70
4.8.1　源码构建	71
4.8.2　Dubbo的核心之SPI	71
4.8.3　无处不在的自适应扩展点	81
4.8.4　Dubbo中的IoC和AOP	85
4.8.5　Dubbo和Spring完美集成的原理	89
4.9　本章小结	95
第5章　服务注册与发现	97
5.1　什么是Alibaba Nacos	98
5.2　Nacos的基本使用	99
5.2.1　Nacos的安装	99
5.2.2　Nacos服务注册发现相关API说明	100
5.2.3　Nacos集成Spring Boot实现服务注册与发现	101
5.3　Nacos的高可用部署	103
5.3.1　安装环境要求	104
5.3.2　安装包及环境准备	104
5.3.3　集群配置	104
5.3.4　配置MySQL数据库	105
5.3.5　启动Nacos服务	105
5.4　Dubbo使用Nacos实现注册中心	106
5.5　Spring Cloud Alibaba Nacos Discovery	109
5.5.1　服务端开发	109
5.5.2　消费端开发	113
5.6　Nacos实现原理分析	115
5.6.1　Nacos架构图	116
5.6.2　注册中心的原理	116
5.7　深入解读Nacos源码	117
5.7.1　Spring Cloud什么时候完成服务注册	117
5.7.2　NacosServiceRegistry的实现	122
5.7.3　从源码层面分析Nacos服务注册的原理	123
5.7.4　揭秘服务提供者地址查询	127
5.7.5　分析Nacos服务地址动态感知原理	130
5.8　本章小结	132
第6章　Nacos实现统一配置管理	133
6.1　Nacos配置中心简介	134
6.2　Nacos集成Spring Boot实现统一配置管理	134
6.2.1　项目准备	134
6.2.2　启动Nacos Server	135
6.2.3　创建配置	135
6.2.4　启动服务并测试	137
6.3　Spring Cloud Alibaba Nacos Config	137
6.3.1　Nacos Config的基本应用	137
6.3.2　动态更新配置	139
6.3.3　基于Data ID配置YAML的文件扩展名	140
6.3.4　不同环境的配置切换	141
6.3.5　Nacos Config自定义Namespace和Group	142
6.4　Nacos Config 实现原理解析	145
6.4.1　配置的CRUD	145
6.4.2　动态监听之Pull Or Push	146
6.5　Spring Cloud如何实现配置的加载	148
6.5.1　PropertySourceBootstrapConfiguration	148
6.5.2　PropertySourceLocator	150
6.6　Nacos Config核心源码解析	152
6.6.1　NacosFactory.createConfigService	154
6.6.2　NacosConfigService构造	155
6.6.3　ClientWorker	155
6.6.4　ClientWorker.checkConfigInfo	157
6.6.5　LongPollingRunnable.run	157
6.6.6　服务端长轮询处理机制	161
6.6.7　ClientLongPolling	164
6.7　本章小结	167
第7章　基于Sentinel的微服务限流及熔断	168
7.1　服务限流的作用及实现	168
7.1.1　计数器算法	169
7.1.2　滑动窗口算法	170
7.1.3　令牌桶限流算法	171
7.1.4　漏桶限流算法	172
7.2　服务熔断与降级	172
7.3　分布式限流框架Sentinel	174
7.3.1　Sentinel的特性	174
7.3.2　Sentinel的组成	175
7.3.3　Sentinel Dashboard的部署	175
7.4　Sentinel的基本应用	176
7.4.1　Sentinel实现限流	176
7.4.2　资源的定义方式	178
7.4.3　Sentinel资源保护规则	179
7.4.4　Sentinel实现服务熔断	183
7.5　Spring Cloud集成Sentinel实践	185
7.5.1　Sentinel接入Spring Cloud	185
7.5.2　基于Sentinel Dashboard来实现流控配置	187
7.5.3　自定义URL限流异常	189
7.5.4　URL资源清洗	189
7.6　Sentinel集成Nacos实现动态流控规则	190
7.7　Sentinel Dashboard集成Nacos实现规则同步	194
7.7.1　Sentinel Dashboard源码修改	194
7.7.2　Sentinel Dashboard规则数据同步	199
7.8　Dubbo集成Sentinel实现限流	200
7.8.1　Dubbo服务接入Sentinel Dashboard	200
7.8.2　Dubbo服务限流规则配置	201
7.9　Sentinel热点限流	203
7.9.1　热点参数限流的使用	204
7.9.2　@SentinelResource热点参数限流	205
7.9.3　热点参数规则说明	206
7.10　Sentinel的工作原理	206
7.11　Spring Cloud Sentinel工作原理分析	207
7.12　Sentinel核心源码分析	210
7.12.1　限流的源码实现	210
7.12.2　实时指标数据统计	216
7.12.3　服务降级的实现原理	225
7.13　本章小结	229
第8章　分布式事务	230
8.1　分布式事务问题的理论模型	231
8.1.1　X/Open分布式事务模型	231
8.1.2　两阶段提交协议	233
8.1.3　三阶段提交协议	234
8.1.4　CAP定理和BASE理论	236
8.2　分布式事务问题的常见解决方案	238
8.2.1　TCC补偿型方案	238
8.2.2　基于可靠性消息的最终一致性方案	239
8.2.3　最大努力通知型	242
8.3　分布式事务框架Seata	243
8.3.1　AT模式	243
8.3.2　Saga模式	244
8.4　Seata的安装	248
8.4.1　file存储模式	248
8.4.2　db存储模式	249
8.4.3　Seata服务端配置中心说明	251
8.5　AT模式Dubbo集成Seata	258
8.5.1　项目准备	259
8.5.2　数据库准备	259
8.5.3　核心方法说明	260
8.5.4　项目启动顺序及访问	264
8.5.5　整合Seata实现分布式事务	265
8.6　Spring Cloud Alibaba Seata	269
8.6.1　Spring Cloud项目准备	270
8.6.2　集成Spring Cloud Alibaba Seata	270
8.6.3　关于事务分组的说明	275
8.7　Seata AT模式的实现原理	276
8.7.1　AT模式第一阶段的实现原理	277
8.7.2　AT模式第二阶段的原理分析	279
8.7.3　关于事务的隔离性保证	280
8.8　本章小结	283
第9章　RocketMQ分布式消息通信	285
9.1　什么是RocketMQ	285
9.1.1　RocketMQ的应用场景	286
9.1.2　RocketMQ的安装	286
9.1.3　RocketMQ如何发送消息	287
9.1.4　RocketMQ如何消费消息	289
9.2　Spring Cloud Alibaba RocketMQ	291
9.2.1　Spring Cloud Alibaba RocketMQ架构图	293
9.2.2　Spring Cloud Stream消息发送流程	294
9.2.3　RocketMQ Binder集成消息发送	299
9.2.4　RocketMQ Binder集成消息订阅	303
9.2.5　Spring Cloud Stream消息订阅流程	308
9.3　RocketMQ集群管理	314
9.3.1　整体架构设计	314
9.3.2　基本概念	315
9.3.3　为什么放弃ZooKeeper而选择NameServer	316
9.4　如何实现顺序消息	318
9.4.1　顺序消息的使用场景	318
9.4.2　如何发送和消费顺序消息	319
9.4.3　顺序发送的技术原理	321
9.4.4　普通发送的技术原理	322
9.4.5　顺序消费的技术原理	324
9.4.6　并发消费的技术原理	325
9.4.7　消息的幂等性	325
9.5　如何实现事务消息	326
9.5.1　事务消息的使用场景	326
9.5.2　如何发送事务消息	327
9.5.3　事务消息的技术原理	330
9.6　高性能设计	331
9.6.1　顺序写盘	333
9.6.2　消费队列设计	334
9.6.3　消息跳跃读取	336
9.6.4　数据零拷贝	336
9.6.5　动态伸缩能力	336
9.6.6　消息实时投递	337
9.7　高可用设计	338
9.7.1　消息发送重试机制	339
9.7.2　故障规避机制	340
9.7.3　同步刷盘与异步刷盘	343
9.7.4　主从复制	350
9.7.5　读写分离	351
9.7.6　消费重试机制	351
9.7.7　ACK机制	352
9.7.8　Broker集群部署	352
9.8　本章小结	353
第10章　微服务网关之Spring Cloud Gateway	354
10.1　API网关的作用	355
10.1.1　统一认证鉴权	356
10.1.2　灰度发布	357
10.2　网关的本质及技术选型	358
10.2.1　OpenResty	358
10.2.2　Spring Cloud Zuul	360
10.2.3　Spring Cloud Gateway	361
10.3　Spring Cloud Gateway网关实战	361
10.3.1　spring-cloud-gateway-service	361
10.3.2　spring-cloud-gateway-sample	362
10.4　Spring Cloud Gateway原理分析	363
10.5　Route Predicate Factories	364
10.5.1　指定时间规则匹配路由	365
10.5.2　Cookie匹配路由	365
10.5.3　Header匹配路由	366
10.5.4　Host匹配路由	366
10.5.5　请求方法匹配路由	367
10.5.6　请求路径匹配路由	367
10.6　Gateway Filter Factories	367
10.6.1　GatewayFilter	368
10.6.2　GlobalFilter	372
10.7　自定义过滤器	375
10.7.1　自定义GatewayFilter	375
10.7.2　自定义GlobalFilter	377
10.8　Spring Cloud Gateway集成Nacos实现请求负载	378
10.9　Spring Cloud Gateway集成Sentinel网关限流	381
10.9.1　Route维度限流	382
10.9.2　自定义API分组限流	384
10.9.3　自定义异常	386
10.9.4　网关流控控制台	387
10.9.5　网关限流原理	388
10.10　本章小结	389
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud Alibaba 微服务原理与实战
